<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</title>
      <link href="/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>前面第一章节已经分析过mMediaPlayer.setDataSource()、mMediaPlayer.setDisplay()下来的分析尝试分析解答如下疑问：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong></p></blockquote><h4 id="（一）、多媒体文件解析-MediaExtractor分离音视频"><a href="#（一）、多媒体文件解析-MediaExtractor分离音视频" class="headerlink" title="（一）、多媒体文件解析 - MediaExtractor分离音视频"></a>（一）、多媒体文件解析 - MediaExtractor分离音视频</h4><p>接下来继续分析mMediaPlayer.prepareAsync()</p><h5 id="1-1、mMediaPlayer-prepareAsync"><a href="#1-1、mMediaPlayer-prepareAsync" class="headerlink" title="1.1、mMediaPlayer.prepareAsync()"></a>1.1、mMediaPlayer.prepareAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p>通过JNI调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">android_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(st);</span><br><span class="line"></span><br><span class="line">    process_media_player_call( env, thiz, mp-&gt;prepareAsync(), <span class="string">"java/io/IOException"</span>, <span class="string">"Prepare Async failed."</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置视频的 display surface（关于IGraphicBufferProducer相关知识请参考：Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]），</p><h5 id="1-1-1、MediaPlayer-setVideoSurfaceTexture"><a href="#1-1-1、MediaPlayer-setVideoSurfaceTexture" class="headerlink" title="1.1.1、MediaPlayer.setVideoSurfaceTexture()"></a>1.1.1、MediaPlayer.setVideoSurfaceTexture()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::setVideoSurfaceTexture(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setVideoSurfaceTexture"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mPlayer == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面setDataSource()分析过，此处会调用NuPlayer的setVideoSurfaceTexture()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处首先构造了一个AMessage消息，然后new Surface()，接下来看看消息处理过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,</span><br><span class="line">                                           FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                    <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                        mDeferredActions.push_back(</span><br><span class="line">                                <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line"></span><br><span class="line">            processDeferredActions();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::performSetSurface(<span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface) &#123;</span><br><span class="line">    ALOGV(<span class="string">"performSetSurface"</span>);</span><br><span class="line"></span><br><span class="line">    mSurface = surface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX - ignore error from setVideoScalingMode for now</span></span><br><span class="line">    setVideoScalingMode(mVideoScalingMode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            driver-&gt;notifySetSurfaceComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到将surface 赋值给NuPlayer的mSurface ，待视频解码后就可以在此surface 上渲染画面了，<br>这个稍后再作分析。</p><h5 id="1-1-2、MediaPlayer-prepareAsync"><a href="#1-1-2、MediaPlayer-prepareAsync" class="headerlink" title="1.1.2、MediaPlayer.prepareAsync()"></a>1.1.2、MediaPlayer.prepareAsync()</h5><p>然后接着调用MediaPlayer prepareAsync()函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"prepareAsync"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(<span class="string">"prepareAsync called in state %d, mPlayer(%p)"</span>, mCurrentState, mPlayer.get());</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处会调用NuPlayer的prepareAsync()函数，prepareAsync()发送了一个kWhatPrepare的AMessage，我们直接看看消息处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处又调用了GenericSource的prepareAsync()函数，发送了一个kWhatPrepareAsync消息。直接看看GenericSource如何处理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::prepareAsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLooper-&gt;setName(<span class="string">"generic"</span>);</span><br><span class="line">        mLooper-&gt;start();</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatPrepareAsync, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">      <span class="keyword">case</span> kWhatPrepareAsync:</span><br><span class="line">      &#123;</span><br><span class="line">          onPrepareAsync();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::onPrepareAsync() &#123;</span><br><span class="line">    <span class="comment">// delayed data source creation</span></span><br><span class="line">    <span class="keyword">if</span> (mDataSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// set to false first, if the extractor</span></span><br><span class="line">        <span class="comment">// comes back as secure, set it to true then.</span></span><br><span class="line">        mIsSecure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mUri.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* uri = mUri.c_str();</span><br><span class="line">            String8 contentType;</span><br><span class="line">            mIsWidevine = !strncasecmp(uri, <span class="string">"widevine://"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!strncasecmp(<span class="string">"http://"</span>, uri, <span class="number">7</span>)</span><br><span class="line">                    || !strncasecmp(<span class="string">"https://"</span>, uri, <span class="number">8</span>)</span><br><span class="line">                    || mIsWidevine) &#123;</span><br><span class="line">                mHttpSource = DataSource::CreateMediaHTTP(mHTTPService);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDataSource = DataSource::CreateFromURI(</span><br><span class="line">                   mHTTPService, uri, &amp;mUriHeaders, &amp;contentType,</span><br><span class="line">                   <span class="keyword">static_cast</span>&lt;HTTPBase *&gt;(mHttpSource.get()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mIsWidevine = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            mDataSource = <span class="keyword">new</span> FileSource(mFd, mOffset, mLength);</span><br><span class="line">            mFd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;flags() &amp; DataSource::kIsCachingDataSource) &#123;</span><br><span class="line">        mCachedSource = <span class="keyword">static_cast</span>&lt;NuCachedSource2 *&gt;(mDataSource.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsStreaming = (mIsWidevine || mCachedSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init extractor from data source</span></span><br><span class="line">    <span class="keyword">status_t</span> err = initFromDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack.mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = doGetFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage;</span><br><span class="line">        err = convertMetaDataToMessage(meta, &amp;msg);</span><br><span class="line">        ......</span><br><span class="line">        notifyVideoSizeChanged(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mIsSecure) &#123;</span><br><span class="line">        <span class="comment">// secure decoders must be instantiated before starting widevine source</span></span><br><span class="line">        sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatSecureDecodersInstantiated, <span class="keyword">this</span>);</span><br><span class="line">        notifyInstantiateSecureDecoders(reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishPrepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造了  mDataSource = new FileSource，然后调用了initFromDataSource()，这里面包含多媒体文件格式探测，。</p><h5 id="1-1-3、GenericSource-initFromDataSource"><a href="#1-1-3、GenericSource-initFromDataSource" class="headerlink" title="1.1.3、GenericSource.initFromDataSource()"></a>1.1.3、GenericSource.initFromDataSource()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::GenericSource::initFromDataSource() &#123;</span><br><span class="line">    sp&lt;IMediaExtractor&gt; extractor;</span><br><span class="line">    String8 mimeType;</span><br><span class="line">    <span class="keyword">float</span> confidence;</span><br><span class="line">    sp&lt;AMessage&gt; dummy;</span><br><span class="line">    <span class="keyword">bool</span> isWidevineStreaming = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CHECK(mDataSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWidevine) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsStreaming) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDataSource-&gt;sniff(&amp;mimeType, &amp;confidence, &amp;dummy)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        isWidevineStreaming = !strcasecmp(</span><br><span class="line">                mimeType.<span class="built_in">string</span>(), MEDIA_MIMETYPE_CONTAINER_WVM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWidevineStreaming) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extractor = MediaExtractor::Create(mDataSource,</span><br><span class="line">                mimeType.isEmpty() ? <span class="literal">NULL</span> : mimeType.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(mDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFileMeta = extractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (mFileMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> duration;</span><br><span class="line">        <span class="keyword">if</span> (mFileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> totalBitrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> numtracks = extractor-&gt;countTracks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numtracks; ++i) &#123;</span><br><span class="line">        sp&lt;IMediaSource&gt; track = extractor-&gt;getTrack(i);</span><br><span class="line">        </span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do the string compare immediately with "mime",</span></span><br><span class="line">        <span class="comment">// we can't assume "mime" would stay valid after another</span></span><br><span class="line">        <span class="comment">// extractor operation, some extractors might modify meta</span></span><br><span class="line">        <span class="comment">// during getTrack() and make it invalid.</span></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"audio/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAudioTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mAudioTrack.mIndex = i;</span><br><span class="line">                mAudioTrack.mSource = track;</span><br><span class="line">                mAudioTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mAudioTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mVideoTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mVideoTrack.mIndex = i;</span><br><span class="line">                mVideoTrack.mSource = track;</span><br><span class="line">                mVideoTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mVideoTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if the source requires secure buffers</span></span><br><span class="line">                <span class="keyword">int32_t</span> secure;</span><br><span class="line">                <span class="keyword">if</span> (meta-&gt;findInt32(kKeyRequiresSecureBuffers, &amp;secure)</span><br><span class="line">                        &amp;&amp; secure) &#123;</span><br><span class="line">                    mIsSecure = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">                        extractor-&gt;setUID(mUID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSources.push(track);</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="keyword">if</span> (meta-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> bitrate;</span><br><span class="line">        <span class="keyword">if</span> (totalBitrate &gt;= <span class="number">0</span> &amp;&amp; meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            totalBitrate += bitrate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalBitrate = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    mBitrate = totalBitrate;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过MediaExtractor::Create()得到MediaExtractor，然后将数据解析成track 赋值给mAudioTrack.mSource、mVideoTrack.mSource。</p><h5 id="1-1-4、MediaExtractor-Create"><a href="#1-1-4、MediaExtractor-Create" class="headerlink" title="1.1.4、MediaExtractor::Create()"></a>1.1.4、MediaExtractor::Create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaExtractor.cpp]</span><br><span class="line">sp&lt;IMediaExtractor&gt; MediaExtractor::Create(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> <span class="keyword">char</span> *mime) &#123;</span><br><span class="line">    ALOGV(<span class="string">"MediaExtractor::Create %s"</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"media.stagefright.extractremote"</span>, value, <span class="literal">NULL</span>)</span><br><span class="line">            &amp;&amp; (!<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) || !strcasecmp(<span class="string">"false"</span>, value))) &#123;</span><br><span class="line">        <span class="comment">// local extractor</span></span><br><span class="line">        ALOGW(<span class="string">"creating media extractor in calling process"</span>);</span><br><span class="line">        <span class="keyword">return</span> CreateFromService(source, mime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check if it's WVM, since WVMExtractor needs to be created in the media server process,</span></span><br><span class="line">        <span class="comment">// not the extractor process.</span></span><br><span class="line">        String8 mime8;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        sp&lt;AMessage&gt; meta;</span><br><span class="line">        <span class="keyword">if</span> (SniffWVM(source, &amp;mime8, &amp;confidence, &amp;meta) &amp;&amp;</span><br><span class="line">                !strcasecmp(mime8, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WVMExtractor(source);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SniffDRM(source, &amp;mime8, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *drmMime = mime8.<span class="built_in">string</span>();</span><br><span class="line">            ALOGV(<span class="string">"Detected media content as '%s' with confidence %.2f"</span>, drmMime, confidence);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drmMime, <span class="string">"drm+es_based+"</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">                <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DRMExtractor(source, drmMime + <span class="number">14</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remote extractor</span></span><br><span class="line">        ALOGV(<span class="string">"get service manager"</span>);</span><br><span class="line">        sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(<span class="string">"media.extractor"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;IMediaExtractorService&gt; mediaExService(interface_cast&lt;IMediaExtractorService&gt;(binder));</span><br><span class="line">            sp&lt;IMediaExtractor&gt; ex = mediaExService-&gt;makeExtractor(RemoteDataSource::wrap(source), mime);</span><br><span class="line">            <span class="keyword">return</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过Binder通信获取”media.extractor”服务得到一个Extractor。</p><h5 id="1-1-5、IMediaExtractor-gt-getTrack"><a href="#1-1-5、IMediaExtractor-gt-getTrack" class="headerlink" title="1.1.5、IMediaExtractor-&gt;getTrack()"></a>1.1.5、IMediaExtractor-&gt;getTrack()</h5><p>根据不同类别解析出不同的Track</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\]</span><br><span class="line"></span><br><span class="line">AACExtractor.cpp sp&lt;IMediaSource&gt; AACExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">AMRExtractor.cpp sp&lt;IMediaSource&gt; AMRExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MP3Extractor.cpp sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">NuMediaExtractor.cpp sp&lt;IMediaSource&gt; source = mImpl-&gt;getTrack(index)</span><br><span class="line">WAVExtractor.cpp sp&lt;IMediaSource&gt; WAVExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">FLACExtractor.cpp sp&lt;IMediaSource&gt; FLACExtractor::getTrack(<span class="keyword">size_t</span> index) </span><br><span class="line">StagefrightMetadataRetriever.cpp sp&lt;IMediaSource&gt; source = mExtractor-&gt;getTrack(i)</span><br><span class="line">AVIExtractor.cpp sp&lt;MediaSource&gt; AVIExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">OggExtractor.cpp sp&lt;IMediaSource&gt; OggExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MPEG4Extractor.cpp sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3</span></span><br><span class="line">sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MP3Source(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MPEG4</span></span><br><span class="line">sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    ......</span><br><span class="line">    Track *track = mFirstTrack;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track = track-&gt;next;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trex *trex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> trackId;</span><br><span class="line">    <span class="keyword">if</span> (track-&gt;meta-&gt;findInt32(kKeyTrackID, &amp;trackId)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mTrex.size(); i++) &#123;</span><br><span class="line">            Trex *t = &amp;mTrex.editItemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;track_ID == (<span class="keyword">uint32_t</span>) trackId) &#123;</span><br><span class="line">                trex = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyAVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyHVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPEG4Source(<span class="keyword">this</span>,</span><br><span class="line">            track-&gt;meta, mDataSource, track-&gt;timescale, track-&gt;sampleTable,</span><br><span class="line">            mSidxEntries, trex, mMoofOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到不同格式的 MP3Extractor、MPEG4Source ……</p><p>还记的前面提出的第一点疑问吗，现在我们知道了如何分离音视频了并且得到了相应的文件Source了。<br>图示（红线部分）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-01-source-demux-decoder-output-MediaExtractor.jpg" alt="Alt text"></p><h4 id="（二）、多媒体文件-音视频解码（Decoder）"><a href="#（二）、多媒体文件-音视频解码（Decoder）" class="headerlink" title="（二）、多媒体文件 - 音视频解码（Decoder）"></a>（二）、多媒体文件 - 音视频解码（Decoder）</h4><p>音频解码、视频解码在何处，答案就在mMediaPlayer.start()流程当中，先看看start()总体时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-02-NuPlayer-Start-instantiateDecoder.png" alt="Alt text"></p><p>由于从Java层到JNI前面已多次分析，这里直接从NuPlayer::start()开始分析</p><h5 id="2-1、NuPlayer-start"><a href="#2-1、NuPlayer-start" class="headerlink" title="2.1、NuPlayer::start()"></a>2.1、NuPlayer::start()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            ALOGV(<span class="string">"kWhatStart"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">                <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startPositionUs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        performSeek(startPositionUs);</span><br><span class="line">        <span class="keyword">if</span> (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = <span class="literal">false</span>;</span><br><span class="line">    mAudioEOS = <span class="literal">false</span>;</span><br><span class="line">    mVideoEOS = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSource-&gt;isRealTime()) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_REAL_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; audioMeta = mSource-&gt;getFormatMeta(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    sp&lt;MetaData&gt; videoMeta = mSource-&gt;getFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    ......</span><br><span class="line">    ALOGV_IF(audioMeta == <span class="literal">NULL</span>, <span class="string">"no metadata for audio source"</span>);  <span class="comment">// video only stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">audio_stream_type_t</span> streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; videoFormat = mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line"></span><br><span class="line">    mOffloadAudio =</span><br><span class="line">        canOffloadStream(audioMeta, (videoFormat != <span class="literal">NULL</span>), mSource-&gt;isStreaming(), streamType)</span><br><span class="line">                &amp;&amp; (mPlaybackSettings.mSpeed == <span class="number">1.f</span> &amp;&amp; mPlaybackSettings.mPitch == <span class="number">1.f</span>);</span><br><span class="line">    <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_OFFLOAD_AUDIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration;</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了名为NuPlayerRenderer的Renderer对象，然后启动循环，看看初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">NuPlayer::Renderer::Renderer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    : mAudioSink(sink),</span><br><span class="line">      mUseVirtualAudioSink(<span class="literal">false</span>),</span><br><span class="line">      mNotify(notify),</span><br><span class="line">      mFlags(flags),</span><br><span class="line">      mNumFramesWritten(<span class="number">0</span>),</span><br><span class="line">      mDrainAudioQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mDrainVideoQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mAudioQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioEOSGeneration(<span class="number">0</span>),</span><br><span class="line">      mPlaybackSettings(AUDIO_PLAYBACK_RATE_DEFAULT),</span><br><span class="line">      ......</span><br><span class="line">      mWakeLock(<span class="keyword">new</span> AWakeLock()) &#123;</span><br><span class="line">    mMediaClock = <span class="keyword">new</span> MediaClock;</span><br><span class="line">    mPlaybackRate = mPlaybackSettings.mSpeed;</span><br><span class="line">    mMediaClock-&gt;setPlaybackRate(mPlaybackRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、postScanSources"><a href="#2-2、postScanSources" class="headerlink" title="2.2、postScanSources()"></a>2.2、postScanSources()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::postScanSources() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatScanSources, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"generation"</span>, mScanSourcesGeneration);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> generation;</span><br><span class="line">            mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> mHadAnySourcesBefore =</span><br><span class="line">                (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">            <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">            <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此处调用了instantiateDecoder()来初始化音视频解码器Decoder</p><h5 id="2-3、instantiateDecoder"><a href="#2-3、instantiateDecoder" class="headerlink" title="2.3、instantiateDecoder()"></a>2.3、instantiateDecoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::instantiateDecoder(</span><br><span class="line">        <span class="keyword">bool</span> audio, sp&lt;DecoderBase&gt; *decoder, <span class="keyword">bool</span> checkAudioModeChange) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;getFormat(audio);</span><br><span class="line"></span><br><span class="line">    format-&gt;setInt32(<span class="string">"priority"</span>, <span class="number">0</span> <span class="comment">/* realtime */</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatAudioNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mAudioDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkAudioModeChange) &#123;</span><br><span class="line">            determineAudioModeChange(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">true</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> hasVideo = (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/*audio */</span>) != <span class="literal">NULL</span>);</span><br><span class="line">            format-&gt;setInt32(<span class="string">"has-video"</span>, hasVideo);</span><br><span class="line">            *decoder = <span class="keyword">new</span> DecoderPassThrough(notify, mSource, mRenderer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">false</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            *decoder = <span class="keyword">new</span> Decoder(notify, mSource, mPID, mRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatVideoNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mVideoDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        *decoder = <span class="keyword">new</span> Decoder(</span><br><span class="line">                notify, mSource, mPID, mRenderer, mSurface, mCCDecoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enable FRC if high-quality AV sync is requested, even if not</span></span><br><span class="line">        <span class="comment">// directly queuing to display, as this will even improve textureview</span></span><br><span class="line">        <span class="comment">// playback.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">            <span class="keyword">if</span> (property_get(<span class="string">"persist.sys.media.avsync"</span>, value, <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (!<span class="built_in">strcmp</span>(<span class="string">"1"</span>, value) || !strcasecmp(<span class="string">"true"</span>, value))) &#123;</span><br><span class="line">                format-&gt;setInt32(<span class="string">"auto-frc"</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*decoder)-&gt;init();</span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-1、创建音视频解码器new-Decoder"><a href="#2-3-1、创建音视频解码器new-Decoder" class="headerlink" title="2.3.1、创建音视频解码器new Decoder()"></a>2.3.1、创建音视频解码器new Decoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line">NuPlayer::Decoder::Decoder(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Source&gt; &amp;source,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Renderer&gt; &amp;renderer,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CCDecoder&gt; &amp;ccDecoder)</span><br><span class="line">    : DecoderBase(notify),</span><br><span class="line">      mSurface(surface),</span><br><span class="line">      mSource(source),</span><br><span class="line">      mRenderer(renderer),</span><br><span class="line">      mCCDecoder(ccDecoder),</span><br><span class="line">      ......</span><br><span class="line">      mVideoWidth(<span class="number">0</span>),</span><br><span class="line">      mVideoHeight(<span class="number">0</span>),</span><br><span class="line">      mIsAudio(<span class="literal">true</span>),</span><br><span class="line">      ......</span><br><span class="line">      mComponentName(<span class="string">"decoder"</span>) &#123;</span><br><span class="line">    mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mCodecLooper-&gt;setName(<span class="string">"NPDecoder-CL"</span>);</span><br><span class="line">    mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mVideoTemporalLayerAggregateFps[<span class="number">0</span>] = mFrameRateTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建音视频解码器（NuPlayer::Decoder），为其创建名为NPDecoder-CL的mCodecLooper 【其父类NuPlayer::DecoderBase的构造中则会创建NPDecoder】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line">NuPlayer::DecoderBase::DecoderBase(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify)</span><br><span class="line">    :  mNotify(notify),</span><br><span class="line">       mBufferGeneration(<span class="number">0</span>),</span><br><span class="line">       mPaused(<span class="literal">false</span>),</span><br><span class="line">       mStats(<span class="keyword">new</span> AMessage),</span><br><span class="line">       mRequestInputBuffersPending(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Every decoder has its own looper because MediaCodec operations</span></span><br><span class="line">    <span class="comment">// are blocking, but NuPlayer needs asynchronous operations.</span></span><br><span class="line">    mDecoderLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mDecoderLooper-&gt;setName(<span class="string">"NPDecoder"</span>);</span><br><span class="line">    mDecoderLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2、初始化Decoder-gt-init"><a href="#2-3-2、初始化Decoder-gt-init" class="headerlink" title="2.3.2、初始化Decoder-&gt;init()"></a>2.3.2、初始化Decoder-&gt;init()</h5><p>对该解码器进行init()操作，调用NuPlayer::DecoderBase::init()为mDecoderLooper注册handler【init()和configure()都是NuPlayerDecoder继承自NuPlayer::DecoderBase的方法】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::configure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"format"</span>, format);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::init() &#123;</span><br><span class="line">    mDecoderLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            CHECK(msg-&gt;findMessage(<span class="string">"format"</span>, &amp;format));</span><br><span class="line">            onConfigure(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对该解码器进行configure(format)操作，调用NuPlayer::DecoderBase::configure(…)产生一个kWhatConfigure消息，然后消息处理中调用NuPlayer::Decoder::onConfigure(…)</p><h5 id="2-3-3、配置Decoder-gt-configure"><a href="#2-3-3、配置Decoder-gt-configure" class="headerlink" title="2.3.3、配置Decoder-&gt;configure()"></a>2.3.3、配置Decoder-&gt;configure()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onConfigure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">  </span><br><span class="line">    mFormatChangePending = <span class="literal">false</span>;</span><br><span class="line">    mTimeChangePending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++mBufferGeneration;</span><br><span class="line"></span><br><span class="line">    AString mime;</span><br><span class="line"></span><br><span class="line">    mIsAudio = !strncasecmp(<span class="string">"audio/"</span>, mime.c_str(), <span class="number">6</span>);</span><br><span class="line">    mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());</span><br><span class="line"></span><br><span class="line">    mComponentName = mime;</span><br><span class="line">    mComponentName.append(<span class="string">" decoder"</span>);</span><br><span class="line">    ALOGV(<span class="string">"[%s] onConfigure (surface=%p)"</span>, mComponentName.c_str(), mSurface.get());</span><br><span class="line"></span><br><span class="line">    mCodec = MediaCodec::CreateByType(</span><br><span class="line">            mCodecLooper, mime.c_str(), <span class="literal">false</span> <span class="comment">/* encoder */</span>, <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="keyword">int32_t</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (format-&gt;findInt32(<span class="string">"secure"</span>, &amp;secure) &amp;&amp; secure != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line">            mComponentName.append(<span class="string">".secure"</span>);</span><br><span class="line">            mCodec-&gt;release();</span><br><span class="line">            ALOGI(<span class="string">"[%s] creating"</span>, mComponentName.c_str());</span><br><span class="line">            mCodec = MediaCodec::CreateByComponentName(</span><br><span class="line">                    mCodecLooper, mComponentName.c_str(), <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mIsSecure = secure;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// disconnect from surface as MediaCodec will reconnect</span></span><br><span class="line">        err = native_window_api_disconnect(</span><br><span class="line">                mSurface.get(), NATIVE_WINDOW_API_MEDIA);</span><br><span class="line">        <span class="comment">// We treat this as a warning, as this is a preparatory step.</span></span><br><span class="line">        <span class="comment">// Codec will try to connect to the surface, which is where</span></span><br><span class="line">        <span class="comment">// any error signaling will occur.</span></span><br><span class="line">        ALOGW_IF(err != OK, <span class="string">"failed to disconnect from surface: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    err = mCodec-&gt;configure(</span><br><span class="line">            format, mSurface, <span class="literal">NULL</span> <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    ......</span><br><span class="line">    rememberCodecSpecificData(format);</span><br><span class="line">    mStats-&gt;setString(<span class="string">"mime"</span>, mime.c_str());</span><br><span class="line">    mStats-&gt;setString(<span class="string">"component-name"</span>, mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;findInt32(<span class="string">"width"</span>, &amp;width)</span><br><span class="line">                &amp;&amp; mOutputFormat-&gt;findInt32(<span class="string">"height"</span>, &amp;height)) &#123;</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"width"</span>, width);</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"height"</span>, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>);</span><br><span class="line">    mCodec-&gt;setCallback(reply);</span><br><span class="line"></span><br><span class="line">    err = mCodec-&gt;start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    releaseAndResetMediaBuffers();</span><br><span class="line"></span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    mResumePending = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onConfigure中，首先会调用MediaCodec::CreateByType(…)或者MediaCodec::CreateByComponentName(…)根据情况创建MediaCodec，接着调用MediaCodec::init(…)，随后调用MediaCodec::configure(…)对MediaCodec进行配置使其转入Configured状态;然后又调用MediaCodec::start()使MediaCodec转入Executing状态。</p><h5 id="2-3-4、MediaCodec-init-…"><a href="#2-3-4、MediaCodec-init-…" class="headerlink" title="2.3.4、MediaCodec::init(…)"></a>2.3.4、MediaCodec::init(…)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByComponentName(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;name, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(name, <span class="literal">false</span> <span class="comment">/* nameIsType */</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *err = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::init(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType, <span class="keyword">bool</span> encoder) &#123;</span><br><span class="line">    mResourceManagerService-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save init parameters for reset</span></span><br><span class="line">    mInitName = name;</span><br><span class="line">    mInitNameIsType = nameIsType;</span><br><span class="line">    mInitIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current video decoders do not return from OMX_FillThisBuffer</span></span><br><span class="line">    <span class="comment">// quickly, violating the OpenMAX specs, until that is remedied</span></span><br><span class="line">    <span class="comment">// we need to invest in an extra looper to free the main event</span></span><br><span class="line">    <span class="comment">// queue.</span></span><br><span class="line"></span><br><span class="line">    mCodec = GetCodecBase(name, nameIsType);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> secureCodec = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType &amp;&amp; !strncasecmp(name.c_str(), <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        mIsVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AString tmp = name;</span><br><span class="line">        <span class="keyword">if</span> (tmp.endsWith(<span class="string">".secure"</span>)) &#123;</span><br><span class="line">            secureCodec = <span class="literal">true</span>;</span><br><span class="line">            tmp.erase(tmp.size() - <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">ssize_t</span> codecIdx = mcl-&gt;findCodecByName(tmp.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codecIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = mcl-&gt;getCodecInfo(codecIdx);</span><br><span class="line">            Vector&lt;AString&gt; mimes;</span><br><span class="line">            info-&gt;getSupportedMimes(&amp;mimes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mimes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mimes[i].startsWith(<span class="string">"video/"</span>)) &#123;</span><br><span class="line">                    mIsVideo = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        <span class="comment">// video codec needs dedicated looper</span></span><br><span class="line">        <span class="keyword">if</span> (mCodecLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">            mCodecLooper-&gt;setName(<span class="string">"CodecLooper"</span>);</span><br><span class="line">            mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;setNotificationMessage(<span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatInit, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">"name"</span>, name);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"nameIsType"</span>, nameIsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"encoder"</span>, encoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    MediaResource::Type type =</span><br><span class="line">            secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec;</span><br><span class="line">    MediaResource::SubType subtype =</span><br><span class="line">            mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec;</span><br><span class="line">    resources.push_back(MediaResource(type, subtype, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-1、GetCodecBase"><a href="#2-3-4-1、GetCodecBase" class="headerlink" title="2.3.4.1、GetCodecBase"></a>2.3.4.1、GetCodecBase</h5><p>当编解码以”omx.”开头则创建ACodec对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;CodecBase&gt; MediaCodec::GetCodecBase(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType) &#123;</span><br><span class="line">    <span class="comment">// at this time only ACodec specifies a mime type.</span></span><br><span class="line">    <span class="keyword">if</span> (nameIsType || name.startsWithIgnoreCase(<span class="string">"omx."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWithIgnoreCase(<span class="string">"android.filter."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MediaFilter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-3-4-2、MediaCodecList-getInstance"><a href="#2-3-4-2、MediaCodecList-getInstance" class="headerlink" title="2.3.4.2、MediaCodecList::getInstance()"></a>2.3.4.2、MediaCodecList::getInstance()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getInstance() &#123;</span><br><span class="line">    Mutex::Autolock _l(sRemoteInitMutex);</span><br><span class="line">    <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; binder =</span><br><span class="line">            defaultServiceManager()-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">        sp&lt;IMediaPlayerService&gt; service =</span><br><span class="line">            interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">        <span class="keyword">if</span> (service.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sRemoteList = service-&gt;getCodecList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sRemoteList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Binder通信获取MediaCodec列表。getCodecList()函数实现在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::getCodecList() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MediaCodecList::getLocalInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getLocalInstance() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br><span class="line">MediaCodecList::MediaCodecList()</span><br><span class="line">    : mInitCheck(NO_INIT),</span><br><span class="line">      mUpdate(<span class="literal">false</span>),</span><br><span class="line">      mGlobalSettings(<span class="keyword">new</span> AMessage()) &#123;</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs.xml"</span>);</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs_performance.xml"</span>, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">    parseTopLevelXMLFile(kProfilingResults, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(∩_∩)O哈哈~，终于分析到Codecs加载的地方了。还记得第一章节分析的附录吗，高通的音视频硬解码，这里再贴一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line"></span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br></pre></td></tr></table></figure><h5 id="2-3-5、MediaCodec-gt-configure"><a href="#2-3-5、MediaCodec-gt-configure" class="headerlink" title="2.3.5、MediaCodec-&gt;configure()"></a>2.3.5、MediaCodec-&gt;configure()</h5><p>产生kWhatConfigure消息，在消息处理中调用ACodec::initiateConfigureComponent(…)又产生消息kWhatConfigureComponent，然后该消息处理中又调用了ACodec::LoadedState::onConfigureComponent(…)。然后在其中又会先调用ACodec::configureCodec(…)，在configureCodec中会对IOMX进行一系列的设置以及配置操作，通过Binder通信就对OMXNodeInstance进行相应的设置和配置操作，最终就对OMX组件进行了相应的设置和配置。然后向MediaCodec发送kWhatComponentConfigured消息，在消息处理中将MediaCodec状态设为CONFIGURED；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::configure(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ICrypto&gt; &amp;crypto,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format-&gt;setObject(<span class="string">"native-window"</span>, obj);</span><br><span class="line">                <span class="keyword">status_t</span> err = handleSetSurface(<span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleSetSurface(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mReplyID = replyID;</span><br><span class="line">            setState(CONFIGURING);</span><br><span class="line">            ......</span><br><span class="line">            extractCSD(format);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateConfigureComponent(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateConfigureComponent(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    msg-&gt;setWhat(kWhatConfigureComponent);</span><br><span class="line">    msg-&gt;setTarget(<span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">        &#123;</span><br><span class="line">            onConfigureComponent(msg);</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">bool</span> ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;findString(<span class="string">"mime"</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = mCodec-&gt;configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"input-format"</span>, mCodec-&gt;mInputFormat);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"output-format"</span>, mCodec-&gt;mOutputFormat);</span><br><span class="line">        notify-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-6、MediaCodec-gt-start"><a href="#2-3-6、MediaCodec-gt-start" class="headerlink" title="2.3.6、MediaCodec-&gt;start()"></a>2.3.6、MediaCodec-&gt;start()</h5><p>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::start() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            setState(STARTING);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateStart();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateStart() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;sendCommand(mCodec-&gt;mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCodec-&gt;changeState(mCodec-&gt;mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦缓冲区成功分配到输入和输出端口，OMX组件（编解码）会为Loaded-to-Idle状态生成OMX_EventCmdComplete事件转换并使用EventHandlerCallback将其发送给客户端。</p><h4 id="（三）、音视频解码数据处理"><a href="#（三）、音视频解码数据处理" class="headerlink" title="（三）、音视频解码数据处理"></a>（三）、音视频解码数据处理</h4><h5 id="3-1、音视频解码数据处理-emptyBuffer"><a href="#3-1、音视频解码数据处理-emptyBuffer" class="headerlink" title="3.1、音视频解码数据处理-emptyBuffer"></a>3.1、音视频解码数据处理-emptyBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-03-acodec-emptyBuffer.png" alt="Alt text"></p><p>1、    MediaCodec::start()之后ACodec是在LoadedToIdleState状态，此时若ACodec::LoadedToIdleState::onOMXEvent(…)接收到组件转换至Idle状态后的OMX_EventCmdComplete事件，会向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Executing状态（这里OMX会发送OMX_EventCmdComplete事件），然后ACodec进行changeState至IdleToExecutingState。<br>2、    此时ACodec::IdleToExecutingState::onOMXEvent(…)检测到上面的OMX_EventCmdComplete事件后，会首先调用函数ACodec::ExecutingState::resume()，然后对ACodec进行changeState至ExecutingState。</p><h5 id="3-1-1、ACodec-ExecutingState-resume"><a href="#3-1-1、ACodec-ExecutingState-resume" class="headerlink" title="3.1.1、ACodec::ExecutingState::resume()"></a>3.1.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)BufferInfo::OWNED_BY_US);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    info-&gt;mData-&gt;meta()-&gt;clear();</span><br><span class="line">    notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">    notify-&gt;post();</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数ACodec::ExecutingState::resume()中会调用ACodec::BaseState::postFillThisBuffer(…)，然后其中会先向MediaCodec发送kWhatFillThisBuffer消息，消息处理中在满足相应的条件下就会去调用函数MediaCodec::onInputBufferAvailable()来通知NuPlayer::Decoder有可用的inputbuffer；然后再生成kWhatInputBufferFilled消息，消息处理中调用ACodec::BaseState::onInputBufferFilled(…)。<br>【产生两个消息，一个向上(MediaCodec)处理，一个向下(OMX)处理】</p><h5 id="3-1-1-1、kWhatFillThisBuffer消息处理"><a href="#3-1-1-1、kWhatFillThisBuffer消息处理" class="headerlink" title="3.1.1.1、kWhatFillThisBuffer消息处理"></a>3.1.1.1、kWhatFillThisBuffer消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">                <span class="keyword">case</span> CodecBase::kWhatFillThisBuffer:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* size_t index = */</span>updateBuffers(kPortIndexInput, msg);</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mState == FLUSHED) &#123;</span><br><span class="line">                                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                onInputBufferAvailable();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">                        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">                        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">                        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        postActivityNotificationIfPossible();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 1：MediaCodec::onInputBufferAvailable()的调用：<br>其中会先调用函数MediaCodec::dequeuePortBuffer(…)获取buffer的索引，然后将一个新消息发送给NuPlayer::Decoder，并设置消息的callbackID为CB_INPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_INPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnInputBuffer(…)，其会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">case</span> MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"index"</span>, &amp;index));</span><br><span class="line"></span><br><span class="line">    handleAnInputBuffer(index);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnInputBuffer(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getInputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mInputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add();</span><br><span class="line">            mMediaBuffers.add();</span><br><span class="line">            mInputBufferIsDequeued.add();</span><br><span class="line">            mMediaBuffers.editItemAt(i) = <span class="literal">NULL</span>;</span><br><span class="line">            mInputBufferIsDequeued.editItemAt(i) = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaBuffers[index]-&gt;release();</span><br><span class="line">        mMediaBuffers.editItemAt(index) = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.editItemAt(index) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.isEmpty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(<span class="number">0</span>);</span><br><span class="line">        msg-&gt;setBuffer(<span class="string">"buffer"</span>, buffer);</span><br><span class="line">        mCSDsToSubmit.removeAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin();</span><br><span class="line">        <span class="keyword">if</span> (!onInputBufferFetched(msg)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.editItemAt(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push_back(index);</span><br><span class="line"></span><br><span class="line">    onRequestInputBuffers();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○1、先通过MediaCodec::getInputBuffer(…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer</p><p>○2、然后调用NuPlayer::Decoder::onInputBufferFetched(…)执行内存拷贝将buffer拷贝到编解码器，然后又调用了MediaCodec::queueInputBuffer(…)将buffer提交给解码器，其会产生消息kWhatQueueInputBuffer，消息处理中调用MediaCodec::onQueueInputBuffer(…)</p><p>○3、之后调用函数NuPlayer::DecoderBase::onRequestInputBuffers()，处理是否需要更多的数据。其中会调用NuPlayer::Decoder::doRequestBuffers，若返回true则需要更多的数据，则会产生新消息kWhatRequestInputBuffers，消息处理中又将调用onRequestInputBuffers。（实际获取更多缓冲的操作在下面ACodec部分完成）</p><h5 id="3-1-1-2、kWhatInputBufferFilled消息处理"><a href="#3-1-1-2、kWhatInputBufferFilled消息处理" class="headerlink" title="3.1.1.2、kWhatInputBufferFilled消息处理"></a>3.1.1.2、kWhatInputBufferFilled消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line">        <span class="keyword">case</span> kWhatInputBufferFilled:</span><br><span class="line">        &#123;</span><br><span class="line">            onInputBufferFilled(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onInputBufferFilled(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    <span class="keyword">int32_t</span> err = OK;</span><br><span class="line">    <span class="keyword">bool</span> eos = <span class="literal">false</span>;</span><br><span class="line">    PortMode mode = getPortMode(kPortIndexInput);</span><br><span class="line">    <span class="keyword">int32_t</span> tmp;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexInput, bufferID);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; !mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">                CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">                OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;</span><br><span class="line"></span><br><span class="line">                MetadataBufferType metaType = mCodec-&gt;mInputMetadataType;</span><br><span class="line">                <span class="keyword">int32_t</span> isCSD = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">"csd"</span>, &amp;isCSD) &amp;&amp; isCSD != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCodec-&gt;mIsLegacyVP9Decoder) &#123;</span><br><span class="line">                        postFillThisBuffer(info);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flags |= OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">                    metaType = kMetadataBufferTypeInvalid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">if</span> (buffer != info-&gt;mCodecData) &#123;</span><br><span class="line">                    sp&lt;DataConverter&gt; converter = mCodec-&gt;mConverter[kPortIndexInput];</span><br><span class="line">                    <span class="keyword">status_t</span> err = converter-&gt;convert(buffer, info-&gt;mCodecData);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">status_t</span> err2 = OK;</span><br><span class="line">                <span class="keyword">switch</span> (metaType) &#123;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeInvalid:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeNativeHandleSource:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeHandleMetadata)) &#123;</span><br><span class="line">                        VideoNativeHandleMetadata *vnhmd =</span><br><span class="line">                            (VideoNativeHandleMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateNativeHandleInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                NativeHandle::create(vnhmd-&gt;pHandle, <span class="literal">false</span> <span class="comment">/* ownsHandle */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeANWBuffer:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeMetadata)) &#123;</span><br><span class="line">                        VideoNativeMetadata *vnmd = (VideoNativeMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateGraphicBufferInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                <span class="keyword">new</span> GraphicBuffer(vnmd-&gt;pBuffer, <span class="literal">false</span> <span class="comment">/* keepOwnership */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    err2 = ERROR_UNSUPPORTED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err2 == OK) &#123;</span><br><span class="line">                    err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mCodecData-&gt;size(),</span><br><span class="line">                        flags,</span><br><span class="line">                        timeUs,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eos &amp;&amp; err == OK) &#123;</span><br><span class="line">                    getMoreInputDataIfPossible();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGV(<span class="string">"[%s] Signalled EOS (%d) on the input port"</span>,</span><br><span class="line">                         mCodec-&gt;mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line">                <span class="keyword">status_t</span> err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        OMX_BUFFERFLAG_EOS,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 2：ACodec::BaseState::onInputBufferFilled(…)的调用：<br>因为当前ACodec在ExecutingState，所以PortMode为RESUBMIT_BUFFERS，故会调用IOMX的emptyBuffer(…)方法，经过进程间通信调用到OMX::emptyBuffer(…)，并最终调用OMXNodeInstance::emptyBuffer(…)，其中又会调用到函数OMXNodeInstance::emptyBuffer_l(…)，其则会调用OMX_EmptyThisBuffer宏对OMX组件进行相关的操作（根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent</p><p>○1、其的构造函数的初始化列表中有mComponent-&gt;EmptyThisBuffer = EmptyThisBufferWrapper;故实际会调用其EmptyThisBufferWrapper(…)函数，而其中调用SoftOMXComponent的虚函数emptyThisBuffer。</p><p>○2、所以调用子类的emptyThisBuffer即SimpleSoftOMXComponent::emptyThisBuffer(…)产生kWhatEmptyThisBuffer消息，消息处理中实际的解码器就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyEmptyBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。</p><p>○4、调用到OMXNodeInstance::OnEmptyBufferDone(…)，其又会调用OMX::OnEmptyBufferDone(…)，然后在其中会发送omx_message::EMPTY_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState::onOMXEmptyBufferDone(…)</p><p>○5、在onOMXEmptyBufferDone中获取PortMode，为RESUBMIT_BUFFERS则ACodec::BaseState::postFillThisBuffer(…)被调用，从而又从3中的postFillThisBuffer开始循环执行相关操作以处理更多的输入缓冲。</p><h5 id="3-2、音视频解码数据处理-fillBuffer"><a href="#3-2、音视频解码数据处理-fillBuffer" class="headerlink" title="3.2、音视频解码数据处理-fillBuffer"></a>3.2、音视频解码数据处理-fillBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-04-acodec-fillBuffer.png" alt="Alt text"></p><h5 id="3-2-1、ACodec-ExecutingState-resume"><a href="#3-2-1、ACodec-ExecutingState-resume" class="headerlink" title="3.2.1、ACodec::ExecutingState::resume()"></a>3.2.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitOutputBuffers() &#123;</span><br><span class="line">    submitRegularOutputBuffers();</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        submitOutputMetaBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitRegularOutputBuffers() &#123;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexOutput].size(); ++i) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexOutput].editItemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;checkWriteFence(<span class="string">"submitRegularOutputBuffers"</span>);</span><br><span class="line">        <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、ACodec::ExecutingState::resume()函数，在resume()中调用ACodec::BaseState::postFillThisBuffer(…)前会先调用函数ACodec::ExecutingState::submitOutputBuffers()，即在获取输入数据前会先把输出端的数据提交出去。</p><p>2、在submitOutputBuffers()中调用ACodec::ExecutingState::submitRegularOutputBuffers()，其中又会调用到IOMX的fillBuffer (…)方法，经过进程间通信调用到OMX:: fillBuffer (…)，并最终调用OMXNodeInstance:: fillBuffer (…)，其中又会调用到OMX_FillThisBuffer宏对OMX组件进行相关的操作（同样根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent：（下面的操作与emptyBuffer时类似）</p><p>○1、在其构造函数的初始化列表中有mComponent-&gt;FillThisBuffer = FillThisBufferWrapper;所以实际会调用到其FillThisBufferWrapper (…)函数<br>○2、然后调用SimpleSoftOMXComponent::fillThisBuffer(…)产生kWhatFillThisBuffer消息，消息处理中实际的组件就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyFillBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。<br>○4之后调用到OMXNodeInstance:: OnFillBufferDone (…)函数，其又会调用OMX:: OnFillBufferDone (…)，然后在其中会发送omx_message:: FILL_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState:: onOMXFillBufferDone (…)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">bool</span> ACodec::BaseState::onOMXFillBufferDone(</span><br><span class="line">        IOMX::buffer_id bufferID,</span><br><span class="line">        <span class="keyword">size_t</span> rangeOffset, <span class="keyword">size_t</span> rangeLength,</span><br><span class="line">        OMX_U32 flags,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">    ALOGV(<span class="string">"[%s] onOMXFillBufferDone %u time %"</span> PRId64 <span class="string">" us, flags = 0x%08x"</span>,</span><br><span class="line">         mCodec-&gt;mComponentName.c_str(), bufferID, timeUs, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    <span class="keyword">status_t</span> err= OK;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACK_BUFFER_TIMING</span></span><br><span class="line">    index = mCodec-&gt;mBufferStats.indexOfKey(timeUs);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ACodec::BufferStats *stats = &amp;mCodec-&gt;mBufferStats.editValueAt(index);</span><br><span class="line">        stats-&gt;mFillBufferDoneTimeUs = ALooper::GetNowUs();</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"frame PTS %lld: %lld"</span>,</span><br><span class="line">                timeUs,</span><br><span class="line">                stats-&gt;mFillBufferDoneTimeUs - stats-&gt;mEmptyBufferTimeUs);</span><br><span class="line"></span><br><span class="line">        mCodec-&gt;mBufferStats.removeItemsAt(index);</span><br><span class="line">        stats = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    BufferInfo *info =</span><br><span class="line">        mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_COMPONENT) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in FBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ::close(fenceFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mDequeuedAt = ++mCodec-&gt;mDequeueCounter;</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;mRenderInfo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// The fence for an emptied buffer must have signaled, but there still could be queued</span></span><br><span class="line">        <span class="comment">// or out-of-order dequeued buffers in the render queue prior to this buffer. Drop these,</span></span><br><span class="line">        <span class="comment">// as we will soon requeue this buffer to the surface. While in theory we could still keep</span></span><br><span class="line">        <span class="comment">// track of buffers that are requeued to the surface, it is better to add support to the</span></span><br><span class="line">        <span class="comment">// buffer-queue to notify us of released buffers and their fences (in the future).</span></span><br><span class="line">        mCodec-&gt;notifyOfRenderedFrames(<span class="literal">true</span> <span class="comment">/* dropIncomplete */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte buffers cannot take fences, so wait for any fence now</span></span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mCodec-&gt;waitForFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line">        fenceFd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;setReadFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line"></span><br><span class="line">    PortMode mode = getPortMode(kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rangeLength == <span class="number">0</span> &amp;&amp; (!(flags &amp; OMX_BUFFERFLAG_EOS)</span><br><span class="line">                    || mCodec-&gt;mPortEOS[kPortIndexOutput])) &#123;</span><br><span class="line">                ......</span><br><span class="line">                err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; reply =</span><br><span class="line">                <span class="keyword">new</span> AMessage(kWhatOutputBufferDrained, mCodec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mOutputFormat != mCodec-&gt;mLastOutputFormat &amp;&amp; rangeLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// pretend that output format has changed on the first frame (we used to do this)</span></span><br><span class="line">                <span class="keyword">if</span> (mCodec-&gt;mBaseOutputFormat == mCodec-&gt;mOutputFormat) &#123;</span><br><span class="line">                    mCodec-&gt;onOutputFormatChanged(mCodec-&gt;mOutputFormat);</span><br><span class="line">                &#125;</span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">                mCodec-&gt;sendFormatChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeLength &gt; <span class="number">0</span> &amp;&amp; mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// If potentially rendering onto a surface, always save key format data (crop &amp;</span></span><br><span class="line">                <span class="comment">// data space) so that we can set it if and once the buffer is rendered.</span></span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;usingMetadataOnEncoderOutput()) &#123;</span><br><span class="line">                <span class="keyword">native_handle_t</span> *handle = <span class="literal">NULL</span>;</span><br><span class="line">                VideoNativeHandleMetadata &amp;nativeMeta =</span><br><span class="line">                    *(VideoNativeHandleMetadata *)info-&gt;mData-&gt;data();</span><br><span class="line">                <span class="keyword">if</span> (info-&gt;mData-&gt;size() &gt;= <span class="keyword">sizeof</span>(nativeMeta)</span><br><span class="line">                        &amp;&amp; nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                    <span class="comment">// handle is only valid on 32-bit/mediaserver process</span></span><br><span class="line">                    handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    handle = (<span class="keyword">native_handle_t</span> *)nativeMeta.pHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setPointer(<span class="string">"handle"</span>, handle);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeOffset"</span>, rangeOffset);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeLength"</span>, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mData == info-&gt;mCodecData) &#123;</span><br><span class="line">                info-&gt;mData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;mCodecData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">                <span class="comment">// in this case we know that mConverter is not null</span></span><br><span class="line">                <span class="keyword">status_t</span> err = mCodec-&gt;mConverter[kPortIndexOutput]-&gt;convert(</span><br><span class="line">                        info-&gt;mCodecData, info-&gt;mData);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mCodec-&gt;mSkipCutBuffer-&gt;submit(info-&gt;mData);</span><br><span class="line">            &#125;</span><br><span class="line">            info-&gt;mData-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatDrainThisBuffer);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line">            notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">            reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">            notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">            notify-&gt;post();</span><br><span class="line"></span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">                ALOGV(<span class="string">"[%s] saw output EOS"</span>, mCodec-&gt;mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">                sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatEOS);</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"err"</span>, mCodec-&gt;mInputEOSResult);</span><br><span class="line">                notify-&gt;post();</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexOutput] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FREE_BUFFERS:</span><br><span class="line">            err = mCodec-&gt;freeBuffer(kPortIndexOutput, index);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Invalid port mode: %d"</span>, mode);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>○5、在onOMXFillBufferDone中获取PortMode，为RESUBMIT_BUFFERS则首先如果需要继续调用到IOMX的fillBuffer (…)填充输出缓冲重复做相关操作，接着ACodec又会生成一个kWhatOutputBufferDrained消息存在reply中，作为kWhatDrainThisBuffer消息的返回消息【notify-&gt;setMessage(“reply”, reply);】，然后向MediaCodec发送消息kWhatDrainThisBuffer，消息处理中调用函数MediaCodec::onOutputBufferAvailable()通知NuPlayer::Decoder有可用的output buffer，其中会设置消息的callbackID为CB_OUTPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_OUTPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnOutputBuffer(…)，在其中会进行如下处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onOutputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer =</span><br><span class="line">            mPortBuffers[kPortIndexOutput].itemAt(index).mData;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_OUTPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;setSize(<span class="string">"offset"</span>, buffer-&gt;offset());</span><br><span class="line">        msg-&gt;setSize(<span class="string">"size"</span>, buffer-&gt;size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> omxFlags;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt32(<span class="string">"omxFlags"</span>, &amp;omxFlags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_CODECCONFIG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、多媒体文件-音视频渲染（Renderer）"><a href="#（四）、多媒体文件-音视频渲染（Renderer）" class="headerlink" title="（四）、多媒体文件 - 音视频渲染（Renderer）"></a>（四）、多媒体文件 - 音视频渲染（Renderer）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnOutputBuffer(</span><br><span class="line">        <span class="keyword">size_t</span> index,</span><br><span class="line">        <span class="keyword">size_t</span> offset,</span><br><span class="line">        <span class="keyword">size_t</span> size,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getOutputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mOutputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mOutputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mOutputBuffers.add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOutputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setRange(offset, size);</span><br><span class="line">    buffer-&gt;meta()-&gt;clear();</span><br><span class="line">    buffer-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> eos = flags &amp; MediaCodec::BUFFER_FLAG_EOS;</span><br><span class="line">    <span class="comment">// we do not expect CODECCONFIG or SYNCFRAME for decoder</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatRenderBuffer, <span class="keyword">this</span>);</span><br><span class="line">    reply-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"generation"</span>, mBufferGeneration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">        reply-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSkipRenderingUntilMediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeUs &lt; mSkipRenderingUntilMediaTimeUs) &#123;</span><br><span class="line">            reply-&gt;post();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSkipRenderingUntilMediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumFramesTotal += !mIsAudio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until 1st frame comes out to signal resume complete</span></span><br><span class="line">    notifyResumeCompleteIfNecessary();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// send the buffer to renderer.</span></span><br><span class="line">        mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply);</span><br><span class="line">        <span class="keyword">if</span> (eos &amp;&amp; !isDiscontinuityPending()) &#123;</span><br><span class="line">            mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a.    在kWhatRenderBuffer消息处理中会调用NuPlayer::Decoder::onRenderBuffer(…)，在其中根据情况调用函数MediaCodec::renderOutputBufferAndRelease(..)渲染并释放，或者调用MediaCodec::releaseOutputBuffer(…)不渲染直接释放，两中情况都会产生kWhatReleaseOutputBuffer消息，该消息处理中调用函数MediaCodec::onReleaseOutputBuffer(…)，其中判断若SoftRenderer非空则进行软件渲染，不然就会通过○5中的reply让ACodec去硬件渲染，在kWhatOutputBufferDrained消息处理就会中调用到函数ACodec::BaseState::onOutputBufferDrained(…)进行真正的硬件渲染。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onRenderBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">size_t</span> bufferIx;</span><br><span class="line">    <span class="keyword">int32_t</span> eos;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"buffer-ix"</span>, &amp;bufferIx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mOutputBuffers[bufferIx];</span><br><span class="line">        buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCCDecoder != <span class="literal">NULL</span> &amp;&amp; mCCDecoder-&gt;isSelected()) &#123;</span><br><span class="line">            mCCDecoder-&gt;display(timeUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs;</span><br><span class="line">        CHECK(msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs));</span><br><span class="line">        err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNumOutputFramesDropped += !mIsAudio;</span><br><span class="line">        err = mCodec-&gt;releaseOutputBuffer(bufferIx);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.    MediaCodec:: getOutputBuffer (…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer的信息<br>c.    若Renderer非空则会调用NuPlayer::Renderer::queueBuffer(…)进行Renderer的相关处理同时消耗产生的kWhatRenderBuffer消息。queueBuffer()会产生kWhatQueueBuffer消息，消息处理中会调用函数NuPlayer::Renderer::onQueueBuffer(…) –&gt; NuPlayer::Renderer::postDrainVideoQueue() 【另外有audio的相关处理】，其中产生kWhatDrainVideoQueue消息，消息处理中调用先NuPlayer::Renderer::onDrainVideoQueue()在VideoQueue中取相关数据，再调用NuPlayer::Renderer::postDrainVideoQueue()循环取video数据，接着还会发送kWhatRenderBuffer消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onQueueBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> audio;</span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        mHasAudio = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHasVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoScheduler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mVideoScheduler = <span class="keyword">new</span> VideoFrameScheduler();</span><br><span class="line">            mVideoScheduler-&gt;init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">"buffer"</span>, &amp;buffer));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notifyConsumed;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"notifyConsumed"</span>, &amp;notifyConsumed));</span><br><span class="line"></span><br><span class="line">    QueueEntry entry;</span><br><span class="line">    entry.mBuffer = buffer;</span><br><span class="line">    entry.mNotifyConsumed = notifyConsumed;</span><br><span class="line">    entry.mOffset = <span class="number">0</span>;</span><br><span class="line">    entry.mFinalResult = OK;</span><br><span class="line">    entry.mBufferOrdinal = ++mTotalBuffersQueued;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mAudioQueue.push_back(entry);</span><br><span class="line">        postDrainAudioQueue_l();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVideoQueue.push_back(entry);</span><br><span class="line">        postDrainVideoQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mSyncQueues || mAudioQueue.empty() || mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer;</span><br><span class="line">    sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstAudioBuffer == <span class="literal">NULL</span> || firstVideoBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        syncQueuesDone_l();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> firstVideoTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> diff = firstVideoTimeUs - firstAudioTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000l</span>l) &#123;</span><br><span class="line">        (*mAudioQueue.begin()).mNotifyConsumed-&gt;post();</span><br><span class="line">        mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syncQueuesDone_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-05-source-demux-decoder-output-render.jpg" alt="Alt text"></p><h4 id="（五）、视频解码输出到SurfaceFlinger"><a href="#（五）、视频解码输出到SurfaceFlinger" class="headerlink" title="（五）、视频解码输出到SurfaceFlinger"></a>（五）、视频解码输出到SurfaceFlinger</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_DOWNSTREAM) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in OBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">android_native_rect_t</span> crop;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findRect(<span class="string">"crop"</span>, &amp;crop.left, &amp;crop.top, &amp;crop.right, &amp;crop.bottom)</span><br><span class="line">            &amp;&amp; <span class="built_in">memcmp</span>(&amp;crop, &amp;mCodec-&gt;mLastNativeWindowCrop, <span class="keyword">sizeof</span>(crop)) != <span class="number">0</span>) &#123;</span><br><span class="line">        mCodec-&gt;mLastNativeWindowCrop = crop;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_crop(mCodec-&gt;mNativeWindow.get(), &amp;crop);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set crop: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> dataSpace;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"dataspace"</span>, &amp;dataSpace)</span><br><span class="line">            &amp;&amp; dataSpace != mCodec-&gt;mLastNativeWindowDataSpace) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_buffers_data_space(</span><br><span class="line">                mCodec-&gt;mNativeWindow.get(), (android_dataspace)dataSpace);</span><br><span class="line">        mCodec-&gt;mLastNativeWindowDataSpace = dataSpace;</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set dataspace: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render != <span class="number">0</span></span><br><span class="line">            &amp;&amp; info-&gt;mData != <span class="literal">NULL</span> &amp;&amp; info-&gt;mData-&gt;size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">"render"</span>);</span><br><span class="line">        <span class="comment">// The client wants this buffer to be rendered.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// save buffers sent to the surface so we can get render time when they return</span></span><br><span class="line">        <span class="keyword">int64_t</span> mediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">        info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs);</span><br><span class="line">        <span class="keyword">if</span> (mediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mCodec-&gt;mRenderTracker.onFrameQueued(</span><br><span class="line">                    mediaTimeUs, info-&gt;mGraphicBuffer, <span class="keyword">new</span> Fence(::dup(info-&gt;mFenceFd)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">            <span class="comment">// use media timestamp if client did not request a specific render timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">                ALOGV(<span class="string">"using buffer PTS of %lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)timestampNs);</span><br><span class="line">                timestampNs *= <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err;</span><br><span class="line">        err = native_window_set_buffers_timestamp(mCodec-&gt;mNativeWindow.get(), timestampNs);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set buffer timestamp: %d"</span>, err);</span><br><span class="line"></span><br><span class="line">        info-&gt;checkReadFence(<span class="string">"onOutputBufferDrained before queueBuffer"</span>);</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"queueBuffer failed in onOutputBufferDrained: %d"</span>, err);</span><br><span class="line">            mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">            <span class="comment">// keeping read fence as write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (info-&gt;mData == <span class="literal">NULL</span> || info-&gt;mData-&gt;size() != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// move read fence into write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">            ATRACE_NAME(<span class="string">"frame-drop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1、Surfaceflinger-视频解码缓存申请"><a href="#5-1、Surfaceflinger-视频解码缓存申请" class="headerlink" title="5.1、Surfaceflinger 视频解码缓存申请"></a>5.1、Surfaceflinger 视频解码缓存申请</h5><p>前面2.3.6、MediaCodec-&gt;start()分析过：<br>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="comment">//使用surface渲染，为输出分配图形缓存GraphicBuffer  </span></span><br><span class="line"><span class="keyword">status_t</span> ACodec::LoadedToIdleState::allocateBuffers() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;allocateBuffersOnPort(kPortIndexInput);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCodec-&gt;allocateBuffersOnPort(kPortIndexOutput);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateBuffersOnPort(OMX_U32 portIndex) &#123;</span><br><span class="line">    CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    CHECK(mDealer[portIndex] == <span class="literal">NULL</span>);</span><br><span class="line">    CHECK(mBuffers[portIndex].isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">            err = allocateOutputMetadataBuffers();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = allocateOutputBuffersFromNativeWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-1-1、allocateOutputBuffersFromNativeWindow-的实现"><a href="#5-1-1、allocateOutputBuffersFromNativeWindow-的实现" class="headerlink" title="5.1.1、allocateOutputBuffersFromNativeWindow()的实现"></a>5.1.1、allocateOutputBuffersFromNativeWindow()的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;</span><br><span class="line">    <span class="keyword">status_t</span> err = configureOutputBuffersFromNativeWindow(</span><br><span class="line">            &amp;bufferCount, &amp;bufferSize, &amp;minUndequeuedBuffers, <span class="literal">true</span> <span class="comment">/* preregister */</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    mNumUndequeuedBuffers = minUndequeuedBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">                -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Dequeue buffers and send them to OMX</span></span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(buf, <span class="literal">false</span>));</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">        info.mFenceFd = fenceFd;</span><br><span class="line">        info.mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        info.mRenderInfo = <span class="literal">NULL</span>;</span><br><span class="line">        info.mData = <span class="keyword">new</span> ABuffer(<span class="literal">NULL</span> <span class="comment">/* data */</span>, bufferSize <span class="comment">/* capacity */</span>);</span><br><span class="line">        info.mCodecData = info.mData;</span><br><span class="line">        info.mGraphicBuffer = graphicBuffer;</span><br><span class="line">        mBuffers[kPortIndexOutput].push(info);</span><br><span class="line"></span><br><span class="line">        IOMX::buffer_id bufferId;</span><br><span class="line">        err = mOMX-&gt;useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,</span><br><span class="line">                &amp;bufferId);</span><br><span class="line">        ......</span><br><span class="line">        mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-1-1、首先为视频编码输出准备Surface"><a href="#5-1-1-1、首先为视频编码输出准备Surface" class="headerlink" title="5.1.1.1、首先为视频编码输出准备Surface"></a>5.1.1.1、首先为视频编码输出准备Surface</h5><p>此处通过Binder通信使用IGraphicBufferProducer请求分配一个Native Surface<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">        -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-06-Surface-ANativeWindow.png" alt="Alt text"></p><h5 id="5-1-1-2、Surface-gt-dequeueBuffer"><a href="#5-1-1-2、Surface-gt-dequeueBuffer" class="headerlink" title="5.1.1.2、Surface-&gt;dequeueBuffer"></a>5.1.1.2、Surface-&gt;dequeueBuffer</h5><p>为Surface分配Buffer，提供给视频解码后数据使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-2、Surface-gt-queueBuffer"><a href="#5-2、Surface-gt-queueBuffer" class="headerlink" title="5.2、Surface-&gt;queueBuffer()"></a>5.2、Surface-&gt;queueBuffer()</h5><p>待视频解码后，使用queueBuffer()交给SurfaceFlinger渲染，就可以在屏幕上看到视频画面了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-07-OpenMax-Based video decode-surfaceflinger.png" alt="Alt text"></p><p>关于SurfaceFlinger的知识请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】</p><p><strong>（ ͡° ͜ʖ ͡°）、（ಡωಡ）累~~~，有时间再继续Todo的分析吧，(๑乛◡乛๑) ！！！</strong><br><strong>Todo：Android OpenMax机制 实现分析</strong><br><strong>Todo：Android 音视频同步机制 源码分析</strong><br><strong>Todo：Android 音视频录制（Recoder）、编码（Encode）、混合（MediaMuxer）源码分析</strong></p><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/16222.html" target="_blank" rel="noopener">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a href="https://blog.csdn.net/nonmarking/article/category/6746500" target="_blank" rel="noopener">深入理解Android音视频同步机制（总共五篇）</a><br><a href="https://blog.csdn.net/junzia/article/details/54018671" target="_blank" rel="noopener">Android硬编码——音频编码、视频编码及音视频混合</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Video System（1）：Video System(视频系统)框架分析</title>
      <link href="/2018/06/01/Android%20Video%20System%EF%BC%881%EF%BC%89%EF%BC%9AVideo%20System(%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F)%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/01/Android%20Video%20System%EF%BC%881%EF%BC%89%EF%BC%9AVideo%20System(%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F)%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><h4 id="一-、Android-Video-Overview"><a href="#一-、Android-Video-Overview" class="headerlink" title="(一)、Android Video Overview"></a>(一)、Android Video Overview</h4><p>基于 OpenMAX 的视频解码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-01-OpenMax-Based video decode - data flow.png" alt="Alt text"></p><blockquote><p>YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。<a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV</a><br>VPU，Video processing unit </p></blockquote><p>基于 OpenMAX 的视频编码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-02-OpenMax-Based video encode - data flow.png.png" alt="Alt text"></p><p>视频框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-03-Video Architecture Software Stack.png" alt="Alt text"></p><p>组件描述：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-04-Q Component Description.png" alt="Alt text"></p><p>总结：<br>    从视频框架可以了解到。视频文件先经Stagefright传到OMX decoder解码（软解或硬解）、OMX decoder将解码后的YUV数据回传到Stagefright，不断循环播放同时经由SurfaceFlinger渲染到LCD屏幕上。</p><h4 id="二-、Android-MediaPlayer-amp-Nuplayer-框架分析"><a href="#二-、Android-MediaPlayer-amp-Nuplayer-框架分析" class="headerlink" title="(二)、Android MediaPlayer &amp; Nuplayer 框架分析"></a>(二)、Android MediaPlayer &amp; Nuplayer 框架分析</h4><h5 id="2-1、MediaPlayer"><a href="#2-1、MediaPlayer" class="headerlink" title="2.1、MediaPlayer"></a>2.1、MediaPlayer</h5><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>通常MediaPlayer的调用逻辑是，构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，按照实际需求还会调用pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法。</p><h5 id="2-1-1、MediaPlayer状态图"><a href="#2-1-1、MediaPlayer状态图" class="headerlink" title="2.1.1、MediaPlayer状态图:"></a>2.1.1、MediaPlayer状态图:</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-05-MediaPlayer-status-turn-.png" alt="Alt text"></p><p>☯ Idle状态<br>调用new或reset()方法创建MediaPlayer后进入空闲<br>☯ End状态<br>调用release()后就结束<br>☯ Error状态<br>播放控制操作出错或无效状态下调用播放控制操作<br>☯ Initialized状态</p><p>调用setDataSource之后完成初始化<br>☯ Prepared状态<br>同步prepare()或异步prepareAsync()完成准备<br>☯ Preparing状态<br>是一种瞬时状态，调用prepareAsync()时会先进入此状态<br>☯ Started  状态<br>要开始播放必须调用start()<br>☯ Paused  状态<br>调用pause()并成功返回后播放可以被暂停<br>☯ Stopped状态<br>调用stop()会停止播放<br>☯ PlaybackCompleted状态<br>当播放到达流末端时，播放完成</p><h5 id="2-1-2、MediaPlayer和MediaPlayerService"><a href="#2-1-2、MediaPlayer和MediaPlayerService" class="headerlink" title="2.1.2、MediaPlayer和MediaPlayerService"></a>2.1.2、MediaPlayer和MediaPlayerService</h5><p>mediaserver 启动后会把media相关一些服务添加到servicemanager中，其中就有mediaPlayerService。这样应用启动前，系统就有了mediaPlayerService这个服务程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\mediaserver\main_mediaserver.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-06-Main_mediaserver.png" alt="Alt text"></p><h5 id="2-1-3、创建MediaPlayer"><a href="#2-1-3、创建MediaPlayer" class="headerlink" title="2.1.3、创建MediaPlayer"></a>2.1.3、创建MediaPlayer</h5><p>☯ Java应用程序中创建MediaPlayer对象<br>MediaPlayer mediaPlayer = new MediaPlayer();<br>☯ MediaPlayer的构造函数中比较重要的就是本地的native函数：native_setup()其对应的JNI函数为<br>android_media_MediaPlayer_native_setup()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-07-android_media_MediaPlayer_native_setup.png" alt="Alt text"></p><p>构造Native层的MediaPlayer对象的时候【MediaPlayer.cpp】，也会构造其父类的对象。在MediaPlayer的父类IMediaDeathNotifier中有个很重要的方法getMediaPlayerService()来获取MediaPlayerService，其关系到MediaPlayer和MediaPlayerService之间的通信。</p><h5 id="2-1-4、setDataSource-设置播放资源"><a href="#2-1-4、setDataSource-设置播放资源" class="headerlink" title="2.1.4、setDataSource()设置播放资源"></a>2.1.4、setDataSource()设置播放资源</h5><p>在整个应用程序的进程中，Mediaplayer.cpp 中 setDataSource会从service manager中获得mediaPlayerService 服务，然后通过服务来创建player，这个player就是播放器的真实实例，同时也使MediaPlayer和MediaPlayerService建立了联系。<br>在java层MediaPlayer.java中的setDataSource最终会调用_setDataSource方法，对应native层MediaPlayer.cpp中的setDataSource方法。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-08-mp_setDataSource.png" alt="Alt text"></p><p>通过 getMediaPlayerService 得到的BpMediaPlayerService类型的service，和mediaPlayerService进程中的BnMediaPlayerService 相对应负责binder通讯。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-09-MediaPlayerService_Create.png" alt="Alt text"></p><p>在create函数中创建了一个MediaPlayerService::Client的实例，是MediaPlayerService的内部类，也就是说MediaPlayerService会为每个client应用进程创建一个相应的MediaPlayerService::Client的实例，来实现播放以及播放过程的控制，向MediaPlayer发事件通知。到这里，在Server端的对象就创建完成了。</p><p>然后在MediaPlayer.cpp中就得到了一个sever端的player实例，它和本地其他类的实例没什么用法上的区别，而实际上则是通过binder机制运行在另外一个进程中的。获得此实例后继续player-&gt;setDataSource操作。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-10-player-setDataSource.png" alt="Alt text"></p><p>小结：<br>Java应用程序中使用MediaPlayer.java的setDataSource()会传递到Native层中MediaPlayer.cpp的setDataSource()去执行，而MediaPlayer.cpp又会把这个方法交给MediaPlayerservice去执行。MediaPlayerService则是使用NuPlayer实现的，最后， setDataSource还是交给了NuPlayer去执行了。这个过程把MediaPlayer和MediaPlayerService之间的联系建立起来，同时又把MediaPlayerService和NuPlayer的关系建立了起来。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-11-GenericSource-setDataSource.png" alt="Alt text"></p><h5 id="2-1-5、setDisplay"><a href="#2-1-5、setDisplay" class="headerlink" title="2.1.5、setDisplay()"></a>2.1.5、setDisplay()</h5><p> 下一步就是java层的setDisplay，依然查看java层MediaPlayer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(SurfaceHolder sh)</span> </span>&#123;</span><br><span class="line">        mSurfaceHolder = sh;</span><br><span class="line">        Surface surface;</span><br><span class="line">        <span class="keyword">if</span> (sh != null) &#123;</span><br><span class="line">            surface = sh.getSurface();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            surface = null;</span><br><span class="line">        &#125;</span><br><span class="line">        _setVideoSurface(surface);</span><br><span class="line">        updateSurfaceScreenOn();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后会调用本地方法_setVideoSurface，我们继续找到它的jni实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setVideoSurface(env, thiz, jsurface, <span class="literal">true</span> <span class="comment">/* mediaPlayerMustBeAlive */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);<span class="comment">//获取C++的MediaPlayer</span></span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayerMustBeAlive) &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line">    decVideoSurfaceRef(env, thiz);</span><br><span class="line"><span class="comment">//IGraphicBufferProducer图层缓冲区合成器</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; new_st;</span><br><span class="line">    <span class="keyword">if</span> (jsurface) &#123;</span><br><span class="line">    <span class="comment">//得到java层的surface</span></span><br><span class="line">        sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));</span><br><span class="line">        <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//获取IGraphicBufferProducer</span></span><br><span class="line">            new_st = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">if</span> (new_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface does not have a binding SurfaceTexture!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加IGraphicBufferProducer的强引用+1</span></span><br><span class="line">            new_st-&gt;incStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface has been released"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上面我们在native_init方法中将java层mNativeSurfaceTexture查找给了jni层，正好，在这里将IGraphicBufferProducer赋给它</span></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will fail if the media player has not been initialized yet. This</span></span><br><span class="line">    <span class="comment">// can be the case if setDisplay() on MediaPlayer.java has been called</span></span><br><span class="line">    <span class="comment">// before setDataSource(). The redundant call to setVideoSurfaceTexture()</span></span><br><span class="line">    <span class="comment">// in prepare/prepareAsync covers for this case.</span></span><br><span class="line">    <span class="comment">//如果MediaPlayer没有初始化，这一步会失败。原因可能是setDisplay在setDataSource之前。如果在prepare/prepareAsync 时想规避这个错误而去调用setVideoSurfaceTexture是多余的。</span></span><br><span class="line">    <span class="comment">//最终会调用C++层的setVideoSurfaceTexture方法，下一节在分析</span></span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(new_st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decVideoSurfaceRef</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; old_st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (old_st != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old_st-&gt;decStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要是对图像显示的surface的保存，然后将旧的IGraphicBufferProducer强引用减一，再获得新的IGraphicBufferProducer，最后会调用C++的MediaPlayer的setVideoSurfaceTexture将它折纸进去。</p><p>IGraphicBufferProducer是SurfaceFlinger的内容，一个UI完全显示到diplay的过程，SurfaceFlinger扮演着重要的角色但是它的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上，而其他方面比如各个程序的绘画过程，就由其他东西来担任了。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-12-IGraphicBufferProducer.png" alt="Alt text"></p><p>   虽说是三者的关系，但是他们所属的层却只有两个，app属于Java层，BufferQueue/SurfaceFlinger属于native层。也就是说BufferQueue也是隶属SurfaceFlinger，所有工作围绕SurfaceFlinger展开。<br>       这里IGraphicBufferProducer就是app和BufferQueue重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。</p><h5 id="2-1-6、播放器基本模型"><a href="#2-1-6、播放器基本模型" class="headerlink" title="2.1.6、播放器基本模型"></a>2.1.6、播放器基本模型</h5><p>NuPlayer不管有多么神秘，说到底还是个播放器。在播放器的基本模型上，他与VCL、mplayer、ffmpeg等开源的结构是一致的。只是组织实现的方式不同。<br>深入了解NuPlayer之前，把播放器的基本模型总结一下，然后按照模型的各个部分来深入研究NuPlayer的实现方式。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-13-source-demux-decoder-output.jpg" alt="Alt text"></p><p>☯ datasource数据源：数据源，数据的来源不一定都是本地file，也有可能是网路上的各种协议例如：http、rtsp、HLS等。source的任务就是把数据源抽象出来，为下一个demux模块提供它需要的稳定的数据流。demux不用关信数据到底是从什么地方来的。</p><p>☯ demuxer解复用：视频文件一般情况下都是把音视频的ES流交织的通过某种规则放在一起。这种规则就是容器规则。现在有很多不同的容器格式。如ts、mp4、flv、mkv、avi、rmvb等等。demux的功能就是把音视频的ES流从容器中剥离出来，然后分别送到不同的解码器中。其实音频和视频本身就是2个独立的系统。容器把它们包在了一起。但是他们都是独立解码的，所以解码之前，需要把它分别 独立出来。demux就是干这活的，他为下一步decoder解码提供了数据流。</p><p>☯ decoder解码：解码器—-播放器的核心模块。分为音频和视频解码器。影像在录制后, 原始的音视频都是占用大量空间, 而且是冗余度较高的数据. 因此, 通常会在制作的时候就会进行某种压缩 ( 压缩技术就是将数据中的冗余信息去除数据之间的相关性 ). 这就是我们熟知的音视频编码格式, 包括MPEG1（VCD）\ MPEG2（DVD）\ MPEG4 \ H.264 等等. 音视频解码器的作用就是把这些压缩了的数据还原成原始的音视频数据. 当然, 编码解码过程基本上都是有损的 .解码器的作用就是把编码后的数据还原成原始数据。</p><p>☯ output输出：输出部分分为音频和视频输出。解码后的音频（pcm）和视频（yuv）的原始数据需要得到音视频的output模块的支持才能真正的让人的感官系统（眼和耳）辨识到。</p><p>所以，播放器大致分成上述4部分。怎么抽象的实现这4大部分、以及找到一种合理的方式将这几部分组织并运动起来。是每个播放器不同的实现方式而已。接下来就围绕这4大部分做深入学习，看看NuPlayer的工作原理。</p><h5 id="2-2、NuPlayer分析"><a href="#2-2、NuPlayer分析" class="headerlink" title="2.2、NuPlayer分析"></a>2.2、NuPlayer分析</h5><h5 id="2-2-0、NuPlayer简介"><a href="#2-2-0、NuPlayer简介" class="headerlink" title="2.2.0、NuPlayer简介"></a>2.2.0、NuPlayer简介</h5><p>Android2.3时引入流媒体框架，而流媒体框架的核心是NuPlayer。在之前的版本中一般认为Local Playback就用Stagefrightplayer+Awesomeplayer，流媒体用NuPlayer。Android4.0之后HttpLive和RTSP协议开始使用NuPlayer播放器，Android5.0（L版本）之后本地播放也开始使用NuPlayer播放器。 Android7.0(N版本)则完全去掉了Awesomeplayer。<br>通俗点说，NuPlayer是AOSP中提供的多媒体播放框架，能够支持本地文件、HTTP（HLS）、RTSP等协议的播放，通常支持H.264、H.265/HEVC、AAC编码格式，支持MP4、MPEG-TS封装。<br>在实现上NuPlayer和Awesomeplayer不同，NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来异步地处理请求，ALooper列队消息请求，AHandler中去处理，所以有更少的Mutex/Lock在NuPlayer中。Awesomeplayer中利用了omxcodec而NuPlayer中利用了Acodec。</p><h5 id="2-2-1、NuPlayer整体类关系图"><a href="#2-2-1、NuPlayer整体类关系图" class="headerlink" title="2.2.1、NuPlayer整体类关系图"></a>2.2.1、NuPlayer整体类关系图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-14-NuPlayer-arc.jpg" alt="Alt text"></p><p>NuPlayer由NuPlayerDriver封装，利用了底层的ALooper/AHandler机制来异步地处理请求，ALooper保存消息请求，然后在AHandler中处理。另外，NuPlayer中利用到了Acodec。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-15-NuPlayer-class.jpg" alt="Alt text"></p><p>☯ NuPlayer::Source<br>解析模块（parser，功能类似FFmpeg的avformat）。其接口与MediaExtractor和<br>MediaSource组合的接口差不多，同时提供了用于快速定位的seekTo接口。</p><p>☯ NuPlayer::Decoder<br>解码模块（decoder，功能类似FFmpeg的avcodec），封装了用于AVC、AAC解码的接口，<br>通过ACodec实现解码（包含OMX硬解码和软解码）。</p><p>☯ NuPlayer::Render<br>渲染模块（render，功能类似声卡驱动和显卡驱动），主要用于音视频渲染和同步，与<br>NativeWindow有关。</p><p>☯ NuPlayer  是播放框架中连接Source、Decoder、Renderer的纽带</p><p>☯ NuPlayerDriver<br>作为NuPlayer类的封装，直接调用NuPlayer。</p><p>NuPlayer框架中最顶层的类是NuPlayerDriver，继承自MediaPlayerInterface，主要提供一个状态转换机制，作为NuPlayer类的Wrapper。NuPlayerDriver类中最重要的成员是以下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; State mState 播放器状体标志 </span><br><span class="line">&gt; sp &lt;ALooper&gt; mLooper 内部消息驱动机制 </span><br><span class="line">&gt; sp &lt;NuPlayer&gt;  mPlayer 真正完成播放器的类</span><br></pre></td></tr></table></figure><p>NuPlayerDriver主要是 构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，实际需求pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法</p><h5 id="2-2-2、NuPlayer框架需要关注知识点"><a href="#2-2-2、NuPlayer框架需要关注知识点" class="headerlink" title="2.2.2、NuPlayer框架需要关注知识点"></a>2.2.2、NuPlayer框架需要关注知识点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NuPlayer的框架，其内部实现逻辑。那么最终就落实到如何从一个类中提取出需要的框架及知识点。那么一个类的对外接口部分通常包括：</span><br><span class="line">--- 构造函数和析构函数</span><br><span class="line">--- 必须调用的接口</span><br><span class="line">--- 可选的调用接口</span><br><span class="line"></span><br><span class="line">在多媒体播放中，通过关注的点有：</span><br><span class="line">--- 如何实现解复用，得到音频、视频、字幕等数据</span><br><span class="line">--- 如何实现解码</span><br><span class="line">--- 如何实现音视频同步</span><br><span class="line">--- 如何渲染视频</span><br><span class="line">--- 如何播放音频</span><br><span class="line">--- 如何实现快速定位</span><br></pre></td></tr></table></figure><h4 id="三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper"><a href="#三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper" class="headerlink" title="(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper"></a>(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper</h4><p>前文中提到过NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来<strong>异步地处理请求</strong>，ALooper保存消息请求，然后调用AHandler接口去处理。<br>实际上在代码中NuPlayer本身继承自AHandler类，而ALooper对象保存在NuPlayerDriver中。<br>ALooper/AHandler机制是模拟的消息循环处理方式，通常有三个主要部分：消息（message，通常包含Handler）、消息队列（queue）、消息处理线程（looper thread）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-16-AHandler-ALooper-AMessage.png" alt="Alt text"></p><p>对于handler消息机制，构成就必须包括一个Loop，message。那么对应的AHandler，也应该有对应的ALooper、AMessage。<br>因此本小节主要涉及到三个类ALooper、AHandler、AMessage。</p><h5 id="3-1、AHandler接口分析（消息处理类）"><a href="#3-1、AHandler接口分析（消息处理类）" class="headerlink" title="3.1、AHandler接口分析（消息处理类）"></a>3.1、AHandler接口分析（消息处理类）</h5><p>下面代码是AHandler接口:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AHandler.h"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AHandler</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AHandler();</span><br><span class="line"></span><br><span class="line">    ALooper::<span class="function">handler_id <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    sp&lt;ALooper&gt; looper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;ALooper&gt; getLooper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;AHandler&gt; getHandler() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>      <span class="comment">// deliverMessage()</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooperRoster</span>;</span> <span class="comment">// setID()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mMessageCounter;</span><br><span class="line">    KeyedVector&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; mMessages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(ALooper::handler_id id, wp&lt;ALooper&gt; looper)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliverMessage</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上面接口，初步印象是AHandler没有直接对外的接口（只有获取成员变量的接口），基本上只有一个onMessageReceived用于子类继承，deliverMessage用于给类AMessage使用，setID用于给友元类ALooperRoster使用。从这点来说，真正代码应该在AMessage里边。</p><h5 id="3-2、AMessage接口分析（消息载体）"><a href="#3-2、AMessage接口分析（消息载体）" class="headerlink" title="3.2、AMessage接口分析（消息载体）"></a>3.2、AMessage接口分析（消息载体）</h5><p>下面代码是AMessage的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AMessage.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AMessage();</span><br><span class="line">    AMessage(<span class="keyword">uint32_t</span> what, <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler); <span class="comment">// 代码中常用的构造函数</span></span><br><span class="line">    <span class="keyword">static</span> sp&lt;AMessage&gt; FromParcel(<span class="keyword">const</span> Parcel &amp;parcel, <span class="keyword">size_t</span> maxNestingLevel = <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write this AMessage to a parcel.</span></span><br><span class="line">    <span class="comment">// All items in the AMessage must have types that are recognized by</span></span><br><span class="line">    <span class="comment">// FromParcel(); otherwise, TRESPASS error will occur.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel *parcel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWhat</span><span class="params">(<span class="keyword">uint32_t</span> what)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> what() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这是一个AHandler，通过这个可以获得ALooper对象引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有设置的消息属性参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一系列设置/获取 Message 属性的函数。。。</span></span><br><span class="line">    <span class="keyword">void</span> setInt32/setInt64/setSize/setFloat/setDouble/setPointer/setPointer/setString/setRect/setObject/setBuffer/setMessage(...);</span><br><span class="line">    <span class="keyword">bool</span> findInt32/findInt64/findSize/findFloat/findDouble/findPointer/findString/findObject/findBuffer/findMessage/findRect(...) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过这个函数检索下指定名称的消息属性是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息的接口，顾名思义直接投递给构造函数的ALooper，注意支持延时消息，但不支持提前消息，delayUS &gt; 0</span></span><br><span class="line">    <span class="keyword">status_t</span> post(<span class="keyword">int64_t</span> delayUs = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息并等待执行结束后发送response消息</span></span><br><span class="line">    <span class="keyword">status_t</span> postAndAwaitResponse(sp&lt;AMessage&gt; *response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this returns true, the sender of this message is synchronously</span></span><br><span class="line">    <span class="comment">// awaiting a response and the reply token is consumed from the message</span></span><br><span class="line">    <span class="comment">// and stored into replyID. The reply token must be used to send the response</span></span><br><span class="line">    <span class="comment">// using "postReply" below.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">senderAwaitsResponse</span><span class="params">(sp&lt;AReplyToken&gt; *replyID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Posts the message as a response to a reply token.  A reply token can</span></span><br><span class="line">    <span class="comment">// only be used once. Returns OK if the response could be posted; otherwise,</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    sp&lt;AMessage&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个消息，并返回差异</span></span><br><span class="line">    sp&lt;AMessage&gt; changesFrom(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AMessage&gt; &amp;other, <span class="keyword">bool</span> deep = <span class="literal">false</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息属性存储的个数及特定索引上的消息属性参数</span></span><br><span class="line">    <span class="keyword">size_t</span> countEntries() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getEntryNameAt</span><span class="params">(<span class="keyword">size_t</span> index, Type *type)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AMessage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span>;</span> <span class="comment">// deliver()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mWhat;</span><br><span class="line"></span><br><span class="line">    wp&lt;AHandler&gt; mHandler;</span><br><span class="line">    wp&lt;ALooper&gt; mLooper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于ALooper调用的，发送消息的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的接口可以看出在使用AMessage是只需要指定消息的id和要处理该消息的AHandler即可，可以通过构造函数，也可以单独调用setWhat和setTarget接口。AMessage构造完成之后，可以调用setXXX设置对应的参数，通过findXXX获取传递的参数。最后通过post即可将消息投递到AHandler的消息队列中。</p><h5 id="3-3、ALooper接口分析（消息处理循环及后台线程）"><a href="#3-3、ALooper接口分析（消息处理循环及后台线程）" class="headerlink" title="3.3、ALooper接口分析（消息处理循环及后台线程）"></a>3.3、ALooper接口分析（消息处理循环及后台线程）</h5><p>其简化的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/ALooper.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    ALooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Takes effect in a subsequent call to start().</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">handler_id <span class="title">registerHandler</span><span class="params">(<span class="keyword">const</span> sp&lt;AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterHandler</span><span class="params">(handler_id handlerID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> start(<span class="keyword">bool</span> runOnCallingThread = <span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">bool</span> canCallJava = <span class="literal">false</span>, <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> stop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> int64_t <span class="title">GetNowUs</span><span class="params">()</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~ALooper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>       <span class="comment">// post()</span></span><br><span class="line"></span><br><span class="line">    AString mName;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> mWhenUs;</span><br><span class="line">        sp&lt;AMessage&gt; mMessage;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Event&gt; mEventQueue;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LooperThread</span>;</span></span><br><span class="line">    sp&lt;LooperThread&gt; mThread;</span><br><span class="line">    <span class="keyword">bool</span> mRunningLocally;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// START --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// posts a message on this looper with the given timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg, <span class="keyword">int64_t</span> delayUs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creates a reply token to be used with this looper</span></span><br><span class="line">    sp&lt;AReplyToken&gt; createReplyToken();</span><br><span class="line">    <span class="comment">// waits for a response for the reply token.  If status is OK, the response</span></span><br><span class="line">    <span class="comment">// is stored into the supplied variable.  Otherwise, it is unchanged.</span></span><br><span class="line">    <span class="keyword">status_t</span> awaitResponse(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, sp&lt;AMessage&gt; *response);</span><br><span class="line">    <span class="comment">// posts a reply for a reply token.  If the reply could be successfully posted,</span></span><br><span class="line">    <span class="comment">// it returns OK. Otherwise, it returns an error value.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// END --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ALooper对外接口比较简单，通常就是NuPlayerDriver构造函数中的调用逻辑。先创建一个ALooper对象，然后调用setName和start接口，之后调用registerHandler设置一个AHandler，这样就完成了初始化。在析构之前需要调用stop接口。<br>这里需要说明下，ALooper::start接口会启动一个线程，并调用ALooper::loop函数，该函数主要实现消息的实际执行。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ALooper::loop() &#123;</span><br><span class="line">    Event event;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mThread == <span class="literal">NULL</span> &amp;&amp; !mRunningLocally) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从mEventQueue取出消息，判断是否需要执行，不需要的话就等待</span></span><br><span class="line">        <span class="comment">// 需要的话就调用handler执行，并删除对应消息</span></span><br><span class="line">        <span class="keyword">if</span> (mEventQueue.empty()) &#123;</span><br><span class="line">            mQueueChangedCondition.wait(mLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int64_t</span> whenUs = (*mEventQueue.begin()).mWhenUs;</span><br><span class="line">        <span class="keyword">int64_t</span> nowUs = GetNowUs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (whenUs &gt; nowUs) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> delayUs = whenUs - nowUs;</span><br><span class="line">            mQueueChangedCondition.waitRelative(mLock, delayUs * <span class="number">1000l</span>l);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        event = *mEventQueue.begin();</span><br><span class="line">        mEventQueue.erase(mEventQueue.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.mMessage-&gt;deliver();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么消息是通过那个函数添加进来的呢？ 这就是友元类AMessage的作用，通过调用ALooper::post接口，将AMessage添加到mEventQueue中。</p><h5 id="3-4、一个调用实例"><a href="#3-4、一个调用实例" class="headerlink" title="3.4、一个调用实例"></a>3.4、一个调用实例</h5><p>以NuPlayer::setVideoSurfaceTextureAsync为示例分析下ALooper/AHandler机制。<br>这里不解释ALooper的初始化过程，有兴趣的可以参考资料Android Native层异步消息处理框架的内容。<br>下面是setVideoSurfaceTextureAsync的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码功能很简单，创建一个AMessage对象，并设置下参数，参数类型为Object，名称是”surface”，然后通过AMessage::post接口，间接调用ALooper::post接口，将消息发送给ALooper-NuPlayerDriver::mLooper；ALooper的消息循环线程检测到这个消息，在ALooper::loop函数中通过AMessage的deliver接口，调用AHandler::deliverMessage接口，这个函数会调动NuPlayer::onMessageReceived（通过继承机制实现）接口。这样绕了一圈。我们就可以通过ALooper/AHandler机制处理消息了。<br>具体处理代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">        <span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            ALOGD(<span class="string">"onSetVideoSurface(%p video decoder)"</span>, surface.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">            <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">            <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 省略其他部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-、NuPlayer源码分析"><a href="#四-、NuPlayer源码分析" class="headerlink" title="(四)、NuPlayer源码分析"></a>(四)、NuPlayer源码分析</h4><p>这次我们需要深入分析的是NuPlayer类，相比于NuPlayerDriver的接口功能，NuPlayer继承自AHandler类，是AOSP播放框架中连接Source、Decoder、Render的纽带。</p><h5 id="4-1、主要接口和核心的类成员"><a href="#4-1、主要接口和核心的类成员" class="headerlink" title="4.1、主要接口和核心的类成员"></a>4.1、主要接口和核心的类成员</h5><p>NuPlayer类被NuPlayerDriver直接调用，其主要接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code from NuPlayer.h (~/frameworks/av/media/libmediaplayerservice/nuplayer/)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NuPlayer</span> :</span> <span class="keyword">public</span> AHandler &#123;</span><br><span class="line">    NuPlayer(<span class="keyword">pid_t</span> pid);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUID</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(<span class="keyword">const</span> wp&lt;NuPlayerDriver&gt; &amp;driver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVideoSurfaceTextureAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifyResetComplete" once finished.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetAsync</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifySeekComplete" once finished</span></span><br><span class="line">    <span class="comment">// and needNotify is true.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seekToAsync</span><span class="params">(<span class="keyword">int64_t</span> seekTimeUs, <span class="keyword">bool</span> needNotify = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> setVideoScalingMode(<span class="keyword">int32_t</span> mode);</span><br><span class="line">    <span class="keyword">status_t</span> getTrackInfo(Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> getSelectedTrack(<span class="keyword">int32_t</span> type, Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> selectTrack(<span class="keyword">size_t</span> trackIndex, <span class="keyword">bool</span> select, <span class="keyword">int64_t</span> timeUs);</span><br><span class="line">    <span class="keyword">status_t</span> getCurrentPosition(<span class="keyword">int64_t</span> *mediaUs);</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; getFileMeta();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFrameRate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NuPlayer();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口分类下，无外乎几个分类：</p><p>☯ 用于初始化的（比如构造函数、setDriver/setDataSourceAsync/prepareAsync/setVideoSurfaceTextureAsync）<br>☯ 用于销毁的（比如析构函数、resetAsync）<br>☯ 用于播放控制的（比如start/pause/seekToAsync）<br>☯ 用于状态获取的（比如getCurrentPosition/getFileMeta）<br>下面是主要的类成员部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line">wp&lt;NuPlayerDriver&gt; mDriver; <span class="comment">// 接口调用方</span></span><br><span class="line">sp&lt;Source&gt; mSource; <span class="comment">// 相当于FFmpeg中的demuxer</span></span><br><span class="line">sp&lt;Surface&gt; mSurface; <span class="comment">// 显示用的Surface</span></span><br><span class="line">sp&lt;DecoderBase&gt; mVideoDecoder; <span class="comment">// 视频解码器</span></span><br><span class="line">sp&lt;DecoderBase&gt; mAudioDecoder; <span class="comment">// 音频解码器</span></span><br><span class="line">sp&lt;CCDecoder&gt; mCCDecoder; </span><br><span class="line">sp&lt;Renderer&gt; mRenderer; <span class="comment">// 渲染器</span></span><br><span class="line">sp&lt;ALooper&gt; mRendererLooper;</span><br></pre></td></tr></table></figure><h5 id="4-2、setDataSourceAsync-现分析"><a href="#4-2、setDataSourceAsync-现分析" class="headerlink" title="4.2、setDataSourceAsync()现分析"></a>4.2、setDataSourceAsync()现分析</h5><p>这个函数有多重不同的重载形式，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IStreamSource&gt; &amp;source)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source)</span></span>;</span><br></pre></td></tr></table></figure><p>需要根据实际情况选择，这里以第三个接口为例，说明下多本地媒体文件是如何处理的。<br>下面是这个函数的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setDataSourceAsync(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetDataSource, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatSourceNotify, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建对象用于读取本地文件</span></span><br><span class="line">    sp&lt;GenericSource&gt; source =</span><br><span class="line">            <span class="keyword">new</span> GenericSource(notify, mUIDValid, mUID);</span><br><span class="line">    <span class="comment">// 实际干活的的代码</span></span><br><span class="line">    <span class="keyword">status_t</span> err = source-&gt;setDataSource(fd, offset, length);</span><br><span class="line">    </span><br><span class="line">    msg-&gt;setObject(<span class="string">"source"</span>, source);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现很简单，创建GenericSource对象，并调用其setDataSource接口，然后发送kWhatSetDataSource消息。<br>我们看看如何处理然后发送kWhatSetDataSource消息呢？代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetDataSource:</span><br><span class="line">&#123;</span><br><span class="line">    CHECK(mSource == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"source"</span>, &amp;obj));</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mSourceLock)</span></span>;</span><br><span class="line">        mSource = <span class="keyword">static_cast</span>&lt;Source *&gt;(obj.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知Driver函数调用完成</span></span><br><span class="line">    CHECK(mDriver != <span class="literal">NULL</span>);</span><br><span class="line">    sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        driver-&gt;notifySetDataSourceCompleted(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里发现，其实没做什么就是直接通知NuPlayerDriver。我们还注意到这里构建了一个特殊消息（AMessage）notify，这个消息用于在Source和NuPlayer直接传递。下面这是消息循环中的处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSourceNotify:</span><br><span class="line">&#123;</span><br><span class="line">    onSourceNotify(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续讨论Source的时候详细说明这个消息通知的意义。</p><h5 id="4-3、prepareAsync"><a href="#4-3、prepareAsync" class="headerlink" title="4.3、prepareAsync()"></a>4.3、prepareAsync()</h5><p>这个函数实现的功能对应于MediaPlayerBase::prepare/prepareAsync接口，实现异步的prepare功能，一般就是做一些额外的初始化工作。那么直接看一下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是发了一个kWhatPrepare的消息。接下来是如何处理这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终还是调用了Source::prepareAsync接口。后面会解释其功能。（这里面可能会解析下码流，读取音频、视频、字幕流信息，读取时长、元数据等）。</p><h5 id="4-4、setVideoSurfaceTextureAsync"><a href="#4-4、setVideoSurfaceTextureAsync" class="headerlink" title="4.4、setVideoSurfaceTextureAsync()"></a>4.4、setVideoSurfaceTextureAsync()</h5><p>调用这个接口主要为了设置视频渲染窗口。其实现相对简单，创建一个Surface，然后发送异步的kWhatSetVideoSurface消息。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync( <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么看看如何处理kWhatSetVideoSurface消息呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface: &#123;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">    sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">    <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">    <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">    <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">            || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">        performSetSurface(surface); <span class="comment">// 通知NuPlayerDriver设置完成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空音频、视频缓冲</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line">    <span class="comment">// 最终调用NuPlayer::performSetSurface接口</span></span><br><span class="line">    mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">            <span class="comment">// Issue a seek to refresh the video screen only if started otherwise</span></span><br><span class="line">            <span class="comment">// the extractor may not yet be started and will assert.</span></span><br><span class="line">            <span class="comment">// If the video decoder is not set (perhaps audio only in this case)</span></span><br><span class="line">            <span class="comment">// do not perform a seek as it is not needed.</span></span><br><span class="line">            <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于新的surface设置，重置下解码器</span></span><br><span class="line">        mDeferredActions.push_back(<span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After a flush without shutdown, decoder is paused.</span></span><br><span class="line">    <span class="comment">// Don't resume it until source seek is done, otherwise it could</span></span><br><span class="line">    <span class="comment">// start pulling stale data too soon.</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line">    <span class="comment">// 把上面mDeferredActions中缓存的所有Action处理下，并清空</span></span><br><span class="line">    processDeferredActions();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码相对复杂点，涉及到很多，其实主要是为了设置Surface之后，可以正常解码显示，因为某些情况下解码器初始化需要依赖于具体的Surface。当然，里边还涉及到NuPlayer状态及初始化判断。</p><h5 id="4-5、start-pause"><a href="#4-5、start-pause" class="headerlink" title="4.5、start()/pause()"></a>4.5、start()/pause()</h5><p>start函数实现很简单，实际就发送了kWhatStart消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息处理函数中的处理如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">        <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">        <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">            onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了OnStart/OnResume函数。<br>pause函数实现类似，只是发送的是kWhatPause消息。在消息处理函数中的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPause:</span><br><span class="line">&#123;</span><br><span class="line">    onPause();</span><br><span class="line">    mPausedByClient = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用的onPause函数。下面单独分析下这三个函数。先从简单的函数开始OnPause/onResume</p><p>NuPlayer::onPause<br>这个函数实现暂停功能，总体来说就是把Source和Render暂停就可以了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onPause() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onResume<br>这个函数实现恢复功能，代码逻辑跟onPause差不多，把Source和Render恢复，还可能涉及其它操作。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onResume() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPaused || mResetting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// |mAudioDecoder| may have been released due to the pause timeout, so re-create it if</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    <span class="keyword">if</span> (audioDecoderStillNeeded() &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        instantiateDecoder(<span class="literal">true</span> <span class="comment">/* audio */</span>, &amp;mAudioDecoder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onStart<br>这个接口实现启动的操作，相对复杂点，需要初始化解码器、初始化Render、设置Source状态，并将三者关联起来。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start(); <span class="comment">// 设置Source状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (省略部分代码)</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration; <span class="comment">// 创建Render和RenderLooper，属性设置、与解码器关联</span></span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中没有解码器的初始化，那只能继续看看postScanSources代码了。看实现发现就是发送了kWhatScanSources消息。那么消息循环里边是怎么处理的呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> generation;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"generation"</span>, &amp;generation));</span><br><span class="line">    <span class="keyword">if</span> (generation != mScanSourcesGeneration) &#123;</span><br><span class="line">        <span class="comment">// Drop obsolete msg.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> mHadAnySourcesBefore = (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">    <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化视频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化音频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHadAnySourcesBefore &amp;&amp; (mAudioDecoder != <span class="literal">NULL</span> || mVideoDecoder != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// This is the first time we've found anything playable.</span></span><br><span class="line">        <span class="comment">// 设置定期查询时长</span></span><br><span class="line">        <span class="keyword">if</span> (mSourceFlags &amp; Source::FLAG_DYNAMIC_DURATION) &#123;</span><br><span class="line">            schedulePollDuration();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err; <span class="comment">// 一些异常处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;feedMoreTSData()) != OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioDecoder == <span class="literal">NULL</span> &amp;&amp; mVideoDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// We're not currently decoding anything (no audio or</span></span><br><span class="line">            <span class="comment">// video tracks found) and we just ran out of input data.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err == ERROR_END_OF_STREAM) &#123;</span><br><span class="line">                notifyListener(MEDIA_PLAYBACK_COMPLETE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyListener(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要的话，重新扫描Source</span></span><br><span class="line">    <span class="keyword">if</span> (rescan) &#123;</span><br><span class="line">        msg-&gt;post(<span class="number">100000l</span>l);</span><br><span class="line">        mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有seekToAsync()、resetAsync()、getCurrentPosition()、getFileMeta()。由于实现类似，就不一一介绍了。</p><h5 id="4-6、小结结和疑问"><a href="#4-6、小结结和疑问" class="headerlink" title="4.6、小结结和疑问"></a>4.6、小结结和疑问</h5><p>到这里，我们已经把NuPlayer主要的函数分析完了，但是问题依旧在。比如下面几个：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong></p></blockquote><p>我想接下来的分析就是解决这些疑问的。</p><h5 id="4-7、Codec-Encoder-、Decoder列表附录"><a href="#4-7、Codec-Encoder-、Decoder列表附录" class="headerlink" title="4.7、Codec Encoder 、Decoder列表附录"></a>4.7、Codec Encoder 、Decoder列表附录</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line">&lt;!--</span><br><span class="line"> <span class="number">8996</span> Decoder capabilities</span><br><span class="line"> __________________________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    | Secure-dec |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  N         |</span><br><span class="line"> | vc1      | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  Y         |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  N         |</span><br><span class="line"> | vp9      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  Y         |</span><br><span class="line"> | divx3    | <span class="number">720</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">40500</span>   |  N         |</span><br><span class="line"> | div4/<span class="number">5</span>/<span class="number">6</span> | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">10</span>      <span class="number">244800</span>  |  N         |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |  N         |</span><br><span class="line"> | mpeg2    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">40</span>      <span class="number">244800</span>  |  Y         |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">8996</span> Encoder capabilities</span><br><span class="line"> ______________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;MediaCodecs&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_audio.xml"</span> /&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_telephony.xml"</span> /&gt;</span><br><span class="line">    &lt;Settings&gt;</span><br><span class="line">        &lt;Setting name=<span class="string">"max-video-encoder-input-buffers"</span> value=<span class="string">"11"</span> /&gt;</span><br><span class="line">    &lt;/Settings&gt;</span><br><span class="line">    &lt;Encoders&gt;</span><br><span class="line">        &lt;!-- Audio Hardware  --&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-loaded-to-idle-after-allocation"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"96x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"979200"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">          ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">    &lt;/Encoders&gt;</span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2.secure"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br><span class="line">&lt;/MediaCodecs&gt;</span><br></pre></td></tr></table></figure><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Audio System（3）：Android audio system(音频系统)分析</title>
      <link href="/2018/05/25/Audio%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20audio%20system(%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F)%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/25/Audio%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20audio%20system(%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F)%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">【特别感谢 - 林学森的Android专栏】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Yangwen123 - 深入剖析Android音频系统】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Zyuanyun - Android 音频系统：从 AudioTrack 到 AudioFlinger】</a><br>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio 高通HAL 源码)</strong> </p><p>• <strong>/libhardware/modules/audio/ – (Audio 原生HAL 源码)</strong> </p><p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/hardware/libhardware_legacy/audio – (Audio legacy 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><h4 id="一-、深入剖析Android音频之AudioFlinger"><a href="#一-、深入剖析Android音频之AudioFlinger" class="headerlink" title="(一)、深入剖析Android音频之AudioFlinger"></a>(一)、深入剖析Android音频之AudioFlinger</h4><h5 id="1-0、总体框架图"><a href="#1-0、总体框架图" class="headerlink" title="1.0、总体框架图"></a>1.0、总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/31-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><p>系统启动时将执行 /system/etc/init/audioserver.rc ，运行 /system/bin/ 目录下的 audioserver 服务。audioserver.rc 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\audioserver.rc]</span><br><span class="line">service audioserver /system/bin/audioserver</span><br><span class="line">    class main</span><br><span class="line">    user audioserver</span><br><span class="line">    # media gid needed for /dev/fm (radio ) and for  /data/misc/media (tee)</span><br><span class="line">    group audio radio camera drmpc inet media mediarm net_bt net_bt_admin net_bw_acct</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    writepid /dev/cpuset/forground/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure><p>audioserver 是由同目录下main_audioserver编译生成的。</p><h5 id="1-1、AudioFlinger"><a href="#1-1、AudioFlinger" class="headerlink" title="1.1、AudioFlinger"></a>1.1、AudioFlinger</h5><p>AudioFlinger是整个音频系统的核心与难点。作为Android系统中的音频中枢，它同时也是一个系统服务，启到承上(为上层提供访问接口)启下(通过HAL来管理音频设备)的作用。只有理解了AudioFlinger，才能以此为基础更好地深入到其它模块，并且Audioserver最先启动的也是AudioFlinger，因而我们把它放在前面进行分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。<br>AudioFlinger注册名为”media.audio_flinger”的服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_flinger"</span>; &#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-1-1-AudioFlinger服务的启动和运行"><a href="#1-1-1-AudioFlinger服务的启动和运行" class="headerlink" title="1.1.1 AudioFlinger服务的启动和运行"></a>1.1.1 AudioFlinger服务的启动和运行</h5><p>AudioFlinger的构造函数，发现它只是简单地为内部一些变量做了初始化，除此之外就没有任何代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::AudioFlinger()</span><br><span class="line">    : BnAudioFlinger(),</span><br><span class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</span><br><span class="line">      mHardwareStatus(AUDIO_HW_IDLE),</span><br><span class="line">      mMasterVolume(<span class="number">1.0f</span>),</span><br><span class="line">      mMasterMute(<span class="literal">false</span>),</span><br><span class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></span><br><span class="line">      mMode(AUDIO_MODE_INVALID),</span><br><span class="line">      mBtNrecIsOff(<span class="literal">false</span>),</span><br><span class="line">      mIsLowRamDevice(<span class="literal">true</span>),</span><br><span class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</span><br><span class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</span><br><span class="line">      mSystemReady(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// unsigned instead of audio_unique_id_use_t, because ++ operator is unavailable for enum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> use = AUDIO_UNIQUE_ID_USE_UNSPECIFIED; use &lt; AUDIO_UNIQUE_ID_USE_MAX; use++) &#123;</span><br><span class="line">        <span class="comment">// zero ID has a special meaning, so unavailable</span></span><br><span class="line">        mNextUniqueIds[use] = AUDIO_UNIQUE_ID_USE_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BnAudioFlinger是由RefBase层层继承而来的，并且IServiceManager::addService的第二个参数实际上是一个强指针引用(constsp<ibinder>&amp;),因而AudioFlinger具备了强指针被第一次引用时调用onFirstRef的程序逻辑。</ibinder></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> move all this work into an Init() function */</span></span><br><span class="line">    <span class="keyword">char</span> val_str[PROPERTY_VALUE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"ro.audio.flinger_standbytime_ms"</span>, val_str, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> int_val;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">sscanf</span>(val_str, <span class="string">"%u"</span>, &amp;int_val)) &#123;</span><br><span class="line">            mStandbyTimeInNsecs = milliseconds(int_val);</span><br><span class="line">            ALOGI(<span class="string">"Using %u mSec as standby time."</span>, int_val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs;</span><br><span class="line">            ALOGI(<span class="string">"Using default %u mSec as standby time."</span>,</span><br><span class="line">                    (<span class="keyword">uint32_t</span>)(mStandbyTimeInNsecs / <span class="number">1000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mMode = AUDIO_MODE_NORMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这时开始，AudioFlinger就是一个“有意义”的实体了</p><h5 id="1-2、音频设备的管理"><a href="#1-2、音频设备的管理" class="headerlink" title="1.2、音频设备的管理"></a>1.2、音频设备的管理</h5><p>虽然AudioFlinger实体已经成功创建并初始化，但到目前为止它还是一块静态的内存空间，没有涉及到具体的工作。</p><p>从职能分布上来讲，AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。</p><p>目前Audio系统中支持的音频设备接口(Audio Interface)分为三大类，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">static const char * const audio_interfaces[] = &#123;</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_PRIMARY,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_A2DP,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_USB,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种音频设备接口由一个对应的so库提供支持。那么AudioFlinger怎么会知道当前设备中支持上述的哪些接口，每种接口又支持哪些具体的音频设备呢？这是AudioPolicyService的责任之一，即根据用户配置来指导AudioFlinger加载设备接口。</p><p>当AudioPolicyManagerBase(AudioPolicyService中持有的Policy管理者，后面小节有详细介绍)构造时，它会读取厂商关于音频设备的描述文件(audio_policy.conf)，然后据此来打开以上三类音频接口(如果存在的话)。这一过程最终会调用loadHwModule@AudioFlinger，如下所示：</p><h5 id="1-2-1、加载设备loadHwModule"><a href="#1-2-1、加载设备loadHwModule" class="headerlink" title="1.2.1、加载设备loadHwModule()"></a>1.2.1、加载设备loadHwModule()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">/*name就是前面audio_interfaces 数组成员中的字符串*/</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    if (name == NULL) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!settingsAllowed()) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    return loadHwModule_l(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数没有做实质性的工作，只是执行了加锁动作，然后接着调用下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">// loadHwModule_l() must be called with AudioFlinger::mLock held</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* Step 1. 是否已经添加了这个interface ? */</span><br><span class="line">    for (size_t i = 0; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">        if (strncmp(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, strlen(name)) == 0) &#123;</span><br><span class="line">            ALOGW(&quot;loadHwModule() module %s already loaded&quot;, name);</span><br><span class="line">            return mAudioHwDevs.keyAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_hw_device_t *dev;</span><br><span class="line">    /* Step 2. 加载audio interface */</span><br><span class="line">    int rc = load_audio_interface(name, &amp;dev);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /* Step 3. 初始化 */</span><br><span class="line">    mHardwareStatus = AUDIO_HW_INIT;</span><br><span class="line">    rc = dev-&gt;init_check(dev);</span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    /* Step 4. 添加到全局变量中 */</span><br><span class="line">    audio_module_handle_t handle = (audio_module_handle_t) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</span><br><span class="line">    mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags));</span><br><span class="line"></span><br><span class="line">    return handle;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1@ loadHwModule_l. 首先查找mAudioHwDevs是否已经添加了变量name所指示的audio interface，如果是的话直接返回。第一次进入时mAudioHwDevs的size为0，所以还会继续往下执行。</p><p>Step2@ loadHwModule_l. 加载指定的audiointerface，比如“primary”、“a2dp”或者“usb”。函数load_audio_interface用来加载设备所需的库文件，然后打开设备并创建一个audio_hw_device_t实例。音频接口设备所对应的库文件名称是有一定格式的，比如a2dp的模块名可能是audio.a2dp.so或者audio.a2dp.default.so等等。查找路径主要有两个，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\hardware.c]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">"/system/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">"/vendor/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH3 <span class="meta-string">"/odm/lib64/hw"</span></span></span><br></pre></td></tr></table></figure><p>当然，因为Android是完全开源的，各开发商可以根据自己的需要来进行相应的修改，比如下面是Google pixel 设备的音频库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell &amp;&amp; cd system/lib64/hw &amp;&amp; ls -l</span><br><span class="line">-rw-r--r-- 1 root root   30440 2009-01-01 00:00 audio.a2dp.default.so</span><br><span class="line">-rw-r--r-- 1 root root   18156 2009-01-01 00:00 audio.primary.default.so</span><br><span class="line">-rw-r--r-- 1 root root  275612 2009-01-01 00:00 audio.primary.msm8996.so</span><br><span class="line">-rw-r--r-- 1 root root   34540 2009-01-01 00:00 audio.r_submix.default.so</span><br><span class="line">-rw-r--r-- 1 root root   22248 2009-01-01 00:00 audio.usb.default.so</span><br><span class="line">-rw-r--r-- 1 root root   96096 2009-01-01 00:00 audio_policy.default.so</span><br><span class="line">-rw-r--r-- 1 root root 1637208 2009-01-01 00:00 bluetooth.default.so</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>Step3@ loadHwModule_l，进行初始化操作。其中init_check是为了确定这个audio interface是否已经成功初始化，0是成功，其它值表示失败。接下来如果这个device支持主音量，我们还需要通过set_master_volume进行设置。在每次操作device前，都要先改变mHardwareStatus的状态值，操作结束后将其复原为AUDIO_HW_IDLE(根据源码中的注释，这样做是为了方便dump时正确输出内部状态，这里我们就不去深究了)。</p><p>Step4@ loadHwModule_l. 把加载后的设备添加入mAudioHwDevs键值对中，其中key的值是由nextUniqueId生成的，这样做保证了这个audiointerface拥有全局唯一的id号。</p><p>完成了audiointerface的模块加载只是万里长征的第一步。因为每一个interface包含的设备通常不止一个，Android系统目前支持的音频设备如下列表所示：<br> Android系统支持的音频设备列表(输出)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</span><br><span class="line">static uint32_t audio_device_conv_table[][HAL_API_REV_NUM] =</span><br><span class="line">&#123;</span><br><span class="line">    /* output devices */</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_EARPIECE, AUDIO_DEVICE_OUT_EARPIECE &#125;,//</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_SPEAKER, AUDIO_DEVICE_OUT_SPEAKER &#125;,//SPEAKER</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADSET, AUDIO_DEVICE_OUT_WIRED_HEADSET &#125;,//HEADSET</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADPHONE, AUDIO_DEVICE_OUT_WIRED_HEADPHONE &#125;,//HEADPHONE</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO, AUDIO_DEVICE_OUT_BLUETOOTH_SCO &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_AUX_DIGITAL, AUDIO_DEVICE_OUT_AUX_DIGITAL &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET, AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET, AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DEFAULT, AUDIO_DEVICE_OUT_DEFAULT &#125;,//默认设备</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可能会有疑问：</p><p>Ø 这么多的输出设备，那么当我们回放音频流(录音也是类似的情况)时，该选择哪一种呢？</p><p>Ø 而且当前系统中audio interface也很可能不止一个，应该如何选择？</p><p>显然这些决策工作将由AudioPolicyService来完成，我们会在下一小节做详细阐述。这里先给大家分析下，AudioFlinger是如何打开一个Output通道的(一个audiointerface可能包含若干个output)。</p><h5 id="1-2-2、打开音频输出通道openOutput"><a href="#1-2-2、打开音频输出通道openOutput" class="headerlink" title="1.2.2、打开音频输出通道openOutput()"></a>1.2.2、打开音频输出通道openOutput()</h5><p>打开音频输出通道(output)在AudioFlinger中对应的接口是openOutput()，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                  <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</span><br><span class="line">                                  <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</span><br><span class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</span><br><span class="line">        *latencyMs = thread-&gt;latency();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notify client processes of the new output creation</span></span><br><span class="line">        thread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the first primary output opened designates the primary hw device</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Using module %d has the primary audio interface"</span>, <span class="keyword">module</span>);</span><br><span class="line">            mPrimaryHardwareDev = thread-&gt;getOutput()-&gt;audioHwDev;</span><br><span class="line"></span><br><span class="line">            <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</span><br><span class="line">            mHardwareStatus = AUDIO_HW_SET_MODE;</span><br><span class="line">            mPrimaryHardwareDev-&gt;hwDevice()-&gt;set_mode(mPrimaryHardwareDev-&gt;hwDevice(), mMode);</span><br><span class="line">            mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用 openOutput_l()函数从处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                                            <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">                                                            <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Step 1. 查找相应的audio interface</span></span><br><span class="line"><span class="comment">    AudioHwDevice *outHwDev = findSuitableHwDev_l(module, devices);</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    AudioStreamOut *outputStream = NULL;</span></span><br><span class="line"><span class="comment">     /*Step 2. 为设备打开一个输出流*/</span></span><br><span class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    <span class="comment">/*Step 3.创建PlaybackThread*/</span></span><br><span class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这段代码中，颜色加深的部分是我们接下来分析的重点，主要还是围绕outHwDev这个变量所做的一系列操作，即：</p><p>·        查找合适的音频接口设备( findSuitableHwDev_l() )</p><p>·        创建音频输出流( 通过openOutputStream()创建AudioStreamOut )</p><p>·        创建播放线程( PlaybackThread )</p><p>outHwDev用于记录一个打开的音频接口设备，它的数据类型是audio_hw_device_t，是由HAL规定的一个音频接口设备所应具有的属性集合，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioHwDevice</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">audio_module_handle_t</span> handle() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHandle; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">moduleName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mModuleName; &#125;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> *hwDevice() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice; &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> version() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice-&gt;common.version; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> openOutputStream(</span><br><span class="line">            AudioStreamOut **ppStreamOut,</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> handle,</span><br><span class="line">            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">            <span class="keyword">audio_output_flags_t</span> flags,</span><br><span class="line">            struct audio_config *config,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *address);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">audio_module_handle_t</span> mHandle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span>          mModuleName;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> * <span class="keyword">const</span>   mHwDevice;</span><br><span class="line">    <span class="keyword">const</span> Flags                 mFlags;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中common代表了HAL层所有设备的共有属性;set_master_volume、set_mode、open_output_stream分别为我们设置audio interface的主音量、设置音频模式类型(比如AUDIO_MODE_RINGTONE、AUDIO_MODE_IN_CALL等等)、打开输出数据流提供了接口。</p><p>接下来我们分步来阐述。</p><h5 id="1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l"><a href="#1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l" class="headerlink" title="1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()"></a>1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()</h5><p>Step1@ AudioFlinger::openOutput. 在openOutput中，设备outHwDev是通过查找当前系统来得到的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioHwDevice* AudioFlinger::findSuitableHwDev_l(</span><br><span class="line">        <span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">        <span class="keyword">audio_devices_t</span> devices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if module is 0, the request comes from an old policy manager and we should load</span></span><br><span class="line">    <span class="comment">// well known modules</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"findSuitableHwDev_l() loading well know audio hw modules"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(audio_interfaces); i++) &#123;</span><br><span class="line">            loadHwModule_l(audio_interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then try to find a module supporting the requested device.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">            AudioHwDevice *audioHwDevice = mAudioHwDevs.valueAt(i);</span><br><span class="line">            <span class="keyword">audio_hw_device_t</span> *dev = audioHwDevice-&gt;hwDevice();</span><br><span class="line">            <span class="keyword">if</span> ((dev-&gt;get_supported_devices != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (dev-&gt;get_supported_devices(dev) &amp; devices) == devices)</span><br><span class="line">                <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// check a match for the requested module handle</span></span><br><span class="line">        AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">if</span> (audioHwDevice != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量module值为0的情况，是为了兼容之前的Audio Policy而特别做的处理。当module等于0时，首先加载所有已知的音频接口设备，然后再根据devices来确定其中符合要求的。入参devices的值实际上来源于“ Android系统支持的音频设备列表(输出)”所示的设备。可以看到，enum中每个设备类型都对应一个特定的比特位，因而上述代码段中可以通过“与运算”来找到匹配的设备。</p><p>当modules为非0值时，说明Audio Policy指定了具体的设备id号，这时就通过查找全局的mAudioHwDevs变量来确认是否存在符合要求的设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.h]</span><br><span class="line">DefaultKeyedVector&lt;audio_module_handle_t, AudioHwDevice*&gt;  mAudioHwDevs;</span><br></pre></td></tr></table></figure><p>变量mAudioHwDevs是一个Vector，以audio_module_handle_t为key，每一个handle值唯一确定了已经添加的音频设备。那么在什么时候添加设备呢？</p><p>一种情况就是前面看到的modules为0时，会load所有潜在设备，另一种情况就是AudioPolicyManagerBase在构造时会预加载所有audio_policy.conf中所描述的output。不管是哪一种情况，最终都会调用loadHwModuleàloadHwModule_l，这个函数我们开头就分析过了。</p><p>如果modules为非0，且从mAudioHwDevs中也找不到符合要求的设备，程序并不会就此终结——它会退而求其次，遍历数组中的所有元素寻找支持devices的任何一个audio interface。</p><h5 id="1-2-2-2、创建音频输出流openOutputStream"><a href="#1-2-2-2、创建音频输出流openOutputStream" class="headerlink" title="1.2.2.2、创建音频输出流openOutputStream()"></a>1.2.2.2、创建音频输出流openOutputStream()</h5><p>Step2@ AudioFlinger::openOutput，调用openOutputStream()函数打开一个AudioStreamOut 。源码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.cpp]</span><br><span class="line">status_t AudioHwDevice::openOutputStream(</span><br><span class="line">        AudioStreamOut **ppStreamOut,</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        audio_output_flags_t flags,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct audio_config originalConfig = *config;</span><br><span class="line">    AudioStreamOut *outputStream = new AudioStreamOut(this, flags);</span><br><span class="line">    </span><br><span class="line">    status_t status = outputStream-&gt;open(handle, devices, config, address);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    *ppStreamOut = outputStream;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成AudioStreamOut对象并赋值给ppStreamOut ，进一步调用了AudioStreamOut-&gt;open()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioStreamOut.cpp]</span><br><span class="line">status_t AudioStreamOut::open(</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line">    audio_stream_out_t *outStream;</span><br><span class="line">    .......</span><br><span class="line">    int status = hwDev()-&gt;open_output_stream(</span><br><span class="line">            hwDev(),</span><br><span class="line">            handle,</span><br><span class="line">            devices,</span><br><span class="line">            customFlags,</span><br><span class="line">            config,</span><br><span class="line">            &amp;outStream,</span><br><span class="line">            address);</span><br><span class="line">    ......</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即会通过audio_hw_device_t-&gt;-&gt;open_output_stream()创建音频输出流</p><h5 id="1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream"><a href="#1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream" class="headerlink" title="1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()"></a>1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()</h5><p>我们先看一下HAL层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open(const hw_module_t *module, const char *name,</span><br><span class="line">                     hw_device_t **device)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    adev = calloc(1, sizeof(struct audio_device));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;adev-&gt;lock, (const pthread_mutexattr_t *) NULL);</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    adev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    adev-&gt;device.common.module = (struct hw_module_t *)module;</span><br><span class="line">    adev-&gt;device.common.close = adev_close;</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    adev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    adev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    adev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    adev-&gt;device.set_master_mute = adev_set_master_mute;</span><br><span class="line">    adev-&gt;device.get_master_mute = adev_get_master_mute;</span><br><span class="line">    adev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    adev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    adev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    adev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    adev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    adev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    adev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    adev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    adev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    adev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当调用open_output_stream 就会调用adev_open_output_stream。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open_output_stream(struct audio_hw_device *dev,</span><br><span class="line">                                   audio_io_handle_t handle,</span><br><span class="line">                                   audio_devices_t devices,</span><br><span class="line">                                   audio_output_flags_t flags,</span><br><span class="line">                                   struct audio_config *config,</span><br><span class="line">                                   struct audio_stream_out **stream_out,</span><br><span class="line">                                   const char *address __unused)</span><br><span class="line">&#123;</span><br><span class="line">    struct audio_device *adev = (struct audio_device *)dev;</span><br><span class="line">    struct stream_out *out;</span><br><span class="line">    int i, ret;</span><br><span class="line">    </span><br><span class="line">    *stream_out = NULL;</span><br><span class="line">    out = (struct stream_out *)calloc(1, sizeof(struct stream_out));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    out-&gt;stream.common.get_sample_rate = out_get_sample_rate;</span><br><span class="line">    out-&gt;stream.common.set_sample_rate = out_set_sample_rate;</span><br><span class="line">    out-&gt;stream.common.get_buffer_size = out_get_buffer_size;</span><br><span class="line">    out-&gt;stream.common.get_channels = out_get_channels;</span><br><span class="line">    out-&gt;stream.common.get_format = out_get_format;</span><br><span class="line">    out-&gt;stream.common.set_format = out_set_format;</span><br><span class="line">    out-&gt;stream.common.standby = out_standby;</span><br><span class="line">    out-&gt;stream.common.dump = out_dump;</span><br><span class="line">    out-&gt;stream.common.set_parameters = out_set_parameters;</span><br><span class="line">    out-&gt;stream.common.get_parameters = out_get_parameters;</span><br><span class="line">    out-&gt;stream.common.add_audio_effect = out_add_audio_effect;</span><br><span class="line">    out-&gt;stream.common.remove_audio_effect = out_remove_audio_effect;</span><br><span class="line">    out-&gt;stream.get_latency = out_get_latency;</span><br><span class="line">    out-&gt;stream.set_volume = out_set_volume;</span><br><span class="line">#ifdef NO_AUDIO_OUT</span><br><span class="line">    out-&gt;stream.write = out_write_for_no_output;</span><br><span class="line">#else</span><br><span class="line">    out-&gt;stream.write = out_write;</span><br><span class="line">#endif</span><br><span class="line">    out-&gt;stream.get_render_position = out_get_render_position;</span><br><span class="line">    out-&gt;stream.get_next_write_timestamp = out_get_next_write_timestamp;</span><br><span class="line">    out-&gt;stream.get_presentation_position = out_get_presentation_position;</span><br><span class="line"></span><br><span class="line">    out-&gt;af_period_multiplier  = out-&gt;realtime ? af_period_multiplier : 1;</span><br><span class="line">    out-&gt;standby = 1;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    *stream_out = &amp;out-&gt;stream;</span><br><span class="line">    ALOGV(&quot;%s: exit&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据音频流的熟悉做一系列初始化操作。转了一大圈，继续看看</p><h5 id="1-2-2-3、创建播放线程-PlaybackThread"><a href="#1-2-2-3、创建播放线程-PlaybackThread" class="headerlink" title="1.2.2.3、创建播放线程(PlaybackThread)"></a>1.2.2.3、创建播放线程(PlaybackThread)</h5><p>Step3@ AudioFlinger::openOutput. 既然通道已经打开，那么由谁来往通道里放东西呢？这就是PlaybackThread。这里分三种不同的情况：<br>·        OffloadThread</p><p>·        DirectOutput</p><p>如果不需要混音</p><p>·        Mixer</p><p>需要混音</p><p>这三种情况分别对应DirectOutputThread、OffloadThread和MixerThread两种线程。我们以后者为例来分析下PlaybackThread的工作模式，也会后面小节打下基础。回放线程（PlaybackThread 及其派生的子类）和录制线程（RecordThread）进行的，先简单看看回放线程和录制线程类关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/32-Audio-system-mixerthread.jpg" alt="Alt text"></p><p>·       ThreadBase：PlaybackThread 和 RecordThread 的基类<br>·       RecordThread：录制线程类，由 ThreadBase 派生<br>·       PlaybackThread：回放线程基类，同由 ThreadBase 派生<br>·       MixerThread：混音回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流，MixerThread 可以把多个音轨的数据混音后再输出<br>·       DirectOutputThread：直输回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_DIRECT 的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可<br>·       DuplicatingThread：复制回放线程类，由 MixerThread 派生，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB 声卡设备同时输出<br>·       OffloadThread：硬解回放线程类，由 DirectOutputThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流，这种音频流未经软件解码的（一般是 MP3、AAC 等格式的数据），需要输出到硬件解码器，由硬件解码器解码成 PCM 数据</p><p>PlaybackThread 中有个极为重要的函数 threadLoop()，当 PlaybackThread 被强引用时，threadLoop() 会真正运行起来进入循环主体，处理音频流数据相关事务，threadLoop() 大致流程如下（以 MixerThread 为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\Threads.cpp]</span><br><span class="line">bool AudioFlinger::PlaybackThread::threadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    while (!exitPending())</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        &#123; // scope for mLock</span><br><span class="line"></span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">            processConfigEvents_l();</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line"></span><br><span class="line">            if ((!mActiveTracks.size() &amp;&amp; systemTime() &gt; mStandbyTimeNs) ||</span><br><span class="line">                                   isSuspended()) &#123;</span><br><span class="line">                // put audio hardware into standby after short delay</span><br><span class="line">                if (shouldStandby_l()) &#123;</span><br><span class="line"></span><br><span class="line">                    threadLoop_standby();</span><br><span class="line"></span><br><span class="line">                    mStandby = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // mMixerStatusIgnoringFastTracks is also updated internally</span><br><span class="line">            mMixerStatus = prepareTracks_l(&amp;tracksToRemove);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125; // mLock scope ends</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (mBytesRemaining == 0) &#123;</span><br><span class="line">            mCurrentWriteLength = 0;</span><br><span class="line">            if (mMixerStatus == MIXER_TRACKS_READY) &#123;</span><br><span class="line">                // threadLoop_mix() sets mCurrentWriteLength</span><br><span class="line">                threadLoop_mix();</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!waitingAsyncCallback()) &#123;</span><br><span class="line">            // mSleepTimeUs == 0 means we must write to audio hardware</span><br><span class="line">            if (mSleepTimeUs == 0) &#123;</span><br><span class="line">                // ......</span><br><span class="line">                if (mBytesRemaining) &#123;</span><br><span class="line">                    // FIXME rewrite to reduce number of system calls</span><br><span class="line">                    ret = threadLoop_write();</span><br><span class="line">                    lastWriteFinished = systemTime();</span><br><span class="line">                    delta = lastWriteFinished - mLastWriteTime;</span><br><span class="line">                    if (ret &lt; 0) &#123;</span><br><span class="line">                        mBytesRemaining = 0;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBytesWritten += ret;</span><br><span class="line">                        mBytesRemaining -= ret;</span><br><span class="line">                        mFramesWritten += ret / mFrameSize;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally let go of removed track(s), without the lock held</span><br><span class="line">        // since we can&apos;t guarantee the destructors won&apos;t acquire that</span><br><span class="line">        // same lock.  This will also mutate and push a new fast mixer state.</span><br><span class="line">        threadLoop_removeTracks(tracksToRemove);</span><br><span class="line">        tracksToRemove.clear();</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadLoop_exit();</span><br><span class="line"></span><br><span class="line">    if (!mStandby) &#123;</span><br><span class="line">        threadLoop_standby();</span><br><span class="line">        mStandby = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLoop() 循环的条件是 exitPending() 返回 false，如果想要 PlaybackThread 结束循环，则可以调用 requestExit() 来请求退出；<br>processConfigEvents_l() ：处理配置事件；当有配置改变的事件发生时，需要调用 sendConfigEvent_l() 来通知 PlaybackThread，这样 PlaybackThread 才能及时处理配置事件；常见的配置事件是切换音频通路；<br>检查此时此刻是否符合 standby 条件，比如当前并没有 ACTIVE 状态的 Track（mActiveTracks.size() = 0），那么调用 threadLoop_standby() 关闭音频硬件设备以节省能耗；<br>prepareTracks_l()： 准备音频流和混音器，该函数非常复杂，这里不详细分析了，仅列一下流程要点：<br>遍历 mActiveTracks，逐个处理 mActiveTracks 上的 Track，检查该 Track 是否为 ACTIVE 状态；<br>如果 Track 设置是 ACTIVE 状态，则再检查该 Track 的数据是否准备就绪了；<br>根据音频流的音量值、格式、声道数、音轨的采样率、硬件设备的采样率，配置好混音器参数；<br>如果 Track 的状态是 PAUSED 或 STOPPED，则把该 Track 添加到 tracksToRemove 向量中；<br>threadLoop_mix()：读取所有置了 ACTIVE 状态的音频流数据，混音器开始处理这些数据；<br>threadLoop_write()： 把混音器处理后的数据写到输出流设备；<br>threadLoop_removeTracks()： 把 tracksToRemove 上的所有 Track 从 mActiveTracks 中移除出来；这样下一次循环时就不会处理这些 Track 了。<br>这里说说 PlaybackThread 与输出流设备的关系：PlaybackThread 实例与输出流设备是一一对应的，比方说 OffloadThread 只会将音频数据输出到 compress_offload 设备中，MixerThread(with FastMixer) 只会将音频数据输出到 low_latency 设备中。</p><p>从 Audio HAL 中，我们通常看到如下 4 种输出流设备，分别对应着不同的播放场景：</p><p>primary_out：主输出流设备，用于铃声类声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_PRIMARY 的音频流和一个 MixerThread 回放线程实例<br>low_latency：低延迟输出流设备，用于按键音、游戏背景音等对时延要求高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_FAST 的音频流和一个 MixerThread 回放线程实例<br>deep_buffer：音乐音轨输出流设备，用于音乐等对时延要求不高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流和一个 MixerThread 回放线程实例<br>compress_offload：硬解输出流设备，用于需要硬件解码的数据输出，对应着标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流和一个 OffloadThread 回放线程实例<br>其中 primary_out 设备是必须声明支持的，而且系统启动时就已经打开 primary_out 设备并创建好对应的 MixerThread 实例。其他类型的输出流设备并非必须声明支持的，主要是看硬件上有无这个能力。</p><p>可能有人产生这样的疑问：既然 primary_out 设备一直保持打开，那么能耗岂不是很大？这里阐释一个概念：输出流设备属于逻辑设备，并不是硬件设备。所以即使输出流设备一直保持打开，只要硬件设备不工作，那么就不会影响能耗。那么硬件设备什么时候才会打开呢？答案是 PlaybackThread 将音频数据写入到输出流设备时。</p><p>下图简单描述 AudioTrack、PlaybackThread、输出流设备三者的对应关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/33-Audio-system-Audio-playback-.png" alt="Alt text"></p><p>我们可以这么说：输出流设备决定了它对应的 PlaybackThread 是什么类型。怎么理解呢？意思是说：只有支持了该类型的输出流设备，那么该类型的 PlaybackThread 才有可能被创建。举个例子：只有硬件上具备硬件解码器，系统才建立 compress_offload 设备，然后播放 mp3 格式的音乐文件时，才会创建 OffloadThread 把数据输出到 compress_offload 设备上；反之，如果硬件上并不具备硬件解码器，系统则不应该建立 compress_offload 设备，那么播放 mp3 格式的音乐文件时，通过 MixerThread 把数据输出到其他输出流设备上。</p><p>那么有无可能出现这种情况：底层并不支持 compress_offload 设备，但偏偏有个标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流送到 AudioFlinger 了呢？这是不可能的。系统启动时，会检查并保存输入输出流设备的支持信息；播放器在播放 mp3 文件时，首先看 compress_offload 设备是否支持了，如果支持，那么不进行软件解码，直接把数据标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD；如果不支持，那么先进行软件解码，然后把解码好的数据标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER，前提是 deep_buffer 设备是支持了的；如果 deep_buffer 设备也不支持，那么把数据标识为 AUDIO_OUTPUT_FLAG_PRIMARY。</p><p>系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 MixerThread 了；而此时 DirectOutputThread 与 OffloadThread 不会被创建，直到标识为 AUDIO_OUTPUT_FLAG_DIRECT/AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流需要输出时，才开始创建 DirectOutputThread/OffloadThread 和打开 direct_out/compress_offload 设备。这一点请参考如下代码，注释非常清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    // ......</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span><br><span class="line">    // open all output streams needed to access attached devices</span><br><span class="line">    // ......</span><br><span class="line">    for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        // ......</span><br><span class="line">        // open all output streams needed to access attached devices</span><br><span class="line">        // except for direct output streams that are only opened when they are actually</span><br><span class="line">        // required by an app.</span><br><span class="line">        // This also validates mAvailableOutputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            if ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">            audio_io_handle_t output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        // open input streams needed to access attached devices to validate</span><br><span class="line">        // mAvailableInputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            status_t status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mpClientInterface-&gt;openOutput() 最终会调用到 AudioFlinger::openOutput()：打开输出流设备，并创建 PlaybackThread 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t AudioFlinger::openOutput(audio_module_handle_t module,</span><br><span class="line">                                  audio_io_handle_t *output,</span><br><span class="line">                                  audio_config_t *config,</span><br><span class="line">                                  audio_devices_t *devices,</span><br><span class="line">                                  const String8&amp; address,</span><br><span class="line">                                  uint32_t *latencyMs,</span><br><span class="line">                                  audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags);</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module,</span><br><span class="line">                                                            audio_io_handle_t *output,</span><br><span class="line">                                                            audio_config_t *config,</span><br><span class="line">                                                            audio_devices_t devices,</span><br><span class="line">                                                            const String8&amp; address,</span><br><span class="line">                                                            audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line">    // 分配全局唯一的 audio_io_handle_t，可以理解它是回放线程的索引号</span><br><span class="line">    if (*output == AUDIO_IO_HANDLE_NONE) &#123;</span><br><span class="line">        *output = nextUniqueId(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 打开音频输出流设备，HAL 层根据 flags 选择打开相关类型的输出流设备</span><br><span class="line">    AudioStreamOut *outputStream = NULL;</span><br><span class="line">    status_t status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.string());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line"></span><br><span class="line">    if (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 音频流，创建 OffloadThread 实例</span><br><span class="line">            thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created offload output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_DIRECT 音频流，创建 DirectOutputThread 实例</span><br><span class="line">            thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created direct output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他标识的音频流，创建 MixerThread 实例</span><br><span class="line">            thread = new MixerThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created mixer output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        // 把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中</span><br><span class="line">        // 键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一</span><br><span class="line">        // 一对应的关系，所以拿到一个 audio_io_handle_t，就能找到它对应的 PlaybackThread</span><br><span class="line">        // 所以可以理解 audio_io_handle_t 为 PlaybackThread 的索引号</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-3、AudioFlinger-音频流管理"><a href="#1-2-3、AudioFlinger-音频流管理" class="headerlink" title="1.2.3、AudioFlinger 音频流管理"></a>1.2.3、AudioFlinger 音频流管理</h5><p>AudioFlinger 音频流管理由 AudioFlinger::PlaybackThread::Track 实现，Track 与 AudioTrack 是一对一的关系，一个 AudioTrack 创建后，那么 AudioFlinger 会创建一个 Track 与之对应；PlaybackThread 与 AudioTrack/Track 是一对多的关系，一个 PlaybackThread 可以挂着多个 Track。</p><p>具体来说：AudioTrack 创建后，AudioPolicyManager 根据 AudioTrack 的输出标识和流类型，找到对应的输出流设备和 PlaybackThread（如果没有找到的话，则系统会打开对应的输出流设备并新建一个 PlaybackThread），然后创建一个 Track 并挂到这个 PlaybackThread 下面。</p><p>PlaybackThread 有两个私有成员向量与此强相关：</p><p>·       mTracks：该 PlaybackThread 创建的所有 Track 均添加保存到这个向量中<br>·       mActiveTracks：只有需要播放（设置了 ACTIVE 状态）的 Track 会添加到这个向量中；PlaybackThread 会从该向量上找到所有设置了 ACTIVE 状态的 Track，把这些 Track 数据混音后写到输出流设备<br>音频流控制最常用的三个接口：</p><p>AudioFlinger::PlaybackThread::Track::start：开始播放：把该 Track 置 ACTIVE 状态，然后添加到 mActiveTracks 向量中，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::Track::stop：停止播放：把该 Track 置 STOPPED 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::Track::pause：暂停播放：把该 Track 置 PAUSING 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::threadLoop() 得悉情况有变后，调用 prepareTracks_l() 重新准备音频流和混音器：ACTIVE 状态的 Track 会添加到 mActiveTracks，此外的 Track 会从 mActiveTracks 上移除出来，然后重新准备 AudioMixer。</p><p>可见这三个音频流控制接口是非常简单的，主要是设置一下 Track 的状态，然后发个事件通知 PlaybackThread 就行，复杂的处理都在 AudioFlinger::PlaybackThread::threadLoop() 中了。</p><h4 id="二-、深入剖析Android音频之AudioPolicyService"><a href="#二-、深入剖析Android音频之AudioPolicyService" class="headerlink" title="(二)、深入剖析Android音频之AudioPolicyService"></a>(二)、深入剖析Android音频之AudioPolicyService</h4><p>AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。AudioPolicyService根据用户配置来指导AudioFlinger加载设备接口，起到路由功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_policy"</span>; &#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService注册名为”media.audio_policy”的服务。<br>首先看看AudioPolicyService的onFirstRef()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"></span><br><span class="line">AudioPolicyService::AudioPolicyService()</span><br><span class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        <span class="comment">/* Step 1:创建AudioCommandThread线程 */</span></span><br><span class="line">        <span class="comment">// start tone playback thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start audio commands thread</span></span><br><span class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start output activity command thread</span></span><br><span class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_LEGACY_AUDIO_POLICY</span></span><br><span class="line">         <span class="comment">// 使用老版本的 audio policy 初始化方式</span></span><br><span class="line">        ....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 使用最新的 audio policy 初始化方式</span></span><br><span class="line">        ALOGI(<span class="string">"AudioPolicyService CSTOR in new mode"</span>);</span><br><span class="line">        <span class="comment">/* Step 2:创建AudioPolicyClient、 AudioPolicyManager */</span></span><br><span class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</span><br><span class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load audio processing modules</span></span><br><span class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        mAudioPolicyEffects = audioPolicyEffects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看总体时序图：</p><h5 id="2-1、Step-1-创建AudioCommandThread线程"><a href="#2-1、Step-1-创建AudioCommandThread线程" class="headerlink" title="2.1、Step 1:创建AudioCommandThread线程"></a>2.1、Step 1:创建AudioCommandThread线程</h5><p>在AudioPolicyService对象构造过程中，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程：</p><p>1、 ApmTone用于播放tone音；</p><p>2、 ApmAudio用于执行audio命令；</p><p>3、ApmOutput用于执行输出命令；</p><p>在第一次强引用AudioCommandThread线程对象时，AudioCommandThread的onFirstRef函数被回调，在此启动线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。</p><h5 id="2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager"><a href="#2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager" class="headerlink" title="2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager"></a>2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager</h5><p>首先创建AudioPolicyClient </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioPolicyClient</span> :</span> <span class="keyword">public</span> AudioPolicyClientInterface</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        AudioPolicyClient(AudioPolicyService *service) : mAudioPolicyService(service) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~AudioPolicyClient() &#123;&#125;</span><br><span class="line">        <span class="comment">// loads a HW module.</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_module_handle_t <span class="title">loadHwModule</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> status_t <span class="title">openOutput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_io_handle_t</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">uint32_t</span> *latencyMs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_output_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// opens an audio input</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_io_handle_t <span class="title">openInput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_io_handle_t</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_source_t</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_input_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        AudioPolicyService *mAudioPolicyService;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>createAudioPolicyManager() 函数的实现位于 frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cpp文件中。查看源码后我们会发现它实际上是直接调用了 AudioPolicyManager 的构造函数。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\manager\AudioPolicyFactory.cpp]</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">AudioPolicyInterface* <span class="title">createAudioPolicyManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AudioPolicyClientInterface *clientInterface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AudioPolicyManager(clientInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、创建AudioPolicyManager"><a href="#2-3、创建AudioPolicyManager" class="headerlink" title="2.3、创建AudioPolicyManager()"></a>2.3、创建AudioPolicyManager()</h5><p>总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/34-Audio-system-CreateAudioPolicyManager.png" alt="Alt text"></p><p>AudioPolicyManager 的构造函数将解析音频策略配置文件，从而获取到设备所支持的音频设备信息（包括设备是否支持 Offload、Direct 模式输出，各输入输出 profile 所支持的采样率、通道数、数据格式等），加载全部 HwModule，为之创建所有非 direct 输出类型的 outputStream 和所有 inputStream，并创建相应的 playbackThread 或 recordThread 线程。需要注意的是，Android 7.0上的音频策略配置文件开始使用 XML 格式，其文件名为 audio_policy_configuration.xml，</p><p>而在之前的版本上音频策略配置文件为 audio_policy.conf。frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp 中 AudioPolicyManager 构造函数的关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    :</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AUDIO_POLICY_TEST</span></span><br><span class="line">    Thread(<span class="literal">false</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//AUDIO_POLICY_TEST</span></span></span><br><span class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</span><br><span class="line">    mA2dpSuspended(<span class="literal">false</span>),</span><br><span class="line">    mAudioPortGeneration(<span class="number">1</span>),</span><br><span class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconMuted(<span class="literal">false</span>),</span><br><span class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</span><br><span class="line">    mMasterMono(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy_configuration.xml</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></span><br><span class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</span><br><span class="line">    PolicySerializer serializer;</span><br><span class="line">    <span class="comment">// 解析 xml 配置文件，将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> (serializer.deserialize(AUDIO_POLICY_XML_CONFIG_FILE, config) != NO_ERROR) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy.conf</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</span><br><span class="line">    <span class="comment">// 优先解析 vendor 目录下的 conf 配置文件，然后解析 device 目录下的 conf 配置文件。</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</span><br><span class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</span><br><span class="line">        config.setDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></span><br><span class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);    <span class="comment">// 设置音量调节曲线</span></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 依次加载 HwModule 并打开其所含 profile 的 outputStream 及 inputStream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</span><br><span class="line">        <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"could not open HW module %s"</span>, mHwModules[i]-&gt;getName());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open all output streams needed to access attached devices</span></span><br><span class="line">        <span class="comment">// except for direct output streams that are only opened when they are actually</span></span><br><span class="line">        <span class="comment">// required by an app.</span></span><br><span class="line">        <span class="comment">// This also validates mAvailableOutputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有非 direct 类型 profile 的 outputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 如果当前操作的 module.profile 是 direct 类型，则不为其打开 outputStream</span></span><br><span class="line">            <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            sp&lt;SwAudioOutputDescriptor&gt; outputDesc = <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile,</span><br><span class="line">                                                                                 mpClientInterface);</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;devicesForType = supportedDevices.getDevicesFromType(profileType);</span><br><span class="line">            String8 address = devicesForType.size() &gt; <span class="number">0</span> ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            outputDesc-&gt;mDevice = profileType;</span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = outputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = outputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = outputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 outputStream 并创建 playbackThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open input streams needed to access attached devices to validate</span></span><br><span class="line">        <span class="comment">// mAvailableInputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有 profile 的 inputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; inProfile = mHwModules[i]-&gt;mInputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            sp&lt;AudioInputDescriptor&gt; inputDesc =</span><br><span class="line">                    <span class="keyword">new</span> AudioInputDescriptor(inProfile);</span><br><span class="line"></span><br><span class="line">            inputDesc-&gt;mDevice = profileType;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            <span class="comment">// find the address</span></span><br><span class="line">            DeviceVector inputDevices = mAvailableInputDevices.getDevicesFromType(profileType);</span><br><span class="line">            <span class="comment">//   the inputs vector must be of size 1, but we don't want to crash here</span></span><br><span class="line">            String8 address = inputDevices.size() &gt; <span class="number">0</span> ? inputDevices.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line">            ALOGV(<span class="string">"  for input device 0x%x using address %s"</span>, profileType, address.<span class="built_in">string</span>());</span><br><span class="line">            ALOGE_IF(inputDevices.size() == <span class="number">0</span>, <span class="string">"Input device list is empty!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = inputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = inputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = inputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> input = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 inputStream 并创建 recordThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();    <span class="comment">// 更新系统缓存的音频输出设备信息</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyManager对象构造过程中主要完成以下几个步骤：</p><p>1、  加载audio_policy_configuration.xml或者audio_policy.conf配置文件</p><p>2、 初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</p><p>3、  加载audio policy硬件抽象库：mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;mName)</p><p>4、  打开对应的outputStream和inputStream  ： mpClientInterface-&gt;openOutput()、mpClientInterface-&gt;openInput</p><p>5、   更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</p><h5 id="2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件"><a href="#2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件" class="headerlink" title="2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件"></a>2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件</h5><p><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/audio_policy_configuration.xml" target="_blank" rel="noopener">audio_policy_configuration.xml</a><br>audio_policy.conf同时定义了多个audio 接口，每一个audio 接口包含若干output和input，而每个output和input又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/35-Audio-system-audio_policy.conf.png" alt="Alt text"></p><h5 id="2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled"><a href="#2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled" class="headerlink" title="2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)"></a>2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</h5><p>在AudioPolicyManagerBase中定义了音量调节对应的音频流描述符数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//audio_policy_volumes.xml</span><br><span class="line">const AudioPolicyManagerBase::VolumeCurvePoint</span><br><span class="line">            *AudioPolicyManagerBase::sVolumeProfiles[AudioSystem::NUM_STREAM_TYPES]</span><br><span class="line">                                                   [AudioPolicyManagerBase::DEVICE_CATEGORY_CNT] = &#123;</span><br><span class="line">    &#123; // AUDIO_STREAM_VOICE_CALL</span><br><span class="line">        sDefaultVoiceVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sSpeakerVoiceVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultVoiceVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; // AUDIO_STREAM_SYSTEM</span><br><span class="line">        sHeadsetSystemVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sDefaultSystemVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultSystemVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>initializeVolumeCurves()函数就是初始化该数组元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManagerBase::initializeVolumeCurves()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AudioSystem::NUM_STREAM_TYPES; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DEVICE_CATEGORY_CNT; j++) &#123;</span><br><span class="line">            mStreams[i].mVolumeCurve[j] =</span><br><span class="line">                    sVolumeProfiles[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check availability of DRC on speaker path: if available, override some of the speaker curves</span></span><br><span class="line">    <span class="keyword">if</span> (mSpeakerDrcEnabled) &#123;</span><br><span class="line">        mStreams[AUDIO_STREAM_SYSTEM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sDefaultSystemVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_RING].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_ALARM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_NOTIFICATION].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3、加载audio-policy硬件抽象库loadHwModule"><a href="#2-3-3、加载audio-policy硬件抽象库loadHwModule" class="headerlink" title="2.3.3、加载audio policy硬件抽象库loadHwModule()"></a>2.3.3、加载audio policy硬件抽象库loadHwModule()</h5><p>我们直接分析AudioFlinger::loadHwModule_l()中的load_audio_interface()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int load_audio_interface(const char *if_name, audio_hw_device_t **dev)</span><br><span class="line">&#123;</span><br><span class="line">    const hw_module_t *mod;</span><br><span class="line">    int rc;</span><br><span class="line">    //根据名字加载audio_module模块  </span><br><span class="line">    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t load audio hw module %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    //打开audio_device设备</span><br><span class="line">    rc = audio_hw_device_open(mod, dev);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t open audio hw device in %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">audio_hw_device_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct audio_hw_device** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, AUDIO_HARDWARE_INTERFACE,</span><br><span class="line">                                 (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int legacy_adev_open(const hw_module_t* module, const char* name,</span><br><span class="line">                            hw_device_t** device)</span><br><span class="line">&#123;</span><br><span class="line">    struct legacy_audio_device *ladev;</span><br><span class="line">    int ret;</span><br><span class="line">    ladev = (struct legacy_audio_device *)calloc(1, sizeof(*ladev));</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    ladev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    ladev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module);</span><br><span class="line">    ladev-&gt;device.common.close = legacy_adev_close;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    ladev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    ladev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    ladev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    ladev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    ladev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    ladev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    ladev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    ladev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    ladev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    ladev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    ladev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    ladev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    ladev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ladev-&gt;device.dump = adev_dump;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;hwif = createAudioHardware();</span><br><span class="line"></span><br><span class="line">    *device = &amp;ladev-&gt;device.common;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此就加载完系统定义的所有音频接口，并生成相应的数据对象，如下图所示：’<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/36-Audio-system-audiohwdevice.png" alt="Alt text"></p><h5 id="2-3-4、打开对应的outputStream和inputStream"><a href="#2-3-4、打开对应的outputStream和inputStream" class="headerlink" title="2.3.4、打开对应的outputStream和inputStream"></a>2.3.4、打开对应的outputStream和inputStream</h5><p>前面一小节已经分析过outputStream，这里不再分析了<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/37-Audio-system-AudioStreamOut.png" alt="Alt text"></p><p>打开音频输出后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/38-Audio-system-audiohwdevice-openoutput.png" alt="Alt text"></p><p>打开音频输入:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/39-Audio-system-AudioStreamIn.png" alt="Alt text"><br>打开音频输入后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/310-Audio-system-audiohwdevice-openinput.png" alt="Alt text"></p><h5 id="2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs"><a href="#2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs" class="headerlink" title="2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()"></a>2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManager::updateDevicesAndOutputs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_STRATEGIES; i++) &#123;</span><br><span class="line">        mDeviceForStrategy[i] = getDeviceForStrategy((routing_strategy)i, <span class="literal">false</span> <span class="comment">/*fromCache*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPreviousOutputs = mOutputs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h5><p>-&gt;打开音频输出时创建一个audio_stream_out通道，并创建AudioStreamOut对象以及新建PlaybackThread播放线程。</p><p>-&gt; 打开音频输入时创建一个audio_stream_in通道，并创建AudioStreamIn对象以及创建RecordThread录音线程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/311-Audio-system-audio_stream_in-out.png" alt="Alt text"></p><h4 id="三-、深入剖析Android音频之AudioTrack"><a href="#三-、深入剖析Android音频之AudioTrack" class="headerlink" title="(三)、深入剖析Android音频之AudioTrack"></a>(三)、深入剖析Android音频之AudioTrack</h4><p>现在我们开始分析 AudioTrack 的创建过程，特别留意 AudioTrack 与 AudioFlinger 如何建立联系、用于 AudioTrack 与 AudioFlinger 交换数据的匿名共享内存如何分配。</p><h5 id="3-1-AudioTrack-amp-AudioFlinger-相关类"><a href="#3-1-AudioTrack-amp-AudioFlinger-相关类" class="headerlink" title="3.1. AudioTrack &amp; AudioFlinger 相关类"></a>3.1. AudioTrack &amp; AudioFlinger 相关类</h5><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/312-Audio-system-create_audiotrack-flow.png" alt="Alt text"></p><p>首先看一下 AudioTrack &amp; AudioFlinger 的类图，理一下 AudioFlinger 的主要类及其关系、AudioTrack 与 AudioFlinger 之间的联系，后面将以该图为脉络展开分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/313-Audio-system-create_audiotrack.jpg" alt="Alt text"></p><p>☯ AudioFlinger::PlaybackThread：回放线程基类，不同输出标识的音频流对应不同类型的 PlaybackThread 实例（分为四种：MixerThread、DirectOutputThread、DuplicatingThread、OffloadThread），具体见 3.4. AudioFlinger 回放录制线程 小节，所有的 PlaybackThread 实例都会添加到 AudioFlinger.mPlaybackThreads 向量中；这个向量的定义： DefaultKeyedVector&lt; audio_io_handle_t, sp<playbackthread> &gt; mPlaybackThreads;，可见 audio_io_handle_t 是与 PlaybackThread 是一一对应的，由已知的 audio_io_handle_t 就能找到对应的 PlaybackThread；audio_io_handle_t 在创建 PlaybackThread 时由系统分配，这个值是全局唯一的<br>☯ AudioFlinger::PlaybackThread::Track：音频流管理类，创建一块匿名共享内存用于 AudioTrack 与 AudioFlinger 之间的数据交换（方便起见，这块匿名共享内存，以后均简单称为 FIFO），同时实现 start()、stop()、pause() 等音频流常用控制手段；注意，多个 Track 对象可能都注册到同一个 PlaybackThread 中（尤其对于 MixerThread 而言，一个 MixerThread 往往挂着多个 Track 对象），这多个 Track 对象都会添加到 PlaybackThread.mTracks 向量中统一管理<br>☯ AudioFlinger::TrackHandle：Track 对象只负责音频流管理业务，对外并没有提供跨进程的 Binder 调用接口，而应用进程又需要对音频流进行控制，所以需要一个对象来代理 Track 的跨进程通讯，这个角色就是 TrackHandle，AudioTrack 通过它与 Track 交互<br>☯ AudioTrack：Android 音频系统对外提供的一个 API 类，负责音频流数据输出；每个音频流对应着一个 AudioTrack 实例，不同输出标识的 AudioTrack 会匹配到不同的 AudioFlinger::PlaybackThread；AudioTrack 与 AudioFlinger::PlaybackThread 之间通过 FIFO 来交换音频数据，AudioTrack 是 FIFO 生产者，AudioFlinger::PlaybackThread 是 FIFO 消费者<br>☯ AudioTrack::AudioTrackThread：数据传输模式为 TRANSFER_CALLBACK 时，需要创建该线程，它通过调用 audioCallback 回调函数主动从用户进程处索取数据并填充到 FIFO 上；数据传输模式为 TRANSFER_SYNC 时，则不需要创建这个线程，因为用户进程会持续调用 AudioTrack.write() 填充数据到 FIFO；数据传输模式为 TRANSFER_SHARED 时，也不需要创建这个线程，因为用户进程会创建一块匿名共享内存，并把要播放的音频数据一次性拷贝到这块匿名共享内存上了<br>☯ IAudioTrack：IAudioTrack 是链结 AudioTrack 与 AudioFlinger 的桥梁；它在 AudioTrack 端的对象是 BpAudioTrack，在 AudioFlinger 端的对象是 BnAudioTrack，从图中不难看出，AudioFlinger::TrackHandle 继承自 BnAudioTrack，而 AudioFlinger::TrackHandle 恰恰是AudioFlinger::PlaybackThread::Track 的代理对象，所以 AudioTrack 得到 IAudioTrack 实例后，就可以调用 IAudioTrack 的接口与 AudioFlinger::PlaybackThread::Track 交互</playbackthread></p><p><strong>audio_io_handle_t：</strong></p><p>这里再详细说明一下 audio_io_handle_t，它是 AudioTrack/AudioRecord/AudioSystem、AudioFlinger、AudioPolicyManager 之间一个重要的链结点。3.4. AudioFlinger 回放录制线程 小节在 AudioFlinger::openOutput_l() 注释中大致说明了它的来历及其作用，现在回顾下：当打开输出流设备及创建 PlaybackThread 时，系统会分配一个全局唯一的值作为 audio_io_handle_t，并把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一一对应的关系，因此拿到一个 audio_io_handle_t，就能遍历键值对向量 mPlaybackThreads 找到它对应的 PlaybackThread，可以简单理解 audio_io_handle_t 为 PlaybackThread 的索引号或线程 id。由于 audio_io_handle_t 具有 PlaybackThread 索引特性，所以应用进程想获取 PlaybackThread 某些信息的话，只需要传入对应的 audio_io_handle_t 即可。例如 AudioFlinger::format(audio_io_handle_t output)，这是 AudioFlinger 的一个服务接口，用户进程可以通过该接口获取某个 PlaybackThread 配置的音频格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">audio_format_t</span> AudioFlinger::format(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">// checkPlaybackThread_l() 根据传入的 audio_io_handle_t，从键值对向量</span></span><br><span class="line">    <span class="comment">// mPlaybackThreads 中找到它对应的 PlaybackThread</span></span><br><span class="line">    PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"format() unknown thread %d"</span>, output);</span><br><span class="line">        <span class="keyword">return</span> AUDIO_FORMAT_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread-&gt;format();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::PlaybackThread *AudioFlinger::checkPlaybackThread_l(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlaybackThreads.valueFor(output).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-AudioTrack-构造过程"><a href="#3-2-AudioTrack-构造过程" class="headerlink" title="3.2. AudioTrack 构造过程"></a>3.2. AudioTrack 构造过程</h5><p>当我们构造一个 AudioTrack 实例时（以 MODE_STREAM/TRANSFER_SYNC 模式为例，这也是最常用的模式了，此时 sharedBuffer 为空），系统都发生了什么事？阐述下大致流程：</p><p>如果 cbf（audioCallback 回调函数）非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数（MODE_STREAM 模式时，cbf 为空）；<br>根据 streamType（流类型）、flags（输出标识）等参数调用 AudioSystem::getOutputForAttr()；经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()：<br>如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相应的 PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；<br>如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；别忘了在 3.4. AudioFlinger 回放录制线程 小节中提到：系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 PlaybackThread 了；<br>通过 Binder 机制调用 AudioFlinger::createTrack()（注意 step2 中 AudioTrack 已经拿到一个 audio_io_handle_t 了，此时把这个 audio_io_handle_t 传入给 createTrack()）：<br>根据传入的 audio_io_handle_t 找到它对应的 PlaybackThread；<br>PlaybackThread 新建一个音频流管理对象 Track；Track 构造时会分配一块匿名共享内存用于 AudioFlinger 与 AudioTrack 的数据交换缓冲区（FIFO）及其控制块（audio_track_cblk_t），并创建一个 AudioTrackServerProxy 对象（PlaybackThread 将使用它从 FIFO 上取得可读数据的位置）；<br>最后新建一个 Track 的通讯代理 TrackHandle，并以 IAudioTrack 作为返回值给 AudioTrack（TrackHandle、BnAudioTrack、BpAudioTrack、IAudioTrack 的关系见上一个小节）；<br>通过 IAudioTrack 接口，取得 AudioFlinger 中的 FIFO 控制块（audio_track_cblk_t），由此再计算得到 FIFO 的首地址；<br>创建一个 AudioTrackClientProxy 对象（AudioTrack 将使用它从 FIFO 上取得可用空间的位置）；<br>AudioTrack 由此建立了和 AudioFlinger 的全部联系工作：</p><p>通过 IAudioTrack 接口可以控制该音轨的状态，例如 start、stop、pause<br>持续写入数据到 FIFO 上，实现音频连续播放<br>通过 audio_io_handle_t，可以找到它对应的 PlaybackThread，从而查询该 PlaybackThread 的相关信息，如所设置的采样率、格式等等<br>构造 1 个 AudioTrack 实例时，AudioFlinger 会有 1 个 PlaybackThread 实例、1 个 Track 实例、1 个 TrackHandle 实例、1 个 AudioTrackServerProxy 实例、1 块 FIFO 与之对应。</p><p>当同时构造 1 个 AudioTrack with AUDIO_OUTPUT_FLAG_PRIMARY、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_FAST、3 个 AudioTrack with AUDIO_OUTPUT_FLAG_DEEP_BUFFER、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_DIRECT 时（事实上，Android 音频策略不允许出现这种情形的），AudioFlinger 拥有的 PlaybackThread、Track、TrackHandle 实例如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/314-Audio-system-PlaybackThread-Track-TrackHandle.png" alt="Alt text"></p><p>最后附上相关代码的流程分析，我本意是不多贴代码的，但不上代码总觉得缺点什么，这里我尽量把代码精简，提取主干，忽略细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">AudioTrack::AudioTrack(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,    <span class="comment">// 音频流类型：如 Music、Voice-Call、DTMF、Alarm 等等</span></span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,               <span class="comment">// 采样率：如 16KHz、44.1KHz、48KHz 等等</span></span><br><span class="line">        <span class="keyword">audio_format_t</span> format,             <span class="comment">// 音频格式：如 PCM、MP3、AAC 等等</span></span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,  <span class="comment">// 声道数：如 Mono（单声道）、Stereo（双声道）</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,   <span class="comment">// 共享内存缓冲区：数据模式是 MODE_STATIC 时使用，数据模式是 MODE_STREAM 时为空</span></span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        <span class="comment">// 输出标识位，详见 AUDIO_OUTPUT_FLAG 描述</span></span><br><span class="line">        <span class="keyword">callback_t</span> cbf,                    <span class="comment">// 回调函数</span></span><br><span class="line">        <span class="keyword">void</span>* user,                        <span class="comment">// 回调函数的参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,        <span class="comment">// 数据传输类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">    : mStatus(NO_INIT),</span><br><span class="line">      mIsTimed(<span class="literal">false</span>),</span><br><span class="line">      mPreviousPriority(ANDROID_PRIORITY_NORMAL),</span><br><span class="line">      mPreviousSchedulingGroup(SP_DEFAULT),</span><br><span class="line">      mPausedPosition(<span class="number">0</span>),</span><br><span class="line">      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    mStatus = <span class="built_in">set</span>(streamType, sampleRate, format, channelMask,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/*frameCount*/</span>, flags, cbf, user, notificationFrames,</span><br><span class="line">            sharedBuffer, <span class="literal">false</span> <span class="comment">/*threadCanCallJava*/</span>, sessionId, transferType, offloadInfo,</span><br><span class="line">            uid, pid, pAttributes, doNotReconnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::<span class="built_in">set</span>(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">        <span class="keyword">audio_format_t</span> format,</span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">        <span class="keyword">size_t</span> frameCount,</span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        </span><br><span class="line">        <span class="keyword">callback_t</span> cbf,</span><br><span class="line">        <span class="keyword">void</span>* user,</span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        <span class="keyword">bool</span> threadCanCallJava,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数格式合法性检查、音轨音量初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 cbf 非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (cbf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioTrackThread = <span class="keyword">new</span> AudioTrackThread(*<span class="keyword">this</span>, threadCanCallJava);</span><br><span class="line">        mAudioTrackThread-&gt;run(<span class="string">"AudioTrack"</span>, ANDROID_PRIORITY_AUDIO, <span class="number">0</span> <span class="comment">/*stack*/</span>);</span><br><span class="line">        <span class="comment">// thread begins in paused state, and will not reference us until start()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the IAudioTrack</span></span><br><span class="line">    <span class="keyword">status_t</span> status = createTrack_l();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::createTrack_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 IAudioFlinger，通过 binder 请求 AudioFlinger 服务</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger();</span><br><span class="line">    <span class="keyword">if</span> (audioFlinger == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get audioflinger"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioSystem::getOutputForAttr() 经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()</span></span><br><span class="line">    <span class="comment">// 如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，</span></span><br><span class="line">    <span class="comment">// 那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相关的</span></span><br><span class="line">    <span class="comment">// PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；</span></span><br><span class="line">    <span class="comment">// 如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该</span></span><br><span class="line">    <span class="comment">// PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack</span></span><br><span class="line">    <span class="keyword">audio_io_handle_t</span> output;</span><br><span class="line">    status = AudioSystem::getOutputForAttr(attr, &amp;output,</span><br><span class="line">                                           (<span class="keyword">audio_session_t</span>)mSessionId, &amp;streamType, mClientUid,</span><br><span class="line">                                           mSampleRate, mFormat, mChannelMask,</span><br><span class="line">                                           mFlags, mSelectedDeviceId, mOffloadInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 AudioFlinger 发出 createTrack 请求</span></span><br><span class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</span><br><span class="line">                                                      mSampleRate,</span><br><span class="line">                                                      mFormat,</span><br><span class="line">                                                      mChannelMask,</span><br><span class="line">                                                      &amp;temp,</span><br><span class="line">                                                      &amp;trackFlags,</span><br><span class="line">                                                      mSharedBuffer,</span><br><span class="line">                                                      output,</span><br><span class="line">                                                      tid,</span><br><span class="line">                                                      &amp;mSessionId,</span><br><span class="line">                                                      mClientUid,</span><br><span class="line">                                                      &amp;status);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioFlinger 创建 Track 对象时会分配一个 FIFO，这里获取 FIFO 的控制块</span></span><br><span class="line">    sp&lt;IMemory&gt; iMem = track-&gt;getCblk();</span><br><span class="line">    <span class="keyword">if</span> (iMem == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匿名共享内存首地址</span></span><br><span class="line">    <span class="keyword">void</span> *iMemPointer = iMem-&gt;pointer();</span><br><span class="line">    <span class="keyword">if</span> (iMemPointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    mAudioTrack = track; <span class="comment">// 保存 AudioFlinger::PlaybackThread::Track 的代理对象 IAudioTrack</span></span><br><span class="line">    mCblkMemory = iMem; <span class="comment">// 保存匿名共享内存首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制块位于 AudioFlinger 分配的匿名共享内存的首部</span></span><br><span class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span>*&gt;(iMemPointer);</span><br><span class="line">    mCblk = cblk;</span><br><span class="line">    mOutput = output; <span class="comment">// 保存返回的 audio_io_handle_t，用它可以找到对应的 PlaybackThread</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update proxy</span></span><br><span class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 为空，意味着音轨数据模式为 MODE_STREAM，那么创建 AudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy.clear();</span><br><span class="line">        mProxy = <span class="keyword">new</span> AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 非空，意味着音轨数据模式为 MODE_STATIC，那么创建 StaticAudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy = <span class="keyword">new</span> StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">        mProxy = mStaticProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger::createTrack()，顾名思义，创建一个 Track 对象，将用于音频流的控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;IAudioTrack&gt; AudioFlinger::createTrack(</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *frameCount,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        audio_io_handle_t output,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int *sessionId,</span><br><span class="line">        int clientUid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;PlaybackThread::Track&gt; track;</span><br><span class="line">    sp&lt;TrackHandle&gt; trackHandle;</span><br><span class="line">    sp&lt;Client&gt; client;</span><br><span class="line">    status_t lStatus;</span><br><span class="line">    int lSessionId;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        // 根据传入来的 audio_io_handle_t，找到对应的 PlaybackThread</span><br><span class="line">        PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">        if (thread == NULL) &#123;</span><br><span class="line">            ALOGE(&quot;no playback thread found for output handle %d&quot;, output);</span><br><span class="line">            lStatus = BAD_VALUE;</span><br><span class="line">            goto Exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // 在 PlaybackThread 上创建一个音频流管理对象 Track</span><br><span class="line">        track = thread-&gt;createTrack_l(client, streamType, sampleRate, format,</span><br><span class="line">                channelMask, frameCount, sharedBuffer, lSessionId, flags, tid, clientUid, &amp;lStatus);</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        setAudioHwSyncForSession_l(thread, (audio_session_t)lSessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 创建 Track 的通讯代理 TrackHandle 并返回它</span><br><span class="line">    trackHandle = new TrackHandle(track);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return trackHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l(</span><br><span class="line">        const sp&lt;AudioFlinger::Client&gt;&amp; client,</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *pFrameCount,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        int sessionId,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int uid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    size_t frameCount = *pFrameCount;</span><br><span class="line">    sp&lt;Track&gt; track;</span><br><span class="line">    status_t lStatus;</span><br><span class="line"></span><br><span class="line">    bool isTimed = (*flags &amp; IAudioFlinger::TRACK_TIMED) != 0;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    &#123; // scope for mLock</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!isTimed) &#123;</span><br><span class="line">            // 创建 Track，等会再看看 Track 构造函数干些啥</span><br><span class="line">            track = new Track(this, client, streamType, sampleRate, format,</span><br><span class="line">                              channelMask, frameCount, NULL, sharedBuffer,</span><br><span class="line">                              sessionId, uid, *flags, TrackBase::TYPE_DEFAULT);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建 TimedTrack，带时间戳的 Track？这里不深究</span><br><span class="line">            track = TimedTrack::create(this, client, streamType, sampleRate, format,</span><br><span class="line">                    channelMask, frameCount, sharedBuffer, sessionId, uid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        // 把创建的 Track 添加到 mTracks 向量中，方便 PlaybackThread 统一管理</span><br><span class="line">        mTracks.add(track);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lStatus = NO_ERROR;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return track;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------------------------</span><br><span class="line">// 如下是 TrackHandle 的相关代码，可以看到，TrackHandle 其实就是一个壳子，是 Track 的包装类</span><br><span class="line">// 所有 TrackHandle 接口都是调向 Track 的</span><br><span class="line">// Google 为什么要搞这么一则？Track 是 PlaybackThread 内部使用的，不适宜对外暴露，但应用进程</span><br><span class="line">// 又确实需要控制音频流的状态（start、stop、pause），所以就采取这么一种方式实现</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::TrackHandle(const sp&lt;AudioFlinger::PlaybackThread::Track&gt;&amp; track)</span><br><span class="line">    : BnAudioTrack(),</span><br><span class="line">      mTrack(track)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::~TrackHandle() &#123;</span><br><span class="line">    // just stop the track on deletion, associated resources</span><br><span class="line">    // will be freed from the main thread once all pending buffers have</span><br><span class="line">    // been played. Unless it&apos;s not in the active track list, in which</span><br><span class="line">    // case we free everything now...</span><br><span class="line">    mTrack-&gt;destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IMemory&gt; AudioFlinger::TrackHandle::getCblk() const &#123;</span><br><span class="line">    return mTrack-&gt;getCblk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t AudioFlinger::TrackHandle::start() &#123;</span><br><span class="line">    return mTrack-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::stop() &#123;</span><br><span class="line">    mTrack-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::flush() &#123;</span><br><span class="line">    mTrack-&gt;flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::pause() &#123;</span><br><span class="line">    mTrack-&gt;pause();</span><br><span class="line">&#125;</span><br><span class="line">// ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>最后，我们看看 Track 的构造过程，主要分析数据 FIFO 及它的控制块是如何分配的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::PlaybackThread::Track::Track(</span><br><span class="line">            PlaybackThread *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> uid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   TrackBase(thread, client, sampleRate, format, channelMask, frameCount,</span><br><span class="line">                  (sharedBuffer != <span class="number">0</span>) ? sharedBuffer-&gt;pointer() : buffer,</span><br><span class="line">                  sessionId, uid, flags, <span class="literal">true</span> <span class="comment">/*isOut*/</span>,</span><br><span class="line">                  (type == TYPE_PATCH) ? ( buffer == <span class="literal">NULL</span> ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK,</span><br><span class="line">                  type),</span><br><span class="line">    mFillingUpStatus(FS_INVALID),</span><br><span class="line">    <span class="comment">// mRetryCount initialized later when needed</span></span><br><span class="line">    mSharedBuffer(sharedBuffer),</span><br><span class="line">    mStreamType(streamType),</span><br><span class="line">    mName(<span class="number">-1</span>),  <span class="comment">// see note below</span></span><br><span class="line">    mMainBuffer(thread-&gt;mixBuffer()),</span><br><span class="line">    mAuxBuffer(<span class="literal">NULL</span>),</span><br><span class="line">    mAuxEffectId(<span class="number">0</span>), mHasVolumeController(<span class="literal">false</span>),</span><br><span class="line">    mPresentationCompleteFrames(<span class="number">0</span>),</span><br><span class="line">    mFastIndex(<span class="number">-1</span>),</span><br><span class="line">    mCachedVolume(<span class="number">1.0</span>),</span><br><span class="line">    mIsInvalid(<span class="literal">false</span>),</span><br><span class="line">    mAudioTrackServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">    mResumeToStopping(<span class="literal">false</span>),</span><br><span class="line">    mFlushHwPending(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// client == 0 implies sharedBuffer == 0</span></span><br><span class="line">    ALOG_ASSERT(!(client == <span class="number">0</span> &amp;&amp; sharedBuffer != <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ALOGV_IF(sharedBuffer != <span class="number">0</span>, <span class="string">"sharedBuffer: %p, size: %d"</span>, sharedBuffer-&gt;pointer(),</span><br><span class="line">            sharedBuffer-&gt;size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 FIFO 控制块（audio_track_cblk_t）是否分配好了，上面代码并未分配 audio_track_cblk_t</span></span><br><span class="line">    <span class="comment">// 因此只可能是构造 TrackBase 时分配的，等下再看看 TrackBase 的构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STREAM 模式，创建一个 AudioTrackServerProxy 对象</span></span><br><span class="line">        <span class="comment">// PlaybackThread 将持续使用它从 FIFO 上取得可读数据的位置</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> AudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize, !isExternalTrack(), sampleRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STATIC 模式，创建一个 StaticAudioTrackServerProxy 对象</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize);</span><br><span class="line">    &#125;</span><br><span class="line">    mServerProxy = mAudioTrackServerProxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 Track 分配一个名称，AudioMixer 会根据 TrackName 找到对应的 Track</span></span><br><span class="line">    mName = thread-&gt;getTrackName_l(channelMask, format, sessionId);</span><br><span class="line">    <span class="keyword">if</span> (mName &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"no more track names available"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::ThreadBase::TrackBase::TrackBase(</span><br><span class="line">            ThreadBase *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> clientUid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            <span class="keyword">bool</span> isOut,</span><br><span class="line">            alloc_type alloc,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   RefBase(),</span><br><span class="line">        mThread(thread),</span><br><span class="line">        mClient(client),</span><br><span class="line">        mCblk(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="comment">// mBuffer</span></span><br><span class="line">        mState(IDLE),</span><br><span class="line">        mSampleRate(sampleRate),</span><br><span class="line">        mFormat(format),</span><br><span class="line">        mChannelMask(channelMask),</span><br><span class="line">        mChannelCount(isOut ?</span><br><span class="line">                audio_channel_count_from_out_mask(channelMask) :</span><br><span class="line">                audio_channel_count_from_in_mask(channelMask)),</span><br><span class="line">        mFrameSize(audio_is_linear_pcm(format) ?</span><br><span class="line">                mChannelCount * audio_bytes_per_sample(format) : <span class="keyword">sizeof</span>(<span class="keyword">int8_t</span>)),</span><br><span class="line">        mFrameCount(frameCount),</span><br><span class="line">        mSessionId(sessionId),</span><br><span class="line">        mFlags(flags),</span><br><span class="line">        mIsOut(isOut),</span><br><span class="line">        mServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">        mId(android_atomic_inc(&amp;nextTrackId)),</span><br><span class="line">        mTerminated(<span class="literal">false</span>),</span><br><span class="line">        mType(type),</span><br><span class="line">        mThreadIoHandle(thread-&gt;id())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGD("Creating track with %d buffers @ %d bytes", bufferCount, bufferSize);</span></span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">    <span class="keyword">size_t</span> bufferSize = (buffer == <span class="literal">NULL</span> ? roundup(frameCount) : frameCount) * mFrameSize;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span> &amp;&amp; alloc == ALLOC_CBLK) &#123;</span><br><span class="line">        <span class="comment">// 这个 size 将是分配的匿名共享内存的大小</span></span><br><span class="line">        <span class="comment">// 等于控制块的大小（sizeof(audio_track_cblk_t)加上数据 FIFO的大小（bufferSize）</span></span><br><span class="line">        <span class="comment">// 待会看到这块内存的结构，就明白这样分配的意义了</span></span><br><span class="line">        size += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块匿名共享内存</span></span><br><span class="line">        mCblkMemory = client-&gt;heap()-&gt;allocate(size);</span><br><span class="line">        <span class="keyword">if</span> (mCblkMemory == <span class="number">0</span> ||</span><br><span class="line">                (mCblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span> *&gt;(mCblkMemory-&gt;pointer())) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"not enough memory for AudioTrack size=%u"</span>, size);</span><br><span class="line">            client-&gt;heap()-&gt;dump(<span class="string">"AudioTrack"</span>);</span><br><span class="line">            mCblkMemory.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// this syntax avoids calling the audio_track_cblk_t constructor twice</span></span><br><span class="line">        mCblk = (<span class="keyword">audio_track_cblk_t</span> *) <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size];</span><br><span class="line">        <span class="comment">// assume mCblk != NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the shared structure in-place.</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是 C++ 的 placement new（定位创建对象）语法：new(@BUFFER) @CLASS();</span></span><br><span class="line">        <span class="comment">// 可以在特定内存位置上构造一个对象</span></span><br><span class="line">        <span class="comment">// 这里，在匿名共享内存首地址上构造了一个 audio_track_cblk_t 对象</span></span><br><span class="line">        <span class="comment">// 这样 AudioTrack 与 AudioFlinger 都能访问这个 audio_track_cblk_t 对象了</span></span><br><span class="line">        <span class="keyword">new</span>(mCblk) <span class="keyword">audio_track_cblk_t</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如下分配数据 FIFO，将用于 AudioTrack 与 AudioFlinger 的数据交换</span></span><br><span class="line">        <span class="keyword">switch</span> (alloc) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> ALLOC_CBLK:</span><br><span class="line">            <span class="comment">// clear all buffers</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STREAM/TRANSFER_SYNC 时，数据 FIFO 的分配</span></span><br><span class="line">                <span class="comment">// 数据 FIFO 的首地址紧靠控制块（audio_track_cblk_t）之后</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   | -------------------&gt; mCblkMemory &lt;--------------------- |</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |             Buffer                 |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                    ^</span></span><br><span class="line">                <span class="comment">//   |                    |</span></span><br><span class="line">                <span class="comment">//   mCblk               mBuffer</span></span><br><span class="line">                mBuffer = (<span class="keyword">char</span>*)mCblk + <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">                <span class="built_in">memset</span>(mBuffer, <span class="number">0</span>, bufferSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STATIC/TRANSFER_SHARED 时，直接指向 sharedBuffer</span></span><br><span class="line">                <span class="comment">// sharedBuffer 是应用进程分配的匿名共享内存，应用进程已经一次性把数据</span></span><br><span class="line">                <span class="comment">// 写到 sharedBuffer 来了，AudioFlinger 可以直接从这里读取</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |    |            sharedBuffer           |</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                         ^</span></span><br><span class="line">                <span class="comment">//   |                         |</span></span><br><span class="line">                <span class="comment">//   mCblk                    mBuffer</span></span><br><span class="line">                mBuffer = buffer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-AudioTrack-数据写入"><a href="#3-3-AudioTrack-数据写入" class="headerlink" title="3.3. AudioTrack 数据写入"></a>3.3. AudioTrack 数据写入</h5><p>AudioTrack 实例构造后，应用程序接着可以写入音频数据了。如之前所描述：AudioTrack 与 AudioFlinger 是 生产者-消费者 的关系：</p><p>☯ AudioTrack：AudioTrack 在 FIFO 中找到一块可用空间，把用户传入的音频数据写入到这块可用空间上，然后更新写位置（对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据了）；如果用户传入的数据量比可用空间要大，那么要把用户传入的数据拆分多次写入到 FIFO 中（AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地读取数据，所以 FIFO 可用空间是在不停变化的）<br>☯ AudioFlinger：AudioFlinger 在 FIFO 中找到一块可读数据块，把可读数据拷贝到目的缓冲区上，然后更新读位置（对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间了）；如果FIFO 上可读数据量比预期的要小，那么要进行多次的读取，才能积累到预期的数据量（AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地写入数据，所以 FIFO 可读的数据量是在不停变化的）<br>上面的过程中，如果 AudioTrack 总能及时生产数据，并且 AudioFlinger 总能及时消耗掉这些数据，那么整个过程将是非常和谐的；但系统可能会发生异常，出现如下的状态：</p><p>☯ Block：AudioFlinger 长时间不读取 FIFO 上的可读数据，使得 AudioTrack 长时间获取不到可用空间，无法写入数据；这种情况的根本原因大多是底层驱动发生阻塞异常，导致 AudioFlinger 无法继续写数据到硬件设备中，AudioFlinger 本身并没有错<br>☯ Underrun：AudioTrack 写入数据的速度跟不上 AudioFlinger 读取数据的速度，使得 AudioFlinger 不能及时获取到预期的数据量，反映到现实的后果就是声音断续；这种情况的根本原因大多是应用程序不能及时写入数据或者缓冲区分配过小，AudioTrack 本身并没有错；AudioFlinger 针对这点做了容错处理：当发现 underrun 时，先陷入短时间的睡眠，不急着读取数据，让应用程序准备更多的数据（如果某一天做应用的哥们意识到自己的错误原来由底层的兄弟默默埋单了，会不会感动得哭了^_^）</p><h5 id="3-3-1-AudioTrack-写数据流程"><a href="#3-3-1-AudioTrack-写数据流程" class="headerlink" title="3.3. 1. AudioTrack 写数据流程"></a>3.3. 1. AudioTrack 写数据流程</h5><p>我们看一下 AudioTrack 写数据的代码，流程很简单：obtainBuffer() 在 FIFO 中找到一块可用区间，memcpy() 把用户传入的音频数据拷贝到这个可用区间上，releaseBuffer() 更新写位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">ssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)</span><br><span class="line">&#123;</span><br><span class="line">    if (mTransfer != TRANSFER_SYNC) &#123;</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDirect()) &#123;</span><br><span class="line">        AutoMutex lock(mLock);</span><br><span class="line">        int32_t flags = android_atomic_and(</span><br><span class="line">                            ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END),</span><br><span class="line">                            &amp;mCblk-&gt;mFlags);</span><br><span class="line">        if (flags &amp; CBLK_INVALID) &#123;</span><br><span class="line">            return DEAD_OBJECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ssize_t(userSize) &lt; 0 || (buffer == NULL &amp;&amp; userSize != 0)) &#123;</span><br><span class="line">        // Sanity-check: user is most-likely passing an error code, and it would</span><br><span class="line">        // make the return value ambiguous (actualSize vs error).</span><br><span class="line">        ALOGE(&quot;AudioTrack::write(buffer=%p, size=%zu (%zd)&quot;, buffer, userSize, userSize);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t written = 0;</span><br><span class="line">    Buffer audioBuffer;</span><br><span class="line"></span><br><span class="line">    while (userSize &gt;= mFrameSize) &#123;</span><br><span class="line">        // 单帧数据量 frameSize = channelCount * bytesPerSample</span><br><span class="line">        //   对于双声道，16位采样的音频数据来说，frameSize = 2 * 2 = 4(bytes)</span><br><span class="line">        // 用户传入的数据帧数 frameCount = userSize / frameSize</span><br><span class="line">        audioBuffer.frameCount = userSize / mFrameSize;</span><br><span class="line"></span><br><span class="line">        // obtainBuffer() 从 FIFO 上得到一块可用区间</span><br><span class="line">        status_t err = obtainBuffer(&amp;audioBuffer,</span><br><span class="line">                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);</span><br><span class="line">        if (err &lt; 0) &#123;</span><br><span class="line">            if (written &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (err == TIMED_OUT || err == -EINTR) &#123;</span><br><span class="line">                err = WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            return ssize_t(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // toWrite 是 FIFO 可用区间的大小，可能比 userSize（用户传入数据的大小）要小</span><br><span class="line">        //   因此用户传入的数据可能要拆分多次拷贝到 FIFO 上</span><br><span class="line">        // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地</span><br><span class="line">        //   消耗数据，所以 FIFO 可用区间是在不停变化的</span><br><span class="line">        size_t toWrite = audioBuffer.size;</span><br><span class="line">        memcpy(audioBuffer.i8, buffer, toWrite); // 把用户数据拷贝到 FIFO 可用区间</span><br><span class="line">        buffer = ((const char *) buffer) + toWrite; // 未拷贝数据的位置</span><br><span class="line">        userSize -= toWrite; // 未拷贝数据的大小</span><br><span class="line">        written += toWrite; // 已拷贝数据的大小</span><br><span class="line"></span><br><span class="line">        // releaseBuffer() 更新 FIFO 写位置</span><br><span class="line">        // 对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据</span><br><span class="line">        releaseBuffer(&amp;audioBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (written &gt; 0) &#123;</span><br><span class="line">        mFramesWritten += written / mFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-AudioFlinger-读数据流程"><a href="#3-3-2-AudioFlinger-读数据流程" class="headerlink" title="3.3. 2. AudioFlinger 读数据流程"></a>3.3. 2. AudioFlinger 读数据流程</h5><p>AudioFlinger 消费数据的流程稍微复杂一点，3.4. AudioFlinger 回放录制线程 小节中描述了 AudioFlinger::PlaybackThread::threadLoop() 工作流程，这里不累述了，我们把焦点放在“如何从 FIFO 读取数据”节点上。</p><p>我们以 DirectOutputThread/OffloadThread 为例说明（MixerThread 读数据也是类似的过程，只不过是在 AudioMixer 中进行的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">void AudioFlinger::DirectOutputThread::threadLoop_mix()</span><br><span class="line">&#123;</span><br><span class="line">    // mFrameCount 是硬件设备（PCM 设备）处理单个数据块的帧数（周期大小）</span><br><span class="line">    //   上层必须积累了足够多（mFrameCount）的数据，才写入到 PCM 设备</span><br><span class="line">    //   所以 mFrameCount 也就是 AudioFlinger 预期的数据量</span><br><span class="line">    size_t frameCount = mFrameCount;</span><br><span class="line">    // mSinkBuffer 目的缓冲区，threadLoop_write() 会把 mSinkBuffer 上的数据写到 PCM 设备</span><br><span class="line">    int8_t *curBuf = (int8_t *)mSinkBuffer;</span><br><span class="line">    // output audio to hardware</span><br><span class="line">    // FIFO 上可读的数据量可能要比预期的要小，因此可能需要多次读取才能积累足够的数据量</span><br><span class="line">    // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地生产数据</span><br><span class="line">    //   所以 FIFO 可读的数据量是在不停变化的</span><br><span class="line">    while (frameCount) &#123;</span><br><span class="line">        AudioBufferProvider::Buffer buffer;</span><br><span class="line">        buffer.frameCount = frameCount;</span><br><span class="line">        // getNextBuffer() 从 FIFO 上获取可读数据块</span><br><span class="line">        status_t status = mActiveTrack-&gt;getNextBuffer(&amp;buffer);</span><br><span class="line">        if (status != NO_ERROR || buffer.raw == NULL) &#123;</span><br><span class="line">            memset(curBuf, 0, frameCount * mFrameSize);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // memcpy() 把 FIFO 可读数据拷贝到 mSinkBuffer 目的缓冲区</span><br><span class="line">        memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize);</span><br><span class="line">        frameCount -= buffer.frameCount;</span><br><span class="line">        curBuf += buffer.frameCount * mFrameSize;</span><br><span class="line">        // releaseBuffer() 更新 FIFO 读位置</span><br><span class="line">        // 对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间</span><br><span class="line">        mActiveTrack-&gt;releaseBuffer(&amp;buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentWriteLength = curBuf - (int8_t *)mSinkBuffer;</span><br><span class="line">    mSleepTimeUs = 0;</span><br><span class="line">    mStandbyTimeNs = systemTime() + mStandbyDelayNs;</span><br><span class="line">    mActiveTrack.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-3-环形-FIFO-管理"><a href="#3-3-3-环形-FIFO-管理" class="headerlink" title="3.3. 3. 环形 FIFO 管理"></a>3.3. 3. 环形 FIFO 管理</h5><p>在上述过程中，不知大家有无意识到：整个过程中，最难的是如何协调生产者与消费者之间的步调。上文所说的 FIFO 是环形 FIFO，AudioTrack 写指针、AudioFlinger 读指针都是基于 FIFO 当前的读写位置来计算的。</p><p>☯AudioTrack 与 AudioFlinger 不在同一个进程上，怎么保证读写指针的线程安全<br>☯读写指针越过 FIFO 后，怎么处理<br>☯AudioTrack 写数据完成后，需要同步状态给 AudioFlinger，让 AudioFlinger 知道当前有可读数据了，而 AudioFlinger 读数据完成后，也需要同步状态给 AudioTrack，让 AudioTrack 知道当前有可用空间了；这里采取什么同步机制<br>我们回顾下创建 AudioTrack 对象时，FIFO 及其控制块的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MODE_STREAM 模式下的匿名共享内存结构：</span><br><span class="line">  |                                                         |</span><br><span class="line">  | -------------------&gt; mCblkMemory &lt;--------------------- |</span><br><span class="line">  |                                                         |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  | audio_track_cblk_t |               FIFO                 |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  ^                    ^</span><br><span class="line">  |                    |</span><br><span class="line">mCblk               mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = static_cast&lt;audio_track_cblk_t *&gt;(mCblkMemory-&gt;pointer());</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = (char*)mCblk + sizeof(audio_track_cblk_t);</span><br></pre></td></tr></table></figure><p>☯MODE_STATIC 模式下的匿名共享内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  | audio_track_cblk_t |    |         FIFO (sharedBuffer)       |</span><br><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  ^                         ^</span><br><span class="line">  |                         |</span><br><span class="line">mCblk                    mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = (audio_track_cblk_t *) new uint8_t[size];</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = sharedBuffer-&gt;pointer()</span><br></pre></td></tr></table></figure><p>FIFO 管理相关的类图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/315-Audio-system-FIFO.jpg" alt="Alt text"></p><p>☯AudioTrackClientProxy：MODE_STREAM 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯AudioTrackServerProxy：MODE_STREAM 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯StaticAudioTrackClientProxy：MODE_STATIC 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯StaticAudioTrackServerProxy：MODE_STATIC 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯AudioRecordClientProxy：消费者 AudioRecord 使用它在 FIFO 中找到可读数据的位置<br>☯AudioTrackServerProxy：生产者 AudioFlinger::RecordThread 使用它在 FIFO 中找到可用空间的位置<br>到这里，我决定结束本文了。环形 FIFO 管理是 Android 音频系统的精髓，一个小节并不足以描述其原理及实现细节；Android 环形 FIFO 的实现可说得上精妙绝伦，其他项目如果要用到环形 FIFO，不妨多借鉴它。</p><h4 id="四-、深入剖析MediaPlayer播放音频流程"><a href="#四-、深入剖析MediaPlayer播放音频流程" class="headerlink" title="(四)、深入剖析MediaPlayer播放音频流程"></a>(四)、深入剖析MediaPlayer播放音频流程</h4><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/316-Audio-system-mediaplayer-playback.png" alt="Alt text"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Audio System（2）：Linux ALSA音频系统分析</title>
      <link href="/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/zyuanyun" target="_blank" rel="noopener">【特别感谢 - 雲和山的彼端 - 音频系统分析】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio HAL 源码)</strong> </p><p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><blockquote><p>Kernel space audio code 源码：</p></blockquote><p>• <strong>/kernel/sound/soc/msm/ –  msm8996.c machine driver 源码 </strong></p><p>• <strong>/kernel/sound/soc/msm/qdsp6v2 –  platform drivers, front end (FE), and back-end (BE) DAI driver, Hexagon DSP drivers for AFE, ADM, and ASM, voice driver 相关源码</strong></p><p>• <strong>kernel/sound/soc/soc-<em>.c – All the SoC-</em>.c  ALSA SoCs framework 源码</strong></p><p>• <strong>kernel/drivers/slimbus/ –  SLIMbus driver 源码 </strong></p><p>• <strong>kernel/arch/arm/mach-msm/ – 包含比如 acpuclock-8996.c, board-8996-gpiomux.c, board-8996.c, and clock-8996.c related to the GPIO, clock, and board-specific information on the MSM8996 相关源码</strong></p><p>• <strong>/kernel/arch/arm/mach-msm/qdsp6v2/ – Contains the drivers for DSP-based encoders and decoders, code for the aDSP loader, APR driver, Ion memory driver, and other utility files</strong></p><p>• <strong>/kernel/arch/arm/boot/dts – Contains MSM8996-<em>.its and MSM8996-</em>.Dtsi files that contain MSM8996-specific information; audio-related customization is available in files such as MSM8996.dtsi, msm8996-mtp.dtsi, and msm8996-cdp.dtsi</strong></p><p>• <strong>/kernel/sound/soc/codecs/ – Contains the source code for the codec driver for WCD9335; codec driver-related source files are wcd9335.c, wcd9xxx-mbhc.c, wcd9xxx-resmgr.c, wcd9xxx-common.c, and so on.</strong></p><p>• <strong>/kernel/drivers/mfd/ – Contains the source code for the codec driver; wcd9xxx-core.c, wcd9xxx-slimslave.c, and wcd9xxx-irq.c are the codec driverrelated files</strong></p><h4 id="（一）-Overview"><a href="#（一）-Overview" class="headerlink" title="（一） Overview"></a>（一） Overview</h4><p>硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><p>Linux ALSA 音频系统架构大致如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/21-Audio-system-Android-Linux-ASoc-arc.png.png" alt="Alt text"></p><p>• Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>• ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>• ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>• ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>• Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><p>Platform：指某款 SoC 平台的音频模块，如 exynos、omap、qcom 等等。Platform 又可细分两部分：</p><p>  • cpu dai：在嵌入式系统里面通常指 SoC 的 I2S、PCM 总线控制器，负责把音频数据从 I2S tx FIFO 搬运到 CODEC（这是回放的情形，录制则方向相反）。cpu_dai 通过 <strong>snd_soc_register_dai()</strong> 来注册。注：DAI 是 Digital Audio Interface 的简称，分为 cpu_dai 和 codec_dai，这两者通过 I2S/PCM 总线连接；AIF 是 Audio Interface 的简称，嵌入式系统中一般是 I2S 和 PCM 接口。<br>  • pcm dma：负责把 dma buffer 中的音频数据搬运到 I2S tx FIFO。值得留意的是：某些情形下是不需要 dma 操作的，比如 Modem 和 CODEC 直连，因为 Modem 本身已经把数据送到 FIFO 了，这时只需启动 codec_dai 接收数据即可；该情形下，Machine 驱动 dai_link 中需要设定 .platform_name = “msm-pcm-xxx”。</p><p>Codec：对于回放来说，userspace 送过来的音频数据是经过采样量化的数字信号，在 codec 经过 DAC 转换成模拟信号然后输出到外放或耳机，这样我们就可以听到声音了。Codec 字面意思是编解码器，但芯片里面的功能部件很多，常见的有 AIF、DAC、ADC、Mixer、PGA、Line-in、Line-out，有些高端的 codec 芯片还有 EQ、DSP、SRC、DRC、AGC、Echo-Canceller、Noise-Suppression 等部件。</p><p>Machine：指某款机器，通过配置 dai_link 把 cpu_dai、codec_dai、modem_dai 各个音频接口给链结成一条条音频链路，然后注册 snd_soc_card。和上面两个不一样，Platform 和 CODEC 驱动一般是可以重用的，而 Machine 有它特定的硬件特性，几乎是不可重用的。所谓的硬件特性指：SoC Platform 与 Codec 的差异；DAIs 之间的链结方式；通过某个 GPIO 打开 Amplifier；通过某个 GPIO 检测耳机插拔；使用某个时钟如 MCLK/External-OSC 作为 I2S、CODEC 的时钟源等等。</p><p>从上面的描述来看，对于回放的情形，PCM 数据流向大致是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        copy_from_user           DMA                 I2S           DAC</span><br><span class="line">              ^                   ^                   ^             ^</span><br><span class="line">+---------+   |    +----------+   |   +-----------+   |   +-----+   |   +------+</span><br><span class="line">|userspace+--------&gt;DMA Buffer+-------&gt;I2S TX FIFO+-------&gt;CODEC+-------&gt;SPK/HP|</span><br><span class="line">+---------+        +----------+       +-----------+       +-----+       +------+</span><br></pre></td></tr></table></figure><p>几个音频物理链路的概念：</p><p>dai_link：machine 驱动中定义的音频数据链路，它指定链路用到的 codec、codec_dai、cpu_dai、platform。比如对于 WCD9335 平台的 media 链路：.codec_dai_name = “snd-soc-dummy-dai”, .codec_name = “snd-soc-dummy”, .cpu_dai_name = “MultiMediaX”, .platform_name = “msm-pcm-dsp.0”，这四者就构成了一条音频数据链路用于多媒体声音的回放和录制。一个系统可能有多个音频数据链路，比如 media 和 voice，因此可以定义多个 dai_link 。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"MSM8996 Media1"</span>,</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-dsp.0"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/22-MSM8996-Linux-Android-Audio-ASoc-Architectre.png" alt="Alt text"></p><p>高通平台因DSP而存在特殊性，如上图，Frontend 链接 “Platform”，经由 “Platform”-&gt;Backend链接到Codec。<br>Front-end DAI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm-dai-fe.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">msm_fe_dais</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.playback = &#123;</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1 Playback"</span>,</span><br><span class="line">.aif_name = <span class="string">"MM_DL1"</span>,</span><br><span class="line">.rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">SNDRV_PCM_RATE_KNOT),</span><br><span class="line">.formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">8</span>,</span><br><span class="line">.rate_min =     <span class="number">8000</span>,</span><br><span class="line">.rate_max =<span class="number">192000</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.capture = &#123;</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1 Capture"</span>,</span><br><span class="line">.aif_name = <span class="string">"MM_UL1"</span>,</span><br><span class="line">.rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">SNDRV_PCM_RATE_KNOT),</span><br><span class="line">.formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">    SNDRV_PCM_FMTBIT_S24_LE|</span><br><span class="line">    SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">4</span>,</span><br><span class="line">.rate_min =     <span class="number">8000</span>,</span><br><span class="line">.rate_max =<span class="number">48000</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;msm_fe_Multimedia_dai_ops,</span><br><span class="line">.name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.probe = fe_dai_probe,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Back-end DAI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_tasha_be_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* Backend DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = LPASS_BE_SLIMBUS_0_RX,</span><br><span class="line">.stream_name = <span class="string">"Slimbus Playback"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"msm-dai-q6-dev.16384"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-routing"</span>,</span><br><span class="line">.codec_name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"tasha_mix_rx1"</span>,</span><br><span class="line">.no_pcm = <span class="number">1</span>,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX,</span><br><span class="line">.init = &amp;msm_audrx_init,</span><br><span class="line">.be_hw_params_fixup = msm_slim_0_rx_be_hw_params_fixup,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">.ops = &amp;msm8996_be_ops,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> struct snd_soc_dai_link msm8996_tasha_fe_dai_links[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">.name = LPASS_BE_SLIMBUS_4_TX,</span><br><span class="line">.stream_name = <span class="string">"Slimbus4 Capture"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"msm-dai-q6-dev.16393"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-hostless"</span>,</span><br><span class="line">.codec_name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"tasha_vifeedback"</span>,</span><br><span class="line">.be_id = MSM_BACKEND_DAI_SLIMBUS_4_TX,</span><br><span class="line">.be_hw_params_fixup = msm_slim_4_tx_be_hw_params_fixup,</span><br><span class="line">.ops = &amp;msm8996_be_ops,</span><br><span class="line">.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hw constraints：指平台本身的硬件限制，如所能支持的通道数/采样率/数据格式、DMA 支持的数据周期大小（period size）、周期次数（period count）等，通过 snd_pcm_hardware 结构体描述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hardware</span> <span class="title">msm_pcm_hardware_capture</span> = &#123;</span></span><br><span class="line">.info =                 (SNDRV_PCM_INFO_MMAP |</span><br><span class="line">SNDRV_PCM_INFO_BLOCK_TRANSFER |</span><br><span class="line">SNDRV_PCM_INFO_MMAP_VALID |</span><br><span class="line">SNDRV_PCM_INFO_INTERLEAVED |</span><br><span class="line">SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),</span><br><span class="line">.formats =              (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.rates =                SNDRV_PCM_RATE_8000_48000,</span><br><span class="line">.rate_min =             <span class="number">8000</span>,</span><br><span class="line">.rate_max =             <span class="number">48000</span>,</span><br><span class="line">.channels_min =         <span class="number">1</span>,</span><br><span class="line">.channels_max =         <span class="number">4</span>,</span><br><span class="line">.buffer_bytes_max =     CAPTURE_MAX_NUM_PERIODS *</span><br><span class="line">CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">.period_bytes_min =CAPTURE_MIN_PERIOD_SIZE,</span><br><span class="line">.period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">.periods_min =          CAPTURE_MIN_NUM_PERIODS,</span><br><span class="line">.periods_max =          CAPTURE_MAX_NUM_PERIODS,</span><br><span class="line">.fifo_size =            <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>hw params：用户层设置的硬件参数，如 channels、sample rate、pcm format、period size、period count；这些参数受 hw constraints 约束。</p><p>sw params：用户层设置的软件参数，如 start threshold、stop threshold、silence threshold。</p><h4 id="（二）ASoC-Core"><a href="#（二）ASoC-Core" class="headerlink" title="（二）ASoC Core"></a>（二）ASoC Core</h4><p>ASoC：ALSA System on Chip，是建立在标准 ALSA 驱动之上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系，它依赖于标准 ALSA 驱动框架。内核文档 Documentation/alsa/soc/overview.txt 中详细介绍了 ASoC 的设计初衷，这里不一一引用，简单陈述如下：</p><p>• 独立的 codec 驱动，标准的 ALSA 驱动框架里面 codec 驱动往往与 SoC/CPU 耦合过于紧密，不利于在多样化的平台/机器上移植复用<br>• 方便 codec 与 SoC 通过 PCM/I2S 总线建立链接<br>• 动态音频电源管理 DAPM，使得 codec 任何时候都工作在最低功耗状态，同时负责音频路由的创建<br>• POPs 和 click 音抑制弱化处理，在 ASoC 中通过正确的音频部件上下电次序来实现<br>• Machine 驱动的特定控制，比如耳机、麦克风的插拔检测，外放功放的开关<br>在概述中已经介绍了 ASoC 硬件设备驱动的三大构成：Codec、Platform 和 Machine，下面列举各驱动的功能构成：</p><p>ASoC Codec Driver：</p><p>• Codec DAI 和 PCM 的配置信息<br>• Codec 的控制接口，如 I2C/SPI<br>• Mixer 和其他音频控件<br>• Codec 的音频接口函数，见 snd_soc_dai_ops 结构体定义<br>• DAPM 描述信息<br>• DAPM 事件处理句柄<br>• DAC 数字静音控制</p><p>ASoC Platform Driver： 包括 dma 和 cpu_dai 两部分：</p><p>• dma 驱动实现音频 dma 操作，具体见 snd_pcm_ops 结构体定义<br>• cpu_dai 驱动实现音频数字接口控制器的描述和配置<br>• ASoC Machine Driver：</p><p>作为链结 Platform 和 Codec 的载体，它必须配置 dai_link 为音频数据链路指定 Platform 和 Codec<br>处理机器特有的音频控件和音频事件，例如回放时打开外放功放<br>硬件设备驱动相关结构体：</p><p>• snd_soc_codec_driver：音频编解码芯片描述及操作函数，如控件/微件/音频路由的描述信息、时钟配置、IO 控制等<br>• snd_soc_dai_driver：音频数据接口描述及操作函数，根据 codec 端和 soc 端，分为 codec_dai 和 cpu_dai<br>• snd_soc_platform_driver：音频 dma 设备描述及操作函数<br>• snd_soc_dai_link：音频链路描述及板级操作函数</p><h4 id="（三）Codec-Driver"><a href="#（三）Codec-Driver" class="headerlink" title="（三）Codec Driver"></a>（三）Codec Driver</h4><p>基本是以内核文档 Documentation/sound/alsa/soc/codec.txt 中的内容为脉络来分析的。Codec 的作用，之前已有描述，本章主要罗列下 Codec driver 中重要的数据结构及注册流程。<br>其中有着各种功能部件，包括但不限于 ：</p><blockquote><p>ADC    把麦克风拾取的模拟信号转换成数字信号<br>DAC    把音频接口过来的数字信号转换成模拟信号<br>MIXER    混音器，把多路输入信号混合成单路输出</p></blockquote><h5 id="3-1-Codec-DAI-and-PCM-configuration"><a href="#3-1-Codec-DAI-and-PCM-configuration" class="headerlink" title="3.1. Codec DAI and PCM configuration"></a>3.1. Codec DAI and PCM configuration</h5><p>codec_dai 和 pcm 配置信息通过结构体 snd_soc_dai_driver 描述，包括 dai 的能力描述和操作接口，snd_soc_dai_driver 最终会被注册到 soc-core 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment"> * operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment"> * structure for every DAI they have.</span></span><br><span class="line"><span class="comment"> * This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* DAI description */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> ac97_control;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct snd_soc_dai *dai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ops */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI capabilities */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">    <span class="keyword">int</span> probe_order;</span><br><span class="line">    <span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name：codec_dai 的名称标识，dai_link 通过配置 codec_dai_name 来找到对应的 codec_dai；<br>probe：codec_dai 的初始化函数，注册声卡时回调；<br>playback：回放能力描述，如回放设备所支持的声道数、采样率、音频格式；<br>capture：录制能力描述，如录制设备所支持声道数、采样率、音频格式；<br>ops：codec_dai 的操作函数集，这些函数集非常重要，用于 dai 的时钟配置、格式配置、硬件参数配置。</p><p>codec_dai：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">tasha_i2s_dai</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_i2s_rx1"</span>,</span><br><span class="line">.id = AIF1_PB,</span><br><span class="line">.playback = &#123;</span><br><span class="line">.stream_name = <span class="string">"AIF1 Playback"</span>,</span><br><span class="line">.rates = WCD9335_RATES_MASK,</span><br><span class="line">.formats = TASHA_FORMATS_S16_S24_LE,</span><br><span class="line">.rate_max = <span class="number">192000</span>,</span><br><span class="line">.rate_min = <span class="number">8000</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">2</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;tasha_dai_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_i2s_tx1"</span>,</span><br><span class="line">.id = AIF1_CAP,</span><br><span class="line">.capture = &#123;</span><br><span class="line">.stream_name = <span class="string">"AIF1 Capture"</span>,</span><br><span class="line">.rates = WCD9335_RATES_MASK,</span><br><span class="line">.formats = TASHA_FORMATS,</span><br><span class="line">.rate_max = <span class="number">192000</span>,</span><br><span class="line">.rate_min = <span class="number">8000</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">4</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;tasha_dai_ops,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3-2-Codec-control-IO"><a href="#3-2-Codec-control-IO" class="headerlink" title="3.2. Codec control IO"></a>3.2. Codec control IO</h5><p>移动设备的音频 Codec，其控制接口一般是 I2C 或 SPI，控制接口用于读写 codec 的寄存器。在 snd_soc_codec_driver 结构体中，有如下字段描述 Codec 的控制接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="comment">/* codec driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_driver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/* codec IO */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *(*<span class="title">get_regmap</span>)(<span class="title">struct</span> <span class="title">device</span> *);</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*read)</span><span class="params">(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*write)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*display_register)(struct snd_soc_codec *, <span class="keyword">char</span> *,</span><br><span class="line"><span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*volatile_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*readable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*writable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> reg_cache_size;</span><br><span class="line"><span class="keyword">short</span> reg_cache_step;</span><br><span class="line"><span class="keyword">short</span> reg_word_size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *reg_cache_default;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>• read：读寄存器；<br>• write：写寄存器；<br>• volatile_register：判断指定的寄存器是否是 volatile 属性；假如是，则读取寄存器时不是读 cache，而直接访问硬件；<br>• readable_register：判断指定的寄存器是否可读；<br>• reg_cache_default：寄存器的缺省值；<br>• reg_cache_size：缺省的寄存器值数组大小；<br>• reg_word_size：寄存器宽度。<br>在 Linux-3.4.5 中，很多 codec 的控制接口都改用 regmap 了。soc-core 中判断是否用的是 regmap，如果是，则调用 regmap 接口。</p><h5 id="3-3-Mixers-and-audio-controls"><a href="#3-3-Mixers-and-audio-controls" class="headerlink" title="3.3. Mixers and audio controls"></a>3.3. Mixers and audio controls</h5><p>音频控件多用于部件开关和音量的设定，音频控件可通过 soc.h 中的宏来定义，例如单一型控件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;   .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">    .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">    .put = snd_soc_put_volsw, \</span><br><span class="line">    .private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) &#125;</span><br></pre></td></tr></table></figure><p>这种控件只有一个设置量，一般用于部件开关。宏定义的参数说明：</p><p>• xname：控件的名称标识；<br>• reg：控件对应的寄存器地址；<br>• shift：控件控制位在寄存器中的偏移；<br>• max：控件设置值范围；<br>• invert：设定值是否取反。<br>其他类型控件类似，不一一介绍了。</p><p>上述只是宏定义，音频控件真正的结构是 snd_kcontrol_new：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">    <span class="keyword">snd_ctl_elem_iface_t</span> iface; <span class="comment">/* interface identifier */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> device;        <span class="comment">/* device/client number */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;     <span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;  <span class="comment">/* ASCII name of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;     <span class="comment">/* index of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> access;        <span class="comment">/* access rights */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;     <span class="comment">/* count of same elements */</span></span><br><span class="line">    <span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line">    <span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line">    <span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">    &#125; tlv;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Codec 初始化时，通过 snd_soc_add_codec_controls() 把所有定义好的音频控件注册到 alsa-core ，上层可以通过 tinymix、alsa_amixer 等工具查看修改这些控件的设定。</p><h5 id="3-6-Codec-audio-operations"><a href="#3-6-Codec-audio-operations" class="headerlink" title="3.6. Codec audio operations"></a>3.6. Codec audio operations</h5><p>Codec 音频操作接口通过结构体 snd_soc_dai_ops 描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI clocking configuration, all optional.</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*set_sysclk)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">int</span> clk_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq, <span class="keyword">int</span> dir);</span><br><span class="line"><span class="keyword">int</span> (*set_pll)(struct snd_soc_dai *dai, <span class="keyword">int</span> pll_id, <span class="keyword">int</span> source,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> freq_in, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_out);</span><br><span class="line"><span class="keyword">int</span> (*set_clkdiv)(struct snd_soc_dai *dai, <span class="keyword">int</span> div_id, <span class="keyword">int</span> div);</span><br><span class="line"><span class="keyword">int</span> (*set_bclk_ratio)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> ratio);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI format configuration</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*set_fmt)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> fmt);</span><br><span class="line"><span class="keyword">int</span> (*xlate_tdm_slot_mask)(<span class="keyword">unsigned</span> <span class="keyword">int</span> slots,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_mask);</span><br><span class="line"><span class="keyword">int</span> (*set_tdm_slot)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_mask,</span><br><span class="line"><span class="keyword">int</span> slots, <span class="keyword">int</span> slot_width);</span><br><span class="line"><span class="keyword">int</span> (*set_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"><span class="keyword">int</span> (*set_tristate)(struct snd_soc_dai *dai, <span class="keyword">int</span> tristate);</span><br><span class="line"><span class="keyword">int</span> (*get_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释比较详细的了，Codec 音频操作接口分为 5 大部分：时钟配置、格式配置、数字静音、PCM 音频接口、FIFO 延迟。着重说下时钟配置及格式配置接口：</p><p>• set_sysclk：codec_dai 系统时钟设置，当上层打开 pcm 设备时，需要回调该接口设置 Codec 的系统时钟，Codec 才能正常工作；<br>• set_pll：Codec FLL 设置，Codec 一般接了一个 MCLK 输入时钟，回调该接口基于 MCLK 来产生 Codec FLL 时钟，接着 codec_dai 的 sysclk、bclk、lrclk 均可从 FLL 分频出来（假设 Codec 作为 master）；<br>• set_fmt：codec_dai 格式设置，具体见 soc-dai.h；<br>  • SND_SOC_DAIFMT_I2S：音频数据是 I2S 格式，常用于多媒体音频；<br>  • SND_SOC_DAIFMT_DSP_A：音频数据是 PCM 格式，常用于通话语音；<br>  • SND_SOC_DAIFMT_CBM_CFM：Codec 作为 master，BCLK 和 LRCLK 由 Codec 提供；<br>  • SND_SOC_DAIFMT_CBS_CFS：Codec 作为 slave，BCLK 和 LRCLK 由 SoC/CPU 提供；<br>• hw_params：codec_dai 硬件参数设置，根据上层设定的声道数、采样率、数据格式，来配置 codec_dai 相关寄存器。</p><p>WCD9335的snd_soc_dai_ops ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> <span class="title">tasha_dai_ops</span> = &#123;</span></span><br><span class="line">.startup = tasha_startup,</span><br><span class="line">.shutdown = tasha_shutdown,</span><br><span class="line">.hw_params = tasha_hw_params,</span><br><span class="line">.prepare = tasha_prepare,</span><br><span class="line">.set_sysclk = tasha_set_dai_sysclk,</span><br><span class="line">.set_fmt = tasha_set_dai_fmt,</span><br><span class="line">.set_channel_map = tasha_set_channel_map,</span><br><span class="line">.get_channel_map = tasha_get_channel_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="3-6-Codec-register"><a href="#3-6-Codec-register" class="headerlink" title="3.6. Codec register"></a>3.6. Codec register</h5><p>当 platform_driver：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">tasha_codec_driver</span> = &#123;</span></span><br><span class="line">.probe = tasha_probe,</span><br><span class="line">.remove = tasha_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">.pm = &amp;tasha_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与.name = “tasha_codec”  的 platform_device（该 platform_device 在 drivers/mfd/wcd9xxx-core.c 中注册wcd9xxx_device_init-&gt;wcd9xxx_check_codec_type-&gt;tasha_devs）匹配后，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/mfd/wcd9xxx-core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> <span class="title">tasha_devs</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>立即回调 tasha_probe() 注册 Codec：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tasha_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasha_priv</span> *<span class="title">tasha</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">wcd_ext_clk</span>, *<span class="title">wcd_native_clk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_resmgr_v2</span> *<span class="title">resmgr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_power_region</span> *<span class="title">cdc_pwr</span>;</span></span><br><span class="line">......</span><br><span class="line">tasha = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(struct tasha_priv),</span><br><span class="line">    GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    tasha-&gt;resmgr = resmgr;</span><br><span class="line">tasha-&gt;swr_plat_data.handle = (<span class="keyword">void</span> *) tasha;</span><br><span class="line">tasha-&gt;swr_plat_data.read = tasha_swrm_read;</span><br><span class="line">tasha-&gt;swr_plat_data.write = tasha_swrm_write;</span><br><span class="line">tasha-&gt;swr_plat_data.bulk_write = tasha_swrm_bulk_write;</span><br><span class="line">tasha-&gt;swr_plat_data.clk = tasha_swrm_clock;</span><br><span class="line">tasha-&gt;swr_plat_data.handle_irq = tasha_swrm_handle_irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register for Clock */</span></span><br><span class="line">wcd_ext_clk = clk_get(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">"wcd_clk"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(wcd_ext_clk)) &#123;</span><br><span class="line">dev_err(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">"%s: clk get %s failed\n"</span>,</span><br><span class="line">__func__, <span class="string">"wcd_ext_clk"</span>);</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line">tasha-&gt;wcd_ext_clk = wcd_ext_clk;</span><br><span class="line">tasha-&gt;sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;</span><br><span class="line">set_bit(AUDIO_NOMINAL, &amp;tasha-&gt;status_mask);</span><br><span class="line">tasha-&gt;sido_ccl_cnt = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS)</span><br><span class="line">ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">     tasha_dai, ARRAY_SIZE(tasha_dai));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)</span><br><span class="line">ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">     tasha_i2s_dai,</span><br><span class="line">     ARRAY_SIZE(tasha_i2s_dai));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snd_soc_register_codec：将 codec_driver 和 codec_dai_driver 注册到 soc-core。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_soc_register_codec - Register a codec with the ASoC core</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @codec: codec to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_register_codec</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct snd_soc_codec_driver *codec_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               struct snd_soc_dai_driver *dai_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> num_dai)</span></span></span><br></pre></td></tr></table></figure><p>创建一个 snd_soc_codec 实例，包含 codec_drv（snd_soc_dai_driver）相关信息，封装给 soc-core 使用，相关代码段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"></span><br><span class="line">    dev_dbg(dev, <span class="string">"codec register %s\n"</span>, dev_name(dev));</span><br><span class="line"></span><br><span class="line">    codec = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_codec), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create CODEC component name */</span></span><br><span class="line">    codec-&gt;name = fmt_single_name(dev, &amp;codec-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kfree(codec);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Codec 的寄存器缓存配置及读写接口</span></span><br><span class="line">    codec-&gt;write = codec_drv-&gt;write;</span><br><span class="line">    codec-&gt;read = codec_drv-&gt;read;</span><br><span class="line">    codec-&gt;volatile_register = codec_drv-&gt;volatile_register;</span><br><span class="line">    codec-&gt;readable_register = codec_drv-&gt;readable_register;</span><br><span class="line">    codec-&gt;writable_register = codec_drv-&gt;writable_register;</span><br><span class="line">    codec-&gt;ignore_pmdown_time = codec_drv-&gt;ignore_pmdown_time;</span><br><span class="line">    codec-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;</span><br><span class="line">    codec-&gt;dapm.dev = dev;</span><br><span class="line">    codec-&gt;dapm.codec = codec;</span><br><span class="line">    codec-&gt;dapm.seq_notifier = codec_drv-&gt;seq_notifier;</span><br><span class="line">    codec-&gt;dapm.stream_event = codec_drv-&gt;stream_event;</span><br><span class="line">    codec-&gt;dev = dev;</span><br><span class="line">    codec-&gt;driver = codec_drv;</span><br><span class="line">    codec-&gt;num_dai = num_dai;</span><br><span class="line">    mutex_init(&amp;codec-&gt;mutex);</span><br></pre></td></tr></table></figure><p>把以上 codec 实例插入到 codec_list链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec 并绑定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;codec-&gt;<span class="built_in">list</span>, &amp;codec_list);</span><br></pre></td></tr></table></figure><p>把 codec_drv 中的 snd_soc_dai_driver（tasha_dai 或者tasha_i2s_dai ）注册到 soc-core：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">snd_soc_register_dais(&amp;codec-&gt;component, dai_drv, num_dai, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>snd_soc_register_dais() 会把 dai 插入到 dai_list 链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec_dai 并绑定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;dai_list);</span><br></pre></td></tr></table></figure><p>最后顺便提下 codec 和 codec_dai 的区别：codec 指音频芯片共有的部分，包括 codec 初始化函数、控制接口、寄存器缓存、控件、dapm 部件、音频路由、偏置电压设置函数等描述信息；而 codec_dai 指 codec 上的音频接口驱动描述，包括时钟配置、格式配置、能力描述等等，各个接口的描述信息不一定都是一致的，所以每个音频接口都有着各自的驱动描述。</p><h4 id="（四）Platform-Driver"><a href="#（四）Platform-Driver" class="headerlink" title="（四）Platform Driver"></a>（四）Platform Driver</h4><p>概述中提到音频 Platform 驱动主要用于音频数据传输，这里又细分为两步：</p><p>启动 dma 设备，把音频数据从 dma buffer 搬运到 cpu_dai FIFO，这部分驱动用 snd_soc_platform_driver 描述，后面分析用 pcm_dma 指代它。<br>启动数字音频接口控制器（I2S/PCM/AC97），把音频数据从 cpu_dai FIFO 传送到 codec_dai（高通平台会将数据传送到ADSP）这部分驱动用 snd_soc_dai_driver 描述，后面分析用 cpu_dai 指代它。</p><blockquote><p>MSM8996 包含三个 Hexagon DSP ：application, modem, and sensor。<br>Application  DSP：不仅可以处理语音和音频，还可以处理计算机 视觉、视频、图像和Camera。<br> Sensor DSP：也叫做SLPI，所有的sensor都链接到SLPI上面，它管理所有的Sensor及相关算法。</p></blockquote><p>对于 cpu_dai 驱动，从上面的类图我们可知，主要工作有：</p><p>实现 dai 操作函数，见 snd_soc_dai_ops 定义，用于配置和操作音频数字接口控制器，如时钟配置 set_sysclk()、格式配置 set_fmt()、硬件参数配置 hw_params()、启动/停止数据传输 trigger() 等；<br>实现 probe 函数（初始化）、remove 函数（卸载）、suspend/resume 函数（电源管理）；<br>初始化 snd_soc_dai_driver 实例，包括回放和录制的能力描述、dai 操作函数集、probe/remove 回调、电源管理相关的 suspend/resume 回调；<br>通过 snd_soc_register_dai() 把初始化完成的 snd_soc_dai_driver 注册到 soc-core：首先创建一个 snd_soc_dai 实例，然后把该 snd_soc_dai 实例插入到 dai_list 链表（声卡注册时会遍历该链表，找到 dai_link 声明的 cpu_dai 并绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_register_dais</span><span class="params">(struct snd_soc_component *component,</span></span></span><br><span class="line"><span class="function"><span class="params">struct snd_soc_dai_driver *dai_drv, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> legacy_dai_naming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">component</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">dai</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">dev_dbg(dev, <span class="string">"ASoC: dai register %s #%Zu\n"</span>, dev_name(dev), count);</span><br><span class="line"></span><br><span class="line">component-&gt;dai_drv = dai_drv;</span><br><span class="line">component-&gt;num_dai = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">dai = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dai), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; legacy_dai_naming) &#123;</span><br><span class="line">dai-&gt;name = fmt_single_name(dev, &amp;dai-&gt;id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dai-&gt;name = fmt_multiple_name(dev, &amp;dai_drv[i]);</span><br><span class="line"><span class="keyword">if</span> (dai_drv[i].id)</span><br><span class="line">dai-&gt;id = dai_drv[i].id;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dai-&gt;id = i;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">dai-&gt;component = component;</span><br><span class="line">dai-&gt;dev = dev;</span><br><span class="line">dai-&gt;driver = &amp;dai_drv[i];</span><br><span class="line"><span class="keyword">if</span> (!dai-&gt;driver-&gt;ops)</span><br><span class="line">dai-&gt;driver-&gt;ops = &amp;null_dai_ops;</span><br><span class="line"></span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;component-&gt;dai_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dai 操作函数的实现是 cpu_dai 驱动的主体，需要配置好相关寄存器让 I2S/PCM 总线控制器正常运转，snd_soc_dai_ops 字段的详细说明见 3.6. Codec audio operations 章节。</p><p>cpu_dai 驱动应该算是这个系列中最简单的一环，因此不多花费笔墨在这里了。倒是某些平台上，dma 设备信息（总线地址、通道号、传输单元大小）是在这里初始化的，这点要留意，这些 dma 设备信息在 pcm_dma 驱动中用到。</p><h5 id="4-1-pcm-operations"><a href="#4-1-pcm-operations" class="headerlink" title="4.1. pcm operations"></a>4.1. pcm operations</h5><p>操作函数的实现是本模块的主体，见 snd_pcm_ops 结构体描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/pcm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> (*open)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*close)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*ioctl)(struct snd_pcm_substream * substream,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">int</span> (*compat_ioctl)(struct snd_pcm_substream *substream,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">int</span> (*hw_params)(struct snd_pcm_substream *substream,</span><br><span class="line"> struct snd_pcm_hw_params *params);</span><br><span class="line"><span class="keyword">int</span> (*hw_free)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*prepare)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*trigger)(struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd);</span><br><span class="line"><span class="keyword">snd_pcm_uframes_t</span> (*pointer)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*delay_blk)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*wall_clock)(struct snd_pcm_substream *substream,</span><br><span class="line">  struct timespec *audio_ts);</span><br><span class="line"><span class="keyword">int</span> (*copy)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">    <span class="keyword">snd_pcm_uframes_t</span> pos,</span><br><span class="line">    <span class="keyword">void</span> __user *buf, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line"><span class="keyword">int</span> (*silence)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">       <span class="keyword">snd_pcm_uframes_t</span> pos, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">page</span>)(<span class="title">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>,</span></span><br><span class="line"><span class="class">     <span class="title">unsigned</span> <span class="title">long</span> <span class="title">offset</span>);</span></span><br><span class="line"><span class="keyword">int</span> (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);</span><br><span class="line"><span class="keyword">int</span> (*ack)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*restart)(struct snd_pcm_substream *substream);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-1-platform-driver-注册"><a href="#4-1-platform-driver-注册" class="headerlink" title="4.1. platform_driver 注册"></a>4.1. platform_driver 注册</h5><p>当 platform_driver：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm_pcm_driver</span> = &#123;</span></span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"msm-pcm-dsp"</span>,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.of_match_table = msm_pcm_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = msm_pcm_probe,</span><br><span class="line">.remove = msm_pcm_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与 .name = “msm-pcm-dsp” 的 platform_device 注册 匹配后，系统会回调 msm_pcm_probe() 注册 platform：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_pcm_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_plat_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *latency_level;</span><br><span class="line"></span><br><span class="line">rc = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,msm-pcm-dsp-id"</span>, &amp;id);</span><br><span class="line">......</span><br><span class="line">pdata = kzalloc(<span class="keyword">sizeof</span>(struct msm_plat_data), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,msm-pcm-low-latency"</span>)) &#123;</span><br><span class="line">pdata-&gt;perf_mode = LOW_LATENCY_PCM_MODE;</span><br><span class="line">rc = of_property_read_string(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,latency-level"</span>, &amp;latency_level);</span><br><span class="line"><span class="keyword">if</span> (!rc) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">"ultra"</span>))</span><br><span class="line">pdata-&gt;perf_mode = ULTRA_LOW_LATENCY_PCM_MODE;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">"ull-pp"</span>))</span><br><span class="line">pdata-&gt;perf_mode =</span><br><span class="line">ULL_POST_PROCESSING_PCM_MODE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pdata-&gt;perf_mode = LEGACY_PCM_MODE;</span><br><span class="line"></span><br><span class="line">dev_set_drvdata(&amp;pdev-&gt;dev, pdata);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> snd_soc_register_platform(&amp;pdev-&gt;dev,</span><br><span class="line">   &amp;msm_soc_platform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>snd_soc_register_platform：将 platform_drv 注册到 soc-core。<br>创建一个 snd_soc_platform 实例，包含 platform_drv（snd_soc_platform_driver）的相关信息，封装给 soc-core 使用；<br>把以上创建的 platform 实例插入到 platform_list 链表上（声卡注册时会遍历该链表，找到 dai_link 声明的 platform 并绑定）。<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int snd_soc_register_platform(struct device *dev,</span><br><span class="line">const struct snd_soc_platform_driver *platform_drv)</span><br><span class="line">&#123;</span><br><span class="line">struct snd_soc_platform *platform;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">ret = snd_soc_add_platform(dev, platform, platform_drv);</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成了 Platform 驱动的实现。回放情形下，pcm_dma 设备负责把 dma buffer 中的数据搬运到 I2S tx FIFO，I2S 总线控制器负责把 I2S tx FIFO 中的数据传送DSP，DSP经处理后传送到到 Codec。</p><h4 id="（五）-Machine-Driver"><a href="#（五）-Machine-Driver" class="headerlink" title="（五）  Machine Driver"></a>（五）  Machine Driver</h4><p>章节 3. Codec 和 4. Platform 介绍了 Codec、Platform 驱动，但仅有 Codec、Platform 驱动是不能工作的，需要一个角色把 codec、codec_dai、cpu_dai、platform 给链结起来才能构成一个完整的音频链路，这个角色就由 machine_drv 承担了。</p><p>snd_soc_dai_link 结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* Codec name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *stream_name;<span class="comment">/* Stream name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpu_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">cpu_of_node</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpu_dai_name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *codec_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">codec_of_node</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *codec_dai_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *platform_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">platform_of_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> be_id;<span class="comment">/* optional ID for machine driver BE identification */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dai_fmt;           <span class="comment">/* format to set on init */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dpcm_trigger trigger[<span class="number">2</span>]; <span class="comment">/* trigger type for DPCM */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_suspend:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> no_pcm:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dynamic:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> no_host_mode:<span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_capture:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_playback:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_pmdown_time:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> (*init)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line"><span class="keyword">int</span> (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">struct snd_pcm_hw_params *params);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line"><span class="keyword">bool</span> playback_only;</span><br><span class="line"><span class="keyword">bool</span> capture_only;</span><br><span class="line"><span class="keyword">enum</span> snd_soc_async_ops async_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点介绍如下几个字段：</p><p>• codec_name：音频链路需要绑定的 codec 名称，声卡注册时会遍历 codec_list，找到同名的 codec 并绑定；<br>• platform_name：音频链路需要绑定的 platform 名称，声卡注册时会遍历 platform_list，找到同名的 platform 并绑定；<br>• cpu_dai_name：音频链路需要绑定的 cpu_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>• codec_dai_name：音频链路需要绑定的 codec_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>ops：重点留意 hw_params() 回调，一般来说这个回调是要实现的，用于配置 codec、codec_dai、cpu_dai 的数据格式和系统时钟。在 3.6. Codec audio operations 小节中有描述。<br>/sound/soc/msm/msm8996.c 中的 dai_link 定义，两个音频链路分别用于 Media和 Voice：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"MSM8996 Media1"</span>,</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-dsp.0"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.stream_name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-voice"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">    SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_VOICEMMODE1,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 dai_link，机器中一些特定的音频控件和音频事件也可以在 machine_drv 定义，如耳机插拔检测、外部功放打开关闭等。</p><p>我们再分析 machine_drv 初始化过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line">static struct platform_driver msm8996_asoc_machine_driver = &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = DRV_NAME,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.pm = &amp;snd_soc_pm_ops,</span><br><span class="line">.of_match_table = msm8996_asoc_machine_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = msm8996_asoc_machine_probe,</span><br><span class="line">.remove = msm8996_asoc_machine_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm8996_asoc_machine_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm8996_asoc_mach_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mbhc_audio_jack_type = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *mclk_freq_prop_name;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">    ......</span><br><span class="line">pdata = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(struct msm8996_asoc_mach_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">card = populate_snd_card_dailinks(&amp;pdev-&gt;dev);</span><br><span class="line">......</span><br><span class="line">match = of_match_node(msm8996_asoc_machine_of_match,</span><br><span class="line">pdev-&gt;dev.of_node);</span><br><span class="line">ret = msm8996_populate_dai_link_component_of_node(card);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ret = snd_soc_register_card(card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置dailinks后，继而调用 snd_soc_register_card() 注册声卡。由于该过程很冗长，这里不一一贴代码分析了，但整个流程是比较简单的，流程图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/23-Audio-system-msm8996-probe-snd-card-register.png" alt="Alt text"></p><p>• 取出 platform_device 的私有数据，该私有数据就是 snd_soc_card ；<br>• snd_soc_register_card() 为每个 dai_link 分配一个 snd_soc_pcm_runtime 实例，别忘了之前提过 snd_soc_pcm_runtime 是 ASoC 的桥梁，保存着 codec、codec_dai、cpu_dai、platform 等硬件设备实例。<br>• 随后的工作都在 snd_soc_instantiate_card() 进行：<br>• 遍历 dai_list、codec_list、platform_list 链表，为每个音频链路找到对应的 cpu_dai、codec_dai、codec、platform；找到的 cpu_dai、codec_dai、codec、platform 保存到 snd_soc_pcm_runtime ，完成音频链路的设备绑定；<br>• 调用 snd_card_create() 创建声卡；<br>• soc_probe_dai_link() 依次回调 cpu_dai、codec、platform、codec_dai 的 probe() 函数，完成各音频设备的初始化，随后调用<br>• soc_new_pcm() 创建 pcm 逻辑设备（因为涉及到本系列的重点内容，后面具体分析这个函数）；<br>最后调用 snd_card_register() 注册声卡。</p><p>[-&gt;sound/soc/soc-core.c]</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/24-Audio-system-msm8996-probe-snd-card.png" alt="Alt text"></p><p>soc_new_pcm 源码分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-pcm.c]</span><br><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">soc_new_pcm</span><span class="params">(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_platform</span> *<span class="title">platform</span> = <span class="title">rtd</span>-&gt;<span class="title">platform</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">codec_dai</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">cpu_dai</span> = <span class="title">rtd</span>-&gt;<span class="title">cpu_dai</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line"><span class="keyword">char</span> new_name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, playback = <span class="number">0</span>, capture = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic || rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line">playback = rtd-&gt;dai_link-&gt;dpcm_playback;</span><br><span class="line">capture = rtd-&gt;dai_link-&gt;dpcm_capture;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rtd-&gt;num_codecs; i++) &#123;</span><br><span class="line">codec_dai = rtd-&gt;codec_dais[i];</span><br><span class="line"><span class="keyword">if</span> (codec_dai-&gt;driver-&gt;playback.channels_min)</span><br><span class="line">playback = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (codec_dai-&gt;driver-&gt;capture.channels_min)</span><br><span class="line">capture = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span><br><span class="line">playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;playback_only) &#123;</span><br><span class="line">playback = <span class="number">1</span>;</span><br><span class="line">capture = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;capture_only) &#123;</span><br><span class="line">playback = <span class="number">0</span>;</span><br><span class="line">capture = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the PCM */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"(%s)"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"></span><br><span class="line">ret = snd_pcm_new_internal(rtd-&gt;card-&gt;snd_card, new_name, num,</span><br><span class="line">playback, capture, &amp;pcm);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic)</span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"%s (*)"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"%s %s-%d"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name,</span><br><span class="line">(rtd-&gt;num_codecs &gt; <span class="number">1</span>) ?</span><br><span class="line"><span class="string">"multicodec"</span> : rtd-&gt;codec_dai-&gt;name, num);</span><br><span class="line"></span><br><span class="line">ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback,</span><br><span class="line">capture, &amp;pcm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(rtd-&gt;card-&gt;dev, <span class="string">"ASoC: can't create pcm for %s\n"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;name);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">dev_dbg(rtd-&gt;card-&gt;dev, <span class="string">"ASoC: registered pcm #%d %s\n"</span>,num, new_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DAPM dai link stream work */</span></span><br><span class="line">INIT_DELAYED_WORK(&amp;rtd-&gt;delayed_work, close_delayed_work);</span><br><span class="line"></span><br><span class="line">rtd-&gt;pcm = pcm;</span><br><span class="line">pcm-&gt;private_data = rtd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line"><span class="keyword">if</span> (playback)</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;private_data = rtd;</span><br><span class="line"><span class="keyword">if</span> (capture)</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;private_data = rtd;</span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new)</span><br><span class="line">rtd-&gt;platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setup any hostless PCMs - i.e. no host IO is performed */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_host_mode) &#123;</span><br><span class="line"><span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream) &#123;</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">snd_soc_set_runtime_hwparams(</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream,</span><br><span class="line">&amp;no_host_hardware);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream) &#123;</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">snd_soc_set_runtime_hwparams(</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream,</span><br><span class="line">&amp;no_host_hardware);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ASoC PCM operations */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">rtd-&gt;ops.open= dpcm_fe_dai_open;</span><br><span class="line">rtd-&gt;ops.hw_params= dpcm_fe_dai_hw_params;</span><br><span class="line">rtd-&gt;ops.prepare= dpcm_fe_dai_prepare;</span><br><span class="line">rtd-&gt;ops.trigger= dpcm_fe_dai_trigger;</span><br><span class="line">rtd-&gt;ops.hw_free= dpcm_fe_dai_hw_free;</span><br><span class="line">rtd-&gt;ops.close= dpcm_fe_dai_close;</span><br><span class="line">rtd-&gt;ops.pointer= soc_pcm_pointer;</span><br><span class="line">rtd-&gt;ops.delay_blk= soc_pcm_delay_blk;</span><br><span class="line">rtd-&gt;ops.ioctl= soc_pcm_ioctl;</span><br><span class="line">rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rtd-&gt;ops.open= soc_pcm_open;</span><br><span class="line">rtd-&gt;ops.hw_params= soc_pcm_hw_params;</span><br><span class="line">rtd-&gt;ops.prepare= soc_pcm_prepare;</span><br><span class="line">rtd-&gt;ops.trigger= soc_pcm_trigger;</span><br><span class="line">rtd-&gt;ops.hw_free= soc_pcm_hw_free;</span><br><span class="line">rtd-&gt;ops.close= soc_pcm_close;</span><br><span class="line">rtd-&gt;ops.pointer= soc_pcm_pointer;</span><br><span class="line">rtd-&gt;ops.delay_blk= soc_pcm_delay_blk;</span><br><span class="line">rtd-&gt;ops.ioctl= soc_pcm_ioctl;</span><br><span class="line">rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">rtd-&gt;ops.ack= platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">rtd-&gt;ops.copy= platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">rtd-&gt;ops.silence= platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">rtd-&gt;ops.page= platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">rtd-&gt;ops.mmap= platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">rtd-&gt;ops.restart= platform-&gt;driver-&gt;ops-&gt;restart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (playback)</span><br><span class="line">snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (capture)</span><br><span class="line">snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new) &#123;</span><br><span class="line">ret = platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(platform-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: pcm constructor failed: %d\n"</span>,</span><br><span class="line">ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pcm-&gt;private_free = platform-&gt;driver-&gt;pcm_free;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 soc_new_pcm() 最主要的工作是创建 pcm 逻辑设备，创建回放子流和录制子流实例，并初始化回放子流和录制子流的 pcm 操作函数（数据搬运时，需要调用这些函数来驱动 codec、codec_dai、cpu_dai、dma 设备工作）。</p><h4 id="（六）、声卡和-PCM-设备的建立过程"><a href="#（六）、声卡和-PCM-设备的建立过程" class="headerlink" title="（六）、声卡和 PCM 设备的建立过程"></a>（六）、声卡和 PCM 设备的建立过程</h4><p>前面几章分析了 Codec、Platform、Machine 驱动的组成部分及其注册过程，这三者都是物理设备相关的，大家应该对音频物理链路有了一定的认知。接着分析音频驱动的中间层，由于这些并不是真正的物理设备，故我们称之为逻辑设备。</p><p>PCM 逻辑设备，我们又习惯称之为 PCM 中间层或 pcm native，起着承上启下的作用：往上是与用户态接口的交互，实现音频数据在用户态和内核态之间的拷贝；往下是触发 codec、platform、machine 的操作函数，实现音频数据在 dma_buffer &lt;-&gt; cpu_dai &lt;-&gt; codec 之间的传输。后面章节将会详细分析这个过程，这里还是先从声卡的注册谈起。<br>声卡驱动中，一般挂载着多个逻辑设备，看看我们计算机的声卡驱动有几个逻辑设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/asound/devices </span><br><span class="line">  2: [ 0]   : control</span><br><span class="line">  3: [ 0- 0]: digital audio playback</span><br><span class="line">  4: [ 0- 0]: digital audio capture</span><br><span class="line">  5: [ 0- 1]: digital audio playback</span><br><span class="line">  6: [ 0- 1]: digital audio capture</span><br><span class="line"> ......</span><br><span class="line"> 27: [ 0-16]: digital audio playback</span><br><span class="line"> 28: [ 0-16]: digital audio capture</span><br><span class="line"> 29: [ 0-17]: digital audio playback</span><br><span class="line"> 30: [ 0-17]: digital audio capture</span><br><span class="line"> 33:        : timer</span><br></pre></td></tr></table></figure><blockquote><p>digital audio playback    用于回放的 PCM 设备<br>digital audio capture    用于录制的 PCM 设备<br>control    用于声卡控制的 CTL 设备，如通路控制、音量调整等<br>timer    定时器设备<br>手机系统中，通常我们更关心 PCM 和 CTL 这两种设备。</p></blockquote><p>设备节点如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">adb shell ls -l /dev/snd</span><br><span class="line">crw-rw---- 1 system audio 116,  51 1970-06-19 02:07 comprC0D24</span><br><span class="line">crw-rw---- 1 system audio 116,  52 1970-06-19 02:07 comprC0D27</span><br><span class="line">crw-rw---- 1 system audio 116,  53 1970-06-19 02:07 comprC0D28</span><br><span class="line">......</span><br><span class="line">crw-rw---- 1 system audio 116,   2 1970-06-19 02:07 controlC0</span><br><span class="line">crw-rw---- 1 system audio 116,  59 1970-06-19 02:07 hwC0D1000</span><br><span class="line">crw-rw---- 1 system audio 116,  66 1970-06-19 02:07 hwC0D11</span><br><span class="line">crw-rw---- 1 system audio 116,  67 1970-06-19 02:07 hwC0D12</span><br><span class="line">crw-rw---- 1 system audio 116,  76 1970-06-19 02:07 hwC0D13</span><br><span class="line">......</span><br><span class="line">crw-rw---- 1 system audio 116,  13 1970-06-19 02:07 pcmC0D6c</span><br><span class="line">crw-rw---- 1 system audio 116,  14 1970-06-19 02:07 pcmC0D7p</span><br><span class="line">crw-rw---- 1 system audio 116,  15 1970-06-19 02:07 pcmC0D8c</span><br><span class="line">crw-rw---- 1 system audio 116,  33 1970-06-19 02:07 timer</span><br></pre></td></tr></table></figure><p>可以看到这些设备节点的 Major=116，Minor 则与 /proc/asound/devices 所列的对应起来，都是字符设备。上层可以通过 open/close/read/write/ioctl 等系统调用来操作声卡设备，这和其他字符设备类似，但一般情况下我们会使用已封装好的用户接口库如 tinyalsa、alsa-lib。</p><h5 id="6-1-声卡结构概述"><a href="#6-1-声卡结构概述" class="headerlink" title="6.1. 声卡结构概述"></a>6.1. 声卡结构概述</h5><p>回顾下 ASoC 是如何注册声卡的，详细请参考章节 5. ASoC machine driver，这里仅简单陈述下：</p><p>• Machine 驱动初始化时，.name = “soc-audio” 的 platform_device 与 platform_driver 匹配成功，触发 soc_probe() 调用；<br>• 继而调用 snd_soc_register_card()：<br>  ﹋• 为每个音频物理链路找到对应的 codec、codec_dai、cpu_dai、platform 设备实例，完成 dai_link 的绑定；<br>  ﹋ • 调用 snd_card_create() 创建声卡；<br>  ﹋ • 依次回调 cpu_dai、codec、platform 的 probe() 函数，完成物理设备的初始化；<br>• 随后调用 soc_new_pcm()：<br>  ﹋ • 设置 pcm native 中要使用的 pcm 操作函数，这些函数用于驱动音频物理设备，包括 machine、codec_dai、cpu_dai、platform；<br>  ﹋ • 调用 snd_pcm_new() 创建 pcm 逻辑设备，回放子流和录制子流都在这里创建；<br>  ﹋ • 回调 platform 驱动的 pcm_new()，完成音频 dma 设备初始化和 dma buffer 内存分配；<br>• 最后调用 snd_card_register() 注册声卡。<br>关于音频物理设备部分（Codec/Platform/Machine）不再累述，下面详细分析声卡和 PCM 逻辑设备的注册过程。</p><p>上面提到声卡驱动上挂着多个逻辑子设备，有 pcm 音频数据流、control 混音器、midi 迷笛、timer 定时器等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                  +-----------+</span><br><span class="line">                  | snd_card  |</span><br><span class="line">                  +-----------+</span><br><span class="line">                    |   |   |</span><br><span class="line">        +-----------+   |   +------------+</span><br><span class="line">        |               |                |</span><br><span class="line">+-----------+    +-----------+    +-----------+</span><br><span class="line"> |  snd_pcm  |    |snd_control|    | snd_timer |    ...</span><br><span class="line"> +-----------+    +-----------+    +-----------+</span><br></pre></td></tr></table></figure><p>这些与声音相关的逻辑设备都在结构体 snd_card 管理之下，可以说 snd_card 是 alsa 中最顶层的结构。我们再看看 alsa 声卡驱动的大致结构图（不是严格的 UML 类图，有结构体定义、模块关系、函数调用，方便标示结构模块的层次及关系）：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/25-Audio-system-snd-card-uml.png" alt="Alt text"></p><p>snd_cards：记录着所注册的声卡实例，每个声卡实例有着各自的逻辑设备，如 PCM 设备、CTL 设备、MIDI 设备等，并一一记录到 snd_card 的 devices 链表上<br>snd_minors：记录着所有逻辑设备的上下文信息，它是声卡逻辑设备与系统调用 API 之间的桥梁；每个 snd_minor 在逻辑设备注册时被填充，在逻辑设备使用时就可以从该结构体中得到相应的信息（主要是系统调用函数集 file_operations）</p><h5 id="6-2-声卡的创建snd-card-create"><a href="#6-2-声卡的创建snd-card-create" class="headerlink" title="6.2. 声卡的创建snd_card_create()"></a>6.2. 声卡的创建snd_card_create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/core/init.c]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  snd_card_new - create and initialize a soundcard structure</span></span><br><span class="line"><span class="comment"> *  @parent: the parent device object</span></span><br><span class="line"><span class="comment"> *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]</span></span><br><span class="line"><span class="comment"> *  @xid: card identification (ASCII string)</span></span><br><span class="line"><span class="comment"> *  @module: top level module for locking</span></span><br><span class="line"><span class="comment"> *  @extra_size: allocate this extra size after the main soundcard structure</span></span><br><span class="line"><span class="comment"> *  @card_ret: the pointer to store the created card instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Creates and initializes a soundcard structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The function allocates snd_card instance via kzalloc with the given</span></span><br><span class="line"><span class="comment"> *  space for the driver to use freely.  The allocated struct is stored</span></span><br><span class="line"><span class="comment"> *  in the given card_ret pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Return: Zero if successful or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_card_new</span><span class="params">(struct device *parent, <span class="keyword">int</span> idx, <span class="keyword">const</span> <span class="keyword">char</span> *xid,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">int</span> extra_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct snd_card **card_ret)</span></span></span><br></pre></td></tr></table></figure><p>注释非常详细，简单说下：<br>idx：声卡的编号，如为 -1，则由系统自动分配<br>xid：声卡标识符，如为 NULL，则以 snd_card 的 shortname 或 longname 代替<br>card_ret：返回所创建的声卡实例的指针<br>如下是Google Pixel手机的声卡信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">sailfish:/ $ cat /proc/asound/cards</span><br><span class="line"> 0 [msm8996tashamar]: msm8996-tasha-m - msm8996-tasha-marlin-snd-card</span><br><span class="line">                      msm8996-tasha-marlin-snd-card</span><br></pre></td></tr></table></figure></p><h5 id="6-3-逻辑设备的创建"><a href="#6-3-逻辑设备的创建" class="headerlink" title="6.3. 逻辑设备的创建"></a>6.3. 逻辑设备的创建</h5><p>当声卡实例建立后，接着可以创建声卡下面的各个逻辑设备了。每个逻辑设备创建时，都会调用 snd_device_new() 生成一个 snd_device 实例，并把该实例挂到声卡 snd_card 的 devices 链表上。alsa 驱动为各种逻辑设备提供了创建接口，如下：</p><blockquote><p>PCM    snd_pcm_new()<br>CONTROL    snd_ctl_create()<br>MIDI    snd_rawmidi_new()<br>TIMER    snd_timer_new()<br>SEQUENCER    snd_seq_device_new()<br>JACK    snd_jack_new()</p></blockquote><p>这些接口的一般过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_xxx_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这些接口供逻辑设备注册时回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_device_ops</span> <span class="title">ops</span> = &#123;</span></span><br><span class="line">        .dev_free = snd_xxx_dev_free,</span><br><span class="line">        .dev_register = snd_xxx_dev_register,</span><br><span class="line">        .dev_disconnect = snd_xxx_dev_disconnect,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑设备实例初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个设备实例 snd_device，挂到 snd_card 的 devices 链表上，把该逻辑设备纳入声卡的管理当中，SNDRV_DEV_xxx 是逻辑设备的类型</span></span><br><span class="line">    <span class="keyword">return</span> snd_device_new(card, SNDRV_DEV_xxx, card, &amp;ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 snd_device_ops 是声卡逻辑设备的注册函数集，dev_register() 回调尤其重要，它在声卡注册时被调用，用于建立系统的设备节点，/dev/snd/ 目录的设备节点都是在这里创建的，通过这些设备节点可系统调用 open/release/read/write/ioctl… 访问操作该逻辑设备。</p><p>例如 snd_ctl_dev_register()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/control.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">snd_ctl_f_ops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.owner =THIS_MODULE,</span><br><span class="line">.read =snd_ctl_read,</span><br><span class="line">.open =snd_ctl_open,</span><br><span class="line">.release =snd_ctl_release,</span><br><span class="line">.llseek =no_llseek,</span><br><span class="line">.poll =snd_ctl_poll,</span><br><span class="line">.unlocked_ioctl =snd_ctl_ioctl,</span><br><span class="line">.compat_ioctl =snd_ctl_ioctl_compat,</span><br><span class="line">.fasync =snd_ctl_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * registration of the control device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_ctl_dev_register</span><span class="params">(struct snd_device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span> = <span class="title">device</span>-&gt;<span class="title">device_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, cardnum;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_BUG_ON(!card))</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line">cardnum = card-&gt;number;</span><br><span class="line"><span class="keyword">if</span> (snd_BUG_ON(cardnum &lt; <span class="number">0</span> || cardnum &gt;= SNDRV_CARDS))</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line"><span class="built_in">sprintf</span>(name, <span class="string">"controlC%i"</span>, cardnum);</span><br><span class="line"><span class="keyword">if</span> ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, <span class="number">-1</span>,</span><br><span class="line">       &amp;snd_ctl_f_ops, card, name)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实是调用 snd_register_device_for_dev ()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/sound.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_register_device_for_dev</span><span class="params">(<span class="keyword">int</span> type, struct snd_card *card, <span class="keyword">int</span> dev,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct file_operations *f_ops,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *private_data,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name, struct device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_minor</span> *<span class="title">preg</span>;</span></span><br><span class="line">preg = kmalloc(<span class="keyword">sizeof</span> *preg, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">preg-&gt;type = type;</span><br><span class="line">preg-&gt;card = card ? card-&gt;number : <span class="number">-1</span>;</span><br><span class="line">preg-&gt;device = dev;</span><br><span class="line">preg-&gt;f_ops = f_ops;</span><br><span class="line">preg-&gt;private_data = private_data;</span><br><span class="line">preg-&gt;card_ptr = card;</span><br><span class="line">mutex_lock(&amp;sound_mutex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_DYNAMIC_MINORS</span></span><br><span class="line">minor = snd_find_free_minor(type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">minor = snd_kernel_minor(type, card, dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">snd_minors[minor] = preg;</span><br><span class="line">preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor),</span><br><span class="line">  private_data, <span class="string">"%s"</span>, name);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;sound_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配并初始化一个 snd_minor 实例；<br>保存该 snd_minor 实例到 snd_minors 数组中；<br>调用 device_create() 生成设备文件节点。</p><p>上面过程是声卡注册时才被回调的。</p><h5 id="6-4-声卡的注册"><a href="#6-4-声卡的注册" class="headerlink" title="6.4. 声卡的注册"></a>6.4. 声卡的注册</h5><p>当声卡下的所有逻辑设备都已经准备就绪后，就可以调用 snd_card_register() 注册声卡了：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/26-Audio-system-snd-card-register.png.png" alt="Alt text"></p><p>• 创建声卡的 sysfs 设备；<br>• 调用 snd_device_register_all() 注册所有挂在该声卡下的逻辑设备；<br>• 建立 proc 信息文件和 sysfs 属性文件。</p><h4 id="（七）、DAPM分析"><a href="#（七）、DAPM分析" class="headerlink" title="（七）、DAPM分析"></a>（七）、DAPM分析</h4><h5 id="7-1、DAPM简介"><a href="#7-1、DAPM简介" class="headerlink" title="7.1、DAPM简介"></a>7.1、DAPM简介</h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><p>DAPM是基于kcontrol改进过后的相应框架，增加了相应的电源管理机制，其电源管理机制其实就是按照相应的音频路径，完美的对各种部件的电源进行控制，而且按照某种顺序进行。</p><h5 id="7-1、kcontrol"><a href="#7-1、kcontrol" class="headerlink" title="7.1、kcontrol"></a>7.1、kcontrol</h5><p>通常，一个kcontrol代表着一个mixer（混音器），或者是一个mux（多路开关），又或者是一个音量控制器等等。 从上述文章中我们知道，定义一个kcontrol主要就是定义一个snd_kcontrol_new 结构，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line"><span class="keyword">snd_ctl_elem_iface_t</span> iface;<span class="comment">/* interface identifier */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> device;<span class="comment">/* device/client number */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;<span class="comment">/* subdevice (substream) number */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;<span class="comment">/* ASCII name of item */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;<span class="comment">/* index of item */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> access;<span class="comment">/* access rights */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;<span class="comment">/* count of same elements */</span></span><br><span class="line"><span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line"><span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line"><span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">&#125; tlv;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每个控件，我们需要定义一个和他对应的snd_kcontrol_new结构，这些snd_kcontrol_new结构会在声卡的初始化阶段，通过snd_soc_dapm_new_controls()函数注册到系统中，用户空间就可以通过tinymix查看和设定这些控件的状态。<br>编译/external/tinyalsa/得到tinymix, tinyplay, tinycap，Push到手机执行tinymix可得到如下类似信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">990BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia10    Off</span><br><span class="line">991BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia11    Off</span><br><span class="line">992BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia12    Off</span><br><span class="line">993BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia13    Off</span><br><span class="line">994BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia14    Off</span><br><span class="line">995BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia15    Off</span><br><span class="line">996BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia16    Off</span><br><span class="line">997BOOL1MI2S_RX Audio Mixer MultiMedia1          Off</span><br><span class="line">998BOOL1MI2S_RX Audio Mixer MultiMedia2          Off</span><br><span class="line">999BOOL1MI2S_RX Audio Mixer MultiMedia3          Off</span><br><span class="line">1000BOOL1MI2S_RX Audio Mixer MultiMedia4          Off</span><br><span class="line">1001BOOL1MI2S_RX Audio Mixer MultiMedia5          Off</span><br><span class="line">1002BOOL1MI2S_RX Audio Mixer MultiMedia6          Off</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>snd_kcontrol_new结构中，几个主要的字段是get，put，private_value，get回调函数用于获取该控件当前的状态值，而put回调函数则用于设置控件的状态值，而private_value字段则根据不同的控件类型有不同的意义，比如对于普通的控件，private_value字段可以用来定义该控件所对应的寄存器的地址以及对应的控制位在寄存器中的位置信息。值得庆幸的是，ASoc系统已经为我们准备了大量的宏定义，用于定义常用的控件，这些宏定义位于include/sound/soc.h中。下面我们分别讨论一下如何用这些预设的宏定义来定义一些常用的控件。</p><h5 id="7-1-1、简单型的控件"><a href="#7-1-1、简单型的控件" class="headerlink" title="7.1.1、简单型的控件"></a>7.1.1、简单型的控件</h5><p>SOC_SINGLE    SOC_SINGLE应该算是最简单的控件了，这种控件只有一个控制量，比如一个开关，或者是一个数值变量（比如Codec中某个频率，FIFO大小等等）。我们看看这个宏是如何定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">.put = snd_soc_put_volsw, \</span><br><span class="line">.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure></p><p>宏定义的参数分别是：xname（该控件的名字），reg（该控件对应的寄存器的地址），shift（控制位在寄存器中的位移），max（控件可设置的最大值），invert（设定值是否逻辑取反）。这里又使用了一个宏来定义private_value字段：SOC_SINGLE_VALUE，我们看看它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \</span></span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;(struct soc_mixer_control) \</span><br><span class="line">&#123;.reg = xreg, .rreg = xreg, .shift = shift_left, \</span><br><span class="line">.rshift = shift_right, .max = xmax, .platform_max = xmax, \</span><br><span class="line">.invert = xinvert, .autodisable = xautodisable&#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \</span></span><br><span class="line">SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)</span><br></pre></td></tr></table></figure><p>这里实际上是定义了一个soc_mixer_control结构，然后把该结构的地址赋值给了private_value字段，soc_mixer_control结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* mixer control */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_mixer_control</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> min, max, platform_max;</span><br><span class="line"><span class="keyword">int</span> reg, rreg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shift, rshift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sign_bit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> invert:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> autodisable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看来soc_mixer_control是控件特征的真正描述者，它确定了该控件对应寄存器的地址，位移值，最大值和是否逻辑取反等特性，控件的put回调函数和get回调函数需要借助该结构来访问实际的寄存器。<br><strong>SOC_SINGLE_TLV</strong>    <strong>SOC_SINGLE_TLV</strong>是SOC_SINGLE的一种扩展，主要用于定义那些有增益控制的控件，例如音量控制器，EQ均衡器等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \</span></span><br><span class="line">&#123;.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span><br><span class="line"> SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span><br><span class="line">.tlv.p = (tlv_array), \</span><br><span class="line">.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">.put = snd_soc_put_volsw, \</span><br><span class="line">.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>从他的定义可以看出，用于设定寄存器信息的private_value字段的定义和SOC_SINGLE是一样的，甚至put、get回调函数也是使用同一套，唯一不同的是增加了一个tlv_array参数，并把它赋值给了tlv.p字段。用户空间可以通过对声卡的control设备发起以下两种ioctl来访问tlv字段所指向的数组：<br>  •  SNDRV_CTL_IOCTL_TLV_READ<br>  •  SNDRV_CTL_IOCTL_TLV_WRITE<br>  •  SNDRV_CTL_IOCTL_TLV_COMMAND</p><p>SOC_DOUBLE    与SOC_SINGLE相对应，区别是SOC_SINGLE只控制一个变量，而SOC_DOUBLE则可以同时在一个寄存器中控制两个相似的变量，最常用的就是用于一些立体声的控件，我们需要同时对左右声道进行控制，因为多了一个声道，参数也就相应地多了一个shift位移值</p><p>SOC_DOUBLE_R    与SOC_DOUBLE类似，对于左右声道的控制寄存器不一样的情况，使用SOC_DOUBLE_R来定义，参数中需要指定两个寄存器地址。<br>SOC_DOUBLE_TLV    与SOC_SINGLE_TLV对应的立体声版本，通常用于立体声音量控件的定义。</p><p>SOC_DOUBLE_R_TLV    左右声道有独立寄存器控制的SOC_DOUBLE_TLV版本</p><h5 id="7-1-2、Mixer控件"><a href="#7-1-2、Mixer控件" class="headerlink" title="7.1.2、Mixer控件"></a>7.1.2、Mixer控件</h5><p>Mixer控件用于音频通道的路由控制，由多个输入和一个输出组成，多个输入可以自由地混合在一起，形成混合后的输出：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/27-Audio-system-mixer-1525417497024.png" alt="Alt text"></p><p>对于Mixer控件，我们可以认为是多个简单控件的组合，通常，我们会为mixer的每个输入端都单独定义一个简单控件来控制该路输入的开启和关闭，反应在代码上，就是定义一个soc_kcontrol_new数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">aif4_vi_mixer</span>[] = &#123;</span></span><br><span class="line">SOC_SINGLE_EXT(<span class="string">"SPKR_VI_1"</span>, SND_SOC_NOPM, TASHA_TX14, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">SOC_SINGLE_EXT(<span class="string">"SPKR_VI_2"</span>, SND_SOC_NOPM, TASHA_TX15, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-1-3、Mux控件"><a href="#7-1-3、Mux控件" class="headerlink" title="7.1.3、Mux控件"></a>7.1.3、Mux控件</h5><p>mux控件与mixer控件类似，也是多个输入端和一个输出端的组合控件，与mixer控件不同的是，mux控件的多个输入端同时只能有一个被选中。因此，mux控件所对应的寄存器，通常可以设定一段连续的数值，每个不同的数值对应不同的输入端被打开，与上述的mixer控件不同，ASoc用soc_enum结构来描述mux控件的寄存器信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* enumerated kcontrol */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> reg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift_l;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift_r;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> items;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *texts;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个寄存器地址和位移字段：reg，reg2，shift_l，shift_r，用于描述左右声道的控制寄存器信息。字符串数组指针用于描述每个输入端对应的名字，value字段则指向一个数组，该数组定义了寄存器可以选择的值，每个值对应一个输入端，如果value是一组连续的值，通常我们可以忽略values参数。</p><h5 id="7-2、widget、path、route"><a href="#7-2、widget、path、route" class="headerlink" title="7.2、widget、path、route"></a>7.2、widget、path、route</h5><p>前面一节中，我们介绍了音频驱动中对基本控制单元的封装：kcontrol。利用kcontrol，我们可以完成对音频系统中的mixer，mux，音量控制，音效控制，以及各种开关量的控制，通过对各种kcontrol的控制，使得音频硬件能够按照我们预想的结果进行工作。同时我们可以看到，kcontrol还是有以下几点不足：<br>只能描述自身，无法描述各个kcontrol之间的连接关系；<br>没有相应的电源管理机制；<br>没有相应的时间处理机制来响应播放、停止、上电、下电等音频事件；<br>为了防止pop-pop声，需要用户程序关注各个kcontrol上电和下电的顺序；<br>当一个音频路径不再有效时，不能自动关闭该路径上的所有的kcontrol；<br>为此，DAPM框架正是为了要解决以上这些问题而诞生的，DAPM目前已经是ASoc中的重要组成部分，让我们先从DAPM的数据结构开始，了解它的设计思想和工作原理。</p><h5 id="7-2-1、DAPM的基本单元：widget"><a href="#7-2-1、DAPM的基本单元：widget" class="headerlink" title="7.2.1、DAPM的基本单元：widget"></a>7.2.1、DAPM的基本单元：widget</h5><p>文章的开头，我们说明了一下目前kcontrol的一些不足，而DAPM框架为了解决这些问题，引入了widget这一概念，所谓widget，其实可以理解为是kcontrol的进一步升级和封装，她同样是指音频系统中的某个部件，比如mixer，mux，输入输出引脚，电源供应器等等，甚至，我们可以定义虚拟的widget，例如playback stream widget。widget把kcontrol和动态电源管理进行了有机的结合，同时还具备音频路径的连结功能，一个widget可以与它相邻的widget有某种动态的连结关系。在DAPM框架中，widget用结构体snd_soc_dapm_widget来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> &#123;</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type id;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* widget name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sname;<span class="comment">/* stream name */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *priv;<span class="comment">/* widget specific data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span><span class="comment">/* attached regulator */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span> <span class="comment">/* params for dai links */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dapm control */</span></span><br><span class="line"><span class="keyword">int</span> reg;<span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift;<span class="comment">/* bits to shift */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;<span class="comment">/* non-shifted mask */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> on_val;<span class="comment">/* on state value */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> off_val;<span class="comment">/* off state value */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> power:<span class="number">1</span>;<span class="comment">/* block power status */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> active:<span class="number">1</span>;<span class="comment">/* active stream on DAC, ADC's */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> connected:<span class="number">1</span>;<span class="comment">/* connected codec pin */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">new</span>:<span class="number">1</span>;<span class="comment">/* cnew complete */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ext:<span class="number">1</span>;<span class="comment">/* has external widgets */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> force:<span class="number">1</span>;<span class="comment">/* force state */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> new_power:<span class="number">1</span>;<span class="comment">/* power from this run */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> power_checked:<span class="number">1</span>;<span class="comment">/* power checked this run */</span></span><br><span class="line"><span class="keyword">int</span> subseq;<span class="comment">/* sort within widget type */</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* widget input and outputs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sources</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sinks</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>snd_soc_dapm_widget结构比较大，为了简洁一些，这里我没有列出该结构体的完整字段，不过不用担心，下面我会说明每个字段的意义：<br>id    该widget的类型值，比如snd_soc_dapm_output，snd_soc_dapm_mixer等等。</p><p>*name    该widget的名字</p><p>*sname    代表该widget所在stream的名字，比如对于snd_soc_dapm_dai_in类型的widget，会使用该字段。</p><p><em>codec </em>platform    指向该widget所属的codec和platform。</p><p>list    所有注册到系统中的widget都会通过该list，链接到代表声卡的snd_soc_card结构的widgets链表头字段中。</p><p>*dapm    snd_soc_dapm_context结构指针，ASoc把系统划分为多个dapm域，每个widget属于某个dapm域，同一个域代表着同样的偏置电压供电策略，比如，同一个codec中的widget通常位于同一个dapm域，而平台上的widget可能又会位于另外一个platform域中。</p><p>*priv    有些widget可能需要一些专有的数据，可以使用该字段来保存，像snd_soc_dapm_dai_in类型的widget，会使用该字段来记住与之相关联的snd_soc_dai结构指针。</p><p>*regulator    对于snd_soc_dapm_regulator_supply类型的widget，该字段指向与之相关的regulator结构指针。</p><p>*params    目前对于snd_soc_dapm_dai_link类型的widget，指向该dai的配置信息的snd_soc_pcm_stream结构。</p><p>reg shift mask     这3个字段用来控制该widget的电源状态，分别对应控制信息所在的寄存器地址，位移值和屏蔽值。</p><p>value  on_val  off_val    电源状态的当前只，开启时和关闭时所对应的值。</p><p>power invert    用于指示该widget当前是否处于上电状态，invert则用于表明power字段是否需要逻辑反转。</p><p>active connected    分别表示该widget是否处于激活状态和连接状态，当和相邻的widget有连接关系时，connected位会被置1，否则置0。</p><p>new   我们定义好的widget（snd_soc_dapm_widget结构），在注册到声卡中时需要进行实例化，该字段用来表示该widget是否已经被实例化。</p><p>ext    表示该widget当前是否有外部连接，比如连接mic，耳机，喇叭等等。</p><p>force    该位被设置后，将会不管widget当前的状态，强制更新至新的电源状态。</p><p>ignore_suspend new_power power_checked    这些电源管理相关的字段。</p><p>subseq    该widget目前在上电或下电队列中的排序编号，为了防止在上下电的过程中出现pop-pop声，DAPM会给每个widget分配合理的上下电顺序。</p><p>*power_check    用于检查该widget是否应该上电或下电的回调函数指针。<br>event_flags    该字段是一个位或字段，每个位代表该widget会关注某个DAPM事件通知。只有被关注的通知事件会被发送到widget的事件处理回调函数中。</p><p>*event    DAPM事件处理回调函数指针。</p><p>num_kcontrols <em>kcontrol_news *</em>kcontrols    这3个字段用来描述与该widget所包含的kcontrol控件，例如一个mixer控件或者是一个mux控件。</p><p>sources sinks    两个链表字段，两个widget如果有连接关系，会通过一个snd_soc_dapm_path结构进行连接，sources链表用于链接所有的输入path，sinks链表用于链接所有的输出path。</p><p>power_list    每次更新整个dapm的电源状态时，会根据一定的算法扫描所有的widget，然后把需要变更电源状态的widget利用该字段链接到一个上电或下电的链表中，扫描完毕后，dapm系统会遍历这两个链表执行相应的上电或下电操作。</p><p>dirty    链表字段，widget的状态变更后，dapm系统会利用该字段，把该widget加入到一个dirty链表中，稍后会对dirty链表进行扫描，以执行整个路径的更新。</p><p>inputs    该widget的所有有效路径中，连接到输入端的路径数量。</p><p>outputs    该widget的所有有效路径中，连接到输出端的路径数量。</p><p>*clk    对于snd_soc_dapm_clock_supply类型的widget，指向相关联的clk结构指针。</p><p>以上我们对snd_soc_dapm_widget结构的各个字段所代表的意义一一做出了说明，这里只是让大家现有个概念</p><h5 id="7-2-2、widget的种类"><a href="#7-2-2、widget的种类" class="headerlink" title="7.2.2、widget的种类"></a>7.2.2、widget的种类</h5><p>在DAPM框架中，把各种不同的widget划分为不同的种类，snd_soc_dapm_widget结构中的id字段用来表示该widget的种类，可选的种类都定义在一个枚举中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget types */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type &#123;</span><br><span class="line">snd_soc_dapm_input = <span class="number">0</span>,<span class="comment">/* input pin */</span></span><br><span class="line">snd_soc_dapm_output,<span class="comment">/* output pin */</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>下面我们逐个解释一下这些widget的种类：<br>snd_soc_dapm_input     该widget对应一个输入引脚。<br>snd_soc_dapm_output    该widget对应一个输出引脚。<br>snd_soc_dapm_mux    该widget对应一个mux控件。<br>snd_soc_dapm_virt_mux    该widget对应一个虚拟的mux控件。<br>snd_soc_dapm_value_mux    该widget对应一个value类型的mux控件。<br>snd_soc_dapm_mixer    该widget对应一个mixer控件。<br>snd_soc_dapm_mixer_named_ctl    该widget对应一个mixer控件，但是对应的kcontrol的名字不会加入widget的名字作为前缀。<br>snd_soc_dapm_pga    该widget对应一个pga控件（可编程增益控件）。<br>snd_soc_dapm_out_drv    该widget对应一个输出驱动控件<br>snd_soc_dapm_adc    该widget对应一个ADC<br>snd_soc_dapm_dac    该widget对应一个DAC<br>snd_soc_dapm_micbias    该widget对应一个麦克风偏置电压控件<br>snd_soc_dapm_mic    该widget对应一个麦克风。<br>snd_soc_dapm_hp    该widget对应一个耳机。<br>snd_soc_dapm_spk    该widget对应一个扬声器。<br>snd_soc_dapm_line     该widget对应一个线路输入。<br>snd_soc_dapm_switch       该widget对应一个模拟开关。<br>snd_soc_dapm_vmid      该widget对应一个codec的vmid偏置电压。<br>snd_soc_dapm_pre      machine级别的专用widget，会先于其它widget执行检查操作。<br>snd_soc_dapm_post    machine级别的专用widget，会后于其它widget执行检查操作。<br>snd_soc_dapm_supply           对应一个电源或是时钟源。<br>snd_soc_dapm_regulator_supply  对应一个外部regulator稳压器。<br>snd_soc_dapm_clock_supply      对应一个外部时钟源。<br>snd_soc_dapm_aif_in            对应一个数字音频输入接口，比如I2S接口的输入端。<br>snd_soc_dapm_aif_out          对应一个数字音频输出接口，比如I2S接口的输出端。<br>snd_soc_dapm_siggen            对应一个信号发生器。<br>snd_soc_dapm_dai_in           对应一个platform或codec域的输入DAI结构。<br>snd_soc_dapm_dai_out        对应一个platform或codec域的输出DAI结构。<br>snd_soc_dapm_dai_link         用于链接一对输入/输出DAI结构。</p><h5 id="7-2-3、widget之间的连接器：path"><a href="#7-2-3、widget之间的连接器：path" class="headerlink" title="7.2.3、widget之间的连接器：path"></a>7.2.3、widget之间的连接器：path</h5><p>之前已经提到，一个widget是有输入和输出的，而且widget之间是可以动态地进行连接的，那它们是用什么来连接两个widget的呢？DAPM为我们提出了path这一概念，path相当于电路中的一根跳线，它把一个widget的输出端和另一个widget的输入端连接在一起，path用snd_soc_dapm_path结构来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm audio path between two widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* source (input) and sink (output) widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">source</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">sink</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* status */</span></span><br><span class="line">u32 connect:<span class="number">1</span>;<span class="comment">/* source and sink widgets are connected */</span></span><br><span class="line">u32 walked:<span class="number">1</span>;<span class="comment">/* path has been walked */</span></span><br><span class="line">u32 walking:<span class="number">1</span>;  <span class="comment">/* path is in the process of being walked */</span></span><br><span class="line">u32 weak:<span class="number">1</span>;<span class="comment">/* path ignored for power management */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line"> struct snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_source</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_sink</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_kcontrol</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当widget之间发生连接关系时，snd_soc_dapm_path作为连接者，它的source字段会指向该连接的起始端widget，而它的sink字段会指向该连接的到达端widget，还记得前面snd_soc_dapm_widget结构中的两个链表头字段：sources和sinks么？widget的输入端和输出端可能连接着多个path，所有输入端的snd_soc_dapm_path结构通过list_sink字段挂在widget的souces链表中，同样，所有输出端的snd_soc_dapm_path结构通过list_source字段挂在widget的sinks链表中。这里可能大家会被搞得晕呼呼的，一会source，一会sink，不要紧，只要记住，连接的路径是这样的：起始端widget的输出–&gt;path的输入–&gt;path的输出–&gt;到达端widget输入。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/28-Audio-system-snd_soc_dapm_path.png" alt="Alt text"><br>另外，snd_soc_dapm_path结构的list字段用于把所有的path注册到声卡中，其实就是挂在snd_soc_card结构的paths链表头字段中。如果你要自己定义方法来检查path的当前连接状态，你可以提供自己的connected回调函数指针。</p><p>connect，walked，walking，weak是几个辅助字段，用于帮助所有path的遍历。</p><h5 id="7-2-4、widget的连接关系：route"><a href="#7-2-4、widget的连接关系：route" class="headerlink" title="7.2.4、widget的连接关系：route"></a>7.2.4、widget的连接关系：route</h5><p>通过上一节的内容，我们知道，一个路径的连接至少包含以下几个元素：起始端widget，跳线path，到达端widget，在DAPM中，用snd_soc_dapm_route结构来描述这样一个连接关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sink;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *control;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: currently only supported for links where source is a supply */</span></span><br><span class="line"><span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line"> struct snd_soc_dapm_widget *sink);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sink指向到达端widget的名字字符串，source指向起始端widget的名字字符串，control指向负责控制该连接所对应的kcontrol名字字符串，connected回调则定义了上一节所提到的自定义连接检查回调函数。该结构的意义很明显就是：source通过一个kcontrol，和sink连接在一起，现在是否处于连接状态，请调用connected回调函数检查。<br>这里直接使用名字字符串来描述连接关系，所有定义好的route，最后都要注册到dapm系统中，dapm会根据这些名字找出相应的widget，并动态地生成所需要的snd_soc_dapm_path结构，正确地处理各个链表和指针的关系，实现两个widget之间的连接</p><h5 id="7-3、建立widget之间的连接关系"><a href="#7-3、建立widget之间的连接关系" class="headerlink" title="7.3、建立widget之间的连接关系"></a>7.3、建立widget之间的连接关系</h5><p>前面我们主要着重于codec、platform、machine驱动程序中如何使用和建立dapm所需要的widget，route，这些是音频驱动开发人员必须要了解的内容，经过前几章的介绍，我们应该知道如何在alsa音频驱动的3大部分（codec、platform、machine）中，按照所使用的音频硬件结构，定义出相应的widget，kcontrol，以及必要的音频路径，而在本节中，我们将会深入dapm的核心部分，看看各个widget之间是如何建立连接关系，形成一条完整的音频路径。</p><p>前面我们已经简单地介绍过，驱动程序需要使用以下api函数创建widget：</p><p>• snd_soc_dapm_new_controls()<br>实际上，这个函数只是创建widget的第一步，它为每个widget分配内存，初始化必要的字段，然后把这些widget挂在代表声卡的snd_soc_card的widgets链表字段中。要使widget之间具备连接能力，我们还需要第二个函数：<br>• snd_soc_dapm_new_widgets()<br>这个函数会根据widget的信息，创建widget所需要的dapm kcontrol，这些dapm kcontol的状态变化，代表着音频路径的变化，从而影响着各个widget的电源状态。看到函数的名称可能会迷惑一下，实际上，snd_soc_dapm_new_controls的作用更多地是创建widget，而snd_soc_dapm_new_widget的作用则更多地是创建widget所包含的kcontrol，所以在我看来，这两个函数名称应该换过来叫更好！下面我们分别介绍一下这两个函数是如何工作的。</p><h5 id="7-3-1、创建widget"><a href="#7-3-1、创建widget" class="headerlink" title="7.3.1、创建widget"></a>7.3.1、创建widget</h5><p>snd_soc_dapm_new_controls()函数完成widget的创建工作，并把这些创建好的widget注册在声卡的widgets链表中，我们看看他的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_controls</span><span class="params">(struct snd_soc_dapm_context *dapm,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct snd_soc_dapm_widget *widget,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">w = snd_soc_dapm_new_control(dapm, widget);</span><br><span class="line"><span class="keyword">if</span> (!w) &#123;</span><br><span class="line">dev_err(dapm-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: Failed to create DAPM control %s\n"</span>,</span><br><span class="line">widget-&gt;name);</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">widget++;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是简单的一个循环，为传入的widget模板数组依次调用snd_soc_dapm_new_control函数，实际的工作由snd_soc_dapm_new_control完成，继续进入该函数，看看它做了那些工作。<br>我们之前已经说过，驱动中定义的snd_soc_dapm_widget数组，只是作为一个模板，所以，snd_soc_dapm_new_control所做的第一件事，就是为该widget重新分配内存，并把模板的内容拷贝过来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *</span></span><br><span class="line"><span class="class"><span class="title">snd_soc_dapm_new_control</span>(<span class="title">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>,</span></span><br><span class="line"><span class="class"> <span class="title">const</span> <span class="title">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">widget</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *prefix;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((w = dapm_cnew_widget(widget)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//由dapm_cnew_widget完成内存申请和拷贝模板的动作。接下来，根据widget的类型做不同的处理：</span></span><br><span class="line"><span class="keyword">switch</span> (w-&gt;id) &#123;</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">prefix = soc_dapm_prefix(dapm);</span><br><span class="line"><span class="comment">//对于snd_soc_dapm_regulator_supply类型的widget，根据widget的名称获取对应的regulator结构，对于snd_soc_dapm_clock_supply类型的widget，根据widget的名称，获取对应的clock结构。接下来，根据需要，在widget的名称前加入必要的前缀：</span></span><br><span class="line"><span class="keyword">if</span> (prefix) &#123;</span><br><span class="line">w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">"%s %s"</span>, prefix, widget-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">"%s %s"</span>, prefix,</span><br><span class="line">     widget-&gt;sname);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">"%s"</span>, widget-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">"%s"</span>, widget-&gt;sname);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/29-Audio-system-widget-1525420992983.png" alt="Alt text"><br>当音频路径发生变化时，power_check回调会被调用，用于检查该widget的电源状态是否需要更新。power_check设置完成后，需要设置widget所属的codec、platform和dapm context，几个用于音频路径的链表也需要初始化，然后，把该widget加入到声卡的widgets链表中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line">w-&gt;dapm = dapm;  </span><br><span class="line">w-&gt;codec = dapm-&gt;codec;  </span><br><span class="line">w-&gt;platform = dapm-&gt;platform;  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sources);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sinks);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;<span class="built_in">list</span>);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;dirty);  </span><br><span class="line">list_add(&amp;w-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;widgets);</span><br></pre></td></tr></table></figure><p>几个链表的作用如下：<br>sources    用于链接所有连接到该widget输入端的snd_soc_path结构<br>sinks    用于链接所有连接到该widget输出端的snd_soc_path结构<br>list    用于链接到声卡的widgets链表<br>dirty    用于链接到声卡的dapm_dirty链表<br>最后，把widget设置为connect状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line"><span class="comment">/* machine layer set ups unconnected pins and insertions */</span>  </span><br><span class="line">w-&gt;connected = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">return</span> w;</span><br></pre></td></tr></table></figure><p>connected字段代表着引脚的连接状态，目前，只有以下这些widget使用connected字段：<br>snd_soc_dapm_output<br>snd_soc_dapm_input<br>snd_soc_dapm_hp<br>snd_soc_dapm_spk<br>snd_soc_dapm_line<br>snd_soc_dapm_vmid<br>snd_soc_dapm_mic<br>snd_soc_dapm_siggen<br>驱动程序可以使用以下这些api来设置引脚的连接状态：<br>snd_soc_dapm_enable_pin<br>snd_soc_dapm_force_enable_pin<br>snd_soc_dapm_disable_pin<br>snd_soc_dapm_nc_pin<br>到此，widget已经被正确地创建并初始化，而且被挂在声卡的widgets链表中，以后我们就可以通过声卡的widgets链表来遍历所有的widget，再次强调一下snd_soc_dapm_new_controls函数所完成的主要功能：<br>为widget分配内存，并拷贝参数中传入的在驱动中定义好的模板<br>设置power_check回调函数<br>把widget挂在声卡的widgets链表中</p><h5 id="7-3-2、为widget建立dapm-kcontrol"><a href="#7-3-2、为widget建立dapm-kcontrol" class="headerlink" title="7.3.2、为widget建立dapm kcontrol"></a>7.3.2、为widget建立dapm kcontrol</h5><p>定义一个widget，我们需要指定两个很重要的内容：一个是用于控制widget的电源状态的reg/shift等寄存器信息，另一个是用于控制音频路径切换的dapm kcontrol信息，这些dapm kcontrol有它们自己的reg/shift寄存器信息用于切换widget的路径连接方式。前一节的内容中，我们只是创建了widget的实例，并把它们注册到声卡的widgts链表中，但是到目前为止，包含在widget中的dapm kcontrol并没有建立起来，dapm框架在声卡的初始化阶段，等所有的widget（包括machine、platform、codec）都创建好之后，通过snd_soc_dapm_new_widgets函数，创建widget内包含的dapm kcontrol，并初始化widget的初始电源状态和音频路径的初始连接状态。我们看看声卡的初始化函数，都有那些初始化与dapm有关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_instantiate_card</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="comment">/* card bind complete so register a sound card */</span>  </span><br><span class="line">        ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,  </span><br><span class="line">                        card-&gt;owner, <span class="number">0</span>, &amp;card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">   </span><br><span class="line">        card-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;  </span><br><span class="line">        card-&gt;dapm.dev = card-&gt;dev;  </span><br><span class="line">        card-&gt;dapm.card = card;  </span><br><span class="line">        list_add(&amp;card-&gt;dapm.<span class="built_in">list</span>, &amp;card-&gt;dapm_list);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_widgets)    <span class="comment">/* 创建machine级别的widget  */</span>  </span><br><span class="line">                snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets,  </span><br><span class="line">                                          card-&gt;num_dapm_widgets);  </span><br><span class="line">        ......  </span><br><span class="line">        snd_soc_dapm_link_dai_widgets(card);  <span class="comment">/*  连接dai widget  */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;controls)    <span class="comment">/*  建立machine级别的普通kcontrol控件  */</span>  </span><br><span class="line">                snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_routes)    <span class="comment">/*  注册machine级别的路径连接信息  */</span>  </span><br><span class="line">                snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes,  </span><br><span class="line">                                        card-&gt;num_dapm_routes);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;fully_routed)    <span class="comment">/*  如果该标志被置位，自动把codec中没有路径连接信息的引脚设置为无用widget  */</span>  </span><br><span class="line">                list_for_each_entry(codec, &amp;card-&gt;codec_dev_list, card_list)  </span><br><span class="line">                        snd_soc_dapm_auto_nc_codec_pins(codec);  </span><br><span class="line">  </span><br><span class="line">        snd_soc_dapm_new_widgets(card);    <span class="comment">/*初始化widget包含的dapm kcontrol、电源状态和连接状态*/</span>  </span><br><span class="line">  </span><br><span class="line">        ret = snd_card_register(card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">        card-&gt;instantiated = <span class="number">1</span>;  </span><br><span class="line">        snd_soc_dapm_sync(&amp;card-&gt;dapm);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我添加的注释中所示，在完成machine级别的widget和route处理之后，调用的snd_soc_dapm_new_widgets函数，来为所有已经注册的widget初始化他们所包含的dapm kcontrol，并初始化widget的电源状态和路径连接状态。下面我们看看snd_soc_dapm_new_widgets函数的工作过程。</p><h5 id="7-3-2-1、snd-soc-dapm-new-widgets函数"><a href="#7-3-2-1、snd-soc-dapm-new-widgets函数" class="headerlink" title="7.3.2.1、snd_soc_dapm_new_widgets函数"></a>7.3.2.1、snd_soc_dapm_new_widgets函数</h5><p>该函数通过声卡的widgets链表，遍历所有已经注册了的widget，其中的new字段用于判断该widget是否已经执行过snd_soc_dapm_new_widgets函数，如果num_kcontrols字段有数值，表明该widget包含有若干个dapm kcontrol，那么就需要为这些kcontrol分配一个指针数组，并把数组的首地址赋值给widget的kcontrols字段，该数组存放着指向这些kcontrol的指针，当然现在这些都是空指针，因为实际的kcontrol现在还没有被创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_widgets</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;card-&gt;widgets, <span class="built_in">list</span>)  </span><br><span class="line">        &#123;                 </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;<span class="keyword">new</span>) <span class="keyword">continue</span>;  </span><br><span class="line">                                  </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;num_kcontrols) &#123;  </span><br><span class="line">                        w-&gt;kcontrols = kzalloc(w-&gt;num_kcontrols *  </span><br><span class="line">                                                <span class="keyword">sizeof</span>(struct snd_kcontrol *),  </span><br><span class="line">                                                GFP_KERNEL);  </span><br><span class="line">                        ......  </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>接着，对几种能影响音频路径的widget，创建并初始化它们所包含的dapm kcontrol：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="keyword">switch</span>(w-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        dapm_new_mixer(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        dapm_new_mux(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line">        dapm_new_pga(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到的创建函数分别是：<br>dapm_new_mixer()    对于mixer类型，用该函数创建dapm kcontrol；<br>dapm_new_mux()   对于mux类型，用该函数创建dapm kcontrol；<br>dapm_new_pga()   对于pga类型，用该函数创建dapm kcontrol；<br>然后，根据widget寄存器的当前值，初始化widget的电源状态，并设置到power字段中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="comment">/* Read the initial power state from the device */</span>  </span><br><span class="line"><span class="keyword">if</span> (w-&gt;reg &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        val = soc_widget_read(w, w-&gt;reg) &gt;&gt; w-&gt;shift;  </span><br><span class="line">        val &amp;= w-&gt;mask;  </span><br><span class="line">        <span class="keyword">if</span> (val == w-&gt;on_val)  </span><br><span class="line">                w-&gt;power = <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，设置new字段，表明该widget已经初始化完成，我们还要吧该widget加入到声卡的dapm_dirty链表中，表明该widget的状态发生了变化，稍后在合适的时刻，dapm框架会扫描dapm_dirty链表，统一处理所有已经变化的widget。为什么要统一处理？因为dapm要控制各种widget的上下电顺序，同时也是为了减少寄存器的读写次数（多个widget可能使用同一个寄存器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">w-&gt;<span class="keyword">new</span> = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">dapm_mark_dirty(w, <span class="string">"new widget"</span>);  </span><br><span class="line">dapm_debugfs_add_widget(w);</span><br></pre></td></tr></table></figure><p>最后，通过dapm_power_widgets函数，统一处理所有位于dapm_dirty链表上的widget的状态改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);  </span><br><span class="line">......  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="7-3-2-2、dapm-mixer-kcontrol"><a href="#7-3-2-2、dapm-mixer-kcontrol" class="headerlink" title="7.3.2.2、dapm mixer kcontrol"></a>7.3.2.2、dapm mixer kcontrol</h5><p>上一节中，我们提到，对于mixer类型的dapm kcontrol，我们会使用dapm_new_mixer来完成具体的创建工作，先看代码后分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mixer</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, ret;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* add kcontrol */</span>  </span><br><span class="line">（<span class="number">1</span>）        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w-&gt;num_kcontrols; i++) &#123;                                  </span><br><span class="line">                <span class="comment">/* match name */</span>  </span><br><span class="line">（<span class="number">2</span>）                list_for_each_entry(path, &amp;w-&gt;sources, list_sink) &#123;               </span><br><span class="line">                        <span class="comment">/* mixer/mux paths name must match control name */</span>  </span><br><span class="line">（<span class="number">3</span>）                        <span class="keyword">if</span> (path-&gt;name != (<span class="keyword">char</span> *)w-&gt;kcontrol_news[i].name)       </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">4</span>）                        <span class="keyword">if</span> (w-&gt;kcontrols[i]) &#123;                                   </span><br><span class="line">                                dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);  </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">5</span>）                        ret = dapm_create_or_share_mixmux_kcontrol(w, i);        </span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                                <span class="keyword">return</span> ret;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">6</span>）                        dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);           </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  因为一个mixer是由多个kcontrol组成的，每个kcontrol控制着mixer的一个输入端的开启和关闭，所以，该函数会根据kcontrol的数量做循环，逐个建立对应的kcontrol。<br>（2）（3）  之前多次提到，widget之间使用snd_soc_path进行连接，widget的sources链表保存着所有和输入端连接的snd_soc_path结构，所以我们可以用kcontrol模板中指定的名字来匹配对应的snd_soc_path结构。<br>（4）  因为一个输入脚可能会连接多个输入源，所以可能在上一个输入源的path关联时已经创建了这个kcontrol，所以这里判断kcontrols指针数组中对应索引中的指针值，如果已经赋值，说明kcontrol已经在之前创建好了，所以我们只要简单地把连接该输入端的path加入到kcontrol的path_list链表中，并且增加一个虚拟的影子widget，该影子widget连接和输入端对应的源widget，因为使用了kcontrol本身的reg/shift等寄存器信息，所以实际上控制的是该kcontrol的开和关，这个影子widget只有在kcontrol的autodisable字段被设置的情况下才会被创建，该特性使得source的关闭时，与之连接的mixer的输入端也可以自动关闭，这个特性通过dapm_kcontrol_add_path来实现这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dapm_kcontrol_add_path</span><span class="params">(<span class="keyword">const</span> struct snd_kcontrol *kcontrol,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dapm_kcontrol_data</span> *<span class="title">data</span> = <span class="title">snd_kcontrol_chip</span>(<span class="title">kcontrol</span>);</span>  </span><br><span class="line">        <span class="comment">/*  把kcontrol连接的path加入到paths链表中  */</span>  </span><br><span class="line">        <span class="comment">/*  paths链表所在的dapm_kcontrol_data结构会保存在kcontrol的private_data字段中  */</span>  </span><br><span class="line">        list_add_tail(&amp;path-&gt;list_kcontrol, &amp;data-&gt;paths);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (data-&gt;widget) &#123;  </span><br><span class="line">                snd_soc_dapm_add_path(data-&gt;widget-&gt;dapm, data-&gt;widget,  </span><br><span class="line">                    path-&gt;source, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）  如果kcontrol之前没有被创建，则通过dapm_create_or_share_mixmux_kcontrol创建这个输入端的kcontrol，同理，kcontrol对应的影子widget也会通过dapm_kcontrol_add_path判断是否需要创建。</p><h5 id="7-3-2-3、dapm-mux-kcontrol"><a href="#7-3-2-3、dapm-mux-kcontrol" class="headerlink" title="7.3.2.3、dapm mux kcontrol"></a>7.3.2.3、dapm mux kcontrol</h5><p>因为一个widget最多只会包含一个mux类型的damp kcontrol，所以他的创建方法稍有不同，dapm框架使用dapm_new_mux函数来创建mux类型的dapm kcontrol：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mux</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span> = <span class="title">w</span>-&gt;<span class="title">dapm</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">          </span><br><span class="line">(<span class="number">1</span>)     <span class="keyword">if</span> (w-&gt;num_kcontrols != <span class="number">1</span>) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev,  </span><br><span class="line">                        <span class="string">"ASoC: mux %s has incorrect number of controls\n"</span>,  </span><br><span class="line">                        w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;w-&gt;sources)) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev, <span class="string">"ASoC: mux %s has no paths\n"</span>, w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">(<span class="number">2</span>)     ret = dapm_create_or_share_mixmux_kcontrol(w, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">return</span> ret;  </span><br><span class="line">(<span class="number">3</span>)       list_for_each_entry(path, &amp;w-&gt;sources, list_sink)  </span><br><span class="line">                dapm_kcontrol_add_path(w-&gt;kcontrols[<span class="number">0</span>], path);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  对于mux类型的widget，因为只会有一个kcontrol，所以在这里做一下判断。<br>（2）  同样地，和mixer类型一样，也使用dapm_create_or_share_mixmux_kcontrol来创建这个kcontrol。<br>（3）  对每个输入端所连接的path都加入dapm_kcontrol_data结构的paths链表中，并且创建一个影子widget，用于支持autodisable特性。</p><h5 id="7-3-2-4、dapm-pga-kcontrol"><a href="#7-3-2-4、dapm-pga-kcontrol" class="headerlink" title="7.3.2.4、dapm pga kcontrol"></a>7.3.2.4、dapm pga kcontrol</h5><p>目前对于pga类型的widget，kcontrol的创建函数是个空函数，所以我们不用太关注它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_pga</span><span class="params">(struct snd_soc_dapm_widget *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (w-&gt;num_kcontrols)</span><br><span class="line">dev_err(w-&gt;dapm-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: PGA controls not supported: '%s'\n"</span>, w-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dapm_create_or_share_mixmux_kcontrol函数<br>上面所说的mixer类型和mux类型的widget，在创建他们所包含的dapm kcontrol时，最后其实都是使用了dapm_create_or_share_mixmux_kcontrol函数来完成创建工作的，所以在这里我们有必要分析一下这个函数的工作原理。这个函数中有很大一部分代码实在处理kcontrol的名字是否要加入codec的前缀，我们会忽略这部分的代码，感兴趣的读者可以自己查看内核的代码，路径在：sound/soc/soc-dapm.c中，简化后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_create_or_share_mixmux_kcontrol</span><span class="params">(struct snd_soc_dapm_widget *w,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> kci)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">          ......  </span><br><span class="line">(<span class="number">1</span>)       shared = dapm_is_shared_kcontrol(dapm, w, &amp;w-&gt;kcontrol_news[kci],  </span><br><span class="line">                                         &amp;kcontrol);  </span><br><span class="line">     </span><br><span class="line">(<span class="number">2</span>)       <span class="keyword">if</span> (!kcontrol) &#123;  </span><br><span class="line">(<span class="number">3</span>)            kcontrol = snd_soc_cnew(&amp;w-&gt;kcontrol_news[kci], <span class="literal">NULL</span>, name,prefix）;  </span><br><span class="line">               ......  </span><br><span class="line">               kcontrol-&gt;private_free = dapm_kcontrol_free;  </span><br><span class="line">(<span class="number">4</span>)            ret = dapm_kcontrol_data_alloc(w, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">(<span class="number">5</span>)            ret = snd_ctl_add(card, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">        &#125;  </span><br><span class="line">(<span class="number">6</span>)     ret = dapm_kcontrol_add_widget(kcontrol, w);  </span><br><span class="line">        ......  </span><br><span class="line">(<span class="number">7</span>)     w-&gt;kcontrols[kci] = kcontrol;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  为了节省内存，通过kcontrol名字的匹配查找，如果这个kcontrol已经在其他widget中已经创建好了，那我们不再创建，dapm_is_shared_kcontrol的参数kcontrol会返回已经创建好的kcontrol的指针。<br>（2）  如果kcontrol指针被赋值，说明在（1）中查找到了其他widget中同名的kcontrol，我们不用再次创建，只要共享该kcontrol即可。<br>（3）  标准的kcontrol创建函数，<br>（4）  如果widget支持autodisable特性，创建与该kcontrol所对应的影子widget，该影子widget的类型是：snd_soc_dapm_kcontrol。<br>（5）  标准的kcontrol创建函数，<br>（6）  把所有共享该kcontrol的影子widget（snd_soc_dapm_kcontrol），加入到kcontrol的private_data字段所指向的dapm_kcontrol_data结构中。<br>（7）  把创建好的kcontrol指针赋值到widget的kcontrols数组中。<br>需要注意的是，如果kcontol支持autodisable特性，一旦kcontrol由于source的关闭而被自动关闭，则用户空间只能操作该kcontrol的cache值，只有该kcontrol再次打开时，该cache值才会被真正地更新到寄存器中。<br>现在。我们总结一下，创建一个widget所包含的kcontrol所做的工作：<br>• 循环每一个输入端，为每个输入端依次执行下面的一系列操作<br>• 为每个输入端创建一个kcontrol，能共享的则直接使用创建好的kcontrol<br>• kcontrol的private_data字段保存着这些共享widget的信息<br>• 如果支持autodisable特性，每个输入端还要额外地创建一个虚拟的snd_soc_dapm_kcontrol类型的影子widget，该影子widget也记录在private_data字段中<br>• 创建好的kcontrol会依次存放在widget的kcontrols数组中，供路径的控制和匹配之用。</p><h5 id="7-3-2-5、为widget建立连接关系"><a href="#7-3-2-5、为widget建立连接关系" class="headerlink" title="7.3.2.5、为widget建立连接关系"></a>7.3.2.5、为widget建立连接关系</h5><p>如果widget之间没有连接关系，dapm就无法实现动态的电源管理工作，正是widget之间有了连结关系，这些连接关系形成了一条所谓的完成的音频路径，dapm可以顺着这条路径，统一控制路径上所有widget的电源状态，前面我们已经知道，widget之间是使用snd_soc_path结构进行连接的，驱动要做的是定义一个snd_soc_route结构数组，该数组的每个条目描述了目的widget的和源widget的名称，以及控制这个连接的kcontrol的名称，最终，驱动程序使用api函数snd_soc_dapm_add_routes来注册这些连接信息，接下来我们就是要分析该函数的具体实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_add_routes</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct snd_soc_dapm_route *route, <span class="keyword">int</span> num)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, r, ret = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;  </span><br><span class="line">                r = snd_soc_dapm_add_route(dapm, route);  </span><br><span class="line">                ......  </span><br><span class="line">                route++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是一个循环，依次对参数传入的数组调用snd_soc_dapm_add_route，主要的工作由snd_soc_dapm_add_route完成。我们进入snd_soc_dapm_add_route函数看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_route</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> struct snd_soc_dapm_route *route)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wsource</span> = <span class="title">NULL</span>, *<span class="title">wsink</span> = <span class="title">NULL</span>, *<span class="title">w</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wtsource</span> = <span class="title">NULL</span>, *<span class="title">wtsink</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *sink;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *source;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;dapm-&gt;card-&gt;widgets, <span class="built_in">list</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!wsink &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, sink))) &#123;  </span><br><span class="line">                        wtsink = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsink = w;  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!wsource &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, source))) &#123;  </span><br><span class="line">                        wtsource = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsource = w;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的代码我再次省略了关于名称前缀的处理部分。我们可以看到，用widget的名字来比较，遍历声卡的widgets链表，找出源widget和目的widget的指针，这段代码虽然正确，但我总感觉少了一个判断退出循环的条件，如果链表的开头就找到了两个widget，还是要遍历整个链表才结束循环，好浪费时间。<br>下面，如果在本dapm context中没有找到，则使用别的dapm context中找到的widget：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line"><span class="keyword">if</span> (!wsink)  </span><br><span class="line">        wsink = wtsink;  </span><br><span class="line"><span class="keyword">if</span> (!wsource)  </span><br><span class="line">        wsource = wtsource;</span><br></pre></td></tr></table></figure><p>最后，使用来增加一条连接信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line">        ret = snd_soc_dapm_add_path(dapm, wsource, wsink, route-&gt;control,  </span><br><span class="line">                route-&gt;connected);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snd_soc_dapm_add_path函数是整个调用链条中的关键，我们来分析一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_path</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *control,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> (*connected)</span><span class="params">(struct snd_soc_dapm_widget *source,  </span></span></span><br><span class="line">                         struct snd_soc_dapm_widget *sink))  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">  </span><br><span class="line">        path = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dapm_path), GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!path)  </span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;  </span><br><span class="line">  </span><br><span class="line">        path-&gt;source = wsource;  </span><br><span class="line">        path-&gt;sink = wsink;  </span><br><span class="line">        path-&gt;connected = connected;  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;<span class="built_in">list</span>);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_kcontrol);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_source);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_sink);</span><br></pre></td></tr></table></figure><p>函数的一开始，首先为这个连接分配了一个snd_soc_path结构，path的source和sink字段分别指向源widget和目的widget，connected字段保存connected回调函数，初始化几个snd_soc_path结构中的几个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* check for external widgets */</span>  </span><br><span class="line">        <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_input) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_micbias ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_mic ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_output)  </span><br><span class="line">                        wsink-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_output) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_spk ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_hp ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_input)  </span><br><span class="line">                        wsource-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这段代码用于判断是否有外部连接关系，如果有，置位widget的ext字段。判断方法从代码中可以方便地看出：<br>目的widget是一个输入脚，如果源widget是mic、line、micbias或output，则认为目的widget具有外部连接关系。<br>源widget是一个输出脚，如果目的widget是spk、hp、line或input，则认为源widget具有外部连接关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">dapm_mark_dirty(wsource, <span class="string">"Route added"</span>);  </span><br><span class="line">dapm_mark_dirty(wsink, <span class="string">"Route added"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* connect static paths */</span>  </span><br><span class="line"><span class="keyword">if</span> (control == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为增加了连结关系，所以把源widget和目的widget加入到dapm_dirty链表中。如果没有kcontrol来控制该连接关系，则这是一个静态连接，直接用path把它们连接在一起。在接着往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* connect dynamic paths */</span>  </span><br><span class="line"><span class="keyword">switch</span> (wsink-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_adc:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dac:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_input:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_output:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_siggen:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_micbias:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_vmid:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pre:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_post:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_clock_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_link:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_kcontrol:  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>按照目的widget来判断，如果属于以上这些类型，直接把它们连接在一起即可，这段感觉有点多余，因为通常以上这些类型的widget本来也没有kcontrol，直接用上一段代码就可以了，也许是dapm的作者们想着以后可能会有所扩展吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        ret = dapm_connect_mux(dapm, wsource, wsink, path, control,  </span><br><span class="line">                &amp;wsink-&gt;kcontrol_news[<span class="number">0</span>]);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        ret = dapm_connect_mixer(dapm, wsource, wsink, path, control);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>目的widget如果是mixer和mux类型，分别用dapm_connect_mixer和dapm_connect_mux函数完成连接工作，这两个函数我们后面再讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_hp:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_mic:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_line:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_spk:  </span><br><span class="line">                list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">                list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">                path-&gt;connect = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">err:  </span><br><span class="line">        kfree(path);  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hp、mic、line和spk这几种widget属于外部器件，也只是简单地连接在一起，不过connect字段默认为是未连接状态。<br>现在，我们回过头来看看目的widget是mixer和mux这两种类型时的连接方式：<br>dapm_connect_mixer  用该函数连接一个目的widget为mixer类型的所有输入端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mixer</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* search for mixer kcontrol */</span>  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dest-&gt;num_kcontrols; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(control_name, dest-&gt;kcontrol_news[i].name)) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = dest-&gt;kcontrol_news[i].name;  </span><br><span class="line">                        dapm_set_path_status(dest, path, i);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用需要用来连接的kcontrol的名字，和目的widget中的kcontrol模板数组中的名字相比较，找出该kcontrol在widget中的编号，path的名字设置为该kcontrol的名字，然后用dapm_set_path_status函数来初始化该输入端的连接状态。连接两个widget的链表操作和其他widget是一样的。</p><p>dapm_connect_mux 用该函数连接一个目的widget是mux类型的所有输入端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mux</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct snd_kcontrol_new *kcontrol)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> *<span class="title">e</span> = (<span class="title">struct</span> <span class="title">soc_enum</span> *)<span class="title">kcontrol</span>-&gt;<span class="title">private_value</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;max; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">strcmp</span>(control_name, e-&gt;texts[i]))) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = (<span class="keyword">char</span>*)e-&gt;texts[i];  </span><br><span class="line">                        dapm_set_path_status(dest, path, <span class="number">0</span>);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和mixer类型一样用名字进行匹配，只不过mux类型的kcontrol只需一个，所以要通过private_value字段所指向的soc_enum结构找出匹配的输入脚编号，最后也是通过dapm_set_path_status函数来初始化该输入端的连接状态，因为只有一个kcontrol，所以第三个参数是0。连接两个widget的链表操作和其他widget也是一样的。<br>dapm_set_path_status    该函数根据传入widget中的kcontrol编号，读取实际寄存器的值，根据寄存器的值来初始化这个path是否处于连接状态，详细的代码这里就不贴了。<br>当widget之间通过path进行连接之后，他们之间的关系就如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/210-Audio-system-snd_soc_dapm_path.png" alt="Alt text"></p><p>到这里为止，我们为声卡创建并初始化好了所需的widget，各个widget也通过path连接在了一起，接下来，dapm等待用户的指令，一旦某个dapm kcontrol被用户空间改变，利用这些连接关系，dapm会重新创建音频路径，脱离音频路径的widget会被下电，加入音频路径的widget会被上电，所有的上下电动作都会自动完成，用户空间的应用程序无需关注这些变化，它只管按需要改变某个dapm kcontrol即可。</p><h4 id="（八）、tinyplay-playback、capture"><a href="#（八）、tinyplay-playback、capture" class="headerlink" title="（八）、tinyplay playback、capture"></a>（八）、tinyplay playback、capture</h4><h5 id="8-1、tinyplay-playback"><a href="#8-1、tinyplay-playback" class="headerlink" title="8.1、tinyplay playback"></a>8.1、tinyplay playback</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/211-tiny-capture.png" alt="Alt text"></p><p>有时序图可知：主要涉及pcm_open()、pcm_write()、pcm_prepare()、pcm_start()。</p><h5 id="8-1-1、使用耳机播放"><a href="#8-1-1、使用耳机播放" class="headerlink" title="8.1.1、使用耳机播放"></a>8.1.1、使用耳机播放</h5><ol><li>启动音频播放</li><li>启用 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘RX1’<br>tinymix ‘RX2 MIX1 INP1’ ‘RX2’<br>tinymix ‘RDAC2 MUX’ ‘RX2’<br>tinymix ‘HPHL’ ‘Switch’<br>tinymix ‘HPHR’ ‘Switch’<br>tinymix ‘MI2S_RX Channels’ ‘Two</li><li>启用用于通过 MI2S 接口进行播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 1</li><li>播放 PCM 音频<br>tinyplay <filename.wav> </filename.wav></li><li>停止音频播放</li><li>禁用接收 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RX2 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RDAC2 MUX’ ‘ZERO’<br>tinymix ‘HPHL’ ‘ZERO’<br>tinymix ‘HPHR’ ‘ZERO’<br>tinymix ‘MI2S_RX Channels’ ‘One’</li><li>禁用用于通过 I2S 接口进行音频播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 0</li></ol><h5 id="8-2、tinyplay-capture"><a href="#8-2、tinyplay-capture" class="headerlink" title="8.2、tinyplay capture"></a>8.2、tinyplay capture</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/212-tiny-playback.png" alt="Alt text"></p><p>有时序图可知：主要涉及pcm_open()、pcm_read()、pcm_start()。</p><h5 id="8-2-1、使用音频录制"><a href="#8-2-1、使用音频录制" class="headerlink" title="8.2.1、使用音频录制"></a>8.2.1、使用音频录制</h5><ol><li>输入以下命令：<br>//Enable DSP AFE for Audio Recording over I2S<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 1<br>//Enable Codec TX Path<br>tinymix ‘DEC1 MUX’ ‘ADC2’<br>tinymix ‘ADC2 MUX’ ‘INP2’</li><li>启动录音功能：<br>tinycap /data/rec.wav</li><li>禁用 HeadsetX 设备 (AMIC2)：<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 0<br>tinymix ‘DEC1 MUX’ ‘ZERO’<br>tinymix ‘ADC2 MUX’ ‘ZERO’</li></ol><h4 id="（九）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（九）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（九）、参考资料(特别感谢各位前辈的分析和图示)："></a>（九）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析</title>
      <link href="/2018/05/01/Audio%20System%EF%BC%881%EF%BC%89%EF%BC%9ALinux%20&amp;&amp;%20Android%20Audio%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/01/Audio%20System%EF%BC%881%EF%BC%89%EF%BC%9ALinux%20&amp;&amp;%20Android%20Audio%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><h4 id="（一）、音频基础知识"><a href="#（一）、音频基础知识" class="headerlink" title="（一）、音频基础知识"></a>（一）、音频基础知识</h4><p>理解音频的一些基础知识，对于我们分析整个音频系统是大有裨益的。它可以让我们从实现的层面去思考，音频系统的目的是什么，然后才是怎么样去完成这个目的</p><p>#####（1）声音有哪些重要属性呢？</p><h5 id="1-1、响度-Loudness"><a href="#1-1、响度-Loudness" class="headerlink" title="1.1、响度(Loudness)"></a>1.1、响度(Loudness)</h5><p>响度就是人类可以感知到的各种声音的大小，也就是音量。响度与声波的振幅有直接关系。</p><h5 id="1-2、音调-Pitch"><a href="#1-2、音调-Pitch" class="headerlink" title="1.2、音调(Pitch)"></a>1.2、音调(Pitch)</h5><p>音调与声音的频率有关系，当声音的频率越大时，人耳所感知到的音调就越高，否则就越低。</p><h5 id="1-3、音色-Quality"><a href="#1-3、音色-Quality" class="headerlink" title="1.3、音色(Quality)"></a>1.3、音色(Quality)</h5><p>同一种乐器，使用不同的材质来制作，所表现出来的音色效果是不一样的，这是由物体本身的结构特性所决定的。</p><p>如何将各种媒体源数字化呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/11-Audio-system-1024px-A-D-A_Flow.svg.png" alt="Alt text"></p><p>将声波波形信号通过ADC转换成计算机支持的二进制的过程叫做音频采样(Audio Sampling)。采样(Sampling)的核心是把连续的模拟信号转换成离散的数字信号。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/12-Audio-system-sampling.png" alt="Alt text"></p><h5 id="1-4、样本-Sample"><a href="#1-4、样本-Sample" class="headerlink" title="1.4、样本(Sample)"></a>1.4、样本(Sample)</h5><p>这是我们进行采样的初始资料，比如一段连续的声音波形。</p><h5 id="1-5、采样器-Sampler"><a href="#1-5、采样器-Sampler" class="headerlink" title="1.5、采样器(Sampler)"></a>1.5、采样器(Sampler)</h5><p>采样器是将样本转换成终态信号的关键。它可以是一个子系统，也可以指一个操作过程，甚至是一个算法，取决于不同的信号处理场景。理想的采样器要求尽可能不产生信号失真。</p><h5 id="1-6、量化-Quantization"><a href="#1-6、量化-Quantization" class="headerlink" title="1.6、量化(Quantization)"></a>1.6、量化(Quantization)</h5><p>采样后的值还需要通过量化，也就是将连续值近似为某个范围内有限多个离散值的处理过程。因为原始数据是模拟的连续信号，而数字信号则是离散的，它的表达范围是有限的，所以量化是必不可少的一个步骤。</p><h5 id="1-7、编码-Coding"><a href="#1-7、编码-Coding" class="headerlink" title="1.7、编码(Coding)"></a>1.7、编码(Coding)</h5><p>计算机的世界里，所有数值都是用二进制表示的，因而我们还需要把量化值进行二进制编码。这一步通常与量化同时进行。</p><h5 id="1-8、采样率（samplerate）"><a href="#1-8、采样率（samplerate）" class="headerlink" title="1.8、采样率（samplerate）"></a>1.8、采样率（samplerate）</h5><p>采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用0101来表示的数字信号，示意图如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/13-Audio-system-sampling-rate.png.png" alt="Alt text"></p><p>蓝色代表模拟音频信号，红色的点代表采样得到的量化数值。</p><p>采样频率越高，红色的间隔就越密集，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。</p><p>根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。</p><p>通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。</p><h5 id="1-9、量化精度（位宽）"><a href="#1-9、量化精度（位宽）" class="headerlink" title="1.9、量化精度（位宽）"></a>1.9、量化精度（位宽）</h5><p>上图（1.8）中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。</p><p>常见的位宽是：8bit 或者 16bit</p><h5 id="1-10、-声道数（channels）"><a href="#1-10、-声道数（channels）" class="headerlink" title="1.10、 声道数（channels）"></a>1.10、 声道数（channels）</h5><p>由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。</p><p>单声道（Mono）和双声道（Stereo）比较常见，顾名思义，前者的声道数为1，后者为2</p><h5 id="1-11、音频帧（frame）"><a href="#1-11、音频帧（frame）" class="headerlink" title="1.11、音频帧（frame）"></a>1.11、音频帧（frame）</h5><p>这个概念在应用开发中非常重要，网上很多文章都没有专门介绍这个概念。</p><p>音频跟视频很不一样，视频每一帧就是一张图像，而从上面的正玄波可以看出，音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。</p><p>这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：</p><p>假设某音频信号是采样率为8kHz、双通道、位宽为16bit，20ms一帧，则一帧音频数据的大小为：</p><p>int size = 8000 x 2 x 16bit x 0.02s = 5120 bit = 640 byte</p><h5 id="1-12、常见的音频编码方式有哪些？"><a href="#1-12、常见的音频编码方式有哪些？" class="headerlink" title="1.12、常见的音频编码方式有哪些？"></a>1.12、常见的音频编码方式有哪些？</h5><p>上面提到过，模拟的音频信号转换为数字信号需要经过采样和量化，量化的过程被称之为编码，根据不同的量化策略，产生了许多不同的编码方式，常见的编码方式有：PCM 和 ADPCM，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。</p><p>我们在音频开发过程中，会经常涉及到WAV文件的读写，以验证采集、传输、接收的音频数据的正确性。</p><h5 id="1-13、常见的音频压缩格式有哪些？"><a href="#1-13、常见的音频压缩格式有哪些？" class="headerlink" title="1.13、常见的音频压缩格式有哪些？"></a>1.13、常见的音频压缩格式有哪些？</h5><p>首先简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。</p><p>（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。</p><p>（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。</p><p>下面简单列出常见的音频压缩格式：</p><p>MP3，AAC，OGG，WMA，Opus，FLAC，APE，M4A，AMR，等等</p><h5 id="1-14、奈奎斯特采样理论"><a href="#1-14、奈奎斯特采样理论" class="headerlink" title="1.14、奈奎斯特采样理论"></a>1.14、奈奎斯特采样理论</h5><p>“当对被采样的模拟信号进行还原时，其最高频率只有采样频率的一半”。<br>换句话说，如果我们要完整重构原始的模拟信号，则采样频率就必须是它的两倍以上。比如人的声音范围是2~ 20kHZ,那么选择的采样频率就应该在40kHZ左右，数值太小则声音将产生失真现象，而数值太大也无法明显提升人耳所能感知的音质。</p><h5 id="1-15、总结（音频处理和播放过程）："><a href="#1-15、总结（音频处理和播放过程）：" class="headerlink" title="1.15、总结（音频处理和播放过程）："></a>1.15、总结（音频处理和播放过程）：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/14-Audio-system-how-audio-works.png" alt="Alt text"></p><h4 id="（二）、Audio-系统框架"><a href="#（二）、Audio-系统框架" class="headerlink" title="（二）、Audio 系统框架"></a>（二）、Audio 系统框架</h4><h5 id="总体Audio框架图"><a href="#总体Audio框架图" class="headerlink" title="总体Audio框架图"></a>总体Audio框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/15-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><h5 id="2-1、APP"><a href="#2-1、APP" class="headerlink" title="2.1、APP"></a>2.1、APP</h5><p>音乐播放器软件等等。</p><h5 id="2-2、Framework"><a href="#2-2、Framework" class="headerlink" title="2.2、Framework"></a>2.2、Framework</h5><p>Android也提供了另两个相似功能的类，即AudioTrack和AudioRecorder，MediaPlayerService内部的实现就是通过它们来完成的,只不过MediaPlayer/MediaRecorder提供了更强大的控制功能，相比前者也更易于使用。除此以外，Android系统还为我们控制音频系统提供了AudioManager、AudioService及AudioSystem类。这些都是framework为便利上层应用开发所设计的。</p><h5 id="2-3、Libraries"><a href="#2-3、Libraries" class="headerlink" title="2.3、Libraries"></a>2.3、Libraries</h5><p>framework只是向应用程序提供访问Android库的桥梁，具体功能实现放在库中完成。比如上面的AudioTrack、AudioRecorder、MediaPlayer和MediaRecorder等等在库中都能找到相对应的类。</p><p>1、frameworks/av/media/libmedia【libmedia.so】<br>2、frameworks/av/services/audioflinger【libaudioflinger.so】<br>3、frameworks/av/media/libmediaplayerservice【libmediaplayerservice.so】</p><h5 id="2-4、HAL"><a href="#2-4、HAL" class="headerlink" title="2.4、HAL"></a>2.4、HAL</h5><p>从设计上来看，硬件抽象层是AudioFlinger直接访问的对象。这说明了两个问题，一方面AudioFlinger并不直接调用底层的驱动程序;另一方面，AudioFlinger上层模块只需要与它进行交互就可以实现音频相关的功能了。因而我们可以认为AudioFlinger是Android音频系统中真正的“隔离板”，无论下面如何变化，上层的实现都可以保持兼容。</p><p>音频方面的硬件抽象层主要分为两部分，即AudioFlinger和AudioPolicyService。实际上后者并不是一个真实的设备，只是采用虚拟设备的方式来让厂商可以方便地定制出自己的策略。抽象层的任务是将AudioFlinger/AudioPolicyService真正地与硬件设备关联起来，但又必须提供灵活的结构来应对变化——特别是对于Android这个更新相当频繁的系统。比如以前Android系统中的Audio系统依赖于ALSA-lib，但后期就变为了tinyalsa，这样的转变不应该对上层造成破坏。因而Audio HAL提供了统一的接口来定义它与AudioFlinger/AudioPolicyService之间的通信方式，这就是audio_hw_device、audio_stream_in及audio_stream_out等等存在的目的，这些Struct数据类型内部大多只是函数指针的定义，是一些“壳”。当AudioFlinger/AudioPolicyService初始化时，它们会去寻找系统中最匹配的实现(这些实现驻留在以audio.primary.<em>,audio.a2dp.</em>为名的各种库中)来填充这些“壳”。根据产品的不同，音频设备存在很大差异，在Android的音频架构中，这些问题都是由HAL层的audio.primary等等库来解决的，而不需要大规模地修改上层实现。换句话说，厂商在定制时的重点就是如何提供这部分库的高效实现了。</p><h5 id="2-5、Tinyalsa"><a href="#2-5、Tinyalsa" class="headerlink" title="2.5、Tinyalsa"></a>2.5、Tinyalsa</h5><p>源码在external/tinyalsa目录下<br>Tinyalsa：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制</p><h5 id="2-6、Kernel部分"><a href="#2-6、Kernel部分" class="headerlink" title="2.6、Kernel部分"></a>2.6、Kernel部分</h5><h5 id="2-6-1、ALSA-和-ASoC"><a href="#2-6-1、ALSA-和-ASoC" class="headerlink" title="2.6.1、ALSA 和 ASoC"></a>2.6.1、ALSA 和 ASoC</h5><p>Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><h5 id="2-6-2、ASoC"><a href="#2-6-2、ASoC" class="headerlink" title="2.6.2、ASoC"></a>2.6.2、ASoC</h5><p>ASoC被分为Machine、Platform和Codec三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p><h5 id="2-6-2-1、Machine"><a href="#2-6-2-1、Machine" class="headerlink" title="2.6.2.1、Machine"></a>2.6.2.1、<strong>Machine</strong></h5><p>用于描述设备组件信息和特定的控制如耳机/外放等。</p><blockquote><p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。</p></blockquote><p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p><h5 id="2-6-2-2、Platform"><a href="#2-6-2-2、Platform" class="headerlink" title="2.6.2.2、Platform"></a>2.6.2.2、<strong>Platform</strong></h5><p>用于实现平台相关的DMA驱动和音频接口等。</p><blockquote><p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p></blockquote><p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：DMA引擎和SoC集成的PCM、I2S或AC ‘97数字接口控制。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：snd_soc_platform_driver和snd_soc_dai_driver。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p><h5 id="2-6-2-3、Codec"><a href="#2-6-2-3、Codec" class="headerlink" title="2.6.2.3、Codec"></a>2.6.2.3、<strong>Codec</strong></h5><p>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</p><blockquote><p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p></blockquote><p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p><p>1、对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。<br>2、对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。<br>3、对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。<br>4、对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</p><p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/16-Audio-system-asoc-pcm-control.png" alt="Alt text"></p><p>ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p><p>☁ Codec驱动向ASoC注册snd_soc_codec和snd_soc_dai设备。<br>☁ Platform驱动向ASoC注册snd_soc_platform和snd_soc_dai设备。<br>☁ Machine驱动通过snd_soc_dai_link绑定codec/dai/platform。</p><p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p><p>☁ path描述与其它widget的连接关系。<br>☁ event用于通知该widget的上下电状态。<br>☁ power指示当前的上电状态。<br>☁ control实现空间用户接口用于控制widget的音量/通路切换等。</p><p>对驱动开者来说，就可以很好的解耦了：</p><p>☁ codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了;<br>☁ soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等;<br>☁ 板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。</p><h5 id="2-6-3、DAPM"><a href="#2-6-3、DAPM" class="headerlink" title="2.6.3、DAPM"></a>2.6.3、<strong>DAPM</strong></h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><h5 id="2-6-4、DPCM"><a href="#2-6-4、DPCM" class="headerlink" title="2.6.4、DPCM"></a>2.6.4、<strong>DPCM</strong></h5><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/sound/soc/dpcm.rst?h=v4.16-rc5" target="_blank" rel="noopener">Dynamic PCM</a></p><h5 id="2-7、Audio-devices"><a href="#2-7、Audio-devices" class="headerlink" title="2.7、Audio devices"></a>2.7、Audio devices</h5><p>具体的Audio硬件设备。</p><h4 id="（三）、Qualcomm平台-Audio系统框架"><a href="#（三）、Qualcomm平台-Audio系统框架" class="headerlink" title="（三）、Qualcomm平台 - Audio系统框架"></a>（三）、Qualcomm平台 - Audio系统框架</h4><p>由于接下来的一系列Android &amp;&amp; kernel 源码分析都是基于Qualcomm 平台的，十分有必要介绍Qualcomm 平台的Audio 系统框架。硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><h5 id="3-1、Qualcomm-Audio系统总体框架图"><a href="#3-1、Qualcomm-Audio系统总体框架图" class="headerlink" title="3.1、Qualcomm Audio系统总体框架图"></a>3.1、Qualcomm Audio系统总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/17-MSM8996-Linux-Android-Audio-Software-Overview-Architecture.png" alt="Alt text"></p><h5 id="3-2、ASoC-driver"><a href="#3-2、ASoC-driver" class="headerlink" title="3.2、ASoC driver"></a>3.2、ASoC driver</h5><p>ALSA 片上系统 (ASoC) 驱动程序将音频系统分为四个组成部分Machine driver、Platform driver、CPU driver、Codec driver。</p><h5 id="3-2-1、Machine-driver"><a href="#3-2-1、Machine-driver" class="headerlink" title="3.2.1、Machine driver"></a>3.2.1、Machine driver</h5><p>将平台、CPU 和编解码驱动程序整合在一起<br>kernel/sound/soc/msm/<chipset>.c<br>定义Frontend (FE) and Backend (BE), Digital Audio Interface (DAI) links</chipset></p><h5 id="3-2-2、Platform-driver"><a href="#3-2-2、Platform-driver" class="headerlink" title="3.2.2、Platform driver"></a>3.2.2、Platform driver</h5><p>包含用于流数据传输与路由的平台特定的控件（control）， 细分为 FE 和 BE 平台驱动程序<br><strong>FE</strong><br> Audio – 实例化 PCM 播放和录制会话；借助 ASM 接口，将 PCM 数据从用户空间传输到 DSP 进行播放<br>以及从 DSP 传输到用户空间进行录制 – 在 kernel/sound/soc/msm-pcm-q6-v2.c 中实现<br> Voice – 初始化/取消初始化语音呼叫设置 – 在 kernel/sound/soc/msm-pcm-voice-v2.c 中实现<br> VoIP – 初始化/取消初始化 MVS 接口以传输自/至 DSP 的 PCM 数据 – 在kernel/sound/soc/msm-pcmvoip-v2.c<br>中实现<br> Compressed offload – 支持将压缩数据发送到 DSP 进行压缩分流播放 – 在 kernel/sound/soc/msm-compress-q6-<br>v2.c 中实现<br><strong>BE</strong><br> 路由 – 执行音频路由任务 – 在 /kernel/sound/soc/msm-pcm-routing-v2.c 中实现</p><h5 id="3-2-3、CPU-driver"><a href="#3-2-3、CPU-driver" class="headerlink" title="3.2.3、CPU driver"></a>3.2.3、CPU driver</h5><p><strong>FE</strong><br> 向 ASoC 框架提供关于 FE PCM 设备的信息<br> ASoC 框架与平台驱动程序提供的路由表共同将 PCM 播放/捕获从 FE 传递至 BE<br> 没有针对播放和录制的内置逻辑<br> 定义 FE CPU DAI – 在 kernel/sound/soc/msm/msm-dai-fe.c 中实现<br><strong>BE</strong><br> 要在初始化 PCM 播放/捕获时激活所需音频硬件端口，则配置 DSP AFE 模块<br> 定义 BE CPU DAI – 在 kernel/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c 中实现</p><h5 id="3-2-4、Codec-driver"><a href="#3-2-4、Codec-driver" class="headerlink" title="3.2.4、Codec driver"></a>3.2.4、Codec driver</h5><p>与平台无关，其中包含音频控制、音频接口功能、编解码器 DAPM 定义以及编解<br>码器输入输出功能<br> 此外，实现 MBHC 状态机，用于检测有线耳机插入/拔出、附件类型、连接器类型<br>和多按钮检测</p><h5 id="3-3、DSP-driver"><a href="#3-3、DSP-driver" class="headerlink" title="3.3、DSP driver"></a>3.3、DSP driver</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/18-MSM8996-Linux-Android-Audio-ADSP-Architecture.png" alt="Alt text"></p><p><strong>ASM（Audio Stream Manager）</strong><br> 用于与 DSP ASM 模块通信的接口<br> 提供将 PCM 数据路由至 DSP 的机制，支持按数据流进行后期处理/预处理<br><strong>ADM（Audio Device Manager）</strong><br> 允许在 DSP 中使用 ADM 服务<br> 配置 COPP 和路由矩阵<br> 与音频校准数据库 (ACDB) 进行通信，使用正确的校准数据配置 COPP<br> 将 ASM 会话 ID 路由至 ADM 会话<br><strong>AFE（Audio Front-End）</strong><br> 允许在 DSP 中使用 AFE 服务<br> 激活/禁用音频硬件端口<br> 子系统管理器 – 发生 MDSP 复位事件时，通知音频和语音驱动程序关闭待处理<br>会话、执行清理操作并等待一个指示 MDSP 已启动的事件<br><strong>APR（Asynchronous Packet Router）</strong><br> 为处理器间通信提供异步框架<br> 用于与 Hexagon 和调制解调器处理器进行通信<br> Image loader PIL  – 载入 MDSP 图像</p><h5 id="3-4、User-Space"><a href="#3-4、User-Space" class="headerlink" title="3.4、User Space"></a>3.4、User Space</h5><p> Audio Hardware Abstraction Layer (AHAL) – 通过 tinyALSA 将 AudioFlinger<br> 调用映射至ASoC 驱动程序的硬件抽象层。<br> ACDB loader – 检索特定设备的校准信息，并写入 PMEM。ACDB 驱动程<br>序在启动过程中分配该 PMEM。在设备切换时，此校准将被发送到 DSP。<br> tinyALSA – 连接至内核 ASoC 驱动程序的接口，供音频 HAL 使用。提供用<br>于音频流和设备管理的基本 PCM 和混音控件 API。<br> Audio route – 此模块会从一个 .xml 文件读取 ALSA 混音控件，并根据音频<br>HAL 所选的设备设置混音控件。<br> Concurrency Manager - 在MSM8x10中，视频解码和编码在DSP中完成; 因此，有<br>对可支持的并发性有一些限制。MSM8x10中引入的并发管理器管理并发性<br>可以支持涉及语音和音频的不同用例</p><p>Multimedia framework – Stagefright<br> 支持标准音频格式的播放/录制<br> 与解码器/编码器库以及 OpenMAX IL 组件通信，以便进行解码和编码</p><p>Audio service<br> 由系统服务器启动并由服务管理器管理的运行时服务之一<br> 意图注册；当从各种应用程序（HDMI、蓝牙等）接收到这些意图时，通知音频<br>系统</p><p>AudioFlinger<br> 通过 libaudio 接口、蓝牙 A2DP 接口管理所有音频输出/输入设备<br> 将多个音频流处理为单一的 PCM 音频；混合后的输出被传送到输出设备<br> 播放音乐流时的音量</p><p>Audio Policy Manager (APM)<br> 定义多个音频用例之间的并发规则<br> 用例示例 – 电话通话、音乐播放、系统声音和通知<br> 定义播放的音频（例如：语音、播放、铃声）以及播放的设备（蓝牙、扬声器<br>和耳机）<br>APM 用途：<br> 管理各种输入输出设备接口<br> 管理各种输入输出设备，例如：麦克风、扬声器、耳机、听筒、A2DP、蓝牙 SCO<br> 基于音频流、模式和方法选择和定义适当的路由策略<br> 管理每个音频流的音量/静音设置（在它们激活或禁用时）</p><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功 [i.wonder~]</title>
      <link href="/2018/04/20/Google%20Pixel%20Oreo%208.1%20OPM2.171019.029%20Root%20%E4%BA%B2%E6%B5%8B%E6%88%90%E5%8A%9F/"/>
      <url>/2018/04/20/Google%20Pixel%20Oreo%208.1%20OPM2.171019.029%20Root%20%E4%BA%B2%E6%B5%8B%E6%88%90%E5%8A%9F/</url>
      <content type="html"><![CDATA[<p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">Root教程原文 Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP</a></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>✢ 电池电量高于80％。<br>✢ 数据会完全丢失不可恢复，请提前备份您的数据。<br>✢ 解锁你的Bootloader。<br>✢ 仅限Google Pixel Oreo 8.1。<br>✢ 仅限奥利奥版本。<br>✢ 笔者手机如图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/others/google-pixel.jpg" alt="enter image description here"></p><h4 id="一、解锁Bootloader"><a href="#一、解锁Bootloader" class="headerlink" title="一、解锁Bootloader"></a>一、解锁Bootloader</h4><p>在Google Pixel Oreo 8.1 OPM2.171019.029中解锁引导加载程序bootloader</p><h5 id="1-1、OEM解锁"><a href="#1-1、OEM解锁" class="headerlink" title="1.1、OEM解锁"></a>1.1、OEM解锁</h5><p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">解锁BootLoader教程 Unlocking Bootloader in Google Pixel and Pixel XL</a><br>✢ <a href="https://bitbucket.org/Serverbee/downloadbee/downloads/adb-setup-1.4.3.exe" target="_blank" rel="noopener">下载</a>（Windows）/<a href="https://bitbucket.org/Serverbee/downloadbee/downloads/adb-mac.zip" target="_blank" rel="noopener">下载</a>（Mac）相应的ADB、Fastboot、驱动程序并将其安装到您的系统中。<br>✢ 进入 设置-&gt;关于手机 连续点击5次版本号，直到提示”你已处于开发者模式，无需进行此操作”<br>✢ 点击返回进入 “开发者模式” 打开 “OEM解锁” 和 “USB调试”<br>✢ 连接手机，若弹出提示框请选择是/允许，命令行执行：adb devices，成功会有以下类似提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">* daemon not running; starting now at tcp:5037</span><br><span class="line">* daemon started successfully</span><br><span class="line">FA7240301112    device</span><br></pre></td></tr></table></figure><p>✢ 命令行执行：adb reboot bootloader<br>✢ 执行：fastboot oem unlock<br>✢ 您需要通过增大音量按钮来确认手机中的操作。您将成功解除成功消息。当您收到此消息时，请按音量键并导航开始，然后按电源按钮。手机将重新启动。启动第一次启动需要一些时间。<br>✢ 解锁成功在开机界面会有一个打开的小锁图标</p><h5 id="1-2、将系统升级到Oreo-8-1-OPM2-171019-029稳定版"><a href="#1-2、将系统升级到Oreo-8-1-OPM2-171019-029稳定版" class="headerlink" title="1.2、将系统升级到Oreo 8.1 OPM2.171019.029稳定版"></a>1.2、将系统升级到Oreo 8.1 OPM2.171019.029稳定版</h5><p>Root Google Pixel Oreo 8.1 OPM2.171019.029稳定的版本于2018年4月发布。<br>1、<a href="https://developers.google.cn/android/images#sailfish" target="_blank" rel="noopener">Sailfish-OPM2.171019.029下载地址</a><br>2、解压运行update-all.bat（Windows）/ update-all.bat（Mac）</p><h5 id="1-3、Root-Pixel-Oreo-8-1-OPM2-171019-029有四个步骤"><a href="#1-3、Root-Pixel-Oreo-8-1-OPM2-171019-029有四个步骤" class="headerlink" title="1.3、Root Pixel Oreo 8.1 OPM2.171019.029有四个步骤"></a>1.3、Root Pixel Oreo 8.1 OPM2.171019.029有四个步骤</h5><p>✢ Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029<br>✢ Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0<br>✢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0<br>✢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</p><h4 id="二、Install-TWRP-Recovery-Officially-in-Google-Pixel-Oreo-8-1-OPM2-171019-029"><a href="#二、Install-TWRP-Recovery-Officially-in-Google-Pixel-Oreo-8-1-OPM2-171019-029" class="headerlink" title="二、Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029"></a>二、Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029</h4><p><strong>步骤：</strong><br>1、确保 系统OEM解锁成功、手机版本为Oreo 8.1 OPM2.171019.029，然后执行接下来的操作<br>2、<a href="https://www.firmwares.androidinfotech.com/google-pixel-official-twrp-3-2-0-0-sailfish-img/" target="_blank" rel="noopener">下载 twrp-3.2.1-2-sailfish.img</a> Google Pixel Oreo 8.1 OPM2.171019.029的TWRP恢复镜像<br>3、通过USB连接您的手机，执行：adb reboot bootloader进入BootLoader模式（或者关机状态 Power键+音量下键进入）<br>4、确保您的手机已被系统检测到，执行：fastboot devices 会看到设备号<br>5、fastboot boot twrp-3.2.1-2-sailfish.img<br>6、重启进入下一步操作</p><h4 id="三、Install-Root-Files-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#三、Install-Root-Files-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="三、Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>三、Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.firmwares.androidinfotech.com/twrp-pixel-installer-sailfish-3-1-1-0-zip/" target="_blank" rel="noopener">下载 twrp-pixel-installer-sailfish-3.1.1-0.zip</a>，将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/others/twrp-3-0.jpg" alt="enter image description here"><br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select twrp-pixel-installer-sailfish-3.1.1-0.zip<br>安装后重新启动您的手机。</p><h4 id="四、Install-SuperSu-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#四、Install-SuperSu-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="四、Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>四、Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.firmwares.androidinfotech.com/sr5-supersu-v2-82-sr5-20171001224502-zip/" target="_blank" rel="noopener">下载 SR5-SuperSU-v2.82-SR5-20171001224502.zip</a> 将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select SR5-SuperSU-v2.82-SR5-20171001224502.zip<br>安装后重新启动您的手机。</p><h4 id="五、Install-Magisk-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#五、Install-Magisk-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="五、Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>五、Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.androidinfotech.com/2017/07/magisk-versions-download.html" target="_blank" rel="noopener">下载 Magisk-v16.1(1610).zip</a> 将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select Magisk-v16.1(1610).zip<br>安装后重新启动您的手机。</p><h4 id="六、出现的问题"><a href="#六、出现的问题" class="headerlink" title="六、出现的问题"></a>六、出现的问题</h4><p>（一）问题：adb 出现 device offline，更新adb版本到1.0.39<br>（二）问题：笔者Pixel手机执行上述步骤后，无法开机，执行以下步骤就可以开机了：<br>1、关掉你的手机<br>2、Power键+音量下键进入BootLoader模式模式，然后音量键选择 recovery mode，按power键进入Recovery模式<br>3、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>4、滑动清除Data</p><p>Root成功，(o゜▽゜)o☆[BINGO!]</p><h4 id="七、参考资料-特别感谢各位前辈的辛苦奉献-："><a href="#七、参考资料-特别感谢各位前辈的辛苦奉献-：" class="headerlink" title="七、参考资料(特别感谢各位前辈的辛苦奉献)："></a>七、参考资料(特别感谢各位前辈的辛苦奉献)：</h4><p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">解锁BootLoader教程 Unlocking Bootloader in Google Pixel and Pixel XL</a><br><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">Root教程原文 Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人网站(分享一个有趣的的Loading gif) [i.wonder~]</title>
      <link href="/2018/04/03/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99(%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9A%84Loading%20gif)/"/>
      <url>/2018/04/03/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99(%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9A%84Loading%20gif)/</url>
      <content type="html"><![CDATA[<h4 id="（一）、-Loading-gif："><a href="#（一）、-Loading-gif：" class="headerlink" title="（一）、 Loading gif："></a>（一）、 Loading gif：</h4><p>茶不思饭不想、不眠不夜折腾近两周，总算把个人网站搭建好了(๑乛◡乛๑)。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/01-zhoujinjian.home.loading.gif" alt="Markdown"></p><h4 id="（二）、个人网站（zhoujinjian-cc）"><a href="#（二）、个人网站（zhoujinjian-cc）" class="headerlink" title="（二）、个人网站（zhoujinjian.cc）"></a>（二）、个人网站（zhoujinjian.cc）</h4><p>闷骚的主题，我想基本也不会有人来浏览我的个人网站，闷骚就闷骚点吧(๑乛◡乛๑)：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/02-zhoujinjian.home.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/03-zhoujinjian.home-2.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/04-zhoujinjian.home-404.png" alt="Markdown"></p><h4 id="（三）、总结"><a href="#（三）、总结" class="headerlink" title="（三）、总结"></a>（三）、总结</h4><p>个人网站先暂时告一段落了，接下来还是继续老本行分析Android 源代码，之前分析虽已大致打通 App层 -&gt; Framework层 -&gt; Native层 -&gt; Kernel层，冒似有一定经验了然并卵，路漫漫其修远兮，生命不息，学无止境（其实嘛就是 -&gt; 人丑就要多读书๑乛◡乛๑）。好想读读书去看看外面的世界啊。</p><p>where you want to go-&gt;(Castelluccio di Norcia卡斯特鲁奇奥公园,意大利):</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/05-zhoujinjian.home-norcaia.png" alt="Markdown"></p><p>Or-&gt;(Lofoten, Reinebringen(雷訥),挪威):</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/06-zhoujinjian.home-lofoten.png" alt="Markdown"></p><p>PS：哇哦，好美，算了我就想想<strong>（ಡωಡ）</strong>。</p><h4 id="（四）、参考资料-特别感谢各位前辈的辛苦奉献-："><a href="#（四）、参考资料-特别感谢各位前辈的辛苦奉献-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的辛苦奉献)："></a>（四）、参考资料(特别感谢各位前辈的辛苦奉献)：</h4><p><a href="https://bing.ioliu.cn/v1?p=1&amp;d=0&amp;w=1280&amp;h=768" target="_blank" rel="noopener">Bing 壁纸 API</a><br><a href="https://api.lylares.com/bing/image/?w=1920&amp;h=1080" target="_blank" rel="noopener">Api-bing-wallpaper</a><br><a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank" rel="noopener">Mrminfive - Hexo-theme-skapp</a><br><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Molunerfinn - Hexo-theme-melody</a><br><a href="https://github.com/stkevintan/canoe-blog" target="_blank" rel="noopener">Stkevintan - canoe-blog</a><br><a href="https://www.designernews.co/404" target="_blank" rel="noopener">(404) The page you were looking for doesn’t exist</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux内核（Kernel-3.18） - Linux Input 子系统分析 [i.wonder~]</title>
      <link href="/2018/04/01/Linux%E5%86%85%E6%A0%B8%EF%BC%88Kernel-3-18%EF%BC%89-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-i-wonder/"/>
      <url>/2018/04/01/Linux%E5%86%85%E6%A0%B8%EF%BC%88Kernel-3-18%EF%BC%89-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-i-wonder/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input" target="_blank" rel="noopener">【博客原图链接】</a></p><p>源码（部分）：</p><p><strong>kernel/msm-3.18/include/linux</strong></p><ul><li>Input.h</li><li>evdev.h</li></ul><p><strong>kernel/msm-3.18/drivers/input</strong></p><ul><li>Input.c</li><li>evdev.c</li><li>gpio_keys.c</li></ul><p><strong>kernel/msm-3.18/drivers/input/touchscreen/synaptics_dsx_htc_2.6</strong></p><ul><li>Makefile</li><li>Kconfig</li><li>synaptics_dsx_core.c</li></ul><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：</p><p><a href="https://android.googlesource.com/kernel/msm/+/android-msm-marlin-3.18-nougat-mr2-pixel" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - Google</a> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><hr><h2 id="（一）、Linux-Input-子系统框架"><a href="#（一）、Linux-Input-子系统框架" class="headerlink" title="（一）、Linux Input 子系统框架"></a>（一）、Linux Input 子系统框架</h2><p>输入(Input)子系统是分层架构的，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）。</p><p>驱动根据CORE提供的接口，向上报告发生的按键动作。然后CORE根据驱动的类型，分派这个报告给对应的事件处理层进行处理。事件处理层把数据变化反应到设备模型的文件中（事件缓冲区）。并通知在这些设备模型文件上等待的进程。</p><p>input子系统框架： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/01-Linux-kernel-input-subsystem-framework.png" alt="Markdown"></p><p>(1) “硬件驱动层”负责操作具体的硬件设备，这层的代码是针对具体的驱动程序的，比如你的设备是触摸输入设备，还是鼠标输入设备，还是键盘输入设备，这些不同的设备，自然有不同的硬件操作，驱动工程师往往只需要完成这层的代码编写。</p><p>(2) “输入子系统核心层”是链接其他两层之间的纽带与桥梁，向下提供硬件驱动层的接口，向上提供事件处理层的接口。</p><p>(3) “事件处理层” 负责与用户程序打交道，将硬件驱动层传来的事件报告给用户程序。</p><p>各层之间通信的基本单位就是事件，任何一个输入设备的动作都可以抽象成一种事件，如键盘的按下，触摸屏的按下，鼠标的移动等。事件有三种属性：类型（type），编码(code)，值(value)， Input 子系统支持的所有事件都定义在 input.h中，包括所有支持的类型，所属类型支持的编码等。事件传送的方向是 硬件驱动层–&gt;子系统核心–&gt;事件处理层–&gt;用户空间。</p><h2 id="（二）、Input-主要通用数据结构"><a href="#（二）、Input-主要通用数据结构" class="headerlink" title="（二）、Input 主要通用数据结构"></a>（二）、Input 主要通用数据结构</h2><h2 id="2-1、input-dev"><a href="#2-1、input-dev" class="headerlink" title="2.1、input_dev"></a>2.1、input_dev</h2><p>输入设备 input_dev，这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//输入设备的名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys;    <span class="comment">//输入设备节点名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *uniq;    <span class="comment">//指定唯一的ID号，就像MAC地址一样</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//输入设备标识ID，用于和事件处理层进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[BITS_TO_LONGS(EV_CNT)];    <span class="comment">//位图，记录设备支持的事件类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，记录设备支持的按键类型      </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[BITS_TO_LONGS(REL_CNT)];    <span class="comment">//位图，记录设备支持的相对坐标  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];    <span class="comment">//位图，记录设备支持的绝对坐标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];    <span class="comment">//位图，记录设备支持的其他功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，记录设备支持的指示灯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];   <span class="comment">//位图，记录设备支持的声音或警报</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];     <span class="comment">//位图，记录设备支持的作用力功能  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swbit[BITS_TO_LONGS(SW_CNT)];     <span class="comment">//位图，记录设备支持的开关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodemax;      <span class="comment">//设备支持的最大按键值个数  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodesize;    <span class="comment">//每个按键的字节大小</span></span><br><span class="line">    <span class="keyword">void</span> *keycode;      <span class="comment">//指向按键池，即指向按键值数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*setkeycode)(struct input_dev *dev,</span><br><span class="line">              <span class="keyword">const</span> struct input_keymap_entry *ke,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> *old_keycode);    <span class="comment">//修改按键值</span></span><br><span class="line">    <span class="keyword">int</span> (*getkeycode)(struct input_dev *dev,</span><br><span class="line">              struct input_keymap_entry *ke);   <span class="comment">//获取按键值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span>     <span class="comment">//用于强制更新输入设备的部分内容  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat_key;    <span class="comment">//重复按键的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>   <span class="comment">//设置当有连击时的延时定时器  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，按键的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> led[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，led的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> snd[BITS_TO_LONGS(SND_CNT)];    <span class="comment">//位图，声音的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sw[BITS_TO_LONGS(SW_CNT)];   <span class="comment">//位图，开关的状态  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">    <span class="keyword">int</span> (*event)(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span> <span class="comment">//类似私有指针，可以直接访问到事件处理接口event  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> event_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> users;</span><br><span class="line">    <span class="keyword">bool</span> going_away;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span> <span class="comment">//该链表头用于链接此设备所关联的input_handle   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span> <span class="comment">//用于将此设备链接到input_dev_list(链接了所有注册到内核的事件处理器)  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_vals;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_vals;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-1、input-handler"><a href="#2-1、input-handler" class="headerlink" title="2.1、input_handler"></a>2.1、input_handler</h2><p>input_handler 这是事件处理器的数据结构，代表一个事件处理器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/* 当事件处理器接收到来自Input设备传来的事件时调用的处理函数,</span></span><br><span class="line"><span class="comment">        event、events用于处理事件 */</span>  </span><br><span class="line">    <span class="keyword">void</span> (*event)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*events)(struct input_handle *handle,</span><br><span class="line">               <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">bool</span> (*filter)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="comment">/* 比较 device's id with handler's id_table ，匹配device and handler*/</span></span><br><span class="line">    <span class="keyword">bool</span> (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    <span class="comment">/* connect用于建立intput_handler和input_dev的联系,</span></span><br><span class="line"><span class="comment">       当一个Input设备注册到内核的时候被调用,将输入设备与事件处理器联结起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*connect)(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id);</span><br><span class="line">    <span class="comment">/* disconnect用于解除handler和device的联系 */</span></span><br><span class="line">    <span class="keyword">void</span> (*disconnect)(struct input_handle *handle);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> legacy_minors;</span><br><span class="line">    <span class="keyword">int</span> minor;    <span class="comment">//次设备号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span>    <span class="comment">//用于和device匹配 ,这个是事件处理器所支持的input设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3、input-handle"><a href="#2-3、input-handle" class="headerlink" title="2.3、input_handle"></a>2.3、input_handle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构，</span></span><br><span class="line"><span class="comment">    注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    打开标志，每个input_handle 打开后才能操作，</span></span><br><span class="line"><span class="comment">    这个一般通过事件处理器的open方法间接设置  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> open;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">/* 指向Input_dev结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="comment">/* 指向Input_Hander结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过d_node连接到了input_dev上的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过h_node连接到了input_handler的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4、三个数据结构之间的关系"><a href="#2-4、三个数据结构之间的关系" class="headerlink" title="2.4、三个数据结构之间的关系"></a>2.4、三个数据结构之间的关系</h2><blockquote><p>input_dev: 是硬件驱动层，代表一个input设备。 input_handler: 是事件处理层，代表一个事件处理器。 input_handle: 属于核心层，代表一个配对的input_dev与input_handler</p></blockquote><p>input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    ......</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。通过input_dev 和input_handler就可以找到input_handle在设备注册和事件处理器，注册的时候都要进行配对工作<strong>(input_match_device)</strong>，配对后就会实现链接<strong>(handler-&gt;connect)</strong>通过input_handle也可以找到input_dev和input_handler。注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，input_device和input_handler中都有一个h_list,而input_handle拥有指向input_dev和input_handler的指针，也就是说input_handle是用来关联input_dev和input_handler的。 那么为什么一个input_device和input_handler中拥有的是h_list而不是一个handle呢？因为一个device可能对应多个handler,而一个handler也不能只处理一个device,比如说一个鼠标，它可以对应even handler，也可以对应mouse handler,因此当其注册时与系统中的handler进行匹配，就有可能产生两个实例，一个是evdev,另一个是mousedev,而任何一个实例中都只有一个handle。至于以何种方式来传递事件，就由用户程序打开哪个实例来决定。后面一个情况很容易理解，一个事件驱动不能只为一个甚至一种设备服务，系统中可能有多种设备都能使用这类handler,比如event handler就可以匹配所有的设备。在input子系统中，有8种事件驱动，每种事件驱动最多可以对应32个设备，因此dev实例总数最多可以达到256个。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/02-Linux-kernel-input-dev-handler.png" alt="Markdown"></p><h2 id="（三）、Input-核心层（Input-c）"><a href="#（三）、Input-核心层（Input-c）" class="headerlink" title="（三）、Input 核心层（Input.c）"></a>（三）、Input 核心层（Input.c）</h2><p>这一节主要介绍核心层的初始化，input_device、input_handle、input_handler之间的关系(稍后回头看更佳)。 总体概览图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/03-Linux-kernel-input-core-h_list.png" alt="Markdown"></p><h2 id="3-1、输入核心层：初始化"><a href="#3-1、输入核心层：初始化" class="headerlink" title="3.1、输入核心层：初始化"></a>3.1、输入核心层：初始化</h2><p>首先从驱动”入口函数”开始查看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//注册input类，可在/sys/class下看到对应节点文件</span></span><br><span class="line">    err = class_register(&amp;input_class);</span><br><span class="line">    ......</span><br><span class="line">    err = input_proc_init();<span class="comment">/*创建/proc中的项，查看/proc/bus/input  */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*注册设备/dev/input，主设备号为INPUT_MAJOR，就是13，后面注册的输入设备都使用该主设备号*/</span></span><br><span class="line">    err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">                     INPUT_MAX_CHAR_DEVICES, <span class="string">"input"</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在入口函数里面创建了一个input_class类，其实就在/sys/class下创建了一个目录input.当然对于一个新设备，可以注册进一个class也可以不注册进去，如果存在对应class的话注册进去更好，另外在/proc创建了入口项,这样就可以/proc目录看到input的信息，然后就注册设备，可以看出输入子系统的主设备号是13，在这里并没有生成设备文件。只是在/dev/目录下创建了input目录，以后所有注册进系统的输入设备文件都放在这个目录下。</p><p>相应的对应关系可以使用adb 命令进入文件系统之后，cat /proc/bus/input/devices ，查看各个设备对应的event多少，比如Google Pixel 手机：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=<span class="number">0000</span> Vendor=<span class="number">0000</span> Product=<span class="number">0003</span> Version=<span class="number">2066</span></span><br><span class="line">N: Name=<span class="string">"synaptics_dsxv26"</span></span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=<span class="number">2</span></span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=<span class="number">8000</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">B: ABS=<span class="number">663800000000000</span></span><br></pre></td></tr></table></figure><p>event3 就是事件序号， 我们在调试的时候直接 adb shell getevent /dev/input/event3，来实时捕捉 event3 中储存的数据。</p><p>那么接下来看看怎么注册input设备的.我们需要在设备驱动层中完成输入设备的注册，通过调用input_register_device()函数来完成，该函数的一个重要任务就是完成设备与事件驱动的匹配</p><h2 id="3-2、输入核心层：注册设备input-dev"><a href="#3-2、输入核心层：注册设备input-dev" class="headerlink" title="3.2、输入核心层：注册设备input_dev"></a>3.2、输入核心层：注册设备input_dev</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">                      <span class="keyword">sizeof</span>(struct input_devres), GFP_KERNEL);</span><br><span class="line">        ......</span><br><span class="line">        devres-&gt;input = dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//EN_SYN这个是设备都要支持的事件类型，所以要设置   </span></span><br><span class="line">    <span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">    packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">        dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">    dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">    dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">     * is handled by the driver itself and we don't do it in input.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 这个定时器是为了重复按键而设置的</span></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">        dev-&gt;timer.data = (<span class="keyword">long</span>) dev;</span><br><span class="line">        dev-&gt;timer.function = input_repeat_key;</span><br><span class="line">        dev-&gt;rep[REP_DELAY] = <span class="number">250</span>;</span><br><span class="line">        dev-&gt;rep[REP_PERIOD] = <span class="number">33</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有设置自己的获取键值的函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">        dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有指定按键重置函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">        dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">    error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">    pr_info(<span class="string">"%s as %s\n"</span>,</span><br><span class="line">        dev-&gt;name ? dev-&gt;name : <span class="string">"Unspecified device"</span>,</span><br><span class="line">        path ? path : <span class="string">"N/A"</span>);</span><br><span class="line">    kfree(path);</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将新分配的input设备连接到input_dev_list链表上  </span></span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line">    <span class="comment">/* 核心重点，input设备在增加到input_dev_list链表上之后，会查找</span></span><br><span class="line"><span class="comment">     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配</span></span><br><span class="line"><span class="comment">     * 方式与设备模型的device和driver匹配过程很相似，所有的input</span></span><br><span class="line"><span class="comment">     * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list</span></span><br><span class="line"><span class="comment">     * 上，进行“匹配相亲”，list_for_each_entry就是个for循环，跳出条件遍历了一遍，又回到链表头 */</span>  </span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        dev_dbg(dev-&gt;dev.parent, <span class="string">"%s: registering %s with devres.\n"</span>,</span><br><span class="line">            __func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">        devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情：</p><p>1、进一步初始化输入设备，例如连击事件 2、注册输入设备到input类中，把输入设备挂到输入设备链表input_dev_list中 3、查找并匹配输入设备对应的事件处理层，通过input_handler_list链表</p><p>我们需要再分析下这个匹配的过程，input_attach_handler()匹配过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* input_dev 和 input_handler 进行匹配,返回匹配的id，类型是struct input_device_id  */</span>  </span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 匹配成功，调用handler里面的connect函数,这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构 */</span>  </span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看下input_match_device（）函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct input_device_id *<span class="title">input_match_device</span><span class="params">(struct input_handler *handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype) <span class="comment">//匹配总线id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)  <span class="comment">//匹配生产商id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)  <span class="comment">//匹配产品id  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version) <span class="comment">//匹配版本  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配id的evbit和input_dev中evbit的各个位，如果不匹配则continue，数组中下一个设备  </span></span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">            <span class="keyword">return</span> id;<span class="comment">//匹配成功,返回id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_match_device() 到最合适的事件处理层驱动时，便执行handler-&gt;connect() 函数进行连接了，看下面这部分代码（以evdev类型驱动为例，在input/evdev.c中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">int</span> dev_no;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev */</span></span><br><span class="line">    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 开始给evdev事件层驱动分配空间了 */</span></span><br><span class="line">    evdev = kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 初始化client_list列表和evdev_wait队列，后面介绍 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">    spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">    mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">    init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">    evdev-&gt;exist = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */</span></span><br><span class="line">    dev_no = minor;</span><br><span class="line">    <span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">    <span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)</span><br><span class="line">        dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, <span class="string">"event%d"</span>, dev_no);</span><br><span class="line">    <span class="comment">/*这里就将handle的dev指针指向了input_dev*/</span></span><br><span class="line">    evdev-&gt;handle.dev = input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler = handler;<span class="comment">/*这里将handle的handler指向了当前的input_handler.注意本函数evdev_connect,可能是在在输入设备注册的时候</span></span><br><span class="line"><span class="comment">38     在input_register_device函数中调用input_attach_handler的时候调用;也可能是在输入设备的处理方法input_handler时在input_register_handler</span></span><br><span class="line"><span class="comment">39     函数中也会用到input_attach_handler函数,就会调用本函数.这里就很明显了,本函数就将input_handler和input_dev都放在input_handle中统一管理*/</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化evdev中的内嵌device*/</span></span><br><span class="line">    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);</span><br><span class="line">    evdev-&gt;dev.class = &amp;input_class;</span><br><span class="line">    evdev-&gt;dev.parent = &amp;dev-&gt;dev;</span><br><span class="line">    evdev-&gt;dev.release = evdev_free;</span><br><span class="line">    device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line">   <span class="comment">/* input_dev设备驱动层和input_handler事件处理层的关联，由input_handle完成(不要和handler搞混淆了，这不是一个概念～) */</span>  </span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</span><br><span class="line">    evdev-&gt;cdev.kobj.parent = &amp;evdev-&gt;dev.kobj;</span><br><span class="line">    error = cdev_add(&amp;evdev-&gt;cdev, evdev-&gt;dev.devt, <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    error = device_add(&amp;evdev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、输入核心层：注册input-handler"><a href="#3-3、输入核心层：注册input-handler" class="headerlink" title="3.3、输入核心层：注册input_handler"></a>3.3、输入核心层：注册input_handler</h2><p>为了逻辑更清新，我们稍后再来看input_register_handle() 程，先来了解input_handler的注册过程。 要了解input_handler的注册过程，又需要先了解evdev初始化过程（以evdev为例）： /kernel/drivers/input下众多事件处理器handler其中的一个，可以看下源码/kernel/drivers/input/evdev.c中的模块init</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">evdev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化就是往input核心中注册一个input_handler类型的evdev_handler，调用的是input.c提供的接口，input_handler结构前面有介绍，看下evdev_handler的赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> = &#123;</span></span><br><span class="line">    .event        = evdev_event,</span><br><span class="line">    .events        = evdev_events,</span><br><span class="line">    .connect    = evdev_connect,</span><br><span class="line">    .disconnect    = evdev_disconnect,</span><br><span class="line">    .legacy_minors    = <span class="literal">true</span>,</span><br><span class="line">    .minor        = EVDEV_MINOR_BASE,</span><br><span class="line">    .name        = <span class="string">"evdev"</span>,</span><br><span class="line">    .id_table    = evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以注意的是evdev是匹配所有设备的，因为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] = &#123;</span></span><br><span class="line">    &#123; .driver_info = <span class="number">1</span> &#125;,    <span class="comment">/* Matches all devices */</span></span><br><span class="line">    &#123; &#125;,            <span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">    <span class="comment">//添加进input_handler_list全局链表</span></span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">    <span class="comment">//同样遍历input_dev这个链表，依次调用下面的input_attach_handler去匹配input_dev,这个跟input_dev注册的时候的情形类似  </span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）"><a href="#3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）" class="headerlink" title="3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）"></a>3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）</h2><p>input_handle关联匹配input_dev和input_handler 继续分析input_dev和input_handler 是如何关联上的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上</span></span><br><span class="line"><span class="comment">    * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以</span></span><br><span class="line"><span class="comment">    * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把这个handle的d_node 加到对应input_dev的h_list链表里面  </span></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">        list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//把这个handle的h_node 加到对应input_handler的h_list链表里面</span></span><br><span class="line">    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">        handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注册是把handle 本身的链表加入到它自己的input_dev 以及 input_handler的h_list链表中，这样以后就可以通过h_list遍历到这个handle，这样就实现了三者的绑定联系。</p><p>以上是输入设备驱动注册的全过程，纵观整个过程，输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件被谁去处理呢？知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。 整个关联注册的过程：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/04-Linux-kernel-input-reg-device.png" alt="Markdown"></p><h2 id="（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）"><a href="#（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）" class="headerlink" title="（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）"></a>（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/05-Linux-kernel-input-event-hardware.png" alt="Markdown"></p><h2 id="4-1、主要数据结构"><a href="#4-1、主要数据结构" class="headerlink" title="4.1、主要数据结构"></a>4.1、主要数据结构</h2><p><strong>（1） evdev设备结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> exist;   </span><br><span class="line">    <span class="keyword">int</span> open;                     <span class="comment">//打开标志   </span></span><br><span class="line">    <span class="keyword">int</span> minor;                    <span class="comment">//次设备号   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span>   <span class="comment">//关联的input_handle   </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;       <span class="comment">//等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">grab</span>;</span>    <span class="comment">//强制绑定的evdev_client结构，这个结构后面再分析   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span> <span class="comment">//evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备   </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> client_lock;       <span class="comment">/* protects client_list */</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>            <span class="comment">//device结构，说明这是一个设备结构   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)，如触摸屏驱动的event3，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input3。这个设备结构生成之后保存在evdev_table中，索引值是minor。 <strong>（2）evdev用户端结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> head;  <span class="comment">//buffer数组的索引头  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tail;   <span class="comment">//buffer数组的索引尾  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wake_lock</span> <span class="title">wake_lock</span>;</span>  </span><br><span class="line">    <span class="keyword">bool</span> use_wake_lock;  </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">28</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span>    <span class="comment">//异步通知函数  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span>  <span class="comment">//包含一个evdev变量  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>  <span class="comment">//链表  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span>   <span class="comment">//input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value）  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构在进程打开event3设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。 <strong>（3）input_event结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>    <span class="comment">//事件发生的时间   </span></span><br><span class="line">    __u16 type;             <span class="comment">//事件类型   </span></span><br><span class="line">    __u16 code;             <span class="comment">//子事件   </span></span><br><span class="line">    __s32 value;            <span class="comment">//事件的value  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2、事件处理层evdev"><a href="#4-2、事件处理层evdev" class="headerlink" title="4.2、事件处理层evdev"></a>4.2、事件处理层evdev</h2><p>事件处理层与用户程序和输入子系统核心打交道，是他们两层的桥梁。一般内核有好几个事件处理器，像evdev mousedev jotdev。evdev事件处理器可以处理所有的事件，触摸屏驱动就是用的这个，所以下面分析这个事件处理器的实现。它也是作为模块注册到内核中的,前面已经分析过它的模块初始化函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> = &#123;</span></span><br><span class="line">    .owner        = THIS_MODULE,</span><br><span class="line">    .read        = evdev_read,</span><br><span class="line">    .write        = evdev_write,</span><br><span class="line">    .poll        = evdev_poll,</span><br><span class="line">    .open        = evdev_open,</span><br><span class="line">    .release    = evdev_release,</span><br><span class="line">    .unlocked_ioctl    = evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_ioctl    = evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">    .fasync        = evdev_fasync,</span><br><span class="line">    .flush        = evdev_flush,</span><br><span class="line">    .llseek        = no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果匹配上了就会创建一个evdev，它里边封装了一个handle，会把input_dev和input_handler关联到一起。关系如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/06-Linux-kernel-input-evdev-connect.png" alt="Markdown"></p><h2 id="4-3、evdev设备结点的open-操作"><a href="#4-3、evdev设备结点的open-操作" class="headerlink" title="4.3、evdev设备结点的open()操作"></a>4.3、evdev设备结点的open()操作</h2><p>我们知道.对主设备号为INPUT_MAJOR的设备节点进行操作，会将操作集转换成handler的操作集。在evdev中，这个操作集就是evdev_fops。对应的open函数如下示：</p><p>首先来看打开event(x)设备文件，evdev_open函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">container_of</span>(<span class="title">inode</span>-&gt;<span class="title">i_cdev</span>, <span class="title">struct</span> <span class="title">evdev</span>, <span class="title">cdev</span>);</span></span><br><span class="line">    <span class="comment">//evdev_client的buffer大小  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct evdev_client) +</span><br><span class="line">                    bufsize * <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">//打开的时候创建一个evdev_client</span></span><br><span class="line">    client = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    client-&gt;bufsize = bufsize;</span><br><span class="line">    spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="built_in">snprintf</span>(client-&gt;name, <span class="keyword">sizeof</span>(client-&gt;name), <span class="string">"%s-%d"</span>,</span><br><span class="line">            dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current));</span><br><span class="line">    client-&gt;evdev = evdev;</span><br><span class="line">    evdev_attach_client(evdev, client);</span><br><span class="line">    <span class="comment">//调用打开真正的底层设备函数  </span></span><br><span class="line">    error = evdev_open_device(evdev);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    file-&gt;private_data = client;</span><br><span class="line">    nonseekable_open(inode, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open_device</span><span class="params">(struct evdev *evdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (retval)<span class="comment">/*如果设备不存在，返回错误*/</span>  </span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!evdev-&gt;exist)</span><br><span class="line">        retval = -ENODEV;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!evdev-&gt;open++) &#123;<span class="comment">//递增打开计数  </span></span><br><span class="line">        retval = input_open_device(&amp;evdev-&gt;handle);<span class="comment">//如果是被第一次打开，则调用input_open_device</span></span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            evdev-&gt;open--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_open_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span><span class="comment">//根据input_handle找到对应的input_dev设备  </span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    handle-&gt;open++;<span class="comment">//递增handle的打开计数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;users++ &amp;&amp; dev-&gt;open)</span><br><span class="line">        retval = dev-&gt;open(dev);<span class="comment">//如果是第一次打开.则调用input device的open()函数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        dev-&gt;users--;</span><br><span class="line">        <span class="keyword">if</span> (!--handle-&gt;open) &#123;</span><br><span class="line">            synchronize_rcu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4、用户进程读取event的底层实现"><a href="#4-4、用户进程读取event的底层实现" class="headerlink" title="4.4、用户进程读取event的底层实现"></a>4.4、用户进程读取event的底层实现</h2><p>至于具体的如何初始化input_dev，这个是具体的输入设备去实现的，稍后具体实例再分析，现在来看看，对于一个event(x)设备文件的，应用程序来读，最终会导致”handler”里面的的”读函数”被调用。</p><p>evdev_fops 结 构 体 是 一 个 file_operations 的 类 型 。 当 用 户 层 调 用 类 似 代 码open(“/dev/input/event3” , O_RDONLY) 函 数 打 开 设 备 结 点 时 , 会 调 用 evdev_fops 中 的evdev_read()函数,该函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">evdev_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span><span class="comment">//就是刚才在open函数中保存的evdev_client  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//如果获得了数据则取出来，调用evdev_fetch_next_event  </span></span><br><span class="line">        <span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">               evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//input_event_to_user调用copy_to_user传入用户程序中，这样读取完成  </span></span><br><span class="line">            <span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            read += input_event_size();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/*如果是可阻塞状态的话,则等待在wait队列上.直到有数据要被处理,当前进程才被唤醒.这很好理解,既然是</span></span><br><span class="line"><span class="comment">         输入设备,读的话比如读按键,那么必须要有硬件设备有按键按下才会返回按键值,这里还是处于事件处理层,应用程序在这里休眠,那么谁来唤醒?</span></span><br><span class="line"><span class="comment">         当然是有按键按下才去唤醒,因此这个工作就交给了设备驱动层,那么找到这个唤醒呢,直接去找不好找,那么可以直接搜索evdev-&gt;wait,搜索结果</span></span><br><span class="line"><span class="comment">         可知evdev-&gt;wait在evdev_event()函数中被唤醒*/</span></span><br><span class="line">        <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">            error = wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">                    client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">                    !evdev-&gt;exist || client-&gt;revoked);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_fetch_next_event</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> have_event;</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="comment">/*先判断一下是否有数据*/</span>   </span><br><span class="line">    have_event = client-&gt;packet_head != client-&gt;tail;</span><br><span class="line">    <span class="comment">/*如果有就从环形缓冲区的取出来，记得是从head存储，tail取出*/</span></span><br><span class="line">    <span class="keyword">if</span> (have_event) &#123;</span><br><span class="line">        *event = client-&gt;buffer[client-&gt;tail++];</span><br><span class="line">        client-&gt;tail &amp;= client-&gt;bufsize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (client-&gt;use_wake_lock &amp;&amp;</span><br><span class="line">            client-&gt;packet_head == client-&gt;tail)</span><br><span class="line">            wake_unlock(&amp;client-&gt;wake_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> have_event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_event_to_user</span><span class="params">(<span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*如果设置了标志INPUT_COMPAT_TEST就将事件event包装成结构体compat_event*/</span></span><br><span class="line">    <span class="keyword">if</span> (INPUT_COMPAT_TEST &amp;&amp; !COMPAT_USE_64BIT_TIME) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_event_compat</span> <span class="title">compat_event</span>;</span></span><br><span class="line"></span><br><span class="line">        compat_event.time.tv_sec = event-&gt;time.tv_sec;</span><br><span class="line">        compat_event.time.tv_usec = event-&gt;time.tv_usec;</span><br><span class="line">        compat_event.type = event-&gt;type;</span><br><span class="line">        compat_event.code = event-&gt;code;</span><br><span class="line">        compat_event.value = event-&gt;value;</span><br><span class="line">         <span class="comment">/*将包装成的compat_event拷贝到用户空间*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, &amp;compat_event,</span><br><span class="line">                 <span class="keyword">sizeof</span>(struct input_event_compat)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/*否则，将event拷贝到用户空间*/</span>   </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是可阻塞状态的话，则等待在wait队列上。直到有数据要被处理，当前进程才被唤醒。这很好理解，既然是输入设备，读的话比如读按键，那么必须要有硬件设备有按键按下才会返回按键值，这里还是处于事件处理层，应用程序在这里休眠，那么谁来唤醒?</p><p>当然是有按键按下才去唤醒，因此这个工作就交给了设备驱动层。那么找到这个唤醒呢，直接去找不好找。那么可以直接搜索evdev-&gt;wait，搜索结果可知evdev-&gt;wait在evdev_event()函数中被唤醒</p><p>注释中说的很清楚，evdev_event()会唤醒此处的读按键进程。那么evdev_event()又是被谁调用?显然是设备驱动层，现在看一个设备层例子，内核中有个按键的例子，gpiokey.c，这只是个例子不针对任何设备，在gpio_keys.c终端处理函数里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;gpio_keys.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">gpio_keys_irq_isr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!bdata-&gt;key_pressed) &#123;</span><br><span class="line">        ......</span><br><span class="line">        input_event(input, EV_KEY, button-&gt;code, <span class="number">1</span>);</span><br><span class="line">        input_sync(input);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此可以看出 在设备的中断服务程序里面，确定事件是什么，然后调用相应的input_handler的event处理函数 实际上这就是我们的核心 input_event()是用来上报事件的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">        spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        input_handle_event(dev, type, code, value);</span><br><span class="line">        spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_handle_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">            input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;</span><br><span class="line">        dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">        input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_pass_values</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = rcu_dereference(dev-&gt;grab);</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">            <span class="keyword">if</span> (handle-&gt;open)</span><br><span class="line">                count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_to_handler</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> = <span class="title">vals</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">        handler-&gt;events(handle, vals, count);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)</span><br><span class="line">        <span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">            handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终调用handler-&gt;event()来处理，此处handler即对应evdev。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line">handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value)</span><br></pre></td></tr></table></figure><p>所以会调用evdev_event()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_pass_values</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">ktime_t</span> mono, <span class="keyword">ktime_t</span> real)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;revoked)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    event.time = ktime_to_timeval(client-&gt;clkid == CLOCK_MONOTONIC ?</span><br><span class="line">                      mono : real);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interrupts are disabled, just acquire the lock. */</span></span><br><span class="line">    spin_lock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">        event.type = v-&gt;type;</span><br><span class="line">        event.code = v-&gt;code;</span><br><span class="line">        event.value = v-&gt;value;</span><br><span class="line">        __pass_event(client, &amp;event);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT)</span><br><span class="line">            wakeup = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wakeup)</span><br><span class="line">        wake_up_interruptible(&amp;evdev-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_events</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">handle</span>-&gt;<span class="title">private</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (client)</span><br><span class="line">        evdev_pass_values(client, vals, count, time_mono, time_real);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">            evdev_pass_values(client, vals, count,</span><br><span class="line">                      time_mono, time_real);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_event</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] = &#123;</span> &#123; type, code, value &#125; &#125;;</span><br><span class="line">    evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终唤醒evdev_read()将数据拷贝到用户空间。</p><h2 id="（五）、Input-事件上报过程"><a href="#（五）、Input-事件上报过程" class="headerlink" title="（五）、Input 事件上报过程"></a>（五）、Input 事件上报过程</h2><h2 id="5-1、Input-事件产生"><a href="#5-1、Input-事件产生" class="headerlink" title="5.1、Input 事件产生"></a>5.1、Input 事件产生</h2><p>当按下触摸屏时，进入触摸屏按下中断，开始ad转换，ad转换完成进入ad完成中断，在这个终端中将事件发送出去，会调用以下函数上报事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> input_report_key(input_dev,</span><br><span class="line">         BTN_TOUCH, 1);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_X, x);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_Y, y);</span><br><span class="line"></span><br><span class="line">input_sync(input_dev);</span><br></pre></td></tr></table></figure><p>这两个函数调用了 input_event(dev, EV_ABS, code, value) 所有的事件报告函数都调用这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_key</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_abs</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_ABS, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2、Input-事件报告"><a href="#5-2、Input-事件报告" class="headerlink" title="5.2、Input 事件报告"></a>5.2、Input 事件报告</h2><p>input_event 函数前面已经分析过，这里不再分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c:input_pass_values]</span><br><span class="line"><span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">    handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br></pre></td></tr></table></figure><p>最终会调用handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) 来将数据 传递给用户空间等待读取数据的进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event))</span><br></pre></td></tr></table></figure><h2 id="（六）、Android-Input子系统"><a href="#（六）、Android-Input子系统" class="headerlink" title="（六）、Android Input子系统"></a>（六）、Android Input子系统</h2><p>输入子系统的系统架构如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/07-Linux-kernel-android-input-system.png" alt="Markdown"></p><p>详细分析请参考：Android 7.1.2 (Android N) Android 输入子系统-Input System 分析</p><h2 id="（七）、Input-设备驱动层实例（Synaptics）"><a href="#（七）、Input-设备驱动层实例（Synaptics）" class="headerlink" title="（七）、Input 设备驱动层实例（Synaptics）"></a>（七）、Input 设备驱动层实例（Synaptics）</h2><p>触摸屏也是用上面这一套框架来操作的。右边需要一个”evdev.c”文件。左边要分配一个”input_dev”结构。接着就看上图的硬件设备左边的过程：分配一个”input_dev”结构体 –&gt; 设置这个”input_dev”结构体 –&gt; 注册这个”input_dev”结构体 –&gt; 硬件相关的操作。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/08-Linux-kernel-input-drivers-fw.png" alt="Markdown"></p><p>编写Input驱动一般框架:</p><p>Google Pixel、Pixel XL 触控驱动模块型号为Synaptics（ClearPad S3708），源码：<a href="https://github.com/matthewdalex/marlin/tree/2f567606935d601f1391ad9575b103f35737a438/drivers/input/touchscreen/synaptics_dsx_htc_2.6" target="_blank" rel="noopener">Synaptics 触摸屏驱动源码</a></p><p>Makefile：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/input/touchscreen/synaptics_dsx_htc_2<span class="number">.6</span>/Makefile]</span><br><span class="line">#</span><br><span class="line"># Makefile <span class="keyword">for</span> the Synaptics DSX touchscreen driver.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Each configuration option enables a <span class="built_in">list</span> of files.</span><br><span class="line"></span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C_HTC_v26) += synaptics_dsx_i2c.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_SPI_HTC_v26) += synaptics_dsx_spi.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_HTC_v26) += synaptics_dsx_core.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_HTC_v26) += synaptics_dsx_rmi_dev.o</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>抓取kernel log：可知input 驱动名为synaptics_dsxv26，全局搜索可知synaptics_rmi4_f12_init在[-&gt;synaptics_dsx_core.c]中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[    <span class="number">1.362728</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init: Function <span class="number">12</span> max x = <span class="number">1079</span> max y = <span class="number">1919</span> Rx: <span class="number">16</span> Tx: <span class="number">28</span></span><br><span class="line">[    <span class="number">1.363344</span>] c3      <span class="number">1</span> [TP]synaptics_rmi4_f12_init:Wakeup Gesture range (<span class="number">0</span>,<span class="number">0</span>) -&gt; (<span class="number">1079</span>,<span class="number">1919</span>)</span><br><span class="line">[    <span class="number">1.363623</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init report data init done</span><br><span class="line">[    <span class="number">1.371945</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: chip_id:<span class="number">3708</span>, firmware_id:<span class="number">2433782</span></span><br><span class="line">[    <span class="number">1.372865</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: config_version: <span class="number">5331763200190000000000000000000000000000000000000000000000000000</span></span><br><span class="line">[    <span class="number">1.373249</span>] c3      <span class="number">1</span> input: synaptics_dsxv26 as /devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br></pre></td></tr></table></figure><p>查看input设备：adb shell cat /proc/bus/input/devices</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=0000 Vendor=0000 Product=0003 Version=2066</span><br><span class="line">N: Name=&quot;synaptics_dsxv26&quot;</span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=2</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=8000 0 0</span><br><span class="line">B: ABS=663800000000000</span><br><span class="line"></span><br><span class="line">对应：/dev/input/event3</span><br></pre></td></tr></table></figure><h2 id="7-1、分配Input-dev结构体"><a href="#7-1、分配Input-dev结构体" class="headerlink" title="7.1、分配Input_dev结构体"></a>7.1、分配Input_dev结构体</h2><h2 id="7-1-1、synaptics-rmi4-f12-init"><a href="#7-1-1、synaptics-rmi4-f12-init" class="headerlink" title="7.1.1、synaptics_rmi4_f12_init()"></a>7.1.1、synaptics_rmi4_f12_init()</h2><p>首先看一下初始化过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">synaptics_rmi4_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = PLATFORM_DRIVER_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">        .pm = &amp;synaptics_rmi4_dev_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = synaptics_rmi4_probe,</span><br><span class="line">    .remove = synaptics_rmi4_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">synaptics_rmi4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_bus_init();</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;synaptics_rmi4_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(synaptics_rmi4_init);</span><br></pre></td></tr></table></figure><p>首先注册平台驱动，当驱动和设备匹配成功，继续看一下synaptics_rmi4_probe()函数</p><h2 id="7-1-2、synaptics-rmi4-probe"><a href="#7-1-2、synaptics-rmi4-probe" class="headerlink" title="7.1.2、synaptics_rmi4_probe()"></a>7.1.2、synaptics_rmi4_probe()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval, len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> attr_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_hw_interface</span> *<span class="title">hw_if</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="comment">//初始化platform_data、board_data、rmi4_data</span></span><br><span class="line">    hw_if = pdev-&gt;dev.platform_data;</span><br><span class="line">    bdata = hw_if-&gt;board_data;</span><br><span class="line">    rmi4_data = kzalloc(<span class="keyword">sizeof</span>(*rmi4_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;pdev = pdev;</span><br><span class="line">    rmi4_data-&gt;current_page = MASK_8BIT;</span><br><span class="line">    rmi4_data-&gt;hw_if = hw_if;</span><br><span class="line">    rmi4_data-&gt;touch_stopped = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;sensor_sleep = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;irq_enabled = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fw_updating = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;update_coords = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;write_buf = devm_kzalloc(&amp;pdev-&gt;dev, I2C_WRITE_BUF_MAX_LEN,</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    rmi4_data-&gt;write_buf_len = I2C_WRITE_BUF_MAX_LEN;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq_enable = synaptics_rmi4_irq_enable;</span><br><span class="line">    rmi4_data-&gt;reset_device = synaptics_rmi4_reset_device;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_io_ctrl_mutex));</span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_reset_mutex));</span><br><span class="line"></span><br><span class="line">    retval = synaptics_dsx_regulator_configure(rmi4_data);</span><br><span class="line">    retval = synaptics_dsx_regulator_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    platform_set_drvdata(pdev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;gpio_config) &#123;</span><br><span class="line">        retval = synaptics_rmi4_set_gpio(rmi4_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = synaptics_dsx_pinctrl_init(rmi4_data);</span><br><span class="line">        <span class="keyword">if</span> (!retval &amp;&amp; rmi4_data-&gt;ts_pinctrl) &#123;</span><br><span class="line">            retval = pinctrl_select_state(rmi4_data-&gt;ts_pinctrl,</span><br><span class="line">                    rmi4_data-&gt;pinctrl_state_active);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        retval = synaptics_dsx_gpio_configure(rmi4_data, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;fw_name) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(bdata-&gt;fw_name);</span><br><span class="line"></span><br><span class="line">        strlcpy(rmi4_data-&gt;fw_name, bdata-&gt;fw_name, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配Input_dev结构体，设置，注册</span></span><br><span class="line">    retval = synaptics_rmi4_set_input_dev(rmi4_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq = gpio_to_irq(bdata-&gt;irq_gpio);</span><br><span class="line">    <span class="comment">//请求中断，并设置中断处理函数synaptics_rmi4_irq</span></span><br><span class="line">    retval = synaptics_rmi4_irq_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!exp_data.initialized) &#123;</span><br><span class="line">        mutex_init(&amp;exp_data.mutex);</span><br><span class="line">        INIT_LIST_HEAD(&amp;exp_data.<span class="built_in">list</span>);</span><br><span class="line">        exp_data.initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exp_data.workqueue = create_singlethread_workqueue(<span class="string">"dsx_exp_workqueue"</span>);</span><br><span class="line">    INIT_DELAYED_WORK(&amp;exp_data.work, synaptics_rmi4_exp_fn_work);</span><br><span class="line">    exp_data.rmi4_data = rmi4_data;</span><br><span class="line">    exp_data.queue_work = <span class="literal">true</span>;</span><br><span class="line">    queue_delayed_work(exp_data.workqueue,</span><br><span class="line">            &amp;exp_data.work,</span><br><span class="line">            msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;dir = debugfs_create_dir(DEBUGFS_DIR_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (attr_count = <span class="number">0</span>; attr_count &lt; ARRAY_SIZE(attrs); attr_count++) &#123;</span><br><span class="line">        retval = sysfs_create_file(&amp;rmi4_data-&gt;input_dev-&gt;dev.kobj,</span><br><span class="line">                &amp;attrs[attr_count].attr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synaptics_secure_touch_init(rmi4_data);</span><br><span class="line">    synaptics_secure_touch_stop(rmi4_data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-3、分配Input-dev结构体"><a href="#7-1-3、分配Input-dev结构体" class="headerlink" title="7.1.3、分配Input_dev结构体"></a>7.1.3、分配Input_dev结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……"><a href="#7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……" class="headerlink" title="7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……"></a>7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME "synaptics_dsxv26"(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3、注册设备input-register-device"><a href="#7-3、注册设备input-register-device" class="headerlink" title="7.3、注册设备input_register_device()"></a>7.3、注册设备input_register_device()</h2><p>此处即与前面kernel log呼应：注册名为 synaptics_dsxv26 的输入设备</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME "synaptics_dsxv26"(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">    retval = input_register_device(rmi4_data-&gt;input_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4、硬件相关操作"><a href="#7-4、硬件相关操作" class="headerlink" title="7.4、硬件相关操作"></a>7.4、硬件相关操作</h2><p>当触摸屏按下，会产生中断，进而调用中断处理函数synaptics_rmi4_irq():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">synaptics_rmi4_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">            <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IRQ_HANDLED == synaptics_filter_interrupt(data))</span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gpio_get_value(bdata-&gt;irq_gpio) != bdata-&gt;irq_on_state)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_sensor_report(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步调用synaptics_rmi4_sensor_report(rmi4_data, true)处理数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_sensor_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> report)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[MAX_INTR_REGISTERS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *intr = &amp;data[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> was_in_bl_mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f01_device_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_fn</span> *<span class="title">fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_exp_fhandler</span> *<span class="title">exp_fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_device_info</span> *<span class="title">rmi</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi = &amp;(rmi4_data-&gt;rmi4_mod_info);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">            data,</span><br><span class="line">            rmi4_data-&gt;num_of_intr_regs + <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//读取寄存器数据</span></span><br><span class="line">    status.data[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (status.status_code == STATUS_CRC_IN_PROGRESS) &#123;</span><br><span class="line">        retval = synaptics_rmi4_check_status(rmi4_data,</span><br><span class="line">                &amp;was_in_bl_mode);</span><br><span class="line">        ....</span><br><span class="line">        retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">                rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">                status.data,</span><br><span class="line">                <span class="keyword">sizeof</span>(status.data));</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.unconfigured &amp;&amp; !status.flash_prog) &#123;</span><br><span class="line">        pr_notice(<span class="string">"%s: spontaneous reset detected\n"</span>, __func__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//synaptics_rmi4_report_touch()上报数据</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;rmi-&gt;support_fn_list)) &#123;</span><br><span class="line">        list_for_each_entry(fhandler, &amp;rmi-&gt;support_fn_list, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fhandler-&gt;num_of_data_sources) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fhandler-&gt;intr_mask &amp;</span><br><span class="line">                        intr[fhandler-&gt;intr_reg_num]) &#123;</span><br><span class="line">                    synaptics_rmi4_report_touch(rmi4_data,</span><br><span class="line">                            fhandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;exp_data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;exp_data.<span class="built_in">list</span>)) &#123;</span><br><span class="line">        list_for_each_entry(exp_fhandler, &amp;exp_data.<span class="built_in">list</span>, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exp_fhandler-&gt;insert &amp;&amp;</span><br><span class="line">                    !exp_fhandler-&gt;remove &amp;&amp;</span><br><span class="line">                    (exp_fhandler-&gt;exp_fn-&gt;attn != <span class="literal">NULL</span>))</span><br><span class="line">                exp_fhandler-&gt;exp_fn-&gt;attn(rmi4_data, intr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;exp_data.mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-1、Input数据上报："><a href="#7-4-1、Input数据上报：" class="headerlink" title="7.4.1、Input数据上报："></a>7.4.1、Input数据上报：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_report_touch</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (fhandler-&gt;fn_number) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> SYNAPTICS_RMI4_F12:</span><br><span class="line">        touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,</span><br><span class="line">                fhandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (touch_count_2d)</span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_f12_abs_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> touch_count = <span class="number">0</span>; <span class="comment">/* number of touch points */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fingers_to_process;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_status;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> size_of_2d_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> gesture_type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> data_addr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> wx;</span><br><span class="line">    <span class="keyword">int</span> wy;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_extra_data</span> *<span class="title">extra_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">finger_data</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_presence;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> stylus_presence;</span><br><span class="line"></span><br><span class="line">    fingers_to_process = fhandler-&gt;num_of_data_points;</span><br><span class="line">    data_addr = fhandler-&gt;full_addr.data_base;</span><br><span class="line">    extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler-&gt;extra;</span><br><span class="line">    size_of_2d_data = <span class="keyword">sizeof</span>(struct synaptics_rmi4_f12_finger_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            data_addr + extra_data-&gt;data1_offset,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)fhandler-&gt;data,</span><br><span class="line">            fingers_to_process * size_of_2d_data);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data = (struct synaptics_rmi4_f12_finger_data *)fhandler-&gt;data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line">    <span class="comment">//根据触摸点数量循环上报input数据</span></span><br><span class="line">    <span class="keyword">for</span> (finger = <span class="number">0</span>; finger &lt; fingers_to_process; finger++) &#123;</span><br><span class="line">        finger_data = data + finger;</span><br><span class="line">        finger_status = finger_data-&gt;object_type_and_status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        x = (finger_data-&gt;x_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;x_lsb);</span><br><span class="line">        y = (finger_data-&gt;y_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;y_lsb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;swap_axes) &#123;</span><br><span class="line">            temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">            temp = wx;</span><br><span class="line">            wx = wy;</span><br><span class="line">            wy = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;x_flip)</span><br><span class="line">            x = rmi4_data-&gt;sensor_max_x - x;</span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;y_flip)</span><br><span class="line">            y = rmi4_data-&gt;sensor_max_y - y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (finger_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> F12_FINGER_STATUS:</span><br><span class="line">        <span class="keyword">case</span> F12_GLOVED_FINGER_STATUS:</span><br><span class="line"></span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOOL_FINGER, <span class="number">1</span>);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_X, x);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_Y, y);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    input_sync(rmi4_data-&gt;input_dev);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> touch_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用input_report_key()、input_report_abs()、input_sync() 上报、同步数据。</p><h2 id="（八）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（八）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（八）、参考文档(特别感谢各位前辈的分析和图示)："></a>（八）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://blog.csdn.net/column/details/input.html" target="_blank" rel="noopener">Linux/Android—-Input系统</a><br><a href="https://blog.csdn.net/tiantangniaochao/article/details/50497353" target="_blank" rel="noopener">Android Input子系统浅谈</a><br><a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/" target="_blank" rel="noopener">Android(Linux) 输入子系统解析</a><br><a href="http://www.cnblogs.com/jason-lu/p/3156411.html" target="_blank" rel="noopener">input子系统分析之三:驱动模块</a><br><a href="https://blog.csdn.net/fanwenjieok/article/details/38503027" target="_blank" rel="noopener">Linux驱动框架之—-Input子系统</a><br><a href="https://www.zybuluo.com/zifehng/note/718523" target="_blank" rel="noopener">input子系统事件处理层(evdev)的环形缓冲区</a><br><a href="https://blog.csdn.net/ielife/article/details/7814108" target="_blank" rel="noopener">linux input输入子系统分析《四》：input子系统整体流程全面分析</a><br><a href="https://blog.csdn.net/yueqian_scut/article/details/48792939" target="_blank" rel="noopener">Linux input子系统分析之二：深入剖析input_handler、input_core、input_device</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Android WindowManagerService 窗口管理服务 分析 [i.wonder~]</title>
      <link href="/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90-i-wonder/"/>
      <url>/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90-i-wonder/</url>
      <content type="html"><![CDATA[<p>窗口管理系统WMS是Android中的主要子系统之一，它涉及到App中组件的管理，系统和应用窗口的管理和绘制等工作。由于其涉及模块众多，且与用户体验密切相关，所以它也是Android当中最为复杂的子系统之一。一个App从启动到主窗口显示出来，需要App，ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。</p><a id="more"></a><h2 id="【博客原图链接】"><a href="#【博客原图链接】" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.wms" target="_blank" rel="noopener">【博客原图链接】</a></h2><h2 id="源码（部分）："><a href="#源码（部分）：" class="headerlink" title="源码（部分）："></a>源码（部分）：</h2><p><strong>/frameworks/base/services/core/java/com/android/server/am/</strong></p><ul><li>ActivityStack.java</li><li>ActivityManagerService.java</li><li>ActivityStackSupervisor.java</li><li>ActivityStarter.java</li><li>ActivityRecord.java</li></ul><p><strong>/frameworks/base/core/java/android/view/</strong></p><ul><li>WindowManagerImpl.java</li><li>ViewManager.java</li><li>WindowManagerGlobal.java</li><li>ViewRootImpl.java</li><li>Choreographer.java</li><li>IWindowSession.aidl</li><li>DisplayEventReceiver.java</li><li>SurfaceControl.java</li><li>Surface.java</li><li>SurfaceSession.java</li></ul><p><strong>/frameworks/base/services/core/java/com/android/server/wm/</strong></p><ul><li>WindowManagerService.java</li><li>AppWindowAnimator.java</li><li>AppTransition.java</li><li>AppWindowToken.java</li><li>Session.java</li><li>WindowState.java</li><li>WindowAnimator.java</li><li>WindowStateAnimator.java</li><li>WindowSurfacePlacer.java</li><li>WindowSurfaceController.java</li></ul><h2 id="【博客原图链接】-1"><a href="#【博客原图链接】-1" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.wms" target="_blank" rel="noopener">【博客原图链接】</a></h2><p>我们先看一下窗口启动、退出过程动态图，之后再详细分析：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/01-Android-WMS-ezgif.com-gif-maker-WindowManagerService-resize.gif" alt="Markdown"></p><h2 id="（一）、Window-组织方式"><a href="#（一）、Window-组织方式" class="headerlink" title="（一）、Window 组织方式"></a>（一）、Window 组织方式</h2><p>ActivityManagerService（AMS），WindowManagerService（WMS），SurfaceFlinger（SF）等几个模块相互合作。App负责业务逻辑，绘制自己的视图；AMS管理组件、进程信息和Activity的堆栈及状态等等；WMS管理Activity对应的窗口及子窗口，还有系统窗口等；SF用于管理图形缓冲区，将App绘制的东西合成渲染在屏幕上。 窗口管理系统主要框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/02-Android-WMS-AMS-SurfaceFlinger-Conn.png" alt="Markdown"></p><blockquote><p>主要对象功能介绍：</p><p>WindowManagerService负责完成窗口的管理工作</p><p>WindowState和应用端窗口一一对应，应用调用WMS添加窗口时，最终会在WindowManagerService.addWindow()创建一个WindowState与之一一对应</p><p>WindowToken是一个句柄，保存了所有具有同一个token的WindowState。应用请求WindowManagerService添加窗口的时候，提供了一个token，该token标识了被添加窗口的归属，WindowManagerService为该token生成一个WindowToken对象，所有token相同的WindowState被关联到同一个WindowToken，如输入法添加窗口时，会传递一个IBinder mCurToken，墙纸服务添加窗口时，会传递一个WallpaperConnection::final Binder mToken。</p><p>AppWindowToken继承于WindowToken，专门用于标识一个Activity。AppWindowToken里的token实际上就是指向了一个Activity。ActivityManagerService通知应用启动的时候，在服务端生成一个token用于标识该Activity，并且把该token传递到应用客户端，客户端的Activity在申请添加窗口时，以该token作为标识传递到WindowManagerService。同一个Activity中的主窗口、对话框窗口、菜单窗口都关联到同一个AppWindowToken。</p><p>Session表示一个客户端和服务端的交互会话。一般来说不同的应用通过不同的会话来和WindowManagerService交互，但是处于同一个进程的不同应用通过同一个Session来交互。</p></blockquote><h3 id="1-1、Android-Token介绍"><a href="#1-1、Android-Token介绍" class="headerlink" title="1.1、Android Token介绍"></a>1.1、Android Token介绍</h3><p>Token是ActivityRecord的内部静态类，我们先来看下Token的继承关系，Token extends IApplicationToken.Stub，从IApplicationToken.Stub类进行继承，根据Binder的机制可以知道Token是一个匿名Binder实体类，这个匿名Binder实体会传递给其他进程，其他进程会拿到Token的代理端。 我们知道匿名Binder有两个比较重要的用途，一个是拿到Binder代理端后可跨Binder调用实体端的函数接口，另一个作用便是在多个进程中标识同一个对象。往往这两个作用是同时存在的，比如我们这里研究的Token就同时存在这两个作用，但最重要的便是后者，Token标识了一个ActivityRecord对象，即间接标识了一个Activity。</p><p>Token梳理： 分析源码，我们发现，大多数 token 的对象，都表示一个 IBinder 对象。提到 IBinder，大家一点也不陌生，就是 Android 的 IPC 通信机制。在创建窗口过程中，涉及到的 IPC 通信，无非包含两方面，一个是 WmS 用来跟应用所在的进程进行通信的 ViewRootImpl.W 类的对象，另一个是指向一个 ActivityRecord 的对象，自然应该是WMS用来跟 AMS进行通信的了。我们梳理了一下，token 以下几处的定义，分别来讲讲这里的 token 代表什么。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/03-Android-WMS-Token-Detail.png" alt="Markdown"></p><p>分析一下 View 的 AttachInfo 的赋值。ViewRootImpl 在构建方法里，会初始化一个 AttachInfo 实例，把它的 Session，以及 W类对象赋值给 AttachInfo。分析可以看到，AttachInfo 中的 mWindowToken，与mWindow 都是指向 ViewRootImpl 中的 mWindow(W类实例)。当一个 View attach 到窗口后，ViewRootImpl会执行performTraversals，如果发现是首次调用会，会把自己的 mAttachInfo 传递给根 View（通过dispatchAttachedToWindow），告诉 View 树现在已经 attch to Window 了，马上可以显示了。根 View（一般是 ViewGroup）会把这个信息，遍历地传递给 View 树中的每一个子 View，这样每个 View 的 mAttachInfo 都被赋值为 ViewRootImp 的 mAttachInfo了。</p><h3 id="1-1-1、Token对象的创建"><a href="#1-1-1、Token对象的创建" class="headerlink" title="1.1.1、Token对象的创建"></a>1.1.1、Token对象的创建</h3><p>下面这个图是Token的传递，首先会传递到WMS中，接着会传递到应用进程ActivityThread中，下面来具体分析这个传递流程。 总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/04-Android-WMS-Token.png" alt="Markdown"></p><p>我们之前分析：【Android 7.1.2 (Android N) Activity启动流程分析】 在启动Activity过程中会调用ActivityStarter.startActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">            intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,</span><br><span class="line">            requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, container,</span><br><span class="line">            options, sourceRecord);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                <span class="keyword">true</span>, options, inTask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在startActivityLocked()中创建了一个ActivityRecord对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="keyword">final</span> IApplicationToken.Stub appToken; <span class="comment">// window manager token</span></span><br><span class="line"></span><br><span class="line">ActivityRecord(ActivityManagerService _service, ProcessRecord _caller,</span><br><span class="line">        <span class="keyword">int</span> _launchedFromUid, String _launchedFromPackage, Intent _intent, String _resolvedType,</span><br><span class="line">        ActivityInfo aInfo, Configuration _configuration,</span><br><span class="line">        ActivityRecord _resultTo, String _resultWho, <span class="keyword">int</span> _reqCode,</span><br><span class="line">        <span class="keyword">boolean</span> _componentSpecified, <span class="keyword">boolean</span> _rootVoiceInteraction,</span><br><span class="line">        ActivityStackSupervisor supervisor,</span><br><span class="line">        ActivityContainer container, ActivityOptions options, ActivityRecord sourceRecord) &#123;</span><br><span class="line">    service = _service;</span><br><span class="line">    appToken = <span class="keyword">new</span> Token(<span class="keyword">this</span>, service);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在ActivityRecord的构造函数中创建，标识着当前这个ActivityRecord，即间接代表着一个Activity。</p><h3 id="1-1-2、AMS调用WMS的addAPPToken-接口"><a href="#1-1-2、AMS调用WMS的addAPPToken-接口" class="headerlink" title="1.1.2、AMS调用WMS的addAPPToken()接口"></a>1.1.2、AMS调用WMS的addAPPToken()接口</h3><p>在启动一个Activity时，会调用startActivityLocked()来在WMS中添加一个AppWindowToken对象 startActivityLocked()创建ActivityRecord对象后会继续调用startActivityUnchecked()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">            addConfigOverride(r, task);</span><br><span class="line">            ......</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addConfigOverride</span><span class="params">(ActivityRecord r, TaskRecord task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = task.updateOverrideConfigurationFromLaunchBounds();</span><br><span class="line">        <span class="comment">// 跳转到WMS</span></span><br><span class="line">        mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,</span><br><span class="line">                r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">                (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != <span class="number">0</span>, r.userId, r.info.configChanges,</span><br><span class="line">                task.voiceSession != <span class="keyword">null</span>, r.mLaunchTaskBehind, bounds, task.mOverrideConfig,</span><br><span class="line">                task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(),</span><br><span class="line">                r.appInfo.targetSdkVersion, r.mRotationAnimationHint);</span><br><span class="line">        r.taskConfigOverride = task.mOverrideConfig;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们继续看下WindowManager.addAppToken()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppToken</span><span class="params">(<span class="keyword">int</span> addPos, IApplicationToken token, <span class="keyword">int</span> taskId, <span class="keyword">int</span> stackId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> requestedOrientation, <span class="keyword">boolean</span> fullscreen, <span class="keyword">boolean</span> showForAllUsers, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> voiceInteraction, <span class="keyword">boolean</span> launchTaskBehind,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect taskBounds, Configuration config, <span class="keyword">int</span> taskResizeMode, <span class="keyword">boolean</span> alwaysFocusable,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> homeTask, <span class="keyword">int</span> targetSdkVersion, <span class="keyword">int</span> rotationAnimationHint)</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            AppWindowToken atoken = findAppWindowToken(token.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (atoken != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_WM, <span class="string">"Attempted to add existing app token: "</span> + token);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据ActivityRecord中IApplicationToken.Stub的代理，创建AppWindowToken</span></span><br><span class="line">            atoken = <span class="keyword">new</span> AppWindowToken(<span class="keyword">this</span>, token, voiceInteraction);</span><br><span class="line">            atoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos;</span><br><span class="line">            atoken.appFullscreen = fullscreen;</span><br><span class="line">            atoken.showForAllUsers = showForAllUsers;</span><br><span class="line">            atoken.targetSdk = targetSdkVersion;</span><br><span class="line">            atoken.requestedOrientation = requestedOrientation;</span><br><span class="line">            atoken.layoutConfigChanges = (configChanges &amp;</span><br><span class="line">                    (ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_ORIENTATION)) != <span class="number">0</span>;</span><br><span class="line">            atoken.mLaunchTaskBehind = launchTaskBehind;</span><br><span class="line">            atoken.mAlwaysFocusable = alwaysFocusable;</span><br><span class="line">            atoken.mRotationAnimationHint = rotationAnimationHint;</span><br><span class="line"></span><br><span class="line">            Task task = mTaskIdToTask.get(taskId);</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                task = createTaskLocked(taskId, stackId, userId, atoken, taskBounds, config);</span><br><span class="line">            &#125;</span><br><span class="line">            task.addAppToken(addPos, atoken, taskResizeMode, homeTask);</span><br><span class="line">            <span class="comment">//将atoken放入到mTokenMap中，等应用程序addWindow时，进行身份验证</span></span><br><span class="line">            <span class="comment">//其中token.asBinder()是IApplicationToken.Stub的代理，atoken就是根据代理，得到对应AppWindowToken</span></span><br><span class="line">            mTokenMap.put(token.asBinder(), atoken);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Application tokens start out hidden.</span></span><br><span class="line">            atoken.hidden = <span class="keyword">true</span>;</span><br><span class="line">            atoken.hiddenRequested = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-3、AMS跨Binder调用应用进程的scheduleLaunchActivity-将Token传递给上层应用进程"><a href="#1-1-3、AMS跨Binder调用应用进程的scheduleLaunchActivity-将Token传递给上层应用进程" class="headerlink" title="1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程"></a>1.1.3、AMS跨Binder调用应用进程的scheduleLaunchActivity()将Token传递给上层应用进程</h3><p>当框架通过ApplicationThread的代理回调到ActivityThread的时候，将对应的步骤一种生成的token代理传入。 ActivityStackSupervisor.realStartActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">        app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过调用IApplicationThread的方法实现的，这里调用的是scheduleLaunchActivity()方法，所以真正执行的是ActivityThread中的scheduleLaunchActivity()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java :ApplicationThread]</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">                ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">                CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">                List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line">            <span class="comment">//传递给了ActivityThread的token，这个token就是IApplicationToken.Stub的代理</span></span><br><span class="line">            r.token = token;</span><br><span class="line">            ......</span><br><span class="line">            updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">            sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-4、Activity窗口添加过程"><a href="#1-1-4、Activity窗口添加过程" class="headerlink" title="1.1.4、Activity窗口添加过程"></a>1.1.4、Activity窗口添加过程</h3><p>详细过程请查看：【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityThread.java]</span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而层层调用到：ViewRootImpl.setView()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line">WindowManager.LayoutParams l = r.window.getAttributes();</span><br></pre></td></tr></table></figure><p>ViewRootImpl.setView()函数中添加Activity窗口时在参数mWindowAttributes中携带Token代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,  </span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,  </span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel)</span> </span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;  </span><br><span class="line">        <span class="comment">//attrs这个是应用程序ActivityClientRecord中传递过来的参数，其中的attrs.token就是步骤三种的r.token</span></span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);  </span><br><span class="line">        ......  </span><br><span class="line">        win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,  </span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);  </span><br><span class="line"></span><br><span class="line">        mWindowMap.put(client.asBinder(), win);  </span><br><span class="line">        ......  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据Binder机制可以知道从上层应用传递过来的Token代理对象会转换成SystemServer进程中的Token本地对象，后者与第2步中从Token对象是同一个对象，所以上面调用mTokenMap.get(attrs.token)时便能返回正确返回一个WindowToken（这个WindowToken其实是一个APPWindowToken），这样添加的窗口也就跟Activity关联上了。</p><h3 id="1-2、WMS组织方式"><a href="#1-2、WMS组织方式" class="headerlink" title="1.2、WMS组织方式"></a>1.2、WMS组织方式</h3><p>Activity管理服务ActivityManagerService中每一个ActivityRecord对象在Window管理服务WindowManagerService中都对应有一个AppWindowToken对象。</p><p>此外，在输入法管理服务InputMethodManagerService中，每一个输入法窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService又对应有一个WindowToken对象。</p><p>与输入法窗口类似，在壁纸管理服务WallpaperManagerService中，每一个壁纸窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService也对应有一个WindowToken对象。</p><p>在Window管理服务WindowManagerService中，无论是AppWindowToken对象，还是WindowToken对象，它们都是用来描述一组有着相同令牌的窗口的，每一个窗口都是通过一个WindowState对象来描述的。例如，一个Activity组件窗口可能有一个启动窗口（Starting Window），还有若干个子窗口，那么这些窗口就会组成一组，并且都是以Activity组件在Window管理服务WindowManagerService中所对应的AppWindowToken对象为令牌的。从抽象的角度来看，就是在Window管理服务WindowManagerService中，每一个令牌（AppWindowToken或者WindowToken）都是用来描述一组窗口（WindowState）的，并且每一个窗口的子窗口也是与它同属于一个组，即都有着相同的令牌。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/05-Android-WMS-AppWindowToken.png" alt="Markdown"><br>其中，Activity Stack是在ActivityManagerService服务中创建的，Token List和Window Stack是在WindowManagerService中创建的，而Binder for IM和Binder for WP分别是在InputMethodManagerService服务和WallpaperManagerService服务中创建的，用来描述一个输入法窗口和一个壁纸窗口。</p><h3 id="1-3、WMS窗口类型"><a href="#1-3、WMS窗口类型" class="headerlink" title="1.3、WMS窗口类型"></a>1.3、WMS窗口类型</h3><p>添加一个窗口是通过 WindowManagerGlobal.addView()来完成的，分析 addView 方法的参数，有三个参数是必不可少的，view，params，以及 display。而 display 一般直接取 WindowMnagerImpl 中的 mDisplay，表示要输出的显示设备。view 自然表示要显示的 View，而 params 是 WindowManager.LayoutParams，用来描述这个 view 的些窗口属性，其中一个重要的参数 type，用来描述窗口的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerGlobal]</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">            Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ```</span><br></pre></td></tr></table></figure><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">打开WindowManager类，看到静态内部类。</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">[-&gt;WindowManager]</span><br><span class="line">public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在LayoutParams中，有2个比较重要的参数: flags,type。 我们简要的分析一下flags,该参数表示Window的属性，它有很多选项，通过这些选项可以控制Window的显示特性，这里主要介绍几个比较常用的选项。</p><p>FLAG_NOT_FOCUSABLE 表示Window不需要获取焦点，也不需要接收各种输入事件，此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层具有焦点的Window。</p><p>FLAG_NOT_TOUCH_MODAL 系统会将当前Window区域以外的单击事件传递给底层的Window，当前Window区域以内的单击事件则自己处理，这个标记很重要，一般来说都需要开启此标记，否则其他Window将无法接收到单击事件。</p><p>FLAG_SHOW_WHEN_LOCKED 开启此模式可以让Window显示在锁屏的界面上。</p><blockquote><p>Type参数表示Window的类型，Window有三种类型，分别是应用Window、子Window、系统Window。应用类Window对应着一个Activity。子Window不能单独存在，它需要附属在特定的父Window之中，比如常见的PopupWindow就是一个子Window。有些系统Window是需要声明权限才能创建的Window，比如Toast和系统状态栏这些都是系统Window。</p></blockquote><h3 id="1-3-1、应用窗口"><a href="#1-3-1、应用窗口" class="headerlink" title="1.3.1、应用窗口"></a>1.3.1、应用窗口</h3><p>Activity 对应的窗口类型是应用窗口， 所有 Activity 默认的窗口类型是 TYPE_BASE_APPLICATION。 WindowManager 的 LayoutParams 的默认类型是 TYPE_APPLICATION。 Dialog 并没有设置type，所以也是默认的窗口类型即 TYPE_APPLICATION。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManager.LayoutParams]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);</span><br><span class="line">    type = TYPE_APPLICATION;</span><br><span class="line">    format = PixelFormat.OPAQUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">type层级</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">FIRST_APPLICATION_WINDOW=1</td><td style="text-align:left">开始应用程序窗口，第一个普通应用窗口</td></tr><tr><td style="text-align:left">TYPE_BASE_APPLICATION=1</td><td style="text-align:left">所有程序窗口的base窗口，其他应用程序窗口都显示在它上面</td></tr><tr><td style="text-align:left">TYPE_APPLICATION=2</td><td style="text-align:left">普通应用程序窗口，token必须设置为Activity的token来指定窗口属于谁</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_STARTING=3</td><td style="text-align:left">应用程序启动时先显示此窗口，当真正的窗口配置完成后，关闭此窗口</td></tr><tr><td style="text-align:left">LAST_APPLICATION_WINDOW=99</td><td style="text-align:left">最后一个应用窗口</td></tr></tbody></table><h3 id="1-3-2、子窗口"><a href="#1-3-2、子窗口" class="headerlink" title="1.3.2、子窗口"></a>1.3.2、子窗口</h3><p>子窗口不能单独存在，它需要附属在特定的父Window之中，例如开篇第一张图，绿色框框即为popupWindow，它就是子窗口，类型一般为TYPE_APPLICATION_PANEL。之所以称为子窗口，即它的父窗口显示时，子窗口才显示。父窗口不显示，它也不显示。追随父窗口。</p><table><thead><tr><th style="text-align:left">type层级</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">FIRST_SUB_WINDOW=1000</td><td style="text-align:left">第一个子窗口</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_PANEL=1000</td><td style="text-align:left">应用窗口的子窗口,popupWindow的默认类型</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_MEDIA=1001</td><td style="text-align:left">媒体窗口</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_SUB_PANEL=1002</td><td style="text-align:left">TYPE_APPLICATION_PANE的子窗口</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_ATTACHED_DIALOG=1003</td><td style="text-align:left">对话框，类似于面板窗口(OptionMenu,ContextMenu)</td></tr><tr><td style="text-align:left">TYPE_APPLICATION_MEDIA_OVERLAY=1004</td><td style="text-align:left">媒体信息，显示在媒体层和程序窗口之间，需要实现半透明效果</td></tr><tr><td style="text-align:left">LAST_SUB_WINDOW=1999</td><td style="text-align:left">最后一个子窗口</td></tr></tbody></table><h3 id="1-3-3、系统窗口"><a href="#1-3-3、系统窗口" class="headerlink" title="1.3.3、系统窗口"></a>1.3.3、系统窗口</h3><p>系统窗口跟应用窗口不同，不需要对应 Activity。跟子窗口不同，不需要有父窗口。一般来讲，系统窗口应该由系统来创建的，例如发生异常，ANR时的提示框，又如系统状态栏，屏保等。但是，Framework 还是定义了一些，可以被应用所创建的系统窗口，如 TYPE _TOAST，TYPE <em>INPUT</em> METHOD，TYPE _WALLPAPTER 等等。</p><table><thead><tr><th style="text-align:left">type层级</th><th style="text-align:left">类型</th></tr></thead><tbody><tr><td style="text-align:left">FIRST_SYSTEM_WINDOW=2000</td><td style="text-align:left">第一个系统窗口</td></tr><tr><td style="text-align:left">TYPE_STATUS_BAR=2000</td><td style="text-align:left">状态栏，只能有一个状态栏，位于屏幕顶端</td></tr><tr><td style="text-align:left">TYPE_SEARCH_BAR =2001</td><td style="text-align:left">搜索栏</td></tr><tr><td style="text-align:left">TYPE_PHONE=2002</td><td style="text-align:left">电话窗口，它用于电话交互</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_ALERT=2003</td><td style="text-align:left">系统警告，出现在应用程序窗口之上</td></tr><tr><td style="text-align:left">TYPE_KEYGUARD=2004</td><td style="text-align:left">锁屏窗口</td></tr><tr><td style="text-align:left">TYPE_TOAST=2005</td><td style="text-align:left">信息窗口，用于显示Toast</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_OVERLAY=2006</td><td style="text-align:left">系统顶层窗口，显示在其他内容之上，此窗口不能获得输入焦点，否则影响锁屏</td></tr><tr><td style="text-align:left">TYPE_PRIORITY_PHONE=2007</td><td style="text-align:left">当锁屏时显示的来电显示窗口</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_DIALOG=2008</td><td style="text-align:left">系统对话框</td></tr><tr><td style="text-align:left">TYPE_KEYGUARD_DIALOG=2009</td><td style="text-align:left">锁屏时显示的对话框</td></tr><tr><td style="text-align:left">TYPE_SYSTEM_ERROR=2010</td><td style="text-align:left">系统内部错误提示</td></tr><tr><td style="text-align:left">TYPE_INPUT_METHOD=2011</td><td style="text-align:left">输入法窗口，显示于普通应用/子窗口之上</td></tr><tr><td style="text-align:left">TYPE_INPUT_METHOD_DIALOG=2012</td><td style="text-align:left">输入法中备选框对应的窗口</td></tr><tr><td style="text-align:left">TYPE_WALLPAPER=2013</td><td style="text-align:left">墙纸窗口</td></tr><tr><td style="text-align:left">TYPE_STATUS_BAR_PANEL=2014</td><td style="text-align:left">滑动状态条后出现的窗口</td></tr><tr><td style="text-align:left">TYPE_SECURE_SYSTEM_OVERLAY=2015</td><td style="text-align:left">安全系统覆盖窗口</td></tr><tr><td style="text-align:left">……</td><td style="text-align:left">……</td></tr><tr><td style="text-align:left">LAST_SYSTEM_WINDOW=2999</td><td style="text-align:left">最后一个系统窗口</td></tr></tbody></table><p>那么，这个type层级到底有什么作用呢？ Window是分层的，每个Window都有对应的z-ordered，（z轴，从1层层叠加到2999，你可以将屏幕想成三维坐标模式）层级大的会覆盖在层级小的Window上面。</p><p>在三类Window中，应用Window的层级范围是1~99。子Window的层级范围是1000~1999，系统Window的层级范围是2000~2999，这些层级范围对应着WindowManager.LayoutParams的type参数。如果想要Window位于所有Window的最顶层，那么采用较大的层级即可。另外有些系统层级的使用是需要声明权限的。</p><h2 id="（二）、Window-Size（大小）和-Window-Position（位置）-计算过程"><a href="#（二）、Window-Size（大小）和-Window-Position（位置）-计算过程" class="headerlink" title="（二）、Window Size（大小）和 Window Position（位置） 计算过程"></a>（二）、Window Size（大小）和 Window Position（位置） 计算过程</h2><p>之前在【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】分析过，当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。为了分析的连贯性，这里重新贴一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals()函数相当复杂，其主要实现以下几个重要步骤：</p><p>1.执行窗口测量；</p><p>2.执行窗口注册；</p><p>3.执行窗口布局；</p><p>4.执行窗口绘图；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ......</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1、-Android-屏幕区域介绍"><a href="#2-1、-Android-屏幕区域介绍" class="headerlink" title="2.1、 Android 屏幕区域介绍"></a>2.1、 Android 屏幕区域介绍</h3><p>首先来看relayoutWindow()。relayoutWindow() 是Window Manager Service 重要工作之一，它的流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/06-Android-WMS-relayoutWindow-flow.png.png" alt="Markdown"></p><p>每个View将期望窗口尺寸交给WMS（WindowManager Service). WMS 将所有的窗口大小以及当前的Overscan区域传给WPM （WindowManager Policy). WPM根据用户配置确定每个Window在最终Display输出上的位置以及需要分配的Surface大小。 返回这些信息给每个View，他们将在给会的区域空间里绘图。 Android里定义了很多区域,如下图所示<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/07-Android-WMS-OverSan-area.png" alt="Markdown"></p><p><strong>Overscan:</strong> Overscan 是电视特有的概念，上图中黄色部分就是Overscan区域，指的是电视机屏幕四周某些不可见的区域（因为电视特性，这部分区域的buffer内容显示时被丢弃），也意味着如果窗口的某些内容画在这个区域里，它在某些电视上就会看不到。为了避免这种情况发生，通常要求UI不要画在屏幕的边角上，而是预留一定的空间。因为Overscan的区域大小随着电视不 同而不同，它一般由终端用户通过UI指定，（比如说GoogleTV里就有确定Overscan大小的应用）。</p><p><strong>OverscanScreen, Screen:</strong> OverscanScreen 是包含Overscan区域的屏幕大小,而Screen则为去除Overscan区域后的屏幕区域, OverscanScreen &gt; Screen.</p><p><strong>Restricted and Unrestricted:</strong> 某些区域是被系统保留的，比如说手机屏幕上方的状态栏(如图纸绿色区域）和下方的导航栏，根据是否包括这些预留的区域，Android把区域分为Unrestricted Area 和 Resctrited Aread, 前者包括这部分预留区域，后者则不包含, Unrestricted area &gt; Rectricted area。</p><p><strong>mFrame, mDisplayFrame, mContainingFrame</strong> Frame指的是一片内存区域, 对应于屏幕上的一块矩形区域. mFrame的大小就是Surface的大小, 如上上图中的蓝色区域. mDisplayFrame 和 mContainingFrame 一般和mFrame 大小一致. mXXX 是Window(ViewRootImpl, Windowstate) 里面定义的成员变量.</p><p><strong>mContentFrame, mVisibleFrame</strong> 一个Surface的所有内容不一定在屏幕上都得到显示, 与Overscan重叠的部分会被截掉, 系统的其他窗口也会遮挡掉部分区域 (比如短信窗口，ContentFrame是800x600(没有Status Bar), 但当输入法窗口弹出是，变成了800x352), 剩下的区域称为Visible Frame, UI内容只有画在这个区域里才能确保可见. 所以也称为Content Frame. mXXX也是Window(ViewRootImpl, WindowState) 里面定义的成员变量.<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/08-Android-WMS-Content-Insets.png" alt="Markdown"></p><p><strong>Insets</strong> insets的定义如上图所示, 用了表示某个Frame的边缘大小.</p><h3 id="2-2、-Window-大小位置计算过程"><a href="#2-2、-Window-大小位置计算过程" class="headerlink" title="2.2、 Window 大小位置计算过程"></a>2.2、 Window 大小位置计算过程</h3><p>在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘制。 一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下Activity窗口的区域是如何划分的。 我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/09-Android-WMS-Content-Visible-Frame.png" alt="Markdown"></p><p>从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。 我们还知道，Activity窗口有时候需要显示输入法窗口，如图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/10-Android-WMS-InputMethod-Content-Frame.png" alt="Markdown"></p><p>这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设Activity窗口的内容区域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, visible-top, visible-right, visible-bottom）来描述，其中，visible-left、visible-right、visible-top、visible-bottom分别用来描述可见区域与窗口区域的左右上下边界距离。</p><p>在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里面的UI元素进行测量、布局以及绘制等操作了。 总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/11-Android-WMS-relayoutWindow-time-diagram.png" alt="Markdown"></p><p>这个过程可以分为13个步骤，接下来我们就详细分析每一个步骤。</p><h3 id="2-2-1、ViewRootImpl-performTraversals"><a href="#2-2-1、ViewRootImpl-performTraversals" class="headerlink" title="2.2.1、ViewRootImpl.performTraversals()"></a>2.2.1、ViewRootImpl.performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cache mView since it is used so much below...</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    ......</span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">    <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line">    ......</span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//第一次被请求执行测量、布局和绘制操作，desiredWindowWidth和desiredWindowHeight等于Display Size，否则mWinFrame保存的宽度和高度值。</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">            Point size = <span class="keyword">new</span> Point();</span><br><span class="line">            mDisplay.getRealSize(size);</span><br><span class="line">            desiredWindowWidth = size.x;</span><br><span class="line">            desiredWindowHeight = size.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">            desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">            desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">true</span>);</span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不是第一次请求，当desiredWindowWidth != mWidth || desiredWindowHeight != mHeight，说明Activity窗口的大小发生了变化，这时候windowSizeMayChange = true，以便接下来对Activity窗口大小变化进行处理</span></span><br><span class="line">        desiredWindowWidth = frame.width();</span><br><span class="line">        desiredWindowHeight = frame.height();</span><br><span class="line">        <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。</p><p>继续阅读代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"><span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line"><span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//AttachInfo对象用来描述Activity窗口的属性,mContentInsets和mVisibleInsets分别用来描述Activity窗口的当前内容边衬大小和可见边衬大小。</span></span><br><span class="line">        <span class="comment">//判断Activity窗口的OverscanInsets、ContentInsets、StableInsets、VisibleInsets大小是否发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">            insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//WRAP_CONTENT表明Activity窗口的大小要等于内容区域的大小，同时等于Display size</span></span><br><span class="line">        <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Configuration config = res.getConfiguration();</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">    <span class="comment">//知道了顶层Activity窗口大小从而计算Activity内各个子View的大小</span></span><br><span class="line">    windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。</p><p>继续阅读代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"> <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">        viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//relayoutWindow来请求WMS计算Activity窗口的大小以及xxxInsets大小，并保存在PendingxxxInsets中</span></span><br><span class="line">        relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (contentInsetsChanged) &#123;</span><br><span class="line">            mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (visibleInsetsChanged) &#123;</span><br><span class="line">            mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop</span></span><br><span class="line">    mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">    mAttachInfo.mWindowTop = frame.top;</span><br><span class="line">    <span class="comment">//将计算得到的Activity窗口的宽度和高度保存在ViewRootImpl类的成员变量mWidth和mHeight中</span></span><br><span class="line">    <span class="keyword">if</span> (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">        mWidth = frame.width();</span><br><span class="line">        mHeight = frame.height();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码主要调用relayoutWindow()来请求WMS计算Activity窗口的大小以及边忖xxxInsets大小。计算完毕之后，分别保存在mPendingXXXInsets中。</p><p>继续阅读代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java::performTraversals()]</span><br><span class="line"> <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                    (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                    || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                    updatedConfiguration) &#123;</span><br><span class="line">                <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line">                ......</span><br><span class="line">                 <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                            MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码用来检查是否需要重新测量Activity窗口的大小。</p><p>经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局 performLayout(lp, mWidth, mHeight)和进行绘画了，performDraw()，由于主要关注Activity窗口大小计算过程，在此不做继续分析。</p><h3 id="2-2-2、ViewRootImpl-relayoutWindow"><a href="#2-2-2、ViewRootImpl-relayoutWindow" class="headerlink" title="2.2.2、ViewRootImpl.relayoutWindow()"></a>2.2.2、ViewRootImpl.relayoutWindow()</h3><p>通过调用这个Session对象的成员函数relayout()来请求WindowManagerService服务计算Activity窗口的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明： 1、mWindow 用来标志要计算的是哪一个Activity窗口的大小p 2、Activity窗口的顶层视图经过测量后得到的宽度和高度 3、Activity窗口的可见状态，即viewVisibility 4、Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending 5、mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大小 6、mPendingOverscanInsets用来保存Overscan边衬，mPendingContentInsets用来保存内容区域边衬，mPendingVisibleInsets用来保存可见区域边衬，mPendingStableInsets用来保存可能被系统UI元素部分或完全遮蔽的全屏窗口区域 7、mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的配置信息 8、mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表面</p><h3 id="2-2-3、Session-relayout"><a href="#2-2-3、Session-relayout" class="headerlink" title="2.2.3、Session.relayout()"></a>2.2.3、Session.relayout()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Session.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算参数window所描述的一个Activity窗品的大小</p><h3 id="2-2-4、WindowManagerService-relayoutWindow"><a href="#2-2-4、WindowManagerService-relayoutWindow" class="headerlink" title="2.2.4、WindowManagerService.relayoutWindow()"></a>2.2.4、WindowManagerService.relayoutWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility != View.GONE) &#123;</span><br><span class="line">            win.setRequestedSize(requestedWidth, requestedHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> (attrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPolicy.adjustWindowParamsLw(attrs);</span><br><span class="line">                ......</span><br><span class="line">        &#125;</span><br><span class="line">        win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            win.adjustStartingWindowFlags();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">        ......</span><br><span class="line">        outFrame.set(win.mCompatFrame);</span><br><span class="line">        outOverscanInsets.set(win.mOverscanInsets);</span><br><span class="line">        outContentInsets.set(win.mContentInsets);</span><br><span class="line">        outVisibleInsets.set(win.mVisibleInsets);</span><br><span class="line">        outStableInsets.set(win.mStableInsets);</span><br><span class="line">        outOutsets.set(win.mOutsets);</span><br><span class="line">        outBackdropFrame.set(win.getBackdropFrame(win.mFrame));</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只关注relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示： 1、参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中 2、WindowState对象win的成员变量mAttrs，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局参数 3、调用WindowSurfacePlacer.performSurfacePlacement()来计算Activity窗口的大小。计算完成之后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets中 4、 将WindowState对象win的成员变量mCompatFrame、mOverscanInsets、mContentInsets、mVisibleInsets、mStableInsets、mOutsets拷贝赋值对应变量中，以便可以返回给应用程序进程</p><p>经过上述4个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowSurfacePlacer.performSurfacePlacement()的实现，以便可以详细了解Activity窗口的大小计算过程</p><h3 id="2-2-5、WindowSurfacePlacer-performSurfacePlacement"><a href="#2-2-5、WindowSurfacePlacer-performSurfacePlacement" class="headerlink" title="2.2.5、WindowSurfacePlacer.performSurfacePlacement()"></a>2.2.5、WindowSurfacePlacer.performSurfacePlacement()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performSurfacePlacement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDeferDepth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> loopCount = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        performSurfacePlacementLoop();</span><br><span class="line">        mService.mH.removeMessages(DO_TRAVERSAL);</span><br><span class="line">        loopCount--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mTraversalScheduled &amp;&amp; loopCount &gt; <span class="number">0</span>);</span><br><span class="line">    mWallpaperActionPending = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop"><a href="#2-2-6-WindowSurfacePlacer-performSurfacePlacementLoop" class="headerlink" title="2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()"></a>2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performSurfacePlacementLoop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       mInLayout = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> recoveringMemory = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mService.mForceRemoves.isEmpty()) &#123;</span><br><span class="line">            recoveringMemory = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!mService.mForceRemoves.isEmpty()) &#123;</span><br><span class="line">                WindowState ws = mService.mForceRemoves.remove(<span class="number">0</span>);</span><br><span class="line">                mService.removeWindowInnerLocked(ws);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        performSurfacePlacementInner(recoveringMemory);</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mService.needsLayout()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++mLayoutRepeatCount &lt; <span class="number">6</span>) &#123;</span><br><span class="line">                requestTraversal();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Performed 6 layouts in a row. Skipping"</span>);</span><br><span class="line">                mLayoutRepeatCount = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mLayoutRepeatCount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123;</span><br><span class="line">            mService.mH.removeMessages(REPORT_WINDOWS_CHANGE);</span><br><span class="line">            mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用成员函数performSurfacePlacementInner()刷新系统UI的前后 1、检查系统中是否存在强制删除的窗口 2、检查系统中是否有窗口需要移除</p><h3 id="2-2-7、WindowSurfacePlacer-performSurfacePlacementInner"><a href="#2-2-7、WindowSurfacePlacer-performSurfacePlacementInner" class="headerlink" title="2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()"></a>2.2.7、WindowSurfacePlacer.performSurfacePlacementInner()</h3><p>继续分析的performSurfacePlacementInner()实现，以便可以了解Activity窗口的大小计算过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performSurfacePlacementInner</span><span class="params">(<span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_WINDOW_TRACE) Slog.v(TAG, <span class="string">"performSurfacePlacementInner: entry. Called by "</span></span><br><span class="line">            + Debug.getCallers(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> DisplayContent defaultDisplay = mService.getDefaultDisplayContentLocked();</span><br><span class="line">    <span class="keyword">final</span> DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultDw = defaultInfo.logicalWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> defaultDh = defaultInfo.logicalHeight;</span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applySurfaceChangesTransaction(recoveringMemory, numDisplays, defaultDw, defaultDh);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Unhandled exception in Window Manager"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowList defaultWindows = defaultDisplay.getWindowList();</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = mService.mPendingRemove.size();</span><br><span class="line">        <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mService.mPendingRemoveTmp.length &lt; N) &#123;</span><br><span class="line">                mService.mPendingRemoveTmp = <span class="keyword">new</span> WindowState[N+<span class="number">10</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            mService.mPendingRemove.toArray(mService.mPendingRemoveTmp);</span><br><span class="line">            mService.mPendingRemove.clear();</span><br><span class="line">            DisplayContentList displayList = <span class="keyword">new</span> DisplayContentList();</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                WindowState w = mService.mPendingRemoveTmp[i];</span><br><span class="line">                mService.removeWindowInnerLocked(w);</span><br><span class="line">                <span class="keyword">final</span> DisplayContent displayContent = w.getDisplayContent();</span><br><span class="line">                <span class="keyword">if</span> (displayContent != <span class="keyword">null</span> &amp;&amp; !displayList.contains(displayContent)) &#123;</span><br><span class="line">                    displayList.add(displayContent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (DisplayContent displayContent : displayList) &#123;</span><br><span class="line">                mService.mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mService.scheduleAnimationLocked();</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到进一步调用applySurfaceChangesTransaction()方法进行进一步计算</p><h3 id="2-2-8、WindowSurfacePlacer-applySurfaceChangesTransaction"><a href="#2-2-8、WindowSurfacePlacer-applySurfaceChangesTransaction" class="headerlink" title="2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()"></a>2.2.8、WindowSurfacePlacer.applySurfaceChangesTransaction()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applySurfaceChangesTransaction</span><span class="params">(<span class="keyword">boolean</span> recoveringMemory, <span class="keyword">int</span> numDisplays,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> defaultDw, <span class="keyword">int</span> defaultDh)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> focusDisplayed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">boolean</span> updateAllDrawn = <span class="keyword">false</span>;</span><br><span class="line">        WindowList windows = displayContent.getWindowList();</span><br><span class="line">        DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> displayId = displayContent.getDisplayId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dw = displayInfo.logicalWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> dh = displayInfo.logicalHeight;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> innerDw = displayInfo.appWidth;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> innerDh = displayInfo.appHeight;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset for each display.</span></span><br><span class="line">        mDisplayHasContent = <span class="keyword">false</span>;</span><br><span class="line">        mPreferredRefreshRate = <span class="number">0</span>;</span><br><span class="line">        mPreferredModeId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> repeats = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            repeats++;</span><br><span class="line">            <span class="keyword">if</span> (repeats &gt; <span class="number">6</span>) &#123;<span class="comment">//最多执行7次的while循环</span></span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通知SurfaceFlinger服务了，也就是让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲区中去</span></span><br><span class="line">            <span class="keyword">if</span> ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_WALLPAPER) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    mWallpaperControllerLocked.adjustWallpaperWindows()) &#123;</span><br><span class="line">                mService.mLayersController.assignLayersLocked(windows);</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">                displayContent.layoutNeeded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIRST LOOP: Perform a layout, if needed.</span></span><br><span class="line">            <span class="comment">//计算各个窗品的大小</span></span><br><span class="line">            <span class="keyword">if</span> (repeats &lt; LAYOUT_REPEAT_THRESHOLD) &#123;</span><br><span class="line">                performLayoutLockedInner(displayContent, repeats == <span class="number">1</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* updateInputWindows */</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think</span></span><br><span class="line">            <span class="comment">// it is animating.</span></span><br><span class="line">            displayContent.pendingLayoutChanges = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">                mService.mPolicy.beginPostLayoutPolicyLw(dw, dh);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = windows.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    WindowState w = windows.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (w.mHasSurface) &#123;</span><br><span class="line">                        mService.mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs,</span><br><span class="line">                                w.mAttachedWindow);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                displayContent.pendingLayoutChanges |=</span><br><span class="line">                        mService.mPolicy.finishPostLayoutPolicyLw();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (displayContent.pendingLayoutChanges != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-9、WindowSurfacePlacer-applySurfaceChangesTransaction"><a href="#2-2-9、WindowSurfacePlacer-applySurfaceChangesTransaction" class="headerlink" title="2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()"></a>2.2.9、WindowSurfacePlacer.applySurfaceChangesTransaction()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfacePlacer.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performLayoutLockedInner</span><span class="params">(<span class="keyword">final</span> DisplayContent displayContent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> initial, <span class="keyword">boolean</span> updateInputWindows)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    displayContent.layoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">    WindowList windows = displayContent.getWindowList();</span><br><span class="line">    <span class="keyword">boolean</span> isDefaultDisplay = displayContent.isDefaultDisplay;</span><br><span class="line"></span><br><span class="line">    DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dw = displayInfo.logicalWidth;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> dh = displayInfo.logicalHeight;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mService.mRotation,</span><br><span class="line">            mService.mCurConfiguration.uiMode);</span><br><span class="line">    ......</span><br><span class="line">    displayContent.resize(mTmpContentRect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> seq = mService.mLayoutSeq+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (seq &lt; <span class="number">0</span>) seq = <span class="number">0</span>;</span><br><span class="line">    mService.mLayoutSeq = seq;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> behindDream = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> topAttached = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = N-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState win = windows.get(i);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> gone = (behindDream &amp;&amp; mService.mPolicy.canBeForceHidden(win, win.mAttrs))</span><br><span class="line">                || win.isGoneForLayoutLw();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!gone || !win.mHaveFrame || win.mLayoutNeeded</span><br><span class="line">                || ((win.isConfigChanged() || win.setReportResizeHints())</span><br><span class="line">                        &amp;&amp; !win.isGoneForLayoutLw() &amp;&amp;</span><br><span class="line">                        ((win.mAttrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != <span class="number">0</span> ||</span><br><span class="line">                        (win.mHasSurface &amp;&amp; win.mAppToken != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        win.mAppToken.layoutConfigChanges)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!win.mLayoutAttached) &#123;</span><br><span class="line">                ......</span><br><span class="line">                win.mLayoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                win.prelayout();</span><br><span class="line">                mService.mPolicy.layoutWindowLw(win, <span class="keyword">null</span>);</span><br><span class="line">                win.mLayoutSeq = seq;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Window frames may have changed. Update dim layer with the new bounds.</span></span><br><span class="line">                <span class="keyword">final</span> Task task = win.getTask();</span><br><span class="line">                <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    displayContent.mDimLayerController.updateDimLayer(task);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> attachedBehindDream = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (i = topAttached; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState win = windows.get(i);</span><br><span class="line">        <span class="keyword">if</span> (win.mLayoutAttached) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled)</span><br><span class="line">                    || !win.mHaveFrame || win.mLayoutNeeded) &#123;</span><br><span class="line">                ......</span><br><span class="line">                win.mLayoutNeeded = <span class="keyword">false</span>;</span><br><span class="line">                win.prelayout();</span><br><span class="line">                mService.mPolicy.layoutWindowLw(win, win.mAttachedWindow);</span><br><span class="line">                win.mLayoutSeq = seq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (win.mAttrs.type == TYPE_DREAM) &#123;</span><br><span class="line">            attachedBehindDream = behindDream;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Window frames may have changed. Tell the input dispatcher about it.</span></span><br><span class="line">    mService.mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line">    <span class="keyword">if</span> (updateInputWindows) &#123;</span><br><span class="line">        mService.mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.mPolicy.finishLayoutLw();</span><br><span class="line">    mService.mH.sendEmptyMessage(UPDATE_DOCKED_STACK_DIVIDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、mPolicy指向的是一个窗口管理策略类，即PhoneWindowManager对象，主要是用来制定窗口的大小计算策略 2、准备阶段：调用PhoneWindowManager.beginLayoutLw()来设置屏幕的大小。包括NavigationBar、StatusBar大小计算 3、计算阶段：调用PhoneWindowManager.layoutWindowLw()来计算各个窗口的大小、内容区域边衬大小以及可见区域边衬大小。 4、结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw()来执行一些清理工作。</p><h3 id="2-2-10、PhoneWindowManager-beginLayoutLw"><a href="#2-2-10、PhoneWindowManager-beginLayoutLw" class="headerlink" title="2.2.10、PhoneWindowManager.beginLayoutLw()"></a>2.2.10、PhoneWindowManager.beginLayoutLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginLayoutLw</span><span class="params">(<span class="keyword">boolean</span> isDefaultDisplay, <span class="keyword">int</span> displayWidth, <span class="keyword">int</span> displayHeight,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> displayRotation, <span class="keyword">int</span> uiMode)</span> </span>&#123;</span><br><span class="line">    mDisplayRotation = displayRotation;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> overscanLeft, overscanTop, overscanRight, overscanBottom;</span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (displayRotation) &#123;</span><br><span class="line">            <span class="keyword">case</span> Surface.ROTATION_90:</span><br><span class="line">                overscanLeft = mOverscanTop;</span><br><span class="line">                overscanTop = mOverscanRight;</span><br><span class="line">                overscanRight = mOverscanBottom;</span><br><span class="line">                overscanBottom = mOverscanLeft;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        overscanLeft = <span class="number">0</span>;</span><br><span class="line">        overscanTop = <span class="number">0</span>;</span><br><span class="line">        overscanRight = <span class="number">0</span>;</span><br><span class="line">        overscanBottom = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mOverscanScreenLeft = mRestrictedOverscanScreenLeft = <span class="number">0</span>;</span><br><span class="line">    mOverscanScreenTop = mRestrictedOverscanScreenTop = <span class="number">0</span>;</span><br><span class="line">    mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth;</span><br><span class="line">    mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight;</span><br><span class="line">    mSystemLeft = <span class="number">0</span>;</span><br><span class="line">    mSystemTop = <span class="number">0</span>;</span><br><span class="line">    mSystemRight = displayWidth;</span><br><span class="line">    mSystemBottom = displayHeight;</span><br><span class="line">    mUnrestrictedScreenLeft = overscanLeft;</span><br><span class="line">    mUnrestrictedScreenTop = overscanTop;</span><br><span class="line">    mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight;</span><br><span class="line">    mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom;</span><br><span class="line">    mRestrictedScreenLeft = mUnrestrictedScreenLeft;</span><br><span class="line">    mRestrictedScreenTop = mUnrestrictedScreenTop;</span><br><span class="line">    mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth;</span><br><span class="line">    mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight;</span><br><span class="line">    mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft</span><br><span class="line">            = mCurLeft = mUnrestrictedScreenLeft;</span><br><span class="line">    mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop</span><br><span class="line">            = mCurTop = mUnrestrictedScreenTop;</span><br><span class="line">    mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight</span><br><span class="line">            = mCurRight = displayWidth - overscanRight;</span><br><span class="line">    mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom</span><br><span class="line">            = mCurBottom = displayHeight - overscanBottom;</span><br><span class="line">    mDockLayer = <span class="number">0x10000000</span>;</span><br><span class="line">    mStatusBarLayer = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start with the current dock rect, which will be (0,0,displayWidth,displayHeight)</span></span><br><span class="line">    <span class="keyword">final</span> Rect pf = mTmpParentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect df = mTmpDisplayFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect of = mTmpOverscanFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect vf = mTmpVisibleFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect dcf = mTmpDecorFrame;</span><br><span class="line">    pf.left = df.left = of.left = vf.left = mDockLeft;</span><br><span class="line">    pf.top = df.top = of.top = vf.top = mDockTop;</span><br><span class="line">    pf.right = df.right = of.right = vf.right = mDockRight;</span><br><span class="line">    pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom;</span><br><span class="line">    dcf.setEmpty();  <span class="comment">// Decor frame N/A for system bars.</span></span><br><span class="line">        .......</span><br><span class="line">        <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        navVisible |= !canHideNavigationBar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight,</span><br><span class="line">                displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent,navAllowedHidden, statusBarExpandedNotKeyguard);</span><br><span class="line">        updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (updateSysUiVisibility) &#123;</span><br><span class="line">            updateSystemUiVisibilityLw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、初始化Overscan、UnrestrictedScreen、RestrictedScreen等屏幕区域变量 2、计算NavigationBar和StatusBar大小</p><h3 id="2-2-11、PhoneWindowManager-layoutWindowLw"><a href="#2-2-11、PhoneWindowManager-layoutWindowLw" class="headerlink" title="2.2.11、PhoneWindowManager.layoutWindowLw()"></a>2.2.11、PhoneWindowManager.layoutWindowLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layoutWindowLw</span><span class="params">(WindowState win, WindowState attached)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fl = PolicyControl.getWindowFlags(win, attrs);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pfl = attrs.privateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sim = attrs.softInputMode;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> sysUiFl = PolicyControl.getSystemUiVisibility(win, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Rect pf = mTmpParentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect df = mTmpDisplayFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect of = mTmpOverscanFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect cf = mTmpContentFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect vf = mTmpVisibleFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect dcf = mTmpDecorFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect sf = mTmpStableFrame;</span><br><span class="line">    Rect osf = <span class="keyword">null</span>;</span><br><span class="line">    dcf.setEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasNavBar = (isDefaultDisplay &amp;&amp; mHasNavigationBar</span><br><span class="line">            &amp;&amp; mNavigationBar != <span class="keyword">null</span> &amp;&amp; mNavigationBar.isVisibleLw());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> adjust = sim &amp; SOFT_INPUT_MASK_ADJUST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDefaultDisplay) &#123;</span><br><span class="line">        sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isDefaultDisplay) &#123;</span><br><span class="line">        <span class="keyword">if</span> (attached != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If this window is attached to another, our display</span></span><br><span class="line">            <span class="comment">// frame is the same as the one we are attached to.</span></span><br><span class="line">            setAttachedWindowFrames(win, fl, adjust, attached, <span class="keyword">true</span>, pf, df, of, cf, vf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Give the window full screen.</span></span><br><span class="line">            pf.left = df.left = of.left = cf.left = mOverscanScreenLeft;</span><br><span class="line">            pf.top = df.top = of.top = cf.top = mOverscanScreenTop;</span><br><span class="line">            pf.right = df.right = of.right = cf.right</span><br><span class="line">                    = mOverscanScreenLeft + mOverscanScreenWidth;</span><br><span class="line">            pf.bottom = df.bottom = of.bottom = cf.bottom</span><br><span class="line">                    = mOverscanScreenTop + mOverscanScreenHeight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用WindowState.computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。</p><h3 id="2-2-12、WindowState-computeFrameLw"><a href="#2-2-12、WindowState-computeFrameLw" class="headerlink" title="2.2.12、WindowState.computeFrameLw()"></a>2.2.12、WindowState.computeFrameLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowState.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeFrameLw</span><span class="params">(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf, Rect sf,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect osf)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Task task = getTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullscreenTask = !isInMultiWindowMode();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> windowsAreFloating = task != <span class="keyword">null</span> &amp;&amp; task.isFloating();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> Rect layoutContainingFrame;</span><br><span class="line">    <span class="keyword">final</span> Rect layoutDisplayFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The offset from the layout containing frame to the actual containing frame.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutXDiff;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> layoutYDiff;</span><br><span class="line">    <span class="keyword">if</span> (fullscreenTask || layoutInParentFrame()) &#123;</span><br><span class="line">        <span class="comment">// We use the parent frame as the containing frame for fullscreen and child windows</span></span><br><span class="line">        mContainingFrame.set(pf);</span><br><span class="line">        mDisplayFrame.set(df);</span><br><span class="line">        layoutDisplayFrame = df;</span><br><span class="line">        layoutContainingFrame = pf;</span><br><span class="line">        layoutXDiff = <span class="number">0</span>;</span><br><span class="line">        layoutYDiff = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        task.getBounds(mContainingFrame);</span><br><span class="line">        ......</span><br><span class="line">        mDisplayFrame.set(mContainingFrame);</span><br><span class="line">        layoutXDiff = !mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : <span class="number">0</span>;</span><br><span class="line">        layoutYDiff = !mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : <span class="number">0</span>;</span><br><span class="line">        layoutContainingFrame = !mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame;</span><br><span class="line">        mTmpRect.set(<span class="number">0</span>, <span class="number">0</span>, mDisplayContent.getDisplayInfo().logicalWidth,</span><br><span class="line">                mDisplayContent.getDisplayInfo().logicalHeight);</span><br><span class="line">        subtractInsets(mDisplayFrame, layoutContainingFrame, df, mTmpRect);</span><br><span class="line">        ......</span><br><span class="line">        layoutDisplayFrame = df;</span><br><span class="line">        layoutDisplayFrame.intersect(layoutContainingFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pw = mContainingFrame.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> ph = mContainingFrame.height();</span><br><span class="line">    ......</span><br><span class="line">    mOverscanFrame.set(of);</span><br><span class="line">    mContentFrame.set(cf);</span><br><span class="line">    mVisibleFrame.set(vf);</span><br><span class="line">    mDecorFrame.set(dcf);</span><br><span class="line">    mStableFrame.set(sf);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasOutsets = osf != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fw = mFrame.width();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fh = mFrame.height();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (windowsAreFloating &amp;&amp; !mFrame.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> height = Math.min(mFrame.height(), mContentFrame.height());</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> width = Math.min(mContentFrame.width(), mFrame.width());</span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics displayMetrics = getDisplayContent().getDisplayMetrics();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minVisibleHeight = Math.min(height, WindowManagerService.dipToPixel(</span><br><span class="line">                MINIMUM_VISIBLE_HEIGHT_IN_DP, displayMetrics));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minVisibleWidth = Math.min(width, WindowManagerService.dipToPixel(</span><br><span class="line">                MINIMUM_VISIBLE_WIDTH_IN_DP, displayMetrics));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = Math.max(mContentFrame.top,</span><br><span class="line">                Math.min(mFrame.top, mContentFrame.bottom - minVisibleHeight));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = Math.max(mContentFrame.left + minVisibleWidth - width,</span><br><span class="line">                Math.min(mFrame.left, mContentFrame.right - minVisibleWidth));</span><br><span class="line">        mFrame.set(left, top, left + width, top + height);</span><br><span class="line">        mContentFrame.set(mFrame);</span><br><span class="line">        mVisibleFrame.set(mContentFrame);</span><br><span class="line">        mStableFrame.set(mContentFrame);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">        mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame);</span><br><span class="line">        mContentFrame.set(mFrame);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mContentFrame.set(......);</span><br><span class="line"></span><br><span class="line">        mVisibleFrame.set(......);</span><br><span class="line"></span><br><span class="line">        mStableFrame.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fullscreenTask &amp;&amp; !windowsAreFloating) &#123;</span><br><span class="line">        <span class="comment">// Windows that are not fullscreen can be positioned outside of the display frame,</span></span><br><span class="line">        mOverscanInsets.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAttrs.type == TYPE_DOCK_DIVIDER) &#123;</span><br><span class="line">        mStableInsets.set(......);</span><br><span class="line">        mContentInsets.setEmpty();</span><br><span class="line">        mVisibleInsets.setEmpty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        getDisplayContent().getLogicalDisplayRect(mTmpRect);</span><br><span class="line">        <span class="keyword">boolean</span> overrideRightInset = !fullscreenTask &amp;&amp; mFrame.right &gt; mTmpRect.right;</span><br><span class="line">        <span class="keyword">boolean</span> overrideBottomInset = !fullscreenTask &amp;&amp; mFrame.bottom &gt; mTmpRect.bottom;</span><br><span class="line">        mContentInsets.set(......);</span><br><span class="line"></span><br><span class="line">        mVisibleInsets.set(......);</span><br><span class="line"></span><br><span class="line">        mStableInsets.set(......);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Offset the actual frame by the amount layout frame is off.</span></span><br><span class="line">    mFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mCompatFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mContentFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mVisibleFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line">    mStableFrame.offset(-layoutXDiff, -layoutYDiff);</span><br><span class="line"></span><br><span class="line">    mCompatFrame.set(mFrame);</span><br><span class="line">    <span class="keyword">if</span> (mEnforceSizeCompat) &#123;</span><br><span class="line">        mOverscanInsets.scale(mInvGlobalScale);</span><br><span class="line">        mContentInsets.scale(mInvGlobalScale);</span><br><span class="line">        mVisibleInsets.scale(mInvGlobalScale);</span><br><span class="line">        mStableInsets.scale(mInvGlobalScale);</span><br><span class="line">        mOutsets.scale(mInvGlobalScale);</span><br><span class="line">        mCompatFrame.scale(mInvGlobalScale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个窗口大小保存在WindowState类的成员变量mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中</p><h3 id="2-2-13、PhoneWindowManager-finishLayoutLw"><a href="#2-2-13、PhoneWindowManager-finishLayoutLw" class="headerlink" title="2.2.13、PhoneWindowManager.finishLayoutLw()"></a>2.2.13、PhoneWindowManager.finishLayoutLw()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[WindowState.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishLayoutLw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）、Window-Z-Order-计算和调整过程"><a href="#（三）、Window-Z-Order-计算和调整过程" class="headerlink" title="（三）、Window Z-Order 计算和调整过程"></a>（三）、Window Z-Order 计算和调整过程</h2><p>口的UI最终是需要通过SurfaceFlinger服务来统一渲染的，而SurfaceFlinger服务在渲染窗口的UI之前，需要计算基于各个窗口的Z轴位置来计算它们的可见区域。因此，WindowManagerService服务计算好每一个窗口的Z轴位置之后，还需要将它们设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以正确地渲染每一个窗口的UI。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/12-Android-WMS-Z-Order.png" alt="Markdown"></p><h3 id="3-1、需要重新计算窗口Z轴位置的情景"><a href="#3-1、需要重新计算窗口Z轴位置的情景" class="headerlink" title="3.1、需要重新计算窗口Z轴位置的情景"></a>3.1、需要重新计算窗口Z轴位置的情景</h3><p>在【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】中已经详细介绍Window添加过程，这里直接从 WMS.addWindow开始分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">        AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> imMayMove = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">            win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">            mInputMethodWindow = win;</span><br><span class="line">            addInputMethodWindowToListLocked(win);</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">            mInputMethodDialogs.add(win);</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(<span class="keyword">true</span>));</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//重新计算系统中所有窗口的Z轴位置</span></span><br><span class="line">        mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WMS.relayoutWindow()也会调用WindowLayersController.assignLayersLocked()重新计算、调整系统中所有窗口的Z轴位置，由于原理类似这里不做解释。</p><h3 id="3-2、计算系统中所有窗口的Z轴位置"><a href="#3-2、计算系统中所有窗口的Z轴位置" class="headerlink" title="3.2、计算系统中所有窗口的Z轴位置"></a>3.2、计算系统中所有窗口的Z轴位置</h3><p>接下来我们就通过WindowState类的构造函数来分析一个窗口的BaseLayer值是如何确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[WindowState.java]</span><br><span class="line">WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token,</span><br><span class="line">       WindowState attachedWindow, <span class="keyword">int</span> appOp, <span class="keyword">int</span> seq, WindowManager.LayoutParams a,</span><br><span class="line">       <span class="keyword">int</span> viewVisibility, <span class="keyword">final</span> DisplayContent displayContent) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">            mAttrs.type &lt;= LAST_SUB_WINDOW)) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//windowTypeToLayerLw的返回值并且不是一个窗口的最终的BaseLayer值，而是要将它的返回值乘以一个常量TYPE_LAYER_MULTIPLIER，再加上另外一个常量TYPE_LAYER_OFFSET之后，才得到最终的BaseLayer值</span></span><br><span class="line">        mBaseLayer = mPolicy.windowTypeToLayerLw(</span><br><span class="line">                attachedWindow.mAttrs.type) * WindowManagerService.TYPE_LAYER_MULTIPLIER</span><br><span class="line">                + WindowManagerService.TYPE_LAYER_OFFSET;</span><br><span class="line">        mSubLayer = mPolicy.subWindowTypeToLayerLw(a.type);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个窗口除了有一个BaseLayer值之外，还有一个SubLayer值，分别保存在一个对应的WindowState对象的成员变量mBaseLayer和mSubLayer。SubLayer值是用来描述一个窗口是否是另外一个窗口的子窗口的。 在继续分析WindowLayersController.assignLayersLocked()之前，我们首先分析PhoneWindowManager.windowTypeToLayerLw()和subWindowTypeToLayerLw()的实现，以便可以了解一个窗口的BaseLayer值和SubLayer值是如何确定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">windowTypeToLayerLw</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_SYSTEM_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_TOAST:</span><br><span class="line">        <span class="comment">// toasts and the plugged-in battery thing</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_SYSTEM_ALERT:</span><br><span class="line">        <span class="comment">// like the ANR / app crashed dialogs</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR_SUB_PANEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_STATUS_BAR_PANEL:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">17</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_KEYGUARD_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_NAVIGATION_BAR:</span><br><span class="line">        <span class="comment">// the navigation bar, if available, shows atop most things</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    <span class="keyword">case</span> TYPE_NAVIGATION_BAR_PANEL:</span><br><span class="line">        <span class="comment">// some panels (e.g. search) need to show on top of the navigation bar</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">22</span>;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** &#123;<span class="doctag">@inheritDoc</span>&#125; */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subWindowTypeToLayerLw</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_PANEL:</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_ATTACHED_DIALOG:</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_PANEL_SUBLAYER;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> TYPE_APPLICATION_ABOVE_SUB_PANEL:</span><br><span class="line">        <span class="keyword">return</span> APPLICATION_ABOVE_SUB_PANEL_SUBLAYER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要根据不同的Window Type返回不一样的数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LAYER_MULTIPLIER = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LAYER_OFFSET = <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>我们可以用adb shell dumpsys window -a 命令查看一下Layer的数值，可以看到StatusBar的数值计算： mBaseLayer = 16 _WindowManagerService.TYPE_LAYER_MULTIPLIER+ WindowManagerService.TYPE_LAYER<em>OFFSET StatusBar.mBaseLayer = 16</em> 10000 + 1000 = 161000 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Window #4 Window&#123;3c1f1fb u0 StatusBar&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">161000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">161000</span>+<span class="number">0</span>=<span class="number">161000</span> mLastLayer=<span class="number">161000</span></span><br><span class="line">Window #3 Window&#123;fe4aae2 u0 KeyguardScrim&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">141000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">141000</span>+<span class="number">0</span>=<span class="number">141000</span> mLastLayer=<span class="number">141000</span></span><br><span class="line">Window #2 Window&#123;173ee76 u0 DockedStackDivider&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21010</span>+<span class="number">0</span>=<span class="number">21010</span> mLastLayer=<span class="number">0</span></span><br><span class="line">Window #1 Window&#123;3a83a4a u0 com.android.launcher&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21005</span>+<span class="number">0</span>=<span class="number">21005</span> mLastLayer=<span class="number">21005</span></span><br><span class="line">Window #0 Window&#123;aefb7bc u0 com.android.systemui.ImageWallpaper&#125;:</span><br><span class="line">  mBaseLayer=<span class="number">21000</span> mSubLayer=<span class="number">0</span> mAnimLayer=<span class="number">21000</span>+<span class="number">0</span>=<span class="number">21000</span> mLastLayer=<span class="number">21000</span></span><br></pre></td></tr></table></figure><p>理解了窗口的BaseLayer值和SubLayer值的计算过程之外，接下来我们就可以分析WindowManagerService类的成员函数assignLayersLocked()的实现了</p><h3 id="3-2-1、WindowLayersController-assignLayersLocked"><a href="#3-2-1、WindowLayersController-assignLayersLocked" class="headerlink" title="3.2.1、WindowLayersController.assignLayersLocked()"></a>3.2.1、WindowLayersController.assignLayersLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowLayersController.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">assignLayersLocked</span><span class="params">(WindowList windows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_LAYERS) Slog.v(TAG_WM, <span class="string">"Assigning layers based on windows="</span> + windows,</span><br><span class="line">            <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line">    clear();</span><br><span class="line">    <span class="keyword">int</span> curBaseLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curLayer = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> anyLayerChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, windowCount = windows.size(); i &lt; windowCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState w = windows.get(i);</span><br><span class="line">        <span class="keyword">boolean</span> layerChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> oldLayer = w.mLayer;</span><br><span class="line">        <span class="keyword">if</span> (w.mBaseLayer == curBaseLayer || w.mIsImWindow || (i &gt; <span class="number">0</span> &amp;&amp; w.mIsWallpaper)) &#123;</span><br><span class="line">            curLayer += WINDOW_LAYER_MULTIPLIER;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curBaseLayer = curLayer = w.mBaseLayer;</span><br><span class="line">        &#125;</span><br><span class="line">        assignAnimLayer(w, curLayer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Preserved old behavior of code here but not sure comparing</span></span><br><span class="line">        <span class="comment">// oldLayer to mAnimLayer and mLayer makes sense...though the</span></span><br><span class="line">        <span class="comment">// worst case would be unintentionalp layer reassignment.</span></span><br><span class="line">        <span class="keyword">if</span> (w.mLayer != oldLayer || w.mWinAnimator.mAnimLayer != oldLayer) &#123;</span><br><span class="line">            layerChanged = <span class="keyword">true</span>;</span><br><span class="line">            anyLayerChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mHighestApplicationLayer = Math.max(mHighestApplicationLayer,</span><br><span class="line">                    w.mWinAnimator.mAnimLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        collectSpecialWindows(w);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (layerChanged) &#123;</span><br><span class="line">            w.scheduleAnimationIfDimming();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    adjustSpecialWindows();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 assignAnimLayer() 进行Layer调整：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowLayersController.java]</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assignAnimLayer</span><span class="params">(WindowState w, <span class="keyword">int</span> layer)</span> </span>&#123;</span><br><span class="line">        w.mLayer = layer;</span><br><span class="line">        w.mWinAnimator.mAnimLayer = w.mLayer + w.getAnimLayerAdjustment() +</span><br><span class="line">                    getSpecialWindowAnimLayerAdjustment(w);</span><br><span class="line">        <span class="keyword">if</span> (w.mAppToken != <span class="keyword">null</span> &amp;&amp; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; w.mWinAnimator.mAnimLayer &gt; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer) &#123;</span><br><span class="line">            w.mAppToken.mAppAnimator.thumbnailForceAboveLayer = w.mWinAnimator.mAnimLayer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、设置窗口的Z轴位置到SurfaceFlinger服务中去"><a href="#3-3、设置窗口的Z轴位置到SurfaceFlinger服务中去" class="headerlink" title="3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去"></a>3.3、设置窗口的Z轴位置到SurfaceFlinger服务中去</h3><p>WindowManagerService服务在刷新系统的UI的时候，就会将系统中已经计算好了的窗口Z轴位置设置到SurfaceFlinger服务中去，以便SurfaceFlinger服务可以对系统中的窗口进行可见性计算以及合成和渲染等操作 首先看一下堆栈信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WindowSurfaceController.showSurface()添加打印Log</span><br><span class="line">Slog.i(<span class="string">"zhoujinjian"</span>, <span class="string">"zhoujinjian"</span>,<span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>): zhoujinjian</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>): java.lang.RuntimeException: here</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.showSurface(WindowSurfaceController.java:<span class="number">414</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.updateVisibility(WindowSurfaceController.java:<span class="number">402</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowSurfaceController.showRobustlyInTransaction(WindowSurfaceController.java:<span class="number">391</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowStateAnimator.showSurfaceRobustlyLocked(WindowStateAnimator.java:<span class="number">1814</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowStateAnimator.prepareSurfaceLocked(WindowStateAnimator.java:<span class="number">1609</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator.animateLocked(WindowAnimator.java:<span class="number">791</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator.-wrap0(WindowAnimator.java)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.wm.WindowAnimator$<span class="number">1.</span>doFrame(WindowAnimator.java:<span class="number">166</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer$CallbackRecord.run(Choreographer.java:<span class="number">879</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer.doCallbacks(Choreographer.java:<span class="number">693</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer.doFrame(Choreographer.java:<span class="number">625</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:<span class="number">867</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.Handler.handleCallback(Handler.java:<span class="number">751</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.Handler.dispatchMessage(Handler.java:<span class="number">95</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.Looper.loop(Looper.java:<span class="number">154</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at android.os.HandlerThread.run(HandlerThread.java:<span class="number">61</span>)</span><br><span class="line"><span class="number">03</span><span class="number">-01</span> <span class="number">19</span>:<span class="number">06</span>:<span class="number">45.229</span>: I/zhoujinjian(<span class="number">1424</span>):     at com.android.server.ServiceThread.run(ServiceThread.java:<span class="number">46</span>)</span><br></pre></td></tr></table></figure><p>为了了解WMS是如何将Z轴位置设置到SurfaceFlinger服务中去，首先看一下WMS构造方法中关键对象WindowAnimator的创建</p><h3 id="3-3-1、Vsync刷新UI回调过程"><a href="#3-3-1、Vsync刷新UI回调过程" class="headerlink" title="3.3.1、Vsync刷新UI回调过程"></a>3.3.1、Vsync刷新UI回调过程</h3><p>开机启动时会初始化WMS。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">WindowManagerService</span><span class="params">(Context context, InputManagerService inputManager,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> haveInputMethods, <span class="keyword">boolean</span> showBootMsgs, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mAnimator = <span class="keyword">new</span> WindowAnimator(<span class="keyword">this</span>);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用WindowAnimator构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line">WindowAnimator(<span class="keyword">final</span> WindowManagerService service) &#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mContext = service.mContext;</span><br><span class="line">    mPolicy = service.mPolicy;</span><br><span class="line">    mWindowPlacerLocked = service.mWindowPlacerLocked;</span><br><span class="line"></span><br><span class="line">    mAnimationFrameCallback = <span class="keyword">new</span> Choreographer.FrameCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mWindowMap) &#123;</span><br><span class="line">                mService.mAnimationScheduled = <span class="keyword">false</span>;</span><br><span class="line">                animateLocked(frameTimeNs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到创建了Choreographer.FrameCallback()，前面在【Android-7-1-2-Android-N-Activity-Window加载显示流程】分析过，FrameDisplayEventReceiver（在Choreographer构造方法中初始化）对象用于请求并接收Vsync信号，当Vsync信号到来时，系统会自动调用其onVsync()函数，后面会回调到FrameDisplayEventReceiver.run()方法，再回调函数中执行doFrame()实现屏幕刷新，doFrame()会顺序执行CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL 和CALLBACK_COMMIT 对应CallbackQueue队列中注册的回调，从而会执行CallbackRecord.run()，在执行其回调函数时，就需要区别这两种对象类型，如果注册的是Runnable对象，则调用其run()函数，如果注册的是FrameCallback对象，则调用它的doFrame()函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Choreographer.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此种情况下会执行FrameCallback对象的doFrame()函数（原因稍后再分析动画时详细分析），由WindowAnimator构造函数中可知接着就会执行WindowAnimator.animateLocked()</p><h3 id="3-3-2、准备刷新UI"><a href="#3-3-2、准备刷新UI" class="headerlink" title="3.3.2、准备刷新UI"></a>3.3.2、准备刷新UI</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateLocked</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG, <span class="string">"&gt;&gt;&gt; OPEN TRANSACTION animateLocked"</span>);</span><br><span class="line">        SurfaceControl.openTransaction();</span><br><span class="line">        SurfaceControl.setAnimationTransaction();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mDisplayContentsAnimators.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line">                updateAppWindowsLocked(displayId);</span><br><span class="line">                DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i);</span><br><span class="line">                ......</span><br><span class="line">                updateWindowsLocked(displayId);</span><br><span class="line">                updateWallpaperLocked(displayId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">                <span class="comment">//通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                    windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            SurfaceControl.closeTransaction();</span><br><span class="line">            <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                    TAG, <span class="string">"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取windows列表，然后循环调用windows.get(j).mWinAnimator.prepareSurfaceLocked(true)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepareSurfaceLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> recoveringMemory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WindowState w = mWin;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> displayed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line">    computeShownFrameLocked();</span><br><span class="line"></span><br><span class="line">    setSurfaceBoundariesLocked(recoveringMemory);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWallpaper &amp;&amp; !mWin.mWallpaperVisible) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.mAttachedHidden || !w.isOnScreen()) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLastLayer != mAnimLayer</span><br><span class="line">            || mLastAlpha != mShownAlpha</span><br><span class="line">            || mLastDsDx != mDsDx</span><br><span class="line">            || mLastDtDx != mDtDx</span><br><span class="line">            || mLastDsDy != mDsDy</span><br><span class="line">            || mLastDtDy != mDtDy</span><br><span class="line">            || w.mLastHScale != w.mHScale</span><br><span class="line">            || w.mLastVScale != w.mVScale</span><br><span class="line">            || mLastHidden) &#123;</span><br><span class="line">        displayed = <span class="keyword">true</span>;</span><br><span class="line">        mLastAlpha = mShownAlpha;</span><br><span class="line">        mLastLayer = mAnimLayer;</span><br><span class="line">        mLastDsDx = mDsDx;</span><br><span class="line">        mLastDtDx = mDtDx;</span><br><span class="line">        mLastDsDy = mDsDy;</span><br><span class="line">        mLastDtDy = mDtDy;</span><br><span class="line">        w.mLastHScale = w.mHScale;</span><br><span class="line">        w.mLastVScale = w.mVScale;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">boolean</span> prepared =</span><br><span class="line">            mSurfaceController.prepareToShowInTransaction(mShownAlpha, mAnimLayer,</span><br><span class="line">                    mDsDx * w.mHScale * mExtraHScale,</span><br><span class="line">                    mDtDx * w.mVScale * mExtraVScale,</span><br><span class="line">                    mDsDy * w.mHScale * mExtraHScale,</span><br><span class="line">                    mDtDy * w.mVScale * mExtraVScale,</span><br><span class="line">                    recoveringMemory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (showSurfaceRobustlyLocked()) &#123;</span><br><span class="line">                markPreservedSurfaceForDestroy();</span><br><span class="line">                mAnimator.requestRemovalOfReplacedWindows(w);</span><br><span class="line">                mLastHidden = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (mIsWallpaper) &#123;</span><br><span class="line">                    mWallpaperControllerLocked.dispatchWallpaperVisibility(w, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                mAnimator.setPendingLayoutChanges(w.getDisplayId(),</span><br><span class="line">                        WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                w.mOrientationChanging = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasSurface()) &#123;</span><br><span class="line">            w.mToken.hasVisible = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        displayed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用prepareToShowInTransaction()将alph、alayer、setMatrix设置到mSurfaceControl中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">boolean prepareToShowInTransaction(float alpha, int layer, float dsdx, float dtdx, float dsdy,</span><br><span class="line">           float dtdy, boolean recoveringMemory) &#123;</span><br><span class="line">       if (mSurfaceControl != null) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               mSurfaceAlpha = alpha;</span><br><span class="line">               mSurfaceControl.setAlpha(alpha);</span><br><span class="line">               mSurfaceLayer = layer;</span><br><span class="line">               mSurfaceControl.setLayer(layer);</span><br><span class="line">               mSurfaceControl.setMatrix(</span><br><span class="line">                       dsdx, dtdx, dsdy, dtdy);</span><br><span class="line"></span><br><span class="line">           &#125; catch (RuntimeException e) &#123;</span><br><span class="line">               .......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>setSurfaceBoundariesLocked()方法中会调用SurfaceControl.setPosition()等等方法将计算好的数值设置到mSurfaceControl中。 说明：一个窗口的显示和隐藏，以及大小、X轴和Y轴位置、Z轴位置、Alpha通道和变换矩阵设置，是通过调用Java层的SurfaceControl类的成员函数show、hide、setSize、setPosition、setLayer、setAlpha和setMatrix来实现的，它们最终都是通过调用JNI方法实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SurfaceControl.java</span><br><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(<span class="keyword">float</span> alpha)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetAlpha(mNativeObject, alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMatrix</span><span class="params">(<span class="keyword">float</span> dsdx, <span class="keyword">float</span> dtdx, <span class="keyword">float</span> dsdy, <span class="keyword">float</span> dtdy)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetMatrix(mNativeObject, dsdx, dtdx, dsdy, dtdy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindowCrop</span><span class="params">(Rect crop)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    <span class="keyword">if</span> (crop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nativeSetWindowCrop(mNativeObject,</span><br><span class="line">            crop.left, crop.top, crop.right, crop.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeSetWindowCrop(mNativeObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFinalCrop</span><span class="params">(Rect crop)</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    <span class="keyword">if</span> (crop != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nativeSetFinalCrop(mNativeObject,</span><br><span class="line">            crop.left, crop.top, crop.right, crop.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeSetFinalCrop(mNativeObject, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="3-3-3、告知SurfaceFlinger显示UI"><a href="#3-3-3、告知SurfaceFlinger显示UI" class="headerlink" title="3.3.3、告知SurfaceFlinger显示UI"></a>3.3.3、告知SurfaceFlinger显示UI</h3><p>如果WindowState对象w所描述的窗口满足条件：prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN 那么就说明现在是时候要将WindowState对象w所描述的窗口显示出来了，通过调用showSurfaceRobustlyLocked实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">showSurfaceRobustlyLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Task task = mWin.getTask();</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span> &amp;&amp; StackId.windowsAreScaleable(task.mStack.mStackId)) &#123;</span><br><span class="line">        mSurfaceController.forceScaleableInTransaction(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> shown = mSurfaceController.showRobustlyInTransaction();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mWin.mTurnOnScreen) &#123;</span><br><span class="line">        ......</span><br><span class="line">        mWin.mTurnOnScreen = <span class="keyword">false</span>;</span><br><span class="line">        mAnimator.mBulkUpdateParams |= SET_TURN_ON_SCREEN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用WindowSurfaceController.showRobustlyInTransaction() –&gt; updateVisibility()–&gt;showSurface()-&gt;SurfaceControl.show()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowSurfaceController.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">showRobustlyInTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        mHiddenForOtherReasons = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> updateVisibility();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mHiddenForCrop || mHiddenForOtherReasons) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mSurfaceShown) &#123;hideSurface();&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mSurfaceShown) &#123;<span class="keyword">return</span> showSurface();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">showSurface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mSurfaceShown = <span class="keyword">true</span>;</span><br><span class="line">            mSurfaceControl.show();</span><br><span class="line">             Slog.i(<span class="string">"zhoujinjian"</span>, <span class="string">"zhoujinjian"</span>,<span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现异常,回收系统内存资源</span></span><br><span class="line">        mAnimator.reclaimSomeSurfaceMemory(<span class="string">"show"</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceControl.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkNotReleased();</span><br><span class="line">    nativeSetFlags(mNativeObject, <span class="number">0</span>, SURFACE_HIDDEN);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过JNI调用android_view_SurfaceControl.cpp的nativeSetFlags函数，可以看到flags == 0；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;android_view_SurfaceControl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFlags</span><span class="params">(JNIEnv* env, jclass clazz, jlong nativeObject, jint flags, jint mask)</span> </span>&#123;</span><br><span class="line">    SurfaceControl* <span class="keyword">const</span> ctrl = <span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(nativeObject);</span><br><span class="line">    <span class="keyword">status_t</span> err = ctrl-&gt;setFlags(flags, mask);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span> &amp;&amp; err != NO_INIT) &#123;</span><br><span class="line">        doThrowIAE(env);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用SurfaceControl.cpp的setFlags()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceControl.cpp]</span><br><span class="line"><span class="keyword">status_t</span> SurfaceControl::setFlags(<span class="keyword">uint32_t</span> flags, <span class="keyword">uint32_t</span> mask) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = validate();</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) <span class="keyword">return</span> err;</span><br><span class="line">    <span class="keyword">return</span> mClient-&gt;setFlags(mHandle, flags, mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步通过Binder IPC机制，SurfaceComposerClient.cpp-&gt;Composer::setFlags()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;SurfaceComposerClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Composer::setFlags(<span class="keyword">const</span> sp&lt;SurfaceComposerClient&gt;&amp; client,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; id, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        <span class="keyword">uint32_t</span> mask) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">layer_state_t</span>* s = getLayerStateLocked(client, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((mask &amp; <span class="keyword">layer_state_t</span>::eLayerOpaque) ||</span><br><span class="line">            (mask &amp; <span class="keyword">layer_state_t</span>::eLayerHidden) ||</span><br><span class="line">            (mask &amp; <span class="keyword">layer_state_t</span>::eLayerSecure)) &#123;</span><br><span class="line">        s-&gt;what |= <span class="keyword">layer_state_t</span>::eFlagsChanged;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;flags &amp;= ~mask;</span><br><span class="line">    s-&gt;flags |= (flags &amp; mask);</span><br><span class="line">    s-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体数值就不详细计算了，前面分析【Android 7.1.2 (Android N) Android Graphics 系统分析 [i.wonder~]】可知，SurfaceFlinger接收Vsync信号与App有一个offset间隔时间，当SurfaceFlinger接收Vsync信号时，就可以根据flags是否显示 和 上面设置的一系列数值进行渲染合成，最终显示到屏幕上。</p><h2 id="（四）、Activity启动窗口-Starting-Window-添加过程"><a href="#（四）、Activity启动窗口-Starting-Window-添加过程" class="headerlink" title="（四）、Activity启动窗口(Starting Window)添加过程"></a>（四）、Activity启动窗口(Starting Window)添加过程</h2><h3 id="4-1、Activity组件的启动窗口-Starting-Window-的添加过程"><a href="#4-1、Activity组件的启动窗口-Starting-Window-的添加过程" class="headerlink" title="4.1、Activity组件的启动窗口(Starting Window)的添加过程"></a>4.1、Activity组件的启动窗口(Starting Window)的添加过程</h3><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/13-Android-WMS-Starting-Window-addview.png" alt="Markdown"></p><h3 id="4-1-1、-ActivityStack-startActivityLocked"><a href="#4-1-1、-ActivityStack-startActivityLocked" class="headerlink" title="4.1.1、 ActivityStack.startActivityLocked()"></a>4.1.1、 ActivityStack.startActivityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityOptions options)</span> </span>&#123;</span><br><span class="line">            ......</span><br><span class="line">                    <span class="keyword">if</span> (!isHomeStack() || numActivities() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != <span class="number">0</span>) &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition);</span><br><span class="line">                mNoAnimActivities.add(r);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(newTask</span><br><span class="line">                        ? r.mLaunchTaskBehind</span><br><span class="line">                                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                                : TRANSIT_TASK_OPEN</span><br><span class="line">                        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);</span><br><span class="line">                mNoAnimActivities.remove(r);</span><br><span class="line">            &#125;</span><br><span class="line">            addConfigOverride(r, task);</span><br><span class="line">            <span class="keyword">boolean</span> doShow = <span class="keyword">true</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (r.mLaunchTaskBehind) &#123;</span><br><span class="line">                .......</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123;</span><br><span class="line">                ActivityRecord prev = r.task.topRunningActivityWithStartingWindowLocked();</span><br><span class="line">                <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// We don't want to reuse the previous starting preview if:</span></span><br><span class="line">                    <span class="comment">// (1) The current activity is in a different task.</span></span><br><span class="line">                    <span class="keyword">if</span> (prev.task != r.task) &#123;</span><br><span class="line">                        prev = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// (2) The current activity is already displayed.</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (prev.nowVisible) &#123;</span><br><span class="line">                        prev = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.showStartingWindow(prev, showStartingIcon);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到直接调用ActivityRecord.showStartingWindow()进一步添加启动窗口</p><h3 id="4-1-2、-ActivityRecord-showStartingWindow"><a href="#4-1-2、-ActivityRecord-showStartingWindow" class="headerlink" title="4.1.2、 ActivityRecord.showStartingWindow()"></a>4.1.2、 ActivityRecord.showStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showStartingWindow</span><span class="params">(ActivityRecord prev, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CompatibilityInfo compatInfo =</span><br><span class="line">            service.compatibilityInfoForPackageLocked(info.applicationInfo);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shown = service.mWindowManager.setAppStartingWindow(</span><br><span class="line">            appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon,</span><br><span class="line">            logo, windowFlags, prev != <span class="keyword">null</span> ? prev.appToken : <span class="keyword">null</span>, createIfNeeded);</span><br><span class="line">    <span class="keyword">if</span> (shown) &#123;</span><br><span class="line">        mStartingWindowState = STARTING_WINDOW_SHOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-2、ActivityRecord-setAppStartingWindow"><a href="#4-1-2、ActivityRecord-setAppStartingWindow" class="headerlink" title="4.1.2、ActivityRecord.setAppStartingWindow()"></a>4.1.2、ActivityRecord.setAppStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityRecord.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setAppStartingWindow</span><span class="params">(IBinder token, String pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> theme, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes, <span class="keyword">int</span> icon, <span class="keyword">int</span> logo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> windowFlags, IBinder transferFrom, <span class="keyword">boolean</span> createIfNeeded)</span> </span>&#123;</span><br><span class="line">   ......</span><br><span class="line">  <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">   AppWindowToken wtoken = findAppWindowToken(token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (transferStartingWindow(transferFrom, wtoken)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        wtoken.startingData = <span class="keyword">new</span> StartingData(pkg, theme, compatInfo, nonLocalizedLabel,</span><br><span class="line">                labelRes, icon, logo, windowFlags);</span><br><span class="line">        Message m = mH.obtainMessage(H.ADD_STARTING, wtoken);</span><br><span class="line">        mH.sendMessageAtFrontOfQueue(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数transferFrom所描述的Activity组件没有启动窗口或者启动窗口数据转移给参数token所描述的Activity组件，那么接下来就可能需要为参数token所描述的Activity组件创建一个新的启动窗口</p><h3 id="4-1-3、-H-handleMessage"><a href="#4-1-3、-H-handleMessage" class="headerlink" title="4.1.3、 H.handleMessage()"></a>4.1.3、 H.handleMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java::H]</span><br><span class="line"><span class="keyword">case</span> ADD_STARTING: &#123;</span><br><span class="line">    <span class="keyword">final</span> AppWindowToken wtoken = (AppWindowToken)msg.obj;</span><br><span class="line">    <span class="keyword">final</span> StartingData sd = wtoken.startingData;</span><br><span class="line">    ......</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Configuration overrideConfig = wtoken != <span class="keyword">null</span> &amp;&amp; wtoken.mTask != <span class="keyword">null</span></span><br><span class="line">                ? wtoken.mTask.mOverrideConfig : <span class="keyword">null</span>;</span><br><span class="line">        view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme,</span><br><span class="line">            sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo,</span><br><span class="line">            sd.windowFlags, overrideConfig);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> abort = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wtoken.removed || wtoken.startingData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    wtoken.startingWindow = <span class="keyword">null</span>;</span><br><span class="line">                    wtoken.startingData = <span class="keyword">null</span>;</span><br><span class="line">                    abort = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                wtoken.startingView = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mPolicy.removeStartingWindow(wtoken.token, view);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>PhoneWindowManager实现WindowManagerPolicy，所以会调用PhoneWindowManager中的方法 继续分析PhoneWindowManager.addStartingWindow()</p><h3 id="4-1-4、PhoneWindowManager-addStartingWindow"><a href="#4-1-4、PhoneWindowManager-addStartingWindow" class="headerlink" title="4.1.4、PhoneWindowManager.addStartingWindow()"></a>4.1.4、PhoneWindowManager.addStartingWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;PhoneWindowManager.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">addStartingWindow</span><span class="params">(IBinder appToken, String packageName, <span class="keyword">int</span> theme,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, <span class="keyword">int</span> labelRes,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> icon, <span class="keyword">int</span> logo, <span class="keyword">int</span> windowFlags, Configuration overrideConfig)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    WindowManager wm = <span class="keyword">null</span>;</span><br><span class="line">    View view = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Context context = mContext;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> PhoneWindow win = <span class="keyword">new</span> PhoneWindow(context);</span><br><span class="line">        win.setIsStartingWindow(<span class="keyword">true</span>);</span><br><span class="line">        ......</span><br><span class="line">        win.setType(</span><br><span class="line">            WindowManager.LayoutParams.TYPE_APPLICATION_STARTING);</span><br><span class="line">        ......</span><br><span class="line">        win.setLayout(WindowManager.LayoutParams.MATCH_PARENT,</span><br><span class="line">                WindowManager.LayoutParams.MATCH_PARENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> WindowManager.LayoutParams params = win.getAttributes();</span><br><span class="line">        params.token = appToken;</span><br><span class="line">        params.packageName = packageName;</span><br><span class="line">        params.windowAnimations = win.getWindowStyle().getResourceId(</span><br><span class="line">                com.android.internal.R.styleable.Window_windowAnimationStyle, <span class="number">0</span>);</span><br><span class="line">        ......</span><br><span class="line">        params.setTitle(<span class="string">"Starting "</span> + packageName);</span><br><span class="line">        wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">        view = win.getDecorView();</span><br><span class="line">       ......</span><br><span class="line">        wm.addView(view, params);</span><br><span class="line">        <span class="keyword">return</span> view.getParent() != <span class="keyword">null</span> ? view : <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (WindowManager.BadTokenException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wm.removeViewImmediate(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建PhoneWindow对象，接下来继续设置所创建的窗口win的以下属性： 1、窗口类型：设置为WindowManager.LayoutParams.TYPE_APPLICATION_STARTING，即设置为启动窗口类型；</p><p>2、窗口标题：由参数labelRes、nonLocalizedLabel，以及窗口的运行上下文context来确定；</p><p>3、窗口标志：分别将indowManager.LayoutParams.FLAG_NOT_TOUCHABLE、WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE和WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位设置为1，即不可接受触摸事件和不可获得焦点，但是可以接受输入法窗口；</p><p>4、窗口大小：设置为WindowManager.LayoutParams.MATCH_PARENT，即与父窗口一样大，但是由于这是一个顶层窗口，因此实际上是指与屏幕一样大；</p><p>5、布局参数：包括窗口所对应的窗口令牌（token）和包名（packageName），以及窗口所使用的动画类型（windowAnimations）和标题（title）。</p><p>wm.addView(view, params)，一个新创建的Activity组件的启动窗口就增加到WindowManagerService服务中去了，这样，WindowManagerService服务就可以下次刷新系统UI时，将该启动窗口显示出来</p><h2 id="（五）、WMS切换Activity窗口（App-Transition）过程"><a href="#（五）、WMS切换Activity窗口（App-Transition）过程" class="headerlink" title="（五）、WMS切换Activity窗口（App Transition）过程"></a>（五）、WMS切换Activity窗口（App Transition）过程</h2><p>WindowManagerService服务在执行Activity窗口的切换操作的时候，会给参与切换操作的Activity组件的设置一个动画，以便可以向用户展现一个Activity组件切换效果，从而提高用户体验。 首先看一下App Transition动态图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/14-Android-WMS-ezgif.com-video-to-gif-WMS-App-Transition.gif" alt="Markdown"></p><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/15-Android-WMS-executeAppTransition.png" alt="Markdown"></p><p>我们直接分析App Transition过程的prepareAppTransition、executeAppTransition 关于Activity启动过程请参考：【Android-7-1-2-Android-N-Activity启动流程分析】</p><h3 id="5-1、prepareAppTransition-过程"><a href="#5-1、prepareAppTransition-过程" class="headerlink" title="5.1、prepareAppTransition()过程"></a>5.1、prepareAppTransition()过程</h3><h3 id="5-1-1、ActivityStack-startActivityLocked"><a href="#5-1-1、ActivityStack-startActivityLocked" class="headerlink" title="5.1.1、ActivityStack.startActivityLocked()"></a>5.1.1、ActivityStack.startActivityLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">......</span><br><span class="line">mWindowManager.prepareAppTransition(newTask</span><br><span class="line">        ? r.mLaunchTaskBehind</span><br><span class="line">                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                : TRANSIT_TASK_OPEN</span><br><span class="line">        : TRANSIT_ACTIVITY_OPEN, keepCurTransition);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="5-1-2、WindowManagerService-prepareAppTransition"><a href="#5-1-2、WindowManagerService-prepareAppTransition" class="headerlink" title="5.1.2、WindowManagerService.prepareAppTransition()"></a>5.1.2、WindowManagerService.prepareAppTransition()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareAppTransition</span><span class="params">(<span class="keyword">int</span> transit, <span class="keyword">boolean</span> alwaysKeepCurrent)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> prepared = mAppTransition.prepareAppTransitionLocked(</span><br><span class="line">                transit, alwaysKeepCurrent);</span><br><span class="line">        <span class="keyword">if</span> (prepared &amp;&amp; okToDisplay()) &#123;</span><br><span class="line">            mSkipAppTransitionAnimation = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现是直接调用AppTransition.prepareAppTransitionLocked()实现的。</p><h3 id="5-1-3、AppTransition-prepareAppTransitionLocked"><a href="#5-1-3、AppTransition-prepareAppTransitionLocked" class="headerlink" title="5.1.3、AppTransition.prepareAppTransitionLocked()"></a>5.1.3、AppTransition.prepareAppTransitionLocked()</h3><p>进一步调用setAppTransition()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setAppTransition</span><span class="params">(<span class="keyword">int</span> transit)</span> </span>&#123;</span><br><span class="line">    mNextAppTransition = transit;</span><br><span class="line">    setLastAppTransition(TRANSIT_UNSET, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现只是将transit（即AppTransition动画类型）赋值给变量mNextAppTransition</p><h3 id="5-2、AppTransition-animation设置过程"><a href="#5-2、AppTransition-animation设置过程" class="headerlink" title="5.2、AppTransition animation设置过程"></a>5.2、AppTransition animation设置过程</h3><p>继续分析ActivityStackSupervisor.realStartActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line">        mWindowManager.setAppVisibility(r.appToken, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先会通知WindowManagerService服务将参数r.appToken所描述的Activity组件的可见性设置为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppVisibility</span><span class="params">(IBinder token, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    AppWindowToken wtoken;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        wtoken = findAppWindowToken(token);</span><br><span class="line">        ......</span><br><span class="line">        mOpeningApps.remove(wtoken);</span><br><span class="line">        mClosingApps.remove(wtoken);</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            wtoken.inPendingTransaction = <span class="keyword">false</span>;</span><br><span class="line">            setTokenVisibilityLocked(wtoken, <span class="keyword">null</span>, visible, AppTransition.TRANSIT_UNSET,</span><br><span class="line">                    <span class="keyword">true</span>, wtoken.voiceInteraction);</span><br><span class="line">            wtoken.updateReportedVisibilityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用WindowManagerService.setTokenVisibilityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setTokenVisibilityLocked</span><span class="params">(AppWindowToken wtoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> visible, <span class="keyword">int</span> transit, <span class="keyword">boolean</span> performLayout, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) ||</span><br><span class="line">                (visible &amp;&amp; wtoken.waitingForReplacement())) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">if</span> (transit != AppTransition.TRANSIT_UNSET) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123;</span><br><span class="line">                    delayed = runningAppAnimation = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>调用WindowManagerService.applyAnimationLocked()设置AppTransition动画</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">applyAnimationLocked</span><span class="params">(AppWindowToken atoken, WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> transit, <span class="keyword">boolean</span> enter, <span class="keyword">boolean</span> isVoiceInteraction)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (okToDisplay()) &#123;</span><br><span class="line">        Animation a = mAppTransition.loadAnimation(lp, transit, enter, mCurConfiguration.uiMode,</span><br><span class="line">        mCurConfiguration.orientation, frame, displayFrame, insets, surfaceInsets,</span><br><span class="line">        isVoiceInteraction, freeform, atoken.mTask.mTaskId);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于到了AppTransition真正设置过程了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppTransition.java]</span><br><span class="line">Animation loadAnimation(WindowManager.LayoutParams lp, int transit, boolean enter, int uiMode,</span><br><span class="line">            int orientation, Rect frame, Rect displayFrame, Rect insets,</span><br><span class="line">            @Nullable Rect surfaceInsets, boolean isVoiceInteraction, boolean freeform,</span><br><span class="line">            int taskId) &#123;</span><br><span class="line">        Animation a;</span><br><span class="line">      if()&#123;&#125;</span><br><span class="line">      ......</span><br><span class="line">      &#125; else if()&#123;</span><br><span class="line">      ......</span><br><span class="line">      &#125;else &#123;</span><br><span class="line">        int animAttr = 0;</span><br><span class="line">        switch (transit) &#123;</span><br><span class="line">            case TRANSIT_ACTIVITY_OPEN:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_activityOpenEnterAnimation</span><br><span class="line">                        : WindowAnimation_activityOpenExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_ACTIVITY_CLOSE:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_activityCloseEnterAnimation</span><br><span class="line">                        : WindowAnimation_activityCloseExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_DOCK_TASK_FROM_RECENTS:</span><br><span class="line">            case TRANSIT_TASK_OPEN:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskOpenEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskOpenExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_TASK_CLOSE:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskCloseEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskCloseExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_TASK_TO_FRONT:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskToFrontEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskToFrontExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            case TRANSIT_TASK_TO_BACK:</span><br><span class="line">                animAttr = enter</span><br><span class="line">                        ? WindowAnimation_taskToBackEnterAnimation</span><br><span class="line">                        : WindowAnimation_taskToBackExitAnimation;</span><br><span class="line">                break;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        a = animAttr != 0 ? loadAnimationAttr(lp, animAttr) : null;</span><br><span class="line">    &#125;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过<strong>loadAnimationAttr</strong>加载xml文件加载动画，动画xml文件的存放路径（/frameworks/base/core/res/res/anim/）<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/16-Android-WMS-executeAppTransition-xml.png" alt="Markdown"></p><h3 id="5-3、executeAppTransition过程"><a href="#5-3、executeAppTransition过程" class="headerlink" title="5.3、executeAppTransition过程"></a>5.3、executeAppTransition过程</h3><blockquote><p>ActivityStackSupervisor.realStartActivityLocked()</p><blockquote><p>ActivityStack.minimalResumeActivityLocked() ActivityStack.completeResumeLocked() ActivityStackSupervisor.reportResumedActivityLocked()</p></blockquote></blockquote><p>继续分析ActivityStackSupervisor.reportResumedActivityLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">reportResumedActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (allResumedActivitiesComplete()) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">        mWindowManager.executeAppTransition();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是Activity组件的可见性设置，然后执行executeAppTransition()</p><h3 id="5-3-1-WindowManagerService-executeAppTransition"><a href="#5-3-1-WindowManagerService-executeAppTransition" class="headerlink" title="5.3.1.WindowManagerService.executeAppTransition()"></a>5.3.1.WindowManagerService.executeAppTransition()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAppTransition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAppTransition.isTransitionSet()) &#123;</span><br><span class="line">                mAppTransition.setReady();</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而WindowSurfacePlacer.performSurfacePlacement()请看前面第二节分析</p><h2 id="（六）、Activity-Window-动画显示过程"><a href="#（六）、Activity-Window-动画显示过程" class="headerlink" title="（六）、Activity Window 动画显示过程"></a>（六）、Activity Window 动画显示过程</h2><h3 id="6-1、动画的设置过程"><a href="#6-1、动画的设置过程" class="headerlink" title="6.1、动画的设置过程"></a>6.1、动画的设置过程</h3><p>在Android系统中，窗口动画的本质就是对原始窗口施加一个变换（Transformation）。在线性数学中，对物体的形状进行变换是通过乘以一个矩阵（Matrix）来实现，目的就是对物体进行偏移、旋转、缩放、切变、反射和投影等。因此，给窗口设置动画实际上就给窗口设置一个变换矩阵（Transformation Matrix）。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/17-Android-WMS-Transformation-matrix.png" alt="Markdown"></p><p>窗口被设置的动画虽然可以达到三个，但是这三个动画可以归结为两类，一类是普通动画，例如，窗口在打开过程中被设置的进入动画和在关闭过程中被设置的退出动画，另一类是切换动画。其中，Self Transformation和Attached Transformation都是属于普通动画，而App Transformation属于切换动画。前面已经分析过App Transformation的设置过程 接下来分析普通动画的设置过程。</p><h3 id="6-1、普通动画的设置过程"><a href="#6-1、普通动画的设置过程" class="headerlink" title="6.1、普通动画的设置过程"></a>6.1、普通动画的设置过程</h3><p>普通动画的设置过程也是通过setTokenVisibilityLocked()设置的</p><h3 id="6-1-1、WindowManagerService-setTokenVisibilityLocked"><a href="#6-1-1、WindowManagerService-setTokenVisibilityLocked" class="headerlink" title="6.1.1、WindowManagerService.setTokenVisibilityLocked()"></a>6.1.1、WindowManagerService.setTokenVisibilityLocked()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowManagerService.java]</span><br><span class="line">    boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp,</span><br><span class="line">            boolean visible, int transit, boolean performLayout, boolean isVoiceInteraction) &#123;</span><br><span class="line">        ......</span><br><span class="line">        if (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) ||</span><br><span class="line">                (visible &amp;&amp; wtoken.waitingForReplacement())) &#123;</span><br><span class="line">           ......</span><br><span class="line">            if (transit != AppTransition.TRANSIT_UNSET) &#123;</span><br><span class="line">                ......</span><br><span class="line">                if (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123;</span><br><span class="line">                    delayed = runningAppAnimation = true;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                changed = true;</span><br><span class="line">            &#125;</span><br><span class="line">            final int windowsCount = wtoken.allAppWindows.size();</span><br><span class="line">            for (int i = 0; i &lt; windowsCount; i++) &#123;</span><br><span class="line">                WindowState win = wtoken.allAppWindows.get(i);</span><br><span class="line">                ......</span><br><span class="line">                if (visible) &#123;</span><br><span class="line">                    if (!win.isVisibleNow()) &#123;</span><br><span class="line">                        if (!runningAppAnimation) &#123;</span><br><span class="line">                            win.mWinAnimator.applyAnimationLocked(</span><br><span class="line">                                    WindowManagerPolicy.TRANSIT_ENTER, true);</span><br><span class="line">                            ......</span><br><span class="line">                        &#125;</span><br><span class="line">                        changed = true;</span><br><span class="line">                        win.setDisplayLayoutNeeded();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (win.isVisibleNow()) &#123;</span><br><span class="line">                    if (!runningAppAnimation) &#123;</span><br><span class="line">                        win.mWinAnimator.applyAnimationLocked(</span><br><span class="line">                                WindowManagerPolicy.TRANSIT_EXIT, false);</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line">                    changed = true;</span><br><span class="line">                    win.setDisplayLayoutNeeded();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            wtoken.hidden = wtoken.hiddenRequested = !visible;</span><br><span class="line">            visibilityChanged = true;</span><br><span class="line">            ......</span><br><span class="line">            if (changed) &#123;</span><br><span class="line">                mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line">                if (performLayout) &#123;</span><br><span class="line">                    updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES,</span><br><span class="line">                            false /*updateInputWindows*/);</span><br><span class="line">                    mWindowPlacerLocked.performSurfacePlacement();</span><br><span class="line">                &#125;</span><br><span class="line">                mInputMonitor.updateInputWindowsLw(false /*force*/);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到普通动画是通过win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER, true)</p><h3 id="6-1-1-WindowStateAnimator-applyAnimationLocked"><a href="#6-1-1-WindowStateAnimator-applyAnimationLocked" class="headerlink" title="6.1.1.WindowStateAnimator.applyAnimationLocked()"></a>6.1.1.WindowStateAnimator.applyAnimationLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">applyAnimationLocked</span><span class="params">(<span class="keyword">int</span> transit, <span class="keyword">boolean</span> isEntrance)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mService.okToDisplay()) &#123;</span><br><span class="line">        <span class="keyword">int</span> anim = mPolicy.selectAnimationLw(mWin, transit);</span><br><span class="line">        <span class="keyword">int</span> attr = -<span class="number">1</span>;</span><br><span class="line">        Animation a = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (anim != <span class="number">0</span>) &#123;</span><br><span class="line">            a = anim != -<span class="number">1</span> ? AnimationUtils.loadAnimation(mContext, anim) : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (transit) &#123;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_ENTER:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_EXIT:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_SHOW:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> WindowManagerPolicy.TRANSIT_HIDE:</span><br><span class="line">                    attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (attr &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setAnimation(a);</span><br><span class="line">            mAnimationIsEntrance = isEntrance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        clearAnimation();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mAnimation != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到也是根据动画类型从而通过AppTransition.loadAnimationAttr(mWin.mAttrs, attr)加载不同的anim xml文件。</p><h3 id="6-2、窗口动画的显示框架"><a href="#6-2、窗口动画的显示框架" class="headerlink" title="6.2、窗口动画的显示框架"></a>6.2、窗口动画的显示框架</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/19-Android-WMS-animationLocked.png" alt="Markdown"><br>通过堆栈信息可以看到，由Vsync信号驱动，然后调用Choreographer.doFrame完成动画的相关操作，关于Vsync这部分之前文章已经分析过，这里不再分析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="comment">/** Locked on mService.mWindowMap. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateLocked</span><span class="params">(<span class="keyword">long</span> frameTimeNs)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mCurrentTime = frameTimeNs / TimeUtils.NANOS_PER_MS;</span><br><span class="line">    mBulkUpdateParams = SET_ORIENTATION_CHANGE_COMPLETE;</span><br><span class="line">    <span class="keyword">boolean</span> wasAnimating = mAnimating;</span><br><span class="line">    setAnimating(<span class="keyword">false</span>);</span><br><span class="line">    mAppWindowAnimating = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">            TAG, <span class="string">"&gt;&gt;&gt; OPEN TRANSACTION animateLocked"</span>);</span><br><span class="line">    SurfaceControl.openTransaction();</span><br><span class="line">    SurfaceControl.setAnimationTransaction();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mDisplayContentsAnimators.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line">            <span class="comment">//1、Activity组件切换动画的推进过程</span></span><br><span class="line">            updateAppWindowsLocked(displayId);</span><br><span class="line">            DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ScreenRotationAnimation screenRotationAnimation =</span><br><span class="line">                    displayAnimator.mScreenRotationAnimation;</span><br><span class="line">            <span class="keyword">if</span> (screenRotationAnimation != <span class="keyword">null</span> &amp;&amp; screenRotationAnimation.isAnimating()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) &#123;</span><br><span class="line">                    setAnimating(<span class="keyword">true</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mBulkUpdateParams |= SET_UPDATE_ROTATION;</span><br><span class="line">                    screenRotationAnimation.kill();</span><br><span class="line">                    displayAnimator.mScreenRotationAnimation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//TODO (multidisplay): Accessibility supported only for the default display.</span></span><br><span class="line">                    <span class="keyword">if</span> (mService.mAccessibilityController != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                        <span class="comment">// We just finished rotation animation which means we did not</span></span><br><span class="line">                        <span class="comment">// anounce the rotation and waited for it to end, announce now.</span></span><br><span class="line">                        mService.mAccessibilityController.onRotationChangedLocked(</span><br><span class="line">                                mService.getDefaultDisplayContentLocked(), mService.mRotation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update animations of all applications, including those</span></span><br><span class="line">            <span class="comment">// associated with exiting/removed apps</span></span><br><span class="line">            <span class="comment">//2、窗口动画的推进过程</span></span><br><span class="line">            updateWindowsLocked(displayId);</span><br><span class="line">            <span class="comment">//壁纸动画的推进过程</span></span><br><span class="line">            updateWallpaperLocked(displayId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = windows.size();</span><br><span class="line">            <span class="comment">//3、通过一个for循环来遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新</span></span><br><span class="line">            <span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">                windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numDisplays; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = mDisplayContentsAnimators.keyAt(i);</span><br><span class="line"></span><br><span class="line">            testTokenMayBeDrawnLocked(displayId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ScreenRotationAnimation screenRotationAnimation =</span><br><span class="line">                    mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation;</span><br><span class="line">            <span class="keyword">if</span> (screenRotationAnimation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                screenRotationAnimation.updateSurfacesInTransaction();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            orAnimating(mService.getDisplayContentLocked(displayId).animateDimLayers());</span><br><span class="line">            orAnimating(mService.getDisplayContentLocked(displayId).getDockedDividerController()</span><br><span class="line">                    .animate(mCurrentTime));</span><br><span class="line">            <span class="comment">//TODO (multidisplay): Magnification is supported only for the default display.</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mAccessibilityController != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">                mService.mAccessibilityController.drawMagnifiedRegionBorderIfNeededLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//4、触发下一帧动画逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (mAnimating) &#123;</span><br><span class="line">            mService.scheduleAnimationLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mService.mWatermark != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.mWatermark.drawIfNeeded();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SurfaceControl.closeTransaction();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG, <span class="string">"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasPendingLayoutChanges = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mService.mDisplayContents.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pendingChanges = getPendingLayoutChanges(displayContent.getDisplayId());</span><br><span class="line">        <span class="keyword">if</span> ((pendingChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">            mBulkUpdateParams |= SET_WALLPAPER_ACTION_PENDING;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingChanges != <span class="number">0</span>) &#123;</span><br><span class="line">            hasPendingLayoutChanges = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> doRequest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mBulkUpdateParams != <span class="number">0</span>) &#123;</span><br><span class="line">        doRequest = mWindowPlacerLocked.copyAnimToLayoutParamsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5、刷新系统UI</span></span><br><span class="line">    <span class="keyword">if</span> (hasPendingLayoutChanges || doRequest) &#123;</span><br><span class="line">        mWindowPlacerLocked.requestTraversal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mRemoveReplacedWindows) &#123;</span><br><span class="line">        removeReplacedWindowsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.stopUsingSavedSurfaceLocked();</span><br><span class="line">    mService.destroyPreservedSurfaceLocked();</span><br><span class="line">    mService.mWindowPlacerLocked.destroyPendingSurfaces();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、Activity组件切换动画的推进、 2、窗口动画的推进、壁纸动画推进 3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息 4、触发下一帧动画逻辑 5、刷新系统UI 其中第3点 prepareSurfaceLocked在3.3.小节已经分析过了、第5点最终会调用mWindowPlacerLocked.performSurfacePlacement来刷新UI，也已经分析过了。 接下来分析Activity组件切换动画、窗口动画的推进过程。</p><h3 id="6-3、Activity组件切换动画"><a href="#6-3、Activity组件切换动画" class="headerlink" title="6.3、Activity组件切换动画"></a>6.3、Activity组件切换动画</h3><p>AppWindowAnimator:属于AppWindowToken，它的成员变量mAppAnimator代表了此应用程序所属的AppWindowAnimator WindowStateAnimator:WMS记录了所有窗口的WindowState，其中WindowState.mWinAnimator是一个WindowStateAnimator对象，它和上面AppWindowAnimator一样可以由开发人员定制</p><p>WindowAnimator.updateAppWindowsLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateAppWindowsLocked</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;TaskStack&gt; stacks = mService.getDisplayContentLocked(displayId).getStacks();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> TaskStack stack = stacks.get(stackNdx);</span><br><span class="line">        <span class="keyword">final</span> ArrayList&lt;Task&gt; tasks = stack.getTasks();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> taskNdx = tasks.size() - <span class="number">1</span>; taskNdx &gt;= <span class="number">0</span>; --taskNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> AppTokenList tokens = tasks.get(taskNdx).mAppTokens;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> tokenNdx = tokens.size() - <span class="number">1</span>; tokenNdx &gt;= <span class="number">0</span>; --tokenNdx) &#123;</span><br><span class="line">                <span class="keyword">final</span> AppWindowAnimator appAnimator = tokens.get(tokenNdx).mAppAnimator;</span><br><span class="line">                appAnimator.wasAnimating = appAnimator.animating;</span><br><span class="line">                <span class="keyword">if</span> (appAnimator.stepAnimationLocked(mCurrentTime, displayId)) &#123;</span><br><span class="line">                    appAnimator.animating = <span class="keyword">true</span>;</span><br><span class="line">                    setAnimating(<span class="keyword">true</span>);</span><br><span class="line">                    mAppWindowAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (appAnimator.wasAnimating) &#123;</span><br><span class="line">                    <span class="comment">// stopped animating, do one more pass through the layout</span></span><br><span class="line">                    setAppLayoutChanges(appAnimator,</span><br><span class="line">                            WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER,</span><br><span class="line">                            <span class="string">"appToken "</span> + appAnimator.mAppToken + <span class="string">" done"</span>, displayId);</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用stepAnimationLocked()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppWindowAnimator.java]</span><br><span class="line">    <span class="comment">// This must be called while inside a transaction.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stepAnimationLocked</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">final</span> <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.okToDisplay()) &#123;</span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed)</span><br><span class="line">                    &amp;&amp; animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (stepAnimation(currentTime)) &#123;</span><br><span class="line">                    <span class="comment">// animation isn't over, step any thumbnail and that's</span></span><br><span class="line">                    <span class="comment">// it for now.</span></span><br><span class="line">                    <span class="keyword">if</span> (thumbnail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stepThumbnailAnimation(currentTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            animating = <span class="keyword">true</span>;</span><br><span class="line">            animation = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用stepAnimation()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;AppWindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stepAnimation</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (animation == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    transformation.clear();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> animationFrameTime = getAnimationFrameTime(animation, currentTime);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">boolean</span> hasMoreFrames = animation.getTransformation(animationFrameTime, transformation);</span><br><span class="line">    <span class="keyword">if</span> (!hasMoreFrames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deferThumbnailDestruction &amp;&amp; !deferFinalFrameCleanup) &#123;</span><br><span class="line">            deferFinalFrameCleanup = <span class="keyword">true</span>;</span><br><span class="line">            hasMoreFrames = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            deferFinalFrameCleanup = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (mProlongAnimation == PROLONG_ANIMATION_AT_END) &#123;</span><br><span class="line">                hasMoreFrames = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setNullAnimation();</span><br><span class="line">                clearThumbnail();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hasTransformation = hasMoreFrames;</span><br><span class="line">    <span class="keyword">return</span> hasMoreFrames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.将成员变量transformation所描述的变换矩阵的数据清空 2.调用Animation.getTransformation()来计算Activity组件切换动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量transformation</p><h3 id="6-4、窗口动画的推进过程"><a href="#6-4、窗口动画的推进过程" class="headerlink" title="6.4、窗口动画的推进过程"></a>6.4、窗口动画的推进过程</h3><p>继续分析WindowAnimator.animateLocked()的updateWindowsLocked()</p><h3 id="6-4-1、WindowAnimator-updateWindowsLocked"><a href="#6-4-1、WindowAnimator-updateWindowsLocked" class="headerlink" title="6.4.1、WindowAnimator.updateWindowsLocked()"></a>6.4.1、WindowAnimator.updateWindowsLocked()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateWindowsLocked</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    ++mAnimTransactionSequence;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowList windows = mService.getWindowListLocked(displayId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = windows.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        WindowState win = windows.get(i);</span><br><span class="line">        WindowStateAnimator winAnimator = win.mWinAnimator;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = win.mAttrs.flags;</span><br><span class="line">        <span class="keyword">boolean</span> canBeForceHidden = mPolicy.canBeForceHidden(win, win.mAttrs);</span><br><span class="line">        <span class="keyword">boolean</span> shouldBeForceHidden = shouldForceHide(win);</span><br><span class="line">        <span class="keyword">if</span> (winAnimator.hasSurface()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> wasAnimating = winAnimator.mWasAnimating;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> nowAnimating = winAnimator.stepAnimationLocked(mCurrentTime);</span><br><span class="line">            winAnimator.mWasAnimating = nowAnimating;</span><br><span class="line">            orAnimating(nowAnimating);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowStateAnimator.stepAnimationLocked() 如果窗口的动画尚未结束显示，那么stepAnimationLocked()会返回一个true值给调用者，否则的话，就会返回一个false值给调用者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">stepAnimationLocked</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Save the animation state as it was before this step so WindowManagerService can tell if</span></span><br><span class="line">        <span class="comment">// we just started or just stopped animating by comparing mWasAnimating with isAnimationSet().</span></span><br><span class="line">        mWasAnimating = mAnimating;</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = mWin.getDisplayContent();</span><br><span class="line">        <span class="keyword">if</span> (displayContent != <span class="keyword">null</span> &amp;&amp; mService.okToDisplay()) &#123;</span><br><span class="line">            <span class="comment">// We will run animations as long as the display isn't frozen.</span></span><br><span class="line">            <span class="keyword">if</span> (mWin.isDrawnLw() &amp;&amp; mAnimation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHasTransformation = <span class="keyword">true</span>;</span><br><span class="line">                mHasLocalTransformation = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!mLocalAnimating) &#123;</span><br><span class="line">                    <span class="keyword">final</span> DisplayInfo displayInfo = displayContent.getDisplayInfo();</span><br><span class="line">                    <span class="keyword">if</span> (mAnimateMove) &#123;</span><br><span class="line">                        mAnimateMove = <span class="keyword">false</span>;</span><br><span class="line">                        mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(),</span><br><span class="line">                                mAnimDx, mAnimDy);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(),</span><br><span class="line">                                displayInfo.appWidth, displayInfo.appHeight);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mAnimDx = displayInfo.appWidth;</span><br><span class="line">                    mAnimDy = displayInfo.appHeight;</span><br><span class="line">                    mAnimation.setStartTime(mAnimationStartTime != -<span class="number">1</span></span><br><span class="line">                            ? mAnimationStartTime</span><br><span class="line">                            : currentTime);</span><br><span class="line">                    mLocalAnimating = <span class="keyword">true</span>;</span><br><span class="line">                    mAnimating = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((mAnimation != <span class="keyword">null</span>) &amp;&amp; mLocalAnimating) &#123;</span><br><span class="line">                    mLastAnimationTime = currentTime;</span><br><span class="line">                    <span class="keyword">if</span> (stepAnimation(currentTime)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowStateAnimator.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">stepAnimation</span><span class="params">(<span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    currentTime = getAnimationFrameTime(mAnimation, currentTime);</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    mTransformation.clear();</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> more = mAnimation.getTransformation(currentTime, mTransformation);</span><br><span class="line">    <span class="keyword">if</span> (mAnimationStartDelayed &amp;&amp; mAnimationIsEntrance) &#123;</span><br><span class="line">        mTransformation.setAlpha(<span class="number">0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、将成员变量mTransformation所描述的变换矩阵的数据清空。 2、调用mAnimation.getTransformation()来计算窗口动画下一步所对应的变换矩阵，并且将这个变换矩阵的数据保存在成员变量mTransformation。</p><p>然后就是动画过后，窗口大小计算、渲染合成等等显示步骤了，由于之前已经分析过了，不再分析了： 3、循环遍历保存在窗口堆栈的每一个WindowState对象，以便可以对系统中的每一个窗口的绘图表面进行更新 确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="comment">//确定该窗口实际要显示的大小、位置、Alpha通道和变换矩阵等信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">    windows.get(j).mWinAnimator.prepareSurfaceLocked(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、触发下一帧动画逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="keyword">if</span> (mAnimating) &#123;</span><br><span class="line">    mService.scheduleAnimationLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、刷新系统UI</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;WindowAnimator.java::animateLocked()]</span><br><span class="line"><span class="keyword">if</span> (hasPendingLayoutChanges || doRequest) &#123;</span><br><span class="line">    mWindowPlacerLocked.requestTraversal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终经过SurfaceFlinger合成显示到屏幕上。 总体流程图(…)：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.wms/20-Android-WMS-animation_Locked-time-diagram.png" alt="Markdown"></p><h2 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://www.bbsmax.com/A/n2d9gjgJDv/" target="_blank" rel="noopener">浅析 Android 的窗口</a><br><a href="https://www.jianshu.com/p/2faedc664d11" target="_blank" rel="noopener">WMS:窗口大小的计算</a><br><a href="http://blog.csdn.net/luozirong/article/details/70256809" target="_blank" rel="noopener">Android 窗口的计算过程</a><br><a href="http://blog.csdn.net/qian520ao/article/details/78555397" target="_blank" rel="noopener">Android Window 机制探索</a><br><a href="https://calvinlee.github.io/blog/2012/04/21/android-window-management-architecture/" target="_blank" rel="noopener">Android 窗口管理 - 且听风吟</a><br><a href="http://www.cnblogs.com/all-for-fiona/p/4054527.html" target="_blank" rel="noopener">Android 关于Window Overscan</a><br><a href="http://blog.csdn.net/guoqifa29/article/details/49273065" target="_blank" rel="noopener">WindowManagerService动画分析</a><br><a href="http://blog.csdn.net/guoqifa29/article/details/46819377" target="_blank" rel="noopener">深入理解Activity—-Token之旅 - CSDN博客</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/37737439" target="_blank" rel="noopener">Android 4.4(KitKat)窗口管理子系统 - 体系框架</a><br><a href="https://www.jianshu.com/p/c2e48b3e33a0" target="_blank" rel="noopener">Android窗口系统第四篇—Activity动画的设置过程</a><br><a href="http://blog.csdn.net/lin20044140410/article/details/78798048" target="_blank" rel="noopener">Android 7.1 GUI系统-窗口管理WMS-Surface管理（四）</a><br><a href="http://www.cnblogs.com/samchen2009/p/3367496.html" target="_blank" rel="noopener">Android 的窗口管理系统 (View, Canvas, WindowManager)</a><br><a href="http://gityuan.com/2017/01/15/wms_starting_window/" target="_blank" rel="noopener">WMS–启动窗口(StartingWindow) - Gityuan博客 | 袁辉辉博客</a><br><a href="https://www.jianshu.com/p/a65861e946cb" target="_blank" rel="noopener">View绘制流程及源码解析(一)—-performTraversals()源码分析</a><br><a href="http://blog.csdn.net/u013263323/article/details/78482141" target="_blank" rel="noopener">Android窗口系统第三篇—WindowManagerService中窗口的组织方式</a><br><a href="https://juejin.im/entry/58c899bea22b9d006411241c" target="_blank" rel="noopener">google 进入分屏后在横屏模式按 home 键界面错乱 (二) - Android - 掘金</a><br><a href="http://blog.csdn.net/yanbober/article/details/46361191" target="_blank" rel="noopener">Android应用Activity、Dialog、PopWindow、Toast窗口添加机制及源码分析</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8462738" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService的简要介绍和学习计划 - CSDN博客</a><br><a href="https://www.jianshu.com/p/40776c123adb" target="_blank" rel="noopener">Android窗口管理分析（2）：WindowManagerService窗口管理之Window添加流程</a><br><a href="http://blog.csdn.net/luoshengyang/article/details/8611754" target="_blank" rel="noopener">Android窗口管理服务WindowManagerService显示窗口动画的原理分析 - CSDN博客</a><br><a href="http://blog.csdn.net/kc58236582/article/details/53782138" target="_blank" rel="noopener">Android6.0 WMS（五） WMS计算Activity窗口大小的过程分析（二）WMS的relayoutWindow</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]</title>
      <link href="/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
      <url>/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Android系统图形框架由下往上主要的包括HAL(HWComposer和Gralloc两个moudle)，SurfaceFlinger（BufferQueue的消费者），WindowManagerService（窗口管理者），View（BufferQueue的生产者）四大模块。<br>● HAL: 包括HWComposer和Gralloc两个moudle，Android N上由SurfaceFlinger打开，因此在同一进程。 gralloc 用于BufferQueue的内存分配，同时也有fb的显示接口，HWComposer作为合成SurfaceFlinger里面的Layer，并显示（通过gralloc的post函数）<br>● SurfaceFlinger可以叫做LayerFlinger，作为Layer的管理者，同是也是BufferQueue的消费者，当每个Layer的生产者draw完完整的一帧时，会通知SurfaceFlinger，通知的方式采用BufferQueue。<br>● WindowManagerService: 作为Window的管理者，掌管着计算窗口大小，窗口切换等任务，同时也会将相应的参数设置给SurfaceFlinger，比如Window的在z-order，和窗口的大小。<br>● View: 作为BufferQueue的生产者，每当执行lockCanvas-&gt;draw-&gt;unlockCanvas，之后会存入一帧数据进入BufferQueue中。 嘿嘿(<em>^▽^</em>),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。 <a id="more"></a></p><h2 id="【博客原图链接】"><a href="#【博客原图链接】" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.graphics" target="_blank" rel="noopener">【博客原图链接】</a></h2><h2 id="源码（部分）："><a href="#源码（部分）：" class="headerlink" title="源码（部分）："></a>源码（部分）：</h2><p><strong>/frameworks/native/services/surfaceflinger/</strong></p><ul><li>tests/Transaction_test.cpp</li><li>tests/vsync/vsync.cpp</li></ul><p><strong>/frameworks/native/include/gui/</strong></p><ul><li>BitTube.h</li><li>BufferSlot.h</li><li>BufferQueueCore.h</li><li>BufferQueueProducer.h</li></ul><p><strong>/frameworks/base/core/java/android/app/</strong></p><ul><li>Activity.java</li><li>ActivityThread.java</li><li>Instrumentation.java</li></ul><p><strong>/frameworks/base/core/jni/</strong></p><ul><li>android_view_DisplayEventReceiver.cpp</li><li>android_view_SurfaceControl.cpp</li><li>android_view_Surface.cpp</li><li>android_view_SurfaceSession.cpp</li></ul><p><strong>/frameworks/native/include/gui/</strong></p><ul><li>SurfaceComposerClient.h</li><li>IDisplayEventConnection.h</li><li>SurfaceComposerClient.h</li></ul><p><strong>/frameworks/native/services/surfaceflinger/</strong></p><ul><li>SurfaceFlinger.cpp</li><li>Client.cpp</li><li>main_surfaceflinger.cpp</li><li>DisplayDevice.cpp</li><li>DispSync.cpp</li><li>EventControlThread.cpp</li><li>EventThread.cpp</li><li>Layer.cpp</li><li>MonitoredProducer.cpp</li></ul><p><strong>/frameworks/base/core/java/android/view/</strong></p><ul><li>WindowManagerImpl.java</li><li>ViewManager.java</li><li>WindowManagerGlobal.java</li><li>ViewRootImpl.java</li><li>Choreographer.java</li><li>IWindowSession.aidl</li><li>DisplayEventReceiver.java</li><li>SurfaceControl.java</li><li>Surface.java</li><li>SurfaceSession.java</li></ul><p><strong>/frameworks/native/include/ui/</strong></p><ul><li>GraphicBuffer.h</li><li>GraphicBufferAllocator.h</li></ul><p><strong>/frameworks/base/services/core/java/com/android/server/wm/</strong></p><ul><li>WindowManagerService.java</li><li>Session.java</li><li>WindowState.java</li><li>WindowStateAnimator.java</li><li>WindowSurfaceController.java</li></ul><h2 id="【博客原图链接】-1"><a href="#【博客原图链接】-1" class="headerlink" title="【博客原图链接】"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.graphics" target="_blank" rel="noopener">【博客原图链接】</a></h2><h2 id="（一）、Android-Graphics-系统框架"><a href="#（一）、Android-Graphics-系统框架" class="headerlink" title="（一）、Android Graphics 系统框架"></a>（一）、Android Graphics 系统框架</h2><p>（试用限制？？？万恶的亿图(EDraw)强加水印~火~）<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/01-Android-Graphics-Architecture.png" alt="Markdown"></p><p><strong>App</strong> 基于Android系统的GUI框架开发完整的Apk应用。</p><p><strong>Android Graphics Stack Client(SurfaceFlinger Client)</strong><br>Android在客户端的绘图堆栈通常包括： OpenGL ES：使用GPU进行3D和2D的绘图的API EGL：衔接GLES和系统的Native Window系统的适配层 Vulkan：Vulkan为Khronos Group推出的下一代跨平台图形开发接口，用于替代历史悠久的OpenGL。Android从7.0(Nougat)开始加入了对其的支持。Vulkan与OpenGL相比，接口更底层，从而使开发者能更直接地控制GPU。由于更好的并行支持，及更小的开销，性能上也有一定的提升。<br><strong>Android Graphics Stack Server（SurfaceFlinger Server）</strong><br>SurfaceFlinger是Android用于管理Display和负责Window Composite（窗口混合），把应用的显示窗口输出到Display的系统服务。</p><p><strong>Android Drivers（HAL）</strong><br>Android的驱动层，通过Android本身的HAL（硬件抽象层）机制，运行于User Space，跟渲染相关的包括：</p><p>Hwcomposer：如果硬件支持，SurfaceFlinger可以请求hwcomposer去做窗口混合而不需要自己来做，这样的效率也会更高，减少对GPU资源的占用 Gralloc：用来管理Graphics Buffer的分配和管理系统的framebuffer OpenGL ES/EGL</p><p><strong>Linux Kernel and Drivers</strong><br>除了标准的Linux内核和驱动（例如fb是framebuffer驱动），硬件厂商自己的驱动外，Android自己的一些Patches：</p><p>Ashmem：异步共享内存，用于在进程间共享一块内存区域，并允许系统在资源紧张时回收不加锁的内存块 ION：内存管理器 ION是google在Android4.0 为了解决内存碎片管理而引入的通用内存管理器,在面向程序员编程方面，它和ashmem很相似。但ION比ashmem更强大 Binder：高效的进程间通信机制 Vsync：Android 4.1引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作 <strong>Hardware</strong> Display（显示器）、CPU、GPU、VPU（Video Process Unit）、和内存等等</p><h2 id="（二）、Android-Graphics-测试程序（C-）"><a href="#（二）、Android-Graphics-测试程序（C-）" class="headerlink" title="（二）、Android Graphics 测试程序（C++）"></a>（二）、Android Graphics 测试程序（C++）</h2><p>为了便于观察对原生测试程序显示图像大小做了如下修改：</p><blockquote><p>frameworks/native/services/surfaceflinger/tests/Transaction_test.cpp</p></blockquote><p><a href="https://github.com/izhoujinjian/izhoujinjian.github.io.doc/blob/master/Android-7.1.2-Qualcomm-MSM89XX-Disable_HWUI_GPU_HWC.patch" target="_blank" rel="noopener">Disable_HWUI_GPU_HWC.patch</a></p><p>原生SurfaceFlinger测试程序编译：<br>1、编译Android 7.1.2源码-userdebug版本，烧录重启<br>2、编译/frameworks/native/services/surfaceflinger/tests/会生成SurfaceFlinger_test<br>3、连接手机执行命令 adb root、adb remount、adb push SurfaceFlinger_test /system/bin/<br>4、adb shell setenforce 0(暂时关闭SELinux权限)<br>5、adb shell、cd system/bin/、chmod 0777 SurfaceFlinger_test<br>6、运行测试程序：./SurfaceFlinger_test</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/02-Android-graphics-SurfaceFlinger-Test-00.gif" alt="Markdown"></p><p>可以看到在Android 显示屏接替绘制了多个图像，并且会变换形状、位置、颜色、透明度等。 我们先看一下主要步骤： 1、 创建SurfaceComposerClient</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br></pre></td></tr></table></figure><p>2、 客户端SurfaceComposerClient请求SurfaceFlinger创建Surface 注：App端对应SurfaceControl&lt;—&gt;SurfaceFlinger对应Layer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; mBGSurfaceControl;</span><br><span class="line">sp&lt;SurfaceControl&gt; mFGSurfaceControl;</span><br><span class="line">       <span class="comment">// Background surface</span></span><br><span class="line">mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"BG Test Surface"</span>), displayWidth, displayHeight,</span><br><span class="line">                PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">63</span>, <span class="number">63</span>, <span class="number">195</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/03-Android-Graphics-SF-test-color-blue.png" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Foreground surface</span></span><br><span class="line">mFGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">        String8(<span class="string">"FG Test Surface"</span>), <span class="number">64</span>, <span class="number">64</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">195</span>, <span class="number">63</span>, <span class="number">63</span>);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/04-Android-Graphics-SF-test-color-red.png" alt="Markdown"></p><p>3、处理事务，将SurfaceControl（App）的变化更新到Layer（SurfaceFlinger）图层</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">   mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">64</span>, <span class="number">64</span>));</span><br><span class="line">   ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">   SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>4、接受Vsync同步信号，渲染合成，推送到显示屏显示<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/05-Android-Graphics-SF-test-frame_01_delay-1s.gif" alt="Markdown"></p><p>接下来开始Android Graphics系统神秘探索之谜。</p><h2 id="（三）、Android-Graphics-禁用hwc和GPU"><a href="#（三）、Android-Graphics-禁用hwc和GPU" class="headerlink" title="（三）、Android Graphics 禁用hwc和GPU"></a>（三）、Android Graphics 禁用hwc和GPU</h2><h3 id="3-1、Disable-HWUI-GPU-HWC"><a href="#3-1、Disable-HWUI-GPU-HWC" class="headerlink" title="3.1、Disable_HWUI_GPU_HWC"></a>3.1、Disable_HWUI_GPU_HWC</h3><p>注：基于Android 7.1.2 Qualcomm MSM89XX源码，由于代码段较长，已放到GitHub <a href="https://github.com/izhoujinjian/izhoujinjian.github.io.doc/blob/master/Android-7.1.2-Qualcomm-MSM89XX-Disable_HWUI_GPU_HWC.patch" target="_blank" rel="noopener">Disable_HWUI_GPU_HWC.patch</a></p><p>编译userdebug版本，烧录开机: 运行测试程序：./SurfaceFlinger_test 结果跟上述一致，这里不再贴图了。</p><h3 id="3-2、Vsync测试程序"><a href="#3-2、Vsync测试程序" class="headerlink" title="3.2、Vsync测试程序"></a>3.2、Vsync测试程序</h3><p>Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作。</p><p>查看frameworks/native/services/surfaceflinger/tests/下还有vsync测试程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/looper.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/DisplayEventReceiver.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Looper.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">receiver</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver* q = (DisplayEventReceiver*)data;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">nsecs_t</span> oldTimeStamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((n = q-&gt;getEvents(buffer, <span class="number">1</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"event vsync: count=%d\t"</span>, buffer[i].vsync.count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oldTimeStamp) &#123;</span><br><span class="line">                <span class="keyword">float</span> t = <span class="keyword">float</span>(buffer[i].header.timestamp - oldTimeStamp) / s2ns(<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%f ms (%f Hz)\n"</span>, t*<span class="number">1000</span>, <span class="number">1.0</span>/t);</span><br><span class="line">            &#125;</span><br><span class="line">            oldTimeStamp = buffer[i].header.timestamp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>) &#123;<span class="built_in">printf</span>(<span class="string">"error reading events (%s)\n"</span>, strerror(-n));&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DisplayEventReceiver myDisplayEvent;</span><br><span class="line">    sp&lt;Looper&gt; loop = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">    loop-&gt;addFd(myDisplayEvent.getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT, receiver,</span><br><span class="line">            &amp;myDisplayEvent);</span><br><span class="line">    myDisplayEvent.setVsyncRate(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//printf("about to poll...\n");</span></span><br><span class="line">        <span class="keyword">int32_t</span> ret = loop-&gt;pollOnce(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_WAKE:</span><br><span class="line">                <span class="comment">//("ALOOPER_POLL_WAKE\n");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_CALLBACK:</span><br><span class="line">                <span class="comment">//("ALOOPER_POLL_CALLBACK\n");</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_TIMEOUT:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ALOOPER_POLL_TIMEOUT\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALOOPER_POLL_ERROR:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ALOOPER_POLL_TIMEOUT\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"ugh? poll returned %d\n"</span>, ret);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行看看：可以看到vsync信号每隔16 ms一次，关于vsync知识稍后再分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">event vsync: count=<span class="number">2631</span> <span class="number">16.168612</span> ms (<span class="number">61.848231</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2632</span> <span class="number">16.168613</span> ms (<span class="number">61.848224</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2633</span> <span class="number">16.168312</span> ms (<span class="number">61.849378</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2634</span> <span class="number">16.168682</span> ms (<span class="number">61.847961</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2635</span> <span class="number">16.168596</span> ms (<span class="number">61.848288</span> Hz)</span><br><span class="line">event vsync: count=<span class="number">2636</span> <span class="number">16.168867</span> ms (<span class="number">61.847255</span> Hz)</span><br></pre></td></tr></table></figure><h2 id="（四）、Android-SurfaceFlinger-内部机制"><a href="#（四）、Android-SurfaceFlinger-内部机制" class="headerlink" title="（四）、Android SurfaceFlinger 内部机制"></a>（四）、Android SurfaceFlinger 内部机制</h2><h3 id="4-1、APP与SurfaceFlinger的数据结构"><a href="#4-1、APP与SurfaceFlinger的数据结构" class="headerlink" title="4.1、APP与SurfaceFlinger的数据结构"></a>4.1、APP与SurfaceFlinger的数据结构</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/06-Android-Graphics-App-SurfaceFlinger.png" alt="Markdown"></p><h4 id="4-1-1、BufferQueue介绍"><a href="#4-1-1、BufferQueue介绍" class="headerlink" title="4.1.1、BufferQueue介绍"></a>4.1.1、BufferQueue介绍</h4><p>BufferQueue 类是 Android 中所有图形处理操作的核心。它的是将生成图形数据缓冲区的一方（生产者Producer）连接到接受数据以进行显示或进一步处理的一方（消费者Consumer）。几乎所有在系统中移动图形数据缓冲区的内容都依赖于 BufferQueue。 从上图APP与SurfaceFlinger交互中可以看出，BufferQueue内部维持着64个BufferSlot，每一个BufferSlot内部有一个GraphicBuffer指向分配的Graphic Buffer。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/07-Android-Graphics-SurfaceFlinger-BufferQueue.png.png" alt="Markdown"><br>先来看一下图中几个状态代表的含义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/include/gui/BufferSlot.h</span><br><span class="line"></span><br><span class="line"><span class="comment">// A buffer can be in one of five states, represented as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//         | mShared | mDequeueCount | mQueueCount | mAcquireCount |</span></span><br><span class="line"><span class="comment">// --------|---------|---------------|-------------|---------------|</span></span><br><span class="line"><span class="comment">// FREE    |  false  |       0       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// DEQUEUED|  false  |       1       |      0      |       0       |</span></span><br><span class="line"><span class="comment">// QUEUED  |  false  |       0       |      1      |       0       |</span></span><br><span class="line"><span class="comment">// ACQUIRED|  false  |       0       |      0      |       1       |</span></span><br><span class="line"><span class="comment">// SHARED  |  true   |      any      |     any     |      any      |</span></span><br></pre></td></tr></table></figure><p><strong>FREE :</strong> FREE表示缓冲区可由生产者（Producer）DEQUEUED出列。 该BufferSlot由BufferQueue”拥有”。 它转换到DEQUEUED 当调用dequeueBuffer时。</p><p><strong>DEQUEUED：</strong> DEQUEUED表示缓冲区已经被生产者（Producer）出列，但是尚未queued 或canceled。生产者（Producer）可以修改缓冲区的内容一旦相关的释放围栏被发信号通知。BufferSlot由Producer”拥有”。 它可以转换到QUEUED（通过 queueBuffer或者attachBuffer）或者返回FREE（通过cancelBuffer或者detachBuffer）。</p><p><strong>QUEUED：</strong> QUEUED表示缓冲区已经被生产者（Producer）填充排队等待消费者（Consumer）使用。 缓冲区内容可能被继续 修改在有限的时间内，所以内容不能被访问，直到关联的栅栏fence发信号。 该BufferSlot由BufferQueue”拥有”。 它 可以转换为ACQUIRED（通过acquireBuffer）或FREE（如果是另一个缓冲区以异步模式排队）。</p><p><strong>ACQUIRED：</strong> ACQUIRED表示缓冲区已被消费者（Consumer）获取。 如与QUEUED，内容不能被消费者访问，直到 获得栅栏fence信号。 BufferSlot由Consumer”拥有”。 它当releaseBuffer（或detachBuffer）被调用时转换为FREE。 一个 分离的缓冲区也可以通过attachBuffer进入ACQUIRED状态。</p><p><strong>SHARED：</strong> SHARED表示此缓冲区正在共享缓冲区中使用模式。 它可以同时在其他State的任何组合， 除了FREE （因为这不包括在任何其他State）。 它可以也可以出列，排队或多次获得。</p><p><strong>简单描述一下状态转换过程：</strong></p><p>1、首先生产者dequeue过来一块Buffer，此时该buffer的状态为DEQUEUED，所有者为PRODUCER，生产者可以填充数据了。在没有dequeue操作时，buffer的状态为free,所有者为BUFFERQUEUE。</p><p>2、生产者填充完数据后,进行queue操作，此时buffer的状态由DEQUEUED-&gt;QUEUED的转变，buffer所有者也变成了BufferQueue了。</p><p>3、上面已经通知消费者去拿buffer了，这个时候消费者就进行acquire操作将buffer拿过来，此时buffer的状态由QUEUED-&gt;ACQUIRED转变，buffer的拥有者由BufferQueue变成Consumer。</p><p>4、当消费者已经消费了这块buffer(已经合成，已经编码等)，就进行release操作释放buffer,将buffer归还给BufferQueue,buffer状态由ACQUIRED变成FREE.buffer拥有者由Consumer变成BufferQueue.</p><h4 id="4-1-2、生产者Producer"><a href="#4-1-2、生产者Producer" class="headerlink" title="4.1.2、生产者Producer"></a>4.1.2、生产者Producer</h4><p>生产者Producer实现IGraphicBufferProducer的接口，在实际运作过程中，应用（Client端）存在代理端BpGraphicBufferProducer，SurfaceFlinger（Server端）存在Native端BnGraphicBufferProducer。生产者代理端Bp通过Binder通信，不断的dequeueBuffer和queueBuffer操作，Native端同样响应这些操作请求，这样buffer就转了起来了。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/08-Android-Graphics-SurfaceFlinger-IGraphicsBufferProducer.png" alt="Markdown"></p><p>这里介绍几个非常重要的函数： <strong>1、requestBuffer</strong> requestBuffer为给定的索引请求一个新的Buffer。 服务器（即IGraphicBufferProducer实现）分配新创建的Buffer到给定的BufferSlot槽索引，并且客户端可以镜像slot-&gt;Buffer映射，这样就没有必要传输一个GraphicBuffer用于每个出队操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// requestBuffer requests a new buffer for the given index. The server (i.e.</span><br><span class="line">// the IGraphicBufferProducer implementation) assigns the newly created</span><br><span class="line">// buffer to the given slot index, and the client is expected to mirror the</span><br><span class="line">// slot-&gt;buffer mapping so that it&apos;s not necessary to transfer a</span><br><span class="line">// GraphicBuffer for every dequeue operation.</span><br><span class="line">//</span><br><span class="line">// The slot must be in the range of [0, NUM_BUFFER_SLOTS).</span><br><span class="line">virtual status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) = 0;</span><br></pre></td></tr></table></figure><p><strong>2、dequeueBuffer</strong> dequeueBuffer请求一个新的Buffer Slot供客户端使用。 插槽的所有权被转移到客户端，这意味着服务器不会使用与该插槽关联的缓冲区的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// dequeueBuffer requests a new buffer slot for the client to use. Ownership</span><br><span class="line">// of the slot is transfered to the client, meaning that the server will not</span><br><span class="line">// use the contents of the buffer associated with that slot.</span><br><span class="line">//</span><br><span class="line">virtual status_t dequeueBuffer(int* slot, sp&lt;Fence&gt;* fence, uint32_t w,</span><br><span class="line">        uint32_t h, PixelFormat format, uint32_t usage) = 0;</span><br></pre></td></tr></table></figure><p><strong>3、detachBuffer</strong> detachBuffer尝试删除给定buffer 的所有权插槽从buffer queue。 如果这个请求成功，该slot将会被free，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到插槽。 缓冲区必须已经被取出，并且调用者必须已经拥有sp</p><graphicbuffer>（即必须调用requestBuffer）</graphicbuffer><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// detachBuffer attempts to remove all ownership of the buffer in the given</span><br><span class="line">// slot from the buffer queue. If this call succeeds, the slot will be</span><br><span class="line">// freed, and there will be no way to obtain the buffer from this interface.</span><br><span class="line">// The freed slot will remain unallocated until either it is selected to</span><br><span class="line">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span><br><span class="line">// to the slot. The buffer must have already been dequeued, and the caller</span><br><span class="line">// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called</span><br><span class="line">// requestBuffer).</span><br><span class="line">//</span><br><span class="line">virtual status_t detachBuffer(int slot) = 0;</span><br></pre></td></tr></table></figure><p><strong>4、attachBuffer</strong> attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区已经出队一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致很多的缓冲区同时出队。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span><br><span class="line">// queue. If this call succeeds, it will be as if this buffer was dequeued</span><br><span class="line">// from the returned slot number. As such, this call will fail if attaching</span><br><span class="line">// this buffer would cause too many buffers to be simultaneously dequeued.</span><br><span class="line">//</span><br><span class="line">virtual status_t attachBuffer(int* outSlot,</span><br><span class="line">        const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0;</span><br></pre></td></tr></table></figure><h4 id="4-1-3、消费者Consumer"><a href="#4-1-3、消费者Consumer" class="headerlink" title="4.1.3、消费者Consumer"></a>4.1.3、消费者Consumer</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/09-Android-Graphics-SurfaceFlinger-IGraphicsBufferConsumer.png" alt="Markdown"><br>这里介绍几个非常重要的函数： <strong>1、acquireBuffer</strong> acquireBuffer尝试获取下一个未决缓冲区的所有权BufferQueue。 如果没有缓冲区等待，则返回NO_BUFFER_AVAILABLE。 如果缓冲区被成功获取，有关缓冲区的信息将在BufferItem中返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// acquireBuffer attempts to acquire ownership of the next pending buffer in</span><br><span class="line">// the BufferQueue.  If no buffer is pending then it returns</span><br><span class="line">// NO_BUFFER_AVAILABLE.  If a buffer is successfully acquired, the</span><br><span class="line">// information about the buffer is returned in BufferItem.</span><br><span class="line">//</span><br><span class="line">virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen,</span><br><span class="line">        uint64_t maxFrameNumber = 0) = 0;</span><br></pre></td></tr></table></figure><p><strong>2、releaseBuffer</strong> releaseBuffer从消费者释放一个BufferSlot回到BufferQueue。 这可以在缓冲区的内容仍然存在时完成被访问。 栅栏将在缓冲区不再正在使用时发出信号。 frameNumber用于标识返回的确切缓冲区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// releaseBuffer releases a buffer slot from the consumer back to the</span><br><span class="line">// BufferQueue.  This may be done while the buffer&apos;s contents are still</span><br><span class="line">// being accessed.  The fence will signal when the buffer is no longer</span><br><span class="line">// in use. frameNumber is used to indentify the exact buffer returned.</span><br><span class="line">//</span><br><span class="line">virtual status_t releaseBuffer(int buf, uint64_t frameNumber,</span><br><span class="line">        EGLDisplay display, EGLSyncKHR fence,</span><br><span class="line">        const sp&lt;Fence&gt;&amp; releaseFence) = 0;</span><br></pre></td></tr></table></figure><p><strong>3、detachBuffer</strong> detachBuffer尝试删除给定缓冲区的所有权插槽从缓冲区队列。 如果这个请求成功，该插槽将会是释放，并且将无法从这个接口获得缓冲区。释放的插槽将保持未分配状态，直到被选中为止在dequeueBuffer中保存一个新分配的缓冲区，或者附加一个缓冲区到slot。 缓冲区必须已被acquired。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// detachBuffer attempts to remove all ownership of the buffer in the given</span></span><br><span class="line"><span class="comment">// slot from the buffer queue. If this call succeeds, the slot will be</span></span><br><span class="line"><span class="comment">// freed, and there will be no way to obtain the buffer from this interface.</span></span><br><span class="line"><span class="comment">// The freed slot will remain unallocated until either it is selected to</span></span><br><span class="line"><span class="comment">// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached</span></span><br><span class="line"><span class="comment">// to the slot. The buffer must have already been acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">detachBuffer</span><span class="params">(<span class="keyword">int</span> slot)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>4、attachBuffer</strong> attachBuffer尝试将缓冲区的所有权转移给缓冲区队列。 如果这个调用成功，就好像这个缓冲区被获取了一样从返回的插槽号码。 因此，如果连接，这个调用将失败这个缓冲区会导致太多的缓冲区被同时acquired。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// attachBuffer attempts to transfer ownership of a buffer to the buffer</span></span><br><span class="line"><span class="comment">// queue. If this call succeeds, it will be as if this buffer was acquired</span></span><br><span class="line"><span class="comment">// from the returned slot number. As such, this call will fail if attaching</span></span><br><span class="line"><span class="comment">// this buffer would cause too many buffers to be simultaneously acquired.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">attachBuffer</span><span class="params">(<span class="keyword">int</span> *outSlot,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; buffer)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="4-2、App（Java层）请求创建Surface过程"><a href="#4-2、App（Java层）请求创建Surface过程" class="headerlink" title="4.2、App（Java层）请求创建Surface过程"></a>4.2、App（Java层）请求创建Surface过程</h2><h3 id="4-2-1、Activity启动流程"><a href="#4-2-1、Activity启动流程" class="headerlink" title="4.2.1、Activity启动流程"></a>4.2.1、Activity启动流程</h3><p>Activity创建过程这里不再叙述。 请参考<a href="https://izhoujinjian.github.io/2017/12/29/Android-7-1-2-Android-N-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/#%E4%B8%89%E3%80%81-ActivityManagerService%E6%8E%A5%E6%94%B6%E5%90%AF%E5%8A%A8Activity%E7%9A%84%E8%AF%B7%E6%B1%82" target="_blank" rel="noopener">【Android 7.1.2 (Android N) Activity启动流程分析】</a> &amp;&amp; <a href="https://izhoujinjian.github.io/2018/01/02/Android-7-1-2-Android-N-Activity-Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/#%E5%8D%9A%E5%AE%A2%E5%8E%9F%E5%9B%BE%E9%93%BE%E6%8E%A5" target="_blank" rel="noopener">【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</a></p><blockquote><p>● ActivityManagerService接收启动Activity的请求</p><p>Activity.startActivity()<br>Activity.startActivityForResult()<br>Instrumentation.execStartActivity()<br>ActivityManagerProxy.startActivity()<br>ActivityManagerNative.onTransact()<br>ActivityManagerService.startActivity()<br>ActivityStarter.startActivityMayWait()<br>ActivityStarter.startActivityLocked()<br>ActivityStarter.startActivityUnchecked()<br>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() ActivityStack.resumeTopActivityUncheckedLocked()<br>ActivityStack.resumeTopActivityInnerLocked()<br>ActivityStackSupervisor.startSpecificActivityLocked()</p><p>●● 创建Activity所属的应用进程 ActivityManagerService.startProcessLocked()</p><p>●●● Zygote通过socket通信fork一个新的进程，并根据”android.app.ActivityThread”字符串<br>  ●●● 反射出该对象并执行ActivityThread的main方法<br>  ActivityThread.main()<br>  ActivityThread.attach()<br>  ActivityManagerProxy.attachApplication()<br>  ActivityManagerNative.onTransact()<br>  ActivityManagerService.attachApplication()<br>  ActivityManagerService.attachApplicationLocked()<br>  ActivityStackSupervisor.attachApplicationLocked()<br>  ActivityStackSupervisor.realStartActivityLocked()</p><p>●●●● 执行启动Acitivity<br>IApplicationThread.scheduleLaunchActivity()<br>ActivityThread.ApplicationThread.scheduleLaunchActivity()<br>ActivityThread.sendMessage() ActivityThread.H.handleMessage()<br>ActivityThread.handleLauncherActivity()<br>ActivityThread.performLauncherActivity()<br>ActivityThread.handleResumeActivity()</p><h5 id="4-2-2、Window加载显示流程"><a href="#4-2-2、Window加载显示流程" class="headerlink" title="4.2.2、Window加载显示流程"></a>4.2.2、Window加载显示流程</h5><p>画图，需要重新分析一下下，嘿嘿(<em>^▽^</em>)~</p><h5 id="4-2-2-1、ActivityThread-handleLaunchActivity"><a href="#4-2-2-1、ActivityThread-handleLaunchActivity" class="headerlink" title="4.2.2.1、ActivityThread.handleLaunchActivity()"></a>4.2.2.1、ActivityThread.handleLaunchActivity()</h5><p>接着从ActivityThread的handleLaunchActivity方法：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//创建Activity  </span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//启动Activity  </span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-2、ActivityThread-handleResumeActivity"><a href="#4-2-2-2、ActivityThread-handleResumeActivity" class="headerlink" title="4.2.2.2、ActivityThread.handleResumeActivity()"></a>4.2.2.2、ActivityThread.handleResumeActivity()</h3><p>回到我们刚刚的handleLaunchActivity()方法，在调用完performLaunchActivity()方法之后，其有掉用了handleResumeActivity()法。performLaunchActivity()方法完成了两件事： 1) Activity窗口对象的创建，通过attach函数来完成； 2) Activity视图对象的创建，通过setContentView函数来完成； 这些准备工作完成后，就可以显示该Activity了，应用程序进程通过调用handleResumeActivity函数来启动Activity的显示过程。 [-&gt;ActivityThread.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的performLaunchActivity函数中完成Activity的创建后，会将当前当前创建的Activity在应用程序进程端的描述符ActivityClientRecord以键值对的形式保存到ActivityThread的成员变量mActivities中：mActivities.put(r.token, r)，r.token就是Activity的身份证，即是IApplicationToken.Proxy代理对象，也用于与AMS通信。上面的函数首先通过performResumeActivity从mActivities变量中取出Activity的应用程序端描述符ActivityClientRecord，然后取出前面为Activity创建的视图对象DecorView和窗口管理器WindowManager，最后将视图对象添加到窗口管理器中。 ViewManager.addView()真正实现的的地方在WindowManagerImpl.java中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerGlobal.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-3、ViewRootImpl-构造过程："><a href="#4-2-2-3、ViewRootImpl-构造过程：" class="headerlink" title="4.2.2.3、ViewRootImpl()构造过程："></a>4.2.2.3、ViewRootImpl()构造过程：</h3><p>[ViewRootImpl.java # ViewRootImpl()]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> W mWindow;</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line">    <span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();<span class="comment">//IWindowSession的代理对象，该对象用于和WMS通信。</span></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    ......</span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);<span class="comment">//创建了一个W本地Binder对象，用于WMS通知应用程序进程</span></span><br><span class="line">    ......</span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line">    mDensity = context.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">    mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi;</span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line">    mChoreographer = Choreographer.getInstance();<span class="comment">//Choreographer对象</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewRootImpl的构造函数中初始化了一些成员变量，ViewRootImpl创建了以下几个主要对象：</p><p>(1) 通过WindowManagerGlobal.getWindowSession()得到IWindowSession的代理对象，该对象用于和WMS通信。</p><p>(2) 创建了一个W本地Binder对象，用于WMS通知应用程序进程。</p><p>(3) 采用单例模式创建了一个Choreographer对象，用于统一调度窗口绘图。</p><p>(4) 创建ViewRootHandler对象，用于处理当前视图消息。</p><p>(5) 构造一个AttachInfo对象；</p><p>●●●(6) 创建Surface对象，用于绘制当前视图，当然该Surface对象的真正创建是由WMS来完成的，只不过是WMS传递给应用程序进程的。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/10-Android-Graphics-App-WMS-Surface.png.png" alt="Markdown"></p><h3 id="4-2-2-4、IWindowSession代理获取过程"><a href="#4-2-2-4、IWindowSession代理获取过程" class="headerlink" title="4.2.2.4、IWindowSession代理获取过程"></a>4.2.2.4、IWindowSession代理获取过程</h3><p>[-&gt;WindowManagerGlobal.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> IWindowSession sWindowSession;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">                <span class="comment">//得到IWindowSession代理对象</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数通过WMS的openSession函数创建应用程序与WMS之间的连接通道，即获取IWindowSession代理对象，并将该代理对象保存到ViewRootImpl的静态成员变量sWindowSession中,因此在应用程序进程中有且只有一个IWindowSession代理对象。 [-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null client"</span>);</span><br><span class="line">    <span class="keyword">if</span> (inputContext == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null inputContext"</span>);</span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WMS服务端构造了一个Session实例对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。</p><h3 id="4-2-2-5、视图View添加过程ViewRootImpl-setView"><a href="#4-2-2-5、视图View添加过程ViewRootImpl-setView" class="headerlink" title="4.2.2.5、视图View添加过程ViewRootImpl.setView()"></a>4.2.2.5、视图View添加过程ViewRootImpl.setView()</h3><p>窗口管理器WindowManagerImpl为当前添加的窗口创建好各种对象后，调用ViewRootImpl的setView函数向WMS服务添加一个窗口对象。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">////将DecorView保存到ViewRootImpl的成员变量mView中</span></span><br><span class="line">            mView = view;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//1）在添加窗口前进行UI布局  </span></span><br><span class="line">            requestLayout();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                 <span class="comment">//2)将窗口添加到WMS服务中，mWindow为W本地Binder对象，通过Binder传输到WMS服务端后，变为IWindow代理对象  </span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; ......</span><br><span class="line">            <span class="comment">//3)建立窗口消息通道  </span></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的分析可以知道，用户自定义的UI作为一个子View被添加到DecorView中，然后将顶级视图DecorView添加到应用程序进程的窗口管理器中，窗口管理器首先为当前添加的View创建一个ViewRootImpl对象、一个布局参数对象ViewGroup.LayoutParams，然后将这三个对象分别保存到当前应用程序进程的窗口管理器WindowManagerImpl中，最后通过ViewRootImpl对象将当前视图对象注册到WMS服务中。</p><p>ViewRootImpl的setView函数向WMS服务添加一个窗口对象过程： (1) requestLayout()在应用程序进程中进行窗口UI布局； (2) WindowSession.addToDisplay()向WMS服务注册一个窗口对象； (3) 注册应用程序进程端的消息接收通道；</p><h3 id="4-2-2-6、requestLayout-在应用程序进程中进行窗口UI布局；"><a href="#4-2-2-6、requestLayout-在应用程序进程中进行窗口UI布局；" class="headerlink" title="4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；"></a>4.2.2.6、requestLayout()在应用程序进程中进行窗口UI布局；</h3><p>2.10、窗口UI布局过程 requestLayout函数调用里面使用了Hanlder的一个小手段，那就是利用postSyncBarrier添加了一个Barrier（挡板），这个挡板的作用是阻塞普通的同步消息的执行，在挡板被撤销之前，只会执行异步消息，而requestLayout先添加了一个挡板Barrier，之后自己插入了一个异步任务mTraversalRunnable，其主要作用就是保证mTraversalRunnable在所有同步Message之前被执行，保证View绘制的最高优先级。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暂时不讨论Choreographer和Vsync知识，稍后再详细分析。 现在先说出结论：Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号。 此时FrameDisplayEventReceiver会Call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger。Vsync信号每隔16ms一次，此时Vsync信号还未来到，继续分析mWindowSession.addToDisplay()。</p><h3 id="4-2-2-7、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；"><a href="#4-2-2-7、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；" class="headerlink" title="4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；"></a>4.2.2.7、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；</h3><p>[Session.java]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line">public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        Rect outOutsets, InputChannel outInputChannel) &#123;</span><br><span class="line">    return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。 在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。 [WindowState.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(TAG, <span class="string">"Attaching "</span> + <span class="keyword">this</span> + <span class="string">" token="</span> + mToken</span><br><span class="line">        + <span class="string">", list="</span> + mToken.windows);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">            TAG_WM, <span class="string">"First window added to "</span> + <span class="keyword">this</span> + <span class="string">", creating SurfaceSession"</span>);</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(TAG_WM, <span class="string">"  NEW SURFACE SESSION "</span> + mSurfaceSession);</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2-8、SurfaceSession建立过程"><a href="#4-2-2-8、SurfaceSession建立过程" class="headerlink" title="4.2.2.8、SurfaceSession建立过程"></a>4.2.2.8、SurfaceSession建立过程</h3><p>SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。</p><p>客户端请求 [SurfaceSession.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。 [android_view_SurfaceSession.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。 是否似曾相识，就是前面最开始SurfaceFlinger_Test程序第一步：new SurfaceComposerClient的过程。 [SurfaceComposerClient.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService()</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。</p><p>服务端处理 在SurfaceFlinger服务端为应用程序创建交互的Client对象 [SurfaceFlinger.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line"><span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(new Client(<span class="keyword">this</span>)</span>)</span>;</span><br><span class="line">status_t err = client-&gt;initCheck();</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    bclient = client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3、App（C-层）请求创建SurfaceFlinger客户端-client-的过程"><a href="#4-2-3、App（C-层）请求创建SurfaceFlinger客户端-client-的过程" class="headerlink" title="4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程"></a>4.2.3、App（C++层）请求创建SurfaceFlinger客户端(client)的过程</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/11-Android-Graphics-App-Ask-SurfaceFlinger-Create-Client.png.png" alt="Markdown"></p><p>继续详细分析AppApp（C++层）请求创建SurfaceFlinger客户端(client)的过程</p><p>SurfaceComposerClient第一次强引用时，会执行onFirstRef() [SurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line">sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步：获取”SurfaceFlinger”服务 ComposerService::getComposerService()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*static*/</span> sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123;</span><br><span class="line">    ComposerService&amp; instance = ComposerService::getInstance();</span><br><span class="line">    Mutex::Autolock _l(instance.mLock);</span><br><span class="line">    <span class="keyword">if</span> (instance.mComposerService == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ComposerService::getInstance().connectLocked();</span><br><span class="line">        assert(instance.mComposerService != <span class="literal">NULL</span>);</span><br><span class="line">        ALOGD(<span class="string">"ComposerService reconnected"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance.mComposerService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComposerService::getInstance()会调用connectLocked()获取”SurfaceFlinger”服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ComposerService::ComposerService()</span><br><span class="line">: Singleton&lt;ComposerService&gt;() &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    connectLocked();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ComposerService::connectLocked() &#123;</span><br><span class="line">    const String16 name(&quot;SurfaceFlinger&quot;);</span><br><span class="line">    while (getService(name, &amp;mComposerService) != NO_ERROR) &#123;</span><br><span class="line">        usleep(250000);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以前面instance.mComposerService其实返回的是”SurfaceFlinger”服务。 第二步：createConnection() 接下来就会调用”SurfaceFlinger”服务的createConnection()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line">    sp&lt;Client&gt; client(<span class="keyword">new</span> Client(<span class="keyword">this</span>));</span><br><span class="line">    <span class="keyword">status_t</span> err = client-&gt;initCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        bclient = client;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4、APP申请创建Surface过程"><a href="#4-2-4、APP申请创建Surface过程" class="headerlink" title="4.2.4、APP申请创建Surface过程"></a>4.2.4、APP申请创建Surface过程</h3><p>前面讲ViewRootImpl.setView时，requestLayout()需要Vsync trigger，加入现在Vsync信号来到，于是会继续执行。App申请创建Surface的过程就在其中。</p><p>当Vsync事件到来时，就会通过Choreographer的postCallback()，接着执行mTraversalRunnable对象的run()方法。 mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        ......</span><br><span class="line">        performTraversals();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals函数相当复杂，其主要实现以下几个重要步骤：</p><p>1.执行窗口测量；</p><p>2.执行窗口注册；</p><p>3.执行窗口布局；</p><p>4.执行窗口绘图；</p><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        ......</span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、执行窗口测量performMeasure() [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-1、APP申请创建Surface过程-Java层"><a href="#4-2-4-1、APP申请创建Surface过程-Java层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(Java层)"></a>4.2.4.1、APP申请创建Surface过程(Java层)</h4><p>2、执行窗口注册relayoutWindow； [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过前面获取的IWindowSession代理对象请求WMS服务执行窗口布局，mSurface是ViewRootImpl的成员变量 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure><p>[-&gt;Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an empty surface, which will later be filled in by readFromParcel().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Surface构造函数仅仅创建了一个空Surface对象，并没有对该Surface进程native层的初始化，到此我们知道应用程序进程为每个窗口对象都创建了一个Surface对象。并且将该Surface通过跨进程方式传输给WMS服务进程，我们知道，在Android系统中，如果一个对象需要在不同进程间传输，必须实现Parcelable接口，Surface类正好实现了Parcelable接口。ViewRootImpl通过IWindowSession接口请求WMS的完整过程如下： [-&gt;IWindowSession.java$ Proxy]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This file is auto-generated.  DO NOT MODIFY</span></span><br><span class="line"><span class="comment">*  * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(android.view.IWindow window, <span class="keyword">int</span> seq, android.view.WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"><span class="keyword">int</span> _result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">        outSurface.readFromParcel(_reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该函数的实现可以看出，应用程序进程中创建的Surface对象并没有传递到WMS服务进程，只是读取WMS服务进程返回来的Surface。那么WMS服务进程是如何响应应用程序进程布局请求的呢？</p><p>[-&gt;IWindowSession.java$ Stub]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> TRANSACTION_relayout:</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    android.view.Surface _arg15;</span><br><span class="line">    _arg15 = <span class="keyword">new</span> android.view.Surface();</span><br><span class="line">    <span class="keyword">int</span> _result = <span class="keyword">this</span>.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(_result);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((_arg15!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">    _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数可以看出，WMS服务在响应应用程序进程请求添加窗口时，首先在当前进程空间创建一个Surface对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">android.view.Surface _arg15;</span><br><span class="line">_arg15 = <span class="keyword">new</span> android.view.Surface();</span><br></pre></td></tr></table></figure><p>然后调用Session的relayout()函数进一步完成窗口添加过程，最后将WMS服务中创建的Surface返回给应用程序进程。</p><p>到目前为止，在应用程序进程和WMS服务进程分别创建了一个Surface对象，但是他们调用的都是Surface的无参构造函数，在该构造函数中并未真正初始化native层的Surface，那native层的Surface是在那里创建的呢？ [-&gt;Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowSurfaceController.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowStateAnimator.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>);</span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowSurfaceController.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WindowSurfaceController</span><span class="params">(SurfaceSession s,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags, WindowStateAnimator animator)</span> </span>&#123;</span><br><span class="line">    mAnimator = animator;</span><br><span class="line">    mSurfaceW = w;</span><br><span class="line">    mSurfaceH = h;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (animator.mWin.isChildWindow() &amp;&amp;</span><br><span class="line">            animator.mWin.mSubLayer &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            animator.mWin.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">                s, name, w, h, format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-1、APP申请创建Surface过程-C-层"><a href="#4-2-4-1、APP申请创建Surface过程-C-层" class="headerlink" title="4.2.4.1、APP申请创建Surface过程(C++层)"></a>4.2.4.1、APP申请创建Surface过程(C++层)</h4><p>SurfaceControl创建过程 [-&gt;SurfaceControl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_SurfaceControl.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">    jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line">sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));</span><br><span class="line">sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</span><br><span class="line">        String8(name.c_str()), w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/12-Android-Graphics-App-Ask-SurfaceFlinger-CreateSurface.png" alt="Markdown"></p><p>[-&gt;SurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">    <span class="keyword">uint32_t</span> w,</span><br><span class="line">    <span class="keyword">uint32_t</span> h,</span><br><span class="line">    PixelFormat format,</span><br><span class="line">    <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    &#123;</span><br><span class="line">sp&lt;SurfaceControl&gt; sur;</span><br><span class="line"><span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">            &amp;handle, &amp;gbp);</span><br><span class="line">    ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。 [ISurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    ......</span><br><span class="line">    remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">    *handle = reply.readStrongBinder();</span><br><span class="line">    *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">    <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Client.cpp] MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line">Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。</span><br><span class="line">[-&gt;SurfaceFlinger.cpp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> SurfaceFlinger::createLayer(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">    <span class="comment">//ALOGD("createLayer for (%d x %d), name=%s", w, h, name.string());</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    <span class="comment">////根据flags创建不同类型的layer</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将创建好的Layer对象保存在Client中  </span></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了3种类型的Layer: [-&gt;ISurfaceComposerClient.h]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eFXSurfaceNormal    = <span class="number">0x00000000</span>,</span><br><span class="line">eFXSurfaceDim       = <span class="number">0x00020000</span>,</span><br><span class="line">eFXSurfaceMask      = <span class="number">0x000F0000</span></span><br></pre></td></tr></table></figure><p>[-&gt;SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::createNormalLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span><br><span class="line">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;</span><br><span class="line"><span class="comment">// initialize the surfaces</span></span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">    format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象  </span></span><br><span class="line">*outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line"><span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">    *gbp = (*outLayer)-&gt;getProducer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGE_IF(err, <span class="string">"createNormalLayer() failed (%s)"</span>, strerror(-err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/13-Android-Graphics-App-Ask-SurfaceFlinger-Create-Layer.png.png.png" alt="Markdown"><br>第一次强引用Layer对象时，onFirstRef()函数被回调 [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line"><span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line"><span class="comment">//创建BufferQueue对象</span></span><br><span class="line">BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</span><br><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_DISABLE_TRIPLE_BUFFERING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"disabling triple buffering"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的</p><h4 id="4-2-4-2、BufferQueue构造过程"><a href="#4-2-4-2、BufferQueue构造过程" class="headerlink" title="4.2.4.2、BufferQueue构造过程"></a>4.2.4.2、BufferQueue构造过程</h4><p>[-&gt;BufferQueue.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">sp&lt;BufferQueueCore&gt; core(<span class="keyword">new</span> BufferQueueCore(allocator));</span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br><span class="line">*outProducer = producer;</span><br><span class="line">*outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;BufferQueueCore.cpp] 所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueCore::BufferQueueCore(<span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :</span><br><span class="line">mAllocator(allocator),</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (allocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService());</span><br><span class="line">    mAllocator = composer-&gt;createGraphicBufferAlloc();</span><br><span class="line">    <span class="keyword">if</span> (mAllocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">"createGraphicBufferAlloc failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numStartingBuffers = getMaxBufferCountLocked();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">    mFreeSlots.insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS;</span><br><span class="line">        s++) &#123;</span><br><span class="line">    mUnusedSlots.push_front(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/14-Android-Graphics-App-SurfaceFlinger-BufferSlot.png.png" alt="Markdown"></p><p>[-&gt;ISurfaceComposer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">virtual</span> sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()</span><br><span class="line">&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;GraphicBufferAlloc&gt; gba(<span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"><span class="keyword">return</span> gba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GraphicBufferAlloc构造过程</strong></p><p>[-&gt;GraphicBufferAlloc.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(<span class="keyword">uint32_t</span> width,</span><br><span class="line">    <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> usage,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> requestorName, <span class="keyword">status_t</span>* error) &#123;</span><br><span class="line">sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(</span><br><span class="line">        width, height, format, usage, <span class="built_in">std</span>::move(requestorName)));</span><br><span class="line"><span class="keyword">status_t</span> err = graphicBuffer-&gt;initCheck();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> graphicBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图形缓冲区创建过程</strong> [-&gt;GraphicBuffer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span><br><span class="line">    PixelFormat inFormat, <span class="keyword">uint32_t</span> inUsage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">: BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">  mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">width  =</span><br><span class="line">height =</span><br><span class="line">stride =</span><br><span class="line">format =</span><br><span class="line">usage  = <span class="number">0</span>;</span><br><span class="line">handle = <span class="literal">NULL</span>;</span><br><span class="line">mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage,</span><br><span class="line">        <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。</p><p>使用GraphicBufferAllocator对象来为图形缓冲区分配内存空间，GraphicBufferAllocator是对Gralloc模块中的gpu设备的封装类。关于GraphicBufferAllocator内存分配过程请以后作分析，图形缓冲区分配完成后，还会映射到SurfaceFlinger服务进程的虚拟地址空间。</p><p><strong>Android图形缓冲区分配过程源码分析</strong></p><p>[-&gt;Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">:   contentDirty(<span class="literal">false</span>),</span><br><span class="line">    sequence(<span class="keyword">uint32_t</span>(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">    mFlinger(flinger),</span><br><span class="line">    mTextureName(<span class="number">-1U</span>),</span><br><span class="line">    mPremultipliedAlpha(<span class="literal">true</span>),</span><br><span class="line">    mName(<span class="string">"unnamed"</span>),</span><br><span class="line">    mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">    ......&#123;</span><br><span class="line">mCurrentCrop.makeInvalid();</span><br><span class="line">mFlinger-&gt;getRenderEngine().genTextures(<span class="number">1</span>, &amp;mTextureName);</span><br><span class="line">mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此才算真正创建了一个可用于绘图的Surface (Layer)，从上面的分析我们可以看出，在WMS服务进程端，其实创建了两个Java层的Surface对象，第一个Surface使用了无参构造函数，仅仅构造一个Surface对象而已，而第二个Surface却使用了有参构造函数，参数指定了图象宽高等信息，这个Java层Surface对象还会在native层请求SurfaceFlinger创建一个真正能用于绘制图象的native层Surface。最后通过浅拷贝的方式将第二个Surface复制到第一个Surface中，最后通过writeToParcel方式写回到应用程序进程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/15-Android-Graphics-App-WMS-SurfaceFlinger-Surface-SurfaceControl.png" alt="Markdown"></p><p>到目前为止，应用程序和WMS一共创建了3个Java层Surface（SurfaceControl）对象，如上图所示，而真正能用于绘图的Surface只有3号，那么3号Surface与2号Surface之间是什么关系呢？outSurface.copyFrom(surface)</p><p>[Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2号Surface引用到了3号Surface的SurfaceControl对象后，通过writeToParcel()函数写会到应用程序进程。 [Surface.java]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        @Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dest == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"dest must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">        dest.writeInt(mIsSingleBuffered ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        nativeWriteToParcel(mNativeObject, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject parcelObj)</span> </span>&#123;</span><br><span class="line">Parcel* parcel = parcelForJavaObject(env, parcelObj);</span><br><span class="line"><span class="keyword">if</span> (parcel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    doThrowNPE(env);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;Surface&gt; self(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line">android::view::Surface surfaceShim;</span><br><span class="line"><span class="keyword">if</span> (self != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calling code in Surface.java has already written the name of the Surface</span></span><br><span class="line"><span class="comment">// to the Parcel</span></span><br><span class="line">surfaceShim.writeToParcel(parcel, <span class="comment">/*nameAlreadyWritten*/</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"source must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// nativeReadFromParcel() will either return mNativeObject, or</span></span><br><span class="line">        <span class="comment">// create a new native Surface and return it after reducing</span></span><br><span class="line">        <span class="comment">// the reference count on mNativeObject.  Either way, it is</span></span><br><span class="line">        <span class="comment">// not necessary to call nativeRelease() here.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        mName = source.readString();</span><br><span class="line">        mIsSingleBuffered = source.readInt() != <span class="number">0</span>;</span><br><span class="line">        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Activity可以有一个或多个Surface，默认情况下一个Activity只有一个Surface，当Activity中使用SurfaceView时，就存在多个Surface。Activity默认surface是在relayoutWindow过程中由WMS服务创建的，然后回传给应用程序进程，我们知道一个Surface其实就是应用程序端的本地窗口，关于Surface的初始化过程这里就不在介绍。</p><h4 id="4-2-4-2、生产者Producer构造过程"><a href="#4-2-4-2、生产者Producer构造过程" class="headerlink" title="4.2.4.2、生产者Producer构造过程"></a>4.2.4.2、生产者Producer构造过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br></pre></td></tr></table></figure><p>实例化BufferQueueProducer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueProducer::BufferQueueProducer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName(),</span><br><span class="line">    mStickyTransform(<span class="number">0</span>),</span><br><span class="line">    mLastQueueBufferFence(Fence::NO_FENCE),</span><br><span class="line">    mCallbackMutex(),</span><br><span class="line">    mNextCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCurrentCallbackTicket(<span class="number">0</span>),</span><br><span class="line">    mCallbackCondition(),</span><br><span class="line">    mDequeueTimeout(<span class="number">-1</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-3、消费者Consumer构造过程"><a href="#4-2-4-3、消费者Consumer构造过程" class="headerlink" title="4.2.4.3、消费者Consumer构造过程"></a>4.2.4.3、消费者Consumer构造过程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br></pre></td></tr></table></figure><p>实例化BufferQueueConsumer，这里初始化了mCore(core) 和 mSlots(core-&gt;mSlots)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueConsumer::BufferQueueConsumer(<span class="keyword">const</span> sp&lt;BufferQueueCore&gt;&amp; core) :</span><br><span class="line">    mCore(core),</span><br><span class="line">    mSlots(core-&gt;mSlots),</span><br><span class="line">    mConsumerName() &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-4、SurfaceFlinger设置监听"><a href="#4-2-4-4、SurfaceFlinger设置监听" class="headerlink" title="4.2.4.4、SurfaceFlinger设置监听"></a>4.2.4.4、SurfaceFlinger设置监听</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/16-Android-Graphics-App-Ask-SurfaceFlinger-ConsumeLisener-onFrameAvailable.png" alt="Markdown"></p><h4 id="4-2-4-5、应用程序本地窗口Surface创建过程"><a href="#4-2-4-5、应用程序本地窗口Surface创建过程" class="headerlink" title="4.2.4.5、应用程序本地窗口Surface创建过程"></a>4.2.4.5、应用程序本地窗口Surface创建过程</h4><p>从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？</p><p>为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。 [-&gt;SurfaceControl.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">Mutex::Autolock _l(mLock);</span><br><span class="line"><span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">    <span class="keyword">bool</span> controlledByApp)</span><br><span class="line">: mGraphicBufferProducer(bufferProducer),</span><br><span class="line">  mCrop(Rect::EMPTY_RECT),</span><br><span class="line">  mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">  mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">  mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">  mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">  mSharedBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">  mNextFrameNumber(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Initialize the ANativeWindow function pointers.</span></span><br><span class="line">ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">ANativeWindow::query            = hook_query;</span><br><span class="line">ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mReqWidth = <span class="number">0</span>;</span><br><span class="line">mReqHeight = <span class="number">0</span>;</span><br><span class="line">mReqFormat = <span class="number">0</span>;</span><br><span class="line">mReqUsage = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line">mSwapIntervalZero = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。</p><h4 id="4-2-4-5、执行窗口布局performLayout"><a href="#4-2-4-5、执行窗口布局performLayout" class="headerlink" title="4.2.4.5、执行窗口布局performLayout()"></a>4.2.4.5、执行窗口布局performLayout()</h4><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">                ......</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-7、执行窗口绘制performDraw"><a href="#4-2-4-7、执行窗口绘制performDraw" class="headerlink" title="4.2.4.7、执行窗口绘制performDraw()"></a>4.2.4.7、执行窗口绘制performDraw()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125;  ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Android是怎样将View画出来的？由于之前我们已经关闭了HWC、GPU、HWUI，这里只关注软件绘制。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于渲染这个流程很复杂，我们后续章节再分析。</p><h2 id="4-3、APP申请-lock-Buffer的过程"><a href="#4-3、APP申请-lock-Buffer的过程" class="headerlink" title="4.3、APP申请(lock)Buffer的过程"></a>4.3、APP申请(lock)Buffer的过程</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/17-Android-Graphics-App-SurfaceFlinger-lock-unlockpost.png" alt="Markdown"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        ......</span><br><span class="line">    &#125; ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看Surface的lockCanvas方法： [-&gt;Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mCanvas 变量直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    checkNotReleasedLocked();</span><br><span class="line">    ......</span><br><span class="line">    mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">    <span class="keyword">return</span> mCanvas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取java层的Surface保存的long型句柄</span></span><br><span class="line">sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取java层dirty Rect的位置大小信息</span></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">    dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">    dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">    dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">    dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ANativeWindow_Buffer outBuffer;</span><br><span class="line"> <span class="comment">//调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?</span><br><span class="line">                                     kOpaque_SkAlphaType : kPremul_SkAlphaType);</span><br><span class="line"></span><br><span class="line">SkBitmap bitmap;</span><br><span class="line"><span class="comment">//创建一个SkBitmap</span></span><br><span class="line"><span class="comment">//图形缓冲区每一行像素大小</span></span><br><span class="line"><span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">bitmap.setInfo(info, bpr);</span><br><span class="line"><span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    bitmap.setPixels(outBuffer.bits);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">    bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">    nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">            dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">sp&lt;Surface&gt; lockedSurface(surface);</span><br><span class="line">lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line"><span class="keyword">return</span> (jlong) lockedSurface.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码逻辑主要如下： 1）获取java层dirty 的Rect大小和位置信息； 2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer； 3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象； 4）将剪裁位置大小信息赋给java层Canvas对象。</p><h3 id="4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程"><a href="#4-3-1、Surface管理图形缓冲区-APP申请-lock-Buffer的过程" class="headerlink" title="4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程"></a>4.3.1、Surface管理图形缓冲区-APP申请(lock)Buffer的过程</h3><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。 [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::lock(</span><br><span class="line">    ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ANativeWindowBuffer* out;</span><br><span class="line"><span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//调用dequeueBuffer函数，申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">ALOGE_IF(err, <span class="string">"dequeueBuffer failed (%s)"</span>, strerror(-err));</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">//获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer</span></span><br><span class="line">    sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">//如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集，</span></span><br><span class="line">        <span class="comment">//然后将交集的结果设给需要去刷新的新区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.andSelf(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区</span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">    <span class="comment">//上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置</span></span><br><span class="line">    int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));</span><br><span class="line">    <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        Region oldDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span>(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            oldDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty())</span><br><span class="line">                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const Region copyback(oldDirtyRegion.subtract(newDirtyRegion));</span><br><span class="line">        <span class="keyword">if</span> (!copyback.isEmpty())</span><br><span class="line">        <span class="comment">//这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。</span></span><br><span class="line">            <span class="comment">//后续的绘画只要更新脏区域就可以了，这会节约不少资源</span></span><br><span class="line">            copyBlt(backBuffer, frontBuffer, copyback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we can't copy-back anything, modify the user's dirty</span></span><br><span class="line">        <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">        <span class="comment">//如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小，</span></span><br><span class="line">        <span class="comment">//然后去更新整个缓冲区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">//将新的dirty赋给这个bufferslot</span></span><br><span class="line">        mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">     <span class="comment">//lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，</span></span><br><span class="line">    <span class="comment">//例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突,</span></span><br><span class="line">    <span class="comment">//锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">            newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有： 1）调用connect函数完成一些初始化； 2）调用dequeueBuffer函数，申请图形缓冲区； 3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。 [-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::dequeueBuffer(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> reqWidth;</span><br><span class="line"><span class="keyword">uint32_t</span> reqHeight;</span><br><span class="line">PixelFormat reqFormat;</span><br><span class="line"><span class="keyword">uint32_t</span> reqUsage;</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence,</span><br><span class="line">        reqWidth, reqHeight, reqFormat, reqUsage);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据index获取缓冲区</span></span><br><span class="line">sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//由于申请的内存是在surfaceflinger进程中，</span></span><br><span class="line">    <span class="comment">//BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的，</span></span><br><span class="line">    <span class="comment">//Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//获取这个这个buffer对象的指针内容</span></span><br><span class="line">*buffer = gbuf.get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::requestBuffer(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line">Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。</p><h2 id="4-4、APP提交-unlockAndPost-Buffer的过程"><a href="#4-4、APP提交-unlockAndPost-Buffer的过程" class="headerlink" title="4.4、APP提交(unlockAndPost)Buffer的过程"></a>4.4、APP提交(unlockAndPost)Buffer的过程</h2><p>Surface绘制完毕后，unlockCanvasAndPost操作。 [-&gt;android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach the canvas from the surface</span></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock surface</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::unlockAndPost()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也比较简单，核心也是分两步： 1）解锁图形缓冲区，和前面的lockAsync成对出现； 2）queueBuffer去归还图形缓冲区； 所以我们还是重点分析第二步，查看queueBuffer的实现： [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::queueBuffer(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。 [-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::queueBuffer(<span class="keyword">int</span> slot,</span><br><span class="line">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 1）从传入的QueueBufferInput ，解析填充一些变量； 2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断； 3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem； 4）将BufferItem塞进mCore的mQueue队列，依照指定规则； 5）然后通知SurfaceFlinger去消费。 Folw：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/18-Android-Graphics-App-WMS-SurfaceFlinger-All-Flow.png" alt="Markdown"></p><h2 id="（五）、通知SF消费合成"><a href="#（五）、通知SF消费合成" class="headerlink" title="（五）、通知SF消费合成"></a>（五）、通知SF消费合成</h2><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。 listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现： [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; item) &#123;</span><br><span class="line"><span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">&#123; <span class="comment">// Autolock scope</span></span><br><span class="line">    ......</span><br><span class="line">    mQueueItems.push_back(item);</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">    mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">    mQueueItemCondition.broadcast();</span><br><span class="line">&#125;</span><br><span class="line">mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用MessageQueue的invalidate函数： [MessageQueue.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::invalidate() &#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴一下SurfaceFlinger的初始化请求vsync信号流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/19-Android-Graphics-vsync-surfaceflinger.png" alt="Markdown"></p><p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX;</span><br><span class="line">        ATRACE_INT(<span class="string">"FrameMissed"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">        <span class="keyword">if</span> (mPropagateBackpressure &amp;&amp; frameMissed) &#123;</span><br><span class="line">            signalLayerUpdate();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">        refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">        refreshNeeded |= mRepaintEverything;</span><br><span class="line">        <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">            <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">            <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">            <span class="comment">// repaint</span></span><br><span class="line">            signalRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">nsecs_t</span> refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">    mHadClientComposition = mHadClientComposition ||</span><br><span class="line">            mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    layer-&gt;releasePendingBuffer();</span><br><span class="line">&#125;</span><br><span class="line">mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要看下下面几个函数。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br></pre></td></tr></table></figure><h3 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h3><p>我们先来看第一个函数preComposition() [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::preComposition()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。 记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::addClientLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; lbc)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// add this layer to the current state list</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">if</span> (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(IInterface::asBinder(gbc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attach this layer to the client</span></span><br><span class="line">client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。 回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。</p><h2 id="1-1、每个Layer的onFrameAvailable函数"><a href="#1-1、每个Layer的onFrameAvailable函数" class="headerlink" title="1.1、每个Layer的onFrameAvailable函数"></a>1.1、每个Layer的onFrameAvailable函数</h2><p>onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。 [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Layer::onPreComposition() &#123;</span><br><span class="line">mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged || mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。 在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。 SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数 最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理 handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。</p><h2 id="1-2、绘制流程"><a href="#1-2、绘制流程" class="headerlink" title="1.2、绘制流程"></a>1.2、绘制流程</h2><p>用户进程更新Surface图像，将导致SurfaceFlinger中的Layer发送invalidate消息，处理该消息会调用handleTransaction函数和handlePageFilp函数来更新Layer对象。一旦VSync信号到来，再调用rebuildlayerStacks setUpHWComposer doComposition postComposition函数将所有Layer的图像混合后更新到显示设备上去。</p><h3 id="二、handleTransaction-handPageFlip更新Layer对象"><a href="#二、handleTransaction-handPageFlip更新Layer对象" class="headerlink" title="二、handleTransaction handPageFlip更新Layer对象"></a>二、handleTransaction handPageFlip更新Layer对象</h3><p>在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。</p><h2 id="2-1、handleTransaction函数"><a href="#2-1、handleTransaction函数" class="headerlink" title="2.1、handleTransaction函数"></a>2.1、handleTransaction函数</h2><p>handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数 handleTransactionLocked。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransaction(<span class="keyword">uint32_t</span> transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">Mutex::Autolock _l(mStateLock);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInTransaction = now;</span><br><span class="line"></span><br><span class="line">transactionFlags = getTransactionFlags(eTransactionMask);</span><br><span class="line">handleTransactionLocked(transactionFlags);</span><br><span class="line"></span><br><span class="line">mLastTransactionTime = systemTime() - now;</span><br><span class="line">mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">invalidateHwcGeometry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。 handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。</p><h2 id="2-2、Layer的doTransaction函数"><a href="#2-2、Layer的doTransaction函数" class="headerlink" title="2.2、Layer的doTransaction函数"></a>2.2、Layer的doTransaction函数</h2><p>下面是Layer的doTransaction函数代码 [Layer.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint32_t Layer::doTransaction(uint32_t flags) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">pushPendingState();<span class="comment">//上次绘制的State对象  </span></span><br><span class="line">Layer::State c = getCurrentState();<span class="comment">//当前使用的State对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layer::State&amp; s(getDrawingState());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool sizeChanged = (c.requested.w != s.requested.w) ||</span><br><span class="line">                         (c.requested.h != s.requested.h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">    <span class="comment">// the size changed, we need to ask our client to request a new buffer</span></span><br><span class="line">    <span class="comment">//如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸</span></span><br><span class="line">    <span class="comment">// record the new size, form this point on, when the client request</span></span><br><span class="line">    <span class="comment">// a buffer, it'll get the new size.</span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultBufferSize(</span><br><span class="line">            c.requested.w, c.requested.h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool resizePending = (c.requested.w != c.active.w) ||</span><br><span class="line">        (c.requested.h != c.active.h);</span><br><span class="line"><span class="keyword">if</span> (!isFixedSize()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resizePending &amp;&amp; mSidebandStream == NULL) &#123;</span><br><span class="line">    <span class="comment">//如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小  </span></span><br><span class="line">        flags |= eDontUpdateGeometryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有eDontUpdateGeometryState标志，更新active的值为request  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; eDontUpdateGeometryState)  &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Layer::State&amp; editCurrentState(getCurrentState());</span><br><span class="line">    <span class="keyword">if</span> (mFreezePositionUpdates) &#123;</span><br><span class="line">        <span class="keyword">float</span> tx = c.active.transform.tx();</span><br><span class="line">        <span class="keyword">float</span> ty = c.active.transform.ty();</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">        c.active.transform.set(tx, ty);</span><br><span class="line">        editCurrentState.active = c.active;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editCurrentState.active = editCurrentState.requested;</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前state的active和以前的State的active不等，设置更新标志  </span></span><br><span class="line"><span class="keyword">if</span> (s.active != c.active) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= Layer::eVisibleRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前state的sequence和以前state的sequence不等，设置更新标志</span></span><br><span class="line"><span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    <span class="keyword">this</span>-&gt;contentDirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we may use linear filtering, if the matrix scales us</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t type = c.active.transform.getType();</span><br><span class="line">    mNeedsFiltering = (!c.active.transform.preserveRects() ||</span><br><span class="line">            (type &gt;= Transform::SCALE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layer is hidden, signal and clear out all local sync points so</span></span><br><span class="line"><span class="comment">// that transactions for layers depending on this layer's frames becoming</span></span><br><span class="line"><span class="comment">// visible are not blocked</span></span><br><span class="line"><span class="keyword">if</span> (c.flags &amp; layer_state_t::eLayerHidden) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; point : mLocalSyncPoints) &#123;</span><br><span class="line">        point-&gt;setFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    mLocalSyncPoints.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line">commitTransaction(c);</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。 Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。 State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。 State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。 layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。 sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。 doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::commitTransaction(<span class="keyword">const</span> State&amp; stateToCommit) &#123;</span><br><span class="line">mDrawingState = stateToCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、handleTransactionLocked函数"><a href="#2-3、handleTransactionLocked函数" class="headerlink" title="2.3、handleTransactionLocked函数"></a>2.3、handleTransactionLocked函数</h3><p>下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析</p><p>2.3.1 处理Layer的事务 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransactionLocked(<span class="keyword">uint32_t</span> transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">currentLayers</span><span class="params">(mCurrentState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify all layers of available frames</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    currentLayers[i]-&gt;notifyAvailableFrames();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">        <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="keyword">if</span> (!trFlags) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">            mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象 这里用两个变量的目的是和Layer中使用两个变量是一样的。 上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true</p><h3 id="2-3-2、处理显示设备的变化"><a href="#2-3-2、处理显示设备的变化" class="headerlink" title="2.3.2、处理显示设备的变化"></a>2.3.2、处理显示设备的变化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">    <span class="comment">// here we take advantage of Vector's copy-on-write semantics to</span></span><br><span class="line">    <span class="comment">// improve performance by skipping the transaction entirely when</span></span><br><span class="line">    <span class="comment">// know that the lists are identical</span></span><br><span class="line">    <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">    <span class="keyword">if</span> (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cc = curr.size();</span><br><span class="line">              <span class="keyword">size_t</span> dc = draw.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the displays that were removed</span></span><br><span class="line">        <span class="comment">// (ie: in drawing state but not in current state)</span></span><br><span class="line">        <span class="comment">// also handle displays that changed</span></span><br><span class="line">        <span class="comment">// (ie: displays that are in both lists)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;dc ; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in drawing state but not in current state</span></span><br><span class="line">                <span class="keyword">if</span> (!draw[i].isMainDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Call makeCurrent() on the primary display so we can</span></span><br><span class="line">                    <span class="comment">// be sure that nothing associated with this display</span></span><br><span class="line">                    <span class="comment">// is current.</span></span><br><span class="line">                    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice());</span><br><span class="line">                    defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i)));</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    <span class="keyword">if</span> (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(draw[i].type, <span class="literal">false</span>);</span><br><span class="line">                    mDisplays.removeItem(draw.keyAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"trying to remove the main display"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// this display is in both lists. see if something changed.</span></span><br><span class="line">                <span class="keyword">const</span> DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; display(curr.keyAt(j));</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">                    <span class="comment">// changing the surface is like destroying and</span></span><br><span class="line">                    <span class="comment">// recreating the DisplayDevice, so we just remove it</span></span><br><span class="line">                    <span class="comment">// from the drawing state, so that it get re-added</span></span><br><span class="line">                    <span class="comment">// below.</span></span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display));</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    mDisplays.removeItem(display);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--; i--;</span><br><span class="line">                    <span class="comment">// at this point we must loop to the next item</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display));</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">                        disp-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((state.orientation != draw[i].orientation)</span><br><span class="line">                            || (state.viewport != draw[i].viewport)</span><br><span class="line">                            || (state.frame != draw[i].frame))</span><br><span class="line">                    &#123;</span><br><span class="line">                        disp-&gt;setProjection(state.orientation,</span><br><span class="line">                                state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">                        disp-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find displays that were added</span></span><br><span class="line">        <span class="comment">// (ie: in current state but not in drawing state)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;cc ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (draw.indexOfKey(curr.keyAt(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> DisplayDeviceState&amp; <span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">                sp&lt;DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer,</span><br><span class="line">                        <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int32_t</span> hwcDisplayId = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Virtual displays without a surface are dormant:</span></span><br><span class="line">                    <span class="comment">// they have external state (layer stack, projection,</span></span><br><span class="line">                    <span class="comment">// etc.) but no internal state (i.e. a DisplayDevice).</span></span><br><span class="line">                    <span class="keyword">if</span> (state.surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">                        DisplayUtils* displayUtils = DisplayUtils::getInstance();</span><br><span class="line">                        <span class="keyword">int</span> status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">"Unable to query width (%d)"</span>, status);</span><br><span class="line">                        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">                        status = state.surface-&gt;query(</span><br><span class="line">                            NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                            <span class="string">"Unable to query height (%d)"</span>, status);</span><br><span class="line">                        <span class="keyword">if</span> (MAX_VIRTUAL_DISPLAY_DIMENSION == <span class="number">0</span> ||</span><br><span class="line">                            (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp;</span><br><span class="line">                             height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> usage = <span class="number">0</span>;</span><br><span class="line">                            status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage);</span><br><span class="line">                            ALOGW_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">"Unable to query usage (%d)"</span>, status);</span><br><span class="line">                            <span class="keyword">if</span> ( (status == NO_ERROR) &amp;&amp;</span><br><span class="line">                                  displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123;</span><br><span class="line">                                hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface,</span><br><span class="line">                                dispSurface, producer, bqProducer, bqConsumer,</span><br><span class="line">                                state.displayName, state.isSecure, state.type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE_IF(state.surface!=<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="string">"adding a supported display, but rendering "</span></span><br><span class="line">                            <span class="string">"surface is provided (%p), ignoring it"</span>,</span><br><span class="line">                            state.surface.get());</span><br><span class="line">                    hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                    <span class="comment">// for supported (by hwc) displays we provide our</span></span><br><span class="line">                    <span class="comment">// own rendering surface</span></span><br><span class="line">                    dispSurface = <span class="keyword">new</span> FramebufferSurface(*mHwc, state.type,</span><br><span class="line">                            bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; display(curr.keyAt(i));</span><br><span class="line">                <span class="keyword">if</span> (dispSurface != <span class="literal">NULL</span> &amp;&amp; producer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                            state.type, hwcDisplayId,</span><br><span class="line">                            mHwc-&gt;getFormat(hwcDisplayId), state.isSecure,</span><br><span class="line">                            display, dispSurface, producer,</span><br><span class="line">                            mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">                    hw-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    hw-&gt;setProjection(state.orientation,</span><br><span class="line">                            state.viewport, state.frame);</span><br><span class="line">                    hw-&gt;setDisplayName(state.displayName);</span><br><span class="line">                    <span class="comment">// When a new display device is added update the active</span></span><br><span class="line">                    <span class="comment">// config by querying HWC otherwise the default config</span></span><br><span class="line">                    <span class="comment">// (config 0) will be used.</span></span><br><span class="line">                    <span class="keyword">if</span> (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp;</span><br><span class="line">                            hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123;</span><br><span class="line">                        <span class="keyword">int</span> activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId);</span><br><span class="line">                        <span class="keyword">if</span> (activeConfig &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            hw-&gt;setActiveConfig(activeConfig);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDisplays.add(display, hw);</span><br><span class="line">                    <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hwcDisplayId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId,</span><br><span class="line">                                    hw-&gt;getWidth(), hw-&gt;getHeight(),</span><br><span class="line">                                    hw-&gt;getFormat());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(state.type, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是处理显示设备的变化，分成3种情况： 1.显示设备减少了，需要把显示设备对应的DisplayDevice移除 2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性 3.显示设备增加了，创建新的DisplayDevice加入系统中。</p><h3 id="2-3-3、设置TransfromHit"><a href="#2-3-3、设置TransfromHit" class="headerlink" title="2.3.3、设置TransfromHit"></a>2.3.3、设置TransfromHit</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; disp;</span><br><span class="line">    <span class="keyword">uint32_t</span> currentlayerStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> we rely on the fact that layers are sorted by</span></span><br><span class="line">        <span class="comment">// layerStack first (so we don't have to traverse the list</span></span><br><span class="line">        <span class="comment">// of displays for every layer).</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">        <span class="keyword">uint32_t</span> layerStack = layer-&gt;getDrawingState().layerStack;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || currentlayerStack != layerStack) &#123;</span><br><span class="line">            currentlayerStack = layerStack;</span><br><span class="line">            <span class="comment">// figure out if this layerstack is mirrored</span></span><br><span class="line">            <span class="comment">// (more than one display) if so, pick the default display,</span></span><br><span class="line">            <span class="comment">// if not, pick the only display it's on.</span></span><br><span class="line">            disp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">                sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">                <span class="keyword">if</span> (hw-&gt;getLayerStack() == currentlayerStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        disp = hw;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        disp = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> TEMPORARY FIX ONLY. Real fix should cause layers to</span></span><br><span class="line">            <span class="comment">// redraw after transform hint changes. See bug 8508397.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// could be null when this layer is using a layerStack</span></span><br><span class="line">            <span class="comment">// that is not visible on any display. Also can occur at</span></span><br><span class="line">            <span class="comment">// screen off/on times.</span></span><br><span class="line">            disp = getDefaultDisplayDevice();</span><br><span class="line">        &#125;</span><br><span class="line">        layer-&gt;updateTransformHint(disp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。</p><h3 id="2-3-4、处理Layer增加情况"><a href="#2-3-4、处理Layer增加情况" class="headerlink" title="2.3.4、处理Layer增加情况"></a>2.3.4、处理Layer增加情况</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform our own transaction if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (currentLayers.size() &gt; layers.size()) &#123;</span><br><span class="line">    <span class="comment">// layers have been added</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some layers might have been removed, so</span></span><br><span class="line"><span class="comment">// we need to update the regions they're exposing.</span></span><br><span class="line"><span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">    mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        <span class="keyword">if</span> (currentLayers.indexOf(layer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could traverse the tree from front to back and</span></span><br><span class="line">            <span class="comment">//       compute the actual visible region</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could cache the transformed region</span></span><br><span class="line">            const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">            Region visibleReg = s.active.transform.transform(</span><br><span class="line">                    Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">            invalidateLayerStack(s.layerStack, visibleReg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。</p><h3 id="2-3-5、设置mDrawingState"><a href="#2-3-5、设置mDrawingState" class="headerlink" title="2.3.5、设置mDrawingState"></a>2.3.5、设置mDrawingState</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">commitTransaction();</span><br><span class="line">updateCursorAsync();</span><br></pre></td></tr></table></figure><p>调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。</p><p>2.3.6 小结 handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。</p><h2 id="2-4、handlePageFlip函数"><a href="#2-4、handlePageFlip函数" class="headerlink" title="2.4、handlePageFlip函数"></a>2.4、handlePageFlip函数</h2><p>handlePageFlip函数代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">Region dirtyRegion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the set of layers that need updates. This set must not change as</span></span><br><span class="line"><span class="comment">// buffers are being latched, as this could result in a deadlock.</span></span><br><span class="line"><span class="comment">// Example: Two producers share the same command stream and:</span></span><br><span class="line"><span class="comment">// 1.) Layer 0 is latched</span></span><br><span class="line"><span class="comment">// 2.) Layer 0 gets a new frame</span></span><br><span class="line"><span class="comment">// 2.) Layer 1 gets a new frame</span></span><br><span class="line"><span class="comment">// 3.) Layer 1 is latched.</span></span><br><span class="line"><span class="comment">// Display is now waiting on Layer 1's frame, which is behind layer 0's</span></span><br><span class="line"><span class="comment">// second frame. But layer 0's second frame could be waiting on display.</span></span><br><span class="line">Vector&lt;Layer*&gt; layersWithQueuedFrames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layers.size(); i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;hasQueuedFrame()) &#123;</span><br><span class="line">        frameQueued = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">            layersWithQueuedFrames.push_back(layer.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layer-&gt;useEmptyDamage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123;</span><br><span class="line">    Layer* layer = layersWithQueuedFrames[i];</span><br><span class="line">    const Region dirty(layer-&gt;latchBuffer(visibleRegions));</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">    invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line"><span class="comment">// queued frame that shouldn't be displayed during this vsync period, wake</span></span><br><span class="line"><span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line"><span class="keyword">return</span> !layersWithQueuedFrames.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。 我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1. 继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。 下面我们看看latchBuffer函数</p><p>LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。 如果不需要推迟处理，把mQueuedFrames的值减1. 最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。</p><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><p>这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。</p><h2 id="三、rebuildLayerStacks函数"><a href="#三、rebuildLayerStacks函数" class="headerlink" title="三、rebuildLayerStacks函数"></a>三、rebuildLayerStacks函数</h2><p>前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::rebuildLayerStacks() &#123;</span><br><span class="line">updateExtendedMode();</span><br><span class="line"><span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line"><span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">    invalidateHwcGeometry();</span><br><span class="line">    <span class="comment">//计算每个显示设备上可见的Layer  </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        Region opaqueRegion;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">        Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">        const Transform&amp; tr(hw-&gt;getTransform());</span><br><span class="line">        const Rect bounds(hw-&gt;getBounds());</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="comment">//计算每个layer的可见区域，确定设备需要重新绘制的区域  </span></span><br><span class="line">            computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers,</span><br><span class="line">                    hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//只需要和显示设备的LayerStack相同的layer  </span></span><br><span class="line">                    <span class="function">Region <span class="title">drawRegion</span><span class="params">(tr.transform(</span></span></span><br><span class="line">                            layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                    drawRegion.andSelf(bounds);</span><br><span class="line">                    <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果Layer的显示区域和显示设备的窗口有交集  </span></span><br><span class="line">                        <span class="comment">//把Layer加入列表中</span></span><br><span class="line">                        layersSortedByZ.add(layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置显示设备的可见Layer列表  </span></span><br><span class="line">        hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">        hw-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line">        hw-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。 computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。 而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。 其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。</p><h3 id="四、setUpHWComposer函数"><a href="#四、setUpHWComposer函数" class="headerlink" title="四、setUpHWComposer函数"></a>四、setUpHWComposer函数</h3><p>setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setUpHWComposer() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到系统HWComposer对象  </span></span><br><span class="line">HWComposer&amp; hwc(getHwComposer());</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// build the h/w work list</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;</span><br><span class="line">        mHwWorkListDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                    hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">                <span class="comment">//根据Layer数量在HWComposer中创建hwc_layer_list_t列表  </span></span><br><span class="line">                <span class="keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;</span><br><span class="line">                    HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                    <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                        layer-&gt;setGeometry(hw, *cur);</span><br><span class="line">                        <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;</span><br><span class="line">                            cur-&gt;setSkip(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the per-frame data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> freezeSurfacePresent = <span class="literal">false</span>;</span><br><span class="line">            isfreezeSurfacePresent(freezeSurfacePresent, hw, id);</span><br><span class="line">            <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * update the per-frame h/w composer data for each layer</span></span><br><span class="line"><span class="comment">                 * and build the transparent region of the FB</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                <span class="comment">//将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">                layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">                setOrientationEventControl(freezeSurfacePresent,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If possible, attempt to use the cursor overlay on each display.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isPotentialCursor()) &#123;</span><br><span class="line">                    cur-&gt;setIsCursorLayerHint();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = hwc.prepare();</span><br><span class="line">    ALOGE_IF(err, <span class="string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        hw-&gt;prepareFrame(hwc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。 setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组 创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。 HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。</p><h3 id="五、合成所有层的图像-（doComposition-函数）"><a href="#五、合成所有层的图像-（doComposition-函数）" class="headerlink" title="五、合成所有层的图像 （doComposition()函数）"></a>五、合成所有层的图像 （doComposition()函数）</h3><p>doComposition函数是合成所有层的图像，代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doComposition() &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen's coordinate space</span></span><br><span class="line">        const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        hw-&gt;dirtyRegion.clear();</span><br><span class="line">        hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">        hw-&gt;swapRegion.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inform the h/w that we're done compositing</span></span><br><span class="line">    hw-&gt;compositionComplete();</span><br><span class="line">&#125;</span><br><span class="line">postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">    <span class="keyword">const</span> Region&amp; inDirtyRegion)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line"><span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line"><span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line"><span class="comment">// 2) There is work to be done (the dirty region isn't empty)</span></span><br><span class="line"><span class="keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">    ALOGV(<span class="string">"Skipping display composition"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGV(<span class="string">"doDisplayComposition"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the invalid region</span></span><br><span class="line"><span class="comment">//swapRegion设置为需要更新的区域  </span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flags = hw-&gt;getFlags();<span class="comment">//获得显示设备支持的更新方式标志  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">    <span class="comment">// we can redraw only what's dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">    <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">    <span class="comment">// rectangle in that case</span></span><br><span class="line">    dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;<span class="comment">//支持部分更新  </span></span><br><span class="line">        <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">        <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">        <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">        <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">        <span class="comment">//将更新区域调整为整个窗口大小  </span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;bounds());</span><br><span class="line">        hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合成  </span></span><br><span class="line"><span class="keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"><span class="comment">//没有硬件composer的情况，输出图像</span></span><br><span class="line"><span class="comment">// swap buffers (presentation)</span></span><br><span class="line">hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。 真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。 合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。</p><h3 id="六、postFramebuffer-函数"><a href="#六、postFramebuffer-函数" class="headerlink" title="六、postFramebuffer()函数"></a>六、postFramebuffer()函数</h3><p>上一节的doComposition函数最后调用了postFramebuffer函数，代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::postFramebuffer()</span><br><span class="line">&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line">HWComposer&amp; hwc(getHwComposer());</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">        <span class="comment">// EGL spec says:</span></span><br><span class="line">        <span class="comment">//   "surface must be bound to the calling thread's current context,</span></span><br><span class="line">        <span class="comment">//    for the current rendering API."</span></span><br><span class="line">        getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">    &#125;</span><br><span class="line">    hwc.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the default display current because the VirtualDisplayDevice code cannot</span></span><br><span class="line"><span class="comment">// deal with dequeueBuffer() being called outside of the composition loop; however</span></span><br><span class="line"><span class="comment">// the code below can call glFlush() which is allowed (and does in some case) call</span></span><br><span class="line"><span class="comment">// dequeueBuffer().</span></span><br><span class="line">getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">    hw-&gt;onSwapBuffersCompleted(hwc);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">    <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt;=<span class="number">0</span> &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">mDebugInSwapBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();</span><br><span class="line"><span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">    logFrameStats();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。如果支持硬件composer，postFramebuffer函数将调用HWComposer的commit函数继续执行。 [HWComposer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::commit() &#123;</span><br><span class="line"><span class="keyword">int</span> err = NO_ERROR;</span><br><span class="line"><span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="comment">// On version 1.0, the OpenGL ES target surface is communicated</span></span><br><span class="line">        <span class="comment">// by the (dpy, sur) fields and we are guaranteed to have only</span></span><br><span class="line">        <span class="comment">// a single display.</span></span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;dpy = eglGetCurrentDisplay();</span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;sur = eglGetCurrentSurface(EGL_DRAW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (disp.outbufHandle) &#123;</span><br><span class="line">            mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">            mLists[i]-&gt;outbufAcquireFenceFd =</span><br><span class="line">                    disp.outbufAcquireFence-&gt;dup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = mHwc-&gt;<span class="built_in">set</span>(mHwc, mNumDisplays, mLists);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        disp.lastDisplayFence = disp.lastRetireFence;</span><br><span class="line">        disp.lastRetireFence = Fence::NO_FENCE;</span><br><span class="line">        <span class="keyword">if</span> (disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disp.<span class="built_in">list</span>-&gt;retireFenceFd != <span class="number">-1</span>) &#123;</span><br><span class="line">                disp.lastRetireFence = <span class="keyword">new</span> Fence(disp.<span class="built_in">list</span>-&gt;retireFenceFd);</span><br><span class="line">                disp.<span class="built_in">list</span>-&gt;retireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            disp.<span class="built_in">list</span>-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">status_t</span>)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合成效果图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/20-Android-Graphics-SurfaceFlinger-composition.png" alt="Markdown"></p><h2 id="（六）、Android-SurfaceFlinger-VSync工作原理"><a href="#（六）、Android-SurfaceFlinger-VSync工作原理" class="headerlink" title="（六）、Android SurfaceFlinger - VSync工作原理"></a>（六）、Android SurfaceFlinger - VSync工作原理</h2><h3 id="一、VSYNC-总体概念"><a href="#一、VSYNC-总体概念" class="headerlink" title="一、VSYNC 总体概念"></a>一、VSYNC 总体概念</h3><h3 id="6-1-1、VSYNC-概念"><a href="#6-1-1、VSYNC-概念" class="headerlink" title="6.1.1、VSYNC 概念"></a>6.1.1、VSYNC 概念</h3><p>VSYNC（Vertical Synchronization）是一个相当古老的概念，对于游戏玩家，它有一个更加大名鼎鼎的中文名字—垂直同步。 “垂直同步(vsync)”指的是显卡的输出帧数和屏幕的垂直刷新率相同，这完全是一个CRT显示器上的概念。其实无论是VSYNC还是垂直同步这个名字，因为LCD根本就没有垂直扫描的这种东西，因此这个名字本身已经没有意义。但是基于历史的原因，这个名称在图形图像领域被沿袭下来。 在当下，垂直同步的含义我们可以理解为，使得显卡生成帧的速度和屏幕刷新的速度的保持一致。举例来说，如果屏幕的刷新率为60Hz，那么生成帧的速度就应该被固定在1/60 s。</p><h3 id="6-1-2、Android-VSYNC-–-黄油计划"><a href="#6-1-2、Android-VSYNC-–-黄油计划" class="headerlink" title="6.1.2、Android VSYNC – 黄油计划"></a>6.1.2、Android VSYNC – 黄油计划</h3><p>谷歌为解决Android系统流畅性问题。在4.1版本引入了一个重大的改进–Project Butter黄油计划。 Project Butter对Android Display系统进行了重构，引入了三个核心元素，即VSYNC、Triple Buffer和Choreographer。 VSYNC最重要的作用是防止出现画面撕裂（screentearing）。所谓画面撕裂，就是指一个画面上出现了两帧画面的内容，如下图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/21-Android-graphics-view-teaning.png" alt="Markdown"></p><p>为什么会出现这种情况呢？这种情况一般是因为显卡输出帧的速度高于显示器的刷新速度，导致显示器并不能及时处理输出的帧，而最终出现了多个帧的画面都留在了显示器上的问题。这也就是我们所说的画面撕裂。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/22-Android-Graphics-Draw-whithout-vsync.png" alt="Markdown"></p><p>这个图中有三个元素，Display是显示屏幕，GPU和CPU负责渲染帧数据，每个帧以方框表示，并以数字进行编号，如0、1、2等等。VSync用于指导双缓冲区的交换。 以时间的顺序来看下将会发生的异常： Step1. Display显示第0帧数据，此时CPU和GPU渲染第1帧画面，而且赶在Display显示下一帧前完成 Step2. 因为渲染及时，Display在第0帧显示完成后，也就是第1个VSync后，正常显示第1帧 Step3. 由于某些原因，比如CPU资源被占用，系统没有及时地开始处理第2帧，直到第2个VSync快来前才开始处理 Step4. 第2个VSync来时，由于第2帧数据还没有准备就绪，显示的还是第1帧。这种情况被Android开发组命名为”Jank”。 Step5. 当第2帧数据准备完成后，它并不会马上被显示，而是要等待下一个VSync。 所以总的来说，就是屏幕平白无故地多显示了一次第1帧。原因大家应该都看到了，就是CPU没有及时地开始着手处理第2帧的渲染工作，以致”延误军机”。</p><p>其实总结上面的这个情况之所以发生，首先的原因就在于第二帧没有及时的绘制（当然即使第二帧及时绘制，也依然可能出现Jank，这就是同时引入三重缓冲的作用。我们将在三重缓冲一节中再讲解这种情况）。那么如何使得第二帧即使被绘制呢？ 这就是我们在Graphic系统中引入VSYNC的原因，考虑下面这张图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/23-Android-Graphics-Draw-whit-vsync.png" alt="Markdown"></p><p>如上图所示，一旦VSync出现后，立刻就开始执行下一帧的绘制工作。这样就可以大大降低Jank出现的概率。另外，VSYNC引入后，要求绘制也只能在收到VSYNC消息之后才能进行，因此，也就杜绝了另外一种极端情况的出现—CPU（GPU）一直不停的进行绘制，帧的生成速度高于屏幕的刷新速度，导致生成的帧不能被显示，只能丢弃，这样就出现了丢帧的情况—引入VSYNC后，绘制的速度就和屏幕刷新的速度保持一致了。</p><h3 id="二、VSync信号产生"><a href="#二、VSync信号产生" class="headerlink" title="二、VSync信号产生"></a>二、VSync信号产生</h3><p>那么VSYNC信号是如何生成的呢？ Android系统中VSYNC信号分为两种，一种是硬件生成的信号，一种是软件模拟的信号。 硬件信号是由HardwareComposer提供的，HWC封装了相关的HAL层，如果硬件厂商提供的HAL层实现能定时产生VSYNC中断，则直接使用硬件的VSYNC中断，否则HardwareComposer内部会通过VSyncThread来模拟产生VSYNC中断（其实现很简单，就是sleep固定时间，然后唤醒）。</p><p>SurfaceFlinger的启动过程中inti()会创建一个HWComposer对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">"debug.sf.no_hw_vsync"</span>, value, <span class="string">"0"</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don't need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don't have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">HWComposer::HWComposer(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,  </span><br><span class="line">        EventHandler&amp; handler)  </span><br><span class="line">    : mFlinger(flinger),  </span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),  </span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),  </span><br><span class="line">      mEventHandler(handler),  </span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">...  </span><br><span class="line">    <span class="comment">//首先是一些和VSYNC有关的信息的初始化  </span></span><br><span class="line">    <span class="comment">//因为在硬件支持的情况下，VSYNC的功能就是由HWC提供的  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123;  </span><br><span class="line">        mLastHwVSync[i] = <span class="number">0</span>;  </span><br><span class="line">        mVSyncCounts[i] = <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//根据配置来看是否需要模拟VSYNC消息  </span></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];  </span><br><span class="line">    property_get(<span class="string">"debug.sf.no_hw_vsync"</span>, value, <span class="string">"0"</span>);  </span><br><span class="line">    mDebugForceFakeVSync = atoi(value);  </span><br><span class="line">    ...  </span><br><span class="line">    <span class="comment">// don't need a vsync thread if we have a hardware composer  </span></span><br><span class="line">    needVSyncThread = <span class="literal">false</span>;  </span><br><span class="line">    <span class="comment">// always turn vsync off when we start,只是暂时关闭信号，后面会再开启  </span></span><br><span class="line">    eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, <span class="number">0</span>);      </span><br><span class="line"></span><br><span class="line">    <span class="comment">//显然，如果需要模拟VSync信号的话，我们需要线程来做这个工作  </span></span><br><span class="line">    <span class="keyword">if</span> (needVSyncThread) &#123;  </span><br><span class="line">        <span class="comment">// we don't have VSYNC support, we need to fake it  </span></span><br><span class="line">        <span class="comment">//VSyncThread类的实现很简单，无非就是一个计时器而已，定时发送消息而已  </span></span><br><span class="line">        <span class="comment">//TODO VSYNC专题  </span></span><br><span class="line">        mVSyncThread = <span class="keyword">new</span> VSyncThread(*<span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下上面这段代码。 首先mDebugForceFakeVSync是为了调制，可以通过这个变量设置强制使用软件VSYNC模拟。 然后针对不同的屏幕，初始化了他们的mLastHwVSync和mVSyncCounts值。 如果硬件支持，那么就把needVSyncThread设置为false，表示不需要软件模拟。 接着通过eventControl来暂时的关闭了VSYNC信号，这一点将在下面讲解eventControl时一并讲解。 最后，如果需要软件模拟Vsync信号的话，那么我们将通过一个单独的VSyncThread线程来做这个工作(fake VSYNC是这个线程唯一的作用)。我们来看下这个线程。</p><p><strong>软件模拟</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> HWComposer::VSyncThread::threadLoop() &#123;  </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> period = mRefreshPeriod;  </span><br><span class="line">    <span class="comment">//当前的时间  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime(CLOCK_MONOTONIC);  </span><br><span class="line">    <span class="comment">//下一次VSYNC到来的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> next_vsync = mNextFakeVSync;  </span><br><span class="line">    <span class="comment">//为了等待下个时间到来应该休眠的时间  </span></span><br><span class="line">    <span class="keyword">nsecs_t</span> sleep = next_vsync - now;  </span><br><span class="line">    <span class="comment">//错过了VSYNC的时间  </span></span><br><span class="line">    <span class="keyword">if</span> (sleep &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// we missed, find where the next vsync should be  </span></span><br><span class="line">        <span class="comment">//重新计算下应该休息的时间  </span></span><br><span class="line">        sleep = (period - ((now - next_vsync) % period));  </span><br><span class="line">        <span class="comment">//更新下次VSYNC的时间  </span></span><br><span class="line">        next_vsync = now + sleep;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//更新下下次VSYNC的时间  </span></span><br><span class="line">    mNextFakeVSync = next_vsync + period;  </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">spec</span>;</span>  </span><br><span class="line">    spec.tv_sec  = next_vsync / <span class="number">1000000000</span>;  </span><br><span class="line">    spec.tv_nsec = next_vsync % <span class="number">1000000000</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err;  </span><br><span class="line">    <span class="keyword">do</span> &#123;  </span><br><span class="line">        <span class="comment">//纳秒精度级的休眠  </span></span><br><span class="line">        err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>);  </span><br><span class="line">    &#125; <span class="keyword">while</span> (err&lt;<span class="number">0</span> &amp;&amp; errno == EINTR);  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">//休眠之后，到了该发生VSYNC的时间了  </span></span><br><span class="line">        mHwc.mEventHandler.onVSyncReceived(<span class="number">0</span>, next_vsync);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数其实很简单，无非就是一个简单的时间计算，计算过程我已经写在了程序注释里面。总之到了应该发生VSYNC信号的时候，就调用了mHwc.mEventHandler.onVSyncReceived(0, next_vsync)函数来通知VSYNC的到来。</p><p>我们注意到mEventHandler实际上是在HWC创建时被传入的，我们来看下HWC创建时的代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mHwc = new HWComposer(this,  </span><br><span class="line">        *static_cast&lt;HWComposer::EventHandler *&gt;(this));  </span><br><span class="line"></span><br><span class="line">class SurfaceFlinger : public BnSurfaceComposer,  </span><br><span class="line">                   private IBinder::DeathRecipient,  </span><br><span class="line">                   private HWComposer::EventHandler</span><br></pre></td></tr></table></figure><p>可以看到这个mEventHandler实际上就是SurfaceFlinger。也就是说，VSYNC信号到来时，SurfaceFlinger的onVSyncReceived函数处理了这个消息。 这里我们暂时先不展开SurfaceFlinger内的逻辑处理，等我们下面分析完硬件实现后，一并进行分析</p><p><strong>硬件实现</strong> 上面我们讲了软件如何模拟一个VSYNC信号并通知SurfaceFlinger,那么硬件又是如何实现这一点的呢？ 我们再一次回到HWC的创建过程中来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mHwc) &#123;  </span><br><span class="line">       ALOGE(<span class="string">"Lee Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,  </span><br><span class="line">             (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);  </span><br><span class="line">       <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;  </span><br><span class="line">           mCBContext-&gt;hwc = <span class="keyword">this</span>;  </span><br><span class="line">           mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;  </span><br><span class="line">           mCBContext-&gt;procs.vsync = &amp;hook_vsync;  </span><br><span class="line">           <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;  </span><br><span class="line">           <span class="keyword">else</span>  </span><br><span class="line">               mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;  </span><br><span class="line">           <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));  </span><br><span class="line">           mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>来看下上面这段实现。 当HWC有vsync信号生成时，硬件模块会通过procs.vsync来通知软件部分，因此也就是调用了hook_vsync函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,  </span><br><span class="line">        <span class="keyword">int64_t</span> timestamp) &#123;  </span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(  </span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));  </span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp) &#123;  </span><br><span class="line">    <span class="comment">//只有真实的硬件设备才会产生VSYNC  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;  </span><br><span class="line">        &#123;  </span><br><span class="line">            mLastHwVSync[disp] = timestamp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现最后殊途同归，硬件信号最终也通过onVSyncReceived函数通知到了SurfaceFlinger了。下面我们来分析下SurfaceFlinger的处理过程。</p><h3 id="三、Surfaceflinger对VSYNC消息的处理"><a href="#三、Surfaceflinger对VSYNC消息的处理" class="headerlink" title="三、Surfaceflinger对VSYNC消息的处理"></a>三、Surfaceflinger对VSYNC消息的处理</h3><p>先来直接看下Surfaceflinger的onVSyncReceived函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVSyncReceived(<span class="keyword">int32_t</span> type, <span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">bool</span> needsHwVsync = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// Scope for the lock</span></span><br><span class="line">        Mutex::Autolock _l(mHWVsyncLock);</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">0</span> &amp;&amp; mPrimaryHWVsyncEnabled) &#123;</span><br><span class="line">            needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsHwVsync) &#123;</span><br><span class="line">        enableHardwareVsync();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        disableHardwareVsync(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mPrimaryDispSync是什么？addResyncSample有什么作用？ 要回答这三个问题，我们首先还是得回到SurfaceFlinger的init函数中来。</p><h3 id="6-3-1、Surfaceflinger-init"><a href="#6-3-1、Surfaceflinger-init" class="headerlink" title="6.3.1、Surfaceflinger.init()"></a>6.3.1、Surfaceflinger.init()</h3><p>先看一下总体flow：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/24-Android-Graphics-Vsync-surfaceflinger.init.png" alt="Markdown"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void SurfaceFlinger::init() &#123;</span><br><span class="line">    ALOGI(  &quot;SurfaceFlinger&apos;s main thread ready to run. &quot;</span><br><span class="line">            &quot;Initializing graphics H/W...&quot;);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        // start the EventThread</span><br><span class="line">        sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                vsyncPhaseOffsetNs, true, &quot;app&quot;);</span><br><span class="line">        mEventThread = new EventThread(vsyncSrc, *this);</span><br><span class="line">        sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">                sfVsyncPhaseOffsetNs, true, &quot;sf&quot;);</span><br><span class="line">        mSFEventThread = new EventThread(sfVsyncSrc, *this);</span><br><span class="line">        mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mEventControlThread = new EventControlThread(this);</span><br><span class="line">    mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2个EventThread对象分别是mEventThread，给app用，mSFEventThread，给surfaceflinger自己用。 下面给出这4个Thread关系图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/25-Android-Graphics-SurfaceFlinger.init.DispSyncThread.png.png" alt="Markdown"></p><p>这两个DispSyncSource就是KK引入的重大变化。Android 4.4(KitKat)引入了VSync的虚拟化，即把硬件的VSync信号先同步到一个本地VSync模型中，再从中一分为二，引出两条VSync时间与之有固定偏移的线程。示意图如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/26-Android-Graphics-SurfaceFlinger-App-Vsync-offset.png.png" alt="Markdown"></p><p>Google这样修改的目的又是什么呢？ =在当前三重缓冲区的架构下，即对于一帧内容，先等App UI画完了，SurfaceFlinger再出场对其进行合并渲染后放入framebuffer，最后整到屏幕上。而现有的VSync模型是让大家一起开始干活。 这个架构其实会产生一个问题，因为App和SurfaceFlinger被同时唤醒，导致他们二者总是一起工作，必然导致VSync来临的时刻，这二者之间产生了CPU资源的抢占。因此，谷歌给这两个工作都加上一个小小的延迟，让这两个工作并不是同时被唤醒，这样大家就可以错开使用资源的高峰期，提高工作的效率。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/27-Android-graphics-SurfaceFlinger-Vsync-app-sf.png" alt="Markdown"></p><p>这两个延迟，其实就分别对应上面代码中的vsyncSrc（绘制延迟）和sfVsyncSrc（合成延迟）。 在创建了两个DispSyncSource变量后，我们使用它们来初始化了两个EventThread。下面我们来详细看下EventThread的创建流程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EventThread::EventThread(<span class="keyword">const</span> sp&lt;VSyncSource&gt;&amp; src, SurfaceFlinger&amp; flinger)</span><br><span class="line">    : mVSyncSource(src),</span><br><span class="line">      mFlinger(flinger),</span><br><span class="line">      mUseSoftwareVSync(<span class="literal">false</span>),</span><br><span class="line">      mVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mDebugVsyncEnabled(<span class="literal">false</span>),</span><br><span class="line">      mVsyncHintSent(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int32_t</span> i=<span class="number">0</span> ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123;</span><br><span class="line">        mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;</span><br><span class="line">        mVSyncEvent[i].header.id = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].header.timestamp = <span class="number">0</span>;</span><br><span class="line">        mVSyncEvent[i].vsync.count =  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigevent</span> <span class="title">se</span>;</span></span><br><span class="line">    se.sigev_notify = SIGEV_THREAD;</span><br><span class="line">    se.sigev_value.sival_ptr = <span class="keyword">this</span>;</span><br><span class="line">    se.sigev_notify_function = vsyncOffCallback;</span><br><span class="line">    se.sigev_notify_attributes = <span class="literal">NULL</span>;</span><br><span class="line">    timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> EventThread::onFirstRef() &#123;</span><br><span class="line">    run(<span class="string">"EventThread"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventThread的构造函数很简单。重点是它的onFirstRef函数启动了一个EventThread线程，于是下面的代码才是重点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> EventThread::threadLoop() &#123;</span><br><span class="line">    DisplayEventReceiver::Event event;</span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;</span><br><span class="line">    signalConnections = waitForEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dispatch events to listeners...</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = signalConnections.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; conn(signalConnections[i]);</span><br><span class="line">        <span class="comment">// now see if we still need to report this event</span></span><br><span class="line">        <span class="keyword">status_t</span> err = conn-&gt;postEvent(event);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数本身并不复杂，其中调用了一个waitForEvent的函数。这个函数相当之长，为了防止代码展开太多，我们这里暂时不再详细分析这个函数。我们目前只需要知道这个函数的最重要的作用是等待Event的到来，并且查找对event感兴趣的监听者，而在没有event到来时，线程处于休眠状态，等待event的唤醒（我们将下一篇VSYNC的接收和处理中展开分析这个函数）。 这样，EventThread线程就运行起来，处在等待被event唤醒的状态下。 <strong>MessageQueue和EventThread建立连接</strong> 简单说明完EventThread之后，我们再次回到SurfaceFlinger的init过程中来。回到init()函数代码中来： 将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接，这样SurfaceFlinger才能真正接收到来自HWC的VSYNC信号。 我们来看下这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::setEventThread(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)  </span><br><span class="line">&#123;  </span><br><span class="line">    mEventThread = eventThread;  </span><br><span class="line">    mEvents = eventThread-&gt;createEventConnection();  </span><br><span class="line">    mEventTube = mEvents-&gt;getDataChannel();  </span><br><span class="line">    mLooper-&gt;addFd(mEventTube-&gt;getFd(), <span class="number">0</span>, ALOOPER_EVENT_INPUT,  </span><br><span class="line">            MessageQueue::cb_eventReceiver, <span class="keyword">this</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里代码逻辑其实很简单，就是创建了一个到EventThread的连接，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。 <strong>向Eventhread注册一个事件的监听者—-createEventConnection</strong> 在SurfaceFlinger的init函数中，我们调用了mEventQueue.setEventThread(mSFEventThread)函数，我们在前面一章中已经提到过，这个函数将SurfaceFlinger的MessageQueue真正和我们刚才创建的EventThread建立起了连接。我们来看下这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));  </span><br><span class="line">&#125;  </span><br><span class="line">EventThread::Connection::Connection(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)  </span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())  </span><br><span class="line">&#123;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">void</span> EventThread::Connection::onFirstRef() &#123;  </span><br><span class="line">    mEventThread-&gt;registerDisplayEventConnection(<span class="keyword">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">status_t</span> EventThread::registerDisplayEventConnection(  </span><br><span class="line">        <span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;  </span><br><span class="line">    mDisplayEventConnections.add(connection);  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会导致一个Connection类的创建，而这个connection类会被保存在EventThread下的一个容器内。 通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p><h3 id="6-3-2、VSync信号的处理"><a href="#6-3-2、VSync信号的处理" class="headerlink" title="6.3.2、VSync信号的处理"></a>6.3.2、VSync信号的处理</h3><p>我们在前面一章也提到了无论是软件方式还是硬件方式，SurfaceFlinger收到VSync信号后，处理函数都是onVSyncReceived函数：</p><p><strong>VSync消息处理—-addResyncSample</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/28-Android-Graphics-SF-Vsync-addResyncSample.png.png" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> DispSync::addResyncSample(<span class="keyword">nsecs_t</span> timestamp) &#123;  </span><br><span class="line">    <span class="keyword">size_t</span> idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">    mResyncSamples[idx] = timestamp;  </span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    updateModelLocked();  </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗略浏览下这个函数，发现前半部分其实在做一些简单的计数统计，重点实现显然是updateModelLocked函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void DispSync::updateModelLocked() &#123;  </span><br><span class="line">    if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123;  </span><br><span class="line">        nsecs_t durationSum = 0;  </span><br><span class="line">        for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            durationSum += mResyncSamples[idx] - mResyncSamples[prev];  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        mPeriod = durationSum / (mNumResyncSamples - 1);  </span><br><span class="line"></span><br><span class="line">        double sampleAvgX = 0;  </span><br><span class="line">        double sampleAvgY = 0;  </span><br><span class="line">        double scale = 2.0 * M_PI / double(mPeriod);  </span><br><span class="line">        for (size_t i = 0; i &lt; mNumResyncSamples; i++) &#123;  </span><br><span class="line">            size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES;  </span><br><span class="line">            nsecs_t sample = mResyncSamples[idx];  </span><br><span class="line">            double samplePhase = double(sample % mPeriod) * scale;  </span><br><span class="line">            sampleAvgX += cos(samplePhase);  </span><br><span class="line">            sampleAvgY += sin(samplePhase);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        sampleAvgX /= double(mNumResyncSamples);  </span><br><span class="line">        sampleAvgY /= double(mNumResyncSamples);  </span><br><span class="line"></span><br><span class="line">        mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale);  </span><br><span class="line">        ......</span><br><span class="line">        mThread-&gt;updateModel(mPeriod, mPhase);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说，前面大段的数学计算让人有些困惑，我们暂且跳过，先分析下主线流程，也就是mThread-&gt;updateModel(mPeriod, mPhase)这个调用：</p><p><strong>DispSyncThread.updateModel的用途</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateModel</span><span class="params">(<span class="keyword">nsecs_t</span> period, <span class="keyword">nsecs_t</span> phase)</span> </span>&#123;  </span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">    mPeriod = period;  </span><br><span class="line">    mPhase = phase;  </span><br><span class="line">    mCond.signal();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updateModel是DispSyncThread类的函数，这个函数本身代码很短，其实它的主要作用是mCond.signal发送一个信号给等待中的线程。那么究竟是谁在等待这个条件呢？ 其实等待这个条件的正是DispSyncThread的循环函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">status_t</span> err;  </span><br><span class="line">      <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">      <span class="keyword">nsecs_t</span> nextEventTime = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">          Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">          <span class="keyword">nsecs_t</span> targetTime = <span class="number">0</span>;  </span><br><span class="line">          &#123; <span class="comment">// Scope for lock  </span></span><br><span class="line">              Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;  </span><br><span class="line">              ......</span><br><span class="line">              <span class="keyword">if</span> (mPeriod == <span class="number">0</span>) &#123;  </span><br><span class="line">                  err = mCond.wait(mMutex);  </span><br><span class="line">                  ......</span><br><span class="line">              &#125;  </span><br><span class="line">              nextEventTime = computeNextEventTimeLocked(now);  </span><br><span class="line">              targetTime = nextEventTime;  </span><br><span class="line">              ......</span><br><span class="line">              &#125;  </span><br><span class="line">              now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">              ......</span><br><span class="line">              callbackInvocations = gatherCallbackInvocationsLocked(now);  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">if</span> (callbackInvocations.size() &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">              fireCallbackInvocations(callbackInvocations);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>大量的时间相关的计算和状态的转变我们不再深入研究，我们来看下这个线程被通知唤醒之后做的两个主要的函数的处理，gatherCallbackInvocationsLocked()和fireCallbackInvocations()。</p><p>gatherCallbackInvocationsLocked()的代码其实很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(<span class="keyword">nsecs_t</span> now) &#123;  </span><br><span class="line">    Vector&lt;CallbackInvocation&gt; callbackInvocations;  </span><br><span class="line">    <span class="keyword">nsecs_t</span> ref = now - mPeriod;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mEventListeners.size(); i++) &#123;  </span><br><span class="line">        <span class="keyword">nsecs_t</span> t = computeListenerNextEventTimeLocked(mEventListeners[i],  </span><br><span class="line">                ref);  </span><br><span class="line">        <span class="keyword">if</span> (t &lt; now) &#123;  </span><br><span class="line">            CallbackInvocation ci;  </span><br><span class="line">            ci.mCallback = mEventListeners[i].mCallback;  </span><br><span class="line">            ci.mEventTime = t;  </span><br><span class="line">            callbackInvocations.push(ci);  </span><br><span class="line">            mEventListeners.editItemAt(i).mLastEventTime = t;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> callbackInvocations;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是从mEventListeners取出之前注册的事件监听者，放入callbackInvocations中，等待后面的调用。至于监听者从何处而来？在waitforevent时通过enableVSyncLocked注册的。</p><p>继续看下fireCallbackInvocations()函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireCallbackInvocations</span><span class="params">(<span class="keyword">const</span> Vector&lt;CallbackInvocation&gt;&amp; callbacks)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; callbacks.size(); i++) &#123;  </span><br><span class="line">        callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;`</span><br></pre></td></tr></table></figure><p>我们目前只分析主线的走向,接下来调用了DispSyncSource的onDispSyncEvent在：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onDispSyncEvent</span><span class="params">(<span class="keyword">nsecs_t</span> when)</span> </span>&#123;  </span><br><span class="line">        sp&lt;VSyncSource::Callback&gt; callback;  </span><br><span class="line">        &#123;  </span><br><span class="line">            callback = mCallback;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            callback-&gt;onVSyncEvent(when);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="keyword">void</span> EventThread::onVSyncEvent(<span class="keyword">nsecs_t</span> timestamp) &#123;  </span><br><span class="line">    Mutex::Autolock _l(mLock);  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.id = <span class="number">0</span>;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].header.timestamp = timestamp;  </span><br><span class="line">    mVSyncEvent[<span class="number">0</span>].vsync.count++;  </span><br><span class="line">    mCondition.broadcast();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到这里mCondition.broadcas发出了命令，那么EventThread中waitforEvent的等待就会被唤醒。而一旦唤醒，我们就回到了EventThread的loop中，我们来看下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool EventThread::threadLoop() &#123;  </span><br><span class="line">    DisplayEventReceiver::Event event;  </span><br><span class="line">    Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections;  </span><br><span class="line">    signalConnections = waitForEvent(&amp;event);  </span><br><span class="line"></span><br><span class="line">    // dispatch events to listeners...  </span><br><span class="line">    const size_t count = signalConnections.size();  </span><br><span class="line">    for (size_t i=0 ; i&lt;count ; i++) &#123;  </span><br><span class="line">        const sp&lt;Connection&gt;&amp; conn(signalConnections[i]);  </span><br><span class="line">        // now see if we still need to report this event  </span><br><span class="line">        status_t err = conn-&gt;postEvent(event);  </span><br><span class="line">        ......</span><br><span class="line">    &#125;  </span><br><span class="line">    return true;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是通过conn-&gt;postEvent来分发事件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventThread::Connection::postEvent(  </span><br><span class="line">        <span class="keyword">const</span> DisplayEventReceiver::Event&amp; event) &#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? <span class="keyword">status_t</span>(size) : <span class="keyword">status_t</span>(NO_ERROR);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">ssize_t</span> DisplayEventReceiver::sendEvents(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; dataChannel,  </span><br><span class="line">        Event <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">return</span> BitTube::sendObjects(dataChannel, events, count);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/29-Android-Graphics-App-SurfaceFlinger-Vsync-postEvent.png.png" alt="Markdown"></p><p>其实看到这里的BitTube我们就明白了，在本文开始时候我们提到：</p><p>通过createEventConnection这样一个简单的方法，我们其实就注册了一个事件的监听者，得到了发送VSYNC事件通知的BitTube，然后监控这个BitTube中的套接字，并且指定了收到通知后的回调函数，MessageQueue::cb_eventReceiver。这样一旦VSync信号传来，函数cb_eventReceiver将被调用。</p><p>所以我们这里可以来看看MessageQueue::cb_eventReceiver函数了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MessageQueue::cb_eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;  </span><br><span class="line">    MessageQueue* <span class="built_in">queue</span> = <span class="keyword">reinterpret_cast</span>&lt;MessageQueue *&gt;(data);  </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;eventReceiver(fd, events);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MessageQueue::eventReceiver(<span class="keyword">int</span> fd, <span class="keyword">int</span> events) &#123;  </span><br><span class="line">    <span class="keyword">ssize_t</span> n;  </span><br><span class="line">    DisplayEventReceiver::Event buffer[<span class="number">8</span>];  </span><br><span class="line">    <span class="keyword">while</span> ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, <span class="number">8</span>)) &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;n ; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123;  </span><br><span class="line">                mHandler-&gt;dispatchInvalidate();  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到收到消息之后MessageQueue对消息进行了分发，我们目前走的是dispatchInvalidate()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::dispatchInvalidate() &#123;  </span><br><span class="line">    <span class="keyword">if</span> ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == <span class="number">0</span>) &#123;  </span><br><span class="line">        mQueue.mLooper-&gt;sendMessage(<span class="keyword">this</span>, Message(MessageQueue::INVALIDATE));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;  </span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;  </span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:  </span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> REFRESH:  </span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> TRANSACTION:  </span><br><span class="line">            android_atomic_and(~eventMaskTransaction, &amp;mEventMask);  </span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;  </span><br><span class="line">    ATRACE_CALL();  </span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::TRANSACTION:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE:  </span><br><span class="line">        handleMessageTransaction();  </span><br><span class="line">        handleMessageInvalidate();  </span><br><span class="line">        signalRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH:  </span><br><span class="line">        handleMessageRefresh();  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了这里，就进入了SurfaceFlinger的处理流程，我们看到对于INVALIDATE的消息，实际上系统在处理过程中实际还是会发送一个Refresh消息。</p><h3 id="6-4、App向Eventhread注册一个事件的监听者–createEventConnection"><a href="#6-4、App向Eventhread注册一个事件的监听者–createEventConnection" class="headerlink" title="6.4、App向Eventhread注册一个事件的监听者–createEventConnection()"></a>6.4、App向Eventhread注册一个事件的监听者–createEventConnection()</h3><p>在ViewRootImpl的构造函数中会实例化Choreographer对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">                . . . . .</span><br><span class="line">        mChoreographer = Choreographer.getInstance();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在mChoreographer 的构造函数中实例化FrameDisplayEventReceiver对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Choreographer(Looper looper) &#123;</span><br><span class="line">               . . . . . .</span><br><span class="line">               mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在FrameDisplayEventReceiver的父类构造函数中会调用到，android_view_DisplayEventReceiver.cpp中的nativeInit方法,在nativeInit方法中有如下过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">        . . . . . .</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverWeak, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line">    . . . . . .</span><br></pre></td></tr></table></figure><p>创建NativeDisplayEventReceiver类 类型指针 在NativeDisplayEventReceiver的构造函数中会调用DisplayEventReceiver类的无参构造函数实例化成员mReceiver；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DisplayEventReceiver::DisplayEventReceiver() &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService());</span><br><span class="line">    <span class="keyword">if</span> (sf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mEventConnection = sf-&gt;createDisplayEventConnection();</span><br><span class="line">        <span class="keyword">if</span> (mEventConnection != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mDataChannel = mEventConnection-&gt;getDataChannel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中获取Surfaceflinger服务的代理对象，然后通过Binder IPC创建BpDisplayEventConnection对象 该函数经由BnSurfaceComposer.onTransact函数辗转调用到SurfaceFlinger.createDisplayEventConnection函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection() &#123;</span><br><span class="line">    <span class="keyword">return</span> mEventThread-&gt;createEventConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出现了熟悉的面孔mEventThread，该对象是一个EventThread对象，该对象在SurfaceFlinger.init函数里面创建，但是创建运行以后，貌似还没有进行任何的动作，这里调用createEventConnection函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Connection(<span class="keyword">const_cast</span>&lt;EventThread*&gt;(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后mEventConnection-&gt;getDataChannel()方法再次通过Binder IPC创建 BitTube对象mDataChannel ，在Binder IPC创建mDataChannel 过程中会从服务端EventThread::Connection::Connection中（在EventThread类中定义）接收一个socketpair创建的FIFO文件描述符；</p><p>EventThread::Connection::Connection创建描述符的代码： Connection构造函数调用BitTube的无参构造函数，在BitTube的构造函数中调用init函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BitTube::init(<span class="keyword">size_t</span> rcvbuf, <span class="keyword">size_t</span> sndbuf) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = DEFAULT_SOCKET_BUFFER_SIZE;</span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, <span class="keyword">sizeof</span>(rcvbuf));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, <span class="keyword">sizeof</span>(sndbuf));</span><br><span class="line">        <span class="comment">// sine we don't use the "return channel", we keep it small...</span></span><br><span class="line">        setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;size, <span class="keyword">sizeof</span>(size));</span><br><span class="line">        fcntl(sockets[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        fcntl(sockets[<span class="number">1</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">        mReceiveFd = sockets[<span class="number">0</span>];</span><br><span class="line">        mSendFd = sockets[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mReceiveFd = -errno;</span><br><span class="line">        ALOGE(<span class="string">"BitTube: pipe creation failed (%s)"</span>, strerror(-mReceiveFd));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到NativeDisplayEventReceiver类的父类DisplayEventDispatcher中的initialize()方法， 将BpDisplayEventConnection对象获取到的mDataChannel （BitTube类型）中的文件描述符添加到UI主线程Looper的epoll中， 当文件描述符中被写入数据时，该epoll_wait会被唤醒； 直接看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> NativeDisplayEventReceiver::initialize() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to initialize display event receiver, status=%d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的主要代码是mMessageQueue-&gt;getLooper()-&gt;addFd()这一行，其中的参数mReceiver.getFd()返回的是在创建NativeDisplayEventReceiver时从SurfaceFlinger服务端接收回来的socket接收端描述符，前面分析到 mMessageQueue是与当前应用线程关联的java层的MessageQueue对应的native层的MessageQueue对象，下面看一下Looper.addFd这个函数，上面调用时传进来的this指针对应的是一个NativeDisplayEventReceiver对象，该类继承了LooperCallback：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::addFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, Looper_callbackFunc callback, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">return</span> addFd(fd, ident, events, callback ? <span class="keyword">new</span> SimpleLooperCallback(callback) : <span class="literal">NULL</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Looper::addFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">int</span> epollEvents = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT;</span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Request request;</span><br><span class="line">        request.fd = fd;</span><br><span class="line">        request.ident = ident;</span><br><span class="line">        request.callback = callback;</span><br><span class="line">        request.data = data;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">// zero out unused members of data field union</span></span><br><span class="line">        eventItem.events = epollEvents;</span><br><span class="line">        eventItem.data.fd = fd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.add(fd, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem);</span><br><span class="line">            <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将上面传进来的NativeDisplayEventReceiver对象封装成一个SimpleLooperCallback对象，调用下面的addFd函数的时候主要步骤如下： （1）创建一个struct epoll_event结构体对象，将对应的内存全部用清0，并作对应的初始化； （2）查询通过addFd方法已经添加到epoll中监听的文件描述符； （3）查询不到的话，则调用epoll_ctl方法设置EPOLL_CTL_ADD属性将对应的文件描述符添加到epoll监听的描述符中； （4）根据前面addFd传入的参数EVENT_INPUT，说明当前应用线程的native层的Looper对象中的epoll机制已经开始监听来自于SurfaceFlinger服务端socket端的写入事件。</p><h3 id="6-5、App请求Vsync信号"><a href="#6-5、App请求Vsync信号" class="headerlink" title="6.5、App请求Vsync信号"></a>6.5、App请求Vsync信号</h3><p>前面讲解ViewRootImpl.setView()的时候，因涉及到Vsync信号知识，requestLayout()没有具体讲解，现在继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。</p><h3 id="6-5-1、Vsync请求过程"><a href="#6-5-1、Vsync请求过程" class="headerlink" title="6.5.1、Vsync请求过程"></a>6.5.1、Vsync请求过程</h3><p>我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;DisplayEventReceiver.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_DisplayEventReceiver.cpp ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">        reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">status_t status = receiver-&gt;scheduleVsync();</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">    String8 message;</span><br><span class="line">    message.appendFormat(<span class="string">"Failed to schedule next vertical sync pulse.  status=%d"</span>, status);</span><br><span class="line">    jniThrowRuntimeException(env, message.string());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VSync请求过程又转交给了DisplayEventReceiver： [-&gt;DisplayEventReceiver.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line"><span class="keyword">if</span> (mEventConnection != NULL) &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mEventConnection也是前面创建native层对象NativeDisplayEventReceiver时创建的，实际对象是一个BpDisplayEventConnection对象，也就是一个Binder客户端，对应的Binder服务端BnDisplayEventConnection是一个EventThread::Connection对象，对应的BpDisplayEventConnection.requestNextVsync函数和BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)函数没有进行特别的处理，下面就调用到EventThread::Connection.requestNextVsync函数，从BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)开始已经从用户进程将需要垂直同步信号的请求发送到了SurfaceFlinger进程，下面的函数调用开始进入SF进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::Connection::requestNextVsync() &#123;</span><br><span class="line">    mEventThread-&gt;requestNextVsync(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>辗转调用到EventThread.requestNextVsync函数，注意里面传了参数this，也就是当前的EventThread::Connection对象，需要明确的是，这里的mEventThread对象是创建EventThread::Connection对象的时候保存的，对应的是SurfaceFlinger对象的里面的mEventThread成员，该对象是一个在SurfaceFlinger.init里面创建并启动的线程对象，可见设计的时候就专门用这个SurfaceFlinger.mEventThread线程来接收来自应用进程的同步信号请求，每来一个应用进程同步信号请求，就通过SurfaceFlinger.mEventThread创建一个EventThread::Connection对象，并通过EventThread.registerDisplayEventConnection函数将创建的EventThread::Connection对象保存到EventThread.mDisplayEventConnections里面，上面有调用到了EventThread.requestNextVsync函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventThread::requestNextVsync(<span class="keyword">const</span> sp&lt;EventThread::Connection&gt;&amp; connection) &#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (connection-&gt;count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        connection-&gt;count = <span class="number">0</span>;</span><br><span class="line">        mCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传进来的是一个前面创建的EventThread::Connection对象，里面判断到了EventThread::Connection.count成员变量，看一下EventThread::Connection构造函数中初始变量的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EventThread::Connection::Connection(<span class="keyword">const</span> sp&lt;EventThread&gt;&amp; eventThread)</span><br><span class="line">    : count(<span class="number">-1</span>), mEventThread(eventThread), mChannel(<span class="keyword">new</span> BitTube())&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到初始值是-1，这个值就是前面那个问题的关键，EventThread::Connection.count标示了这次应用进程的垂直同步信号的请求是一次性的，还是多次重复的，看一下注释里面对于这个变量的说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count &gt;= 1 : continuous event. count is the vsync rate</span></span><br><span class="line"><span class="comment">// count == 0 : one-shot event that has not fired</span></span><br><span class="line"><span class="comment">// count ==-1 : one-shot event that fired this round / disabled</span></span><br><span class="line"><span class="keyword">int32_t</span> count;</span><br></pre></td></tr></table></figure><p>很清楚的说明了，count = 0说明当前的垂直同步信号请求是一个一次性的请求，并且还没有被处理。上面EventThread::requestNextVsync里面将count设置成0，同时调用了mCondition.broadcast()唤醒所有正在等待mCondition的线程，这个会触发EventThread.waitForEvent函数从：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCondition.wait(mLock);</span><br></pre></td></tr></table></figure><p>中醒来，醒来之后经过一轮do…while循环就会返回，返回以后调用序列如下： （1）EventThread::Connection.postEvent(event) （2）DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1)，mChannel参数就是前面创建DisplayEventReceiver是创建的BitTube对象 （3）BitTube::sendObjects(dataChannel, events, count)，static函数，通过dataChannel指向BitTube对象 最终调用到BitTube::sendObjects函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> BitTube::sendObjects(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span> <span class="keyword">const</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;write(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用到BitTube::write函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> BitTube::write(<span class="keyword">void</span> <span class="keyword">const</span>* vaddr, <span class="keyword">size_t</span> size)&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> err, len;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">        <span class="comment">// cannot return less than size, since we're using SOCK_SEQPACKET</span></span><br><span class="line">        err = len &lt; <span class="number">0</span> ? errno : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == EINTR);</span><br><span class="line">    <span class="keyword">return</span> err == <span class="number">0</span> ? len : -err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用到了::send函数，::是作用域描述符，如果前面没有类名之类的，代表的就是全局的作用域，也就是调用全局函数send，这里很容易就能想到这是一个socket的写入函数，也就是将event事件数据写入到BitTube中互联的socket中，这样在另一端马上就能收到写入的数据，前面分析到这个BitTube的socket的两端连接着SurfaceFlinger进程和应用进程，也就是说通过调用BitTube::write函数，将最初由SurfaceFlinger捕获到的垂直信号事件经由BitTube中互联的socket从SurfaceFlinger进程发送到了应用进程中BitTube的socket接收端。 下面就要分析应用进程是如何接收并使用这个垂直同步信号事件的。</p><h3 id="6-5-2、应用进程接收VSync"><a href="#6-5-2、应用进程接收VSync" class="headerlink" title="6.5.2、应用进程接收VSync"></a>6.5.2、应用进程接收VSync</h3><h4 id="6-5-2-1、解析VSync事件"><a href="#6-5-2-1、解析VSync事件" class="headerlink" title="6.5.2.1、解析VSync事件"></a>6.5.2.1、解析VSync事件</h4><p>VSync同步信号事件已经发送到用户进程中的socket接收端，在前面NativeDisplayEventReceiver.initialize中分析到应用进程端的socket接收描述符已经被添加到Choreographer所在线程的native层的Looper机制中，在epoll中监听EPOLLIN事件，当socket收到数据后，epoll会马上返回，下面分步骤看一下Looper.pollInner()数： （1）epoll_wait</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br></pre></td></tr></table></figure><p>在监听到描述符对应的事件后，epoll_wait会马上返回，并将产生的具体事件类型写入到参数eventItems里面，最终返回的eventCount是监听到的事件的个数 （2）事件分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">     <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">     <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">     <span class="keyword">if</span> (fd == mWakeReadPipeFd) &#123;   <span class="comment">//判断是不是pipe读管道的事件   这里如果是EventThread,这里就是一个socket的描述符,而不是mWakeReadPipeFd</span></span><br><span class="line">         <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">             awoken(); <span class="comment">// 清空读管道中的数据</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake read pipe."</span>, epollEvents);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//EventThread接收到同步信号走的这里</span></span><br><span class="line">         <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">         <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">             <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">             pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                     <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>Looper目前了解到的主要监听的文件描述符种类有两种： 1）消息事件，epoll_wait监听pipe管道的接收端描述符mWakeReadPipeFd 2）与VSync信号，epoll_wait监听socket接收端描述符，并在addFd的过程中将相关的信息封装在一个Request结构中，并以fd为key存储到了mRequests中，具体可以回过头看3.1.2关于addFd的分析； 因此，上面走的是else的分支，辨别出当前的事件类型后，调用pushResponse：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::pushResponse(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request) &#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;  <span class="comment">//复制不是引用，调用拷贝构造函数</span></span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数将Request和events封装在一个Response对象里面，存储到了mResponses里面，也就是mResponses里面放的是”某某fd上接收到了类别为events的时间”记录，继续向下看Looper.pollInner函数 （3）事件分发处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke all response callbacks.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">    Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">    <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">        <span class="keyword">int</span> events = response.events;</span><br><span class="line">        <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Clear the callback reference in the response structure promptly because we</span></span><br><span class="line">        <span class="comment">// will not clear the response vector itself until the next poll.</span></span><br><span class="line">        response.request.callback.clear();</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的response.request是从pushResponse里面复制过来的，里面的request对应的Request对象是在addFd的时候创建的，ident成员就是POLL_CALLBACK，所以继续走到response.request.callback-&gt;handleEvent这个函数，回忆一下3.1.2里面的addFd函数，这里的callback实际上是一个SimpleLooperCallback（定义在Looper.cpp中）对象，看一下里面的handleEvent函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> SimpleLooperCallback::handleEvent(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">return</span> mCallback(fd, events, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mCallback就是当时在addFd的时候传进来的callBack参数，实际上对应的就是NativeDisplayEventReceiver对象本身，因此最终就将垂直同步信号事件分发到了NativeDisplayEventReceiver.handleEvent函数中。</p><h3 id="6-5-3、VSync事件分发"><a href="#6-5-3、VSync事件分发" class="headerlink" title="6.5.3、VSync事件分发"></a>6.5.3、<strong>VSync事件分发</strong></h3><p>调用到NativeDisplayEventReceiver.handleEvent函数，该函数定义在android_view_DisplayEventReceiver.cpp中，直接列出该函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NativeDisplayEventReceiver::handleEvent(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Display event receiver pipe was closed or an error occurred.  "</span></span><br><span class="line">                <span class="string">"events=0x%x"</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                <span class="string">"events=0x%x"</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drain all pending events, keep the last vsync.</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Vsync pulse: timestamp=%"</span> PRId64 <span class="string">", id=%d, count=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先判断事件是不是正确的Looper::EVENT_INPUT事件，然后调用到NativeDisplayEventReceiver.processPendingEvents函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> NativeDisplayEventReceiver::processPendingEvents(<span class="keyword">nsecs_t</span>* outTimestamp, <span class="keyword">int32_t</span>* outId, <span class="keyword">uint32_t</span>* outCount) &#123;</span><br><span class="line">    <span class="keyword">bool</span> gotVsync = <span class="literal">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">ssize_t</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC:</span><br><span class="line">                <span class="comment">// Later vsync events will just overwrite the info from earlier</span></span><br><span class="line">                <span class="comment">// ones. That's fine, we only care about the most recent.</span></span><br><span class="line">                gotVsync = <span class="literal">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outId = ev.header.id;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOGW(<span class="string">"receiver %p ~ ignoring unknown event type %#x"</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to get events from display event receiver, status=%d"</span>, <span class="keyword">status_t</span>(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mReceiver也就是前面创建NativeDisplayEventReceiver对象是创建的成员变量对象DisplayEventReceiver，下面调用到DisplayEventReceiver.getEvents函数，应该是要从出现同步信号事件的socket中读取数据，上面Looper机制中epoll中监听到socket以后，返回到NativeDisplayEventReceiver.handleEvent里面，但是socket里面的数据还没有读取，下面的调用流程为： （1）mReceiver.getEvents(buf, EVENT_BUFFER_SIZE) —&gt; DisplayEventReceiver::getEvents(DisplayEventReceiver::Event _events, size<em>t count) （2）BitTube::recvObjects(dataChannel, events, count) —&gt; BitTube::recvObjects(const sp&amp; tube, void</em> events, size_t count, size_t objSize) 看一下这个recvObjects函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> BitTube::recvObjects(<span class="keyword">const</span> sp&lt;BitTube&gt;&amp; tube, <span class="keyword">void</span>* events, <span class="keyword">size_t</span> count, <span class="keyword">size_t</span> objSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span>* vaddr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(events);</span><br><span class="line">    <span class="keyword">ssize_t</span> size = tube-&gt;read(vaddr, count*objSize);</span><br><span class="line">    <span class="keyword">return</span> size &lt; <span class="number">0</span> ? size : size / <span class="keyword">static_cast</span>&lt;<span class="keyword">ssize_t</span>&gt;(objSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在NativeDisplayEventReceiver中创建了一个缓冲区，并在recvObjects中将socket中的Event数据读到这个缓冲区中，这个Event.header.type一般都是DISPLAY_EVENT_VSYNC，因此在上面的processPendingEvents函数中会将Event数据保存在outCount所指向的内存中，并返回true。 接下来返回到NativeDisplayEventReceiver.handleEvent后会调用到dispatchVsync函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NativeDisplayEventReceiver::dispatchVsync(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    env-&gt;CallVoidMethod(mReceiverObjGlobal, gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"dispatchVsync"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理很直接，直接调用mReceiverObjGlobal对象在gDisplayEventReceiverClassInfo.dispatchVsync中指定的函数，将后面的timestamp（时间戳） id（设备ID） count（经过的同步信号的数量，一般没有设置采样频率应该都是1），下面分别看一下mReceiverObjGlobal以及gDisplayEventReceiverClassInfo.dispatchVsync代表的是什么？ （1）mReceiverObjGlobal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverObj, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)), mMessageQueue(messageQueue), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">"receiver %p ~ Initializing input event receiver."</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到mReceiverObjGlobal是创建NativeDisplayEventReceiver对象时传进来的第二个参数，该对象是在nativeInit函数中创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sp receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env, receiverObj, messageQueue);</span><br></pre></td></tr></table></figure><p>进一步的，receiverObj是调用nativeInit函数时传进来的第一个参数（第一个参数env是系统用于连接虚拟机时自动加上的），nativeInit函数又是在Choreographer中创建FrameDisplayEventReceiver对象时，在基类DisplayEventReceiver构造器中调用的，因此这里的mReceiverObjGlobal对应的就是Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver。 （2）gDisplayEventReceiverClassInfo.dispatchVsync 在JNI中有很多这样的类似的结构体对象，这些对象都是全局结构体对象，这里的gDisplayEventReceiverClassInfo就是这样的一个对象，里面描述了一些在整个文件内可能会调用到的java层的相关类以及成员函数的相关信息，看一下gDisplayEventReceiverClassInfo：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    jclass clazz;</span><br><span class="line">    jmethodID dispatchVsync;</span><br><span class="line">    jmethodID dispatchHotplug;</span><br><span class="line">&#125; gDisplayEventReceiverClassInfo;</span><br></pre></td></tr></table></figure><p>看一下里面的变量名称就能知道大致的含义，clazz成员代表的是某个java层的类的class信息，dispatchVsync和dispatchHotplug代表的是java层类的方法的方法信息，看一下该文件中注册JNI函数的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_view_DisplayEventReceiver</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = RegisterMethodsOrDie(env, <span class="string">"android/view/DisplayEventReceiver"</span>, gMethods, NELEM(gMethods));</span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">"android/view/DisplayEventReceiver"</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">"dispatchVsync"</span>, <span class="string">"(JII)V"</span>);</span><br><span class="line">    gDisplayEventReceiverClassInfo.dispatchHotplug = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, <span class="string">"dispatchHotplug"</span>, <span class="string">"(JIZ)V"</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RegisterMethodsOrDie调用注册了java层调用native方法时链接到的函数的入口，下面clazz对应的就是java层的”android/view/DisplayEventReceiver.java”类，gDisplayEventReceiverClassInfo.dispatchVsync里面保存的就是clazz类信息中与dispatchVsync方法相关的信息，同样dispatchHotplug也是。 分析到这里，就知道应用进程native接收到同步信号事件后，会调用Choreographer中的FrameDisplayEventReceiver成员mDisplayEventReceiver的dispatchVsync方法。</p><h3 id="6-5-4、应用接收Vsync"><a href="#6-5-4、应用接收Vsync" class="headerlink" title="6.5.4、应用接收Vsync"></a>6.5.4、应用接收Vsync</h3><p>看一下FrameDisplayEventReceiver.dispatchVsync方法，也就是DisplayEventReceiver.dispatchVsync方法(Choreographer.java)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// Called from native code.   </span><br><span class="line"> @SuppressWarnings(&quot;unused&quot;)</span><br><span class="line"> private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">     onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line"> &#125;</span><br><span class="line"> 注释表明这个方法是从native代码调用的，该函数然后会调用FrameDisplayEventReceiver.onVsync方法：</span><br><span class="line">     @Override</span><br><span class="line">     public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123;</span><br><span class="line">         // Ignore vsync from secondary display.</span><br><span class="line">         // This can be problematic because the call to scheduleVsync() is a one-shot.</span><br><span class="line">         // We need to ensure that we will still receive the vsync from the primary</span><br><span class="line">         // display which is the one we really care about.  Ideally we should schedule</span><br><span class="line">         // vsync for a particular display.</span><br><span class="line">         // At this time Surface Flinger won&apos;t send us vsyncs for secondary displays</span><br><span class="line">         // but that could change in the future so let&apos;s log a message to help us remember</span><br><span class="line">         // that we need to fix this.</span><br><span class="line">         //注释：忽略来自非主显示器的Vsync信号，但是我们前面调用的scheduleVsync函数只能请求到一次Vsync信号，因此需要重新调用scheduleVsync函数</span><br><span class="line">         //请求来自主显示设备的Vsync信号</span><br><span class="line">         if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">             Log.d(TAG, &quot;Received vsync from secondary display, but we don&apos;t support &quot;</span><br><span class="line">                     + &quot;this case yet.  Choreographer needs a way to explicitly request &quot;</span><br><span class="line">                     + &quot;vsync for a specific display to ensure it doesn&apos;t lose track &quot;</span><br><span class="line">                     + &quot;of its scheduled vsync.&quot;);</span><br><span class="line">             scheduleVsync();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // Post the vsync event to the Handler.</span><br><span class="line">         // The idea is to prevent incoming vsync events from completely starving</span><br><span class="line">         // the message queue.  If there are no messages in the queue with timestamps</span><br><span class="line">         // earlier than the frame time, then the vsync event will be processed immediately.</span><br><span class="line">         // Otherwise, messages that predate the vsync event will be handled first.</span><br><span class="line">         long now = System.nanoTime();</span><br><span class="line">         if (timestampNanos &gt; now) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f)</span><br><span class="line">                     + &quot; ms in the future!  Check that graphics HAL is generating vsync &quot;</span><br><span class="line">                     + &quot;timestamps using the correct timebase.&quot;);</span><br><span class="line">             timestampNanos = now;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (mHavePendingVsync) &#123;</span><br><span class="line">             Log.w(TAG, &quot;Already have a pending vsync event.  There should only be &quot;</span><br><span class="line">                     + &quot;one at a time.&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             mHavePendingVsync = true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         mTimestampNanos = timestampNanos;  //同步信号时间戳</span><br><span class="line">         mFrame = frame;                //同步信号的个数，理解就是从调用scheduleVsync到onVsync接收到信号之间经历的同步信号的个数，一般都是1</span><br><span class="line">         Message msg = Message.obtain(mHandler, this);</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">         mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>貌似这里的处理只是往Choreographer对象中的mHandler对应的线程Looper中发送一个消息，消息的内容有两个特点： （1）将this，也就是当前的FrameDisplayEventReceiver对象作为参数，后面会回调到FrameDisplayEventReceiver.run方法； （2）为Message设置FLAG_ASYNCHRONOUS属性； 发送这个FLAG_ASYNCHRONOUS消息后，后面会回调到FrameDisplayEventReceiver.run方法，至于为什么，后面再写文章结合View.invalidate方法的过程分析，看一下FrameDisplayEventReceiver.run方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mHavePendingVsync = false;</span><br><span class="line">    doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用Choreographer.doFrame方法，如果是重绘事件doFrame方法会最终调用到ViewRootImpl.performTraversals方法进入实际的绘制流程。经过上面的分析可以知道，调用一次Choreographer.scheduleVsyncLocked只会请求一次同步信号，也就是回调一次FrameDisplayEventReceiver.onVsync方法，在思考一个问题，一个应用进程需要多次请求Vsync同步信号会不会使用同样的一串对象？多个线程又是怎么样的？ 答：一般绘制操作只能在主线程里面进行，因此一般来说只会在主线程里面去请求同步信号，可以认为不会存在同一个应用的多个线程请求SF的Vsync信号，Choreographer是一个线程内的单例模式，存储在了 ThreadLocal sThreadInstance对象里面，所以主线程多次请求使用的是同一个Choreographer对象，所以后面的一串对象应该都是可以复用的。</p><p>总体架构： 伐木累:::终于完了，由于Android Graphics系统涉及模块代码纵横交叉复杂，其中代码图示有误的地方请见谅，也没有精力一一核对了，还请海涵~~~主要是分析Android Graphics总体的一个流程思想，有需要再一点点深挖。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.graphics/30-Android-Graphics-Arc-flow.png" alt="Markdown"></p><h2 id="（七）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考文档(特别感谢各位前辈的分析和图示)："></a>（七）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="http://www.10tiao.com/html/431/201601/401709603/1.html" target="_blank" rel="noopener">Android Vsync 原理</a><br><a href="http://blog.csdn.net/uiop78uiop78/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏</a><br><a href="http://coderprof.com/android_tutorials_pdf_examples_PDF.php?q=android+graphics+pdf" target="_blank" rel="noopener">Android Graphics</a><br><a href="https://source.android.com/devices/tech/debug/systrace" target="_blank" rel="noopener">了解 Systrace</a><br><a href="http://www.cnblogs.com/samchen2009/category/524173.html" target="_blank" rel="noopener">图解Android - Android GUI 系统</a><br><a href="http://windrunnerlihuan.com/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路&amp;Android多媒体开发</a><br><a href="http://blog.csdn.net/Gaugamela/article/category/6383486" target="_blank" rel="noopener">Android7.0 基础业务AMS、数据业务、电源管理业务 源码分析</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1647761" target="_blank" rel="noopener">【Android 显示模块】 - 深入剖析Android系统 - CSDN博客</a><br><a href="http://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">深入理解Android卷一全文-第八章(深入理解Surface系统)</a><br><a href="http://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">android系统 - armwind的专栏 - CSDN博客</a><br><a href="http://blog.csdn.net/kc58236582/article/category/6436488" target="_blank" rel="noopener">android显示系统 - kc58236582的博客 - CSDN博客</a><br><a href="http://www.cnblogs.com/wytiger/p/5693569.html" target="_blank" rel="noopener">SurfaceView, TextureView, SurfaceTexture等的区别</a><br><a href="http://blog.csdn.net/armwind/article/details/73436532" target="_blank" rel="noopener">【Demo】Android graphics 学习－生产者、消费者、BufferQueue介绍</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0421/2765.html" target="_blank" rel="noopener">深入Android Graphics Pipeline：从按钮到帧缓冲（第一部分）</a><br><a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0421/2766.html" target="_blank" rel="noopener">深入Android Graphics Pipeline：从按钮到帧缓冲（第二部分）</a><br><a href="https://software.intel.com/en-us/node/713326" target="_blank" rel="noopener">窗口：Profiling 视图（OpenGL/OpenGL ES* 工作负载）</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)</a><br><a href="https://netaz.blogspot.jp/search/label/gralloc" target="_blank" rel="noopener">Android’s Graphics Buffer Management System (Part I: gralloc)</a><br><a href="https://netaz.blogspot.jp/search/label/Graphics" target="_blank" rel="noopener">Android’s Graphics Buffer Management System (Part II: BufferQueue)</a><br><a href="https://www.kancloud.cn/digest/androidcore/149097" target="_blank" rel="noopener">Android GDI之SurfaceFlinger</a><br><a href="http://windrunnerlihuan.com/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理</a><br><a href="http://blog.csdn.net/michaelcao1980/article/details/43233765" target="_blank" rel="noopener">Android 5.1 SurfaceFlinger VSYNC详解</a><br><a href="http://blog.csdn.net/newchenxf/article/details/49131167" target="_blank" rel="noopener">Android 5.1 SurfaceFlinger VSYNC详解</a><br><a href="http://blog.csdn.net/houliang120/article/details/50958212" target="_blank" rel="noopener">Android消息机制Looper与VSync的传播</a><br><a href="http://blog.csdn.net/houliang120/article/details/50908098" target="_blank" rel="noopener">Android垂直同步信号VSync的产生及传播结构详解</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/17293325" target="_blank" rel="noopener">Android 4.4(KitKat)中VSync信号的虚拟化</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/37737439" target="_blank" rel="noopener">Android 4.4(KitKat)窗口管理子系统 - 体系框架</a><br><a href="http://blog.csdn.net/ariesjzj/article/category/1087829/2" target="_blank" rel="noopener">Android中用OpenGL ES Tracer分析绘制过程</a><br><a href="https://www.zhihu.com/question/30372696?sort=created" target="_blank" rel="noopener">android view的绘制中，View绘制的时间如何和vsync屏幕刷新频率保持同步的？</a><br><a href="http://blog.csdn.net/innost/article/details/47208337" target="_blank" rel="noopener">【深入理解Android卷一全文-第八章】入理解Surface系统</a><br><a href="http://blog.csdn.net/april_12345/article/details/52933316" target="_blank" rel="noopener">Android 窗口管理：Z-Order管理</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Android Binder 系统 分析</title>
      <link href="/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Android Binder系统概述： Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。因此，Binder机制在Android系统中的地位非常重要，可以说，理解Binder是理解Android系统的绝对必要前提。</p><a id="more"></a><blockquote><p><strong>framework/base/core/java/ (Java)</strong><br> <strong>framework/base/core/jni/ (JNI)</strong><br> <strong>framework/native/libs/binder (Native)</strong><br> <strong>framework/native/cmds/servicemanager/ (Native)</strong><br> <strong>kernel/drivers/staging/android (Driver)</strong></p></blockquote><hr><blockquote><p><strong>Java framework</strong></p></blockquote><p><strong>framework/base/core/java/android/os/</strong><br>● IInterface.java<br>● IBinder.java<br>● Parcel.java<br>● IServiceManager.java<br>● ServiceManager.java<br>● ServiceManagerNative.java<br>● Binder.java</p><p><strong>framework/base/core/jni/</strong><br>● android_os_Parcel.cpp<br>● AndroidRuntime.cpp<br>● android_util_Binder.cpp (核心类)</p><hr><blockquote><p><strong>Native framework</strong></p></blockquote><p><strong>framework/native/libs/binder</strong><br><br>● IServiceManager.cpp<br>● BpBinder.cpp<br>● Binder.cpp<br>● IPCThreadState.cpp (核心类)<br>● ProcessState.cpp (核心类)</p><p><strong>framework/native/include/binder/</strong><br>● IServiceManager.h<br>● IInterface.h</p><p><strong>framework/native/cmds/servicemanager/</strong><br>● bctest.c<br>● binder.h<br>● binder.c<br>● service_manager.c<br>● servicemanager.rc</p><hr><blockquote><p><strong>Kernel</strong></p></blockquote><p><strong>kernel/drivers/staging/android/</strong></p><p>● binder.c<br>● binder.h</p><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.binder" target="_blank" rel="noopener">博客原图链接</a></h2><h2 id="一、Android-Binder系统C程序示例"><a href="#一、Android-Binder系统C程序示例" class="headerlink" title="一、Android Binder系统C程序示例"></a>一、Android Binder系统C程序示例</h2><h3 id="（1）、简述Binder跨进程机制"><a href="#（1）、简述Binder跨进程机制" class="headerlink" title="（1）、简述Binder跨进程机制"></a>（1）、简述Binder跨进程机制</h3><p>Android系统中，每个应用程序是由Android的Activity，Service，Broadcast，ContentProvider这四组件的中一个或多个组合而成，这四组件所涉及的多进程间的通信底层都是依赖于Binder IPC机制。</p><p>从进程角度来看IPC机制<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/01-Android-binder-binder_interprocess_communication.png" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/02-Android-binder-IPC-Binder.jpg" alt="Markdown"></p><p>现在Client进程需要访问Server进程中的服务，会经过以下步骤：<br>1、Server进程首先向ServiceManager注册服务（ServiceManager先于Server启动）<br>2、Client进程向ServiceManager查询服务得到一个句柄Handle（Server进程可能不止一个服务，用Handle区分是哪一个服务）<br>3、Client进程 封装数据Buffer通过Binder驱动发送给Server进程，Server进程取得数据后解析数据，使用Server进程的Handle服务对应的函数处理数据，处理完成后通过Binder驱动传输给Client进程</p><h4 id="1-1、Server进程向ServiceManager注册服务"><a href="#1-1、Server进程向ServiceManager注册服务" class="headerlink" title="1.1、Server进程向ServiceManager注册服务"></a>1.1、Server进程向ServiceManager注册服务</h4><p>ServiceManager是一个守护进程。它的main()函数源码如下：</p><blockquote><p>ServiceManager是如何启动的？ 这里简要介绍一下ServiceManager的启动方式。当Kernel启动加载完驱动之后，会启动Android的init进程，init进程会解析servicemanager.rc，进而启动servicemanager.rc中定义的守护进程。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ServiceManager.c]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    svcmgr_handle = svcmgr;</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉Kernel，ServiceManager进程进入了消息循环状态。</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Kernel中发送消息(先写后读)。</span></span><br><span class="line">        <span class="comment">// 先将消息传递给Kernel，然后再从Kernel读取消息反馈</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析读取的消息反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_loop()主要工作： (1)、通过ioctl(,BINDER_WRITE_READ,)进入消息循环，休眠等待Client请求 (2)、当Client通过驱动请求服务时，binder驱动会唤醒ServiceManager，通过binder_parse()解析处理数据，回复信息</p><p>代码调用关系图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/03-Android-binder-ServiceManager-main.jpg" alt="Markdown"></p><p>时序流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/04-Android-binder-ServiceManager-main-flow.jpg" alt="Markdown"></p><p>main()主要进行了三项工作： (1) 、通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。 (2) 、调用binder_become_context_manager()，通过ioctl()告诉Binder驱动程序自己是Binder上下文管理者。 (3) 、调用binder_loop()进入消息循环，等待Client的请求。如果没有Client请求，则进入睡眠等待状态；当有Client请求时，就被唤醒，然后读取并处理Client请求。</p><h4 id="1-2、分析Android-binder原生示例程序bctest-c："><a href="#1-2、分析Android-binder原生示例程序bctest-c：" class="headerlink" title="1.2、分析Android binder原生示例程序bctest.c："></a>1.2、分析Android binder原生示例程序bctest.c：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> svcmgr = BINDER_SERVICE_MANAGER;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(<span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (argc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//svcmgr_lookup方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE)</span></span><br><span class="line">            handle = svcmgr_lookup(bs, svcmgr, <span class="string">"alt_svc_mgr"</span>);</span><br><span class="line">            <span class="comment">//svcmgr_publish方法调用binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_CHECK_SERVICE)</span></span><br><span class="line">            svcmgr_publish(bs, svcmgr, argv[<span class="number">1</span>], &amp;token);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3、示例程序（bctest-c）注册服务、获取服务过程"><a href="#1-3、示例程序（bctest-c）注册服务、获取服务过程" class="headerlink" title="1.3、示例程序（bctest.c）注册服务、获取服务过程"></a>1.3、示例程序（bctest.c）注册服务、获取服务过程</h4><p>注册服务的过程（bctest.c）:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/06-Android-binder-ServiceManager-main-SM-Publish.png" alt="Markdown"></p><p>(1) 、bs = binder_open(128*1024) (2) 、binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE) 参数说明： // msg含有服务的名字 // reply它会含有servicemanager回复的数据 // target为0表示servicemanager // code: 表示要调用servicemanager中的”addservice函数”</p><p>获取服务的过程（bctest.c）:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/05-Android-binder-ServiceManager-LookUp.png" alt="Markdown"></p><p>(1) 、bs = binder_open(128*1024) (2) 、binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE) 参数说明： // msg含有服务的名字 // reply它会含有servicemanager回复的数据, 表示提供服务的进程 // target为0表示servicemanager // code: 表示要调用servicemanager中的”getservice函数”</p><p>binder_call远程实现： 根据msg、target、code就知道需要调用哪个服务的哪一个函数。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/07-Android-binder-Binder_call.png" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_call</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_io *msg, struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uint32_t</span> target, <span class="keyword">uint32_t</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) writebuf;</span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    writebuf.cmd = BC_TRANSACTION;</span><br><span class="line">    writebuf.txn.target.handle = target;</span><br><span class="line">    writebuf.txn.code = code;</span><br><span class="line">    writebuf.txn.flags = <span class="number">0</span>;</span><br><span class="line">    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;</span><br><span class="line">    writebuf.txn.offsets_size = ((<span class="keyword">char</span>*) msg-&gt;offs) - ((<span class="keyword">char</span>*) msg-&gt;offs0);</span><br><span class="line">    writebuf.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)msg-&gt;data0;</span><br><span class="line">    writebuf.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)msg-&gt;offs0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="keyword">sizeof</span>(writebuf);</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) &amp;writebuf;</span><br><span class="line"></span><br><span class="line">    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        res = binder_parse(bs, reply, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注： 结构体简介 binder_io 封装一次发送的数据 binder_write_read 存储一次读写操作的数据 binder_transaction_data 存储一次事务的数据<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/08-Android-binder-binder_io_struct.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/09-Android-binder-binder_write_read.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/10-Android-binder-binder_transaction_data.jpg" alt="Markdown"></p></blockquote><p>（1）构造参数，使用binder_io 描述<br>（2）数据转换binder_io -&gt; binder_write_read；首先根据binder_io 、target、code三者构造binder_transaction_data，然后将binder_write_read.write_buffer指向binder_transaction_data<br>（3）调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/11-Android-Binder-binder_call.png" alt="Markdown"></p><h3 id="（2）、Android-Binder系统-ServiceManager"><a href="#（2）、Android-Binder系统-ServiceManager" class="headerlink" title="（2）、Android Binder系统_ServiceManager"></a>（2）、Android Binder系统_ServiceManager</h3><p>我们先跳过ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)所涉及的内核知识和流程，稍后再Android Binder系统-Driver层详细介绍。</p><h4 id="2-1、ServiceManager中service句柄如何管理"><a href="#2-1、ServiceManager中service句柄如何管理" class="headerlink" title="2.1、ServiceManager中service句柄如何管理"></a>2.1、ServiceManager中service句柄如何管理</h4><p>前面分析过，ServiceManager开机初始会启动成为一个守护进程， ServiceManager是如何管理service句柄的？ 进程里有一个全局性的svclist变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">svclist</span> = 0;</span></span><br></pre></td></tr></table></figure><p>它记录着所有添加进系统的”Service”信息，这些信息被组织成一条单向链表，我们不妨称这条链表为”Service向量表”。示意图如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/12-Android-Binder-SM-svclist.jpg" alt="Markdown"></p><p>链表节点类型为svcinfo</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/13-Android-Binder-SM-svcinfo.png" alt="Markdown"></p><p>添加服务简单理解就是 新建svcinfo节点插入到单链表中，查询服务就是看单链表是否有此服务。</p><h4 id="2-2、解析Binder上传数据-binder-parse函数"><a href="#2-2、解析Binder上传数据-binder-parse函数" class="headerlink" title="2.2、解析Binder上传数据-(binder_parse函数)"></a>2.2、解析Binder上传数据-(binder_parse函数)</h4><p>回到ServiceManager的main()函数。binder_loop()会先向binder驱动发出了BC_ENTER_LOOPER命令，接着进入一个for循环不断调用ioctl()读取发来的数据，接着解析这些数据。假设现在Client有请求，Binder驱动就通过会上传数据。读取数据后会交由binder_parse()解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_loop(bs, svcmgr_handler);</span><br></pre></td></tr></table></figure><p>注意binder_loop()的参数svcmgr_handler()函数指针。而且这个参数会进一步传递给binder_parse()。binder_parse()负责解析从binder驱动读来的数据，其代码截选如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end = ptr + (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *(<span class="keyword">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//驱动有数据后会返回次cmd</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                <span class="keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;              </span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前文的代码我们可以看到，binder_loop()声明了一个128节的buffer（即uint32_t readbuf[32]），每次用BINDER_WRITE_READ命令从驱动读取一些内容，并传入binder_parse()。 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。</p><p>binder_loop()就这样一直循环下去，完成了整个ServiceManager的工作。</p><h4 id="2-3、数据转换binder-transaction-data-gt-binder-io"><a href="#2-3、数据转换binder-transaction-data-gt-binder-io" class="headerlink" title="2.3、数据转换binder_transaction_data-&gt;binder_io"></a>2.3、数据转换binder_transaction_data-&gt;binder_io</h4><p>初始化reply；根据txt(Binder驱动反馈的信息)初始化msg</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">bio_init_from_txn(&amp;msg, txn);</span><br></pre></td></tr></table></figure><h4 id="2-4、如何添加服务SVC-MGR-ADD-SERVICE"><a href="#2-4、如何添加服务SVC-MGR-ADD-SERVICE" class="headerlink" title="2.4、如何添加服务SVC_MGR_ADD_SERVICE"></a>2.4、如何添加服务SVC_MGR_ADD_SERVICE</h4><p>前面讲过 binder_parse()在合适的时机，会回调其func参数（binder_handler func）指代的回调函数，即前文说到的svcmgr_handler()函数。并且会根据binder_transaction_data的code判断具体调用哪一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_handler</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *txn,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *msg,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_io *reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> *s;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">uint32_t</span> handle;</span><br><span class="line">    <span class="keyword">uint32_t</span> strict_policy;</span><br><span class="line">    <span class="keyword">int</span> allow_isolated;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span>(txn-&gt;code) &#123;</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_GET_SERVICE:</span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s = bio_get_string16(msg, &amp;len);</span><br><span class="line">        handle = bio_get_ref(msg);</span><br><span class="line">        allow_isolated = bio_get_uint32(msg) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (do_add_service(bs, s, len, handle, txn-&gt;sender_euid,</span><br><span class="line">            allow_isolated, txn-&gt;sender_pid))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    bio_put_uint32(reply, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知code = SVC_MGR_ADD_SERVICE 会调用do_add_service()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        ...</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见添加Service只是新建了一个svcinfo然后插入到前面所说的”Service向量表”中。</p><h4 id="2-5、如何获取服务SVC-MGR-CHECK-SERVICE"><a href="#2-5、如何获取服务SVC-MGR-CHECK-SERVICE" class="headerlink" title="2.5、如何获取服务SVC_MGR_CHECK_SERVICE"></a>2.5、如何获取服务SVC_MGR_CHECK_SERVICE</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> do_find_service(<span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">uid_t</span> uid, <span class="keyword">pid_t</span> spid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span> = <span class="title">find_svc</span>(<span class="title">s</span>, <span class="title">len</span>);</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> si-&gt;handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取服务会查询”Service向量表”是否有此服务，然后返回Service的句柄handle。</p><h4 id="2-6、ServiceManager回复数据"><a href="#2-6、ServiceManager回复数据" class="headerlink" title="2.6、ServiceManager回复数据"></a>2.6、ServiceManager回复数据</h4><p>前面分析回调svcmgr_handler()函数处理数据后，会调用binder_send_reply()函数 回复消息给驱动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res)</span><br></pre></td></tr></table></figure><h4 id="2-7、总结："><a href="#2-7、总结：" class="headerlink" title="2.7、总结："></a>2.7、总结：</h4><p>示例程序（bctest.c）注册、获取服务一般分以下步骤： （1）源进程通过binder_open()打开”/dev/binder”文件，即打开Binder设备文件。 （2）源进程构造数据：[a].构造binder_io [b].转为binder_transaction_data [c].放入binder_write_read （3）源进程调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动 （4）驱动上报数据到目的进程ServiceManager （5）目的进程ServiceManager处理完数据，重新构造数据，通过调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);发送数据给驱动 （6）驱动然后将数据反馈到源进程</p><h3 id="（3）、Android-Binder系统C程序"><a href="#（3）、Android-Binder系统C程序" class="headerlink" title="（3）、Android Binder系统C程序"></a>（3）、Android Binder系统C程序</h3><h4 id="3-1、Android-Binder系统C程序-框架"><a href="#3-1、Android-Binder系统C程序-框架" class="headerlink" title="3.1、Android Binder系统C程序_框架"></a>3.1、Android Binder系统C程序_框架</h4><p>总结bctest.c注册服务获取服务的一般流程框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/14-Android-Binder-binder_C_app_client_server_Arc.png" alt="Markdown"></p><h4 id="3-2、Android-Binder系统C程序-编码"><a href="#3-2、Android-Binder系统C程序-编码" class="headerlink" title="3.2、Android Binder系统C程序_编码"></a>3.2、Android Binder系统C程序_编码</h4><p>参考bctest.c编码： test_server：向ServiceManager添加服务”hello” &amp;&amp; “goodbye” Service test_client ：查询获取服务(ServiceManager) <a href="https://github.com/weidongshan/APP_0003_Binder_C_App" target="_blank" rel="noopener">链接：Binder_C_App</a><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/15-Android-binder-C-Test-App.png" alt="Markdown"></p><h4 id="3-3、Android-Binder系统C程序-测试"><a href="#3-3、Android-Binder系统C程序-测试" class="headerlink" title="3.3、Android Binder系统C程序_测试"></a>3.3、Android Binder系统C程序_测试</h4><p>./test_server &amp; ./test_client hello ./test_client hello 100ask.taobao.com ./test_client goodbye ./test_client goodbye 100ask.taobao.com</p><h2 id="二、Android-Binder系统-Driver层"><a href="#二、Android-Binder系统-Driver层" class="headerlink" title="二、Android Binder系统-Driver层"></a>二、Android Binder系统-Driver层</h2><p>前面打开驱动binder_open(128*1024)、ServiceManager启动是如何与驱动交互成为管理者的，以及添加服务获取服务 驱动部分都没有详细讲解，现在一起来看下。</p><h3 id="（1）、Binder驱动概述"><a href="#（1）、Binder驱动概述" class="headerlink" title="（1）、Binder驱动概述"></a>（1）、Binder驱动概述</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Binder驱动是Android专用的，但底层的驱动架构与Linux驱动一样。binder驱动在以misc设备进行注册，作为虚拟字符设备，没有直接操作硬件，只是对设备内存的处理。主要是驱动设备的初始化(binder_init)，打开 (binder_open)，映射(binder_mmap)，数据操作(binder_ioctl)。如启动ServiceManager调用:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/16-Android-Binder-start_service_manager.jpg" alt="Markdown"></p><h4 id="1-2-系统调用"><a href="#1-2-系统调用" class="headerlink" title="1.2 系统调用"></a>1.2 系统调用</h4><p>用户态的程序调用Kernel层驱动是需要陷入内核态，进行系统调用(syscall)，比如打开Binder驱动方法的调用链为： open-&gt; <strong>open() -&gt; binder_open()。 open()为用户空间的方法，</strong>open()便是系统调用中相应的处理方法，通过查找，对应调用到内核binder驱动的binder_open()方法，至于其他的从用户态陷入内核态的流程也基本一致。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/17-Android-binder_driver_interface.png" alt="Markdown"></p><h3 id="（2）、Binder核心方法"><a href="#（2）、Binder核心方法" class="headerlink" title="（2）、Binder核心方法"></a>（2）、Binder核心方法</h3><h4 id="2-1、binder-init"><a href="#2-1、binder-init" class="headerlink" title="2.1、binder_init()"></a>2.1、binder_init()</h4><p>主要工作是为了注册misc设备 binder_init函数中最主要的工作其实下面这行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = misc_register(&amp;binder_miscdev);</span><br></pre></td></tr></table></figure><p>该行代码真正向内核中注册了Binder设备。binder_miscdev的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">miscdevice</span> <span class="title">binder_miscdev</span> = &#123;</span></span><br><span class="line">    .minor = MISC_DYNAMIC_MINOR,</span><br><span class="line">    .name = <span class="string">"binder"</span>,</span><br><span class="line">    .fops = &amp;binder_fops</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里指定了Binder设备的名称是”binder”。这样，在用户空间便可以通过对/dev/binder文件进行操作来使用Binder。 binder_miscdev同时也指定了该设备的fops。fops是另外一个结构体，这个结构中包含了一系列的函数指针，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .poll = binder_poll,</span><br><span class="line">    .unlocked_ioctl = binder_ioctl,</span><br><span class="line">    .compat_ioctl = binder_ioctl,</span><br><span class="line">    .mmap = binder_mmap,</span><br><span class="line">    .open = binder_open,</span><br><span class="line">    .flush = binder_flush,</span><br><span class="line">    .release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-2、主要结构"><a href="#2-2、主要结构" class="headerlink" title="2.2、主要结构"></a>2.2、<strong>主要结构</strong></h4><p>Binder驱动中包含了很多的结构体。为了便于下文讲解，这里我们先对这些结构体做一些介绍。</p><p>驱动中的结构体可以分为两类：</p><p>一类是与用户空间共用的，这些结构体在Binder通信协议过程中会用到。因此，这些结构体定义在binder.h中，包括：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">flat_binder_object</td><td>描述在Binder IPC中传递的对象，见下文</td></tr><tr><td style="text-align:left"><strong>binder_write_read</strong></td><td>存储一次读写操作的数据</td></tr><tr><td style="text-align:left">binder_version</td><td>存储Binder的版本号</td></tr><tr><td style="text-align:left">transaction_flags</td><td>描述事务的flag，例如是否是异步请求，是否支持fd</td></tr><tr><td style="text-align:left"><strong>binder_transaction_data</strong></td><td>存储一次事务的数据</td></tr><tr><td style="text-align:left">binder_ptr_cookie</td><td>包含了一个指针和一个cookie</td></tr><tr><td style="text-align:left">binder_handle_cookie</td><td>包含了一个句柄和一个cookie</td></tr><tr><td style="text-align:left">binder_pri_desc</td><td>暂未用到</td></tr><tr><td style="text-align:left">binder_pri_ptr_cookie</td><td>暂未用到</td></tr></tbody></table><p>从前面Binder系统C程序框架分析，这其中，<strong>binder_write_read</strong>和<strong>binder_transaction_data</strong>这两个结构体最为重要，它们存储了IPC调用过程中的数据。关于这一点，我们在下文中会讲解。</p><p>Binder驱动中，还有一类结构体是仅仅Binder驱动内部实现过程中需要的，它们定义在binder.c中，包括：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>binder_node</strong></td><td>描述Binder实体节点，即：对应了一个Server</td></tr><tr><td style="text-align:left"><strong>binder_ref</strong></td><td>描述对于Binder实体的引用</td></tr><tr><td style="text-align:left"><strong>binder_buffer</strong></td><td>描述Binder通信过程中存储数据的Buffer</td></tr><tr><td style="text-align:left"><strong>binder_proc</strong></td><td>描述使用Binder的进程</td></tr><tr><td style="text-align:left"><strong>binder_thread</strong></td><td>描述使用Binder的线程</td></tr><tr><td style="text-align:left">binder_work</td><td>描述通信过程中的一项任务</td></tr><tr><td style="text-align:left">binder_transaction</td><td>描述一次事务的相关信息</td></tr><tr><td style="text-align:left">binder_deferred_state</td><td>描述延迟任务</td></tr><tr><td style="text-align:left">binder_ref_death</td><td>描述Binder实体死亡的信息</td></tr><tr><td style="text-align:left">binder_transaction_log</td><td>debugfs日志</td></tr><tr><td style="text-align:left">binder_transaction_log_entry</td><td>debugfs日志条目</td></tr></tbody></table><p>这里需要读者关注的结构体已经用加粗做了标注。</p><h4 id="2-3、Binder协议"><a href="#2-3、Binder协议" class="headerlink" title="2.3、Binder协议"></a>2.3、<strong>Binder协议</strong></h4><p>Binder协议可以分为控制协议和驱动协议两类。</p><p>控制协议是进程通过ioctl(“/dev/binder”) 与Binder设备进行通讯的协议，该协议包含以下几种命令：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th><th style="text-align:center">参数类型</th></tr></thead><tbody><tr><td style="text-align:left"><strong>BINDER_WRITE_READ</strong></td><td>读写操作，最常用的命令。IPC过程就是通过这个命令进行数据传递</td><td style="text-align:center">binder_write_read</td></tr><tr><td style="text-align:left">BINDER_SET_MAX_THREADS</td><td>设置进程支持的最大线程数量</td><td style="text-align:center">size_t</td></tr><tr><td style="text-align:left">BINDER_SET_CONTEXT_MGR</td><td>设置自身为ServiceManager</td><td style="text-align:center">无</td></tr><tr><td style="text-align:left">BINDER_THREAD_EXIT</td><td>通知驱动Binder线程退出</td><td style="text-align:center">无</td></tr><tr><td style="text-align:left">BINDER_VERSION</td><td>获取Binder驱动的版本号</td><td style="text-align:center">binder_version</td></tr><tr><td style="text-align:left">BINDER_SET_IDLE_PRIORITY</td><td>暂未用到</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BINDER_SET_IDLE_TIMEOUT</td><td>暂未用到</td><td style="text-align:center">-</td></tr></tbody></table><p>Binder的驱动协议描述了对于Binder驱动的具体使用过程。驱动协议又可以分为两类：</p><p>一类是binder_driver_command_protocol，描述了进程发送给Binder驱动的命令 一类是binder_driver_return_protocol，描述了Binder驱动发送给进程的命令 binder_driver_command_protocol共包含17个命令，分别是：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th><th style="text-align:center">参数类型</th></tr></thead><tbody><tr><td style="text-align:left">BC_TRANSACTION</td><td>Binder事务，即：Client对于Server的请求</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BC_REPLY</td><td>事务的应答，即：Server对于Client的回复</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BC_FREE_BUFFER</td><td>通知驱动释放Buffer</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BC_ACQUIRE</td><td>强引用计数+1</td><td style="text-align:center">__u32</td></tr><tr><td style="text-align:left">BC_RELEASE</td><td>强引用计数-1</td><td style="text-align:center">__u32</td></tr><tr><td style="text-align:left">BC_INCREFS</td><td>弱引用计数+1</td><td style="text-align:center">__u32</td></tr><tr><td style="text-align:left">BC_DECREFS</td><td>弱引用计数-1 __u32</td></tr><tr><td style="text-align:left">BC_ACQUIRE_DONE</td><td>BR_ACQUIRE的回复</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BC_INCREFS_DONE</td><td>BR_INCREFS的回复</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BC_ENTER_LOOPER</td><td>通知驱动主线程ready</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BC_REGISTER_LOOPER</td><td>通知驱动子线程ready</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BC_EXIT_LOOPER</td><td>通知驱动线程已经退出</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BC_REQUEST_DEATH_NOTIFICATION</td><td>请求接收死亡通知</td><td style="text-align:center">binder_handle_cookie</td></tr><tr><td style="text-align:left">BC_CLEAR_DEATH_NOTIFICATION</td><td>去除接收死亡通知</td><td style="text-align:center">binder_handle_cookie</td></tr><tr><td style="text-align:left">BC_DEAD_BINDER_DONE</td><td>已经处理完死亡通知</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BC_ATTEMPT_ACQUIRE</td><td>暂未实现</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BC_ACQUIRE_RESULT</td><td>暂未实现</td><td style="text-align:center">-</td></tr></tbody></table><p>binder_driver_return_protocol共包含18个命令，分别是：</p><table><thead><tr><th style="text-align:left">结构体名称</th><th>说明</th><th style="text-align:center">参数类型</th></tr></thead><tbody><tr><td style="text-align:left">BR_OK</td><td>操作完成</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_NOOP</td><td>操作完成</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_ERROR</td><td>发生错误</td><td style="text-align:center">__s32</td></tr><tr><td style="text-align:left">BR_TRANSACTION</td><td>通知进程收到一次Binder请求（Server端）</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BR_REPLY</td><td>通知进程收到Binder请求的回复（Client）</td><td style="text-align:center">binder_transaction_data</td></tr><tr><td style="text-align:left">BR_TRANSACTION_COMPLETE</td><td>驱动对于接受请求的确认回复</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_FAILED_REPLY</td><td>告知发送方通信目标不存在</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_SPAWN_LOOPER</td><td>通知Binder进程创建一个新的线程</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_ACQUIRE</td><td>强引用计数+1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_RELEASE</td><td>强引用计数-1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_INCREFS</td><td>弱引用计数+1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_DECREFS</td><td>若引用计数-1请求</td><td style="text-align:center">binder_ptr_cookie</td></tr><tr><td style="text-align:left">BR_DEAD_BINDER</td><td>发送死亡通知</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BR_CLEAR_DEATH_NOTIFICATION_DONE</td><td>清理死亡通知完成</td><td style="text-align:center">binder_uintptr_t</td></tr><tr><td style="text-align:left">BR_DEAD_REPLY</td><td>告知发送方对方已经死亡</td><td style="text-align:center">void</td></tr><tr><td style="text-align:left">BR_ACQUIRE_RESULT</td><td>暂未实现</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BR_ATTEMPT_ACQUIRE</td><td>暂未实现</td><td style="text-align:center">-</td></tr><tr><td style="text-align:left">BR_FINISHED</td><td>暂未实现</td><td style="text-align:center">-</td></tr></tbody></table><p>单独看上面的协议可能很难理解，这里我们以一次Binder请求过程来详细看一下Binder协议是如何通信的，就比较好理解了。</p><p>这幅图的说明如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/18-Android-binder_transaction_ipc.jpg" alt="Markdown"></p><p>Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色 Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据 BC_XXX命令是进程发送给驱动的命令 BR_XXX命令是驱动发送给进程的命令 整个通信过程由Binder驱动控制</p><h4 id="2-4、binder-open"><a href="#2-4、binder-open" class="headerlink" title="2.4、binder_open()"></a>2.4、binder_open()</h4><p>任何进程在使用Binder之前，都需要先通过open(“/dev/binder”)打开Binder设备。上文已经提到，用户空间的open系统调用对应了驱动中的binder_open函数。在这个函数，Binder驱动会为调用的进程做一些初始化工作。binder_open函数代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_open</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建进程对应的binder_proc对象</span></span><br><span class="line">    proc = kzalloc(<span class="keyword">sizeof</span>(*proc), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    get_task_struct(current);</span><br><span class="line">    proc-&gt;tsk = current;</span><br><span class="line">    <span class="comment">// 初始化binder_proc</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;todo);</span><br><span class="line">    init_waitqueue_head(&amp;proc-&gt;wait);</span><br><span class="line">    proc-&gt;default_priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁保护</span></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line"></span><br><span class="line">    binder_stats_created(BINDER_STAT_PROC);</span><br><span class="line">    <span class="comment">// 添加到全局列表binder_procs中</span></span><br><span class="line">    hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs);</span><br><span class="line">    proc-&gt;pid = current-&gt;group_leader-&gt;pid;</span><br><span class="line">    INIT_LIST_HEAD(&amp;proc-&gt;delivered_death);</span><br><span class="line">    filp-&gt;private_data = proc;</span><br><span class="line"></span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Binder驱动中，通过binder_procs记录了所有使用Binder的进程。每个初次打开Binder设备的进程都会被添加到这个列表中的。</p><p>另外，请读者回顾一下上文介绍的Binder驱动中的几个关键结构体：</p><blockquote><p>binder_proc binder_node binder_thread binder_ref binder_buffer</p></blockquote><p>在实现过程中，为了便于查找，这些结构体互相之间都留有字段存储关联的结构。</p><p>下面这幅图描述了这里说到的这些内容：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/19-Android-binder_main_struct.png" alt="Markdown"></p><h4 id="2-5、binder-mmap"><a href="#2-5、binder-mmap" class="headerlink" title="2.5、binder_mmap()"></a>2.5、binder_mmap()</h4><p>在打开Binder设备之后，进程还会通过mmap进行内存映射。mmap的作用有如下两个：</p><p>申请一块内存空间，用来接收Binder通信过程中的数据 对这块内存进行地址映射，以便将来访问 binder_mmap函数对应了mmap系统调用的处理，这个函数也是Binder驱动的精华所在（这里说的binder_mmap函数也包括其内部调用的binder_update_page_range函数，见下文）。</p><p>前文我们说到，使用Binder机制，数据只需要经历一次拷贝就可以了，其原理就在这个函数中。</p><p>binder_mmap这个函数中，会申请一块物理内存，然后在用户空间和内核空间同时对应到这块内存上。在这之后，当有Client要发送数据给Server的时候，只需一次，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/20-Android-mmap_and_transaction.png" alt="Markdown"></p><p>这幅图的说明如下：</p><p>Server在启动之后，调用对/dev/binder设备调用mmap 内核中的binder_mmap函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射 Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间 驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问 了解原理之后，我们再来看一下Binder驱动的相关源码。这段代码有两个函数：</p><p>binder_mmap函数对应了mmap的系统调用的处理 binder_update_page_range函数真正实现了内存分配和地址映射</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> *<span class="title">area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">buffer</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">   <span class="comment">// 在内核空间获取一块地址范围</span></span><br><span class="line">    area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP);</span><br><span class="line">    <span class="keyword">if</span> (area == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"get_vm_area"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_get_vm_area_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer = area-&gt;addr;</span><br><span class="line">    <span class="comment">// 记录内核空间与用户空间的地址偏移</span></span><br><span class="line">    proc-&gt;user_buffer_offset = vma-&gt;vm_start - (<span class="keyword">uintptr_t</span>)proc-&gt;buffer;</span><br><span class="line">    mutex_unlock(&amp;binder_mmap_lock);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">    proc-&gt;pages = kzalloc(<span class="keyword">sizeof</span>(proc-&gt;pages[<span class="number">0</span>]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;pages == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -ENOMEM;</span><br><span class="line">        failure_string = <span class="string">"alloc page array"</span>;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_pages_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start;</span><br><span class="line"></span><br><span class="line">    vma-&gt;vm_ops = &amp;binder_vm_ops;</span><br><span class="line">    vma-&gt;vm_private_data = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* binder_update_page_range assumes preemption is disabled */</span></span><br><span class="line">    preempt_disable();</span><br><span class="line">    <span class="comment">// 通过下面这个函数真正完成内存的申请和地址的映射</span></span><br><span class="line">    <span class="comment">// 初次使用，先申请一个PAGE_SIZE大小的内存</span></span><br><span class="line">    ret = binder_update_page_range(proc, <span class="number">1</span>, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_update_page_range</span><span class="params">(struct binder_proc *proc, <span class="keyword">int</span> allocate,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *start, <span class="keyword">void</span> *end,</span></span></span><br><span class="line"><span class="function"><span class="params">                    struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *page_addr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> user_page_addr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_struct</span> <span class="title">tmp_area</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> **<span class="title">page_array_ptr</span>;</span></span><br><span class="line">        page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE];</span><br><span class="line"></span><br><span class="line">        BUG_ON(*page);</span><br><span class="line">        <span class="comment">// 真正进行内存的分配</span></span><br><span class="line">        *page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO);</span><br><span class="line">        <span class="keyword">if</span> (*page == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pr_err(<span class="string">"%d: binder_alloc_buf failed for page at %p\n"</span>,</span><br><span class="line">                proc-&gt;pid, page_addr);</span><br><span class="line">            <span class="keyword">goto</span> err_alloc_page_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp_area.addr = page_addr;</span><br><span class="line">        tmp_area.size = PAGE_SIZE + PAGE_SIZE <span class="comment">/* guard page? */</span>;</span><br><span class="line">        page_array_ptr = page;</span><br><span class="line">        <span class="comment">// 在内核空间进行内存映射</span></span><br><span class="line">        ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_err(<span class="string">"%d: binder_alloc_buf failed to map page at %p in kernel\n"</span>,</span><br><span class="line">                   proc-&gt;pid, page_addr);</span><br><span class="line">            <span class="keyword">goto</span> err_map_kernel_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        user_page_addr =</span><br><span class="line">            (<span class="keyword">uintptr_t</span>)page_addr + proc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">// 在用户空间进行内存映射</span></span><br><span class="line">        ret = vm_insert_page(vma, user_page_addr, page[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            pr_err(<span class="string">"%d: binder_alloc_buf failed to map page at %lx in userspace\n"</span>,</span><br><span class="line">                   proc-&gt;pid, user_page_addr);</span><br><span class="line">            <span class="keyword">goto</span> err_vm_insert_page_failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* vm_insert_page does not seem to increment the refcount */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mm) &#123;</span><br><span class="line">        up_write(&amp;mm-&gt;mmap_sem);</span><br><span class="line">        mmput(mm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preempt_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>binder_update_page_range主要完成工作：分配物理空间，将物理空间映射到内核空间，将物理空间映射到进程空间. 另外，不同参数下该方法也可以释放物理页面。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/21-Android-binder_mmap.png" alt="Markdown"></p><h4 id="2-6、binder-ioctl-内存管理"><a href="#2-6、binder-ioctl-内存管理" class="headerlink" title="2.6、binder_ioctl()内存管理"></a>2.6、binder_ioctl()内存管理</h4><p>上文中，我们看到binder_mmap的时候，会申请一个PAGE_SIZE(通常是4K)的内存。而实际使用过程中，一个PAGE_SIZE的大小通常是不够的。</p><p>在驱动中，会根据实际的使用情况进行内存的分配。有内存的分配，当然也需要内存的释放。这里我们就来看看Binder驱动中是如何进行内存的管理的。</p><p>首先，我们还是从一次IPC请求说起。</p><p>当一个Client想要对Server发出请求时，它首先将请求发送到Binder设备上，由Binder驱动根据请求的信息找到对应的目标节点，然后将请求数据传递过去。</p><p>进程通过ioctl系统调用来发出请求：ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</p><p>这里的bs-&gt;fd对应了打开Binder设备时的fd。BINDER_WRITE_READ对应了具体要做的操作码，这个操作码将由Binder驱动解析。bwr存储了请求数据，其类型是binder_write_read。</p><p>binder_write_read其实是一个相对外层的数据结构，其内部会包含一个binder_transaction_data结构的数据。binder_transaction_data包含了发出请求者的标识，请求的目标对象以及请求所需要的参数。它们的关系如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/22-Android-binder_write_read.png" alt="Markdown"></p><p>binder_ioctl函数对应了ioctl系统调用的处理。这个函数的逻辑比较简单，就是根据ioctl的命令来确定进一步处理的逻辑，具体如下:</p><p>● 如果命令是BINDER_WRITE_READ，并且<br>● 如果 bwr.write_size &gt; 0，则调用binder_thread_write<br>● 如果 bwr.read_size &gt; 0，则调用binder_thread_read<br>● 如果命令是BINDER_SET_MAX_THREADS，则设置进程的max_threads，即进程支持的最大线程数<br>● 如果命令是BINDER_SET_CONTEXT_MGR，则设置当前进程为ServiceManager，见下文<br>● 如果命令是BINDER_THREAD_EXIT，则调用binder_free_thread，释放binder_thread<br>● 如果命令是BINDER_VERSION，则返回当前的Binder版本号 这其中，最关键的就是binder_thread_write方法。当Client请求Server的时候，便会发送一个BINDER_WRITE_READ命令，同时框架会将将实际的数据包装好。此时，binder_transaction_data中的code将是BC_TRANSACTION，由此便会调用到binder_transaction方法，这个方法是对一次Binder事务的处理，这其中会调用binder_alloc_buf函数为此次事务申请一个缓存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in">free</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> allow_user_free:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> async_transaction:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> debug_id:<span class="number">29</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">transaction</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> data_size;</span><br><span class="line">    <span class="keyword">size_t</span> offsets_size;</span><br><span class="line">    <span class="keyword">uint8_t</span> data[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而在binder_proc（描述了使用Binder的进程）中，包含了几个字段用来管理进程在Binder IPC过程中缓存，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">buffers</span>;</span> <span class="comment">// 进程拥有的buffer列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">free_buffers</span>;</span> <span class="comment">// 空闲buffer列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">allocated_buffers</span>;</span> <span class="comment">// 已使用的buffer列表</span></span><br><span class="line">    <span class="keyword">size_t</span> free_async_space; <span class="comment">// 剩余的异步调用的空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> buffer_size; <span class="comment">// 缓存的上限</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程在mmap时，会设定支持的总缓存大小的上限（下文会讲到）。而进程每当收到BC_TRANSACTION，就会判断已使用缓存加本次申请的和有没有超过上限。如果没有，就考虑进行内存的分配。</p><p>进程的空闲缓存记录在binder_proc的free_buffers中，这是一个以红黑树形式存储的结构。每次尝试分配缓存的时候，会从这里面按大小顺序进行查找，找到最接近需要的一块缓存。查找的逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">    buffer = rb_entry(n, struct binder_buffer, rb_node);</span><br><span class="line">    BUG_ON(!buffer-&gt;<span class="built_in">free</span>);</span><br><span class="line">    buffer_size = binder_buffer_size(proc, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; buffer_size) &#123;</span><br><span class="line">        best_fit = n;</span><br><span class="line">        n = n-&gt;rb_left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; buffer_size)</span><br><span class="line">        n = n-&gt;rb_right;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        best_fit = n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到之后，还需要对binder_proc中的字段进行相应的更新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">rb_erase(best_fit, &amp;proc-&gt;free_buffers);</span><br><span class="line">buffer-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">binder_insert_allocated_buffer(proc, buffer);</span><br><span class="line"><span class="keyword">if</span> (buffer_size != size) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer</span> *<span class="title">new_buffer</span> = (<span class="title">void</span> *)<span class="title">buffer</span>-&gt;<span class="title">data</span> + <span class="title">size</span>;</span></span><br><span class="line">    list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);</span><br><span class="line">    new_buffer-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    binder_insert_free_buffer(proc, new_buffer);</span><br><span class="line">&#125;</span><br><span class="line">binder_debug(BINDER_DEBUG_BUFFER_ALLOC,</span><br><span class="line">         <span class="string">"%d: binder_alloc_buf size %zd got %p\n"</span>,</span><br><span class="line">          proc-&gt;pid, size, buffer);</span><br><span class="line">buffer-&gt;data_size = data_size;</span><br><span class="line">buffer-&gt;offsets_size = offsets_size;</span><br><span class="line">buffer-&gt;async_transaction = is_async;</span><br><span class="line"><span class="keyword">if</span> (is_async) &#123;</span><br><span class="line">    proc-&gt;free_async_space -= size + <span class="keyword">sizeof</span>(struct binder_buffer);</span><br><span class="line">    binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC,</span><br><span class="line">             <span class="string">"%d: binder_alloc_buf size %zd async free %zd\n"</span>,</span><br><span class="line">              proc-&gt;pid, size, proc-&gt;free_async_space);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再来看看内存的释放。</p><p>BC_FREE_BUFFER命令是通知驱动进行内存的释放，binder_free_buf函数是真正实现的逻辑，这个函数与binder_alloc_buf是刚好对应的。在这个函数中，所做的事情包括：</p><p>重新计算进程的空闲缓存大小 通过binder_update_page_range释放内存 更新binder_proc的buffers，free_buffers，allocated_buffers字段</p><h4 id="2-7、Binder中的”面向对象”"><a href="#2-7、Binder中的”面向对象”" class="headerlink" title="2.7、Binder中的”面向对象”"></a>2.7、<strong>Binder中的”面向对象”</strong></h4><p>Binder机制淡化了进程的边界，使得跨越进程也能够调用到指定服务的方法，其原因是因为Binder机制在底层处理了在进程间的”对象”传递。</p><p>在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。Binder驱动中，通过flat_binder_object来描述需要跨越进程传递的对象。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> &#123;</span></span><br><span class="line">    __u32        type;</span><br><span class="line">    __u32        flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">binder_uintptr_t</span>    binder; <span class="comment">/* local object */</span></span><br><span class="line">        __u32            handle;    <span class="comment">/* remote object */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">binder_uintptr_t</span>    cookie;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这其中，type有如下5种类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    BINDER_TYPE_BINDER    = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_BINDER    = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'b'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_HANDLE    = B_PACK_CHARS(<span class="string">'s'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_WEAK_HANDLE    = B_PACK_CHARS(<span class="string">'w'</span>, <span class="string">'h'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">    BINDER_TYPE_FD        = B_PACK_CHARS(<span class="string">'f'</span>, <span class="string">'d'</span>, <span class="string">'*'</span>, B_TYPE_LARGE),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当对象传递到Binder驱动中的时候，由驱动来进行翻译和解释，然后传递到接收的进程。</p><p>例如当Server把Binder实体传递给Client时，在发送数据流中，flat_binder_object中的type是BINDER_TYPE_BINDER，同时binder字段指向Server进程用户空间地址。但这个地址对于Client进程是没有意义的（Linux中，每个进程的地址空间是互相隔离的），驱动必须对数据流中的flat_binder_object做相应的翻译：将type该成BINDER_TYPE_HANDLE；为这个Binder在接收进程中创建位于内核中的引用并将引用号填入handle中。对于发生数据流中引用类型的Binder也要做同样转换。经过处理后接收进程从数据流中取得的Binder引用才是有效的，才可以将其填入数据包binder_transaction_data的target.handle域，向Binder实体发送请求。</p><p>由于每个请求和请求的返回都会经历内核的翻译，因此这个过程从进程的角度来看是完全透明的。进程完全不用感知这个过程，就好像对象真的在进程间来回传递一样。</p><h4 id="2-8、驱动层的线程管理"><a href="#2-8、驱动层的线程管理" class="headerlink" title="2.8、驱动层的线程管理"></a>2.8、<strong>驱动层的线程管理</strong></h4><p>上文多次提到，Binder本身是C/S架构。由Server提供服务，被Client使用。既然是C/S架构，就可能存在多个Client会同时访问Server的情况。 在这种情况下，如果Server只有一个线程处理响应，就会导致客户端的请求可能需要排队而导致响应过慢的现象发生。解决这个问题的方法就是引入多线程。</p><p>Binder机制的设计从最底层–驱动层，就考虑到了对于多线程的支持。具体内容如下：</p><p>使用Binder的进程在启动之后，通过BINDER_SET_MAX_THREADS告知驱动其支持的最大线程数量 驱动会对线程进行管理。在binder_proc结构中，这些字段记录了进程中线程的信息：max_threads，requested_threads，requested_threads_started，ready_threads binder_thread结构对应了Binder进程中的线程 驱动通过BR_SPAWN_LOOPER命令告知进程需要创建一个新的线程 进程通过BC_ENTER_LOOPER命令告知驱动其主线程已经ready 进程通过BC_REGISTER_LOOPER命令告知驱动其子线程（非主线程）已经ready 进程通过BC_EXIT_LOOPER命令告知驱动其线程将要退出 在线程退出之后，通过BINDER_THREAD_EXIT告知Binder驱动。驱动将对应的binder_thread对象销毁</p><h4 id="2-9、再聊ServiceManager"><a href="#2-9、再聊ServiceManager" class="headerlink" title="2.9、再聊ServiceManager"></a>2.9、再聊ServiceManager</h4><p>上文已经说过，每一个Binder Server在驱动中会有一个binder_node进行对应。同时，Binder驱动会负责在进程间传递服务对象，并负责底层的转换。另外，我们也提到，每一个Binder服务都需要有一个唯一的名称。由ServiceManager来管理这些服务的注册和查找。</p><p>而实际上，为了便于使用，ServiceManager本身也实现为一个Server对象。任何进程在使用ServiceManager的时候，都需要先拿到指向它的标识。然后通过这个标识来使用ServiceManager。</p><p>这似乎形成了一个互相矛盾的现象：</p><p>通过ServiceManager我们才能拿到Server的标识 ServiceManager本身也是一个Server 解决这个矛盾的办法其实也很简单：Binder机制为ServiceManager预留了一个特殊的位置。这个位置是预先定好的，任何想要使用ServiceManager的进程只要通过这个特定的位置就可以访问到ServiceManager了（而不用再通过ServiceManager的接口）。</p><p>在Binder驱动中，有一个全局的binder_node 变量：</p><blockquote><p><strong>一般情况下，对于每一个Server驱动层会对应一个binder_node节点，然而binder_context_mgr_node比较特殊，它没有对应的应用层binder实体。在整个系统里，它是如此特殊，以至于系统规定，任何应用都必须使用句柄0来跨进程地访问它。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">binder_context_mgr_node</span>;</span></span><br></pre></td></tr></table></figure><p>这个变量指向的就是ServiceManager。</p><p>当有进程通过ioctl并指定命令为BINDER_SET_CONTEXT_MGR的时候，驱动被认定这个进程是ServiceManager，binder_ioctl()函数中对应的处理如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BINDER_SET_CONTEXT_MGR:</span><br><span class="line">    <span class="keyword">if</span> (binder_context_mgr_node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    binder_context_mgr_uid = current-&gt;cred-&gt;euid;</span><br><span class="line">    binder_context_mgr_node = binder_new_node(proc, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//在Binder驱动层创建binder_node结构体对象</span></span><br><span class="line">    binder_context_mgr_node-&gt;local_weak_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;local_strong_refs++;</span><br><span class="line">    binder_context_mgr_node-&gt;has_strong_ref = <span class="number">1</span>;</span><br><span class="line">    binder_context_mgr_node-&gt;has_weak_ref = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>ServiceManager应当要先于所有Binder Server之前启动。在它启动完成并告知Binder驱动之后，驱动便设定好了这个特定的节点。</p><p>在这之后，当有其他模块想要使用ServerManager的时候，只要将请求指向ServiceManager所在的位置即可。</p><p>在Binder驱动中，通过handle = 0这个位置来访问ServiceManager。例如，binder_transaction中，判断如果target.handler为0，则认为这个请求是发送给ServiceManager的，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">    ref = binder_get_ref(proc, tr-&gt;target.handle, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        binder_user_error(<span class="string">"%d:%d got transaction to invalid handle\n"</span>,</span><br><span class="line">            proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">    &#125;</span><br><span class="line">    target_node = ref-&gt;node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target_node = binder_context_mgr_node;</span><br><span class="line">    <span class="keyword">if</span> (target_node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_DEAD_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_no_context_mgr_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-10、binder-node等重要结构体"><a href="#2-10、binder-node等重要结构体" class="headerlink" title="2.10、binder_node等重要结构体"></a>2.10、binder_node等重要结构体</h4><blockquote><p>binder_proc binder_node binder_thread binder_ref binder_buffer</p></blockquote><p><strong>1. Binder实体binder_node</strong></p><p>Binder实体，是各个Server以及ServiceManager在内核中的存在形式。 Binder实体实际上是内核中binder_node结构体的对象，它的作用是在内核中保存Server和ServiceManager的信息(例如，Binder实体中保存了Server对象在用户空间的地址)。简言之，Binder实体是Server在Binder驱动中的存在形式，内核通过Binder实体可以找到用户空间的Server对象。 在上图中，Server和ServiceManager在Binder驱动中都对应的存在一个Binder实体。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/26-Android-Binder_node_struct.png" alt="Markdown"></p><p><strong>2. Binder引用binder_ref</strong></p><p>说到Binder实体，就不得不说”Binder引用”。所谓Binder引用，实际上是内核中binder_ref结构体的对象，它的作用是在表示”Binder实体”的引用。换句话说，每一个Binder引用都是某一个Binder实体的引用，通过Binder引用可以在内核中找到它对应的Binder实体。 如果将Server看作是Binder实体的话，那么Client就好比Binder引用。Client要和Server通信，它就是通过保存一个Server对象的Binder引用，再通过该Binder引用在内核中找到对应的Binder实体，进而找到Server对象，然后将通信内容发送给Server对象。</p><p>Binder实体和Binder引用都是内核(即，Binder驱动)中的数据结构。每一个Server在内核中就表现为一个Binder实体，而每一个Client则表现为一个Binder引用。这样，每个Binder引用都对应一个Binder实体，而每个Binder实体则可以多个Binder引用。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/24-Android-binder_ref.png" alt="Markdown"></p><p><strong>3、Binder buffer：binder_buffer</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/99-Android-Binder-IPCall.png" alt="Markdown"></p><p><strong>4、Binder进程binder_proc</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/25-Android-binder_proc.png" alt="Markdown"></p><p><strong>5、Binder线程binder_thread</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/27-Android-binder_thread.png" alt="Markdown"></p><p>binder机制到底是如何从Binder对象找到其对应的Binder实体呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/28-Android-Bp-Bbinder.png" alt="Markdown"></p><p>注意其中的那4个rb_root域，”rb”的意思是”red black”，可见binder_proc里搞出了4个红黑树。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/29-Android-binder_proc_red_root.png" alt="Markdown"></p><p>其中，nodes树用于记录binder实体，refs_by_desc树和refs_by_node树则用于记录binder代理。之所以会有两个代理树，是为了便于快速查找，我们暂时只关心其中之一就可以了。threads树用于记录执行传输动作的线程信息。</p><p>在一个进程中，有多少”被其他进程进行跨进程调用的”binder实体，就会在该进程对应的nodes树中生成多少个红黑树节点。另一方面，一个进程要访问多少其他进程的binder实体，则必须在其refs_by_desc树中拥有对应的引用节点。</p><p>这4棵树的节点类型是不同的，threads树的节点类型为binder_thread，nodes树的节点类型为binder_node，refs_by_desc树和refs_by_node树的节点类型相同，为binder_ref。这些节点内部都会包含rb_node子结构，该结构专门负责连接节点的工作，和前文的hlist_node有点儿异曲同工，这也是linux上一个常用的小技巧。我们以nodes树为例<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/30-Android-binder_proc_hlist_node.png" alt="Markdown"></p><p>nodes树是用于记录binder实体的，所以nodes树中的每个binder_node节点，必须能够记录下相应binder实体的信息。因此请大家注意binder_node的ptr域和cookie域。</p><p>另一方面，refs_by_desc树和refs_by_node树的每个binder_ref节点则和上层的一个BpBinder对应，而且更重要的是，它必须具有和”目标binder实体的binder_node”进行关联的信息。</p><p>请注意binder_ref的那个node域，它负责和binder_node关联。另外，binder_ref中有两个类型为rb_node的域：rb_node_desc域和rb_node_node域，它们分别用于连接refs_by_desc树和refs_by_node。也就是说虽然binder_proc中有两棵引用树，但这两棵树用到的具体binder_ref节点其实是复用的。</p><blockquote><p>binder_node.ptr对应于flat_binder_object.binder； binder_node.cookie对应于flat_binder_object.cookie。</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/31-Android-binder_ref-find-binder_node.png" alt="Markdown"><br>OK，现在我们可以更深入地说明binder句柄的作用了，比如进程1的BpBinder在发起跨进程调用时，向binder驱动传入了自己记录的句柄值，binder驱动就会在”进程1对应的binder_proc结构”的引用树中查找和句柄值相符的binder_ref节点，一旦找到binder_ref节点，就可以通过该节点的node域找到对应的binder_node节点，这个目标binder_node当然是从属于进程2的binder_proc啦，不过不要紧，因为binder_ref和binder_node都处于binder驱动的地址空间中，所以是可以用指针直接指向的。目标binder_node节点的cookie域，记录的其实是进程2中BBinder的地址，binder驱动只需把这个值反映给应用层，应用层就可以直接拿到BBinder了。这就是Binder完成精确打击的大体过程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/32-Android-binder_relationship.jpg" alt="Markdown"></p><h2 id="三、Android-Binder系统驱动情景分析"><a href="#三、Android-Binder系统驱动情景分析" class="headerlink" title="三、Android Binder系统驱动情景分析"></a>三、Android Binder系统驱动情景分析</h2><p>为了更深刻的了解Binder系统 注册服务、获取服务、使用服务的过程，在Driver层(kernel/drivers/staging/android/binder.c)的binder_thread_read()函数、binder_transaction()函数入打印log，让前面编写的C程序示例与binder驱动交互打印更详细的过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/weidongshan/DRV_0003_Binder/" target="_blank" rel="noopener">已添加好打印log的binder.c文件见GitHub（注：搜索[/* print] 关键字）</a> 事先已经准备好打印log，现在结合log和Binder事务处理开始详细分析。注：log稍后分析再贴出。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/33-Android-binder_transaction_ipc.jpg" alt="Markdown"></p><h3 id="（1）、Binder系统驱动情景分析–服务”Hello”注册过程"><a href="#（1）、Binder系统驱动情景分析–服务”Hello”注册过程" class="headerlink" title="（1）、Binder系统驱动情景分析–服务”Hello”注册过程"></a>（1）、Binder系统驱动情景分析–服务”Hello”注册过程</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/35-Android-binder-add_service.png" alt="Markdown"></p><h4 id="1-1、ServiceManager休眠等待"><a href="#1-1、ServiceManager休眠等待" class="headerlink" title="1.1、ServiceManager休眠等待"></a>1.1、ServiceManager休眠等待</h4><p>回顾一下ServiceManager启动流程，ServiceManager进入binder_loop()后 会休眠等待响应client请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">binder_loop()&#123;</span><br><span class="line">    <span class="comment">// 告诉Kernel，ServiceManager进程进入了消息循环状态。</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">unsigned</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向Kernel中发送消息(先写后读)。</span></span><br><span class="line">        <span class="comment">// 先将消息传递给Kernel，然后再从Kernel读取消息反馈</span></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        <span class="comment">// 解析读取的消息反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, readbuf, bwr.read_consumed, func);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_write(bs, readbuf, sizeof(unsigned));会调用ioctl向内核发送数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果 bwr.write_size &gt; 0，则调用binder_thread_write 如果 bwr.read_size &gt;0，则调用binder_thread_read</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断等待函数。</span></span><br><span class="line">  ret = wait_event_interruptible(...);</span><br><span class="line">  <span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></span><br><span class="line">  thread = binder_get_thread(proc);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bwr.write_size &gt; 0; 继续查看binder_thread_write()</p><blockquote><p>注：只有BR_TRANSACTION、BR_REPLY、BC_TRANSACTION、BC_REPLY涉及两进程 其他所有BC_XXX、BR_XXX都只是App和驱动交互用于改变报告状态。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_ENTER_LOOPER:</span><br><span class="line">            thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程进入BC_ENTER_LOOPER状态，等待请求。 继续binder_loop()中的for(;;;)循环，bwr.read_size &gt;0;会通过binder_thread_read()读操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line">  <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">  <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line">      <span class="comment">// 修改指针位置</span></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到驱动put_user(BR_NOOP, (uint32_t __user *)ptr)发送BR_NOOP到ServiceManager</p><blockquote><p>对于所有的读操作，数据头都是BR_NOOP，如BR_REPLY<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/36-Android-binder-BWR-read-BR_NOOP.png" alt="Markdown"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  ./service_manager &amp;</span><br><span class="line">&gt; [   32.566620] service_manager (1362, 1362), binder_thread_write : BC_ENTER_LOOPER</span><br><span class="line">&gt; [   32.566712] service_manager (1362, 1362), binder_thread_read : BR_NOOP</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="1-2、Clent（此处为Test-server）请求SM添加服务"><a href="#1-2、Clent（此处为Test-server）请求SM添加服务" class="headerlink" title="1.2、Clent（此处为Test_server）请求SM添加服务"></a>1.2、Clent（此处为Test_server）请求SM添加服务</h4><p><strong>构造数据发送给驱动</strong> 我们执行Test_server时，打印了很多数据，我们首先看一下数据的构造过程 和 组织格式，这有助于加深我们对binder系统的理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">svcmgr_publish</span><span class="params">(struct binder_state *bs, <span class="keyword">uint32_t</span> target, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">unsigned</span> iodata[<span class="number">512</span>/<span class="number">4</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>, <span class="title">reply</span>;</span></span><br><span class="line"></span><br><span class="line">    bio_init(&amp;msg, iodata, <span class="keyword">sizeof</span>(iodata), <span class="number">4</span>);</span><br><span class="line">    bio_put_uint32(&amp;msg, <span class="number">0</span>);  <span class="comment">// strict mode header</span></span><br><span class="line">    bio_put_string16_x(&amp;msg, SVC_MGR_NAME);</span><br><span class="line">    bio_put_string16_x(&amp;msg, name);</span><br><span class="line">    bio_put_obj(&amp;msg, ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    status = bio_get_uint32(&amp;reply);</span><br><span class="line">    binder_done(bs, &amp;msg, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bio_init()、bio_put_uint32()、bio_put_string16_x()函数比较简洁。我们看下bio_put_obj()函数。 构建初始化flat_binder_object结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void bio_put_obj(struct binder_io *bio, void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    struct flat_binder_object *obj;</span><br><span class="line"></span><br><span class="line">    obj = bio_alloc_obj(bio);</span><br><span class="line">    if (!obj)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;//</span><br><span class="line">    obj-&gt;type = BINDER_TYPE_BINDER;//</span><br><span class="line">    obj-&gt;binder = (uintptr_t)ptr;//</span><br><span class="line">    obj-&gt;cookie = 0;//0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据结构示意图：</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/37-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><p>Clent（此处为Test_server），test_server.c调用流程： -&gt;svcmgr_publish() -&gt;binder_call() -&gt;ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) -&gt;binder_thread_write() -&gt;binder_transaction()</p><p>现在数据构造好了，binder_call()会调用ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_call</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_io *msg, struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">uint32_t</span> target, <span class="keyword">uint32_t</span> code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">txn</span>;</span></span><br><span class="line">    &#125; __attribute__((packed)) writebuf;</span><br><span class="line">    <span class="keyword">unsigned</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    writebuf.cmd = BC_TRANSACTION;</span><br><span class="line">    writebuf.txn.target.handle = target;</span><br><span class="line">    writebuf.txn.code = code;</span><br><span class="line">    writebuf.txn.flags = <span class="number">0</span>;</span><br><span class="line">    writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0;</span><br><span class="line">    writebuf.txn.offsets_size = ((<span class="keyword">char</span>*) msg-&gt;offs) - ((<span class="keyword">char</span>*) msg-&gt;offs0);</span><br><span class="line">    writebuf.txn.data.ptr.buffer = (<span class="keyword">uintptr_t</span>)msg-&gt;data0;</span><br><span class="line">    writebuf.txn.data.ptr.offsets = (<span class="keyword">uintptr_t</span>)msg-&gt;offs0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="keyword">sizeof</span>(writebuf);</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>) &amp;writebuf;</span><br><span class="line"></span><br><span class="line">    hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">        ...</span><br><span class="line">        res = binder_parse(bs, reply, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[ 38.320197] test_server (1363, 1363), binder_thread_write : BC_TRANSACTION 发送数据，进而会调用binder_thread_write()处理数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">binder_ioctl(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 中断等待函数。</span></span><br><span class="line">  ret = wait_event_interruptible(...);</span><br><span class="line">  <span class="comment">// 在proc进程中查找该线程对应的binder_thread；若查找失败，则新建一个binder_thread，并添加到proc-&gt;threads中。</span></span><br><span class="line">  thread = binder_get_thread(proc);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line">          ...</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于write_size&gt;0，调用binder_thread_write()处理数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由之前binder_call()分析，writebuf.cmd = BC_TRANSACTION;会执行binder_transaction()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            target_node = ref-&gt;node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 事务目标对象是ServiceManager的binder实体</span></span><br><span class="line">            <span class="comment">// 即，该事务是交给Service Manager来处理的。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置处理事务的目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间,从目的进程映射的空间分配buf</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// 保存事务的目标对象(即处理该事务的binder对象)</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户空间的数据"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户空间的数据中所含对象的偏移地址"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.offsets就是数据中的对象偏移地址数组，tr-&gt;offsets_size就数据中的对象个数</span></span><br><span class="line">    <span class="comment">// 拷贝之后，offp就是flat_binder_object对象数组在内核空间的偏移数组的起始地址</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// off_end就是flat_binder_object对象数组在内核空间的偏移地址的结束地址</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 将所有的flat_binder_object对象读取出来</span></span><br><span class="line">    <span class="comment">// 对TestServer而言，只有一个flat_binder_object对象。</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">        <span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span>;</span></span><br><span class="line">            <span class="comment">// 在proc中查找binder实体对应的binder_node</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span> = <span class="title">binder_get_node</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">binder</span>);</span></span><br><span class="line">            <span class="comment">// 若找不到，则新建一个binder_node；下次就可以直接使用了。</span></span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 在target_proc(即，ServiceManager的进程上下文)中查找是否包行"该Binder实体的引用"，</span></span><br><span class="line">            <span class="comment">// 如果没有找到的话，则将"该binder实体的引用"添加到target_proc-&gt;refs_by_node红黑树中。这样，就可以通过Service Manager对该</span></span><br><span class="line">Binder实体进行管理了。</span><br><span class="line">            ref = binder_get_ref_for_node(target_proc, node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 现在修改目的进程type，表示ServiceManager持有TestServer引用，TestServer进程才能拥有实体。</span></span><br><span class="line">            <span class="keyword">if</span> (fp-&gt;type == BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type = BINDER_TYPE_HANDLE;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            <span class="comment">// 修改handle。handle和binder是联合体，这里将handle设为引用的描述。</span></span><br><span class="line">            <span class="comment">// 根据该handle可以找到"该binder实体在target_proc中的binder引用"；</span></span><br><span class="line">            <span class="comment">// 即，可以根据该handle，可以从Service Manager找到对应的Binder实体的引用，从而获取Binder实体。</span></span><br><span class="line">            fp-&gt;handle = ref-&gt;desc;</span><br><span class="line">            <span class="comment">// 增加引用计数，防止"该binder实体"在使用过程中被销毁。</span></span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 将当前事务添加到当前线程的事务栈中</span></span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：这里的tr-&gt;target.handle=0，因此，会设置target_node为ServiceManager对应的Binder实体。下面是target_node,target_proc等值初始化之后的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target_node = binder_context_mgr_node; <span class="comment">// 目标节点为Service Manager对应的Binder实体</span></span><br><span class="line">target_proc = target_node-&gt;proc;       <span class="comment">// 目标进程为Service Manager对应的binder_proc进程上下文信息</span></span><br><span class="line">target_list = &amp;target_thread-&gt;todo;    <span class="comment">// 待处理事务队列</span></span><br><span class="line">target_wait = &amp;target_thread-&gt;wait;    <span class="comment">// 等待队列</span></span><br></pre></td></tr></table></figure><p>小结： 驱动接收到TestServer发送的数据后，驱动主要工作： （1）根据Handle = 0 找到目的进程ServiceManager （2）把数据通过copy_from_user()放到目的进程ServiceManager的空间（mmap） （3）处理offs数据，即解析flat_binder_object结构体 a. 为TestServer构造binder_node node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); b.构造binder_ref给目的进程ServiceManager ref = binder_get_ref_for_node(target_proc, node); c.增加引用计数TestServer binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); 增加引用计数会添加work.entry（BR_INCREFS、BR_ACQUIR）到TestServer todod队列 list_add_tail(&amp;node-&gt;work.entry, target_list)</p><p>说明：就新建Binder实体的引用，并将其添加到target_proc-&gt;refs_by_node红黑树 和 target_proc-&gt;refs_by_desc红黑树中。 这样，ServiceManager的进程上下文中就存在Hello Service的Binder引用，ServiceManager也就可以对Hello Service进行管理了！然后，修改fp-&gt;type=BINDER_TYPE_HANDLE，并使fp-&gt;handle = ref-&gt;desc。</p><p>（4)新建一个待处理事务t和待完成的工作tcomplete，并对它们进行初始化。待处理事务t会被提交给目标(即ServiceManager对应的Binder实体)进行处理；而待完成的工作tcomplete则是为了反馈给TestServer服务，告诉TestServer它的请求Binder驱动已经收到了。注意，这里仅仅是告诉TestServer该请求已经被收到，而不是处理完毕！待ServiceManager处理完毕该请求之后，Binder驱动会再次反馈相应的消息给TestServer。 （5）binder_thread_write()中执行binder_transaction()后，会更新*consumed的值，即bwr.write_consumed的值 （6）此时，TestServer进程还会继续运行，而且它也通过wake_up_interruptible()唤醒了ServiceManager进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">*consumed = ptr - buffer;</span><br></pre></td></tr></table></figure><p>接下来，ioctl()会执行binder_thread_read()来设置反馈数据给TestServer进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先发送BR_NOOP给TestServer，然后处理todo队列，处理完成后会发送BR_TRANSACTION_COMPLETE。</p><p>现在内核已经处理完数据，我们从log看看数据发生了哪些变化： 我们发现flat_binder_object结构体的type值发生了变化，binder变成了Handle，看一下结构体，handler 和 binder是一个union，占用同一个位置；Handle为1代表第一个引用，意思是在ServiceManager进程里面根据1能找到第一个binder_ref，根据binder_ref能找到服务hello的binder_node实体。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/38-Android-binder-flat_binder_object.png" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/39-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><p>接下来就等待ServiceManager处理完成后，回复消息。</p><h4 id="1-3、唤醒ServiceManager执行添加”hello”服务"><a href="#1-3、唤醒ServiceManager执行添加”hello”服务" class="headerlink" title="1.3、唤醒ServiceManager执行添加”hello”服务"></a>1.3、唤醒ServiceManager执行添加”hello”服务</h4><p>前面驱动已经创建好TestServer的binder_node，现在唤醒ServiceManager添加svcinfo 看看ServiceManager被唤醒后，会干些什么。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_WORK_TRANSACTION: &#123;</span><br><span class="line">                t = container_of(w, struct binder_transaction, work);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// t-&gt;buffer-&gt;target_node是目标节点。</span></span><br><span class="line">        <span class="comment">// 这里，addService请求的目标是ServiceManager，因此target_node是ServiceManager对应的节点；</span></span><br><span class="line">        <span class="comment">// 它的值在事务交互时(binder_transaction中)，被赋值为ServiceManager对应的Binder实体。  </span></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;buffer-&gt;target_node) &#123;</span><br><span class="line">            <span class="comment">// 事务目标对应的Binder实体(即，ServiceManager对应的Binder实体)</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">t</span>-&gt;<span class="title">buffer</span>-&gt;<span class="title">target_node</span>;</span></span><br><span class="line">            <span class="comment">// Binder实体在用户空间的地址(ServiceManager的ptr为NULL)</span></span><br><span class="line">            tr.target.ptr = target_node-&gt;ptr;</span><br><span class="line">            <span class="comment">// Binder实体在用户空间的其它数据(ServiceManager的cookie为NULL)</span></span><br><span class="line">            tr.cookie =  target_node-&gt;cookie;</span><br><span class="line">            t-&gt;saved_priority = task_nice(current);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp;</span><br><span class="line">                !(t-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">                binder_set_nice(t-&gt;priority);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) ||</span><br><span class="line">                 t-&gt;saved_priority &gt; target_node-&gt;min_priority)</span><br><span class="line">                binder_set_nice(target_node-&gt;min_priority);</span><br><span class="line">            **cmd = BR_TRANSACTION;<span class="comment">//将命令改为BR_TRANSACTION</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.target.ptr = <span class="literal">NULL</span>;</span><br><span class="line">            tr.cookie = <span class="literal">NULL</span>;</span><br><span class="line">            cmd = BR_REPLY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交易码</span></span><br><span class="line">        tr.code = t-&gt;code;</span><br><span class="line">        tr.flags = t-&gt;flags;</span><br><span class="line">        tr.sender_euid = t-&gt;sender_euid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t-&gt;from) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">sender</span> = <span class="title">t</span>-&gt;<span class="title">from</span>-&gt;<span class="title">proc</span>-&gt;<span class="title">tsk</span>;</span></span><br><span class="line">            tr.sender_pid = task_tgid_nr_ns(sender,</span><br><span class="line">                            current-&gt;nsproxy-&gt;pid_ns);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据大小</span></span><br><span class="line">        tr.data_size = t-&gt;buffer-&gt;data_size;</span><br><span class="line">        <span class="comment">// 数据中对象的偏移数组的大小(即对象的个数)</span></span><br><span class="line">        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;</span><br><span class="line">        <span class="comment">// 数据</span></span><br><span class="line">        tr.data.ptr.buffer = (<span class="keyword">void</span> *)t-&gt;buffer-&gt;data +</span><br><span class="line">                    proc-&gt;user_buffer_offset;</span><br><span class="line">        <span class="comment">// 数据中对象的偏移数组</span></span><br><span class="line">        tr.data.ptr.offsets = tr.data.ptr.buffer +</span><br><span class="line">                    ALIGN(t-&gt;buffer-&gt;data_size,</span><br><span class="line">                        <span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将cmd指令写入到ptr，即传递到用户空间</span></span><br><span class="line">        <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        <span class="comment">// 将tr数据拷贝到用户空间</span></span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(ptr, &amp;tr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 删除已处理的事务</span></span><br><span class="line">        list_del(&amp;t-&gt;work.entry);</span><br><span class="line">        t-&gt;buffer-&gt;allow_user_free = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 设置回复信息</span></span><br><span class="line">        <span class="keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">            <span class="comment">// 该事务会发送给Service Manager守护进程进行处理。</span></span><br><span class="line">            <span class="comment">// Service Manager处理之后，还需要给Binder驱动回复处理结果。</span></span><br><span class="line">            <span class="comment">// 这里设置Binder驱动回复信息。</span></span><br><span class="line">            t-&gt;to_parent = thread-&gt;transaction_stack;</span><br><span class="line">            <span class="comment">// to_thread表示Service Manager反馈后，将反馈结果交给当前thread进行处理</span></span><br><span class="line">            t-&gt;to_thread = thread;</span><br><span class="line">            <span class="comment">// transaction_stack交易栈保存当前事务。用于之处反馈是针对哪个事务的。</span></span><br><span class="line">            thread-&gt;transaction_stack = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：ServiceManager进程在调用wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))进入等待之后，被TestServer进程唤醒。唤醒之后，binder_has_thread_work()为true，因为ServiceManager的待处理事务队列中有个待处理事务(即，TestServer添加服务的请求)。 (01) 进入while循环后，首先取出待处理事务。 (02) 事务的类型是BINDER_WORK_TRANSACTION，得到对应的binder_transaction*类型指针t之后，跳出switch语句。很显然，此时t不为NULL，因此继续往下执行。下面的工作的目的，是将t中的数据转移到tr中(tr是事务交互数据包结构体binder_transaction_data对应的指针)，然后将指令和tr数据都拷贝到用户空间，让ServiceManager读取后进行处理。</p><p>Service Manager守护进程在处理完事务之后，需要反馈结果给Binder驱动。因此，接下来会设置t-&gt;to_thread和t-&gt;transaction_stack等成员。最后，修改*consumed的值，即bwr.read_consumed的值，表示待读取内容的大小。 执行完binder_thread_read()之后，回到binder_ioctl()中，执行copy_to_user()将数据拷贝到用户空间。接下来，就回到了Service Manager的守护进程当中，即回到binder_loop()中。 binder_loop()会将ioctl()反馈的数据发送给binder_parse()进行解析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_NOOP:</span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会调用svcmgr_handler()-&gt;do_add_service()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint32_t</span> handle, <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">pid_t</span> spid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">                    svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到首先为hello服务新分配一个结构体svcinfo，然后将handle赋值给svcinfo，这也是以后我们查找服务所得到的handle。 然后调动了binder_acquire、binder_link_to_death发送信息给驱动。 [ 38.467270] service_manager (1362, 1362), binder_thread_write : BC_ACQUIRE [ 38.480122] service_manager (1362, 1362), binder_thread_write : BC_REQUEST_DEATH_NOTIFICATION 接着看binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_send_reply</span><span class="params">(struct binder_state *bs,</span></span></span><br><span class="line"><span class="function"><span class="params">                       struct binder_io *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">binder_uintptr_t</span> buffer_to_free,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> status)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data.cmd_free = BC_FREE_BUFFER;</span><br><span class="line">    data.buffer = buffer_to_free;</span><br><span class="line">    data.cmd_reply = BC_REPLY;</span><br><span class="line">    data.txn.target.ptr = <span class="number">0</span>;</span><br><span class="line">    data.txn.cookie = <span class="number">0</span>;</span><br><span class="line">    data.txn.code = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">    binder_write(bs, &amp;data, <span class="keyword">sizeof</span>(data));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有BC_FREE_BUFFER、BC_REPLY，通过binder_write(bs, &amp;data, sizeof(data))回复BC_REPLY到驱动。</p><p>驱动处理消息跟之前流程类似，这里不再分析。简单总结： 1、驱动接收到BC_REPLY请求，会新建一个待处理事务t（TestServer处理）和待完成的工作tcomplete（service_manager处理） 2、然后唤醒TestServer处理BC_REPLY请求 至此，已经成功添加Hello Service svcmgr: add_service(‘hello’), handle = 1</p><h3 id="（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程"><a href="#（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程" class="headerlink" title="（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程"></a>（2）、Binder系统驱动情景分析–TestClent获取”Hello”服务过程</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/40-Android-binder-binder_get_service.png" alt="Markdown"></p><h4 id="2-0、构造数据"><a href="#2-0、构造数据" class="headerlink" title="2.0、构造数据"></a>2.0、构造数据</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/41-Android-binder-getSvr-Binder-io-transaction-data.jpg" alt="Markdown"></p><h4 id="2-1、发送数据给ServiceManager"><a href="#2-1、发送数据给ServiceManager" class="headerlink" title="2.1、发送数据给ServiceManager"></a>2.1、发送数据给ServiceManager</h4><p>bwr初始化完成之后，调用ioctl(,BINDER_WRITE_READ,)和Binder驱动进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> size = _IOC_SIZE(cmd);</span><br><span class="line">  <span class="keyword">void</span> __user *ubuf = (<span class="keyword">void</span> __user *)arg;</span><br><span class="line">  <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">  <span class="keyword">case</span> BINDER_WRITE_READ: &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">      <span class="comment">// 将binder_write_read从"用户空间" 拷贝到 "内核空间"</span></span><br><span class="line">      <span class="keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果write_size&gt;0，则进行写操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.write_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_write(proc, thread, (<span class="keyword">void</span> __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果read_size&gt;0，则进行读操作</span></span><br><span class="line">      <span class="keyword">if</span> (bwr.read_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          ret = binder_thread_read(proc, thread, (<span class="keyword">void</span> __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags   &amp; O_NONBLOCK);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="keyword">sizeof</span>(bwr))) &#123;</span><br><span class="line">          ret = -EFAULT;</span><br><span class="line">          <span class="keyword">goto</span> err;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，会将binder_write_read从用户空间拷贝到内核空间之后。拷贝之后，读取出来的bwr.write_size和bwr.read_size都&gt;0，因此先写后读。即，先执行binder_thread_write()，然后执行binder_thread_read()。</p><h4 id="2-2、binder-thread-write-处理数据"><a href="#2-2、binder-thread-write-处理数据" class="headerlink" title="2.2、binder_thread_write()处理数据"></a>2.2、binder_thread_write()处理数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">      ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：MediaPlayer发送的指令是BC_TRANSACTION，这里只关心与BC_TRANSACTION相关的部分。在通过copy_from_user()将数据拷贝从用户空间拷贝到内核空间之后，就调用binder_transaction()进行处理。</p><h4 id="2-3、Binder驱动中binder-transaction-的源码"><a href="#2-3、Binder驱动中binder-transaction-的源码" class="headerlink" title="2.3、Binder驱动中binder_transaction()的源码"></a>2.3、Binder驱动中binder_transaction()的源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tr-&gt;target.handle) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该getService是从ServiceManager中获取MediaPlayer；</span></span><br><span class="line">            <span class="comment">// 因此事务目标对象是ServiceManager的binder实体。</span></span><br><span class="line">            target_node = binder_context_mgr_node;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置处理事务的目标进程</span></span><br><span class="line">        target_proc = target_node-&gt;proc;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target_list = &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置from，表示该事务是MediaPlayer线程发起的</span></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 下面的一些赋值是初始化事务t</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// 事务编码</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    <span class="comment">// 事务标志</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">// 事务优先级</span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    ...</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// 保存事务的目标对象(即处理该事务的binder对象)</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户空间的数据"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// tr-&gt;data.ptr.buffer就是用户空间数据的起始地址，tr-&gt;data_size就是数据大小</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户空间的数据中所含对象的偏移地址"拷贝到内核中</span></span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, offp=null</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, off_end为null</span></span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// MediaPlayer中不包含对象, offp=off_end</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">        t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">        <span class="comment">// 将当前事务添加到当前线程的事务栈中</span></span><br><span class="line">        thread-&gt;transaction_stack = t;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：参数reply=0，表明这是个请求事务，而不是反馈。binder_transaction新建会新建”一个待处理事务t”和”待完成的工作tcomplete”，并根据请求的数据对它们进行初始化。 (01) TestClent的getService请求是提交给ServiceManager进行处理的，因此，”待处理事务t”会被添加到ServiceManager的待处理事务队列中。此时的target_thread是ServiceManager对应的线程，而target_proc则是ServiceManager对应的进程上下文环境。 (02) 此时，Binder驱动已经收到了TestClent的getService请求；于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”添加到当前线程(即，TestClent线程)的待处理事务队列中。目的是告诉TestClent，Binder驱动已经收到它的getService请求了。 (03) 最后，调用wake_up_interruptible(target_wait)将ServiceManager唤醒。</p><p>接下来，还是先分析完TestClent线程，再看ServiceManager被唤醒后做了些什么。</p><p>binder_transaction()执行完毕之后，就会返回到binder_thread_write()中。binder_thread_write()更新bwr.write_consumed的值后，就返回到binder_ioctl()继续执行”读”动作。即执行binder_thread_read()。</p><h4 id="2-4、Binder驱动中binder-thread-read-的源码"><a href="#2-4、Binder驱动中binder-thread-read-的源码" class="headerlink" title="2.4、Binder驱动中binder_thread_read()的源码"></a>2.4、Binder驱动中binder_thread_read()的源码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_thread_read</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">void</span>  __user *buffer, <span class="keyword">int</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">signed</span> <span class="keyword">long</span> *consumed, <span class="keyword">int</span> non_block)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">    <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> wait_for_proc_work;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果*consumed=0，则写入BR_NOOP到用户传进来的bwr.read_buffer缓存区</span></span><br><span class="line">    <span class="keyword">if</span> (*consumed == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (put_user(BR_NOOP, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 等待proc进程的事务标记。</span></span><br><span class="line">    <span class="comment">// 当线程的事务栈为空 并且 待处理事务队列为空时，该标记位true。</span></span><br><span class="line">    wait_for_proc_work = thread-&gt;transaction_stack == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                list_empty(&amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait_for_proc_work) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前线程的"待完成工作"不为空，则取出待完成工作。</span></span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;thread-&gt;todo))</span><br><span class="line">            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work)</span><br><span class="line">            ...</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) <span class="comment">/* no data added */</span></span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (w-&gt;type) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE: &#123;</span><br><span class="line">            cmd = BR_TRANSACTION_COMPLETE;</span><br><span class="line">            <span class="comment">// 将BR_TRANSACTION_COMPLETE写入到用户缓冲空间中</span></span><br><span class="line">            <span class="keyword">if</span> (put_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 待完成事务已经处理完毕，将其从待完成事务队列中删除。</span></span><br><span class="line">            list_del(&amp;w-&gt;entry);</span><br><span class="line">            kfree(w);</span><br><span class="line">            binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 更新bwr.read_consumed的值</span></span><br><span class="line">    *consumed = ptr - buffer;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： (01) bwr.read_consumed=0，即if (*consumed == 0)为true。因此，会将BR_NOOP写入到bwr.read_buffer中。 (02) thread-&gt;transaction_stack不为空，thread-&gt;todo也不为空。因为，前面在binder_transaction()中有将一个BINDER_WORK_TRANSACTION_COMPLETE类型的待完成工作添加到thread的待完成工作队列中。因此，wait_for_proc_work为false。 (03) binder_has_thread_work(thread)为true。因此，在调用wait_event_interruptible()时，不会进入等待状态，而是继续运行。 (04) 进入while循环后，通过list_first_entry()取出待完成工作w。w的类型w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETE，进入到对应的switch分支。随后，将BR_TRANSACTION_COMPLETE写入到bwr.read_buffer中。此时，待处理工作已经完成，将其从当前线程的待处理工作队列中删除。 (05) 最后，更新bwr.read_consumed的值。</p><p>经过binder_thread_read()处理之后，bwr.read_buffer中包含了两个指令：BR_NOOP和BR_TRANSACTION_COMPLETE。</p><h4 id="2-5、ServiceManager处理getService请求"><a href="#2-5、ServiceManager处理getService请求" class="headerlink" title="2.5、ServiceManager处理getService请求"></a>2.5、ServiceManager处理getService请求</h4><p>下面看看ServiceManager被唤醒之后，是如何处理getService请求的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uint32_t *ptr, uint32_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_txn *txn = (void *) ptr;</span><br><span class="line">            ...</span><br><span class="line">            if (func) &#123;</span><br><span class="line">                unsigned rdata[256/4];</span><br><span class="line">                struct binder_io msg;   // 用于保存&quot;Binder驱动反馈的信息&quot;</span><br><span class="line">                struct binder_io reply; // 用来保存&quot;回复给Binder驱动的信息&quot;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                // 初始化reply</span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                // 根据txt(Binder驱动反馈的信息)初始化msg</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                // 消息处理</span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                // 反馈消息给Binder驱动。</span><br><span class="line">                binder_send_reply(bs, &amp;reply, txn-&gt;data, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_send_reply(bs, &amp;reply, txn-&gt;data, res);-&gt;binder_write()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">binder_write()</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_write</span><span class="params">(struct binder_state *bs, <span class="keyword">void</span> *data, <span class="keyword">unsigned</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    bwr.write_size = len;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">unsigned</span>) data;</span><br><span class="line">    bwr.read_size = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"binder_write: ioctl failed (%s)\n"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：binder_write()会将数据封装到binder_write_read的变量bwr中；其中，bwr.read_size=0，而bwr.write_size&gt;0。接着，便通过ioctl(,BINDER_WRITE_READ,)和Binder驱动交互，将数据反馈给Binder驱动。</p><p>再次回到Binder驱动的binder_ioctl()对应的BINDER_WRITE_READ分支中。此时，由于bwr.read_size=0，而bwr.write_size&gt;0；因此，Binder驱动只调用binder_thread_write进行写操作，而不会进行读。</p><p>返回数据：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/42-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><p>handle = 1 代表第一个</p><h5 id="2-6、Binder驱动中处理ServiceManager返回数据"><a href="#2-6、Binder驱动中处理ServiceManager返回数据" class="headerlink" title="2.6、Binder驱动中处理ServiceManager返回数据"></a>2.6、Binder驱动中处理ServiceManager返回数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_thread_write</span><span class="params">(struct binder_proc *proc, struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="keyword">void</span> __user *buffer, <span class="keyword">int</span> size, <span class="keyword">signed</span> <span class="keyword">long</span> *consumed)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">  <span class="keyword">void</span> __user *ptr = buffer + *consumed;</span><br><span class="line">  <span class="keyword">void</span> __user *end = buffer + size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取binder_write_read.write_buffer中的内容。</span></span><br><span class="line">  <span class="comment">// 每次读取32bit(即4个字节)</span></span><br><span class="line">  <span class="keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123;</span><br><span class="line">      <span class="comment">// 从用户空间读取32bit到内核中，并赋值给cmd。</span></span><br><span class="line">      <span class="keyword">if</span> (get_user(cmd, (<span class="keyword">uint32_t</span> __user *)ptr))</span><br><span class="line">          <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">      ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BC_FREE_BUFFER:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line">        <span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      ...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 更新bwr.write_consumed的值</span></span><br><span class="line">      *consumed = ptr - buffer;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>binder_thread_write()进入BC_REPLY之后，会将数据拷贝到内核空间，然后调用binder_transaction()进行处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_transaction</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_thread *thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                   struct binder_transaction_data *tr, <span class="keyword">int</span> reply)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">tcomplete</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> *offp, *off_end;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">target_proc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">target_thread</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">target_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">target_list</span>;</span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> *target_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">in_reply_to</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_log_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> return_error;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        <span class="comment">// 事务栈</span></span><br><span class="line">        in_reply_to = thread-&gt;transaction_stack;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 设置优先级</span></span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        ...</span><br><span class="line">        thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">        <span class="comment">// 发起请求的线程，即MediaPlayer所在线程。</span></span><br><span class="line">        <span class="comment">// from的值，是MediaPlayer发起请求时在binder_transaction()中赋值的。</span></span><br><span class="line">        target_thread = in_reply_to-&gt;from;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// MediaPlayer对应的进程</span></span><br><span class="line">        target_proc = target_thread-&gt;proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">        target_list = &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait = &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待处理的事务t，t是binder事务(binder_transaction对象)</span></span><br><span class="line">    t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个待完成的工作tcomplete，tcomplete是binder_work对象。</span></span><br><span class="line">    tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id = ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from = thread;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 下面的一些赋值是初始化事务t</span></span><br><span class="line">    t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid;</span><br><span class="line">    <span class="comment">// 事务将交给target_proc进程进行处理</span></span><br><span class="line">    t-&gt;to_proc = target_proc;</span><br><span class="line">    <span class="comment">// 事务将交给target_thread线程进行处理</span></span><br><span class="line">    t-&gt;to_thread = target_thread;</span><br><span class="line">    <span class="comment">// 事务编码</span></span><br><span class="line">    t-&gt;code = tr-&gt;code;</span><br><span class="line">    <span class="comment">// 事务标志</span></span><br><span class="line">    t-&gt;flags = tr-&gt;flags;</span><br><span class="line">    <span class="comment">// 事务优先级</span></span><br><span class="line">    t-&gt;priority = task_nice(current);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        return_error = BR_FAILED_REPLY;</span><br><span class="line">        <span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">    <span class="comment">// 保存事务</span></span><br><span class="line">    t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">    <span class="comment">// target_node为NULL</span></span><br><span class="line">    t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    <span class="keyword">if</span> (target_node)</span><br><span class="line">        binder_inc_node(target_node, <span class="number">1</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offp = (<span class="keyword">size_t</span> *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"用户传入的数据"保存到事务中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将"用户传入的数据偏移地址"保存到事务中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    off_end = (<span class="keyword">void</span> *)offp + tr-&gt;offsets_size;</span><br><span class="line">    <span class="comment">// 将flat_binder_object对象读取出来，</span></span><br><span class="line">    <span class="comment">// 这里就是Service Manager中反馈的MediaPlayerService对象。</span></span><br><span class="line">    <span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (fp-&gt;type) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">                <span class="comment">// 根据handle获取对应的Binder引用，即得到MediaPlayerService的Binder引用</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> *<span class="title">ref</span> = <span class="title">binder_get_ref</span>(<span class="title">proc</span>, <span class="title">fp</span>-&gt;<span class="title">handle</span>);</span></span><br><span class="line">                <span class="keyword">if</span> (ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ref-&gt;node-&gt;proc是MediaPlayerService的进程上下文环境，</span></span><br><span class="line">                <span class="comment">// 而target_proc是MediaPlayer的进程上下文环境</span></span><br><span class="line">                <span class="keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    struct binder_ref *new_ref;</span><br><span class="line">                    <span class="comment">// 在MediaPlayer进程中引用"MediaPlayerService"。</span></span><br><span class="line">                    <span class="comment">// 表现为，执行binder_get_ref_for_node()会，会先在MediaPlayer进程中查找是否存在MediaPlayerService对应的Binder引用；</span></span><br><span class="line">                    <span class="comment">// 很显然是不存在的。于是，并新建MediaPlayerService对应的Binder引用，并将其添加到MediaPlayer的Binder引用红黑树中。</span></span><br><span class="line">                    new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                    <span class="keyword">if</span> (new_ref == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        ...</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将new_ref的引用描述复制给fp-&gt;handle。</span></span><br><span class="line">                    fp-&gt;handle = new_ref-&gt;desc;</span><br><span class="line">                    binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="literal">NULL</span>);</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置事务的类型为BINDER_WORK_TRANSACTION</span></span><br><span class="line">    t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line">    <span class="comment">// 将事务添加到target_list队列中，即target_list的待处理事务中</span></span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    <span class="comment">// 设置待完成工作的类型为BINDER_WORK_TRANSACTION_COMPLETE</span></span><br><span class="line">    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    <span class="comment">// 将待完成工作添加到thread-&gt;todo队列中，即当前线程的待完成工作中。</span></span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    <span class="comment">// 唤醒目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：reply=1，这里只关注reply部分。 (01) 此反馈最终是要回复给TestClient的。因此，target_thread被赋值为TestServer所在的线程，target_proc则是TestClient对应的进程，target_node为null。 (02) 这里，先看看for循环里面的内容，取出BR_REPLY指令所发送的数据，然后获取数据中的flat_binder_object变量fp。因为fp-&gt;type为BINDER_TYPE_HANDLE，因此进入BINDER_TYPE_HANDLE对应的分支。接着，通过binder_get_ref()获取Hello Service对应的Binder引用；很明显，能够正常获取到Hello Service的Binder引用。因为在Hello Service调用addService请求时，已经创建了它的Binder引用。 binder_get_ref_for_node()的作用是在TestClent进程上下文中添加”TestServer对应的Binder引用”。这样，后面就可以根据该Binder引用一步步的获取TestServer对象。 最后，将Binder引用的描述赋值给fp-&gt;handle。 (03) 此时，Service Manager已经处理了getService请求。便调用binder_pop_transaction(target_thread, in_reply_to)将事务从”target_thread的事务栈”中删除，即从MediaPlayer线程的事务栈中删除该事务。 (04) 新建的”待处理事务t”的type为设为BINDER_WORK_TRANSACTION后，会被添加到MediaPlayer的待处理事务队列中。 (05) 此时，Service Manager已经处理了getService请求，而Binder驱动在等待它的回复。于是，将一个BINDER_WORK_TRANSACTION_COMPLETE类型的”待完成工作tcomplete”(作为回复)添加到当前线程(即，Service Manager线程)的待处理事务队列中。 (06) 最后，调用wake_up_interruptible()唤醒TestServer。TestServer被唤醒后，会对事务BINDER_WORK_TRANSACTION进行处理。</p><p>OK，到现在为止，还有两个待处理事务：(01) ServiceManager待处理事务列表中有个BINDER_WORK_TRANSACTION_COMPLETE类型的事务 (02) TestServer待处理事务列表中有个BINDER_WORK_TRANSACTION事务。</p><h4 id="2-7-Testclient获取handle"><a href="#2-7-Testclient获取handle" class="headerlink" title="2.7. Testclient获取handle"></a>2.7. Testclient获取handle</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/43-Android-binder-binder_use_service.png" alt="Markdown"></p><h3 id="（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程"><a href="#（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程" class="headerlink" title="（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程"></a>（3）、Binder系统驱动情景分析–TestClent使用”Hello”服务过程</h3><p>构造数据发送数据”weidongshan”<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/44-Android-binder-Binder-io-transaction-data.jpg" alt="Markdown"></p><h2 id="四、Android-Binder系统-Native层"><a href="#四、Android-Binder系统-Native层" class="headerlink" title="四、Android Binder系统-Native层"></a>四、Android Binder系统-Native层</h2><p>前面我们分析内核驱动Binder使用过程，可以看到，binder系统在内核能正常完成IPC通信，接下来分析Android framwork层，最后是App层。</p><p>Framework是一个中间层，它对接了底层实现，封装了复杂的内部逻辑，并提供供外部使用的接口。Framework层是应用程序开发的基础。</p><p>Binder Framework层分为C++和Java两个部分，为了达到功能的复用，中间通过JNI进行衔接。</p><p>Binder Framework的C++部分，头文件位于这个路径：/frameworks/native/include/binder/，实现位于这个路径：/frameworks/native/libs/binder/ 。Binder库最终会编译成一个动态链接库：libbinder.so，供其他进程链接使用。</p><p>为了便于说明，下文中我们将Binder Framework 的C++部分称之为libbinder。首先说一下ServiceManager，然后详细介绍。</p><h3 id="1-、ServiceManager类图-Native层"><a href="#1-、ServiceManager类图-Native层" class="headerlink" title="(1)、ServiceManager类图(Native层)"></a>(1)、ServiceManager类图(Native层)</h3><p>IServiceManager相关类如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/45-Android-native_binder_framework_servicemananger.png" alt="Markdown"></p><p>IServiceManager是表示servicemanager的接口，有如下方法：</p><p>1) getService获得binder service引用，</p><p>2) checkService获得binder service引用，</p><p>3) addService添加binder service，</p><p>4) listServices 列举所有binder service。</p><p>servicemanager的binder service服务端其实是在frameworks/base/cmds/servicemanager 里实现，BnServiceMananger实际上并未使用。BpServiceMananger就是利用获得的IBinder指针建立的IServiceMananger对象的实际类型。</p><h3 id="2-、Binder框架Native层"><a href="#2-、Binder框架Native层" class="headerlink" title="(2)、Binder框架Native层"></a>(2)、Binder框架Native层</h3><p>libbinder中，将实现分为Proxy和Native两端。Proxy对应了上文提到的Client端，是服务对外提供的接口。而Native是服务实现的一端，对应了上文提到的Server端。类名中带有小写字母p的（例如BpInterface），就是指Proxy端。类名带有小写字母n的（例如BnInterface），就是指Native端。</p><p>Proxy代表了调用方，通常与服务的实现不在同一个进程，因此下文中，我们也称Proxy端为”远程”端。Native端是服务实现的自身，因此下文中，我们也称Native端为”本地”端。</p><p>这里，我们先对libbinder中的主要类做一个简要说明，了解一下它们的关系，然后再详细的讲解。</p><table><thead><tr><th style="text-align:left">类名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">BpRefBase</td><td style="text-align:left">RefBase的子类，提供remote()方法获取远程Binder</td></tr><tr><td style="text-align:left">IInterface</td><td style="text-align:left">Binder服务接口的基类，Binder服务通常需要同时提供本地接口和远程接口</td></tr><tr><td style="text-align:left">BpInterface</td><td style="text-align:left">远程接口的基类，远程接口是供客户端调用的接口集</td></tr><tr><td style="text-align:left">BnInterface</td><td style="text-align:left">本地接口的基类，本地接口是需要服务中真正实现的接口集</td></tr><tr><td style="text-align:left">IBiner</td><td style="text-align:left">Binder对象的基类，BBinder和BpBinder都是这个类的子类</td></tr><tr><td style="text-align:left">BpBinder</td><td style="text-align:left">远程Binder，这个类提供transact方法来发送请求，BpXXX实现中会用到</td></tr><tr><td style="text-align:left">BBinder</td><td style="text-align:left">本地Binder，服务实现方的基类，提供了onTransact接口来接收请求</td></tr><tr><td style="text-align:left">ProcessState</td><td style="text-align:left">代表了使用Binder的进程</td></tr><tr><td style="text-align:left">IPCThreadState</td><td style="text-align:left">代表了使用Binder的线程，这个类中封装了与Binder驱动通信的逻辑</td></tr><tr><td style="text-align:left">Parcel</td><td style="text-align:left">在Binder上传递的数据的包装器</td></tr></tbody></table><p>下图描述了这些类之间的关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/46-Androi-binder_middleware.png" alt="Markdown"></p><p>另外说明一下，Binder服务的实现类（图中紫色部分）通常都会遵守下面的命名规则：</p><p>☯ 服务的接口使用I字母作为前缀 ☯ 远程接口使用Bp作为前缀 ☯ 本地接口使用Bn作为前缀</p><p>看了上面这些介绍，你可能还是不太容易理解。不过不要紧，下面我们会逐步拆分讲解这些内容。</p><p>在这幅图中，浅黄色部分的结构是最难理解的，因此我们先从它们着手。</p><p>我们先来看看IBinder这个类。这个类描述了所有在Binder上传递的对象，它既是Binder本地对象BBinder的父类，也是Binder远程对象BpBinder的父类。这个类中的主要方法说明如下：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">localBinder</td><td style="text-align:left">获取本地Binder对象</td></tr><tr><td style="text-align:left">remoteBinder</td><td style="text-align:left">获取远程Binder对象</td></tr><tr><td style="text-align:left">transact</td><td style="text-align:left">进行一次Binder操作</td></tr><tr><td style="text-align:left">queryLocalInterface</td><td style="text-align:left">尝试获取本地Binder，如何失败返回NULL</td></tr><tr><td style="text-align:left">getInterfaceDescriptor</td><td style="text-align:left">获取Binder的服务接口描述，其实就是Binder服务的唯一标识</td></tr><tr><td style="text-align:left">isBinderAlive</td><td style="text-align:left">查询Binder服务是否还活着</td></tr><tr><td style="text-align:left">pingBinder</td><td style="text-align:left">发送PING_TRANSACTION给Binder服务</td></tr></tbody></table><p>BpBinder的实例代表了远程Binder，这个类的对象将被客户端调用。其中handle方法会返回指向Binder服务实现者的句柄，这个类最重要就是提供了transact方法，这个方法会将远程调用的参数封装好发送的Binder驱动。</p><p>由于每个Binder服务通常都会提供多个服务接口，而这个方法中的uint32_t code参数就是用来对服务接口进行编号区分的。Binder服务的每个接口都需要指定一个唯一的code，这个code要在Proxy和Native端配对好。当客户端将请求发送到服务端的时候，服务端根据这个code（onTransact方法中）来区分调用哪个接口方法。</p><p>BBinder的实例代表了本地Binder，它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现onTransact方法，因为这个方法是所有请求的入口。因此，这个方法是和BpBinder中的transact方法对应的，这个方法同样也有一个uint32_t code参数，在这个方法的实现中，由服务提供者通过code对请求的接口进行区分，然后调用具体实现服务的方法。</p><p>IBinder中定义了uint32_t code允许的范围：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FIRST_CALL_TRANSACTION  = <span class="number">0x00000001</span>,</span><br><span class="line">LAST_CALL_TRANSACTION   = <span class="number">0x00ffffff</span>,</span><br></pre></td></tr></table></figure><p>Binder服务要保证自己提供的每个服务接口有一个唯一的code，例如hello服务:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_SAYHELLO     1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_SAYHELLO_TO  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HELLO_SVR_CMD_GET_FD       3</span></span><br></pre></td></tr></table></figure><p>讲完了IBinder，BpBinder和BBinder三个类，我们再来看看BpReBase，IInterface，BpInterface和BnInterface。</p><p>每个Binder服务都是为了某个功能而实现的，因此其本身会定义一套接口集（通常是C++的一个类）来描述自己提供的所有功能。而Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的，例如：假设服务实现方提供了一个接口为sayhello(void)的服务方法，那么其远程接口中也应当有一个sayhello(void)方法。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类，IInterface的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IInterface</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">            IInterface();</span><br><span class="line">            <span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> IInterface*);</span><br><span class="line">            <span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> sp&lt;IInterface&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span>                     ~IInterface();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之所以要继承自IInterface类是因为这个类中定义了onAsBinder让子类实现。onAsBinder在本地对象的实现类中返回的是本地对象，在远程对象的实现类中返回的是远程对象。onAsBinder方法被两个静态方法asBinder方法调用。有了这些接口之后，在代码中便可以直接通过IXXX::asBinder方法获取到不用区分本地还是远程的IBinder对象。这个在跨进程传递Binder对象的时候有很大的作用（因为不用区分具体细节，只要直接调用和传递就好）。</p><p>下面，我们来看一下BpInterface和BnInterface的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BBinder</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IInterface&gt;      queryLocalInterface(<span class="keyword">const</span> String16&amp; _descriptor);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> String16&amp;     <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpInterface</span> :</span> <span class="keyword">public</span> INTERFACE, <span class="keyword">public</span> BpRefBase</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                BpInterface(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; remote);</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> IBinder*            <span class="title">onAsBinder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这两个类都是模板类，它们在继承自INTERFACE的基础上各自继承了另外一个类。这里的INTERFACE便是我们Binder服务接口的基类。另外，BnInterface继承了BBinder类，由此可以通过复写onTransact方法来提供实现。BpInterface继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-&gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。这个过程如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/47-Android-Binder-IPCall.png" alt="Markdown"></p><p>基于Binder框架开发的服务，除了满足上文提到的类名规则之外，还需要遵守其他一些共同的规约：</p><p>☯为了进行服务的区分，每个Binder服务需要指定一个唯一的标识，这个标识通过getInterfaceDescriptor返回，类型是一个字符串。通常，Binder服务会在类中定义static const android::String16 descriptor;这样一个常量来描述这个标识符，然后在getInterfaceDescriptor方法中返回这个常量。 ☯为了便于调用者获取到调用接口，服务接口的公共基类需要提供一个android::sp</p><ixxx> asInterface方法来返回基类对象指针。<br>由于上面提到的这两点对于所有Binder服务的实现逻辑都是类似的。为了简化开发者的重复工作，在libbinder中，定义了两个宏来简化这些重复工作，它们是：</ixxx><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_META_INTERFACE(INTERFACE)                            \</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> android::String16 descriptor;                       \</span><br><span class="line">    <span class="keyword">static</span> android::sp&lt;I##INTERFACE&gt; asInterface(                    \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj);               \</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> android::<span class="function">String16&amp; <span class="title">getInterfaceDescriptor</span><span class="params">()</span> <span class="keyword">const</span></span>; \</span><br><span class="line">    I##INTERFACE();                                                  \</span><br><span class="line">    <span class="keyword">virtual</span> ~I##INTERFACE();                                         \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMPLEMENT_META_INTERFACE(INTERFACE, NAME)                    \</span></span><br><span class="line">    <span class="keyword">const</span> android::String16 I##INTERFACE::descriptor(NAME);          \</span><br><span class="line">    <span class="keyword">const</span> android::String16&amp;                                         \</span><br><span class="line">            I##INTERFACE::getInterfaceDescriptor() <span class="keyword">const</span> &#123;           \</span><br><span class="line">        <span class="keyword">return</span> I##INTERFACE::descriptor;                             \</span><br><span class="line">    &#125;                                                                \</span><br><span class="line">    android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface(             \</span><br><span class="line">            <span class="keyword">const</span> android::sp&lt;android::IBinder&gt;&amp; obj)                \</span><br><span class="line">    &#123;                                                                \</span><br><span class="line">        android::sp&lt;I##INTERFACE&gt; intr;                              \</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;                                           \</span><br><span class="line">            intr = <span class="keyword">static_cast</span>&lt;I##INTERFACE*&gt;(                       \</span><br><span class="line">                obj-&gt;queryLocalInterface(                            \</span><br><span class="line">                        I##INTERFACE::descriptor).get());            \</span><br><span class="line">            <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;                                      \</span><br><span class="line">                intr = <span class="keyword">new</span> Bp##INTERFACE(obj);                       \</span><br><span class="line">            &#125;                                                        \</span><br><span class="line">        &#125;                                                            \</span><br><span class="line">        <span class="keyword">return</span> intr;                                                 \</span><br><span class="line">    &#125;                                                                \</span><br><span class="line">    I##INTERFACE::I##INTERFACE() &#123; &#125;                                 \</span><br><span class="line">    I##INTERFACE::~I##INTERFACE() &#123; &#125;                                \</span><br></pre></td></tr></table></figure><p>有了这两个宏之后，开发者只要在接口基类（IXXX）头文件中，使用DECLARE_META_INTERFACE宏便完成了需要的组件的声明。然后在cpp文件中使用IMPLEMENT_META_INTERFACE便完成了这些组件的实现。</p><h4 id="2-1、Binder的初始化ProcessState"><a href="#2-1、Binder的初始化ProcessState" class="headerlink" title="2.1、Binder的初始化ProcessState"></a>2.1、<strong>Binder的初始化ProcessState</strong></h4><p>在讲解Binder驱动的时候我们就提到：任何使用Binder机制的进程都必须要对/dev/binder设备进行open以及mmap之后才能使用，这部分逻辑是所有使用Binder机制进程共同的。对于这种共同逻辑的封装便是Framework层的职责之一。libbinder中，ProcessState类封装了这个逻辑，相关代码见下文。</p><p>这里是ProcessState构造函数，在这个函数中，初始化mDriverFD的时候调用了open_driver方法打开binder设备，然后又在函数体中，通过mmap进行内存映射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::ProcessState()</span><br><span class="line">    : mDriverFD(open_driver())</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(<span class="number">0</span>)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(<span class="number">0</span>)</span><br><span class="line">    , mManagesContexts(<span class="literal">false</span>)</span><br><span class="line">    , mBinderContextCheckFunc(<span class="literal">NULL</span>)</span><br><span class="line">    , mBinderContextUserData(<span class="literal">NULL</span>)</span><br><span class="line">    , mThreadPoolStarted(<span class="literal">false</span>)</span><br><span class="line">    , mThreadPoolSeq(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDriverFD &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open_driver的函数实现如下所示。在这个函数中完成了三个工作：</p><p>☯首先通过open系统调用打开了dev/binder设备 ☯然后通过ioctl获取Binder实现的版本号，并检查是否匹配 ☯最后通过ioctl设置进程支持的最大线程数量 关于这部分逻辑背后的处理，在讲解Binder驱动的时候，我们已经讲解过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_driver</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"/dev/binder"</span>, O_RDWR | O_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> vers = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> result = ioctl(fd, BINDER_VERSION, &amp;vers);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">size_t</span> maxThreads = DEFAULT_MAX_BINDER_THREADS;</span><br><span class="line">        result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState是一个Singleton（单例）类型的类，在一个进程中，只会存在一个实例。通过ProcessState::self()接口获取这个实例。一旦获取这个实例，便会执行其构造函数，由此完成了对于Binder设备的初始化工作。</p><h4 id="2-2、关于Binder传递数据的大小限制"><a href="#2-2、关于Binder传递数据的大小限制" class="headerlink" title="2.2、关于Binder传递数据的大小限制"></a>2.2、<strong>关于Binder传递数据的大小限制</strong></h4><p>由于Binder的数据需要跨进程传递，并且还需要在内核上开辟空间，因此允许在Binder上传递的数据并不是无无限大的。mmap中指定的大小便是对数据传递的大小限制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) <span class="comment">// 1M - 8k</span></span></span><br><span class="line">mVMStart = mmap(<span class="number">0</span>, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这里我们看到，在进行mmap的时候，指定了最大size为BINDER_VM_SIZE，即 1M - 8k的大小。 因此我们在开发过程中，一次Binder调用的数据总和不能超过这个大小。</p><p>对于这个区域的大小，我们也可以在设备上进行确认。这里我们还之前提到的system_server为例。上面我们讲解了通过procfs来获取映射的内存地址，除此之外，我们也可以通过showmap命令，来确定这块区域的大小，相关命令如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">angler:/ <span class="meta"># ps  | grep system_server                                            </span></span><br><span class="line">system    <span class="number">1889</span>  <span class="number">526</span>   <span class="number">2353404</span> <span class="number">135968</span> SyS_epoll_ <span class="number">72972</span>eeaf4 S system_server</span><br><span class="line">angler:/ <span class="meta"># showmap 1889 | grep <span class="meta-string">"/dev/binder"</span>                                   </span></span><br><span class="line">    <span class="number">1016</span>        <span class="number">4</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span>        <span class="number">4</span>        <span class="number">0</span>        <span class="number">0</span>    <span class="number">1</span> /dev/binder</span><br></pre></td></tr></table></figure><p>这里可以看到，这块区域的大小正是 1M - 8K = 1016k。</p><p>Tips: 通过showmap命令可以看到进程的详细内存占用情况。在实际的开发过程中，当我们要对某个进程做内存占用分析的时候，这个命令是相当有用的。建议读者尝试通过showmap命令查看system_server或其他感兴趣进程的完整map，看看这些进程都依赖了哪些库或者模块，以及内存占用情况是怎样的。</p><h4 id="2-3、与驱动的通信IPCThreadState"><a href="#2-3、与驱动的通信IPCThreadState" class="headerlink" title="2.3、与驱动的通信IPCThreadState"></a>2.3、<strong>与驱动的通信IPCThreadState</strong></h4><p>上文提到ProcessState是一个单例类，一个进程只有一个实例。而负责与Binder驱动通信的IPCThreadState也是一个单例类。但这个类不是一个进程只有一个实例，而是一个线程有一个实例。</p><p>IPCThreadState负责了与驱动通信的细节处理。这个类中的关键几个方法说明如下：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">transact</td><td style="text-align:left">公开接口。供Proxy发送数据到驱动，并读取返回结果</td></tr><tr><td style="text-align:left">sendReply</td><td style="text-align:left">供Server端写回请求的返回结果</td></tr><tr><td style="text-align:left">waitForResponse</td><td style="text-align:left">发送请求后等待响应结果</td></tr><tr><td style="text-align:left">talkWithDriver</td><td style="text-align:left">通过ioctl BINDER_WRITE_READ来与驱动通信</td></tr><tr><td style="text-align:left">writeTransactionData</td><td style="text-align:left">写入一次事务的数据</td></tr><tr><td style="text-align:left">executeCommand</td><td style="text-align:left">处理binder_driver_return_protocol协议命令</td></tr><tr><td style="text-align:left">freeBuffer</td><td style="text-align:left">通过BC_FREE_BUFFER命令释放Buffer</td></tr></tbody></table><p>BpBinder::transact方法在发送请求的时候，其实就是直接调用了IPCThreadState对应的方法来发送请求到Binder驱动的，相关代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而IPCThreadState::transact方法主要逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码应该还是比较好理解的：首先通过writeTransactionData写入数据，然后通过waitForResponse等待返回结果。TF_ONE_WAY表示此次请求是单向的，即：不用真正等待结果即可返回。</p><p>而writeTransactionData方法其实就是在组装binder_transaction_data数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于binder_transaction_data在讲解Binder驱动的时候我们已经详细讲解过了。而这里的Parcel我们还不了解，那么接下来我们马上就来看一下这个类。</p><p>数据包装器：Parcel Binder上提供的是跨进程的服务，每个服务包含了不同的接口，每个接口的参数数量和类型都不一样。那么当客户端想要调用服务端的接口，参数是如何跨进程传递给服务端的呢？除此之外，服务端想要给客户端返回结果，结果又是如何传递回来的呢？</p><p>这些问题的答案就是：Parcel。Parcel就像一个包装器，调用者可以以任意顺序往里面放入需要的数据，所有写入的数据就像是被打成一个整体的包，然后可以直接在Binde上传输。</p><p>Parcel提供了所有基本类型的写入和读出接口，下面是其中的一部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">status_t</span>            writeInt32(<span class="keyword">int32_t</span> val);</span><br><span class="line"><span class="keyword">status_t</span>            writeUint32(<span class="keyword">uint32_t</span> val);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span>            readUtf8FromUtf16(<span class="built_in">std</span>::<span class="built_in">string</span>* str) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">status_t</span>            readUtf8FromUtf16(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* str) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>*         <span class="title">readCString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>因此对于基本类型，开发者可以直接调用接口写入和读出。而对于非基本类型，需要由开发者将其拆分成基本类型然后写入到Parcel中（读出的时候也是一样）。 Parcel会将所有写入的数据进行打包，Parcel本身可以作为一个整体在进程间传递。接收方在收到Parcel之后，只要按写入同样的顺序读出即可。</p><p>这个过程，和我们现实生活中寄送包裹做法是一样的：我们将需要寄送的包裹放到硬纸盒中交给快递公司。快递公司将所有的包裹进行打包，然后集中放到运输车中送到目的地，到了目的地之后然后再进行拆分。</p><p>Parcel既包含C++部分的实现，也同时提供了Java的接口，中间通过JNI衔接。Java层的接口其实仅仅是一层包装，真正的实现都是位于C++部分中。 特别需要说明一下的是，Parcel类除了可以传递基本数据类型，还可以传递Binder对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法写入的是sp</p><ibinder>类型的对象，而IBinder既可能是本地Binder，也可能是远程Binder，这样我们就不可以不用关心具体细节直接进行Binder对象的传递。</ibinder><p>这也是为什么IInterface中定义了两个asBinder的static方法，如果你不记得了，请回忆一下这两个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> IInterface*);</span><br><span class="line"><span class="keyword">static</span> sp&lt;IBinder&gt;  asBinder(<span class="keyword">const</span> sp&lt;IInterface&gt;&amp;);</span><br></pre></td></tr></table></figure><p>而对于Binder驱动，我们前面已经讲解过：Binder驱动并不是真的将对象在进程间序列化传递，而是由Binder驱动完成了对于Binder对象指针的解释和翻译，使调用者看起来就像在进程间传递对象一样。</p><h4 id="2-4、Framework层的线程管理"><a href="#2-4、Framework层的线程管理" class="headerlink" title="2.4、Framework层的线程管理"></a>2.4、<strong>Framework层的线程管理</strong></h4><p>在讲解Binder驱动的时候，我们就讲解过驱动中对应线程的管理。这里我们再来看看，Framework层是如何与驱动层对接进行线程管理的。</p><p>ProcessState::setThreadPoolMaxThreadCount 方法中，会通过BINDER_SET_MAX_THREADS命令设置进程支持的最大线程数量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MAX_BINDER_THREADS 15</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> ProcessState::setThreadPoolMaxThreadCount(<span class="keyword">size_t</span> maxThreads) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != <span class="number">-1</span>) &#123;</span><br><span class="line">        mMaxThreads = maxThreads;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"Binder ioctl to set max threads failed: %s"</span>, strerror(-result));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此驱动便知道了该Binder服务支持的最大线程数。驱动在运行过程中，会根据需要，并在没有超过上限的情况下，通过BR_SPAWN_LOOPER命令通知进程创建线程：</p><p>IPCThreadState在收到BR_SPAWN_LOOPER请求之后，便会调用ProcessState::spawnPooledThread来创建线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::executeCommand(<span class="keyword">int32_t</span> cmd)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState::spawnPooledThread方法负责为线程设定名称并创建线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ProcessState::spawnPooledThread(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThreadPoolStarted) &#123;</span><br><span class="line">        String8 name = makeBinderThreadName();</span><br><span class="line">        ALOGV(<span class="string">"Spawning new pooled thread, name=%s\n"</span>, name.<span class="built_in">string</span>());</span><br><span class="line">        sp&lt;Thread&gt; t = <span class="keyword">new</span> PoolThread(isMain);</span><br><span class="line">        t-&gt;run(name.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程在run之后，会调用threadLoop将自身添加的线程池中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">threadLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   IPCThreadState::self()-&gt;joinThreadPool(mIsMain);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而IPCThreadState::joinThreadPool方法中，会根据当前线程是否是主线程发送BC_ENTER_LOOPER或者BC_REGISTER_LOOPER命令告知驱动线程已经创建完毕。整个调用流程如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/48-Android-binder_thread_create.jpg" alt="Markdown"></p><h3 id="（3）、Android-Binder系统-Native层添加hello服务"><a href="#（3）、Android-Binder系统-Native层添加hello服务" class="headerlink" title="（3）、Android Binder系统-Native层添加hello服务"></a>（3）、Android Binder系统-Native层添加hello服务</h3><h4 id="3-1、Client构造数据，发送数据给驱动"><a href="#3-1、Client构造数据，发送数据给驱动" class="headerlink" title="3.1、Client构造数据，发送数据给驱动"></a>3.1、<strong>Client构造数据，发送数据给驱动</strong></h4><p>首先看一下Native ServiceManager架构图</p><p>只讲数据构造过程。。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/49-Android-addService.jpg" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/50-Android-binder-BpBinder.png" alt="Markdown"></p><p>构造： [-&gt; IServiceManager.cpp ::BpServiceManager]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service, <span class="keyword">bool</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply; <span class="comment">//Parcel是数据通信包</span></span><br><span class="line">    <span class="comment">//写入头信息"android.os.IServiceManager"</span></span><br><span class="line">    data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());   </span><br><span class="line">    data.writeString16(name);        <span class="comment">// name为 "hello"</span></span><br><span class="line">    data.writeStrongBinder(service); <span class="comment">// HelloService对象，把一个binder实体“打扁”并写入parcel</span></span><br><span class="line">    data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// allowIsolated= false</span></span><br><span class="line">    <span class="comment">//remote()指向的是BpBinder对象</span></span><br><span class="line">    <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务注册过程：向ServiceManager注册服务hello Service，服务名为”hello”； 请大家注意上面data.writeStrongBinder()一句，它专门负责把一个binder实体”打扁”并写入parcel。其代码如下：</p><h4 id="3-2-1、-writeStrongBinder"><a href="#3-2-1、-writeStrongBinder" class="headerlink" title="3.2.1、* writeStrongBinder()"></a>3.2.1、<em>* writeStrongBinder()</em></h4><p>[-&gt; parcel.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Parcel::writeStrongBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> flatten_binder(ProcessState::self(), val, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、flatten-binder"><a href="#3-2-2、flatten-binder" class="headerlink" title="3.2.2、flatten_binder()"></a>3.2.2、<strong>flatten_binder()</strong></h4><p>[-&gt; parcel.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> flatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; <span class="comment">/*proc*/</span>,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binder, Parcel* out)</span><br><span class="line">&#123;</span><br><span class="line">    flat_binder_object obj;</span><br><span class="line"></span><br><span class="line">    obj.flags = <span class="number">0x7f</span> | FLAT_BINDER_FLAG_ACCEPTS_FDS;</span><br><span class="line">    <span class="keyword">if</span> (binder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder *local = binder-&gt;localBinder(); <span class="comment">//本地Binder不为空</span></span><br><span class="line">        <span class="keyword">if</span> (!local) &#123;</span><br><span class="line">            BpBinder *proxy = binder-&gt;remoteBinder();</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> handle = proxy ? proxy-&gt;handle() : <span class="number">0</span>;</span><br><span class="line">            obj.type = BINDER_TYPE_HANDLE;</span><br><span class="line">            obj.binder = <span class="number">0</span>;</span><br><span class="line">            obj.handle = handle;</span><br><span class="line">            obj.cookie = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//进入该分支</span></span><br><span class="line">            obj.type = BINDER_TYPE_BINDER;</span><br><span class="line">            obj.binder = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local-&gt;getWeakRefs());</span><br><span class="line">            obj.cookie = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(local);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finish_flatten_binder(binder, obj, out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/51-Android-Binder-flatten_binder.png" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/52-Android-Binder-flatten_binder.png" alt="Markdown"></p><p>将Binder对象扁平化，转换成flat_binder_object对象。 看到了吗？”打扁”的意思就是把binder对象整理成flat_binder_object变量，如果打扁的是binder实体，那么flat_binder_object用cookie域记录binder实体的指针，即BBinder指针，而如果打扁的是binder代理，那么flat_binder_object用handle域记录的binder代理的句柄值。</p><blockquote><p>总结：Parcel的数据区域分两个部分：mData和mObjects，所有的数据不管是基础数据类型还是对象实体，全都追加到mData里，mObjects是一个偏移量数组，记录所有存放在mData中的flat_binder_object实体的偏移量。</p></blockquote><h4 id="3-2-3、finish-flatten-binder"><a href="#3-2-3、finish-flatten-binder" class="headerlink" title="3.2.3、finish_flatten_binder()"></a>3.2.3、<strong>finish_flatten_binder()</strong></h4><p>将flat_binder_object写入out。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">static</span> status_t <span class="title">finish_flatten_binder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; , <span class="keyword">const</span> flat_binder_object&amp; flat, Parcel* out)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> out-&gt;writeObject(flat, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后flatten_binder()调用了一个关键的finish_flatten_binder()函数。这个函数内部会记录下刚刚被扁平化的flat_binder_object在parcel中的位置。说得更详细点儿就是，parcel对象内部会有一个buffer，记录着parcel中所有扁平化的数据，有些扁平数据是普通数据，而另一些扁平数据则记录着binder对象。所以parcel中会构造另一个mObjects数组，专门记录那些binder扁平数据所在的位置，示意图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/53-Android-Binder-parcel.png" alt="Markdown"></p><p>一旦到了向驱动层传递数据的时候，IPCThreadState::writeTransactionData()会先把Parcel数据整理成一个binder_transaction_data数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="keyword">int32_t</span> cmd, <span class="keyword">uint32_t</span> binderFlags,</span><br><span class="line">    <span class="keyword">int32_t</span> handle, <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, <span class="keyword">status_t</span>* statusBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">    tr.target.ptr = <span class="number">0</span>; <span class="comment">/* Don't pass uninitialized stack data to a remote process */</span></span><br><span class="line">    tr.target.handle = handle;</span><br><span class="line">    tr.code = code;</span><br><span class="line">    tr.flags = binderFlags;</span><br><span class="line">    tr.cookie = <span class="number">0</span>;</span><br><span class="line">    tr.sender_pid = <span class="number">0</span>;</span><br><span class="line">    tr.sender_euid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        tr.data_size = data.ipcDataSize();</span><br><span class="line">        tr.data.ptr.buffer = data.ipcData();</span><br><span class="line">        tr.offsets_size = data.ipcObjectsCount()*<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>);</span><br><span class="line">        tr.data.ptr.offsets = data.ipcObjects();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (statusBuffer) &#123;</span><br><span class="line">        tr.flags |= TF_STATUS_CODE;</span><br><span class="line">        *statusBuffer = err;</span><br><span class="line">        tr.data_size = <span class="keyword">sizeof</span>(<span class="keyword">status_t</span>);</span><br><span class="line">        tr.data.ptr.buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(statusBuffer);</span><br><span class="line">        tr.offsets_size = <span class="number">0</span>;</span><br><span class="line">        tr.data.ptr.offsets = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOut.writeInt32(cmd);</span><br><span class="line">    mOut.write(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/54-Android-binder-writeTransactionData.png" alt="Markdown"></p><h4 id="3-2-4-、waitForResponse"><a href="#3-2-4-、waitForResponse" class="headerlink" title="3.2.4 、waitForResponse()"></a>3.2.4 、<strong>waitForResponse()</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;<span class="comment">//目的就是把上面打包的mOut数据给kernel,接着看taklWithDriver();</span></span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">finish:</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数是与serviceManager通信的主要函数，首先会调用talkWithDriver()方法，将之前的打包在mOut中的数据打包成struct binder_write_read 对象，并通过ioctrl发送给kernel。</p><h4 id="3-2-5、-IPCThreadState-talkWithDriver"><a href="#3-2-5、-IPCThreadState-talkWithDriver" class="headerlink" title="3.2.5、 IPCThreadState::talkWithDriver"></a>3.2.5、 <strong>IPCThreadState::talkWithDriver</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="keyword">bool</span> doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    binder_write_read bwr;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//doReceive参数，默认是为true,上面我们看到没有传参数，那么doReceive = 1；</span></span><br><span class="line">    bwr.write_size = outAvail;</span><br><span class="line">    bwr.write_buffer = (<span class="keyword">uintptr_t</span>)mOut.data(); <span class="comment">//将mOut数据指针存放到这里,这就是我们上面打包的数据。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is what we'll read.</span></span><br><span class="line">    <span class="keyword">if</span> (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size = mIn.dataCapacity(); <span class="comment">//注意这里数据的大小，在我们new IPCThreadState对象时，已经初始化为256.</span></span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>)mIn.data(); <span class="comment">//mIn数据指针，放到这里</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bwr.read_size = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="number">0</span>) <span class="comment">//这里通过ioctl将数据写给kernel</span></span><br><span class="line">      .....</span><br><span class="line">    &#125; <span class="keyword">while</span> (err == -EINTR);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用就是将之前打包的数据通过系统调用ioctl发送给kernel，最终发送给kernel的数据是struct binder_write_read对象。该对象已经被打包了3次，它们的包含关系如下所示。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/55-Android-binder-Transaction_data.png" alt="Markdown"></p><h4 id="3-2-6、Client获取服务、处理回复数据过程"><a href="#3-2-6、Client获取服务、处理回复数据过程" class="headerlink" title="3.2.6、Client获取服务、处理回复数据过程"></a>3.2.6、<strong>Client获取服务、处理回复数据过程</strong></h4><p>内核会唤醒Client进程处理回复消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">          <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">          &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">            <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//当reply对象回收时，则会调用freeBuffer来回收内存</span></span><br><span class="line">                    reply-&gt;ipcSetDataReference(</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                        freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">          ...     </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-7、Parcel-ipcSetDataReference"><a href="#3-2-7、Parcel-ipcSetDataReference" class="headerlink" title="3.2.7、Parcel::ipcSetDataReference"></a>3.2.7、<strong>Parcel::ipcSetDataReference</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parcel::ipcSetDataReference(<span class="keyword">const</span> <span class="keyword">uint8_t</span>* data, <span class="keyword">size_t</span> dataSize,</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">binder_size_t</span>* objects, <span class="keyword">size_t</span> objectsCount, release_func relFunc, <span class="keyword">void</span>* relCookie)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">binder_size_t</span> minOffset = <span class="number">0</span>;</span><br><span class="line">    freeDataNoInit();</span><br><span class="line">    mError = NO_ERROR;</span><br><span class="line">    mData = <span class="keyword">const_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(data); <span class="comment">//这是有4个字节的buffer。且存放的数据是0</span></span><br><span class="line">    mDataSize = mDataCapacity = dataSize; <span class="comment">//之前申请的大小就是4个字节。</span></span><br><span class="line">    <span class="comment">//ALOGI("setDataReference Setting data size of %p to %lu (pid=%d)", this, mDataSize, getpid());</span></span><br><span class="line">    mDataPos = <span class="number">0</span>;</span><br><span class="line">    ALOGV(<span class="string">"setDataReference Setting data pos of %p to %zu"</span>, <span class="keyword">this</span>, mDataPos);</span><br><span class="line">    mObjects = <span class="keyword">const_cast</span>&lt;<span class="keyword">binder_size_t</span>*&gt;(objects); <span class="comment">//binder对象其实地址</span></span><br><span class="line">    mObjectsSize = mObjectsCapacity = objectsCount; <span class="comment">//binder对象的个数。</span></span><br><span class="line">    mNextObjectHint = <span class="number">0</span>;</span><br><span class="line">    mOwner = relFunc; <span class="comment">//释放内存的函数，后面我们就不进行了。</span></span><br><span class="line">    mOwnerCookie = relCookie;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mObjectsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">binder_size_t</span> offset = mObjects[i];</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; minOffset) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: bad object offset %"</span>PRIu64<span class="string">" &lt; %"</span>PRIu64<span class="string">"\n"</span>,</span><br><span class="line">                  __func__, (<span class="keyword">uint64_t</span>)offset, (<span class="keyword">uint64_t</span>)minOffset);</span><br><span class="line">            mObjectsSize = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minOffset = offset + <span class="keyword">sizeof</span>(flat_binder_object);</span><br><span class="line">    &#125;</span><br><span class="line">    scanForFds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面做的工作只是将事务数据分别安放到当前Parcel对象的相应位置。其中scanForFds（）是为了查找返回来的数据中是否有binder对象，这个在获取代理对象时有用。</p><h4 id="3-2-8、readStrongBinder"><a href="#3-2-8、readStrongBinder" class="headerlink" title="3.2.8、readStrongBinder()"></a>3.2.8、<strong>readStrongBinder()</strong></h4><p>[-&gt; Parcel.java]</p><p>readStrongBinder的过程基本是writeStrongBinder逆过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) &#123;</span><br><span class="line">    Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    if (parcel != NULL) &#123;</span><br><span class="line">        return javaObjectForIBinder(env, parcel-&gt;readStrongBinder());</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>javaObjectForIBinder 将native层BpBinder对象转换为Java层BinderProxy对象。</p><h4 id="3-2-9、readStrongBinder-C"><a href="#3-2-9、readStrongBinder-C" class="headerlink" title="3.2.9、readStrongBinder(C++)"></a>3.2.9、<strong>readStrongBinder(C++)</strong></h4><p>[-&gt; Parcel.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; Parcel::readStrongBinder() const</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; val;</span><br><span class="line">    unflatten_binder(ProcessState::self(), *this, &amp;val);</span><br><span class="line">    return val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-10、unflatten-binder"><a href="#3-2-10、unflatten-binder" class="headerlink" title="3.2.10、unflatten_binder()"></a>3.2.10、<strong>unflatten_binder()</strong></h4><p>[-&gt; Parcel.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> unflatten_binder(<span class="keyword">const</span> sp&lt;ProcessState&gt;&amp; proc, <span class="keyword">const</span> Parcel&amp; in, sp&lt;IBinder&gt;* out) &#123;</span><br><span class="line">    <span class="keyword">const</span> flat_binder_object* flat = in.readObject(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (flat) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (flat-&gt;type) &#123;</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">                *out = <span class="keyword">reinterpret_cast</span>&lt;IBinder*&gt;(flat-&gt;cookie);</span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(<span class="literal">NULL</span>, *flat, in);</span><br><span class="line">            <span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">                *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle);</span><br><span class="line">                <span class="comment">//创建BpBinder对象</span></span><br><span class="line">                <span class="keyword">return</span> finish_unflatten_binder(</span><br><span class="line">                    <span class="keyword">static_cast</span>&lt;BpBinder*&gt;(out-&gt;get()), *flat, in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BAD_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：readObject()的作用是从Parcel中读取出它所保存的flat_binder_object类型的对象。该对象的类型是BINDER_TYPE_HANDLE，因此会指向BINDER_TYPE_HANDLE对应的switch分支。 (01) 这里的proc是ProcessState对象，执行proc-&gt;getStrongProxyForHandle()会将句柄(MediaPlayerService的Binder引用描述)保存到ProcessState的链表中，然后再创建并返回该句柄的BpBinder对象(即Binder的代理)。在Android Binder机制(四) defaultServiceManager()的实现中有getStrongProxyForHandle()的详细说明，下面只给出getStrongProxyForHandle()代码。 (02) finish_unflatten_binder()中只有return NO_ERROR。</p><h4 id="3-2-11、getStrongProxyForHandle"><a href="#3-2-11、getStrongProxyForHandle" class="headerlink" title="3.2.11、getStrongProxyForHandle()"></a>3.2.11、<strong>getStrongProxyForHandle()</strong></h4><p>[-&gt; ProcessState.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    //查找handle对应的资源项</span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e != NULL) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            ...</span><br><span class="line">            //当handle值所对应的IBinder不存在或弱引用无效时，则创建BpBinder对象</span><br><span class="line">            b = new BpBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            if (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过该方法，最终创建了指向Binder服务端的BpBinder代理对象。</p><h3 id="（4）、Android-Binder系统-Native层获取hello服务"><a href="#（4）、Android-Binder系统-Native层获取hello服务" class="headerlink" title="（4）、Android Binder系统-Native层获取hello服务"></a>（4）、Android Binder系统-Native层获取hello服务</h3><p>经过前面的分析，知道流程基本类似，这里不再继续分析获取hello服务</p><h2 id="五、Android-Binder系统-Framwork-Java层"><a href="#五、Android-Binder系统-Framwork-Java层" class="headerlink" title="五、Android Binder系统-Framwork-Java层"></a>五、Android Binder系统-Framwork-Java层</h2><h3 id="（1）、Android-Binder系统Java层"><a href="#（1）、Android-Binder系统Java层" class="headerlink" title="（1）、Android Binder系统Java层"></a>（1）、Android Binder系统Java层</h3><p>主要结构 Android应用程序使用Java语言开发，Binder框架自然也少不了在Java层提供接口。</p><p>前文中我们看到，Binder机制在C++层已经有了完整的实现。因此Java层完全不用重复实现，而是通过JNI衔接了C++层以复用其实现。</p><p>下图描述了Binder Framework Java层到C++层的衔接关系。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/56-Android-Binder_JNI.png" alt="Markdown"></p><p>这里对图中Java层和JNI层的几个类做一下说明( 关于C++层的讲解请看这里 )：</p><p>这里的IInterface，IBinder和C++层的两个类是同名的。这个同名并不是巧合：它们不仅仅同名，它们所起的作用，以及其中包含的接口都是几乎一样的，区别仅仅在于一个是C++层，一个是Java层而已。</p><p>除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/57-Android-binder-Java-class.png" alt="Markdown"></p><p>除了IInterface，IBinder之外，这里Binder与BinderProxy类也是与C++的类对应的，下面列出了Java层和C++层类的对应关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/58-Android-binder-Java-c-class.png" alt="Markdown"></p><h3 id="（2）、JNI的衔接"><a href="#（2）、JNI的衔接" class="headerlink" title="（2）、JNI的衔接"></a>（2）、JNI的衔接</h3><p>JNI全称是Java Native Interface，这个是由Java虚拟机提供的机制。这个机制使得native代码可以和Java代码互相通讯。简单来说就是：我们可以在C/C++端调用Java代码，也可以在Java端调用C/C++代码。</p><p>关于JNI的详细说明，可以参见Oracle的官方文档：Java Native Interface ，这里不多说明。</p><p>实际上，在Android中很多的服务或者机制都是在C/C++层实现的，想要将这些实现复用到Java层，就必须通过JNI进行衔接。AOSP源码中，/frameworks/base/core/jni/ 目录下的源码就是专门用来对接Framework层的JNI实现的。</p><p>看一下Binder.java的实现就会发现，这里面有不少的方法都是用native关键字修饰的，并且没有方法实现体，这些方法其实都是在C++中android_util_Binder.cpp实现的： 那么，那么，C++是如何调用Java的呢？最关键的，libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/59-Android-binder-JavaBBinder.png" alt="Markdown"></p><p>这段逻辑就是android_util_Binder.cpp中JavaBBinder::onTransact中处理的了。JavaBBinder是BBinder子类，其类结构如下：libbinder中的BBinder::onTransact是如何能够调用到Java中的Binder::onTransact的呢？ JavaBBinder::onTransact关键代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> status_t <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   JNIEnv* env = javavm_to_jnienv(mVM);</span><br><span class="line"></span><br><span class="line">   IPCThreadState* thread_state = IPCThreadState::self();</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int32_t</span> strict_policy_before = thread_state-&gt;getStrictModePolicy();</span><br><span class="line"></span><br><span class="line">   jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">       code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意这段代码中的这一行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,</span><br><span class="line">  code, <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;data), <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(reply), flags);</span><br></pre></td></tr></table></figure><p>这一行代码其实是在调用mObject上offset为mExecTransact的方法。这里的几个参数说明如下：</p><p>mObject 指向了Java端的Binder对象 gBinderOffsets.mExecTransact 指向了Binder类的execTransact方法 data 调用execTransact方法的参数 code, data, reply, flags都是传递给调用方法execTransact的参数 而JNIEnv.CallBooleanMethod这个方法是由虚拟机实现的。即：虚拟机会提供native方法来调用一个Java Object上的方法（关于Android上的Java虚拟机，今后我们会专门讲解）。</p><p>这样，就在C++层的JavaBBinder::onTransact中调用了Java层Binder::execTransact方法。而在Binder::execTransact方法中，又调用了自身的onTransact方法，由此保证整个过程串联了起来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> boolean <span class="title">execTransact</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">long</span> dataObj, <span class="keyword">long</span> replyObj,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain(dataObj);</span><br><span class="line">   Parcel reply = Parcel.obtain(replyObj);</span><br><span class="line">   boolean res;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       res = onTransact(code, data, reply, flags);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException|RuntimeException e) &#123;</span><br><span class="line">       <span class="keyword">if</span> (LOG_RUNTIME_EXCEPTION) &#123;</span><br><span class="line">           Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e instanceof RemoteException) &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Binder call failed."</span>, e);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               Log.w(TAG, <span class="string">"Caught a RuntimeException from the binder stub implementation."</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">           reply.writeException(e);</span><br><span class="line">       &#125;</span><br><span class="line">       res = <span class="literal">true</span>;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">       RuntimeException re = <span class="keyword">new</span> RuntimeException(<span class="string">"Out of memory"</span>, e);</span><br><span class="line">       reply.setDataPosition(<span class="number">0</span>);</span><br><span class="line">       reply.writeException(re);</span><br><span class="line">       res = <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   checkParcel(<span class="keyword">this</span>, code, reply, <span class="string">"Unreasonably large binder reply buffer"</span>);</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line"></span><br><span class="line">   StrictMode.clearGatheredViolations();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（3）、Java层的ServiceManager"><a href="#（3）、Java层的ServiceManager" class="headerlink" title="（3）、Java层的ServiceManager"></a>（3）、Java层的ServiceManager</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/60-Android-binder-class_ServiceManager_java.jpg" alt="Markdown"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/61-Android-binder-ServiceManager_Java.png" alt="Markdown"></p><p>通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。</p><p>通过这个类图我们看到，Java层的ServiceManager和C++层的接口是一样的。</p><p>然后我们再选取addService方法看一下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"error in addService"</span>, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> IServiceManager <span class="title">getIServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (sServiceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> sServiceManager;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Find the service manager</span></span><br><span class="line">   sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br><span class="line">   <span class="keyword">return</span> sServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，这段代码中，最关键就是下面这个调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceManagerNative.asInterface(BinderInternal.getContextObject());</span><br></pre></td></tr></table></figure><p>然后我们需要再看一下BinderInternal.getContextObject()和ServiceManagerNative.asInterface两个方法。</p><p>BinderInternal.getContextObject()是一个JNI方法，其实现代码在android_util_Binder.cpp中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jobject <span class="title">android_os_BinderInternal_getContextObject</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    <span class="keyword">return</span> javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而ServiceManagerNative.asInterface的实现和其他的Binder服务是一样的套路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IServiceManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   IServiceManager in =</span><br><span class="line">       (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">   <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> in;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ServiceManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先通过queryLocalInterface查看能不能获得本地Binder，如果无法获取，则创建并返回ServiceManagerProxy对象。</p><p>而ServiceManagerProxy自然也是和其他Binder Proxy一样的实现套路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">   Parcel data = Parcel.obtain();</span><br><span class="line">   Parcel reply = Parcel.obtain();</span><br><span class="line">   data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">   data.writeString(name);</span><br><span class="line">   data.writeStrongBinder(service);</span><br><span class="line">   data.writeInt(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">   reply.recycle();</span><br><span class="line">   data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的调用流程前面已经分析过了，在此就不再分析了。 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/62-Android-binder-binder_ipc_process.jpg" alt="Markdown"></p><h2 id="六、Android-Binder系统-AIDL"><a href="#六、Android-Binder系统-AIDL" class="headerlink" title="六、Android Binder系统-AIDL"></a>六、Android Binder系统-AIDL</h2><p>作为Binder机制的最后一个部分内容，我们来讲解一下开发者经常使用的AIDL机制是怎么回事。</p><p>AIDL全称是Android Interface Definition Language，它是Android SDK提供的一种机制。借助这个机制，应用可以提供跨进程的服务供其他应用使用。AIDL的详细说明可以参见官方开发文档：<a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="noopener">https://developer.android.com/guide/components/aidl.html</a> 。</p><p>这里，我们就以官方文档上的例子看来一下AIDL与Binder框架的关系。</p><p>开发一个基于AIDL的Service需要三个步骤：</p><p>定义一个.aidl文件 实现接口 暴露接口给客户端使用 aidl文件使用Java语言的语法来定义，每个.aidl文件只能包含一个interface，并且要包含interface的所有方法声明。</p><p>默认情况下，AIDL支持的数据类型包括：</p><p>基本数据类型（即int，long，char，boolean等） String CharSequence List（List的元素类型必须是AIDL支持的） Map（Map中的元素必须是AIDL支持的） 对于AIDL中的接口，可以包含0个或多个参数，可以返回void或一个值。所有非基本类型的参数必须包含一个描述是数据流向的标签，可能的取值是：in，out或者inout。</p><p>下面是一个aidl文件的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// IRemoteService.aidl</span><br><span class="line">package com.example.android;</span><br><span class="line"></span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line"></span><br><span class="line">/** Example service interface */</span><br><span class="line">interface IRemoteService &#123;</span><br><span class="line">    /** Request the process ID of this service, to do evil things with it. */</span><br><span class="line">    int getPid();</span><br><span class="line"></span><br><span class="line">    /** Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个文件中包含了两个接口 ：</p><p>getPid 一个无参的接口，返回值类型为int basicTypes，包含了几个基本类型作为参数的接口，无返回值 对于包含.aidl文件的工程，Android IDE（以前是Eclipse，现在是Android Studio）在编译项目的时候，会为aidl文件生成对应的Java文件。</p><p>针对上面这个aidl文件生成的java文件中包含的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/63-Android-binder-aidl_java.png" alt="Markdown"></p><p>在这个生成的Java文件中，包括了：</p><p>一个名称为IRemoteService的interface，该interface继承自android.os.IInterface并且包含了我们在aidl文件中声明的接口方法 IRemoteService中包含了一个名称为Stub的静态内部类，这个类是一个抽象类，它继承自android.os.Binder并且实现了IRemoteService接口。这个类中包含了一个onTransact方法 Stub内部又包含了一个名称为Proxy的静态内部类，Proxy类同样实现了IRemoteService接口 仔细看一下Stub类和Proxy两个中包含的方法，是不是觉得很熟悉？是的，这里和前面介绍的服务实现是一样的模式。这里我们列一下各层类的对应关系：</p><table><thead><tr><th style="text-align:center">C++层</th><th style="text-align:center">Java层</th><th style="text-align:center">AIDL</th></tr></thead><tbody><tr><td style="text-align:center">BpXXX</td><td style="text-align:center">XXXProxy</td><td style="text-align:center">IXXX.Stub.Proxy</td></tr><tr><td style="text-align:center">BnXXX</td><td style="text-align:center">XXXNative</td><td style="text-align:center">IXXX.Stub</td></tr></tbody></table><p>为了整个结构的完整性，最后我们还是来看一下生成的Stub和Proxy类中的实现逻辑。</p><p>Stub是提供给开发者实现业务的父类，而Proxy的实现了对外提供的接口。Stub和Proxy两个类都有一个asBinder的方法。</p><p>Stub类中的asBinder实现就是返回自身对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Proxy中asBinder的实现是返回构造函数中获取的mRemote对象，相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line"></span><br><span class="line">Proxy(android.os.IBinder remote) &#123;</span><br><span class="line">    mRemote = remote;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mRemote;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里的mRemote对象其实就是远程服务在当前进程的标识。</p><p>上文我们说了，Stub类是用来提供给开发者实现业务逻辑的父类，开发者者继承自Stub然后完成自己的业务逻辑实现，例如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IRemoteService.Stub mBinder = <span class="keyword">new</span> IRemoteService.Stub() &#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Process.myPid();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicTypes</span><span class="params">(<span class="keyword">int</span> anInt, <span class="keyword">long</span> aLong, <span class="keyword">boolean</span> aBoolean,</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">float</span> aFloat, <span class="keyword">double</span> aDouble, String aString)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Does something</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而这个Proxy类，就是用来给调用者使用的对外接口。我们可以看一下Proxy中的接口到底是如何实现的：</p><p>Proxy中getPid方法实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPid</span><span class="params">()</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">    android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">    <span class="keyword">int</span> _result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">        mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, <span class="number">0</span>);</span><br><span class="line">        _reply.readException();</span><br><span class="line">        _result = _reply.readInt();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        _reply.recycle();</span><br><span class="line">        _data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是通过Parcel对象以及transact调用对应远程服务的接口。而在Stub类中，生成的onTransact方法对应的处理了这里的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> INTERFACE_TRANSACTION: &#123;</span><br><span class="line">        reply.writeString(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_getPid: &#123;</span><br><span class="line">        data.enforceInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">int</span> _result = <span class="keyword">this</span>.getPid();</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(_result);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> TRANSACTION_basicTypes: &#123;</span><br><span class="line">        data.enforceInterface(DESCRIPTOR);</span><br><span class="line">        <span class="keyword">int</span> _arg0;</span><br><span class="line">        _arg0 = data.readInt();</span><br><span class="line">        <span class="keyword">long</span> _arg1;</span><br><span class="line">        _arg1 = data.readLong();</span><br><span class="line">        <span class="keyword">boolean</span> _arg2;</span><br><span class="line">        _arg2 = (<span class="number">0</span> != data.readInt());</span><br><span class="line">        <span class="keyword">float</span> _arg3;</span><br><span class="line">        _arg3 = data.readFloat();</span><br><span class="line">        <span class="keyword">double</span> _arg4;</span><br><span class="line">        _arg4 = data.readDouble();</span><br><span class="line">        java.lang.String _arg5;</span><br><span class="line">        _arg5 = data.readString();</span><br><span class="line">        <span class="keyword">this</span>.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onTransact()所要做的就是：</p><p>根据code区分请求的是哪个接口 通过data来获取请求的参数 调用由子类实现的抽象方法 有了前文的讲解，对于这部分内容应当不难理解了。</p><p>到这里，我们终于讲解完Binder了。</p><p>完整框架： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.binder/64-Android-Binder-IPCall.png" alt="Markdown"></p><h2 id="七、参考文档-特别感谢各位前辈的分析和图示-："><a href="#七、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="七、参考文档(特别感谢各位前辈的分析和图示)："></a>七、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://github.com/xdtianyu/SourceAnalysis/blob/master/Binder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.md" target="_blank" rel="noopener">Binder源码分析</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1609389" target="_blank" rel="noopener">深入分析Android Binder</a><br><a href="http://gityuan.com/tags/#binder" target="_blank" rel="noopener">Binder系列 - Gityuan博客 | 袁辉辉博客</a><br><a href="https://wangkuiwu.github.io/page2/" target="_blank" rel="noopener">Android Binder机制(1) ~ (12) - Wangkuiwu.github.io</a><br><a href="http://www.jcodecraeer.com/tags.php?/Binder/" target="_blank" rel="noopener">Binder机制-关于Binder的文章 - 泡在网上的日子</a><br><a href="http://qiangbo.space/tags/#Android" target="_blank" rel="noopener">理解Android Binder机制 - Qiangbo.space博客</a><br><a href="https://my.oschina.net/youranhongcha/blog?catalog=373547&amp;temp=1505099522160" target="_blank" rel="noopener">红茶一杯话Binder - 悠然红茶</a><br><a href="https://github.com/hehonghui/android-tech-frontier/blob/master/issue-22/Binder%E6%A1%86%E6%9E%B6%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener">Binder框架解析</a><br><a href="https://mr-cao.gitbooks.io/android/content/android-binder.html" target="_blank" rel="noopener">Android Binder详解</a><br><a href="http://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="noopener">图文详解 Android Binder跨进程通信机制 原理</a><br><a href="http://qiangbo.space/2017-01-15/AndroidAnatomy_Binder_Driver/" target="_blank" rel="noopener">理解Android Binder机制(1/3)：驱动篇-qiangbo.space</a><br><a href="http://qiangbo.space/2017-02-12/AndroidAnatomy_Binder_CPP/" target="_blank" rel="noopener">理解Android Binder机制(2/3)：C++层-qiangbo.space</a><br><a href="http://qiangbo.space/2017-03-15/AndroidAnatomy_Binder_Java/" target="_blank" rel="noopener">理解Android Binder机制(3/3)：Java层-qiangbo.space</a><br><a href="http://light3moon.com/1986/12/20/%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/#" target="_blank" rel="noopener">Android Binder 分析–系列-light3moon</a><br><a href="http://palanceli.com/categories/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/page/2/" target="_blank" rel="noopener">Android学习笔记-Binder | Palance’s Blog</a><br><a href="http://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">android系统 -Binder - armwind的专栏 - CSDN博客</a><br><a href="http://blog.csdn.net/Bettarwang/article/category/2276043" target="_blank" rel="noopener">Bettarwang的专栏 -Android Binder机制</a><br><a href="http://blog.csdn.net/yangwen123/article/category/1609389" target="_blank" rel="noopener">深入剖析Android系统 - binder - CSDN博客</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Android 输入子系统 - Input System 分析</title>
      <link href="/2017/12/01/Android-7-1-2-Android-N-Android-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F-Input-System/"/>
      <url>/2017/12/01/Android-7-1-2-Android-N-Android-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F-Input-System/</url>
      <content type="html"><![CDATA[<p>Android 输入子系统概述:<br>● 当时输入设备（如触摸屏，键盘等）可用时，Linux Kernel会在/dev/input/下创建名为event0~eventN的设备节点; 当输入设备不可用时，会将相应的设备节点删除。<br>● 当用户操作输入设备时，Linux Kernel会收到相应的硬件中断，然后会将中断加工成原始输入事件（raw input event），并写入到设备节点中。而后在用户空间就可以通过read()函数读取事件数据了。<br>● Android输入系统会监控/dev/input/下的所有设备节点，当某个结点有数据可读时，将数据读出并进行一系列处理，然后在当前系统中的所有窗口（Window）中寻找合适的接收者，并把事件派发给它。<br>● 具体来说，Linux Kernel将raw input event写入到设备节点后，InputReader会通过EventHub将原始事件读取出来并翻译加工为Android输入事件，而后把它交给InputDispatcher。InputDispatcher根据WMS（WindowManagerService）提供的窗口信息将事件传递给合适的窗口，若窗口为壁纸/SurfaceView等，则到了终点；否则会由该Window的ViewRoot继续分发到合适的View。<br><a id="more"></a></p><p>本章涉及的源代码文件名及位置：</p><p><strong>frameworks/base/services/java/com/android/server/</strong><br>● SystemServer.java</p><p><strong>frameworks/base/services/java/com/android/server/input/</strong><br>● InputManagerService.java</p><p><strong>frameworks/base/services/java/com/android/server/wm/</strong><br>● WindowManagerService.java<br>● WindowState.java<br>● InputMonitor.java</p><p><strong>frameworks/base/core/java/android/view/</strong><br>● View.java<br>● ViewGroup.java<br>● InputEventReceiver.java<br>● ViewRootImpl.java<br>● IWindowSession.aidl<br>● InputChannel.java</p><p><strong>frameworks/base/core/java/android/app/</strong><br>● Activity.java</p><p><strong>frameworks/base/services/jni/</strong><br>● android_view_InputChannel.cpp<br>● android_view_InputEventReceiver.cpp<br>● com_android_server_input_InputManagerService.cpp</p><p><strong>frameworks/native/services/inputflinger/</strong><br>● InputManager.cpp<br>● EventHub.h<br>● EventHub.cpp<br>● InputReader.h<br>● InputReader.cpp<br>● InputListener.h<br>● InputListener.cpp<br>● InputDispatcher.h<br>● InputDispatcher.cpp</p><p><strong>frameworks/native/libs/input/</strong><br>● InputTransport.cpp</p><p><strong>/frameworks/native/include/input/</strong><br>● InputTransport.h</p><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.input" target="_blank" rel="noopener">博客原图链接</a></h2><h2 id="一、Input系统必备Linux知识"><a href="#一、Input系统必备Linux知识" class="headerlink" title="一、Input系统必备Linux知识"></a>一、Input系统必备Linux知识</h2><p>注：必备知识可稍后遇到实际使用的地方再做详细了解。</p><h2 id="（一）、必备的Linux知识-inotify和epoll"><a href="#（一）、必备的Linux知识-inotify和epoll" class="headerlink" title="（一）、必备的Linux知识 inotify和epoll"></a>（一）、必备的Linux知识 inotify和epoll</h2><h3 id="1、INotify介绍与使用"><a href="#1、INotify介绍与使用" class="headerlink" title="1、INotify介绍与使用"></a>1、INotify介绍与使用</h3><p>INotify是一个Linux内核所提供的一种文件系统变化通知机制。它可以为应用程序监控文件系统的变化，如文件的新建、删除、读写等。INotify机制有两个基本对象，分别为inotify对象与watch对象，都使用文件描述符表示。 inotify对象对应了一个队列，应用程序可以向inotify对象添加多个监听。当被监听的事件发生时，可以通过read()函数从inotify对象中将事件信息读取出来。Inotify对象可以通过以下方式创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> inotifyFd = inotify_init();</span><br></pre></td></tr></table></figure><p>而watch对象则用来描述文件系统的变化事件的监听。它是一个二元组，包括监听目标和事件掩码两个元素。监听目标是文件系统的一个路径，可以是文件也可以是文件夹。而事件掩码则表示了需要需要监听的事件类型，掩码中的每一位代表一种事件。可以监听的事件种类很多，其中就包括文件的创建(IN_CREATE)与删除(IN_DELETE)。读者可以参阅相关资料以了解其他可监听的事件种类。以下代码即可将一个用于监听输入设备节点的创建与删除的watch对象添加到inotify对象中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> wd = inotify_add_watch (inotifyFd, “/dev/input”,IN_CREATE | IN_DELETE);</span><br></pre></td></tr></table></figure><p>完成上述watch对象的添加后，当/dev/input/下的设备节点发生创建与删除操作时，都会将相应的事件信息写入到inotifyFd所描述的inotify对象中，此时可以通过read()函数从inotifyFd描述符中将事件信息读取出来。 事件信息使用结构体inotify_event进行描述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> &#123;</span></span><br><span class="line">   __s32           wd;             <span class="comment">/* 事件对应的Watch对象的描述符 */</span></span><br><span class="line">   __u32           mask;           <span class="comment">/* 事件类型，例如文件被删除，此处值为IN_DELETE */</span></span><br><span class="line">   __u32           cookie;</span><br><span class="line">   __u32           len;            <span class="comment">/* name字段的长度 */</span></span><br><span class="line">   <span class="keyword">char</span>            name[<span class="number">0</span>];        <span class="comment">/* 可变长的字段，用于存储产生此事件的文件路径*/</span></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure><p>当没有监听事件发生时，可以通过如下方式将一个或多个未读取的事件信息读取出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> len = read (inotifyFd, events_buf,BUF_LEN);</span><br></pre></td></tr></table></figure><p>其中events_buf是inotify_event的数组指针，能够读取的事件数量由取决于数组的长度。成功读取事件信息后，便可根据inotify_event结构体的字段判断事件类型以及产生事件的文件路径了。</p><p>总结一下INotify机制的使用过程：</p><p>· 通过inotify_init()创建一个inotify对象。</p><p>· 通过inotify_add_watch将一个或多个监听添加到inotify对象中。</p><p>· 通过read()函数从inotify对象中读取监听事件。当没有新事件发生时，inotify对象中无任何可读数据。</p><p>通过INotify机制避免了轮询文件系统的麻烦，但是还有一个问题，INotify机制并不是通过回调的方式通知事件，而需要使用者主动从inotify对象中进行事件读取。那么何时才是读取的最佳时机呢？这就需要借助Linux的另一个优秀的机制Epoll了。</p><p>使用inotify监听目录实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/inotify.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="comment">//参考: frameworks\native\services\inputflinger\EventHub.cpp</span></span><br><span class="line"><span class="comment">//Usage: inotify &lt;dir&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read_process_inotify_fd</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">char</span> event_buf[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">int</span> event_size;</span><br><span class="line"><span class="keyword">int</span> event_pos = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inotify_event</span> *<span class="title">event</span>;</span></span><br><span class="line"><span class="comment">/* read */</span>    </span><br><span class="line">res = read(fd, event_buf, <span class="keyword">sizeof</span>(event_buf));</span><br><span class="line"><span class="keyword">if</span>(res &lt; (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*event)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(errno == EINTR) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"could not get event, %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读到的数据是1个或多个inotify_event,它们的长度不一样,逐个处理</span></span><br><span class="line"><span class="keyword">while</span>(res &gt;= (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*event)) &#123;</span><br><span class="line">    event = (struct inotify_event *)(event_buf + event_pos);</span><br><span class="line">    <span class="comment">//printf("%d: %08x \"%s\"\n", event-&gt;wd, event-&gt;mask, event-&gt;len ? event-&gt;name : "");</span></span><br><span class="line">    <span class="keyword">if</span>(event-&gt;len) &#123;</span><br><span class="line">        <span class="keyword">if</span>(event-&gt;mask &amp; IN_CREATE) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"create file: %s\n"</span>, event-&gt;name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"delete file: %s\n"</span>, event-&gt;name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    event_size = <span class="keyword">sizeof</span>(*event) + event-&gt;len;</span><br><span class="line">    res -= event_size;</span><br><span class="line">    event_pos += event_size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mINotifyFd;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;dir&gt;\n"</span>, argv[<span class="number">0</span>]); <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* inotify_init */</span></span><br><span class="line">mINotifyFd = inotify_init();</span><br><span class="line"><span class="comment">/* add watch */</span></span><br><span class="line">result = inotify_add_watch(mINotifyFd, argv[<span class="number">1</span>], IN_DELETE | IN_CREATE);</span><br><span class="line"><span class="comment">/* read */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    read_process_inotify_fd(mINotifyFd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译与验证：</strong> gcc -o inotify inotify.c //GCC编译 mkdir tmp //创建tmp文件夹 ./inotify tmp &amp; //后台监测tmp文件夹</p><p>echo &gt; tmp/1 //tmp文件夹新建文件1 echo &gt; tmp/2 //tmp文件夹新建文件2 rm tmp/1 tmp/2 //移除tmp文件1/2</p><p>测试结果可以看到，inotify 成功的监测了tmp文件夹。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N1-Android-Input-System-Inotify-Test.jpg" alt="Markdown"></p><h3 id="2、Epoll介绍与使用"><a href="#2、Epoll介绍与使用" class="headerlink" title="2、Epoll介绍与使用"></a>2、Epoll介绍与使用</h3><p>无论是从设备节点中获取原始输入事件还是从inotify对象中读取文件系统事件，都面临一个问题，就是这些事件都是偶发的。也就是说，大部分情况下设备节点、inotify对象这些文件描述符中都是无数据可读的，同时又希望有事件到来时可以尽快地对事件作出反应。为解决这个问题，我们不希望不断地轮询这些描述符，也不希望为每个描述符创建一个单独的线程进行阻塞时的读取，因为这都将会导致资源的极大浪费。</p><p>此时最佳的办法是使用Epoll机制。Epoll可以使用一次等待监听多个描述符的可读/可写状态。等待返回时携带了可读的描述符或自定义的数据，使用者可以据此读取所需的数据后可以再次进入等待。因此不需要为每个描述符创建独立的线程进行阻塞读取，避免了资源浪费的同时又可以获得较快的响应速度。</p><p>Epoll机制的接口只有三个函数，十分简单。</p><p>· epoll_create(int max_fds)：创建一个epoll对象的描述符，之后对epoll的操作均使用这个描述符完成。max_fds参数表示了此epoll对象可以监听的描述符的最大数量。</p><p>· epoll_ctl (int epfd, int op,int fd, struct epoll_event *event)：用于管理注册事件的函数。这个函数可以增加/删除/修改事件的注册。</p><p>· int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout)：用于等待事件的到来。当此函数返回时，events数组参数中将会包含产生事件的文件描述符。</p><p>接下来以监控若干描述符可读事件为例介绍一下epoll的用法。</p><p>（1） 创建epoll对象</p><p>首先通过epoll_create()函数创建一个epoll对象：</p><p>Int epfd = epoll_create(MAX_FDS)</p><p>（2） 填充epoll_event结构体</p><p>接着为每一个需监控的描述符填充epoll_event结构体，以描述监控事件，并通过epoll_ctl()函数将此描述符与epoll_event结构体注册进epoll对象。epoll_event结构体的定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line"></span><br><span class="line">__uint32_tevents; <span class="comment">/* 事件掩码，指明了需要监听的事件种类*/</span></span><br><span class="line"> <span class="keyword">epoll_data_t</span> data; <span class="comment">/* 使用者自定义的数据，当此事件发生时该数据将原封不动地返回给使用者 */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>epoll_data_t联合体的定义如下，当然，同一时间使用者只能使用一个字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"><span class="keyword">void</span>*ptr;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">__uint32_t</span> u32;</span><br><span class="line"><span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>epoll_event结构中的events字段是一个事件掩码，用以指明需要监听的事件种类，同INotify一样，掩码的每一位代表了一种事件。常用的事件有EPOLLIN（可读），EPOLLOUT（可写），EPOLLERR（描述符发生错误），EPOLLHUP（描述符被挂起）等。更多支持的事件读者可参考相关资料。</p><p>data字段是一个联合体，它让使用者可以将一些自定义数据加入到事件通知中，当此事件发生时，用户设置的data字段将会返回给使用者。在实际使用中常设置epoll_event.data.fd为需要监听的文件描述符，事件发生时便可以根据epoll_event.data.fd得知引发事件的描述符。当然也可以设置epoll_event.data.fd为其他便于识别的数据。</p><p>填充epoll_event的方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">structepoll_event eventItem;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line"></span><br><span class="line">eventItem.events = EPOLLIN | EPOLLERR | EPOLLHUP; <span class="comment">// 监听描述符可读以及出错的事件</span></span><br><span class="line"></span><br><span class="line">eventItem.data.fd= listeningFd; <span class="comment">// 填写自定义数据为需要监听的描述符</span></span><br></pre></td></tr></table></figure><p>接下来就可以使用epoll_ctl()将事件注册进epoll对象了。epoll_ctl()的参数有四个：</p><p>· epfd是由epoll_create()函数所创建的epoll对象的描述符。</p><p>· op表示了何种操作，包括EPOLL_CTL_ADD/DEL/MOD三种，分别表示增加/删除/修改注册事件。</p><p>· fd表示了需要监听的描述符。</p><p>· event参数是描述了监听事件的详细信息的epoll_event结构体。</p><p>注册方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将事件监听添加到epoll对象中去</span></span><br><span class="line"></span><br><span class="line">result =epoll_ctl(epfd, EPOLL_CTL_ADD, listeningFd, &amp;eventItem);</span><br></pre></td></tr></table></figure><p>重复这个步骤可以将多个文件描述符的多种事件监听注册到epoll对象中。完成了监听的注册之后，便可以通过epoll_wait()函数等待事件的到来了。</p><p>（3） 使用epoll_wait()函数等待事件</p><p>epoll_wait()函数将会使调用者陷入等待状态，直到其注册的事件之一发生之后才会返回，并且携带了刚刚发生的事件的详细信息。其签名如下：</p><p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</p><p>· epfd是由epoll_create()函数所创建的epoll对象描述符。</p><p>· events是一个epoll_event的数组，此函数返回时，事件的信息将被填充至此。</p><p>· maxevents表示此次调用最多可以获取多少个事件，当然，events参数必须能够足够容纳这么多事件。</p><p>· timeout表示等待超时的事件。</p><p>epoll_wait()函数返回值表示获取了多少个事件。</p><p>（4） 处理事件</p><p>epoll_wait返回后，便可以根据events数组中所保存的所有epoll_event结构体的events字段与data字段识别事件的类型与来源。</p><p>Epoll的使用步骤总结如下：</p><p>· 通过epoll_create()创建一个epoll对象。</p><p>· 为需要监听的描述符填充epoll_events结构体，并使用epoll_ctl()注册到epoll对象中。</p><p>· 使用epoll_wait()等待事件的发生。</p><p>· 根据epoll_wait()返回的epoll_events结构体数组判断事件的类型与来源并进行处理。</p><p>· 继续使用epoll_wait()等待新事件的发生。</p><p>使用inotify监听目录实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line"><span class="keyword">void</span>        *ptr;</span><br><span class="line"> <span class="keyword">int</span>          fd;</span><br><span class="line">  <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">   <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">   &#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_MAX_LEN 500</span></span><br><span class="line"><span class="comment">/* usage: epoll &lt;file1&gt; [file2] [file3] ... */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_to_epoll</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> epollFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> result;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">eventItem.events = EPOLLIN;</span><br><span class="line">eventItem.data.fd = fd;</span><br><span class="line">result = epoll_ctl(epollFd, EPOLL_CTL_ADD, fd, &amp;eventItem);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rm_from_epoll</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> epollFd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">epoll_ctl(epollFd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mEpollFd;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> buf[DATA_MAX_LEN];</span><br><span class="line"><span class="comment">// Maximum number of signalled FDs to handle at a time.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> EPOLL_MAX_EVENTS = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// The array of pending epoll events and the index of the next event to be handled.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">mPendingEventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;file1&gt; [file2] [file3] ...\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* epoll_create */</span></span><br><span class="line">mEpollFd = epoll_create(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// for each file:* open it</span></span><br><span class="line"><span class="comment">// add it to epoll: epoll_ctl(...EPOLL_CTL_ADD...)</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; argc; i++)     </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//int tmpFd = open(argv[i], O_RDONLY|O_NONBLOCK);</span></span><br><span class="line">    <span class="keyword">int</span> tmpFd = open(argv[i], O_RDWR);</span><br><span class="line">    add_to_epoll(tmpFd, mEpollFd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* epoll_wait */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pollResult; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Reason: 0x%x\n"</span>, mPendingEventItems[i].events);</span><br><span class="line">        <span class="keyword">int</span> len = read(mPendingEventItems[i].data.fd, buf, DATA_MAX_LEN);</span><br><span class="line">        buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get data: %s\n"</span>, buf);</span><br><span class="line">        <span class="comment">//sleep(3);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>epoll , fifo : <a href="http://stackoverflow.com/questions/15055065/o-rdwr-on-named-pipes-with-poll" target="_blank" rel="noopener">o-rdwr-on-named-pipes-with-poll</a></p><p>使用fifo是, 我们的epoll程序是reader echo aa &gt; tmp/1 是writer a. 如果reader以 O_RDONLY|O_NONBLOCK打开FIFO文件, 当writer写入数据时, epoll_wait会立刻返回; 当writer关闭FIFO之后, reader再次调用epoll_wait, 它也会立刻返回(原因是EPPLLHUP, 描述符被挂断) b. 如果reader以 O_RDWR打开FIFO文件 当writer写入数据时, epoll_wait会立刻返回; 当writer关闭FIFO之后, reader再次调用epoll_wait, 它并不会立刻返回, 而是继续等待有数据</p><p><strong>编译与验证：</strong> gcc -o epoll epoll.c //GCC编译 mkdir tmp //创建tmp文件夹 mkfifo tmp/1 tmp/2 tmp/3 //创建文件1、2、3 ./epoll tmp/1 tmp/2 tmp/3 &amp; //epoll后台监测文件1、2、3 echo aaa &gt; tmp/1 //写人aaa到1 echo bbb &gt; tmp/2 //写入bbb到2</p><p>测试结果可以看到，epoll成功的监测了文件内容的改变。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N2-Android-Input-System-epoll-test.jpg" alt="Markdown"></p><h3 id="3、INotify与Epoll的小结"><a href="#3、INotify与Epoll的小结" class="headerlink" title="3、INotify与Epoll的小结"></a>3、INotify与Epoll的小结</h3><p>INotify与Epoll这两套由Linux提供的事件监听机制以最小的开销解决了文件系统变化以及文件描述符可读可写状态变化的监听问题。它们是Reader子系统运行的基石，了解了这两个机制的使用方法之后便为对Reader子系统的分析学习铺平了道路。 参考：<a href="https://github.com/weidongshan/APP_0006_inotify_epoll" target="_blank" rel="noopener">https://github.com/weidongshan/APP_0006_inotify_epoll</a> inotify_epoll.c, 用它来监测tmp/目录: 有文件被创建/删除, 有文件可读出数据 a. 当在tmp/下创建文件时, 会立刻监测到，并且使用epoll监测该文件 b. 当文件有数据时，读出数据 c. 当tmp/下文件被删除时，会立刻监测到，并且把它从epoll中移除不再监测</p><p>inotify_epoll.c <strong>编译与验证：</strong></p><p>gcc -o inotify_epoll inotify_epoll.c mkdir tmp ./inotify_epoll tmp/ &amp; mkfifo tmp/1 tmp/2 tmp/3 echo aaa &gt; tmp/1 echo bbb &gt; tmp/2 rm tmp/3</p><p>由实例可知，使用inotify 和 epoll 结合就可以监测文件增加和移除 ，还能监测文件内容的改变。</p><p>用途简介[稍后进行input system详细分析]： /dev/input 下有多个event文件,对应多个输入设备，如:/dev/input/event0, /dev/input/mouse0, /dev/input/misc 使用inotify 和 epoll 就可以监听输入设备的变化、如Android新连接一个鼠标可检测到改变。同时可监听是否有输入事件。</p><p><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Lnux IO模式及 select、poll、epoll详解</a></p><h2 id="（二）、必备Linux知识-双向通信-scoketpair"><a href="#（二）、必备Linux知识-双向通信-scoketpair" class="headerlink" title="（二）、必备Linux知识_双向通信(scoketpair)"></a>（二）、必备Linux知识_双向通信(scoketpair)</h2><h3 id="1、进程和APP通信"><a href="#1、进程和APP通信" class="headerlink" title="1、进程和APP通信"></a>1、进程和APP通信</h3><p>· 创建进程 · 读取、分发 · 进程发送输入事件给APP · 进程读取APP回应的事件 · 输入系统涉及双向的进程间通信</p><h3 id="2、回顾Binder系统"><a href="#2、回顾Binder系统" class="headerlink" title="2、回顾Binder系统"></a>2、回顾Binder系统</h3><p>· Server– 单向发出请求 · Client – 单向回复请求 · 每次请求只可以单方发出</p><h3 id="3、引入Socketpair"><a href="#3、引入Socketpair" class="headerlink" title="3、引入Socketpair"></a>3、引入Socketpair</h3><p>原因：如果创建两组进程（Client，Server）进行双向通信，实现十分复杂 引入Socketpair： Socketpair();两次，获得两个fd，在内核获得缓冲区，一个作为sendbuf区一个作为receivebuf区 APP通过fd1将数据写入fd1的sendbuf区中，通过内核当中的socket机制就会写到fd2中receivebuf区，同理fd2也是如此 socketpair缺点：只适用于线程间、父子进程通信 解决方法：通过Binder机制通信可以访问任意进程，就解决了sockpair缺点</p><h3 id="4、socketpair具体使用"><a href="#4、socketpair具体使用" class="headerlink" title="4、socketpair具体使用"></a>4、socketpair具体使用</h3><p>创建一个线程–pthread_create(); 创建socketpair–socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets); 线程处理函数–往socket[1]写入数据，读取socket[0]读取数据 主函数–从socket[1]读取数据，往socket[0]写入数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOCKET_BUFFER_SIZE      (32768U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 512</span></span><br><span class="line"><span class="comment">/* 参考:frameworks/native/libs/input/InputTransport.cpp</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="comment">/* 线程执行函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">function_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> thread1_fd = (<span class="keyword">int</span>)arg;<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> buf[MAX];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/* 向 main线程发出: Hello, main thread   */</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,<span class="string">"Hello , main thread , cnt = %d"</span>,cnt++);</span><br><span class="line">    write(thread1_fd,buf,len);</span><br><span class="line">    <span class="comment">/* 读取数据(main线程发回的数据) */</span></span><br><span class="line">    len = read(thread1_fd,buf,MAX);</span><br><span class="line">    buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread1 read : %s\n"</span>,buf);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(thread1_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> threadID;</span><br><span class="line"><span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">socketpair(AF_UNIX,SOCK_SEQPACKET,<span class="number">0</span>,sockets);  <span class="comment">//创建socketpair</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">pthread_create(threadID,<span class="literal">NULL</span>,function_thread,(<span class="keyword">void</span> *)sockets[<span class="number">1</span>]);  <span class="comment">//创建线程</span></span><br><span class="line"><span class="keyword">int</span> mainThread_fd = sockets[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">char</span> buf[MAX];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">/* 读数据: 线程1发出的数据 */</span></span><br><span class="line">    len = read(mainThread_fd,buf,MAX);</span><br><span class="line">    buf[len] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main thread read : %s\n"</span>,buf);</span><br><span class="line">    <span class="comment">/* main thread向thread1 发出: Hello, thread1 */</span></span><br><span class="line">    len = <span class="built_in">sprintf</span>(buf,<span class="string">"Hello , thread1 , cnt = %d"</span>,cnt++);</span><br><span class="line">    write(mainThread_fd,buf,len);       </span><br><span class="line">&#125;</span><br><span class="line">close(mainThread_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法： gcc socketpair.c -o socketpair -pthread 注：出现少量警告，可以忽略 ./socketpair 可以看到main线程 和 thread1双向通信。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N3-Android-Input-System-socketpair.jpg" alt="Markdown"></p><p>main 和 thread1属于两个线程：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N4-Android-Input-System-socketpair-thread.jpg" alt="Markdown"></p><p>父子进程通信： 利用socketpair创建一对无名管道，然后通过sendmsg由服务器进程发送文件的fd给客户端进程，客户端进程通过recvmsg接收服务器进程发来的fd <a href="http://blog.csdn.net/yankai0219/article/details/8453377" target="_blank" rel="noopener">socketpair实现父子进程通信</a> <strong>图示：</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N5-Android-Input-System-socketpair-father-son.jpg" alt="Markdown"></p><h2 id="（三）、必备Linux知识-实现任意进程间双向通信-scoketpair-binder"><a href="#（三）、必备Linux知识-实现任意进程间双向通信-scoketpair-binder" class="headerlink" title="（三）、必备Linux知识_实现任意进程间双向通信(scoketpair+binder)"></a>（三）、必备Linux知识_实现任意进程间双向通信(scoketpair+binder)</h2><p>代码实例，由于代码较多，请往GitHub上查看。 <a href="https://github.com/weidongshan/APP_0004_Binder_CPP_App" target="_blank" rel="noopener">实现任意进程间双向通信(scoketpair+binder)</a></p><p>由第二节最后可知socketpair可实现父子进程通信，图中父进程和子进程可双向通信，假如此时通过binder通信将文件句柄Fd[1]传给另外一个独立进程，我们知道Linux一切皆文件，那个独立进程就可以对Fd[1]读写了，也就是说父进程 就可以和 那个独立进程双向通信了，具体实现请研究上面的代码。</p><p>测试：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N6-Android-Input-System-socketpair-binder.jpg" alt="Markdown"></p><p>可以看到两个没有任何关系的进程使用socketpair实现了双向通信。</p><p>用途简介[稍后进行input system详细分析]： InputManagerService获取事件后需要发送给App，假如App进程关掉了，需要告知IMS，就不需要接受事件了。可以看到需要进程间相互通信，这就是scoketpair+binder实际作用。</p><hr><h2 id="二、输入系统的总体架构"><a href="#二、输入系统的总体架构" class="headerlink" title="二、输入系统的总体架构"></a>二、输入系统的总体架构</h2><h3 id="（一）、输入子系统分层解析"><a href="#（一）、输入子系统分层解析" class="headerlink" title="（一）、输入子系统分层解析"></a>（一）、输入子系统分层解析</h3><p>输入子系统的系统架构如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N7-Android-Input-System--all-arc.png" alt="Markdown"></p><p>Android输入系统系统综述： Linux内核会在/dev/input/下创建对应的名为event0~n或其他名称的设备节点。而当输入设备不可用时，则会将对应的节点删除。在用户空间可以通过ioctl的方式从这些设备节点中获取其对应的输入设备的类型、厂商、描述等信息。</p><p>当用户操作输入设备时，Linux内核接收到相应的硬件中断，然后将中断加工成原始的输入事件数据并写入其对应的设备节点中，在用户空间可以通过read()函数将事件数据读出。</p><p>Android输入系统的工作原理概括来说，就是监控/dev/input/下的所有设备节点，当某个节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中寻找合适的事件接收者，并派发给它。</p><h4 id="1、输入子系统分层解析"><a href="#1、输入子系统分层解析" class="headerlink" title="1、输入子系统分层解析"></a>1、输入子系统分层解析</h4><p>● Hardware层 硬件层主要就是按键、触摸屏、Sensor等各种输入设备。</p><p>● Kernel层</p><p>Kernel 层对Input相关处理只做简单的介绍。 Kernel 层主要分为三层，如下：</p><p>Input 设备驱动层: 采集输入设备的数据信息，通过 Input Core 的 API 上报数据。</p><p>Input Core（核心层）：为事件处理层和设备驱动层提供接口API。 Event Handler（事件处理层）：通过核心层的API获取输入事件上报的数据，定义API与应用层交互。</p><p>Event Handler： Event Handler 层以通用的 evdev.c 为例来解析，上层和 Kernel 层的交互在此文件完成。</p><p>● Framework 层 Android系统中Framework 层负责管理输入事件的主要是InputManagerService（IMS）。它主要的任务就是从设备中读事件数据，然后将输入事件发送到焦点窗口中去，另外还需要让系统有机会来处理一些系统按键。显然，要完成这个工作，IMS需要与其它模块打交道，其中最主要的就是WMS和ViewRootImpl。主要的几个模块示意如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N8-Android-Input-System-framwork-arc.png" alt="Markdown"></p><p>● App层</p><hr><p>WindowManagerService(WMS)是窗口管理服务，核心维护了一个有序的窗口堆栈。PhoneWindowManager(PWM)里有关于手机策略的实现，和输入相关的主要是对系统按键的处理。InputManagerService是输入管理服务，主要干活的是Native层的InputManager。InputManager中的InputReader负责使用EventHub从Input driver中拿事件，然后让InputMapper解析。接着传给InputDispatcher，InputDispatcher负责一方面将事件通过InputManager，InputMonitor一路传给PhoneWindowManager来做系统输入事件的处理，另一方面将这些事件传给焦点及监视窗口。NativeInputManager实现InputReaderPolicyInterface和InputDispatcherPolicyInterface接口，在Native层的InputManager和Java层的IMS间起到一个胶水层的作用。InputMonitor实现了WindowManagerCallbacks接口，起到了IMS到WMS的连接作用。App这边，ViewRootImpl相当于App端一个顶层View的Controller。这个顶层View在WMS中对应一个窗口，用WindowState描述。WindowState中有InputWindowHandle代表一个接收输入事件的窗口句柄。InputDispatcher中的mFocusedWindowHandle指示了焦点窗口的句柄。InputDispatcher管理了一坨连接（一个连接对应一个注册到WMS的窗口），通过这些个连接InputDispatcher可以直接将输入事件发往App端的焦点窗口。输入事件从Driver开始的处理过程大致如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N9-Android-Input-System-app-arc.png" alt="Markdown"></p><p>事件发往App端后，就进入事件分发阶段，这里简单提下，不做详细分析。</p><p>附： Kernel 层生成三个路径及相关设备文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># /sys/<span class="class"><span class="keyword">class</span>/<span class="title">input</span>/</span></span><br><span class="line"><span class="class"><span class="title">event0</span>  <span class="title">event11</span> <span class="title">event4</span> <span class="title">event7</span> <span class="title">input0</span>  <span class="title">input11</span> <span class="title">input4</span> <span class="title">input7</span></span></span><br><span class="line"><span class="class"><span class="title">event1</span>  <span class="title">event2</span>  <span class="title">event5</span> <span class="title">event8</span> <span class="title">input1</span>  <span class="title">input2</span>  <span class="title">input5</span> <span class="title">input8</span></span></span><br><span class="line"><span class="class"><span class="title">event10</span> <span class="title">event3</span>  <span class="title">event6</span> <span class="title">event9</span> <span class="title">input10</span> <span class="title">input3</span>  <span class="title">input6</span> <span class="title">input9</span></span></span><br><span class="line"><span class="class"># /<span class="title">dev</span>/<span class="title">input</span></span></span><br><span class="line"><span class="class"><span class="title">event0</span> <span class="title">event10</span> <span class="title">event2</span> <span class="title">event4</span> <span class="title">event6</span> <span class="title">event8</span></span></span><br><span class="line"><span class="class"><span class="title">event1</span> <span class="title">event11</span> <span class="title">event3</span> <span class="title">event5</span> <span class="title">event7</span> <span class="title">event9</span></span></span><br><span class="line"><span class="class"># /<span class="title">proc</span>/<span class="title">bus</span>/<span class="title">input</span>  </span></span><br><span class="line"><span class="class"><span class="title">devices</span> <span class="title">handlers</span></span></span><br><span class="line"><span class="class"># <span class="title">cat</span> <span class="title">devices</span>  查看总线上的已经注册上的输入设备</span></span><br><span class="line"><span class="class"><span class="title">I</span>:</span> Bus=<span class="number">0019</span> Vendor=<span class="number">0000</span> Product=<span class="number">0000</span> Version=<span class="number">0000</span></span><br><span class="line">N: Name=<span class="string">"ACCDET"</span></span><br><span class="line">P: Phys=</span><br><span class="line">S: Sysfs=/devices/<span class="keyword">virtual</span>/input/input0</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=gpufreq_ib event0</span><br><span class="line">B: PROP=<span class="number">0</span></span><br><span class="line">B: EV=<span class="number">3</span></span><br><span class="line">B: KEY=<span class="number">40</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1000000000</span> c000001800000 <span class="number">0</span></span><br><span class="line">...</span><br><span class="line">I: Bus=<span class="number">0019</span> Vendor=<span class="number">0000</span> Product=<span class="number">0000</span> Version=<span class="number">0001</span></span><br><span class="line">N: Name=<span class="string">"fingerprint_key"</span></span><br><span class="line">P: Phys=</span><br><span class="line">S: Sysfs=/devices/<span class="keyword">virtual</span>/input/input2</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=gpufreq_ib event2</span><br><span class="line">B: PROP=<span class="number">0</span></span><br><span class="line">B: EV=<span class="number">3</span></span><br><span class="line">B: KEY=<span class="number">2000100000000000</span> <span class="number">180001f</span> <span class="number">8000000000000000</span></span><br><span class="line">...</span><br><span class="line">cat handlers <span class="comment">// 查看注册的handler</span></span><br><span class="line">N: Number=<span class="number">0</span> Name=gpufreq_ib</span><br><span class="line">N: Number=<span class="number">1</span> Name=evdev Minor=<span class="number">64</span></span><br></pre></td></tr></table></figure><h4 id="2、getevent与sendevent工具"><a href="#2、getevent与sendevent工具" class="headerlink" title="2、getevent与sendevent工具"></a>2、getevent与sendevent工具</h4><p>Android系统提供了getevent与sendevent两个工具供开发者从设备节点中直接读取输入事件或写入输入事件。</p><p>getevent监听输入设备节点的内容，当输入事件被写入到节点中时，getevent会将其读出并打印在屏幕上。由于getevent不会对事件数据做任何加工，因此其输出的内容是由内核提供的最原始的事件。其用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell getevent [-选项] [device_path]</span><br></pre></td></tr></table></figure><p>其中device_path是可选参数，用以指明需要监听的设备节点路径。如果省略此参数，则监听所有设备节点的事件。</p><p>打开模拟器，执行adb shell getevent –t（-t参数表示打印事件的时间戳），并按一下电源键（不要松手），可以得到以下一条输出，输出的部分数值会因机型的不同而有所差异，但格式一致：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1262.443489</span>] /dev/input/event0: <span class="number">0001</span> <span class="number">0074</span> <span class="number">00000001</span></span><br></pre></td></tr></table></figure><p>松开电源键时，又会产生以下一条输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1262.557130</span>] /dev/input/event0: <span class="number">0001</span> <span class="number">0074</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure><p>这两条输出便是按下和抬起电源键时由内核生成的原始事件。注意其输出是十六进制的。每条数据有五项信息：产生事件时的时间戳（[ 1262.443489]），产生事件的设备节点（/dev/input/event0），事件类型（0001），事件代码（0074）以及事件的值（00000001）。其中时间戳、类型、代码、值便是原始事件的四项基本元素。除时间戳外，其他三项元素的实际意义依照设备类型及厂商的不同而有所区别。在本例中，类型0x01表示此事件为一条按键事件，代码0x74表示电源键的扫描码，值0x01表示按下，0x00则表示抬起。这两条原始数据被输入系统包装成两个KeyEvent对象，作为两个按键事件派发给Framework中感兴趣的模块或应用程序。</p><p>注意一条原始事件所包含的信息量是比较有限的。而在Android API中所使用的某些输入事件，如触摸屏点击/滑动，包含了很多的信息，如XY坐标，触摸点索引等，其实是输入系统整合了多个原始事件后的结果。这个过程将在5.2.4节中详细探讨。</p><p>为了对原始事件有一个感性的认识，读者可以在运行getevent的过程中尝试一下其他的输入操作，观察一下每种输入所对应的设备节点及四项元素的取值。</p><p>输入设备的节点不仅在用户空间可读，而且是可写的，因此可以将将原始事件写入到节点中，从而实现模拟用户输入的功能。sendevent工具的作用正是如此。其用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendevent &lt;节点路径&gt; &lt;类型&gt;&lt;代码&gt; &lt;值&gt;</span><br></pre></td></tr></table></figure><p>可以看出，sendevent的输入参数与getevent的输出是对应的，只不过sendevent的参数为十进制。电源键的代码0x74的十进制为116，因此可以通过快速执行如下两条命令实现点击电源键的效果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell sendevent /dev/input/event0 <span class="number">1</span> <span class="number">116</span> <span class="number">1</span> #按下电源键</span><br><span class="line"></span><br><span class="line">adb shell sendevent /dev/input/event0 <span class="number">1</span> <span class="number">116</span> <span class="number">0</span> #抬起电源键</span><br></pre></td></tr></table></figure><p>执行完这两条命令后，可以看到设备进入了休眠或被唤醒，与按下实际的电源键的效果一模一样。另外，执行这两条命令的时间间隔便是用户按住电源键所保持的时间，所以如果执行第一条命令后迟迟不执行第二条，则会产生长按电源键的效果—-关机对话框出现了。很有趣不是么？输入设备节点在用户空间可读可写的特性为自动化测试提供了一条高效的途径。[1]</p><p>现在，读者对输入设备节点以及原始事件有了直观的认识，接下来看一下Android输入系统的基本原理。</p><h4 id="3、Input-driver模拟驱动"><a href="#3、Input-driver模拟驱动" class="headerlink" title="3、Input driver模拟驱动"></a>3、Input driver模拟驱动</h4><p>代码实例： <a href="https://github.com/weidongshan/DRV_0004_InputEmulator/" target="_blank" rel="noopener">Input driver模拟驱动-作者韦东山</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 参考drivers\input\keyboard\gpio_keys.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">input_emulator_dev</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_emulator_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1\. 分配一个input_dev结构体 */</span></span><br><span class="line">input_emulator_dev = input_allocate_device();;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2\. 设置 */</span></span><br><span class="line"><span class="comment">/* 2.1 能产生哪类事件 */</span></span><br><span class="line">set_bit(EV_KEY, input_emulator_dev-&gt;evbit);</span><br><span class="line">set_bit(EV_REP, input_emulator_dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.2 能产生所有的按键 */</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BITS_TO_LONGS(KEY_CNT); i++)</span><br><span class="line">    input_emulator_dev-&gt;keybit[i] = ~<span class="number">0U</span>L;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2.3 为android构造一些设备信息 */</span></span><br><span class="line">input_emulator_dev-&gt;name = <span class="string">"InputEmulatorFrom100ask.net"</span>;</span><br><span class="line">input_emulator_dev-&gt;id.bustype = <span class="number">1</span>;</span><br><span class="line">input_emulator_dev-&gt;id.vendor  = <span class="number">0x1234</span>;</span><br><span class="line">input_emulator_dev-&gt;id.product = <span class="number">0x5678</span>;</span><br><span class="line">input_emulator_dev-&gt;id.version = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 3\. 注册 */</span></span><br><span class="line">input_register_device(input_emulator_dev);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_emulator_exit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">input_unregister_device(input_emulator_dev);</span><br><span class="line">input_free_device(input_emulator_dev);</span><br><span class="line">&#125;</span><br><span class="line">module_init(input_emulator_init);</span><br><span class="line">module_exit(input_emulator_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">"GPL"</span>);</span><br></pre></td></tr></table></figure><p>测试: insmod InputEmulator.ko</p><p>sendevent /dev/input/event5 1 2 1 // 1 2 1 : EV_KEY, KEY_1, down sendevent /dev/input/event5 1 2 0 // 1 2 0 : EV_KEY, KEY_1, up sendevent /dev/input/event5 0 0 0 // sync</p><p>sendevent /dev/input/event5 1 3 1 // 1 3 1 : EV_KEY, KEY_2, down sendevent /dev/input/event5 1 3 0 // 1 3 0 : EV_KEY, KEY_1, up sendevent /dev/input/event5 0 0 0 // sync 通过sendevent 最后会成功输入字符1、2。</p><hr><h1 id="三、Android-Input系统"><a href="#三、Android-Input系统" class="headerlink" title="三、Android Input系统"></a>三、Android Input系统</h1><h2 id="（一）、Android-Input-系统关键类介绍"><a href="#（一）、Android-Input-系统关键类介绍" class="headerlink" title="（一）、Android Input 系统关键类介绍"></a>（一）、Android Input 系统关键类介绍</h2><p>上一节讲述了输入事件的源头是位于/dev/input/下的设备节点，而输入系统的终点是由WMS管理的某个窗口。最初的输入事件为内核生成的原始事件，而最终交付给窗口的则是KeyEvent或MotionEvent对象。因此Android输入系统的主要工作是读取设备节点中的原始事件，将其加工封装，然后派发给一个特定的窗口以及窗口中的控件。这个过程由InputManagerService（以下简称IMS）系统服务为核心的多个参与者共同完成。</p><p>输入系统的总体流程和参与者如图3-1所示。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N10-Android-Input-System-framwork-arc.png" alt="Markdown"></p><p>上图描述了输入事件的处理流程以及输入系统中最基本的参与者。它们是：</p><p>· <strong>Linux内核</strong>，接受输入设备的中断，并将原始事件的数据写入到设备节点中。</p><p>· <strong>设备节点</strong>，作为内核与IMS的桥梁，它将原始事件的数据暴露给用户空间，以便IMS可以从中读取事件。</p><p>· <strong>InputManagerService</strong>，一个Android系统服务，它分为Java层和Native层两部分。Java层负责与WMS的通信。而Native层则是InputReader和InputDispatcher两个输入系统关键组件的运行容器。</p><p>· <strong>EventHub</strong>，直接访问所有的设备节点。并且正如其名字所描述的，它通过一个名为getEvents()的函数将所有输入系统相关的待处理的底层事件返回给使用者。这些事件包括原始输入事件、设备节点的增删等。</p><p>· <strong>InputReader</strong>，I是IMS中的关键组件之一。它运行于一个独立的线程中，负责管理输入设备的列表与配置，以及进行输入事件的加工处理。它通过其线程循环不断地通过getEvents()函数从EventHub中将事件取出并进行处理。对于设备节点的增删事件，它会更新输入设备列表于配置。对于原始输入事件，InputReader对其进行翻译、组装、封装为包含了更多信息、更具可读性的输入事件，然后交给InputDispatcher进行派发。</p><p>· <strong>InputReaderPolicy</strong>，它为InputReader的事件加工处理提供一些策略配置，例如键盘布局信息等。</p><p>· <strong>InputDispatcher</strong>，是IMS中的另一个关键组件。它也运行于一个独立的线程中。InputDispatcher中保管了来自WMS的所有窗口的信息，其收到来自InputReader的输入事件后，会在其保管的窗口中寻找合适的窗口，并将事件派发给此窗口。</p><p>· <strong>InputDispatcherPolicy</strong>，它为InputDispatcher的派发过程提供策略控制。例如截取某些特定的输入事件用作特殊用途，或者阻止将某些事件派发给目标窗口。一个典型的例子就是HOME键被InputDispatcherPolicy截取到PhoneWindowManager中进行处理，并阻止窗口收到HOME键按下的事件。</p><p>· <strong>WMS</strong>，虽说不是输入系统中的一员，但是它却对InputDispatcher的正常工作起到了至关重要的作用。当新建窗口时，WMS为新窗口和IMS创建了事件传递所用的通道。另外，WMS还将所有窗口的信息，包括窗口的可点击区域，焦点窗口等信息，实时地更新到IMS的InputDispatcher中，使得InputDispatcher可以正确地将事件派发到指定的窗口。</p><p>· <strong>ViewRootImpl</strong>，对于某些窗口，如壁纸窗口、SurfaceView的窗口来说，窗口即是输入事件派发的终点。而对于其他的如Activity、对话框等使用了Android控件系统的窗口来说，输入事件的终点是控件（View）。ViewRootImpl将窗口所接收到的输入事件沿着控件树将事件派发给感兴趣的控件。</p><p>简单来说，内核将原始事件写入到设备节点中，InputReader不断地通过EventHub将原始事件取出来并翻译加工成Android输入事件，然后交给InputDispatcher。InputDispatcher根据WMS提供的窗口信息将事件交给合适的窗口。窗口的ViewRootImpl对象再沿着控件树将事件派发给感兴趣的控件。控件对其收到的事件作出响应，更新自己的画面、执行特定的动作。所有这些参与者以IMS为核心，构建了Android庞大而复杂的输入体系。</p><p>接下来详细讨论除Linux内核以外的其他参与者的工作原理。</p><h2 id="（二）、IMS的创建与启动"><a href="#（二）、IMS的创建与启动" class="headerlink" title="（二）、IMS的创建与启动"></a>（二）、IMS的创建与启动</h2><p>IMS分为Java层与Native层两个部分，其启动过程是从Java部分的初始化开始，进而完成Native部分的初始化。 IMS在SystemServer.startOtherServices()方法中启动的。IMS的诞生分为两个阶段：</p><p>· 创建新的IMS对象。</p><p>· 调用IMS对象的start()函数完成启动。</p><p>我们先看下整个启动过程的序列图，然后根据序列图来一步步分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N11-Android-Input-System-input-create-thread.png" alt="Markdown"></p><h2 id="Step-1、-SystemServer-startOtherServices"><a href="#Step-1、-SystemServer-startOtherServices" class="headerlink" title="Step 1、 SystemServer.startOtherServices()"></a>Step 1、 SystemServer.startOtherServices()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;frameworks/base/services/java/com/android/server/SystemServer.java]</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     ......</span><br><span class="line">       <span class="comment">// ① 新建IMS对象。</span></span><br><span class="line">     traceBeginAndSlog(<span class="string">"StartInputManagerService"</span>);</span><br><span class="line">     inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">     traceBeginAndSlog(<span class="string">"StartWindowManagerService"</span>);</span><br><span class="line">     wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">             mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">             !mFirstBoot, mOnlyCore);</span><br><span class="line">      <span class="comment">//将WindowManagerService加入到ServiceManager中</span></span><br><span class="line">     ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">     <span class="comment">//将InputManagerService加入到ServiceManager中</span></span><br><span class="line">     ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">     Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">     mActivityManagerService.setWindowManager(wm);</span><br><span class="line">      <span class="comment">// 设置向WMS发起回调的callback对象</span></span><br><span class="line">     inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">     <span class="comment">// ② 正式启动IMS</span></span><br><span class="line">     inputManager.start();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SystemServer中先构造了一个InputManagerService对象和一个WindowManagerService对象，然后将InputManagerService对象传给WindowManagerService对象，WindowManagerService中初始化了一个InputMonitor对象，调用InputManagerService.setWindowManagerCallbacks函数将InputMonitor传进去，后面native层回调时会调用到该InputMonitor对象。</p><h2 id="Step-2、-InputManagerService"><a href="#Step-2、-InputManagerService" class="headerlink" title="Step 2、 InputManagerService()"></a>Step 2、 InputManagerService()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    <span class="comment">//注意这里拿了DisplayThread的Handler，意味着IMS中的消息队列处理都是在单独的DisplayThread中进行的。</span></span><br><span class="line">    <span class="comment">//它是系统中共享的单例前台线程，主要用作输入输出的处理用。这样可以使用户体验敏感的处理少受其它工作的影响，减少延时。</span></span><br><span class="line">    <span class="keyword">this</span>.mHandler = <span class="keyword">new</span> InputManagerHandler(DisplayThread.get().getLooper());</span><br><span class="line">    <span class="comment">//调用nativeInit来执行C++层的初始化操作</span></span><br><span class="line">    mPtr = nativeInit(<span class="keyword">this</span>, mContext, mHandler.getLooper().getQueue());</span><br><span class="line">    LocalServices.addService(InputManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-3、-InputManagerService-nativeInit"><a href="#Step-3、-InputManagerService-nativeInit" class="headerlink" title="Step 3、 InputManagerService.nativeInit()"></a>Step 3、 InputManagerService.nativeInit()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    jobject serviceObj, jobject contextObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// 新建了一个NativeInputManager对象，NativeInputManager，此对象将是Native层组件与</span></span><br><span class="line">    <span class="comment">//Java层IMS进行通信的桥梁</span></span><br><span class="line">NativeInputManager* im = <span class="keyword">new</span> NativeInputManager(contextObj, serviceObj,</span><br><span class="line">        messageQueue-&gt;getLooper());</span><br><span class="line">im-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 返回了NativeInputManager对象的指针给Java层的IMS，IMS将其保存在mPtr成员变量中</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(im);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要作用是创建一个NativeInputManager实例，并将其作为返回值保存在InputManagerService.java中的mPtr字段中。</p><h2 id="Step-4、NativeInputManager"><a href="#Step-4、NativeInputManager" class="headerlink" title="Step 4、NativeInputManager()"></a>Step 4、NativeInputManager()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line">NativeInputManager::NativeInputManager(jobject contextObj,</span><br><span class="line">    jobject serviceObj, <span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">    mLooper(looper), mInteractive(<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">// 出现重点了， NativeInputManager创建了EventHub</span></span><br><span class="line"><span class="comment">//构造一个EventHub对象,最原始的输入事件都是通过它收集并且粗加工然后给到InputReader对象</span></span><br><span class="line">sp&lt;EventHub&gt; eventHub = <span class="keyword">new</span> EventHub();</span><br><span class="line"><span class="comment">// 接着创建了Native层的InputManager</span></span><br><span class="line">mInputManager = <span class="keyword">new</span> InputManager(eventHub, <span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NativeInputManager构造函数中创建了一个EventHub实例（稍后会详细介绍），并且将这个实例作为参数来创建一个InputManager对象，这个对象会做一些初始化的操作。</p><h2 id="Step-5、InputManager"><a href="#Step-5、InputManager" class="headerlink" title="Step 5、InputManager()"></a>Step 5、InputManager()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]</span><br><span class="line"></span><br><span class="line">InputManager::InputManager(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;EventHubInterface&gt;&amp; eventHub,   </span><br><span class="line">    <span class="keyword">const</span> sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;</span><br><span class="line">mDispatcher = <span class="keyword">new</span> InputDispatcher(dispatcherPolicy);</span><br><span class="line">mReader = <span class="keyword">new</span> InputReader(eventHub, readerPolicy, mDispatcher);</span><br><span class="line">initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了InputDispatcher对象用于分发按键给当前focus的窗口的，同时创建了一个InputReader用于从EventHub中读取事件。</p><h2 id="Step-6、InputManager-initialize"><a href="#Step-6、InputManager-initialize" class="headerlink" title="Step 6、InputManager.initialize()"></a>Step 6、InputManager.initialize()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputManager::initialize() &#123;</span><br><span class="line"> <span class="comment">// 创建供InputReader运行的线程InputReaderThread</span></span><br><span class="line">mReaderThread = <span class="keyword">new</span> InputReaderThread(mReader);</span><br><span class="line">  <span class="comment">// 创建供InputDispatcher运行的线程InputDispatcherThread</span></span><br><span class="line">mDispatcherThread = <span class="keyword">new</span> InputDispatcherThread(mDispatcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个InputReaderThread和InputDispatcherThread对象，前面构造函数中创建的InputReader实际上是通过InputReaderThread来读取事件，而InputDispatcher实际通过InputDispatcherThread来分发事件</p><h3 id="图3-1："><a href="#图3-1：" class="headerlink" title="图3-1："></a>图3-1：</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N12-Android-Input-System-IMS-system.png" alt="Markdown"></p><p>InputManager的构造函数也比较简洁，它创建了四个对象，分别为IMS的核心参与者InputReader与InputDispatcher，以及它们所在的线程InputReaderThread与InputDispatcherThread。注意InputManager的构造函数的参数readerPolicy与dispatcherPolicy，它们都是NativeInputManager。</p><p>至此，IMS的创建完成了。在这个过程中，输入系统的重要参与者均完成创建，并得到了如图3-1所描述的一套体系。</p><p>依次初始化NativeInputManager，EventHub，InputManager, InputDispatcher，InputReader，InputReaderThread, InputDispatcherThread。NativeInputManager可看作IMS和InputManager的中间层，将IMS的请求转化为对InputManager及其内部对象的操作，同时将InputManager中模块的请求通过JNI调回IMS。InputManager是输入控制中心，它有两个关键线程InputReaderThread和InputDispatcherThread，它们的主要功能部分分别在InputReader和InputDispacher。前者用于从设备中读取事件，后者将事件分发给目标窗口。EventHub是输入设备的控制中心，它直接与input driver打交道。负责处理输入设备的增减，查询，输入事件的处理并向上层提供getEvents()接口接收事件。在它的构造函数中，主要做三件事（结合之前Linux必备知识）：</p><ol><li>创建epoll对象，之后就可以把各输入设备的fd挂在上面多路等待输入事件。</li><li>建立用于唤醒的pipe，把读端挂到epoll上，以后如果有设备参数的变化需要处理，而getEvents()又阻塞在设备上，就可以调用wake()在pipe的写端写入，就可以让线程从等待中返回。</li><li>利用inotify机制监听/dev/input目录下的变更，如有则意味着设备的变化，需要处理。 因为事件的处理是流水线，需要InputReader先读事件，然后InputDispatcher才能进一步处理和分发。因此InputDispatcher需要监听InputReader。这里使用了Listener模式，InputDispacher作为InputReader构造函数的第三个参数，它实现InputListenerInterface接口。到了InputReader的构造函数中，将之包装成QueuedInputListener。QueuedInputListener中的成员变量mArgsQueue是一个缓冲队列，只有在flush()时，才会一次性通知InputDispatcher。QueuedInputListener应用了Command模式，它通过包装InputDispatcher(实现InputListenerInterface接口)，将事件的处理请求封装成NotifyArgs，使其有了缓冲执行的功能。</li></ol><h2 id="IMS的成员关系"><a href="#IMS的成员关系" class="headerlink" title="IMS的成员关系"></a>IMS的成员关系</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N13-Android-Input-System-IMS-membership.png" alt="Markdown"></p><h2 id="（三）、IMS启动"><a href="#（三）、IMS启动" class="headerlink" title="（三）、IMS启动"></a>（三）、IMS启动</h2><p>IMS启动主要是将前面创建的InputReaderThread和InputDispatcherThread启动起来</p><h2 id="Step-1、InputManagerService-start"><a href="#Step-1、InputManagerService-start" class="headerlink" title="Step 1、InputManagerService.start()"></a>Step 1、InputManagerService.start()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Slog.i(TAG, <span class="string">"Starting input manager"</span>);</span><br><span class="line">    nativeStart(mPtr);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要调用了nativeStart进入native层启动</p><h2 id="Step-2-InputManagerService-nativeStart"><a href="#Step-2-InputManagerService-nativeStart" class="headerlink" title="Step 2. InputManagerService.nativeStart()"></a>Step 2. InputManagerService.nativeStart()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeStart</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>, jlong ptr)</span> </span>&#123;</span><br><span class="line">NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> result = im-&gt;getInputManager()-&gt;start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入native层InputManager的start函数</p><h2 id="Step-3、InputManager-start"><a href="#Step-3、InputManager-start" class="headerlink" title="Step 3、InputManager.start()"></a>Step 3、InputManager.start()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputManager::start() &#123;</span><br><span class="line"><span class="keyword">status_t</span> result = mDispatcherThread-&gt;run(<span class="string">"InputDispatcher"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line">result = mReaderThread-&gt;run(<span class="string">"InputReader"</span>, PRIORITY_URGENT_DISPLAY);</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数实际启动了一个InputReaderThread和InputDispatcherThread来从读取和分发键盘消息，调用它们的run方法后，就会进入threadLoop函数中，只要threadLoop函数返回true，该函数就会循环执行。</p><p>InputReaderThread不断调用InputReader的pollOnce()-&gt;getEvents()函数来得到事件，这些事件可以是输入事件，也可以是由inotify监测到设备增减变更所触发的事件，稍后会详细介绍。</p><h2 id="Step-4、InputReaderThread-threadLoop"><a href="#Step-4、InputReaderThread-threadLoop" class="headerlink" title="Step 4、InputReaderThread.threadLoop()"></a>Step 4、InputReaderThread.threadLoop()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputReaderThread::threadLoop() &#123;</span><br><span class="line">mReader-&gt;loopOnce();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用前面创建的InputReaderThread对象的loopOnce进行一次线程循环</p><h2 id="Step5、InputReaderThread-loopOnce"><a href="#Step5、InputReaderThread-loopOnce" class="headerlink" title="Step5、InputReaderThread.loopOnce()"></a>Step5、InputReaderThread.loopOnce()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* ① 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数</span></span><br><span class="line"><span class="comment">   当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时 */</span></span><br><span class="line">size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">&#123;</span><br><span class="line">   AutoMutex _l(mLock);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span>(count) &#123;</span><br><span class="line">       <span class="comment">// ② 如果有抽得事件，则调用processEventsLocked()函数对事件进行加工处理</span></span><br><span class="line">       processEventsLocked(mEventBuffer, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* ③ 发布事件。 processEventsLocked()函数在对事件进行加工处理之后，便将处理后的事件存储在</span></span><br><span class="line"><span class="comment">  mQueuedListener中。在循环的最后，通过调用flush()函数将所有事件交付给InputDispatcher */</span></span><br><span class="line">  mQueuedListener-&gt;flush();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>InputReader的一次线程循环的工作思路比较清晰，一共三步：</p><p>· 首先从EventHub中抽取未处理的事件列表。这些事件分为两类，一类是从设备节点中读取的原始输入事件，另一类则是输入设备可用性变化事件，简称为设备事件。</p><p>· 通过processEventsLocked()对事件进行处理。对于设备事件，此函数对根据设备的可用性加载或移除设备对应的配置信息。对于原始输入事件，则在进行转译、封装与加工后将结果暂存到mQueuedListener中。</p><p>· 所有事件处理完毕后，调用mQueuedListener.flush()将所有暂存的输入事件一次性地交付给InputDispatcher。</p><p>这便是InputReader的总体工作流程。而我们接下来将详细讨论这三步的实现。</p><h2 id="Step-6、InputDispatcherThread-threadLoop"><a href="#Step-6、InputDispatcherThread-threadLoop" class="headerlink" title="Step 6、InputDispatcherThread.threadLoop()"></a>Step 6、InputDispatcherThread.threadLoop()</h2><p>InputDisptacher的主要任务是把收到的输入事件发送到PhoneWIndowManager或App端的焦点窗口上，稍后详细介绍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">mDispatcher-&gt;dispatchOnce();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用前面创建的InputDispatcher对象的dispatchOnce函数进行一次按键分发</p><h2 id="Step-7、InputDispatcher-dispatchOnce"><a href="#Step-7、InputDispatcher-dispatchOnce" class="headerlink" title="Step 7、InputDispatcher.dispatchOnce()"></a>Step 7、InputDispatcher.dispatchOnce()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line"><span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    mDispatcherIsAliveCondition.broadcast();</span><br><span class="line">    <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">        dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">        nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"><span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line"><span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"><span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数主要是调用dispatchOnceInnerLocked来进行一次按键分发，当没有按键消息时会走到mLooper-&gt;pollOnce(timeoutMillis)；这个函数会进入睡眠状态，当有按键消息发生时该函数会返回，然后走到dispatchOnceInnerLocked函数。这里mLooper-&gt;pollOnce为何会睡眠涉及到Android的Handler机制[☺再总结☺]。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>完成IMS的创建之后，InputManagerService.start()函数以启动IMS。InputManager的创建过程分别为InputReader与InputDispatcher创建了承载它们运行的线程，然而并未将这两个线程启动，因此IMS的各员大将仍处于待命状态。此时start()函数的功能就是启动这两个线程，使得InputReader于InputDispatcher开始工作。</p><p>当两个线程启动后，InputReader在其线程循环中不断地从EventHub中抽取原始输入事件，进行加工处理后将加工所得的事件放入InputDispatcher的派发发队列中。InputDispatcher则在其线程循环中将派发队列中的事件取出，查找合适的窗口，将事件写入到窗口的事件接收管道中。窗口事件接收线程的Looper从管道中将事件取出，交由事件处理函数进行事件响应。整个过程共有三个线程首尾相接，像三台水泵似的一层层地将事件交付给事件处理函数。如下图所示。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N14-Android-Input-System-input-event-pop.png" alt="Markdown"></p><p>InputManagerService.start()函数的作用，就像为Reader线程、Dispatcher线程这两台水泵按下开关，而Looper这台水泵在窗口创建时便已经处于运行状态了。自此，输入系统动力十足地开始运转，设备节点中的输入事件将被源源不断地抽取给事件处理者。</p><hr><h1 id="四、深入理解EventHub"><a href="#四、深入理解EventHub" class="headerlink" title="四、深入理解EventHub"></a>四、深入理解EventHub</h1><p>InputReaderThread继承自C++的Thread类，Thread类封装了pthread线程工具，提供了与Java层Thread类相似的API。C++的Thread类提供了一个名为threadLoop()的纯虚函数，当线程开始运行后，将会在内建的线程循环中不断地调用threadLoop()，直到此函数返回false，则退出线程循环，从而结束线程。 InputReaderThread启动后，其线程循环将不断地执行InputReader.loopOnce()函数。因此这个loopOnce()函数作为线程循环的循环体包含了InputReader的所有工作。前面一小节 Step5. InputReaderThread.loopOnce() 已经说到InputReaderThread一次线程循环。接下来详细说明EventHub。</p><p>· 首先从EventHub中抽取未处理的事件列表。这些事件分为两类，一类是从设备节点中读取的原始输入事件，另一类则是输入设备可用性变化事件，简称为设备事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* ① 通过EventHub抽取事件列表。读取的结果存储在参数mEventBuffer中，返回值表示事件的个数</span></span><br><span class="line"><span class="comment">   当EventHub中无事件可以抽取时，此函数的调用将会阻塞直到事件到来或者超时 */</span></span><br><span class="line">size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先贴一张EventHub-&gt;getEvents()工作时序图，跟着时序图一步步介绍。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N15-Android-Input-System-input-reader-thread.png" alt="Markdown"></p><h2 id="（1）、深入理解EventHub"><a href="#（1）、深入理解EventHub" class="headerlink" title="（1）、深入理解EventHub"></a>（1）、深入理解EventHub</h2><h3 id="1、设备节点监听的建立"><a href="#1、设备节点监听的建立" class="headerlink" title="1、设备节点监听的建立"></a>1、设备节点监听的建立</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">frameworks/native/services/inputflinger/EventHub.cpp</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) :</span><br><span class="line">    mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(<span class="number">1</span>), mControllerNumbers(),</span><br><span class="line">    mOpeningDevices(<span class="number">0</span>), mClosingDevices(<span class="number">0</span>),</span><br><span class="line">    mNeedToSendFinishedDeviceScan(<span class="literal">false</span>),</span><br><span class="line">    mNeedToReopenDevices(<span class="literal">false</span>), mNeedToScanDevices(<span class="literal">true</span>),</span><br><span class="line">    mPendingEventCount(<span class="number">0</span>), mPendingEventIndex(<span class="number">0</span>), mPendingINotify(<span class="literal">false</span>) &#123;</span><br><span class="line">acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ① 首先使用epoll_create()函数创建一个epoll对象。EPOLL_SIZE_HINT指定最大监听个数为8</span></span><br><span class="line"><span class="comment">//这个epoll对象将用来监听设备节点是否有数据可读（有无事件）</span></span><br><span class="line">mEpollFd = epoll_create(EPOLL_SIZE_HINT);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(mEpollFd &lt; <span class="number">0</span>, <span class="string">"Could not create epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 创建一个inotify对象。这个inotify对象将被用来监听设备节点的增删事件</span></span><br><span class="line">mINotifyFd = inotify_init();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//将存储设备节点的路径/dev/input作为监听对象添加到inotify对象中。当此文件夹下的设备节点</span></span><br><span class="line"> <span class="comment">//发生创建与删除事件时，都可以通过mINotifyFd读取事件的详细信息</span></span><br><span class="line"> <span class="comment">//static const char *DEVICE_PATH = "/dev/input";</span></span><br><span class="line"><span class="keyword">int</span> result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result &lt; <span class="number">0</span>, <span class="string">"Could not register INotify for %s.  errno=%d"</span>,</span><br><span class="line">        DEVICE_PATH, errno);</span><br><span class="line"></span><br><span class="line"><span class="comment">//③ 接下来将mINotifyFd作为epoll的一个监控对象。当inotify事件到来时，epoll_wait()将</span></span><br><span class="line"><span class="comment">//立刻返回，EventHub便可从mINotifyFd中读取设备节点的增删信息，并作相应处理</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">eventItem.events = EPOLLIN;<span class="comment">// 监听mINotifyFd可读</span></span><br><span class="line">eventItem.data.u32 = EPOLL_ID_INOTIFY; <span class="comment">// 注意这里并没有使用fd字段，而使用了自定义的值EPOLL_ID_INOTIFY</span></span><br><span class="line">result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);<span class="comment">// 将对mINotifyFd的监听注册到epoll对象中</span></span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add INotify to epoll instance.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在构造函数剩余的代码中，EventHub创建了一个名为wakeFds的匿名管道，并将管道读取端的描述符</span></span><br><span class="line"><span class="comment">//的可读事件注册到epoll对象中。因为InputReader在执行getEvents()时会因无事件而导致其线程</span></span><br><span class="line"><span class="comment">//阻塞在epoll_wait()的调用里，然而有时希望能够立刻唤醒InputReader线程使其处理一些请求。此</span></span><br><span class="line"><span class="comment">//时只需向wakeFds管道的写入端写入任意数据，此时读取端有数据可读，使得epoll_wait()得以返回</span></span><br><span class="line"><span class="comment">//从而达到唤醒InputReader线程的目的</span></span><br><span class="line"><span class="keyword">int</span> wakeFds[<span class="number">2</span>];</span><br><span class="line">result = pipe(wakeFds);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not create wake pipe.  errno=%d"</span>, errno);</span><br><span class="line"></span><br><span class="line">mWakeReadPipeFd = wakeFds[<span class="number">0</span>];</span><br><span class="line">mWakeWritePipeFd = wakeFds[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake read pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">        errno);</span><br><span class="line"></span><br><span class="line">result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not make wake write pipe non-blocking.  errno=%d"</span>,</span><br><span class="line">        errno);</span><br><span class="line"></span><br><span class="line">eventItem.data.u32 = EPOLL_ID_WAKE;</span><br><span class="line">result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">LOG_ALWAYS_FATAL_IF(result != <span class="number">0</span>, <span class="string">"Could not add wake read pipe to epoll instance.  errno=%d"</span>,</span><br><span class="line">        errno);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> major, minor;</span><br><span class="line">getLinuxRelease(&amp;major, &amp;minor);</span><br><span class="line"><span class="comment">// EPOLLWAKEUP was introduced in kernel 3.5</span></span><br><span class="line">mUsingEpollWakeup = major &gt; <span class="number">3</span> || (major == <span class="number">3</span> &amp;&amp; minor &gt;= <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventHub的构造函数初识化了Epoll对象和INotify对象，分别监听原始输入事件与设备节点增删事件。同时将INotify对象的可读性事件也注册到Epoll中，因此EventHub可以像处理原始输入事件一样监听设备节点增删事件了。</p><p>构造函数同时也揭示了EventHub的监听工作分为设备节点和原始输入事件两个方面，接下来将深入探讨这两方面的内容。</p><h3 id="2、getEvents-函数的工作方式"><a href="#2、getEvents-函数的工作方式" class="headerlink" title="2、getEvents()函数的工作方式"></a>2、getEvents()函数的工作方式</h3><p>正如前文所述，InputReaderThread的线程循环为Reader子系统提供了运转的动力，EventHub的工作也是由它驱动的。InputReader::loopOnce()函数调用EventHub::getEvents()函数获取事件列表，所以这个getEvents()是EventHub运行的动力所在，几乎包含了EventHub的所有工作内容，因此首先要将getEvents()函数的工作方式搞清楚。 getEvents()函数的签名如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize)</span><br></pre></td></tr></table></figure><p>此函数将尽可能多地读取设备增删事件与原始输入事件，将它们封装为RawEvent结构体，并放入buffer中供InputReader进行处理。RawEvent结构体的定义如下： [EventHub.h–&gt;RawEvent]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RawEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">nsecs_t</span> when;             <span class="comment">/* 发生事件时的时间戳 */</span></span><br><span class="line">    <span class="keyword">int32_t</span> deviceId;        <span class="comment">//产生事件的设备Id，它是由EventHub自行分配的，InputReader</span></span><br><span class="line">                            <span class="comment">//以根据它从EventHub中获取此设备的详细信息</span></span><br><span class="line">    <span class="keyword">int32_t</span> type;             <span class="comment">/* 事件的类型 */</span></span><br><span class="line">    <span class="keyword">int32_t</span> code;             <span class="comment">/* 事件代码 */</span></span><br><span class="line">    <span class="keyword">int32_t</span> value;            <span class="comment">/* 事件值 */</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>可以看出，RawEvent结构体与getevent工具的输出十分一致，包含了原始输入事件的四个基本元素，因此用RawEvent结构体表示原始输入事件是非常直观的。RawEvent同时也用来表示设备增删事件，为此，EventHub定义了三个特殊的事件类型DEVICE_ADD、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN，用以与原始输入事件进行区别。</p><p>由于getEvents()函数较为复杂，为了给后续分析铺平道路，本节不讨论其细节，先通过伪代码理解此函数的结构与工作方式，在后续深入分析时思路才会比较清晰。</p><p><strong>getEvents()函数的本质就是读取并处理Epoll事件与INotify事件</strong></p><p>参考以下代码：</p><p>[EventHub.cpp–&gt;EventHub::getEvents()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// event指针指向了在buffer下一个可用于存储事件的RawEvent结构体。每存储一个事件，</span></span><br><span class="line"><span class="comment">// event指针都回向后偏移一个元素 */</span></span><br><span class="line">RawEvent* event = buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// capacity记录了buffer中剩余的元素数量。当capacity为0时，表示buffer已满，此时需要停</span></span><br><span class="line"><span class="comment">// 继续处理新事件，并将已处理的事件返回给调用者</span></span><br><span class="line">size_tcapacity = bufferSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来的循环是getEvents()函数的主体。在这个循环中，会先将可用事件放入到buffer中并返回。</span></span><br><span class="line"><span class="comment">// 如果没有可用事件，则进入epoll_wait()等待事件的到来，epoll_wait()返回后会重新循环将可用</span></span><br><span class="line"><span class="comment">// 将新事件放入buffer</span></span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">   <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="comment">/* ① 首先进行与设备相关的工作。某些情况下，如EventHub创建后第一次执行getEvents()函数  */</span></span><br><span class="line">    <span class="comment">/* 时，需要扫描/dev/input文件夹下的所有设备节点并将这些设备打开。另外，当设备节点的发生增  */</span></span><br><span class="line">    <span class="comment">/*  动作生时，会将设备事件存入到buffer中 */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* ② 处理未被InputReader取走的输入事件与设备事件。epoll_wait()所取出的epoll_event */</span></span><br><span class="line">    <span class="comment">/* 存储在mPendingEventItems中，mPendingEventCount指定了mPendingEventItems数组 */</span></span><br><span class="line">    <span class="comment">/* 所存储的事件个数。而mPendingEventIndex指定尚未处理的epoll_event的索引 */</span></span><br><span class="line">   <span class="keyword">while</span> (mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> =</span></span><br><span class="line"><span class="class">                             <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/* 在这里分析每一个epoll_event，如果是表示设备节点可读，则读取原始事件并放置到buffer */</span></span><br><span class="line">       <span class="comment">/* 中。如果是表示mINotifyFd可读，则设置mPendingINotify为true，当InputReader */</span></span><br><span class="line">       <span class="comment">/* 将现有的输入事件都取出后读取mINotifyFd中的事件，并进行相应的设备加载与卸载操作。 */</span></span><br><span class="line">       <span class="comment">/* 另外，如果此epoll_event表示wakeFds的读取端有数据可读，则设置awake标志为true， */</span></span><br><span class="line">       <span class="comment">/* 无论此次getEvents()调用有无取到事件，都不会再次进行epoll_wait()进行事件等待 */</span></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ③ 如果mINotifyFd有数据可读，说明设备节点发生了增删操作</span></span><br><span class="line">    <span class="keyword">if</span>(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;</span><br><span class="line">       <span class="comment">/* 读取mINotifyFd中的事件，同时对输入设备进行相应的加载与卸载操作。这个操作必须当 */</span></span><br><span class="line">       <span class="comment">/* InputReader将现有输入事件读取并处理完毕后才能进行，因为现有的输入事件可能来自需要 */</span></span><br><span class="line">       <span class="comment">/* 被卸载的输入设备，InputReader处理这些事件依赖于对应的设备信息 */</span></span><br><span class="line">        ......</span><br><span class="line">        deviceChanged= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设备节点增删操作发生时，则重新执行循环体，以便将设备变化的事件放入buffer中</span></span><br><span class="line">    <span class="keyword">if</span>(deviceChanged) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果此次getEvents()调用成功获取了一些事件，或者要求唤醒InputReader，则退出循环并</span></span><br><span class="line">    <span class="comment">// 结束getEvents()的调用，使InputReader可以立刻对事件进行处理</span></span><br><span class="line">    <span class="keyword">if</span>(event != buffer || awoken) &#123;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* ④ 如果此次getEvents()调用没能获取事件，说明mPendingEventItems中没有事件可用， */</span></span><br><span class="line">    <span class="comment">/* 于是执行epoll_wait()函数等待新的事件到来，将结果存储到mPendingEventItems里，并重 */</span></span><br><span class="line">    <span class="comment">/* 置mPendingEventIndex为0 */</span></span><br><span class="line">   mPendingEventIndex = <span class="number">0</span>;</span><br><span class="line">   ......</span><br><span class="line">   intpollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS,timeoutMillis);</span><br><span class="line">   ......</span><br><span class="line">    mPendingEventCount= <span class="keyword">size_t</span>(pollResult);</span><br><span class="line">    <span class="comment">// 从epoll_wait()中得到新的事件后，重新循环，对新事件进行处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回本次getEvents()调用所读取的事件数量</span></span><br><span class="line">returnevent - buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>getEvents()函数使用Epoll的核心是mPendingEventItems数组，它是一个事件池。getEvents()函数会优先从这个事件池获取epoll事件进行处理，并将读取相应的原始输入事件返回给调用者。当因为事件池枯竭而导致调用者无法获得任何事件时，会调用epoll_wait()函数等待新事件的到来，将事件池重新注满，然后再重新处理事件池中的Epoll事件。从这个意义来说，getEvents()函数的调用过程，就是消费epoll_wait()所产生的Epoll事件的过程。因此可以将从epoll_wait()的调用开始，到将Epoll事件消费完毕的过程称为EventHub的一个监听周期。依据每次epoll_wait()产生的Epoll事件的数量以及设备节点中原始输入事件的数量，一个监听周期包含一次或多次getEvents()调用。周期中的第一次调用会因为事件池枯竭而直接进入epoll_wait()，而周期中的最后一次调用一定会将最后的事件取走。</p><p>注意getEvents()采用事件池机制的根本原因是buffer的容量限制。由于一次epoll_wait()可能返回多个设备节点的可读事件，每个设备节点又有可能读取多条原始输入事件，一段时间内原始输入事件的数量可能大于buffer的容量。因此需要一个事件池以缓存因buffer容量不够而无法处理的epoll事件，以便在下次调用时可以将这些事件优先处理。这是缓冲区操作的一个常用技巧。</p><p>当有INotify事件可以从mINotifyFd中读取时，会产生一个epoll事件，EventHub便得知设备节点发生了增删操作。在getEvents()将事件池中的所有事件处理完毕后，便会从mINotifyFd中读取INotify事件，进行输入设备的加载/卸载操作，然后生成对应的RawEvent结构体并返回给调用者。</p><p>通过上述分析可以看到，getEvents()包含了原始输入事件读取、输入设备加载/卸载等操作。这几乎是EventHub的全部工作了。如果没有geEvents()的调用，EventHub将对输入事件、设备节点增删事件置若罔闻，因此可以将一次getEvents()调用理解为一次心跳，EventHub的核心功能都会在这次心跳中完成。</p><p>getEvents()的代码还揭示了另外一个信息：在一个监听周期内的设备增删事件与Epoll事件的优先级。设备事件的生成逻辑位于Epoll事件的处理之前，因此getEvents()将优先生成设备增删事件，完成所有设备增删事件的生成之前不会处理Epoll事件，也就是不会生成原始输入事件。</p><p>接下来我们将从设备管理与原始输入事件处理两个方面深入探讨EventHub。</p><h3 id="3、输入设备管理"><a href="#3、输入设备管理" class="headerlink" title="3、输入设备管理"></a>3、输入设备管理</h3><p>因为输入设备是输入事件的来源，并且决定了输入事件的含义，因此首先讨论EventHub的输入设备管理机制。</p><p>输入设备是一个可以为接收用户操作的硬件，内核会为每一个输入设备在/dev/input/下创建一个设备节点，而当输入设备不可用时（例如被拔出），将其设备节点删除。这个设备节点包含了输入设备的所有信息，包括名称、厂商、设备类型，设备的功能等。除了设备节点，某些输入设备还包含一些自定义配置，这些配置以键值对的形式存储在某个文件中。这些信息决定了Reader子系统如何加工原始输入事件。EventHub负责在设备节点可用时加载并维护这些信息，并在设备节点被删除时将其移除。</p><p>EventHub通过一个定义在其内部的名为Device的私有结构体来描述一个输入设备。其定义如下：</p><p>[EventHub.h–&gt;EventHub::Device]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Device</span> &#123;</span></span><br><span class="line">Device* next;  <span class="comment">/* Device结构体实际上是一个单链表 */</span></span><br><span class="line"><span class="keyword">int</span> fd;         <span class="comment">/* fd表示此设备的设备节点的描述符，可以从此描述符中读取原始输入事件 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int32_t</span> id;     <span class="comment">/* id在输入系统中唯一标识这个设备，由EventHub在加载设备时进行分配 */</span></span><br><span class="line"><span class="keyword">const</span> String8 path; <span class="comment">/* path存储了设备节点在文件系统中的路径 */</span></span><br><span class="line"><span class="keyword">const</span> InputDeviceIdentifier identifier; <span class="comment">/* 厂商信息，存储了设备的供应商、型号等信息</span></span><br><span class="line"><span class="comment">                                                   这些信息从设备节点中获得 */</span></span><br><span class="line"><span class="keyword">uint32_t</span> classes;  <span class="comment">/* classes表示了设备的类别，键盘设备，触控设备等。一个设备可以同时属于</span></span><br><span class="line"><span class="comment">                          多个设备类别。类别决定了InputReader如何加工其原始输入事件 */</span></span><br><span class="line"><span class="comment">/* 接下来是一系列的事件位掩码，它们详细地描述了设备能够产生的事件类型。设备能够产生的事件类型</span></span><br><span class="line"><span class="comment">   决定了此设备所属的类型*/</span></span><br><span class="line"><span class="keyword">uint8_t</span> keyBitmask[(KEY_MAX + <span class="number">1</span>) / <span class="number">8</span>];</span><br><span class="line">......</span><br><span class="line"><span class="comment">/* 配置信息。以键值对的形式存储在一个文件中，其路径取决于identfier字段中的厂商信息，这些</span></span><br><span class="line"><span class="comment">   配置信息将会影响InputReader对此设备的事件的加工行为 */</span></span><br><span class="line">String8 configurationFile;</span><br><span class="line">PropertyMap* configuration;</span><br><span class="line"><span class="comment">/* 键盘映射表。对于键盘类型的设备，这些键盘映射表将原始事件中的键盘扫描码转换为Android定义的</span></span><br><span class="line"><span class="comment">  的按键值。这个映射表也是从一个文件中加载的，文件路径取决于dentifier字段中的厂商信息 */</span></span><br><span class="line">   VirtualKeyMap* virtualKeyMap;</span><br><span class="line">KeyMap keyMap;</span><br><span class="line"> sp&lt;KeyCharacterMap&gt; overlayKeyMap;</span><br><span class="line"> sp&lt;KeyCharacterMap&gt; combinedKeyMap;</span><br><span class="line"><span class="comment">// 力反馈相关的信息。有些设备如高级的游戏手柄支持力反馈功能，目前暂不考虑</span></span><br><span class="line"><span class="keyword">bool</span> ffEffectPlaying;</span><br><span class="line"><span class="keyword">int16_t</span> ffEffectId;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Device结构体所存储的信息主要包括以下几个方面：</p><p>· 设备节点信息：保存了输入设备节点的文件描述符、文件路径等。</p><p>· 厂商信息：包括供应商、设备型号、名称等信息，这些信息决定了加载配置文件与键盘映射表的路径。</p><p>· 设备特性信息：包括设备的类别，可以上报的事件种类等。这些特性信息直接影响了InputReader对其所产生的事件的加工处理方式。</p><p>· 设备的配置信息：包括键盘映射表及其他自定义的信息，从特定位置的配置文件中读取。</p><p>另外，Device结构体还存储了力反馈所需的一些数据。在本节中暂不讨论。</p><p>EventHub用一个名为mDevices的字典保存当前处于打开状态的设备节点的Device结构体。字典的键为设备Id。</p><h3 id="（1）、输入设备的加载"><a href="#（1）、输入设备的加载" class="headerlink" title="（1）、输入设备的加载"></a>（1）、输入设备的加载</h3><p>EventHub在创建后在第一次调用getEvents()函数时完成对系统中现有输入设备的加载。</p><p>再看一下getEvents()函数中相关内容的实现：</p><p>[EventHub.cpp–&gt;EventHub::getEvents()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    <span class="comment">// 处理输入设备卸载操作</span></span><br><span class="line">   ......</span><br><span class="line">    <span class="comment">/* 在EventHub的构造函数中，mNeedToScanDevices被设置为true，因此创建后第一次调用</span></span><br><span class="line"><span class="comment">      getEvents()函数会执行scanDevicesLocked()，加载所有输入设备 */</span></span><br><span class="line">    <span class="keyword">if</span>(mNeedToScanDevices) &#123;</span><br><span class="line">       mNeedToScanDevices = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">/*scanDevicesLocked()将会把/dev/input下所有可用的输入设备打开并存储到Device</span></span><br><span class="line"><span class="comment">           结构体中 */</span></span><br><span class="line">       scanDevicesLocked();</span><br><span class="line">       mNeedToSendFinishedDeviceScan = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">returnevent – buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载所有输入设备由scanDevicesLocked()函数完成。看一下其实现：</p><p>[EventHub.cpp–&gt;EventHub::scanDevicesLocked()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> EventHub::scanDevicesLocked() &#123;</span><br><span class="line"><span class="comment">// 调用scanDirLocked()函数遍历/dev/input文件夹下的所有设备节点并打开</span></span><br><span class="line">status_tres = scanDirLocked(DEVICE_PATH);</span><br><span class="line">......<span class="comment">// 错误处理</span></span><br><span class="line"><span class="comment">// 打开一个名为VIRTUAL_KEYBOARD的输入设备。这个设备时刻是打开着的。它是一个虚拟的输入设</span></span><br><span class="line">   备，没有对应的输入节点。读者先记住有这么一个输入设备存在于输入系统中 */</span><br><span class="line"><span class="keyword">if</span>(mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   createVirtualKeyboardLocked();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scanDirLocked()遍历指定文件夹下的所有设备节点，分别对其执行openDeviceLocked()完成设备的打开操作。在这个函数中将为设备节点创建并加载Device结构体。参考其代码：</p><p>[EventHub.cpp–&gt;EventHub::openDeviceLocked()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventHub::openDeviceLocked(<span class="keyword">const</span> <span class="keyword">char</span>*devicePath) &#123;</span><br><span class="line"><span class="comment">// 打开设备节点的文件描述符，用于获取设备信息以及读取原始输入事件</span></span><br><span class="line"><span class="keyword">int</span> fd =open(devicePath, O_RDWR | O_CLOEXEC);</span><br><span class="line"><span class="comment">// 接下来的代码通过ioctl()函数从设备节点中获取输入设备的厂商信息</span></span><br><span class="line">InputDeviceIdentifier identifier;</span><br><span class="line">......</span><br><span class="line"><span class="comment">// 分配一个设备Id并创建Device结构体</span></span><br><span class="line">int32_tdeviceId = mNextDeviceId++;</span><br><span class="line">Device*device = <span class="keyword">new</span> Device(fd, deviceId, String8(devicePath), identifier);</span><br><span class="line"><span class="comment">// 为此设备加载配置信息。</span></span><br><span class="line"> loadConfigurationLocked(device);</span><br><span class="line"> <span class="comment">// ① 通过ioctl函数获取设备的事件位掩码。事件位掩码指定了输入设备可以产生何种类型的输入事件</span></span><br><span class="line">  ioctl(fd, EVIOCGBIT(EV_KEY, <span class="keyword">sizeof</span>(device-&gt;keyBitmask)),device-&gt;keyBitmask);</span><br><span class="line">......</span><br><span class="line"> ioctl(fd, EVIOCGPROP(<span class="keyword">sizeof</span>(device-&gt;propBitmask)),device-&gt;propBitmask);</span><br><span class="line">  <span class="comment">// 接下来的一大段内容是根据事件位掩码为设备分配类别，即设置classes字段。、</span></span><br><span class="line">......</span><br><span class="line"> <span class="comment">/* ② 将设备节点的描述符的可读事件注册到Epoll中。当此设备的输入事件到来时，Epoll会在</span></span><br><span class="line"><span class="comment">  getEvents()函数的调用中产生一条epoll事件 */</span></span><br><span class="line">   structepoll_event eventItem;</span><br><span class="line">   <span class="built_in">memset</span>(&amp;eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(eventItem));</span><br><span class="line">   eventItem.events = EPOLLIN;</span><br><span class="line">   eventItem.data.u32 = deviceId; <span class="comment">/* 注意，epoll_event的自定义信息是设备的Id</span></span><br><span class="line"><span class="comment">   if(epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem)) &#123;</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">     ......</span></span><br><span class="line"><span class="comment">     // ③ 调用addDeviceLocked()将Device添加到mDevices字典中</span></span><br><span class="line"><span class="comment">     addDeviceLocked(device);</span></span><br><span class="line"><span class="comment">     return0;</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br></pre></td></tr></table></figure><p>openDeviceLocked()函数打开指定路径的设备节点，为其创建并填充Device结构体，然后将设备节点的可读事件注册到Epoll中，最后将新建的Device结构体添加到mDevices字典中以供检索之需。整个过程比较清晰，但仍有以下几点需要注意：</p><p>· openDeviceLocked()函数从设备节点中获取了设备可能上报的事件类型，并据此为设备分配了类别。整个分配过程非常繁琐，由于它和InputReader的事件加工过程关系紧密，因此这部分内容将在5.2.4节再做详细讨论。</p><p>· 向Epoll注册设备节点的可读事件时，epoll_event的自定义数据被设置为设备的Id而不是fd。</p><p>· addDeviceLocked()将新建的Device对象添加到mDevices字典中的同时也会将其添加到一个名为mOpeningDevices的链表中。这个链表保存了刚刚被加载，但尚未通过getEvents()函数向InputReader发送DEVICE_ADD事件的设备。</p><p>完成输入设备的加载之后，通过getEvents()函数便可以读取到此设备所产生的输入事件了。除了在getEvents()函数中使用scanDevicesLockd()一次性加载所有输入设备，当INotify事件告知有新的输入设备节点被创建时，也会通过opendDeviceLocked()将设备加载，稍后再做讨论。</p><h3 id="（2）、输入设备的卸载"><a href="#（2）、输入设备的卸载" class="headerlink" title="（2）、输入设备的卸载"></a>（2）、输入设备的卸载</h3><p>输入设备的卸载由closeDeviceLocked()函数完成。由于此函数的工作内容与openDeviceLocked()函数正好相反，就不列出其代码了。设备的卸载过程为：</p><p>· 从Epoll中注销对描述符的监听。</p><p>· 关闭设备节点的描述符。</p><p>· 从mDevices字典中删除对应的Device对象。</p><p>· 将Device对象添加到mClosingDevices链表中，与mOpeningDevices类似，这个链表保存了刚刚被卸载，但尚未通过getEvents()函数向InputReader发送DEVICE_REMOVED事件的设备。</p><p>同加载设备一样，在getEvents()函数中有根据需要卸载所有输入设备的操作（比如当EventHub要求重新加载所有设备时，会先将所有设备卸载）。并且当INotify事件告知有设备节点删除时也会调用closeDeviceLocked()将设备卸载。</p><h3 id="（3）、设备增删事件"><a href="#（3）、设备增删事件" class="headerlink" title="（3）、设备增删事件"></a>（3）、设备增删事件</h3><p>在分析设备的加载与卸载时发现，新加载的设备与新卸载的设备会被分别放入mOpeningDevices与mClosingDevices链表之中。这两个链表将是在getEvents()函数中向InputReader发送设备增删事件的依据。</p><p>参考getEvents()函数的相关代码，以设备卸载事件为例看一下设备增删事件是如何产生的：</p><p>[EventHub.cpp–&gt;EventHub::getEvents()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">    <span class="comment">// 遍历mClosingDevices链表，为每一个已卸载的设备生成DEVICE_REMOVED事件</span></span><br><span class="line">   <span class="keyword">while</span> (mClosingDevices) &#123;</span><br><span class="line">       Device* device = mClosingDevices;</span><br><span class="line">       mClosingDevices = device-&gt;next;</span><br><span class="line">       <span class="comment">/* 分析getEvents()函数的工作方式时介绍过，event指针指向buffer中下一个可用于填充</span></span><br><span class="line"><span class="comment">          事件的RawEvent对象 */</span></span><br><span class="line">       event-&gt;when = now; <span class="comment">// 设置产生事件的事件戳</span></span><br><span class="line">       event-&gt;deviceId =</span><br><span class="line">               device-&gt;id ==mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id;</span><br><span class="line">       event-&gt;type = DEVICE_REMOVED; <span class="comment">// 设置事件的类型为DEVICE_REMOVED</span></span><br><span class="line">       event += <span class="number">1</span>; <span class="comment">// 将event指针移动到下一个可用于填充事件的RawEvent对象</span></span><br><span class="line">       <span class="keyword">delete</span> device; <span class="comment">// 生成DEVICE_REMOVED事件之后，被卸载的Device对象就不再需要了</span></span><br><span class="line">       mNeedToSendFinishedDeviceScan = <span class="literal">true</span>; <span class="comment">// 随后发送FINISHED_DEVICE_SCAN事件</span></span><br><span class="line">        <span class="comment">/* 当buffer已满则停止继续生成事件，将已生成的事件返回给调用者。尚未生成的事件</span></span><br><span class="line"><span class="comment">          将在下次getEvents()调用时生成并返回给调用者 */</span></span><br><span class="line">       <span class="keyword">if</span> (--capacity == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接下来进行DEVICE_ADDED事件的生成，此过程与 DEVICE_REMOVED事件的生成一致</span></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">returnevent – buffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在一次getEvents()调用中会尝试为所有尚未发送增删事件的输入设备生成对应的事件返回给调用者。表示设备增删事件的RawEvent对象包含三个信息：产生事件的事件戳、产生事件的设备Id，以及事件类型（DEVICE_ADDED或DEVICE_REMOVED）。</p><p>当生成设备增删事件时，会设置mNeedToSendFinishedDeviceSan为true，这个动作的意思是完成所有DEVICE_ADDED/REMOVED事件的生成之后，需要向getEvents()的调用者发送一个FINISHED_DEVICE_SCAN事件，表示设备增删事件的上报结束。这个事件仅包括时间戳与事件类型两个信息。</p><p>经过以上分析可知，EventHub可以产生的设备增删事件一共有三种，而且这三种事件拥有固定的优先级，DEVICE_REMOVED事件的优先级最高，DEVICE_ADDED事件次之，FINISHED_DEVICE_SCAN事件最低。而且，getEvents()完成当前高优先级事件的生成之前，不会进行低优先级事件的生成。因此，当发生设备的加载与卸载时，EventHub所生成的完整的设备增删事件序列如图5-5所示，其中R表示DEVICE_REMOVED，A表示DEVICE_ADDED，F表示FINISHED_DEVICE_SCAN。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N16-Android-Input-System-input-device-add-del.png" alt="Markdown"></p><p>图：设备增删事件的完整序列</p><p>由于参数buffer的容量限制，这个事件序列可能需要通过多次getEvents()调用才能完整地返回给调用者。另外，根据5.2.2节的讨论，设备增删事件相对于Epoll事件拥有较高的优先级，因此从R1事件开始生成到F事件生成之前，getEvents()不会处理Epoll事件，也就是说不会生成原始输入事件。</p><p>总结一下设备增删事件的生成原理：</p><p>· 当发生设备增删时，addDeviceLocked()函数与closeDeviceLocked()函数会将相应的设备放入mOpeningDevices和mClosingDevices链表中。</p><p>· getEvents()函数会根据mOpeningDevices和mClosingDevices两个链表生成对应DEVICE_ADDED和DEVICE_REMOVED事件，其中后者的生成拥有高优先级。</p><p>· DEVICE_ADDED和DEVICE_REMOVED事件都生成完毕后，getEvents()会生成FINISHED_DEVICE_SCAN事件，标志设备增删事件序列的结束。</p><h3 id="（4）、通过INotify动态地加载与卸载设备"><a href="#（4）、通过INotify动态地加载与卸载设备" class="headerlink" title="（4）、通过INotify动态地加载与卸载设备"></a>（4）、通过INotify动态地加载与卸载设备</h3><p>通过前文的介绍知道了openDeviceLocked()和closeDeviceLocked()可以加载与卸载输入设备。接下来分析EventHub如何通过INotify进行设备的动态加载与卸载。在EventHub的构造函数中创建了一个名为mINotifyFd的INotify对象的描述符，用以监控/dev/input下设备节点的增删。之后将mINotifyFd的可读事件加入到Epoll中。于是可以确定动态加载与卸载设备的工作方式为：首先筛选epoll_wait()函数所取得的Epoll事件，如果Epoll事件表示了mINotifyFd可读，便从mINotifyFd中读取设备节点的增删事件，然后通过执行openDeviceLocked()或closeDeviceLocked()进行设备的加载与卸载。</p><p>看一下getEvents()中与INotify相关的代码：</p><p>[EventHub.cpp–&gt;EventHub::getEvents()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">   ...... <span class="comment">// 设备增删事件处理</span></span><br><span class="line">    <span class="keyword">while</span>(mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> =</span></span><br><span class="line"><span class="class">                             <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line">       <span class="comment">/* ① 通过Epoll事件的data字段确定此事件表示了mINotifyFd可读</span></span><br><span class="line"><span class="comment">          注意EPOLL_ID_INOTIFY在EventHub的构造函数中作为data字段向</span></span><br><span class="line"><span class="comment">          Epoll注册mINotifyFd的可读事件 */</span></span><br><span class="line">       <span class="keyword">if</span> (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123;</span><br><span class="line">           <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">               mPendingINotify = <span class="literal">true</span>; <span class="comment">// 标记INotify事件待处理</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; ...... &#125;</span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">// 继续处理下一条Epoll事件</span></span><br><span class="line">       &#125;</span><br><span class="line">       ...... <span class="comment">// 其他Epoll事件的处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果INotify事件待处理</span></span><br><span class="line">    <span class="keyword">if</span>(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123;</span><br><span class="line">       mPendingINotify = <span class="literal">false</span>;</span><br><span class="line">       <span class="comment">/* ② 调用readNotifyLocked()函数读取并处理存储在mINotifyFd中的INotify事件</span></span><br><span class="line"><span class="comment">          这个函数将完成设备的加载与卸载 */</span></span><br><span class="line">       readNotifyLocked();</span><br><span class="line">       deviceChanged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//③ 如果处理了INotify事件，则返回到循环开始处，生成设备增删事件</span></span><br><span class="line">    <span class="keyword">if</span>(deviceChanged) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getEvents()函数中与INotify相关的代码共有三处：</p><p>· 识别表示mINotifyFd可读的Epoll事件，并通过设置mPendingINotify为true以标记有INotify事件待处理。getEvents()并没有立刻处理INotify事件，因为此时进行设备的加载与卸载是不安全的。其他Epoll事件可能包含了来自即将被卸载的设备的输入事件，因此需要将所有Epoll事件都处理完毕后再进行加载与卸载操作。</p><p>· 当epoll_wait()所返回的Epoll事件都处理完毕后，调用readNotifyLocked()函数读取mINotifyFd中的事件，并进行设备的加载与卸载操作。</p><p>· 完成设备的动态加载与卸载后，需要返回到循环最开始处，以便设备增删事件处理代码生成设备的增删事件。</p><p>其中第一部分与第三部分比较容易理解。接下来看一下readNotifyLocked()是如何工作的。</p><p>[EventHub.cpp–&gt;EventHub::readNotifyLocked()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> EventHub::readNotifyLocked() &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 从mINotifyFd中读取INotify事件列表</span></span><br><span class="line">    res =read(mINotifyFd, event_buf, <span class="keyword">sizeof</span>(event_buf));</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 逐个处理列表中的事件</span></span><br><span class="line">       <span class="keyword">while</span>(res &gt;= (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(*event)) &#123;</span><br><span class="line">       <span class="built_in">strcpy</span>(filename, event-&gt;name); <span class="comment">// 从事件中获取设备节点路径</span></span><br><span class="line">       <span class="keyword">if</span>(event-&gt;mask &amp; IN_CREATE) &#123;</span><br><span class="line">           openDeviceLocked(devname); <span class="comment">// 如果事件类型为IN_CREATE，则加载对应设备</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           closeDeviceByPathLocked(devname); <span class="comment">// 否则卸载对应设备</span></span><br><span class="line">        &#125;</span><br><span class="line">        ......<span class="comment">// 移动到列表中的下一个事件</span></span><br><span class="line">    &#125;</span><br><span class="line">    return0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="（5）、EventHub设备管理总结"><a href="#（5）、EventHub设备管理总结" class="headerlink" title="（5）、EventHub设备管理总结"></a>（5）、EventHub设备管理总结</h3><p>至此，EventHub的设备管理相关的知识便讨论完毕了。在这里进行一下总结：</p><p>· EventHub通过Device结构体描述输入设备的各种信息。</p><p>· EventHub在getEvents()函数中进行设备的加载与卸载操作。设备的加载与卸载分为按需加载或卸载以及通过INotify动态加载或卸载特定设备两种方式。</p><p>· getEvents()函数进行了设备的加载与卸载操作后，会生成DEVICE_ADDED、DEVICE_REMOVED以及FINISHED_DEVICE_SCAN三种设备增删事件，并且设备增删事件拥有高于Epoll事件的优先级。 4．原始输入事件的监听与读取 本节将讨论EventHub另一个核心的功能，监听与读取原始输入事件。</p><p>回忆一下输入设备的加载过程，当设备加载时，openDeviceLocked()会打开设备节点的文件描述符，并将其可读事件注册进Epoll中。于是当设备的原始输入事件到来时，getEvents()函数将会获得一条Epoll事件，然后根据此Epoll事件读取文件描述符中的原始输入事件，将其填充到RawEvents结构体并放入buffer中被调用者取走。openDeviceLocked()注册了设备节点的EPOLLIN和EPOLLHUP两个事件，分别表示可读与被挂起（不可用），因此getEvents()需要分别处理这两种事件。</p><p>看一下getEvents()函数中的相关代码：</p><p>[EventHub.cpp–&gt;EventHub::getEvents()]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis,RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line"><span class="keyword">for</span> (;;)&#123;</span><br><span class="line">   ...... <span class="comment">// 设备增删事件处理</span></span><br><span class="line">    <span class="keyword">while</span>(mPendingEventIndex &lt; mPendingEventCount) &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&amp; <span class="title">eventItem</span> =</span></span><br><span class="line"><span class="class">                             <span class="title">mPendingEventItems</span>[<span class="title">mPendingEventIndex</span>++];</span></span><br><span class="line">       ...... <span class="comment">// INotify与wakeFd的Epoll事件处理</span></span><br><span class="line">       <span class="comment">/* ① 通过Epoll的data.u32字段获取设备Id，进而获取对应的Device对象。如果无法找到</span></span><br><span class="line"><span class="comment">          对应的Device对象，说明此Epoll事件并不表示原始输入事件的到来，忽略之 */</span></span><br><span class="line">       <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(eventItem.data.u32);</span><br><span class="line">       Device* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">       ......</span><br><span class="line">       <span class="keyword">if</span> (eventItem.events &amp; EPOLLIN) &#123;</span><br><span class="line">           <span class="comment">/* ② 如果Epoll事件为EPOLLIN，表示设备节点有原始输入事件可读。此时可以从描述符</span></span><br><span class="line"><span class="comment">              中读取。读取结果作为input_event结构体并存储在readBuffer中，注意事件的个数</span></span><br><span class="line"><span class="comment">               受到capacity的限制*/</span></span><br><span class="line">           <span class="keyword">int32_t</span> readSize = read(device-&gt;fd, readBuffer,</span><br><span class="line">                    <span class="keyword">sizeof</span>(structinput_event) * capacity);</span><br><span class="line">           <span class="keyword">if</span> (......) &#123;                    ......<span class="comment">// 一些错误处理 &#125;</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">size_t</span> count = <span class="keyword">size_t</span>(readSize) / <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">               <span class="comment">/* ② 将读取到的每一个input_event结构体中的数据转换为一个RawEvent对象，</span></span><br><span class="line"><span class="comment">                   并存储在buffer参数中以返回给调用者 */</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                    <span class="keyword">const</span> structinput_event&amp; iev = readBuffer[i];</span><br><span class="line">                    ......</span><br><span class="line">                    event-&gt;when = now;</span><br><span class="line">                    event-&gt;deviceId =deviceId;</span><br><span class="line">                    event-&gt;type =iev.type;</span><br><span class="line">                    event-&gt;code =iev.code;</span><br><span class="line">                    event-&gt;value =iev.value;</span><br><span class="line">                   event += <span class="number">1</span>; <span class="comment">// 移动到buffer的下一个可用元素</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">/* 接下来的一个细节需要注意，因为buffer的容量限制，可能无法完全读取设备节点</span></span><br><span class="line"><span class="comment">                   中存储的原始事件。一旦buffer满了则需要立刻返回给调用者。设备节点中剩余的</span></span><br><span class="line"><span class="comment">                   输入事件将在下次getEvents()调用时继续读取，也就是说，当前的Epoll事件</span></span><br><span class="line"><span class="comment">                   并未处理完毕。mPendingEventIndex -= 1的目的就是使下次getEvents()调用</span></span><br><span class="line"><span class="comment">                   能够继续处理这个Epoll事件 */</span></span><br><span class="line">               capacity -= count;</span><br><span class="line">               <span class="keyword">if</span> (capacity == <span class="number">0</span>) &#123;</span><br><span class="line">                    mPendingEventIndex -=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventItem.events &amp; EPOLLHUP) &#123;</span><br><span class="line">           deviceChanged = <span class="literal">true</span>; <span class="comment">// 如果设备节点的文件描述符被挂起则卸载此设备</span></span><br><span class="line">           closeDeviceLocked(device);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; ...... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ...... <span class="comment">// 读取并处理INotify事件</span></span><br><span class="line">    ......<span class="comment">// 等待新的Epoll事件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> event – buffer；&#125;</span><br></pre></td></tr></table></figure><p>getEvents()通过Epoll事件的data.u32字段在mDevices列表中查找已加载的设备，并从设备的文件描述符中读取原始输入事件列表。从文件描述符中读取的原始输入事件存储在input_event结构体中，这个结构体的四个字段存储了事件的事件戳、类型、代码与值四个元素。然后逐一将input_event的数据转存到RawEvent中并保存至buffer以返回给调用者。</p><p>注意为了叙述简单，上述代码使用了调用getEvents()的时间作为输入事件的时间戳。由于调用getEvents()函数的时机与用户操作的时间差的存在，会使得此时间戳与事件的真实时间有所偏差。从设备节点中读取的input_event中也包含了一个时间戳，这个时间戳消除了getEvents()调用所带来的时间差，因此可以获得更精确的时间控制。可以通过打开HAVE_POSIX_CLOCKS宏以使用input_event中的时间而不是将getEvents()调用的时间作为输入事件的时间戳。</p><p>需要注意的是，由于Epoll事件的处理优先级低于设备增删事件，因此当发生设备加载与卸载动作时，不会产生设备输入事件。另外还需注意，在一个监听周期中，getEvents()在将一个设备节点中的所有原始输入事件读取完毕之前，不会读取其他设备节点中的事件。</p><h3 id="5、EventHub总结"><a href="#5、EventHub总结" class="headerlink" title="5、EventHub总结"></a>5、EventHub总结</h3><p>本节针对EventHub的设备管理与原始输入事件的监听读取两个核心内容介绍了EventHub的工作原理。EventHub作为直接操作设备节点的输入系统组件，隐藏了INotify与Epoll以及设备节点读取等底层操作，通过一个简单的接口getEvents()向使用者提供抽取设备事件与原始输入事件的功能。EventHub的核心功能都在getEvents()函数中完成，因此深入理解getEvents()的工作原理对于深入理解EventHub至关重要。</p><p>getEvents()函数的本质是通过epoll_wait()获取Epoll事件到事件池，并对事件池中的事件进行消费的过程。从epoll_wait()的调用开始到事件池中最后一个事件被消费完毕的过程称之为EventHub的一个监听周期。由于buffer参数的尺寸限制，一个监听周期可能包含多个getEvents()调用。周期中的第一个getEvents()调用一定会因事件池的枯竭而直接进行epoll_wait()，而周期中的最后一个getEvents()一定会将事件池中的最后一条事件消费完毕并将事件返回给调用者。前文所讨论的事件优先级都是在同一个监听周期内而言的。</p><p>在本节中出现了很多种事件，有原始输入事件、设备增删事件、Epoll事件、INotify事件等，存储事件的结构体有RawEvent、epoll_event、inotify_event、input_event等。图5-6可以帮助读者理清这些事件之间的关系。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N17-Android-Input-System-epoll.png" alt="Markdown"></p><p>图 5-6 EventHub的事件关联</p><p>另外，getEvents()函数返回的事件列表依照事件的优先级拥有特定的顺序。并且在一个监听周期中，同一输入设备的输入事件在列表中是相邻的。</p><p>至此，相信读者对EventHub的工作原理，以及EventHub的事件监听与读取机制有了深入的了解。接下来的内容将讨论EventHub所提供的原始输入事件如何被加工为Android输入事件，这个加工者就是Reader子系统中的另一员大将：InputReader。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N18-Android-Input-System-EventHub-Kernel.png" alt="Markdown"></p><hr><h2 id="五、Input-Reader"><a href="#五、Input-Reader" class="headerlink" title="五、Input Reader"></a>五、Input Reader</h2><p>根据第四节的分析。输入设备扫描完成，并加入epoll中，监听事件。从前面的getEvents函数分析得知，当按键事件发生后，getEvents函数返回。 这里再贴一下Input 处理时间流程图，然后按步骤详细分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N15-Android-Input-System-input-reader-thread.png" alt="Markdown"></p><p>以一次键盘按键为例，得到下面的6个事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.680195</span>, type=<span class="number">4</span>, code=<span class="number">4</span>, value=<span class="number">458792</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.680195</span>, type=<span class="number">1</span>, code=<span class="number">28</span>, value=<span class="number">1</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.680195</span>, type=<span class="number">0</span>, code=<span class="number">0</span>, value=<span class="number">0</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.760186</span>, type=<span class="number">4</span>, code=<span class="number">4</span>, value=<span class="number">458792</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.760186</span>, type=<span class="number">1</span>, code=<span class="number">28</span>, value=<span class="number">0</span></span><br><span class="line">EventHub: /dev/input/event2 got: time=<span class="number">4383.760186</span>, type=<span class="number">0</span>, code=<span class="number">0</span>, value=<span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面的type是linux的输入系统里的事件，具体的值可以查看 查看input.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SYN 0x00   同步事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_KEY 0x01   按键事件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REL 0x02   相对坐标</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ABS 0x03   绝对坐标</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_MSC 0x04   其它</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SW  0x05   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_LED 0x11   LED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SND 0x12   声音</span></span><br><span class="line"><span class="comment">/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_REP 0x14   Repeat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_FF  0x15   力反馈</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PWR 0x16   电源</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_FF_STATUS 0x17 状态</span></span><br></pre></td></tr></table></figure><p>上面6个事件，只有两个type为1的事件，是我们需要处理的按键事件，一个down，一个up</p><h2 id="Step-1、-InputReader-loopOnce"><a href="#Step-1、-InputReader-loopOnce" class="headerlink" title="Step 1、 InputReader::loopOnce()"></a>Step 1、 InputReader::loopOnce()</h2><p>返回到InputReader的loopOnce函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">  <span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">  &#123; <span class="comment">// acquire lock</span></span><br><span class="line">      AutoMutex _l(mLock);</span><br><span class="line">      mReaderIsAliveCondition.broadcast();</span><br><span class="line">      <span class="comment">//当有按键事件发生时，count将不为0，以一次按键为例，这里应该是6个事件</span></span><br><span class="line">      <span class="keyword">if</span> (count) &#123;</span><br><span class="line">          processEventsLocked(mEventBuffer, count);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">// release lock</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>当有按键事件发生时，count将不为0，之后会调用processEventsLocked来处理RawEvent。</p><h2 id="Step-2、InputReader-processEventsLocked"><a href="#Step-2、InputReader-processEventsLocked" class="headerlink" title="Step 2、InputReader.processEventsLocked()"></a>Step 2、InputReader.processEventsLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::processEventsLocked(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count;) &#123;</span><br><span class="line">  <span class="keyword">int32_t</span> type = rawEvent-&gt;type;</span><br><span class="line">  <span class="keyword">size_t</span> batchSize = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123;</span><br><span class="line">      <span class="keyword">int32_t</span> deviceId = rawEvent-&gt;deviceId;</span><br><span class="line">      <span class="comment">//依次处理rawEvent</span></span><br><span class="line">      processEventsForDeviceLocked(deviceId, rawEvent, batchSize);</span><br><span class="line">  &#125;</span><br><span class="line">  count -= batchSize;</span><br><span class="line">  rawEvent += batchSize;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数调用processEventsForDeviceLocked依次处理rawEvent</p><h2 id="Step-3、InputReader-processEventsForDeviceLocked"><a href="#Step-3、InputReader-processEventsForDeviceLocked" class="headerlink" title="Step 3、InputReader.processEventsForDeviceLocked()"></a>Step 3、InputReader.processEventsForDeviceLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::processEventsForDeviceLocked(<span class="keyword">int32_t</span> deviceId,</span><br><span class="line">      <span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line">  <span class="keyword">ssize_t</span> deviceIndex = mDevices.indexOfKey(deviceId);</span><br><span class="line">  InputDevice* device = mDevices.valueAt(deviceIndex);</span><br><span class="line">  <span class="comment">//调用InputDevice的process函数</span></span><br><span class="line">  device-&gt;process(rawEvents, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里根据deviceId获取到InputDevice，然后调用InputDevice的process函数</p><h2 id="Step-4、InputDevice-process"><a href="#Step-4、InputDevice-process" class="headerlink" title="Step 4、InputDevice.process()"></a>Step 4、InputDevice.process()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDevice::process(<span class="keyword">const</span> RawEvent* rawEvents, <span class="keyword">size_t</span> count) &#123;</span><br><span class="line"><span class="keyword">size_t</span> numMappers = mMappers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mDropUntilNextSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numMappers; i++) &#123;    </span><br><span class="line">            InputMapper* mapper = mMappers[i];  </span><br><span class="line">            <span class="comment">// InputMapper是做什么的呢，它是用于解析原始输入事件的。比如back, home等VirtualKey，</span></span><br><span class="line">            <span class="comment">// 传上来时是个Touch事件，这里要根据坐标转化为相应的按键事件。再比如多点触摸时，需要计算</span></span><br><span class="line">            <span class="comment">// 每个触摸点分别属于哪条轨迹，安卓系统中每种输入设备都对应了一种Mapper,比如</span></span><br><span class="line">            <span class="comment">// SwitchInputMapper, VibratorInputMapper,KeyBoardInputMapper</span></span><br><span class="line">            mapper-&gt;process(rawEvent);           </span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的mMappers成员变量保存了一系列输入设备事件处理对象，例如负责处理键盘事件的KeyboardKeyMapper对象以及负责处理触摸屏事件的TouchInputMapper对象， 它们是在InputReader类的成员函数createDeviceLocked中创建的。这里查询每一个InputMapper对象是否要对当前发生的事件进行处理。由于发生的是键盘事件，真正会对该事件进行处理的只有KeyboardKeyMapper对象。</p><h2 id="Step-5、KeyboardInputMapper-process"><a href="#Step-5、KeyboardInputMapper-process" class="headerlink" title="Step 5、KeyboardInputMapper.process()"></a>Step 5、KeyboardInputMapper.process()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KeyboardInputMapper::process(<span class="keyword">const</span> RawEvent* rawEvent) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (rawEvent-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EV_KEY: &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode = rawEvent-&gt;code;</span><br><span class="line">        <span class="keyword">int32_t</span> usageCode = mCurrentHidUsage;</span><br><span class="line">        mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isKeyboardOrGamepadKey(scanCode)) &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> keyCode;</span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用EventHub中的mapKey函数进行转化</span></span><br><span class="line">            <span class="comment">// 传入参数</span></span><br><span class="line">            <span class="comment">// scanCode：驱动程序上报的扫描码；keyCode：转化之后的Android使用的按键值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123;</span><br><span class="line">                keyCode = AKEYCODE_UNKNOWN;</span><br><span class="line">                flags = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//映射成功之后，处理该按键</span></span><br><span class="line">            processKey(rawEvent-&gt;when, rawEvent-&gt;value != <span class="number">0</span>, keyCode, scanCode, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_MSC: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == MSC_SCAN) &#123;</span><br><span class="line">            mCurrentHidUsage = rawEvent-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> EV_SYN: &#123;</span><br><span class="line">        <span class="keyword">if</span> (rawEvent-&gt;code == SYN_REPORT) &#123;</span><br><span class="line">            mCurrentHidUsage = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先调用isKeyboardOrGamepadKey来判断键盘扫描码是否正确，如果正确则调用processKey来进一步处理</p><h2 id="Step-6、KeyboardInputMapper-processKey"><a href="#Step-6、KeyboardInputMapper-processKey" class="headerlink" title="Step 6、KeyboardInputMapper.processKey()"></a>Step 6、KeyboardInputMapper.processKey()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> KeyboardInputMapper::processKey(<span class="keyword">nsecs_t</span> when, <span class="keyword">bool</span> down, <span class="keyword">int32_t</span> keyCode,</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode, <span class="keyword">uint32_t</span> policyFlags) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据扫描码scanCode、按键码keyCode、newMetaState、downTime按下的时间进行处理    </span></span><br><span class="line">    <span class="comment">// NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,</span><br><span class="line">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span><br><span class="line">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);</span><br><span class="line">     <span class="comment">// 通知Listener处理，Dispatch线程会监听该事件，并处理，下次博文会具体分析</span></span><br><span class="line">    getListener()-&gt;notifyKey(&amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数首先对按键作一些处理，根据扫描码scanCode、按键码keyCode、newMetaState、downTime按下的时间进行处理</p><p>最后函数会调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags,</span><br><span class="line">            down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP,</span><br><span class="line">            AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);</span><br><span class="line"></span><br><span class="line">getListener()-&gt;notifyKey(&amp;args);</span><br></pre></td></tr></table></figure><p>这里getListener是InputReader初始化时传入的对象，即QueuedInputListener，则会调用QueuedInputListener的notifyKey函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line">mArgsQueue.push(<span class="keyword">new</span> NotifyKeyArgs(*args));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InputReader的loopOnce()的结尾会调用QueuedInputListener::flush()统一回调缓冲队列中各元素的notify()接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line"><span class="keyword">size_t</span> count = mArgsQueue.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    NotifyArgs* args = mArgsQueue[i];</span><br><span class="line">    args-&gt;notify(mInnerListener);</span><br><span class="line">    <span class="keyword">delete</span> args;</span><br><span class="line">&#125;</span><br><span class="line">mArgsQueue.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NotifyConfigurationChangedArgs::notify(<span class="keyword">const</span> sp&lt;InputListenerInterface&gt;&amp; listener) <span class="keyword">const</span> &#123;</span><br><span class="line">listener-&gt;notifyConfigurationChanged(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以按键事件为例，由于InputDispatcher 实现了InputListenerInterface接口的notifyConfigurationChanged()函数，所以最后会调用到InputDispatcher的notifyKey()函数中。</p><h2 id="Step-7、-InputDispatcher-notifyKey"><a href="#Step-7、-InputDispatcher-notifyKey" class="headerlink" title="Step 7、 InputDispatcher.notifyKey()"></a>Step 7、 InputDispatcher.notifyKey()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyKey(<span class="keyword">const</span> NotifyKeyArgs* args) &#123;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 构造一个KeyEvent对象</span></span><br><span class="line">KeyEvent event;</span><br><span class="line">event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">        flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">        args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"><span class="comment">// 调用mPolicy的interceptKeyBeforeQueueing函数，该函数最后会调用到java层的PhoneWindowManagerService函数</span></span><br><span class="line">mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> needWake;</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    mLock.lock();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//构造一个KeyEntry对象，调用enqueueInboundEventLocked函数将按键事件加入队列</span></span><br><span class="line">    KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">            args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">            args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">            metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">    needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">    mLock.unlock();</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先调用validateKeyEvent来判断是否是有效按键事件，实际判断是否是UP/DOWN事件</p><p>然后构造一个KeyEvent对象，调用mPolicy的interceptKeyBeforeQueueing函数，该函数最后会调用到java层的PhoneWindowManagerService函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeyEvent event;</span><br><span class="line">    event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action,</span><br><span class="line">            flags, keyCode, args-&gt;scanCode, metaState, <span class="number">0</span>,</span><br><span class="line">            args-&gt;downTime, args-&gt;eventTime);</span><br><span class="line"></span><br><span class="line">    mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, <span class="comment">/*byref*/</span> policyFlags);</span><br></pre></td></tr></table></figure><p>之后会调用构造一个KeyEntry对象，调用enqueueInboundEventLocked函数将按键事件加入队列，如果返回true，则调用mLooper.wake函数唤醒等待的InputDispatcher，进行按键分发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KeyEntry* newEntry = <span class="keyword">new</span> KeyEntry(args-&gt;eventTime,</span><br><span class="line">                args-&gt;deviceId, args-&gt;source, policyFlags,</span><br><span class="line">                args-&gt;action, flags, keyCode, args-&gt;scanCode,</span><br><span class="line">                metaState, repeatCount, args-&gt;downTime);</span><br><span class="line"></span><br><span class="line">needWake = enqueueInboundEventLocked(newEntry);</span><br></pre></td></tr></table></figure><h2 id="Step-8、InputDispatcher-enqueueInboundEventLocked"><a href="#Step-8、InputDispatcher-enqueueInboundEventLocked" class="headerlink" title="Step 8、InputDispatcher.enqueueInboundEventLocked()"></a>Step 8、InputDispatcher.enqueueInboundEventLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123;</span><br><span class="line">    <span class="keyword">bool</span> needWake = mInboundQueue.isEmpty();</span><br><span class="line">    mInboundQueue.enqueueAtTail(entry);</span><br><span class="line">    traceInboundQueueLengthLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (entry-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(entry);</span><br><span class="line">        <span class="keyword">if</span> (isAppSwitchKeyEventLocked(keyEntry)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123;</span><br><span class="line">                mAppSwitchSawKeyDown = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAppSwitchSawKeyDown) &#123;</span><br><span class="line">                    mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT;</span><br><span class="line">                    mAppSwitchSawKeyDown = <span class="literal">false</span>;</span><br><span class="line">                    needWake = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> needWake;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将EventEntry加入到mInboundQueue中，该函数两种情况下会返回true,一是当加入该键盘事件到mInboundQueue之前，mInboundQueue为空，这表示InputDispatc herThread线程正在睡眠等待InputReaderThread线程的唤醒，因此，它返回true表示要唤醒InputDispatccherThread线程；二是加入该键盘事件到mInboundQueue之前，mInboundQueue不为空，但是此时用户按下的是Home键等需要切换APP的按键，我们知道，在切换App时，新的App会把它的键盘消息接收通道注册到InputDispatcher中去，并且会等待InputReader的唤醒，因此，在这种情况下，也需要返回true，表示要唤醒InputDispatccherThread线程。如果不是这两种情况，那么就说明InputDispatccherThread线程现在正在处理前面的键盘事件，不需要唤醒它。</p><p>至此，InputDispatcherThread被唤醒，开始进行按键分发。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>InputReaderThread不断调用InputReader的pollOnce()-&gt;getEvents()函数来得到事件，这些事件可以是输入事件，也可以是由inotify监测到设备增减变更所触发的事件。第一次进入时会扫描/dev/input目录建立设备列表，存在mDevice成员变量中(EventHub中有设备列表KeyedVector</p><p><int32_t, device*=""> mDevices；对应的，InputReader中也有设备列表KeyedVector<int32_t, inputdevice*=""> mDevices。这里先添加到前者，然后会在InputReader::addDeviceLocked()中添加到后者。)，同时将增加的fd加到epoll的等待集合中。在接下来的epoll_wait()等待时，如果有事件就会返回，同时返回可读事件数量。在这里，从Input driver读出的事件从原始的input_event结构转为RawEvent结构，放到getEvents()的输出参数buffer中。getEvents()返回后，InputReader调用processEventsLocked()处理事件，对于设备改变，会根据实际情况调用addDeviceLocked(), removeDeviceLocked()和handleConfigurationChangedLocked()。对于其它设备中来的输入事件，会调用processEventsForDeviceLocked()进一步处理。其中会根据当时注册的InputMapper对事件进行处理，然后将事件处理请求放入缓冲队列（QueuedInputListener中的mArgsQueue）。</int32_t,></int32_t,></p><p>InputMapper是做什么的呢，它是用于解析原始输入事件的。比如back, home等VirtualKey，传上来时是个Touch事件，这里要根据坐标转化为相应的按键事件。再比如多点触摸时，需要计算每个触摸点分别属于哪条轨迹，这本质上是个二分图匹配问题，这也是在InputMapper中完成的。回到流程主线上，在InputReader的loopOnce()的结尾会调用QueuedInputListener::flush()统一回调缓冲队列中各元素的notify()接口。</p><p>以按键事件为例，最后会调用到InputDispatcher的notifyKey()函数中。这里先将参数封装成KeyEvent： 然后把它作为参数调用NativeInputManager的interceptKeyBeforeQueueing()函数。顾名思义，就是在放到待处理队列前看看是不是需要系统处理的系统按键，它会通过JNI调回Java世界，最终调到PhoneWindowManager的interceptKeyBeforeQueueing()。然后，基于输入事件信息创建KeyEntry对象，调用enqueueInboundEventLocked()将之放入队列等待InputDiaptcherThread线程拿出处理。</p><h2 id="六、Input-Dispatcher"><a href="#六、Input-Dispatcher" class="headerlink" title="六、Input Dispatcher"></a>六、Input Dispatcher</h2><p>InputDisptacher的主要任务是把前面收到的输入事件发送到PWM及App端的焦点窗口。前面提到InputReaderThread中收到事件后会调用notifyKey()来通知InputDispatcher，也就是放在mInboundQueue中，在InputDispatcher的dispatchOnce()函数中，会从这个队列拿出处理。</p><p>其中dispatchOnceInnerLocked()会根据拿出的EventEntry类型调用相应的处理函数，以Key事件为例会调用dispatchKeyLocked()</p><p>它会找到目标窗口，然后通过之前和App间建立的连接发送事件。如果是个需要系统处理的Key事件，这里会封装成CommandEntry插入到mCommandQueue队列中，后面的runCommandLockedInterruptible()函数中会调用doInterceptKeyBeforeDispatchingLockedInterruptible()来让PWM有机会进行处理。最后dispatchOnce()调用pollOnce()从和App的连接上接收处理完成消息。那么，InputDispatcher是怎么确定要往哪个窗口中发事件呢？这里的成员变量mFocusedWindowHandle指示了焦点窗口，然后findFocusedWindowTargetsLocked()会调用一系列函数（handleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()等）检查mFocusedWindowHandle是否能接收输入事件。如果可以，将之以InputTarget的形式加到目标窗口数组中。然后就会调用dispatchEventLocked()进行发送。那么，这个mFocusedWindowHandle是如何维护的呢？为了更好地理解，这里回头分析下窗口连接的管理及焦点窗口的管理。 总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N19-Android-Input-System-InputDispatcher-structure.png" alt="Markdown"></p><p>再贴一张详细的总体流程图，然后根据步骤详细分析；</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N20-Android-Input-System-input-dispatcher-thread.png" alt="Markdown"></p><h2 id="Step-1、InputDispatcher-dispatchOnce"><a href="#Step-1、InputDispatcher-dispatchOnce" class="headerlink" title="Step 1、InputDispatcher.dispatchOnce()"></a>Step 1、InputDispatcher.dispatchOnce()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnce() &#123;</span><br><span class="line"><span class="keyword">nsecs_t</span> nextWakeupTime = LONG_LONG_MAX;</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    mDispatcherIsAliveCondition.broadcast();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run a dispatch loop if there are no pending commands.</span></span><br><span class="line">    <span class="comment">// The dispatch loop might enqueue commands to run afterwards.</span></span><br><span class="line">    <span class="keyword">if</span> (!haveCommandsLocked()) &#123;</span><br><span class="line">        dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run all pending commands if there are any.</span></span><br><span class="line">    <span class="comment">// If any commands were run then force the next poll to wake up immediately.</span></span><br><span class="line">    <span class="keyword">if</span> (runCommandsLockedInterruptible()) &#123;</span><br><span class="line">        nextWakeupTime = LONG_LONG_MIN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait for callback or timeout or wake.  (make sure we round up, not down)</span></span><br><span class="line"><span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line"><span class="keyword">int</span> timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);</span><br><span class="line">mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数主要是调用dispatchOnceInnerLocked来进行一次按键分发，当没有按键消息时会走到mLooper-&gt;pollOnce(timeoutMillis);这个函数会进入睡眠状态，当有按键消息发生时该函数会返回，然后走到dispatchOnceInnerLocked函数。</p><h2 id="Step-2、InputDispatcher-dispatchOnceInnerLocked"><a href="#Step-2、InputDispatcher-dispatchOnceInnerLocked" class="headerlink" title="Step 2、InputDispatcher.dispatchOnceInnerLocked()"></a>Step 2、InputDispatcher.dispatchOnceInnerLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchOnceInnerLocked(<span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> currentTime = now();</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Ready to start a new event.</span></span><br><span class="line">    <span class="comment">// If we don't already have a pending event, go grab one.</span></span><br><span class="line">    <span class="keyword">if</span> (! mPendingEvent) &#123;</span><br><span class="line">        <span class="comment">//当InputReader往队列中插入了一个读取的键盘消息后，此处的mInboundQueue就不为空</span></span><br><span class="line">        <span class="keyword">if</span> (mInboundQueue.isEmpty()) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inbound queue has at least one entry.</span></span><br><span class="line">            mPendingEvent = mInboundQueue.dequeueAtHead();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (mPendingEvent-&gt;type) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line"></span><br><span class="line">        KeyEntry* typedEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(mPendingEvent);</span><br><span class="line">        ...</span><br><span class="line">        done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (done) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dropReason != DROP_REASON_NOT_DROPPED) &#123;</span><br><span class="line">            dropInboundEventLocked(mPendingEvent, dropReason);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastDropReason = dropReason;</span><br><span class="line"></span><br><span class="line">        releasePendingEventLocked();</span><br><span class="line">        *nextWakeupTime = LONG_LONG_MIN;  <span class="comment">// force next poll to wake up immediately</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前文InputReader读取键盘消息过程分析 InputReader读取到一个消息后会调用KeyboardInputMapper的processKey，该函数会调用InputDispatcher的notifyKey函数，然后InputDispatcher会调用enqueueInboundEventLocked函数，将EventEntry加入到mInboundQueue中，然后调用mLooper-&gt;wake函数会唤醒InputDispatcherThread线程，InputDispatcher中把队列的第一个事件取出来，因为这里是键盘事件，所以mPendingEvent-&gt;type是EventEntry::TYPE_KEY，然后调用dispatchKeyLocked函数</p><p>惯例先贴出序列图，按步骤一步步介绍。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N21-Android-Input-System-dispatch-input-event.png" alt="Markdown"></p><h2 id="Step-3、InputDispatcher-dispatchKeyLocked"><a href="#Step-3、InputDispatcher-dispatchKeyLocked" class="headerlink" title="Step 3、InputDispatcher.dispatchKeyLocked()"></a>Step 3、InputDispatcher.dispatchKeyLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> InputDispatcher::dispatchKeyLocked(<span class="keyword">nsecs_t</span> currentTime, KeyEntry* entry,</span><br><span class="line">        DropReason* dropReason, <span class="keyword">nsecs_t</span>* nextWakeupTime) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Give the policy a chance to intercept the key.</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123;</span><br><span class="line">            CommandEntry* commandEntry = postCommandLocked(</span><br><span class="line">                    &amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible);</span><br><span class="line">            <span class="keyword">if</span> (mFocusedWindowHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                commandEntry-&gt;inputWindowHandle = mFocusedWindowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line">    <span class="comment">// Identify targets.</span></span><br><span class="line">    Vector&lt;InputTarget&gt; inputTargets;</span><br><span class="line">    <span class="keyword">int32_t</span> injectionResult = findFocusedWindowTargetsLocked(currentTime,</span><br><span class="line">            entry, inputTargets, nextWakeupTime);</span><br><span class="line">    ......</span><br><span class="line">    setInjectionResultLocked(entry, injectionResult);</span><br><span class="line">    ......</span><br><span class="line">    addMonitoringTargetsLocked(inputTargets);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispatch the key.</span></span><br><span class="line">    dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要做了下面三件事 A. 如果按键是第一次分发，则将命令封装为CommandEntry加入队列，后续执行doInterceptKeyBeforeDispatchingLockedInterruptible，以给java层拦截按键的机会 B. 找到当前激活的Window窗口，并将其加入到Vector中，Android ANR就是在findFocusedWindowTargetsLocked()检测的 C. 找到需要主动监听按键的InputChannel,封装成InputTarget，加入到Vector中 D. 将按键分发到上面的Vector中的InputChannel中，这里存在多个</p><p>下面先分析如果将按键分发给InputChannel</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::dispatchEventLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">    EventEntry* eventEntry, <span class="keyword">const</span> Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputTargets.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> InputTarget&amp; inputTarget = inputTargets.itemAt(i);</span><br><span class="line">    <span class="keyword">ssize_t</span> connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel);</span><br><span class="line">    <span class="keyword">if</span> (connectionIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex);</span><br><span class="line">        prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget);</span><br><span class="line">      &#125; ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-5、InputDispatcher-prepareDispatchCycleLocked"><a href="#Step-5、InputDispatcher-prepareDispatchCycleLocked" class="headerlink" title="Step 5、InputDispatcher.prepareDispatchCycleLocked()"></a>Step 5、InputDispatcher.prepareDispatchCycleLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::prepareDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Not splitting.  Enqueue dispatch entries for the event as is.</span></span><br><span class="line">    enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数前面还有一些状态检查，这里默认都是通过的。最后enqueueDispatchEntriesLocked函数进行将connection分装成DispatchEntry，加入到connection-&gt;outboundQueue的队列中</p><h2 id="Step-6-InputDispatcher-enqueueDispatchEntriesLocked"><a href="#Step-6-InputDispatcher-enqueueDispatchEntriesLocked" class="headerlink" title="Step 6. InputDispatcher::enqueueDispatchEntriesLocked()"></a>Step 6. InputDispatcher::enqueueDispatchEntriesLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::enqueueDispatchEntriesLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, <span class="keyword">const</span> InputTarget* inputTarget) &#123;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = connection-&gt;outboundQueue.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue dispatch entries for the requested modes.</span></span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT);</span><br><span class="line">    ......</span><br><span class="line">    enqueueDispatchEntryLocked(connection, eventEntry, inputTarget,</span><br><span class="line">            InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the outbound queue was previously empty, start the dispatch cycle going.</span></span><br><span class="line">    <span class="keyword">if</span> (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        startDispatchCycleLocked(currentTime, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数首先获取以前的connection的outboundQueue是否为空，然后将该事件调用enqueueDispatchEntryLocked将事件加入到outboundQueue中，如果以前为空，现在不为空，则调用startDispatchCycleLocked开始分发，如果以前的outboundQueue不为空，说明当前的Activity正在处理前面的按键，则不需要再调用startDispatchCycleLocked，因为只要开始处理，会等到队列为空才会停止。</p><h2 id="Step-7、InputDispatcher-startDispatchCycleLocked"><a href="#Step-7、InputDispatcher-startDispatchCycleLocked" class="headerlink" title="Step 7、InputDispatcher.startDispatchCycleLocked()"></a>Step 7、InputDispatcher.startDispatchCycleLocked()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::startDispatchCycleLocked(<span class="keyword">nsecs_t</span> currentTime,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Connection&gt;&amp; connection) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (connection-&gt;status == Connection::STATUS_NORMAL</span><br><span class="line">            &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123;</span><br><span class="line">        DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head;</span><br><span class="line">        dispatchEntry-&gt;deliveryTime = currentTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Publish the event.</span></span><br><span class="line">        <span class="keyword">status_t</span> status;</span><br><span class="line">        EventEntry* eventEntry = dispatchEntry-&gt;eventEntry;</span><br><span class="line">        <span class="keyword">switch</span> (eventEntry-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> EventEntry::TYPE_KEY: &#123;</span><br><span class="line">            KeyEntry* keyEntry = <span class="keyword">static_cast</span>&lt;KeyEntry*&gt;(eventEntry);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Publish the key event.</span></span><br><span class="line">            status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq,</span><br><span class="line">                    keyEntry-&gt;deviceId, keyEntry-&gt;source,</span><br><span class="line">                    dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags,</span><br><span class="line">                    keyEntry-&gt;keyCode, keyEntry-&gt;scanCode,</span><br><span class="line">                    keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime,</span><br><span class="line">                    keyEntry-&gt;eventTime);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Re-enqueue the event on the wait queue.</span></span><br><span class="line">        connection-&gt;outboundQueue.dequeue(dispatchEntry);</span><br><span class="line">        traceOutboundQueueLengthLocked(connection);</span><br><span class="line">        connection-&gt;waitQueue.enqueueAtTail(dispatchEntry);</span><br><span class="line">        traceWaitQueueLengthLocked(connection);</span><br><span class="line">        &#125;<span class="comment">//end of while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数从outboundQueue中取出需要处理的键盘事件，交给connection的inputPublisher去分发，之后将事件加入到connection的waitQueue中。分发事件是通过InputPublisher的publishKeyEvent来完成的。</p><h2 id="Step-8、InputPublisher-publishKeyEvent"><a href="#Step-8、InputPublisher-publishKeyEvent" class="headerlink" title="Step 8、InputPublisher.publishKeyEvent"></a>Step 8、InputPublisher.publishKeyEvent</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputPublisher::publishKeyEvent(</span><br><span class="line">        <span class="keyword">uint32_t</span> seq,<span class="keyword">int32_t</span> deviceId,<span class="keyword">int32_t</span> source,</span><br><span class="line">        <span class="keyword">int32_t</span> action,<span class="keyword">int32_t</span> flags,<span class="keyword">int32_t</span> keyCode,</span><br><span class="line">        <span class="keyword">int32_t</span> scanCode,<span class="keyword">int32_t</span> metaState,<span class="keyword">int32_t</span> repeatCount,</span><br><span class="line">        <span class="keyword">nsecs_t</span> downTime,<span class="keyword">nsecs_t</span> eventTime) &#123;</span><br><span class="line"></span><br><span class="line">    InputMessage msg;</span><br><span class="line">    msg.header.type = InputMessage::TYPE_KEY;</span><br><span class="line">    ......</span><br><span class="line">    msg.body.key.eventTime = eventTime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是将各个参数封装到InputMessage中，然后交给mChannel对象去分发 mChannel其实是socketpair的server端，其实就是创建的服务器InputChannel，其创建过程稍后详细分析。</p><h2 id="Step-9、InputChannel-sendMessage"><a href="#Step-9、InputChannel-sendMessage" class="headerlink" title="Step 9、InputChannel.sendMessage()"></a>Step 9、InputChannel.sendMessage()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::sendMessage(<span class="keyword">const</span> InputMessage* msg) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> msgLength = msg-&gt;size();</span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nWrite == <span class="number">-1</span> &amp;&amp; errno == EINTR);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是通过send函数往socketpair的server端写入InputMessage对象，应用程序这一侧正睡眠在client端的fd上，此时client端就会收到该InputMessage，client会进行按键按键分发，应用程序这一侧的按键分发请看下一节。</p><h2 id="七、App注册消息监听过程分析"><a href="#七、App注册消息监听过程分析" class="headerlink" title="七、App注册消息监听过程分析"></a>七、App注册消息监听过程分析</h2><p>总体流程图 InputDispatcher会找到目标窗口，然后通过之前和App间建立的连接发送事件。如果是个需要系统处理的Key事件，这里会封装成CommandEntry插入到mCommandQueue队列中，后面的runCommandLockedInterruptible()函数中会调用doInterceptKeyBeforeDispatchingLockedInterruptible()来让PWM有机会进行处理。最后dispatchOnce()调用pollOnce()从和App的连接上接收处理完成消息。那么，InputDispatcher是怎么确定要往哪个窗口中发事件呢？这里的成员变量mFocusedWindowHandle指示了焦点窗口，然后findFocusedWindowTargetsLocked()会调用一系列函数（handleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()等）检查mFocusedWindowHandle是否能接收输入事件。如果可以，将之以InputTarget的形式加到目标窗口数组中。然后就会调用dispatchEventLocked()进行发送。那么，这个mFocusedWindowHandle是如何维护的呢？为了更好地理解，这里回头分析下窗口连接的管理及焦点窗口的管理。 在App端，新的顶层窗口需要被注册到WMS中，这是在ViewRootImpl::setView()中做的。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N22-Android-Input-System-inputchannel.png" alt="Markdown"></p><h2 id="Step-1、ViewRootImpl-setView"><a href="#Step-1、ViewRootImpl-setView" class="headerlink" title="Step 1、ViewRootImpl.setView()"></a>Step 1、ViewRootImpl.setView()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用requestLayout来通知InputManagerService当前的窗口是激活的窗口</span></span><br><span class="line">    requestLayout();</span><br><span class="line">    <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该窗口没有指定INPUT_FEATURE_NO_INPUT_CHANNEL属性，则创建消息接收通道InputChannel</span></span><br><span class="line">        mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过binder调用，调用server端的Session对象来跟WindowManagerService通信，该函数最后会调      </span></span><br><span class="line">        <span class="comment">// 用到WindowManagerService的addWindow函数，函数中会创建一对InputChannel(server/client)，</span></span><br><span class="line">        <span class="comment">// 这样在函数调用结束后，mInputChannel就变成了client端的对象。在</span></span><br><span class="line">        <span class="comment">// frameworks/base/core/java/android/view/IWindowSession.aidl的</span></span><br><span class="line">        <span class="comment">// addToDisplay函数的声明中，InputChannel指定的数据流的流向是out，因此</span></span><br><span class="line">        <span class="comment">// WindowManagerService修改了mInputChannel,客户端就能拿到这个对象的数据了。</span></span><br><span class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">             getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">             mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">            mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">            <span class="comment">// 初始化WindowInputEventReceiver，按键消息会从native层传到该对象的onInputEvent函数</span></span><br><span class="line">            <span class="comment">// 中，onInputEvent函数是按键在应用端java层分发的起始端。</span></span><br><span class="line">            mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                    Looper.myLooper());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数与注册键盘消息通道的相关主要有三个功能： 一是调用requestLayout函数来通知InputManagerService，这个Activity窗口是当前被激活的窗口,同时将所有的窗口注册到InputDispatcher中 二是调用mWindowSession的add成员函数来把键盘消息接收通道的server端注册端注册到CPP层的InputManagerService中，client端注册到本应用程序的消息循环Looper中，这样当InputManagerService监控到有键盘消息的时候，就会找到当前被激活的窗口，然后找到其在InputManagerService中对应的键盘消息接收通道(InputChannel)，通过这个通道在InputManagerService的server端来通知应用程序消息循环的client端，这样就把键盘消息分发给当前激活的Activity窗口了 三是应用程序这一侧注册消息接收通道</p><h2 id="Step-2、ViewRootImpl-requestLayout"><a href="#Step-2、ViewRootImpl-requestLayout" class="headerlink" title="Step 2、ViewRootImpl.requestLayout()"></a>Step 2、ViewRootImpl.requestLayout()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了scheduleTraversals函数来做进一步的操作，该函数调用mChoreographer来post一个Runnable到Looper中，之后Vsycn信号到来会执行mTraversalRunnable中的run方法，即调用doTraversal函数</p><p>参考文档：<strong>【Android 7.1.2(Android N) Activity-Window加载显示流程】</strong></p><h2 id="Step-3、ViewRootImpl-doTraversal"><a href="#Step-3、ViewRootImpl-doTraversal" class="headerlink" title="Step 3、ViewRootImpl.doTraversal()"></a>Step 3、ViewRootImpl.doTraversal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        performTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要是执行performTraversals()函数，进而调用relayoutWindow函数，在该函数中又会调用mWindowSession的relayout进入到java层的WindowManagerService的relayoutWindow函数，该函数会调用mInputMonitor.updateInputWindowsLw(true /force/);mInputMonitor是InputMonitor对象。</p><h2 id="Step-4、InputMonitor-updateInputWindowsLw"><a href="#Step-4、InputMonitor-updateInputWindowsLw" class="headerlink" title="Step 4、InputMonitor.updateInputWindowsLw()"></a>Step 4、InputMonitor.updateInputWindowsLw()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateInputWindowsLw</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> addInputConsumerHandle = mService.mInputConsumer != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add all windows on the default display.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> numDisplays = mService.mDisplayContents.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = <span class="number">0</span>; displayNdx &lt; numDisplays; ++displayNdx) &#123;</span><br><span class="line">    WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> winNdx = windows.size() - <span class="number">1</span>; winNdx &gt;= <span class="number">0</span>; --winNdx) &#123;</span><br><span class="line">        <span class="keyword">final</span> WindowState child = windows.get(winNdx);</span><br><span class="line">        <span class="keyword">final</span> InputChannel inputChannel = child.mInputChannel;</span><br><span class="line">        <span class="keyword">final</span> InputWindowHandle inputWindowHandle = child.mInputWindowHandle;</span><br><span class="line">        ......</span><br><span class="line">        addInputWindowHandleLw(inputWindowHandle, child, flags, type, isVisible, hasFocus,</span><br><span class="line">                hasWallpaper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Send windows to native code.</span></span><br><span class="line">mService.mInputManager.setInputWindows(mInputWindowHandles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数将当前系统中带有InputChannel的Activity窗口都设置为InputManagerService的输入窗口，但是后面我们会看到，只有当前激活的窗口才会响应键盘消息。</p><h2 id="Step-5、InputManagerService-setInputWindows"><a href="#Step-5、InputManagerService-setInputWindows" class="headerlink" title="Step 5、InputManagerService.setInputWindows()"></a>Step 5、InputManagerService.setInputWindows()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInputWindows</span><span class="params">(InputWindowHandle[] windowHandles)</span> </span>&#123;</span><br><span class="line">    nativeSetInputWindows(mPtr, windowHandles);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数调用了本地方法nativeSetInputWindows来进一步执行操作,mPtr是native层NativeInputManager实例，在调用InputManagerService.nativeInit函数时会在native层构造NativeInputManager对象并将其保存在mPtr中。nativeSetInputWindows会调用NativeInputManager的setInputWindows函数</p><h2 id="Step-6、NativeInputManager-setInputWindows"><a href="#Step-6、NativeInputManager-setInputWindows" class="headerlink" title="Step 6、NativeInputManager.setInputWindows()"></a>Step 6、NativeInputManager.setInputWindows()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray) &#123;</span><br><span class="line">    Vector&lt;sp&lt;InputWindowHandle&gt; &gt; windowHandles;</span><br><span class="line">    <span class="keyword">if</span> (windowHandleObjArray) &#123;</span><br><span class="line">        jsize length = env-&gt;GetArrayLength(windowHandleObjArray);</span><br><span class="line">        <span class="keyword">for</span> (jsize i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            jobject windowHandleObj = env-&gt;GetObjectArrayElement(windowHandleObjArray, i);</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;InputWindowHandle&gt; windowHandle =</span><br><span class="line">                    android_server_InputWindowHandle_getHandle(env, windowHandleObj);</span><br><span class="line">            <span class="keyword">if</span> (windowHandle != NULL) &#123;</span><br><span class="line">                windowHandles.push(windowHandle);</span><br><span class="line">            &#125;</span><br><span class="line">            env-&gt;DeleteLocalRef(windowHandleObj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windowHandles);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do this after the dispatcher has updated the window handle state.</span></span><br><span class="line">    bool newPointerGesturesEnabled = <span class="keyword">true</span>;</span><br><span class="line">    size_t numWindows = windowHandles.size();</span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; numWindows; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = windowHandles.itemAt(i);</span><br><span class="line">        <span class="keyword">const</span> InputWindowInfo* windowInfo = windowHandle-&gt;getInfo();</span><br><span class="line">        <span class="keyword">if</span> (windowInfo &amp;&amp; windowInfo-&gt;hasFocus &amp;&amp; (windowInfo-&gt;inputFeatures</span><br><span class="line">                &amp; InputWindowInfo::INPUT_FEATURE_DISABLE_TOUCH_PAD_GESTURES)) &#123;</span><br><span class="line">            newPointerGesturesEnabled = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>这个函数首先将Java层的InputWindowHandle转换成C++层的NativeInputWindowHandle，然后放在windowHandles向量中，最后将这些输入窗口设置到InputDispatcher中去。</p><h2 id="Step-7、InputDispatcher-setInputWindows"><a href="#Step-7、InputDispatcher-setInputWindows" class="headerlink" title="Step 7、InputDispatcher.setInputWindows()"></a>Step 7、InputDispatcher.setInputWindows()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputDispatcher::setInputWindows(<span class="keyword">const</span> Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles;</span><br><span class="line">        mWindowHandles = inputWindowHandles;</span><br><span class="line"></span><br><span class="line">        sp&lt;InputWindowHandle&gt; newFocusedWindowHandle;</span><br><span class="line">        <span class="keyword">bool</span> foundHoveredWindow = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mWindowHandles.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mWindowHandles.removeAt(i--);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123;</span><br><span class="line">                newFocusedWindowHandle = windowHandle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFocusedWindowHandle != newFocusedWindowHandle) &#123;</span><br><span class="line">            mFocusedWindowHandle = newFocusedWindowHandle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake up poll loop since it may need to make new input dispatching choices.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里InputDispatcher的成员变量mFocusedWindowHandle 就代表当前激活的窗口的。这个函数遍历inputWindowHandles，获取获得焦点的窗口，并赋值给mFocusedWindowHandle 这样，InputManagerService就把当前激活的窗口保存在InputDispatcher中了，后面就可以把键盘消息分发给它来处理。</p><h2 id="Step-8、mWindowSession-addToDisplay"><a href="#Step-8、mWindowSession-addToDisplay" class="headerlink" title="Step 8、mWindowSession.addToDisplay()"></a>Step 8、mWindowSession.addToDisplay()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">            &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">        mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">             getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">             mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">             mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里会调用到WindowManagerService的addWindow接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> openInputChannels = (outInputChannel != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">            win.openInputChannel(outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接着会调用WindowState的 openInputChannel()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/services/core/java/com/android/server/wm/WindowState.java</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">openInputChannel</span><span class="params">(InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name = makeInputChannelName();</span><br><span class="line">    InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">    mInputChannel = inputChannels[<span class="number">0</span>];</span><br><span class="line">    mClientChannel = inputChannels[<span class="number">1</span>];</span><br><span class="line">    mInputWindowHandle.inputChannel = inputChannels[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (outInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mClientChannel.transferTo(outInputChannel);</span><br><span class="line">        mClientChannel.dispose();</span><br><span class="line">        mClientChannel = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If the window died visible, we setup a dummy input channel, so that taps</span></span><br><span class="line">        <span class="comment">// can still detected by input monitor channel, and we can relaunch the app.</span></span><br><span class="line">        <span class="comment">// Create dummy event receiver that simply reports all events as handled.</span></span><br><span class="line">        mDeadWindowEventReceiver = <span class="keyword">new</span> DeadWindowEventReceiver(mClientChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的outInputChannel即为前面创建的InputChannel，它不为NULL，因此，这里会通过InputChannel.openInputChannelPair函数来创建一对输入通道，其中一个位于WindowManagerService中，另外一个通过outInputChannel参数返回到应用程序中。</p><p>WindowManagerService会为每个窗口创建一个WindowState对象，然后将该InputChannel对的service端保存到WindowState中</p><h2 id="Step-10、InputChannel-openInputChannelPair"><a href="#Step-10、InputChannel-openInputChannelPair" class="headerlink" title="Step 10、InputChannel.openInputChannelPair()"></a>Step 10、InputChannel.openInputChannelPair()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/InputChannel.java]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> InputChannel[] openInputChannelPair(String name) &#123;</span><br><span class="line">    <span class="keyword">return</span> nativeOpenInputChannelPair(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了nativeOpenInputChannelPair函数，在native创建一个InputChannel对</p><h2 id="Step-11、InputChannel-nativeOpenInputChannelPair"><a href="#Step-11、InputChannel-nativeOpenInputChannelPair" class="headerlink" title="Step 11、InputChannel.nativeOpenInputChannelPair()"></a>Step 11、InputChannel.nativeOpenInputChannelPair()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputChannel.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jobjectArray <span class="title">android_view_InputChannel_nativeOpenInputChannelPair</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">        jclass clazz, jstring nameObj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* nameChars = env-&gt;GetStringUTFChars(nameObj, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="function">String8 <span class="title">name</span><span class="params">(nameChars)</span></span>;</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(nameObj, nameChars);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputChannel&gt; serverChannel;</span><br><span class="line">    sp&lt;InputChannel&gt; clientChannel;</span><br><span class="line">    <span class="keyword">status_t</span> result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> channelPair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nativeOpenInputChannelPair函数调用InputChannel的openInputChannelPair函数创建一对InputChannel,该对象是Native层的InputChannel,跟java层是一一对应的。</p><h2 id="Step-12、InputChannel-openInputChannelPair"><a href="#Step-12、InputChannel-openInputChannelPair" class="headerlink" title="Step 12、InputChannel.openInputChannelPair()"></a>Step 12、InputChannel.openInputChannelPair()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputChannel::openInputChannelPair(<span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockets[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_SEQPACKET, <span class="number">0</span>, sockets)) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> result = -errno;</span><br><span class="line">        ALOGE(<span class="string">"channel '%s' ~ Could not create socket pair.  errno=%d"</span>,</span><br><span class="line">                name.<span class="built_in">string</span>(), errno);</span><br><span class="line">        outServerChannel.clear();</span><br><span class="line">        outClientChannel.clear();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> bufferSize = SOCKET_BUFFER_SIZE;</span><br><span class="line">    <span class="comment">//设置server端和client端的接收缓冲区和发送缓冲区</span></span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">0</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line">    setsockopt(sockets[<span class="number">1</span>], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, <span class="keyword">sizeof</span>(bufferSize));</span><br><span class="line"></span><br><span class="line">    String8 serverChannelName = name;</span><br><span class="line">    serverChannelName.append(<span class="string">" (server)"</span>);</span><br><span class="line">    outServerChannel = <span class="keyword">new</span> InputChannel(serverChannelName, sockets[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    String8 clientChannelName = name;</span><br><span class="line">    clientChannelName.append(<span class="string">" (client)"</span>);</span><br><span class="line">    outClientChannel = <span class="keyword">new</span> InputChannel(clientChannelName, sockets[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了socketpair系统调用创建了一对已经连接的UNIX租socket,这里可以把这一对socket当成pipe返回的文件描述符一样使用，pipe返回的管道是单向管道，即只能从一端写入，一端读出，但是socketpair是创建的管道是全双工的，可读可写。</p><p>创建好了server端和client端socketpair通道后，在WindowState.openInputChannel()方法中，一方面它把刚才创建的Client端的输入通道通过outInputChannel参数返回到应用程序中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inputChannels[<span class="number">1</span>].transferTo(outInputChannel);</span><br></pre></td></tr></table></figure><p>WindowSession.addToDisplay()通过Binder通信与WMS通信。IWindowSession.java为编译Android 7.1.2源码得到。 在此看一下通信详细过程,可以看到outInputChannel通过_arg8.writeToParcel()写入，然后通过跨进程方式传输，App端就可以得到Client端的InputChannel 了。 [-&gt;IWindowSession.java$ Stub]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">case</span> TRANSACTION_addToDisplay:</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">android.view.InputChannel _arg8;</span><br><span class="line">_arg8 = <span class="keyword">new</span> android.view.InputChannel();</span><br><span class="line"><span class="keyword">int</span> _result = <span class="keyword">this</span>.addToDisplay(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8);</span><br><span class="line">reply.writeNoException();</span><br><span class="line">reply.writeInt(_result);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((_arg8!=null)) &#123;</span><br><span class="line">reply.writeInt(<span class="number">1</span>);</span><br><span class="line">_arg8.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;IWindowSession.java$ Proxy]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//android/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/view/IWindowSession.java</span></span><br><span class="line"></span><br><span class="line">@Override public int addToDisplay(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int viewVisibility, int layerStackId, android.graphics.Rect outContentInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.view.InputChannel outInputChannel) throws android.os.RemoteException</span><br><span class="line">&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">......</span><br><span class="line">mRemote.transact(Stub.TRANSACTION_addToDisplay, _data, _reply, <span class="number">0</span>);</span><br><span class="line">_result = _reply.readInt();</span><br><span class="line">....</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">0</span>!=_reply.readInt())) &#123;</span><br><span class="line">outInputChannel.readFromParcel(_reply);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外还需要把server端的InputChannel注册到InputManagerService中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle);</span><br></pre></td></tr></table></figure><h2 id="Step-13、InputManagerService-registerInputChannel"><a href="#Step-13、InputManagerService-registerInputChannel" class="headerlink" title="Step 13、InputManagerService.registerInputChannel()"></a>Step 13、InputManagerService.registerInputChannel()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerInputChannel</span><span class="params">(InputChannel inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputWindowHandle inputWindowHandle)</span> </span>&#123;</span><br><span class="line">    nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过调用nativeRegisterInputChannel来将InputChannel注册到native层</p><h2 id="Step-14、InputManagerService-nativeRegisterInputChannel"><a href="#Step-14、InputManagerService-nativeRegisterInputChannel" class="headerlink" title="Step 14、InputManagerService.nativeRegisterInputChannel()"></a>Step 14、InputManagerService.nativeRegisterInputChannel()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeRegisterInputChannel</span><span class="params">(JNIEnv* env, jclass <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor)</span> </span>&#123;</span><br><span class="line">    NativeInputManager* im = <span class="keyword">reinterpret_cast</span>&lt;NativeInputManager*&gt;(ptr);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj);</span><br><span class="line"></span><br><span class="line">    sp&lt;InputWindowHandle&gt; inputWindowHandle =</span><br><span class="line">            android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> status = im-&gt;registerInputChannel(</span><br><span class="line">            env, inputChannel, inputWindowHandle, monitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据java层的InputWindowHandle获得native层的InputWindowHandle对象，根据java层的InputChannel获得native层的InputChannel对象，然后调用NativeInputManager的resgiterInputChannel，该函数又调用了InputDispatcher的registerInputChannel</p><h2 id="Step-15、InputDispatcher-registerInputChannel"><a href="#Step-15、InputDispatcher-registerInputChannel" class="headerlink" title="Step 15、InputDispatcher.registerInputChannel()"></a>Step 15、InputDispatcher.registerInputChannel()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputDispatcher::registerInputChannel(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        sp&lt;Connection&gt; connection = <span class="keyword">new</span> Connection(inputChannel, inputWindowHandle, monitor);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> fd = inputChannel-&gt;getFd();</span><br><span class="line">        mConnectionsByFd.add(fd, connection);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (monitor) &#123;</span><br><span class="line">            mMonitoringChannels.push(inputChannel);</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line">        mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wake the looper because some connections have changed.</span></span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Connection，可以看到用inputChannel初始化了inputPublisher(inputChannel)，这就是之前Input dispatcher小节 Step 8. InputPublisher.publishKeyEvent()方法中的那个mChannel。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --- InputDispatcher::Connection ---</span></span><br><span class="line">InputDispatcher::Connection::Connection(<span class="keyword">const</span> sp&lt;InputChannel&gt;&amp; inputChannel,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, <span class="keyword">bool</span> monitor) :</span><br><span class="line">    status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle),</span><br><span class="line">    monitor(monitor),</span><br><span class="line">    inputPublisher(inputChannel), inputPublisherBlocked(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>将InputWindowHandle, InputChanel封装成Connection对象，然后fd作为key，Connection作为Value，保存在mConnectionsByFd中，如果传入的monitor是true，则需要将InputChannel放到mMonitoringChannels中,从上面的InputManagerService的registerInputChannel函数里传入的monitor是false，所以这里不加入到mMonitoringChannels。同时把fd加入到mLooper的监听中，并指定当该fd有内容可读时，Looper就会调用handleReceiveCallback函数。至此server端的InputChannel注册完成，InputDispatcher睡眠在监听的fds上，当有按键事件发生时，InputDispatcher就会往这些fd写入InputMessage对象，进而回调handleReceiveCallback函数。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N23-Android-Input-System-InputDispatcher-viewrootimpl.png" alt="Markdown"></p><p>至此，server端的InputChannel就注册完成了，再回到前面的WindowManagerService.addWindow上的第二步inputChannels[1].transferTo(outInputChannel);，这个是将创建的一对InputChannel的client端复制到传入的参数InputChannel上，当addWindow返回时，就回到ViewRootImpl.setView()方法中，执行应用程序这一侧的键盘消息接收通道。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mInputChannel != null) &#123;</span><br><span class="line">    mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">        Looper.myLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WindowInputEventReceiver继承自InputEventReceiver类。</p><h2 id="Step-16、InputEventReceiver"><a href="#Step-16、InputEventReceiver" class="headerlink" title="Step 16、InputEventReceiver()"></a>Step 16、InputEventReceiver()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mInputChannel = inputChannel;</span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;InputEventReceiver&gt;(<span class="keyword">this</span>),</span><br><span class="line">            inputChannel, mMessageQueue);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了nativeInit执行native层的初始化</p><h2 id="Step-17-、InputEventReceiver-nativeInit"><a href="#Step-17-、InputEventReceiver-nativeInit" class="headerlink" title="Step 17.、InputEventReceiver.nativeInit()"></a>Step 17.、InputEventReceiver.nativeInit()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverWeak,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject inputChannelObj, jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env,</span><br><span class="line">            inputChannelObj);</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line"></span><br><span class="line">    sp&lt;NativeInputEventReceiver&gt; receiver = <span class="keyword">new</span> NativeInputEventReceiver(env,</span><br><span class="line">            receiverWeak, inputChannel, messageQueue);</span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;initialize();</span><br><span class="line"></span><br><span class="line">    receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建了一个NativeInputEventReceiver对象，并调用其initialize函数</p><h2 id="Step-18-、NativeInputEventReceiver-initialize"><a href="#Step-18-、NativeInputEventReceiver-initialize" class="headerlink" title="Step 18.、NativeInputEventReceiver.initialize()"></a>Step 18.、NativeInputEventReceiver.initialize()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> NativeInputEventReceiver::initialize() &#123;</span><br><span class="line">    setFdEvents(ALOOPER_EVENT_INPUT);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用setFdEvents函数</p><h2 id="Step-19、NativeInputEventReceiver-setFdEvents"><a href="#Step-19、NativeInputEventReceiver-setFdEvents" class="headerlink" title="Step 19、NativeInputEventReceiver.setFdEvents()"></a>Step 19、NativeInputEventReceiver.setFdEvents()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/jni/android_view_InputEventReceiver.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeInputEventReceiver::setFdEvents(<span class="keyword">int</span> events) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mFdEvents != events) &#123;</span><br><span class="line">        mFdEvents = events;</span><br><span class="line">        <span class="keyword">int</span> fd = mInputConsumer.getChannel()-&gt;getFd();</span><br><span class="line">        <span class="keyword">if</span> (events) &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;addFd(fd, <span class="number">0</span>, events, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mMessageQueue-&gt;getLooper()-&gt;removeFd(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用传入的MessageQueue获取Looper对象，如果events是0，则表示要移除监听fd，如果events不为0，表示要监听fd，这个fd是前面WindowManagerService创建的一对InputChannel的client端，这样当Server端写入事件时，client端的looper就能被唤醒，并调用handleEvent函数（Looper::addFd函数可以指定LooperCallback对象，当fd可读时，会调用LooperCallback的handleEvent，而NativeInputEventReceiver继承自LooperCallback，所以这里会调用NativeInputEventReceiver的handleEvent函数） 贴上事件处理序列图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N24-Android-Input-System-Process-input-event.png" alt="Markdown"></p><h2 id="Step-20、NativeInputEventReceiver-handleEvent"><a href="#Step-20、NativeInputEventReceiver-handleEvent" class="headerlink" title="Step 20、NativeInputEventReceiver.handleEvent()"></a>Step 20、NativeInputEventReceiver.handleEvent()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> NativeInputEventReceiver::handleEvent(<span class="keyword">int</span> receiveFd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; ALOOPER_EVENT_INPUT) &#123;</span><br><span class="line">        JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">        <span class="keyword">status_t</span> status = consumeEvents(env, <span class="literal">false</span> <span class="comment">/*consumeBatches*/</span>, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"handleReceiveCallback"</span>);</span><br><span class="line">        <span class="keyword">return</span> status == OK || status == NO_MEMORY ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数调用consumeEvents函数来处理接收一个按键事件</p><h2 id="Step-21、NativeInputEventReceiver-consumeEvents"><a href="#Step-21、NativeInputEventReceiver-consumeEvents" class="headerlink" title="Step 21、NativeInputEventReceiver.consumeEvents()"></a>Step 21、NativeInputEventReceiver.consumeEvents()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> NativeInputEventReceiver::consumeEvents(JNIEnv* env,</span><br><span class="line">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">bool</span>* outConsumedBatch) &#123;</span><br><span class="line">    ......</span><br><span class="line">    ScopedLocalRef&lt;jobject&gt; receiverObj(env, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> skipCallbacks = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> seq;</span><br><span class="line">        InputEvent* inputEvent;</span><br><span class="line">        <span class="comment">// 处理接收一个按键事件</span></span><br><span class="line">        <span class="keyword">status_t</span> status = mInputConsumer.consume(&amp;mInputEventFactory,</span><br><span class="line">                consumeBatches, frameTime, &amp;seq, &amp;inputEvent);</span><br><span class="line">        <span class="keyword">if</span> (!skipCallbacks) &#123;</span><br><span class="line">            jobject inputEventObj;</span><br><span class="line">            <span class="keyword">switch</span> (inputEvent-&gt;getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> AINPUT_EVENT_TYPE_KEY:</span><br><span class="line">                inputEventObj = android_view_KeyEvent_fromNative(env,</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;KeyEvent*&gt;(inputEvent));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inputEventObj) &#123;</span><br><span class="line">                env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br><span class="line">                env-&gt;DeleteLocalRef(inputEventObj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skipCallbacks) &#123;</span><br><span class="line">            mInputConsumer.sendFinishedSignal(seq, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先调用mInputConsumer.consume接收一个InputEvent对象,mInputConsumer在NativeInputEventReceiver构造函数中初始化</p><h2 id="Step-22、InputConsumer-consume"><a href="#Step-22、InputConsumer-consume" class="headerlink" title="Step 22、InputConsumer.consume()"></a>Step 22、InputConsumer.consume()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputConsumer::consume(InputEventFactoryInterface* factory,</span><br><span class="line">        <span class="keyword">bool</span> consumeBatches, <span class="keyword">nsecs_t</span> frameTime, <span class="keyword">uint32_t</span>* outSeq, InputEvent** outEvent) &#123;</span><br><span class="line"></span><br><span class="line">    *outSeq = <span class="number">0</span>;</span><br><span class="line">    *outEvent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fetch the next input message.</span></span><br><span class="line">    <span class="comment">// Loop until an event can be returned or no additional events are received.</span></span><br><span class="line">    <span class="keyword">while</span> (!*outEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMsgDeferred) &#123;</span><br><span class="line">            <span class="comment">// mMsg contains a valid input message from the previous call to consume</span></span><br><span class="line">            <span class="comment">// that has not yet been processed.</span></span><br><span class="line">            mMsgDeferred = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Receive a fresh message.</span></span><br><span class="line">            <span class="keyword">status_t</span> result = mChannel-&gt;receiveMessage(&amp;mMsg);</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                <span class="comment">// Consume the next batched event unless batches are being held for later.</span></span><br><span class="line">                <span class="keyword">if</span> (consumeBatches || result != WOULD_BLOCK) &#123;</span><br><span class="line">                    result = consumeBatch(factory, frameTime, outSeq, outEvent);</span><br><span class="line">                    <span class="keyword">if</span> (*outEvent) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;   </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mMsg.header.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> InputMessage::TYPE_KEY: &#123;</span><br><span class="line">            KeyEvent* keyEvent = factory-&gt;createKeyEvent();</span><br><span class="line">            <span class="keyword">if</span> (!keyEvent) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">            initializeKeyEvent(keyEvent, &amp;mMsg);</span><br><span class="line">            *outSeq = mMsg.body.key.seq;</span><br><span class="line">            *outEvent = keyEvent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数首先调用InputChannel的receiveMessage函数接收InputMessage对象，然后根据InputMessage对象调用initializeKeyEvent来构造KeyEvent对象。拿到可KeyEvent对象后，再对到consumeEvents中调用java层的InputEventReceiver.java的dispatchInputEvent函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                        gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj);</span><br></pre></td></tr></table></figure><h2 id="Step-23、InputEventReceiver-dispatchInputEvent"><a href="#Step-23、InputEventReceiver-dispatchInputEvent" class="headerlink" title="Step 23、InputEventReceiver.dispatchInputEvent()"></a>Step 23、InputEventReceiver.dispatchInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line">SuppressWarnings(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchInputEvent</span><span class="params">(<span class="keyword">int</span> seq, InputEvent event)</span> </span>&#123;</span><br><span class="line">    mSeqMap.put(event.getSequenceNumber(), seq);</span><br><span class="line">    onInputEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进而调用onInputEvent函数。至此按键就开始了java层的分发(下一节详细介绍)。</p><p>回到主线，故事来没讲完。当App这端处理完输入事件调用ViewRootImpl.finishInputEvent()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (q.mReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != <span class="number">0</span>;</span><br><span class="line">        q.mReceiver.finishInputEvent(q.mEvent, handled);</span><br><span class="line">    &#125;......</span><br><span class="line">    recycleQueuedInputEvent(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层InputEventReceiver.nativeFinishInputEvent() 通过JNI 调用android_view_InputEventReceiver.finishInputEvent()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> NativeInputEventReceiver::finishInputEvent(<span class="keyword">uint32_t</span> seq, <span class="keyword">bool</span> handled) &#123;</span><br><span class="line">           <span class="keyword">if</span> (kDebugDispatchCycle) &#123;</span><br><span class="line">              ALOGD(<span class="string">"channel '%s' ~ Finished input event."</span>, getInputChannelName());</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">status_t</span> status = mInputConsumer.sendFinishedSignal(seq, handled);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>层层跳转最后会调用到InputConsumer.sendUnchainedFinishedSignal()发送一个InputMessage::TYPE_FINISHED消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/libs/input/InputTransport.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> InputConsumer::sendUnchainedFinishedSignal(<span class="keyword">uint32_t</span> seq, <span class="keyword">bool</span> handled) &#123;</span><br><span class="line">InputMessage msg;</span><br><span class="line">msg.header.type = InputMessage::TYPE_FINISHED;</span><br><span class="line">msg.body.finished.seq = seq;</span><br><span class="line">msg.body.finished.handled = handled;</span><br><span class="line"><span class="keyword">return</span> mChannel-&gt;sendMessage(&amp;msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在InputDispatcher.registerInputChannel()中添加了一个 handleReceiveCallback回调。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLooper-&gt;addFd(fd, <span class="number">0</span>, ALOOPER_EVENT_INPUT, handleReceiveCallback, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>然后通过和IMS中InputDispacher的通信管道InputChannel发了处理完成通知。那InputDispatcher这边收到后如何处理呢？</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N25-Android-Input-System-InputDispatcher-handleReceiveCallback.jpg" alt="Markdown"></p><p>由前面分析 InputDispatcher会调用handleReceiveCallback()来处理TYPE_FINISHED信号。这里先是往Command队列里放一个处理事务执行doDispatchCycleFinishedLockedInterruptible()，后面在runCommandsLockedInterruptible()中会取出执行。在doDispatchCycleFinishedLockedInterruptible()函数中，会先调用afterKeyEventLockedInterruptible()。Android中可以定义一些Fallback键，即如果一个Key事件App没有处理，可以Fallback成另外默认的Key事件，这是在这里的dispatchUnhandledKey()函数中进行处理的。接着InputDispatcher会将该收到完成信号的事件项从等待队列中移除。同时由于上一个事件已被App处理完，就可以调用startDispatchCycleLocked()来进行下一轮事件的处理了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/services/inputflinger/InputDispatcher.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchEntry == connection-&gt;findWaitQueueEntry(seq)) &#123;  </span><br><span class="line">    connection-&gt;waitQueue.dequeue(dispatchEntry);  </span><br><span class="line">    ...  </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="comment">// Start the next dispatch cycle for this connection.  </span></span><br><span class="line">  startDispatchCycleLocked(now(), connection);</span><br></pre></td></tr></table></figure><p>startDispatchCycleLocked函数会检查相应连接的输出缓冲中(connection-&gt;outboundQueue)是否有事件要发送的，有的话会通过InputChannel发送出去。</p><p>总结：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N26-Android-Input-System-Input-kernel-driver-framwork-app.png" alt="Markdown"></p><h2 id="8、Android-Input子系统之java层按键传递"><a href="#8、Android-Input子系统之java层按键传递" class="headerlink" title="8、Android Input子系统之java层按键传递"></a>8、Android Input子系统之java层按键传递</h2><p>Android开发中在自定义Activity以及View时经常会重写onKeyDown,onKeyUp,dispatchKeyEvent，同时View还有setOnKeyListener等，当一个按键事件发生时，这些方法将会被回调，但是到底哪个先回调，哪个后回调呢，一直不是特别清楚，只知道个大概，下面将详细讲述按键在java层的分发过程，其中重点关注按键事件在View层次中的分发</p><p>java层的按键分发从ViewRootImpl.java的WindowInputEventReceiver中的onInputEvent开始，从前面的应用程序注册消息监听过程分析和Input Dispatcher分析，InputDispatcher在处理按键事件时，会通过InputChannel::sendMessage函数将按键消息从server端写入，这里的InputChannel是当前获取焦点的窗口的InputChannel对的server端，这样应用程序端就可以收到该消息，然后调用NativeInputEventReceiver的handleEvent,最后调用到InputEventReceiver的onInputEvent函数（具体的可以看应用程序注册消息监听过程分析 的Step20-Step23）</p><p>序列图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N27-Android-Input-System-input-stage.png" alt="Markdown"></p><h2 id="Step-1、WindowInputEventReceiver-onInputEvent"><a href="#Step-1、WindowInputEventReceiver-onInputEvent" class="headerlink" title="Step 1、WindowInputEventReceiver.onInputEvent()"></a>Step 1、WindowInputEventReceiver.onInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowInputEventReceiver</span> <span class="keyword">extends</span> <span class="title">InputEventReceiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WindowInputEventReceiver</span><span class="params">(InputChannel inputChannel, Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(inputChannel, looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInputEvent</span><span class="params">(InputEvent event)</span> </span>&#123;</span><br><span class="line">        enqueueInputEvent(event, <span class="keyword">this</span>, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只列出部分代码，当一个按键按下时onInputEvent方法就会被回调，其中调用了ViewRootImpl::enqueueInputEvent(event, this, 0, true);</p><h2 id="Step-2、ViewRootImpl-enqueueInputEvent"><a href="#Step-2、ViewRootImpl-enqueueInputEvent" class="headerlink" title="Step 2、ViewRootImpl.enqueueInputEvent()"></a>Step 2、ViewRootImpl.enqueueInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueueInputEvent</span><span class="params">(InputEvent event,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputEventReceiver receiver, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> processImmediately)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从队列中获取一个QueuedInputEvent，这里的flags传入的是0</span></span><br><span class="line">    QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (processImmediately) &#123;</span><br><span class="line">        doProcessInputEvents();<span class="comment">//这里传入的processImmediately是true，所以调用doProcessInputEvents</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scheduleProcessInputEvents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的参数可知，这里表示要立即处理，所以调用doProcessInputEvents函数.</p><h2 id="Step-3、ViewRootImpl-doProcessInputEvents"><a href="#Step-3、ViewRootImpl-doProcessInputEvents" class="headerlink" title="Step 3、ViewRootImpl.doProcessInputEvents()"></a>Step 3、ViewRootImpl.doProcessInputEvents()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/ViewRootImpl.java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessInputEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Deliver all pending input events in the queue.</span></span><br><span class="line">    <span class="keyword">while</span> (mPendingInputEventHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        QueuedInputEvent q = mPendingInputEventHead;</span><br><span class="line">        mPendingInputEventHead = q.mNext;</span><br><span class="line">        <span class="keyword">if</span> (mPendingInputEventHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingInputEventTail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.mNext = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        mPendingInputEventCount -= <span class="number">1</span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 分发按键事件</span></span><br><span class="line">        deliverInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在deliverInputEvent函数中实际做按键的分发</p><h2 id="Step-4、ViewRootImpl-deliverInputEvent"><a href="#Step-4、ViewRootImpl-deliverInputEvent" class="headerlink" title="Step 4、ViewRootImpl.deliverInputEvent()"></a>Step 4、ViewRootImpl.deliverInputEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverInputEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"deliverInputEvent"</span>,</span><br><span class="line">            q.mEvent.getSequenceNumber());</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onInputEvent(q.mEvent, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InputStage stage;</span><br><span class="line">    <span class="keyword">if</span> (q.shouldSendToSynthesizer()) &#123;</span><br><span class="line">        stage = mSyntheticInputStage;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//选择责任链的模式的入口，如果InputEvent需要跳过IME处理，则从mFirstPostImeInputStage（EarlyPostImeInputStage）开始,否则从mFirstInputStage(NativePreImeInputStage)开始分发</span></span><br><span class="line">        stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stage.deliver(q);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishInputEvent(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了InputStage的deliver方法分发，这里的InputStage代表了输入事件的处理阶段，是一种责任链模式 InputStage将输入事件的处理分成若干个阶段（Stage）, 如果当前有输入法窗口，则事件处理从 NativePreIme 开始，否则的话，从EarlyPostIme 开始。事件会依次经过每个Stage，如果该事件没有被标识为 “Finished”， 该Stage就会处理它，然后返回处理结果，Forward 或 Finish， Forward 运行下一Stage继续处理，而Finished事件将会简单的Forward到下一级，直到最后一级 Synthetic InputStage。流程图和每个阶段完成的事情如下图所示<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N28-Android-Input-System-input-stage-GUI.png" alt="Markdown"></p><p>责任链模式： 责任链模式（Chain of Responsibility）的目标是使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。</p><p>按键分发： 在ViewRootImpl的setView函数中会构造一个如图所示的InputStage的链，按键会从入口阶段，进入责任链，顺序处理，入口阶段根据QueuedInputEvent的状态来决定。q.shouldSendToSynthesizer() 这里一般是false，因此主要看stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; 这里的shouldSkipIme其实是一个flag在构造QueuedInputEvent时传入的，从前面的onInputEvent调用的enqueueInputEvent(event, this, 0, true);可知，这里传入的flags是第三个参数0，那这里的shouldSkipIme就是false，那么按键会从mFirstPostImeInputStage 开始分发，就是图中的NativePreImeInputStage分发。</p><p>下面只从跟本文前面提到的Activity，View的按键分发流程相关的InputStage（ViewPostImeInputStage）开始分析</p><h2 id="Step-5、ViewPostImeInputStage-processKeyEvent"><a href="#Step-5、ViewPostImeInputStage-processKeyEvent" class="headerlink" title="Step 5、ViewPostImeInputStage.processKeyEvent()"></a>Step 5、ViewPostImeInputStage.processKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">processKeyEvent</span><span class="params">(QueuedInputEvent q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> KeyEvent event = (KeyEvent)q.mEvent;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Deliver the key to the view hierarchy.</span></span><br><span class="line">    <span class="comment">// 调用成员变量mView的dispatchKeyEvent函数，这里mView是PhoneWindow.DecorView对象</span></span><br><span class="line">    <span class="keyword">if</span> (mView.dispatchKeyEvent(event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 如果按键是四向键或者是TAB键，则移动焦点</span></span><br><span class="line">    <span class="comment">// Handle automatic focus changes.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">        <span class="keyword">int</span> direction = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (event.getKeyCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_DPAD_LEFT:</span><br><span class="line">                <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                    direction = View.FOCUS_LEFT;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_TAB:</span><br><span class="line">                <span class="keyword">if</span> (event.hasNoModifiers()) &#123;</span><br><span class="line">                    direction = View.FOCUS_FORWARD;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123;</span><br><span class="line">                    direction = View.FOCUS_BACKWARD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (direction != <span class="number">0</span>) &#123;</span><br><span class="line">            View focused = mView.findFocus();</span><br><span class="line">            <span class="keyword">if</span> (focused != <span class="keyword">null</span>) &#123;</span><br><span class="line">                View v = focused.focusSearch(direction);</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v != focused) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    focused.getFocusedRect(mTempRect);</span><br><span class="line">                    <span class="keyword">if</span> (mView <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">                        ((ViewGroup) mView).offsetDescendantRectToMyCoords(</span><br><span class="line">                                focused, mTempRect);</span><br><span class="line">                        ((ViewGroup) mView).offsetRectIntoDescendantCoords(</span><br><span class="line">                                v, mTempRect);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (v.requestFocus(direction, mTempRect)) &#123;</span><br><span class="line">                        playSoundEffect(SoundEffectConstants</span><br><span class="line">                                .getContantForFocusDirection(direction));</span><br><span class="line">                        <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Give the focused view a last chance to handle the dpad key.</span></span><br><span class="line">                <span class="keyword">if</span> (mView.dispatchUnhandledMove(focused, direction)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// find the best view to give focus to in this non-touch-mode with no-focus</span></span><br><span class="line">                View v = focusSearch(<span class="keyword">null</span>, direction);</span><br><span class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; v.requestFocus(direction)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> FINISH_HANDLED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述主要分两步： 第一步是调用PhoneWindow.DecorView的dispatchKeyEvent函数，DecorView是View层次结构的根节点，按键从根节点开始根据Focuse view的path自上而下的分发。 第二步是判断按键是否是四向键，或者是TAB键，如果是则需要移动焦点</p><h2 id="Step-6、mView-dispatchKeyEvent"><a href="#Step-6、mView-dispatchKeyEvent" class="headerlink" title="Step 6、mView.dispatchKeyEvent()"></a>Step 6、mView.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;  </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!isDestroyed()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> handled = cb != <span class="keyword">null</span> &amp;&amp; mFeatureId &lt; <span class="number">0</span> ? cb.dispatchKeyEvent(event)</span><br><span class="line">                : <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">        <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isDown ? PhoneWindow.<span class="keyword">this</span>.onKeyDown(mFeatureId, event.getKeyCode(), event)</span><br><span class="line">            : PhoneWindow.<span class="keyword">this</span>.onKeyUp(mFeatureId, event.getKeyCode(), event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的分发在下面开始，如果cb不为空并且mFeatureId小于0，则调用cb.dispatchKeyEvent开始分发，否则会调用DecorView的父类（View）的dispatchKeyEvent函数。cb是Window.Callback类型，Activity实现了Window.Callback接口，在attach函数中，会调用Window.setCallback函数将自己注册进PhoneWindow中，所以cb不为空。在PhoneWindow初始化时会调用installDecor函数生成DecorView对象，该函数中传入的mFeatureId是-1，所以mFeatureId也小于0。因此此处会调用Activity的dispatchKeyEvent函数，开始在View中分发按键。</p><p>下面来分析按键在View的层次结构中是如何分发的 DecorView的按键分发</p><p>接下来来看这里先看看Activity(Callback)的dispatchKeyEvent实现：</p><h2 id="Step-7、Activity-dispatchKeyEvent"><a href="#Step-7、Activity-dispatchKeyEvent" class="headerlink" title="Step 7、Activity.dispatchKeyEvent()"></a>Step 7、Activity.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[frameworks/base/core/java/android/app/Activity.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用自定义的onUserInteraction</span></span><br><span class="line">    onUserInteraction();</span><br><span class="line"></span><br><span class="line">    Window win = getWindow();</span><br><span class="line">    <span class="comment">//调用PhoneWindow的superDispatchKeyEvent,实际调用DecorView的superDispatchKeyEvent，从DecorView开始从顶层View往子视图传递</span></span><br><span class="line">    <span class="keyword">if</span> (win.superDispatchKeyEvent(event)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    View decor = mDecor;</span><br><span class="line">    <span class="keyword">if</span> (decor == <span class="keyword">null</span>) decor = win.getDecorView();</span><br><span class="line">    <span class="comment">//到这里如果view层次结构没有返回true则交给KeyEvent本身的dispatch方法，Activity的onKeyDown/onKeyUp/onKeyMultiple就会被触发</span></span><br><span class="line">    <span class="keyword">return</span> event.dispatch(<span class="keyword">this</span>, decor != <span class="keyword">null</span></span><br><span class="line">            ? decor.getKeyDispatcherState() : <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着看下PhoneWindow的superDispatchKeyEvent</p><h2 id="Step-8、PhoneWindow-superDispatchKeyEvent"><a href="#Step-8、PhoneWindow-superDispatchKeyEvent" class="headerlink" title="Step 8、PhoneWindow.superDispatchKeyEvent()"></a>Step 8、PhoneWindow.superDispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- PhoneWindow.java --&gt;</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- PhoneWindow.DecorView --&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Give priority to closing action modes if applicable.</span></span><br><span class="line">    <span class="keyword">if</span> (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = event.getAction();</span><br><span class="line">        <span class="comment">// Back cancels action modes first.</span></span><br><span class="line">        <span class="keyword">if</span> (mPrimaryActionMode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (action == KeyEvent.ACTION_UP) &#123;</span><br><span class="line">                mPrimaryActionMode.finish();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进入View的层次结构，调用ViewGroup.dispatchKeyEvent</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchKeyEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看ViewGroup的dispatchKeyEvent函数</p><h2 id="Step-9、ViewGroup-dispatchKeyEvent"><a href="#Step-9、ViewGroup-dispatchKeyEvent" class="headerlink" title="Step 9、ViewGroup.dispatchKeyEvent()"></a>Step 9、ViewGroup.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/ViewGroup.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))</span><br><span class="line">            == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123;</span><br><span class="line">        <span class="comment">//如果此ViewGroup是focused并且具体的大小被设置了（有边界），则交给它处理，即调用View的实现</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">super</span>.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFocused != <span class="keyword">null</span> &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS)</span><br><span class="line">            == PFLAG_HAS_BOUNDS) &#123;</span><br><span class="line">        <span class="comment">//否则，如果此ViewGroup中有focused的child，且child有具体的大小，则交给mFocused处理</span></span><br><span class="line">        <span class="keyword">if</span> (mFocused.dispatchKeyEvent(event)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出如果ViewGroup满足条件，则优先处理事件而不发给子视图去处理。</p><p>下面看下View的dispatchKeyEvent实现</p><h2 id="Step-10、View-dispatchKeyEvent"><a href="#Step-10、View-dispatchKeyEvent" class="headerlink" title="Step 10、View.dispatchKeyEvent()"></a>Step 10、View.dispatchKeyEvent()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/view/View.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchKeyEvent</span><span class="params">(KeyEvent event)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Give any attached key listener a first crack at the event.</span></span><br><span class="line">    <span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="comment">//调用onKeyListener，如果注册了OnKeyListener,并且View属于Enable状态，则触发</span></span><br><span class="line">    <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnKeyListener != <span class="keyword">null</span> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            &amp;&amp; li.mOnKeyListener.onKey(<span class="keyword">this</span>, event.getKeyCode(), event)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="comment">//调用KeyEvent.dispatch方法，并将view作为参数传递进去，实际会回调View的onKeyUp/onKeyDown等方法</span></span><br><span class="line">    <span class="keyword">if</span> (event.dispatch(<span class="keyword">this</span>, mAttachInfo != <span class="keyword">null</span></span><br><span class="line">            ? mAttachInfo.mKeyDispatchState : <span class="keyword">null</span>, <span class="keyword">this</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;     </span><br><span class="line">    ...  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-11、View-onKeyDown-View-onKeyUp"><a href="#Step-11、View-onKeyDown-View-onKeyUp" class="headerlink" title="Step 11、View.onKeyDown/View.onKeyUp"></a>Step 11、View.onKeyDown/View.onKeyUp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[-&gt;frameworks/base/core/java/android/view/View.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//处理KEYCODE_DPAD_CENTER、KEYCODE_ENTER按键</span></span><br><span class="line">    <span class="keyword">if</span> (KeyEvent.isConfirmKey(keyCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="comment">//disabled的view直接返回true，不再继续分发,即Activity的onKeyDown和onKeyUp无法收到KEYCODE_DPAD_CENTER、KEYCODE_ENTER事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Long clickable items don't necessarily have to be clickable</span></span><br><span class="line">        <span class="keyword">if</span> (((mViewFlags &amp; CLICKABLE) == CLICKABLE ||</span><br><span class="line">                (mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &amp;&amp;</span><br><span class="line">                (event.getRepeatCount() == <span class="number">0</span>)) &#123;<span class="comment">// clickable或者long_clickable且是第一次down事件</span></span><br><span class="line">            setPressed(<span class="keyword">true</span>);<span class="comment">// 标记pressed，你可能设置了View不同的background，这时候就会有所体现（比如高亮效果）</span></span><br><span class="line">            checkForLongClick(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理KEYCODE_DPAD_CENTER、KEYCODE_ENTER按键</span></span><br><span class="line">    <span class="keyword">if</span> (KeyEvent.isConfirmKey(keyCode)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            <span class="comment">//disabled的view直接返回true，不再继续分发,即Activity的onKeyDown和onKeyUp无法收到KEYCODE_DPAD_CENTER、KEYCODE_ENTER事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; CLICKABLE) == CLICKABLE &amp;&amp; isPressed()) &#123;</span><br><span class="line">            setPressed(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mHasPerformedLongPress) &#123;</span><br><span class="line">                <span class="comment">// This is a tap, so remove the longpress check</span></span><br><span class="line">                removeLongPressCallback();</span><br><span class="line">                <span class="keyword">return</span> performClick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Step-12、Activity-onKeyDown-onKeyUp"><a href="#Step-12、Activity-onKeyDown-onKeyUp" class="headerlink" title="Step 12、Activity.onKeyDown/onKeyUp"></a>Step 12、Activity.onKeyDown/onKeyUp</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/base/core/java/android/app/Activity.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span>  </span>&#123;</span><br><span class="line">    <span class="comment">//如果是back键则启动追踪</span></span><br><span class="line">    <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt;= Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">            event.startTracking();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            onBackPressed();</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= Build.VERSION_CODES.ECLAIR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking()</span><br><span class="line">                &amp;&amp; !event.isCanceled()) &#123;</span><br><span class="line">            <span class="comment">//如果是back键并且正在追踪该Event，则调用onBackPressed</span></span><br><span class="line">            onBackPressed();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Android常见Touch事件是通过dispatchPointerEvent(MotionEvent event)分发的，主要跟底层传上来的 输入事件相关，不同类型事件分别处理。 具体Touch事件分发机制可参考博客： <a href="http://blog.csdn.net/guolin_blog/article/details/9097463/" target="_blank" rel="noopener">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a> <a href="http://blog.csdn.net/guolin_blog/article/details/9153747/" target="_blank" rel="noopener">Android事件分发机制完全解析，带你从源码的角度彻底理解(下)</a> <a href="http://blog.csdn.net/yanbober/article/details/45887547" target="_blank" rel="noopener">Android触摸屏事件派发机制详解与源码分析一(View篇)</a> <a href="http://blog.csdn.net/yanbober/article/details/45912661" target="_blank" rel="noopener">Android触摸屏事件派发机制详解与源码分析二(ViewGroup篇)</a> <a href="http://blog.csdn.net/yanbober/article/details/45932123" target="_blank" rel="noopener">Android触摸屏事件派发机制详解与源码分析三(Activity篇)</a> <a href="http://hukai.me/android-deeper-touch-event-dispatch-process/" target="_blank" rel="noopener">Android Deeper(00) - Touch事件分发响应机制</a><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N29-Android-Input-System-touch-event.png" alt="Markdown"></p><h2 id="九、总结："><a href="#九、总结：" class="headerlink" title="九、总结："></a>九、总结：</h2><p>再贴一下Input system总体框架图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N30-Android-Input-System-input-system-framwork.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.input/N31-Android-Input-System-Input-kernel-driver-framwork-app.png" alt="Markdown"></p><h2 id="（一）、IMS初始化-amp-amp-IMS与App建立通信："><a href="#（一）、IMS初始化-amp-amp-IMS与App建立通信：" class="headerlink" title="（一）、IMS初始化&amp;&amp; IMS与App建立通信："></a>（一）、IMS初始化&amp;&amp; IMS与App建立通信：</h2><ol><li><p>SystemServer初始化过程中，创建InputManagerService，IMS第一件事情就是初始化Native层，包括EventHub, InputReader 和 InputDispatcher</p></li><li><p>IMS以及其他的System Service 初始化完成之后，应用程序就开始启动。如果一个应用程序有Activity（只有Activit能够接受用户输入），它要将自己的Window(ViewRootImpl)通过setView()注册到WindowManagerService 中</p></li><li><p>用户输入的捕捉和处理发生在不同的进程里（生产者：Input Reader 和 Input Dispatcher 在System Server 进程里，而消费者，应用程序运行在自己的进程里），因此用户输入事件（Event)的传递需要跨进程。在这里，Android使用了Socket + Binder来完成。OpenInputChannelPair 生成了两个Socket的FD， 代表一个双向通道的两端，向一端写入数据，另外一端便可以读出，反之依然，如果一端没有写入数据，另外一端去读，则陷入阻塞等待。OpenInputChannelPair() 发生在WindowManager Service.addWindow()中</p></li><li><p>通过RegisterInputChannel, WindowManagerService 将刚刚创建的一个Socket FD，封装在InputWindowHandle(代表一个WindowState) 里传给InputManagerService</p></li><li><p>InputManagerService 通过JNI（NativeInputManager）最终调用到了InputDispatcher 的 RegisterInputChannel()方法，这里，一个Connection 对象被创建出来，代表与远端某个窗口(InputWindowHandle)的一条用户输入数据通道。一个Dispatcher可能有多个Connection（多个Window）同时存在。为了监听来自于Window的消息，InputDispatcher 通过AddFd 将这些个FD 加入到Looper中，这样，只要某个Window在Socket的另一端写入数据，Looper就会马上从睡眠中醒来，进行处理。</p></li><li><p>到这里，ViewRootImpl mWindowSession.addToDisplay返回，WMS 将SocketPair的另外一个FD 放在返回参数 OutputChannel 里，即返回给APP进程。</p></li><li><p>接着ViewRootImpl 创建了WindowInputEventReceiver 用于接受InputDispatchor 传过来的事件，App进程同样通过AddFd() 将读端的Socket FD 加入到Looper中，这样一旦InputDispatchor发送Event，Looper就会立即醒来处理。</p></li></ol><h2 id="（二）、Eventhub-和-Input-Reader"><a href="#（二）、Eventhub-和-Input-Reader" class="headerlink" title="（二）、Eventhub 和 Input Reader"></a>（二）、Eventhub 和 Input Reader</h2><ol><li><p>NativeInputManager的构造函数里第一件事情就是创建一个EventHub对象，EventHub构造函数里主要生成并初始化几个控制的FD</p></li><li><p>mINotifyFd: 用来监控””/dev/input”目录下是否有文件生成，有的话说明有新的输入设备接入，EventHub将从epool_wait中唤醒，来打开新加入的设备 mWakeReaderFD， mWakeWriterFD： 一个Pipe的两端，当往mWakeWriteFD 写入数据的时候，等待在mWakeReaderFD的线程被唤醒，这里用来给上层应用提供唤醒等待线程，比如说，当上层应用改变输入属性需要EventHub进行相应更新时</p></li><li><p>mEpollFD，用于epoll_wait()的阻塞等待，这里通过epoll_ctrl(EPOLL_ADD_FD, fd) 可以等待多个fd的事件，包括上面提到的mINotifyFD, mWakeReaderFD, 以及输入设备的FD。</p></li><li><p>InputManagerService启动InputReader 线程，进入无限的循环，每次循环调用loopOnce(). 第一次循环，会主动扫描 “/dev/input/“ 目录，并打开下面的所有文件，通过ioctl()从底层驱动获取设备信息，并判断它的设备类型。这里处理的设备类型有：INPUT_DEVICE_CLASS_KEYBOARD， INPUT_DEVICE_CLASS_TOUCH， INPUT_DEVICE_CLASS_DPAD，INPUT_DEVICE_CLASS_JOYSTICK 等。</p></li><li><p>找到每个设备对应的键值映射文件，读取并生产一个KeyMap 对象。一般来说，设备对应的键值映射文件是 “/system/usr/keylayout/Generic.kl”.</p></li><li><p>将刚才扫描到的/dev/input 下所有文件的FD 加到epool等待队列中，调用epool_wait() 开始等待事件的发生。</p></li><li><p>某个时间发生，可能是用户按键输入，也可能是某个设备插入，亦或用户调整了设备属性，epoll_wait() 返回，将发生的Event 存放在mPendingEventItems 里。如果这是一个用户输入，系统调用Read() 从驱动读到这个按键的信息，存放在rawEvents里。</p></li><li><p>EventHub-&gt;getEvents() 返回,代表有新的input事件到来，进入InputReader的processEventLocked函数。</p></li><li><p>通过rawEvent 找到产生时间的Device，再找到这个Device对应的InputMapper对象，最终生成一个NotifyArgs对象，将其放到NotifyArgs的队列中。</p></li><li><p>调用NotifyArgs里面的Notify()方法，最终调用到InputDispatchor 对应的Notify接口（比如NotifyKey) 将接下来的处理交给InputDispatchor，EventHub 和 InputReader 工作结束，但马上又开始新的一轮等待，重复6～9的循环。</p></li></ol><h2 id="（三）、Input-Dispatcher"><a href="#（三）、Input-Dispatcher" class="headerlink" title="（三）、Input Dispatcher"></a>（三）、Input Dispatcher</h2><ol><li><p>接上节的最后一步，NotifyKey() 的实现在Input Dispatcher 内部，他首先做简单的校验，对于按键事件，只有Action 是 AKEY_EVENT_ACTION_DOWN 和 AKEY_EVENT_ACTION_UP，即按下和弹起这两个Event别接受。</p></li><li><p>Input Reader 传给Input Dispather的数据类型是 NotifyKeyArgs， 后者在这里将其转换为 KeyEvent, 然后交由 Policy 来进行第一步的解析和过滤，interceptKeyBeforeDispatching(), 对于手机产品，这个工作是在PhoneWindowManager 里完成，（不同类型的产品可以定义不同的WindowManager, 比如GoogleTV 里用到的是TVWindowManager)。KeyEvent 在这里将会被分为三类：</p><ol><li>System Key: 比如说 音量键，Power键，以及一些特殊的组合键，如用于截屏的音量+Power，等等。部分System Key 会在这里立即处理，比如说电话键，但有一些会放到后面去做处理，比如说音量键，但不管怎样，这些键不会传给应用程序，所以称为系统键。</li><li>Global Key：最终产品中可能会有一些特殊的按键，它不属于某个特定的应用，在所有应用中的行为都是一样，但也不包含在Andrioid的系统键中，比如说GoogleTV 里会有一个”TV” 按键，按它会直接呼起”TV”应用然后收看电视直播，这类按键在Android定义为Global Key.</li><li>User Key：除此之外的按键就是User Key, 它最终会传递到当前的应用窗口。</li></ol></li><li><p>此时，InputDispather 还在Looper中睡眠等待，mLooper-&gt;wake();将其唤醒，然后进入Input Dispatcher 线程。</p></li><li><p>InputDispatcher 大部分的工作在 dispatcherOnce 里完成。首先从mInBoundQueue 中读出队列头部的事件 mPendingEvent, 然后调用 pokeUserActivityLocked()。 poke的英文意思是”搓一下, 捅一下”， 这个函数的目的也就是”捅一下”PowerManagerService 提醒它”别睡眠啊，我还活着呢”，最终调用到PowerManagerService 的 updatePowerStateLocked()，防止手机进入休眠状态。需要注意的是，上述动作不会马上执行，而是存储在命令队列，mCommandQueue里，这里面的命令会在后面依次被执行。</p></li><li><p>接下来是dispatchOnceInnerLocked()-&gt;dispatchKeyLocked() 第一次进去这个函数的时候，先检查Event是否已经过处理（doInterceptKeyBeforeDispatchingLockedInterruptible), 如果没有，则生成一个命令，同样放入mCommandQueue里。</p></li><li><p>runCommandsLockedInterruptible() 依次执行mCommandQueue 里的命令，前面说过，pokeUserActivity 会调用PowerManagerService 的 updatePowerStateLocked(), 而 interceptKeyBeforeDispatching() 则最终调用到PhoneWindowManager的同名函数。我们在interceptBeforeQueuing 里面提到的一些系统按键在这个被执行，比如 HOME/MENU/SEARCH 等。</p></li><li><p>命令运行完之后，退出 dispatchOnce， 然后调用pollOnce 进入下一轮等待。但这里不会被阻塞，因为timeout值被设成了0.</p></li><li><p>第二次进入dispatchKeyLocked(), 这是Event的状态已经设为”已处理”，这时候才真正进入了发射阶段。</p></li><li><p>接下来调用 findFocusedWindowTargetLocked() 获取当前的焦点窗口，这里面会做一件非常重要的事情，就是检测目标应用是否有ANR发生，如果下诉条件满足，则说明可能发生了ANR：</p><ol><li>目标应用不会空，而目标窗口为空。说明应用程序在启动过程中出现了问题。</li><li>目标 Activity 的状态是Pause，即不再是Focused的应用。</li><li>目标窗口还在处理上一个事件。这个我们下面会说到。</li></ol></li><li><p>如果目标窗口处于正常状态，调用dispatchEventLocked() 进入真正的发送程序。</p></li><li><p>然后调用prepareDispatchCycleLocked() ,这里事件换了一件马甲，从EventEntry 变成 DispatchEntry, 并送人mOutBoundQueue。然后调用startDispatchCycleLocked() 开始发送。</p></li><li><p>最终的发送发生在InputChannel的sendMessage()。这里就用到了我们前面提到的SocketPair, 一旦sendMessage() 执行，目标窗口所在进程的Looper线程就会被唤醒，然后读取键值并进行处理。</p></li><li><p>乖乖，还没走完啊？是的，工作还差最后一步，Input Dispatcher给这个窗口发送下一个命令之前，必须等待该窗口的回复，如果超过5s没有收到，就会通过Input Manager Service 向Activity Manager 汇报，后者会弹出我们熟知的 “Application No Response” 窗口。所以，事件会放入mWaitQueue进行暂存。如果窗口一切正常，完成按键处理后它会调用InputConsumer的sendFinishedSignal() 往SocketPair 里写入完成信号，Input Dispatcher 从 Loop中醒来，并从Socket中读取该信号，然后从mWaitQueue 里清除该事件标志其处理完毕。</p></li></ol><h2 id="（四）、Key-Processing"><a href="#（四）、Key-Processing" class="headerlink" title="（四）、Key Processing"></a>（四）、Key Processing</h2><p>略、请参考： <a href="https://www.cnblogs.com/samchen2009/p/3368158.html" target="_blank" rel="noopener">图解Android - Android GUI 系统 (5) - Android的Event Input System - 漫天尘沙 - 博客园</a></p><h2 id="参考文档-特别感谢-："><a href="#参考文档-特别感谢-：" class="headerlink" title="参考文档(特别感谢)："></a>参考文档(特别感谢)：</h2><p><a href="https://github.com/weidongshan" target="_blank" rel="noopener">韦东山第4期Android驱动深度开发视频源码-GitHub</a><br><a href="http://www.100ask.org/index.html" target="_blank" rel="noopener">韦东山第4期Android驱动深度开发视频-输入系统-100ask.org</a><br><a href="http://blog.csdn.net/chenweiaiyanyan/article/category/6948320" target="_blank" rel="noopener">Android输入子系统-ChenWeiaiYanYan</a><br><a href="http://blog.csdn.net/innost/article/details/47660387" target="_blank" rel="noopener">《深入理解Android 卷III》第五章 深入理解Android输入系统 - CSDN博客</a><br><a href="https://www.cnblogs.com/samchen2009/p/3368158.html" target="_blank" rel="noopener">图解Android - Android GUI 系统 (5) - Android的Event Input System - 漫天尘沙 - 博客园</a><br><a href="http://blog.csdn.net/jinzhuojun/article/details/41909159" target="_blank" rel="noopener">Android 5.0(Lollipop)事件输入系统(Input System) - 世事难料，保持低调 - CSDN博客</a><br><a href="http://www.cnblogs.com/lcw/p/3506110.html" target="_blank" rel="noopener">【Android】Android输入子系统 - Leo.cheng - 博客园</a><br><a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/" target="_blank" rel="noopener">Android(Linux) 输入子系统解析 | Andy.Lee’s Blog</a><br><a href="http://www.cheelok.com/aosp/59" target="_blank" rel="noopener">INPUT事件的读取和分发：INPUTREADER、INPUTDISPATCHER</a><br><a href="http://www.hustmeituan.club/tag/android.html" target="_blank" rel="noopener">Android 触摸事件分发机制</a><br><a href="https://www.jianshu.com/p/84b2e0038080" target="_blank" rel="noopener">深入理解Android之Touch事件的分发</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Activity - Window 加载显示流程（AMS &amp;&amp; WMS）分析</title>
      <link href="/2017/11/01/Android-7-1-2-Android-N-Activity-Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/11/01/Android-7-1-2-Android-N-Activity-Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>Activity-Window加载显示流程概述： Android系统中图形系统是相当复杂的，包括WindowManager，SurfaceFlinger,Open GL,GPU等模块。 其中SurfaceFlinger作为负责绘制应用UI的核心，从名字可以看出其功能是将所有Surface合成工作。 不论使用什么渲染API, 所有的东西最终都是渲染到”surface”. surface代表BufferQueue的生产者端, 并且 由SurfaceFlinger所消费, 这便是基本的生产者-消费者模式. Android平台所创建的Window都由surface所支持, 所有可见的surface渲染到显示设备都是通过SurfaceFlinger来完成的. 本文详细分析Android Window加载显示流程，并通过SurfaceFlinger渲染合成输出到屏幕的过程。 <a id="more"></a></p><h2 id="一、Activity启动流程概述"><a href="#一、Activity启动流程概述" class="headerlink" title="一、Activity启动流程概述"></a>一、Activity启动流程概述</h2><p>基于Android 7.1.2的源码剖析， 分析Activity-Window加载显示流程，相关源码：</p><hr><p><strong>frameworks/base/core/java/android/app/</strong><br>● Activity.java<br>● ActivityThread.java<br>● Instrumentation.java</p><p><strong>frameworks/base/core/jni/</strong><br>● android_view_DisplayEventReceiver.cpp<br><br>● android_view_SurfaceControl.cpp<br>● android_view_Surface.cpp<br>● android_view_SurfaceSession.cpp</p><p><strong>frameworks/native/include/gui/</strong><br>● SurfaceComposerClient.cpp<br><br>● SurfaceComposerClient.h</p><p><strong>frameworks/native/services/surfaceflinger/</strong><br>● SurfaceFlinger.cpp<br>● Client.cpp</p><p><strong>frameworks/base/core/java/android/view/</strong><br>● WindowManagerImpl.java<br>● ViewManager.java<br>● WindowManagerGlobal.java<br>● ViewRootImpl.java<br>● Choreographer.java<br>● IWindowSession.aidl<br>● DisplayEventReceiver.java<br>● SurfaceControl.java<br>● Surface.java<br>● SurfaceSession.java</p><p><strong>frameworks/base/core/java/com/android/internal/policy/</strong><br>● PhoneWindow.java</p><p><strong>frameworks/base/services/core/java/com/android/server/wm/</strong><br>● WindowManagerService.java<br>● Session.java<br>● WindowState.java<br>● WindowStateAnimator.java<br>● WindowSurfaceController.java</p><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.addwindow" target="_blank" rel="noopener">博客原图链接</a></h2><p>在前面文章（Android 7.1.2(Android N) Activity启动流程分析）中详细分析了Activity启动流程，这里回顾一下总体流程。 Activity启动流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N1-Android-addWindow-start_activity_process.jpg" alt="Markdown"></p><blockquote><p>启动流程：</p><p>● 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；<br>● system_server进程接收到请求后，向zygote进程发送创建进程的请求；<br>● Zygote进程fork出新的子进程，即App进程；<br>● App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；<br>● system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；<br>● App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；<br>● 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</p></blockquote><p>App正式启动后，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面， 接下来分析UI渲染流程。</p><h3 id="二、Window加载显示流程"><a href="#二、Window加载显示流程" class="headerlink" title="二、Window加载显示流程"></a>二、Window加载显示流程</h3><h4 id="2-1、ActivityThread-handleLaunchActivity"><a href="#2-1、ActivityThread-handleLaunchActivity" class="headerlink" title="2.1、ActivityThread.handleLaunchActivity()"></a>2.1、ActivityThread.handleLaunchActivity()</h4><p>接着从ActivityThread的handleLaunchActivity方法： [-&gt;ActivityThread.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line">    <span class="comment">//创建Activity  </span></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//启动Activity  </span></span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程通过performLaunchActivity函数将即将要启动的Activity加载到当前进程空间来，同时为启动Activity做准备。 [ActivityThread.java #performLaunchActivity()]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过Activity所在的应用程序信息及该Activity对应的CompatibilityInfo信息从PMS服务中查询当前Activity的包信息  </span></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取当前Activity的组件信息  </span></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//packageName为启动Activity的包名，targetActivity为Activity的类名  </span></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过类反射方式加载即将启动的Activity</span></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过单例模式为应用程序进程创建Application对象  </span></span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//为当前Activity创建上下文对象ContextImpl  </span></span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//将当前启动的Activity和上下文ContextImpl、Application绑定</span></span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//将Activity保存到ActivityClientRecord中，ActivityClientRecord为Activity在应用程序进程中的描述符  </span></span><br><span class="line">            r.activity = activity;</span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//生命周期onStart、onresume</span></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//ActivityThread的成员变量mActivities保存了当前应用程序进程中的所有Activity的描述符</span></span><br><span class="line">            mActivities.put(r.token, r);</span><br><span class="line">            ......</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中，首先通过PMS服务查找到即将启动的Activity的包名信息，然后通过类反射方式创建一个该Activity实例，同时为应用程序启动的每一个Activity创建一个LoadedApk实例对象，应用程序进程中创建的所有LoadedApk对象保存在ActivityThread的成员变量mPackages中。接着通过LoadedApk对象的makeApplication函数，使用单例模式创建Application对象，因此在android应用程序进程中有且只有一个Application实例。然后为当前启动的Activity创建一个ContextImpl上下文对象，并初始化该上下文，到此我们可以知道，启动一个Activity需要以下对象：</p><p>1) Activity对象，需要启动的Activity；</p><p>2) LoadedApk对象，每个启动的Activity都拥有属于自身的LoadedApk对象；</p><p>3) ContextImpl对象，每个启动的Activity都拥有属于自身的ContextImpl对象；</p><p>4) Application对象，应用程序进程中有且只有一个实例，和Activity是一对多的关系；</p><h4 id="2-2、Activity对象Attach过程"><a href="#2-2、Activity对象Attach过程" class="headerlink" title="2.2、Activity对象Attach过程"></a>2.2、Activity对象Attach过程</h4><p>Activity所需要的对象都创建好了，就需要将Activity和Application对象、ContextImpl对象绑定在一起。</p><p>参数： context：Activity的上下文对象，就是前面创建的ContextImpl对象；</p><p>aThread：Activity运行所在的主线程描述符ActivityThread；</p><p>instr：用于监控Activity运行状态的Instrumentation对象；</p><p>token：用于和AMS服务通信的IApplicationToken.Proxy代理对象；</p><p>application：Activity运行所在进程的Application对象；</p><p>parent：启动当前Activity的Activity；</p><p>[-&gt;Activity.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将上下文对象ContextImpl保存到Activity的成员变量中  </span></span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//记录应用程序的UI线程  </span></span><br><span class="line">    mUiThread = Thread.currentThread();</span><br><span class="line">    <span class="comment">//记录应用程序的ActivityThread对象</span></span><br><span class="line">    mMainThread = aThread;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//为Activity所在的窗口创建窗口管理器</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该attach函数中主要做了以下几件事：</p><p>1) 根据参数初始化Activity的成员变量；</p><p>2) 为Activity创建窗口Window对象；</p><p>3) 为Window创建窗口管理器；</p><h4 id="2-3、Activity视图对象的创建过程-Activity-setContentView"><a href="#2-3、Activity视图对象的创建过程-Activity-setContentView" class="headerlink" title="2.3、Activity视图对象的创建过程-Activity.setContentView()"></a>2.3、Activity视图对象的创建过程-Activity.setContentView()</h4><blockquote><p>ActivityThread.performLaunchActivity()<br>–&gt; Instrumentation.callActivityOnCreate()<br>——&gt;Activity.performCreate()<br>——&gt;Activity.onCreate()<br>–&gt;Activity.performStart()<br>——&gt;Instrumentation.callActivityOnStart()<br>——&gt;Activity.onStart()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getWindow()函数得到前面创建的窗口对象PhoneWindow，通过PhoneWindow来设置Activity的视图。 [-&gt;PhoneWindow.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//如果窗口顶级视图对象为空，则创建窗口视图对象  </span></span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//加载布局文件，并将布局文件中的所有视图对象添加到mContentParent容器中,PhoneWindow的成员变量mContentParent的类型为ViewGroup，是窗口内容存放的地方</span></span><br><span class="line">        mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParent.requestApplyInsets();</span><br><span class="line">    <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">        cb.onContentChanged();</span><br><span class="line">    &#125;</span><br><span class="line">    mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Activity.onCreate()会调用setContentView(),整个过程主要是Activity的布局文件或View添加至窗口里， 详细过程不再赘述，详细加载过程请参考： <a href="http://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="noopener">Android应用setContentView与LayoutInflater加载解析机制源码分析</a> 重点概括为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">● 创建一个DecorView的对象mDecor，该mDecor对象将作为整个应用窗口的根视图。</span><br><span class="line">● 依据Feature等style theme创建不同的窗口修饰布局文件，并且通过findViewById获取Activity布局文件该存放的地方（窗口修饰布局文件中id为content的FrameLayout）。</span><br><span class="line">● 将Activity的布局文件添加至id为content的FrameLayout内。</span><br><span class="line">● 当setContentView设置显示OK以后会回调Activity的onContentChanged方法。Activity的各种View的findViewById()方法等都可以放到该方法中，系统会帮忙回调。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N2-Android-addWindow-DecorView.jpg" alt="Markdown"></p><h4 id="2-4、ActivityThread-handleResumeActivity"><a href="#2-4、ActivityThread-handleResumeActivity" class="headerlink" title="2.4、ActivityThread.handleResumeActivity()"></a>2.4、ActivityThread.handleResumeActivity()</h4><p>回到我们刚刚的handleLaunchActivity()方法，在调用完performLaunchActivity()方法之后，其有掉用了handleResumeActivity()法。</p><p>performLaunchActivity()方法完成了两件事：</p><p>1) Activity窗口对象的创建，通过attach函数来完成；</p><p>2) Activity视图对象的创建，通过setContentView函数来完成；</p><p>这些准备工作完成后，就可以显示该Activity了，应用程序进程通过调用handleResumeActivity函数来启动Activity的显示过程。</p><p>[-&gt;ActivityThread.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">            <span class="comment">//获得为当前Activity创建的窗口PhoneWindow对象</span></span><br><span class="line">            r.window = r.activity.getWindow();</span><br><span class="line">            <span class="comment">//获取为窗口创建的视图DecorView对象</span></span><br><span class="line">            View decor = r.window.getDecorView();</span><br><span class="line">            decor.setVisibility(View.INVISIBLE);</span><br><span class="line">            <span class="comment">//在attach函数中就为当前Activity创建了WindowManager对象  </span></span><br><span class="line">            ViewManager wm = a.getWindowManager();</span><br><span class="line">            <span class="comment">//得到该视图对象的布局参数  </span></span><br><span class="line">            WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">            <span class="comment">//将视图对象保存到Activity的成员变量mDecor中  </span></span><br><span class="line">            a.mDecor = decor;</span><br><span class="line">            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">            l.softInputMode |= forwardBit;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//将创建的视图对象DecorView添加到Activity的窗口管理器中  </span></span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        ......</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                r.activity.makeVisible();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.onlyLocalRequest) &#123;</span><br><span class="line">            <span class="comment">//onStop()......</span></span><br><span class="line">            Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">        &#125;</span><br><span class="line">        r.onlyLocalRequest = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (reallyResume) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在前面的performLaunchActivity函数中完成Activity的创建后，会将当前当前创建的Activity在应用程序进程端的描述符ActivityClientRecord以键值对的形式保存到ActivityThread的成员变量mActivities中：mActivities.put(r.token, r)，r.token就是Activity的身份证，即是IApplicationToken.Proxy代理对象，也用于与AMS通信。上面的函数首先通过performResumeActivity从mActivities变量中取出Activity的应用程序端描述符ActivityClientRecord，然后取出前面为Activity创建的视图对象DecorView和窗口管理器WindowManager，最后将视图对象添加到窗口管理器中。</p><p>ViewManager.addView()真正实现的的地方在WindowManagerImpl.java中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerGlobal.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        ......</span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5、ViewRootImpl-构造过程："><a href="#2-5、ViewRootImpl-构造过程：" class="headerlink" title="2.5、ViewRootImpl()构造过程："></a>2.5、ViewRootImpl()构造过程：</h4><p>[ViewRootImpl.java # ViewRootImpl()]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> W mWindow;</span><br><span class="line">    <span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line">    <span class="keyword">final</span> ViewRootHandler mHandler = <span class="keyword">new</span> ViewRootHandler();</span><br><span class="line">    ......</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewRootImpl</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mWindowSession = WindowManagerGlobal.getWindowSession();<span class="comment">//IWindowSession的代理对象，该对象用于和WMS通信。</span></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    ......</span><br><span class="line">    mWindow = <span class="keyword">new</span> W(<span class="keyword">this</span>);<span class="comment">//创建了一个W本地Binder对象，用于WMS通知应用程序进程</span></span><br><span class="line">    ......</span><br><span class="line">    mAttachInfo = <span class="keyword">new</span> View.AttachInfo(mWindowSession, mWindow, display, <span class="keyword">this</span>, mHandler, <span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    mViewConfiguration = ViewConfiguration.get(context);</span><br><span class="line">    mDensity = context.getResources().getDisplayMetrics().densityDpi;</span><br><span class="line">    mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi;</span><br><span class="line">    mFallbackEventHandler = <span class="keyword">new</span> PhoneFallbackEventHandler(context);</span><br><span class="line">    mChoreographer = Choreographer.getInstance();<span class="comment">//Choreographer对象</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ViewRootImpl的构造函数中初始化了一些成员变量，ViewRootImpl创建了以下几个主要对象：</p><p>(1) 通过WindowManagerGlobal.getWindowSession()得到IWindowSession的代理对象，该对象用于和WMS通信。</p><p>(2) 创建了一个W本地Binder对象，用于WMS通知应用程序进程。</p><p>(3) 采用单例模式创建了一个Choreographer对象，用于统一调度窗口绘图。</p><p>(4) 创建ViewRootHandler对象，用于处理当前视图消息。</p><p>(5) 构造一个AttachInfo对象；</p><p>(6) 创建Surface对象，用于绘制当前视图，当然该Surface对象的真正创建是由WMS来完成的，只不过是WMS传递给应用程序进程的。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N3-Android-addWindow-ViewRootImpl.png" alt="Markdown"></p><h4 id="2-6、IWindowSession代理获取过程"><a href="#2-6、IWindowSession代理获取过程" class="headerlink" title="2.6、IWindowSession代理获取过程"></a>2.6、IWindowSession代理获取过程</h4><p>[-&gt;WindowManagerGlobal.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> IWindowSession sWindowSession;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IWindowSession <span class="title">getWindowSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (WindowManagerGlobal.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWindowSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//获取输入法管理器</span></span><br><span class="line">                InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">                <span class="comment">//获取窗口管理器  </span></span><br><span class="line">                IWindowManager windowManager = getWindowManagerService();</span><br><span class="line">                <span class="comment">//得到IWindowSession代理对象</span></span><br><span class="line">                sWindowSession = windowManager.openSession(</span><br><span class="line">                        <span class="keyword">new</span> IWindowSessionCallback.Stub() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimatorScaleChanged</span><span class="params">(<span class="keyword">float</span> scale)</span> </span>&#123;</span><br><span class="line">                                ValueAnimator.setDurationScale(scale);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        imm.getClient(), imm.getInputContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sWindowSession;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上函数通过WMS的openSession函数创建应用程序与WMS之间的连接通道，即获取IWindowSession代理对象，并将该代理对象保存到ViewRootImpl的静态成员变量sWindowSession中,因此在应用程序进程中有且只有一个IWindowSession代理对象。 [-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IWindowSession <span class="title">openSession</span><span class="params">(IWindowSessionCallback callback, IInputMethodClient client,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInputContext inputContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null client"</span>);</span><br><span class="line">    <span class="keyword">if</span> (inputContext == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null inputContext"</span>);</span><br><span class="line">    Session session = <span class="keyword">new</span> Session(<span class="keyword">this</span>, callback, client, inputContext);</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WMS服务端构造了一个Session实例对象。ViewRootImpl 是一很重要的类，类似 ActivityThread 负责跟AmS通信一样，ViewRootImpl 的一个重要职责就是跟 WmS 通信，它通静态变量 sWindowSession（IWindowSession实例）与 WmS 进行通信。每个应用进程，仅有一个 sWindowSession 对象，它对应了 WmS 中的 Session 子类，WmS 为每一个应用进程分配一个 Session 对象。WindowState 类有一个 IWindow mClient 参数，是在构造方法中赋值的，是由 Session 调用 addWindow 传递过来了，对应了 ViewRootImpl 中的 W 类的实例。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N4-Android-addWindow-ViewRootImpl-WMS.png" alt="Markdown"></p><h4 id="2-7、AttachInfo构造过程"><a href="#2-7、AttachInfo构造过程" class="headerlink" title="2.7、AttachInfo构造过程"></a>2.7、AttachInfo构造过程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    AttachInfo(IWindowSession session, IWindow window, Display display,</span><br><span class="line">        ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) &#123;</span><br><span class="line">    mSession = session;<span class="comment">//IWindowSession代理对象，用于与WMS通信</span></span><br><span class="line">    mWindow = window;<span class="comment">//W对象  </span></span><br><span class="line">    mWindowToken = window.asBinder();<span class="comment">//W本地Binder对象</span></span><br><span class="line">    mDisplay = display;</span><br><span class="line">    mViewRootImpl = viewRootImpl;<span class="comment">//ViewRootImpl实例  </span></span><br><span class="line">    mHandler = handler;<span class="comment">//ViewRootHandler对象  </span></span><br><span class="line">    mRootCallbacks = effectPlayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-8、创建Choreographer对象"><a href="#2-8、创建Choreographer对象" class="headerlink" title="2.8、创建Choreographer对象"></a>2.8、创建Choreographer对象</h4><p>[-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Thread local storage for the choreographer.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">        <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper looper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Choreographer(looper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为调用线程创建一个Choreographer实例，调用线程必须具备消息循环功能，因为ViewRootImpl对象的构造是在应用程序进程的UI主线程中执行的，因此创建的Choreographer对象将使用UI线程消息队列。 [-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    <span class="comment">//创建消息处理Handler</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    <span class="comment">//如果系统使用了Vsync机制，则注册一个FrameDisplayEventReceiver接收器</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper) : <span class="keyword">null</span>;</span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//屏幕刷新周期</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">    <span class="comment">//创建回调数组  </span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FrameDisplayEventReceiver详细过程以后再Android 7.1.2(Android N) Choreographer机制实现过程分析。</p><h4 id="2-9、视图View添加过程"><a href="#2-9、视图View添加过程" class="headerlink" title="2.9、视图View添加过程"></a>2.9、视图View添加过程</h4><p>窗口管理器WindowManagerImpl为当前添加的窗口创建好各种对象后，调用ViewRootImpl的setView函数向WMS服务添加一个窗口对象。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">////将DecorView保存到ViewRootImpl的成员变量mView中</span></span><br><span class="line">            mView = view;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            mSoftInputMode = attrs.softInputMode;</span><br><span class="line">            mWindowAttributesChanged = <span class="keyword">true</span>;</span><br><span class="line">            mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED;</span><br><span class="line">            <span class="comment">//同时将DecorView保存到mAttachInfo中  </span></span><br><span class="line">            mAttachInfo.mRootView = view;</span><br><span class="line">            mAttachInfo.mScalingRequired = mTranslator != <span class="keyword">null</span>;</span><br><span class="line">            mAttachInfo.mApplicationScale =</span><br><span class="line">                    mTranslator == <span class="keyword">null</span> ? <span class="number">1.0f</span> : mTranslator.applicationScale;</span><br><span class="line">            <span class="keyword">if</span> (panelParentView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAttachInfo.mPanelParentWindowToken</span><br><span class="line">                        = panelParentView.getApplicationWindowToken();</span><br><span class="line">            &#125;</span><br><span class="line">            mAdded = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> res; <span class="comment">/* = WindowManagerImpl.ADD_OKAY; */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//1）在添加窗口前进行UI布局  </span></span><br><span class="line">            requestLayout();</span><br><span class="line">            <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">                    &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">                mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">            &#125;</span><br><span class="line">            mForceDecorViewVisibility = (mWindowAttributes.privateFlags</span><br><span class="line">                    &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                collectViewAttributes();</span><br><span class="line">                 <span class="comment">//2)将窗口添加到WMS服务中，mWindow为W本地Binder对象，通过Binder传输到WMS服务端后，变为IWindow代理对象  </span></span><br><span class="line">                res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                        getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                        mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">            &#125; ......</span><br><span class="line">            <span class="comment">//3)建立窗口消息通道  </span></span><br><span class="line">            <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mInputQueue = <span class="keyword">new</span> InputQueue();</span><br><span class="line">                    mInputQueueCallback.onInputQueueCreated(mInputQueue);</span><br><span class="line">                &#125;</span><br><span class="line">                mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">                        Looper.myLooper());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前面的分析可以知道，用户自定义的UI作为一个子View被添加到DecorView中，然后将顶级视图DecorView添加到应用程序进程的窗口管理器中，窗口管理器首先为当前添加的View创建一个ViewRootImpl对象、一个布局参数对象ViewGroup.LayoutParams，然后将这三个对象分别保存到当前应用程序进程的窗口管理器WindowManagerImpl中，最后通过ViewRootImpl对象将当前视图对象注册到WMS服务中。</p><p>ViewRootImpl的setView函数向WMS服务添加一个窗口对象过程：</p><p>(1) requestLayout()在应用程序进程中进行窗口UI布局；</p><p>(2) WindowSession.addToDisplay()向WMS服务注册一个窗口对象；</p><p>(3) 注册应用程序进程端的消息接收通道；</p><h3 id="1-、requestLayout-在应用程序进程中进行窗口UI布局；"><a href="#1-、requestLayout-在应用程序进程中进行窗口UI布局；" class="headerlink" title="(1)、requestLayout()在应用程序进程中进行窗口UI布局；"></a>(1)、requestLayout()在应用程序进程中进行窗口UI布局；</h3><h4 id="2-10、窗口UI布局过程"><a href="#2-10、窗口UI布局过程" class="headerlink" title="2.10、窗口UI布局过程"></a>2.10、窗口UI布局过程</h4><p>requestLayout函数调用里面使用了Hanlder的一个小手段，那就是利用postSyncBarrier添加了一个Barrier（挡板），这个挡板的作用是阻塞普通的同步消息的执行，在挡板被撤销之前，只会执行异步消息，而requestLayout先添加了一个挡板Barrier，之后自己插入了一个异步任务mTraversalRunnable，其主要作用就是保证mTraversalRunnable在所有同步Message之前被执行，保证View绘制的最高优先级。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        checkThread();</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-10-1、添加回调过程"><a href="#2-10-1、添加回调过程" class="headerlink" title="2.10.1、添加回调过程"></a>2.10.1、添加回调过程</h4><p>[-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis;</span><br><span class="line">        <span class="comment">//将要执行的回调封装成CallbackRecord对象，保存到mCallbackQueues数组中</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该函数中考虑了两种情况，一种是系统没有使用Vsync机制，在这种情况下，首先根据屏幕刷新频率计算下一次刷新时间，通过异步消息方式延时执行doFrame()函数实现屏幕刷新。如果系统使用了Vsync机制，并且当前线程具备消息循环，则直接请求Vsync信号，否则就通过主线程来请求Vsync信号。</p><h4 id="2-10-2、Vsync请求过程"><a href="#2-10-2、Vsync请求过程" class="headerlink" title="2.10.2、Vsync请求过程"></a>2.10.2、Vsync请求过程</h4><p>我们知道在Choreographer构造函数中，构造了一个FrameDisplayEventReceiver对象，用于请求并接收Vsync信号，Vsync信号请求过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;  </span><br><span class="line"><span class="comment">//申请Vsync信号  </span></span><br><span class="line">mDisplayEventReceiver.scheduleVsync();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;DisplayEventReceiver.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_DisplayEventReceiver.cpp ]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">        reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">status_t status = receiver-&gt;scheduleVsync();</span><br><span class="line"><span class="keyword">if</span> (status) &#123;</span><br><span class="line">    String8 message;</span><br><span class="line">    message.appendFormat(<span class="string">"Failed to schedule next vertical sync pulse.  status=%d"</span>, status);</span><br><span class="line">    jniThrowRuntimeException(env, message.string());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>VSync请求过程又转交给了DisplayEventReceiver： [-&gt;DisplayEventReceiver.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">status_t DisplayEventReceiver::requestNextVsync() &#123;</span><br><span class="line"><span class="keyword">if</span> (mEventConnection != NULL) &#123;</span><br><span class="line">    mEventConnection-&gt;requestNextVsync();</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又通过IDisplayEventConnection接口来请求Vsync信号，IDisplayEventConnection实现了Binder通信框架，可以跨进程调用，因为Vsync信号请求进程和Vsync产生进程有可能不在同一个进程空间，因此这里就借助IDisplayEventConnection接口来实现。下面通过图来梳理Vsync请求的调用流程：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N5-Android-addWindow-requestNextVsync.png" alt="Markdown"></p><p>需要说明的是/<em>Vsync</em>/之间的代码此时其实还未执行，call requestNextVsync()来告诉系统我要在下一个VSYNC需要被trigger.</p><p>继续ViewRootImpl的setView函数中的WindowSession.addToDisplay()。</p><h4 id="2-、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；"><a href="#2-、mWindowSession-addToDisplay-向WMS服务注册一个窗口对象；" class="headerlink" title="(2) 、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；"></a>(2) 、mWindowSession.addToDisplay()向WMS服务注册一个窗口对象；</h4><p>[Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> reportNewConfig = <span class="keyword">false</span>;</span><br><span class="line">    WindowState attachedWindow = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> origId;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> type = attrs.type;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> DisplayContent displayContent = getDisplayContentLocked(displayId);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</span><br><span class="line">        WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">        AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line">        ......</span><br><span class="line">        WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> WindowManagerGlobal.ADD_APP_EXITING;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mPolicy.adjustWindowParamsLw(win.mAttrs);</span><br><span class="line">        win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs));</span><br><span class="line">        res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> openInputChannels = (outInputChannel != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>  (openInputChannels) &#123;</span><br><span class="line">            win.openInputChannel(outInputChannel);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (addToken) &#123;</span><br><span class="line">            mTokenMap.put(attrs.token, token);</span><br><span class="line">        &#125;</span><br><span class="line">        win.attach();</span><br><span class="line">        mWindowMap.put(client.asBinder(), win);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> imMayMove = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">            win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">            mInputMethodWindow = win;</span><br><span class="line">            addInputMethodWindowToListLocked(win);</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">            mInputMethodDialogs.add(win);</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(<span class="keyword">true</span>));</span><br><span class="line">            imMayMove = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">                mWallpaperControllerLocked.clearLastWallpaperTimeoutTime();</span><br><span class="line">                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWallpaperControllerLocked.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">                displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mInputMonitor.setUpdateInputWindowsNeededLw();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> focusChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (win.canReceiveKeys()) &#123;</span><br><span class="line">            focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">            <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">                imMayMove = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line">        <span class="comment">// Don't do layout here, the window must call</span></span><br><span class="line">        <span class="comment">// relayout to be displayed, so we'll do it there.</span></span><br><span class="line">        <span class="keyword">if</span> (focusChanged) &#123;</span><br><span class="line">            mInputMonitor.setInputFocusLw(mCurrentFocus, <span class="keyword">false</span> <span class="comment">/*updateInputWindows*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mInputMonitor.updateInputWindowsLw(<span class="keyword">false</span> <span class="comment">/*force*/</span>);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (reportNewConfig) &#123;</span><br><span class="line">        sendNewConfiguration();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道当应用程序进程添加一个DecorView到窗口管理器时，会为当前添加的窗口创建ViewRootImpl对象，同时构造了一个W本地Binder对象，无论是窗口视图对象DecorView还是ViewRootImpl对象，都只是存在于应用程序进程中，在添加窗口过程中仅仅将该窗口的W对象传递给WMS服务，经过Binder传输后，到达WMS服务端进程后变为IWindow.Proxy代理对象，因此该函数的参数client的类型为IWindow.Proxy。参数attrs的类型为WindowManager.LayoutParams，在应用程序进程启动Activity时，handleResumeActivity()函数通过WindowManager.LayoutParams l = r.window.getAttributes();来得到应用程序窗口布局参数，由于WindowManager.LayoutParams实现了Parcelable接口，因此WindowManager.LayoutParams对象可以跨进程传输，WMS服务的addWindow函数中的attrs参数就是应用程序进程发送过来的窗口布局参数。在WindowManagerImpl的addView函数中为窗口布局参数设置了相应的token，如果是应用程序窗口，则布局参数的token设为W本地Binder对象。如果不是应用程序窗口，同时当前窗口没有父窗口，则设置token为当前窗口的IApplicationToken.Proxy代理对象，否则设置为父窗口的IApplicationToken.Proxy代理对象，由于应用程序和WMS分属于两个不同的进程空间，因此经过Binder传输后，布局参数的令牌attrs.token就转变为IWindow.Proxy或者Token。以上函数首先根据布局参数的token等信息构造一个WindowToken对象，然后在构造一个WindowState对象，并将添加的窗口信息记录到mTokenMap和mWindowMap哈希表中。</p><p>在WMS服务端创建了所需对象后，接着调用了WindowState的attach()来进一步完成窗口添加。 [WindowState.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Attaching "</span> + <span class="keyword">this</span> + <span class="string">" token="</span> + mToken</span><br><span class="line">        + <span class="string">", list="</span> + mToken.windows);</span><br><span class="line">    mSession.windowAddedLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">windowAddedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceSession == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (WindowManagerService.localLOGV) Slog.v(</span><br><span class="line">            TAG_WM, <span class="string">"First window added to "</span> + <span class="keyword">this</span> + <span class="string">", creating SurfaceSession"</span>);</span><br><span class="line">        mSurfaceSession = <span class="keyword">new</span> SurfaceSession();</span><br><span class="line">        <span class="keyword">if</span> (SHOW_TRANSACTIONS) Slog.i(</span><br><span class="line">                TAG_WM, <span class="string">"  NEW SURFACE SESSION "</span> + mSurfaceSession);</span><br><span class="line">        mService.mSessions.add(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123;</span><br><span class="line">            mService.dispatchNewAnimatorScaleLocked(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNumWindow++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="SurfaceSession建立过程"><a href="#SurfaceSession建立过程" class="headerlink" title="SurfaceSession建立过程"></a>SurfaceSession建立过程</h5><p>SurfaceSession对象承担了应用程序与SurfaceFlinger之间的通信过程，每一个需要与SurfaceFlinger进程交互的应用程序端都需要创建一个SurfaceSession对象。</p><p>客户端请求 [SurfaceSession.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SurfaceSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNativeClient = nativeCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的SurfaceSession对象构造过程会通过JNI在native层创建一个SurfaceComposerClient对象。</p><p>[android_view_SurfaceSession.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">SurfaceComposerClient* client = <span class="keyword">new</span> SurfaceComposerClient();</span><br><span class="line">client-&gt;incStrong((<span class="keyword">void</span>*)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的SurfaceSession对象与C++层的SurfaceComposerClient对象之间是一对一关系。 [SurfaceComposerClient.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SurfaceComposerClient::SurfaceComposerClient()</span><br><span class="line">: mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;</span><br><span class="line"><span class="keyword">void</span> SurfaceComposerClient::onFirstRef() &#123;</span><br><span class="line"><span class="comment">//得到SurfaceFlinger的代理对象BpSurfaceComposer  </span></span><br><span class="line"><span class="function">sp&lt;ISurfaceComposer&gt; <span class="title">sm</span><span class="params">(ComposerService::getComposerService()</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (sm != <span class="number">0</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection();</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="number">0</span>) &#123;</span><br><span class="line">        mClient = conn;</span><br><span class="line">        mStatus = NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient继承于RefBase类，当第一次被强引用时，onFirstRef函数被回调，在该函数中SurfaceComposerClient会请求SurfaceFlinger为当前应用程序创建一个Client对象，专门接收该应用程序的请求，在SurfaceFlinger端创建好Client本地Binder对象后，将该Binder代理对象返回给应用程序端，并保存在SurfaceComposerClient的成员变量mClient中。</p><p>服务端处理 在SurfaceFlinger服务端为应用程序创建交互的Client对象 [SurfaceFlinger.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;ISurfaceComposerClient&gt; bclient;</span><br><span class="line"><span class="function">sp&lt;Client&gt; <span class="title">client</span><span class="params">(new Client(<span class="keyword">this</span>)</span>)</span>;</span><br><span class="line">status_t err = client-&gt;initCheck();</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    bclient = client;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bclient;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N6-Android-addWindow-SF-Client.png" alt="Markdown"></p><p>/<strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong>Vsync<strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong>/</p><h3 id="Vsync信号处理"><a href="#Vsync信号处理" class="headerlink" title="Vsync信号处理"></a>Vsync信号处理</h3><p>以上是请求过程，FrameDisplayEventReceiver对象用于请求并接收Vsync信号，当Vsync信号到来时，系统会自动调用其onVsync()函数，后面会回调到FrameDisplayEventReceiver.run方法（Why “同步分割栏”？<a href="http://xfenglin.com/a/12007076930.html" target="_blank" rel="noopener">再分析</a>），再回调函数中执行doFrame()实现屏幕刷新。 当VSYNC信号到达时，Choreographer doFrame()函数被调用 [-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos;</span><br><span class="line">        <span class="comment">//保存起始时间</span></span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">//由于Vsync事件处理采用的是异步方式，因此这里计算消息发送与函数调用开始之间所花费的时间</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">//计算函数调用期间所错过的帧数  </span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                        + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果frameTimeNanos小于一个屏幕刷新周期，则重新请求VSync信号</span></span><br><span class="line">        <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//分别回调CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL、CALLBACK_COMMIT事件  </span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N7-Android-addWindow-Vsync-time.png" alt="Markdown"><br>Choreographer类中分别定义了CallbackRecord、CallbackQueue内部类，CallbackQueue是一个按时间先后顺序保存CallbackRecord的单向循环链表。 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N8-Android-addWindow-CallBackRecord.png" alt="Markdown"><br>在Choreographer中定义了三个CallbackQueue队列，用数组mCallbackQueues表示，用于分别保存CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL这三种类型的Callback，当调用Choreographer类的postCallback()函数时，就是往指定类型的CallbackQueue队列中通过addCallbackLocked()函数添加一个CallbackRecord项：首先构造一个CallbackRecord对象，然后按时间先后顺序插入到CallbackQueue链表中。从代码注释中，我们可以知道CALLBACK_INPUT是指输入回调，该回调优先级最高，首先得到执行，而CALLBACK_TRAVERSAL是指处理布局和绘图的回调，只有在所有异步消息都执行完后才得到执行，CALLBACK_ANIMATION是指动画回调，比CALLBACK_TRAVERSAL优先执行，从doFrame()函数中的doCallbacks调用就能印证这点。 当Vsync事件到来时，顺序执行CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL 和CALLBACK_COMMIT 对应CallbackQueue队列中注册的回调。 [-&gt;Choreographer.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        <span class="comment">//从指定类型的CallbackQueue队列中查找执行时间到的CallbackRecord</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = now - frameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                    mDebugPrintNextFrameTimeDelta = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">          <span class="comment">//由于CallbackQueues是按时间先后顺序排序的，因此遍历执行所有时间到的CallbackRecord  </span></span><br><span class="line">            c.run(frameTimeNanos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">                recycleCallbackLocked(callbacks);</span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道Choreographer对外提供了两个接口函数用于注册指定的Callback，postCallback()用于注册Runnable对象，而postFrameCallback()函数用于注册FrameCallback对象，无论注册的是Runnable对象还是FrameCallback对象，在CallbackRecord对象中统一装箱为Object类型。在执行其回调函数时，就需要区别这两种对象类型，如果注册的是Runnable对象，则调用其run()函数，如果注册的是FrameCallback对象，则调用它的doFrame()函数。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N9-Android-addWindow-Choreographer.png" alt="Markdown"></p><h4 id="2-11、视图View添加过程"><a href="#2-11、视图View添加过程" class="headerlink" title="2.11、视图View添加过程"></a>2.11、视图View添加过程</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N10-Android-addWindow-AT-WMS.png" alt="Markdown"></p><p>关于Choreographer的postCallback()用法在前面进行了详细的介绍，当Vsync事件到来时，mTraversalRunnable对象的run()函数将被调用。</p><p>mTraversalRunnable对象的类型为TraversalRunnable，该类实现了Runnable接口，在其run()函数中调用了doTraversal()函数来完成窗口布局。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>performTraversals函数相当复杂，其主要实现以下几个重要步骤：</p><p>1.执行窗口测量；</p><p>2.执行窗口注册；</p><p>3.执行窗口布局；</p><p>4.执行窗口绘图；</p><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    mIsInTraversal = <span class="keyword">true</span>;</span><br><span class="line">    mWillDrawSoon = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> newSurface = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> surfaceChanged = <span class="keyword">false</span>;</span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">    <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewVisibility = getHostVisibility();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> viewVisibilityChanged = !mFirst</span><br><span class="line">            &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> viewUserVisibilityChanged = !mFirst &amp;&amp;</span><br><span class="line">            ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE));</span><br><span class="line"></span><br><span class="line">    WindowManager.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mWindowAttributesChanged) &#123;</span><br><span class="line">        mWindowAttributesChanged = <span class="keyword">false</span>;</span><br><span class="line">        surfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">        params = lp;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************执行窗口测量******************/</span>  </span><br><span class="line">    <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/****************向WMS服务添加窗口******************/</span>  </span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">            viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            ......</span><br><span class="line">                 <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口布局******************/</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">            || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">/****************查找窗口焦点******************/</span></span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mView.hasFocus()) &#123;</span><br><span class="line">                mView.requestFocus(View.FOCUS_FORWARD);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">    <span class="keyword">if</span> (regainedFocus) &#123;</span><br><span class="line">        mLostWindowFocus = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">        mLostWindowFocus = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changedVisibility || regainedFocus) &#123;</span><br><span class="line">        <span class="comment">// Toasts are presented as notifications - don't present them as windows as well</span></span><br><span class="line">        <span class="keyword">boolean</span> isToast = (mWindowAttributes == <span class="keyword">null</span>) ? <span class="keyword">false</span></span><br><span class="line">                : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">        <span class="keyword">if</span> (!isToast) &#123;</span><br><span class="line">            host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFirst = <span class="keyword">false</span>;</span><br><span class="line">    mWillDrawSoon = <span class="keyword">false</span>;</span><br><span class="line">    mNewSurfaceNeeded = <span class="keyword">false</span>;</span><br><span class="line">    mActivityRelaunched = <span class="keyword">false</span>;</span><br><span class="line">    mViewVisibility = viewVisibility;</span><br><span class="line">    mHadWindowFocus = hasWindowFocus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> imTarget = WindowManager.LayoutParams</span><br><span class="line">                .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">        <span class="keyword">if</span> (imTarget != mLastWasImTarget) &#123;</span><br><span class="line">            mLastWasImTarget = imTarget;</span><br><span class="line">            InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">            <span class="keyword">if</span> (imm != <span class="keyword">null</span> &amp;&amp; imTarget) &#123;</span><br><span class="line">                imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                        mWindowAttributes.softInputMode,</span><br><span class="line">                        !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember if we must report the next draw.</span></span><br><span class="line">    <span class="keyword">if</span> ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">        mReportNextDraw = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/****************执行窗口绘制******************/</span>  </span><br><span class="line">    <span class="keyword">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isViewVisible) &#123;</span><br><span class="line">            <span class="comment">// Try again</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsInTraversal = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、执行窗口测量performMeasure"><a href="#1、执行窗口测量performMeasure" class="headerlink" title="1、执行窗口测量performMeasure()"></a>1、执行窗口测量performMeasure()</h4><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、执行窗口注册relayoutWindow；"><a href="#2、执行窗口注册relayoutWindow；" class="headerlink" title="2、执行窗口注册relayoutWindow；"></a>2、执行窗口注册relayoutWindow；</h4><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过前面获取的IWindowSession代理对象请求WMS服务执行窗口布局，mSurface是ViewRootImpl的成员变量 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure><p>[-&gt;Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create an empty surface, which will later be filled in by readFromParcel().</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Surface构造函数仅仅创建了一个空Surface对象，并没有对该Surface进程native层的初始化，到此我们知道应用程序进程为每个窗口对象都创建了一个Surface对象。并且将该Surface通过跨进程方式传输给WMS服务进程，我们知道，在Android系统中，如果一个对象需要在不同进程间传输，必须实现Parcelable接口，Surface类正好实现了Parcelable接口。ViewRootImpl通过IWindowSession接口请求WMS的完整过程如下：</p><p>[-&gt;IWindowSession.java$ Proxy]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* This file is auto-generated.  DO NOT MODIFY</span></span><br><span class="line"><span class="comment">*  * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(android.view.IWindow window, <span class="keyword">int</span> seq, android.view.WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface)</span> <span class="keyword">throws</span> android.os.RemoteException </span>&#123;</span><br><span class="line">android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line"><span class="keyword">int</span> _result;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">0</span> != _reply.readInt())) &#123;</span><br><span class="line">        outSurface.readFromParcel(_reply);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从该函数的实现可以看出，应用程序进程中创建的Surface对象并没有传递到WMS服务进程，只是读取WMS服务进程返回来的Surface。那么WMS服务进程是如何响应应用程序进程布局请求的呢？</p><p>[-&gt;IWindowSession.java$ Stub]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (code)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> TRANSACTION_relayout:</span><br><span class="line">  &#123;</span><br><span class="line">    ......</span><br><span class="line">    android.view.Surface _arg15;</span><br><span class="line">    _arg15 = <span class="keyword">new</span> android.view.Surface();</span><br><span class="line">    <span class="keyword">int</span> _result = <span class="keyword">this</span>.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(_result);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> ((_arg15!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">    reply.writeInt(<span class="number">1</span>);</span><br><span class="line">    _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数可以看出，WMS服务在响应应用程序进程请求添加窗口时，首先在当前进程空间创建一个Surface对象，然后调用Session的relayout()函数进一步完成窗口添加过程，最后将WMS服务中创建的Surface返回给应用程序进程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N11-Android-addWindow-App-WMS-Surface.png" alt="Markdown"></p><p>到目前为止，在应用程序进程和WMS服务进程分别创建了一个Surface对象，但是他们调用的都是Surface的无参构造函数，在该构造函数中并未真正初始化native层的Surface，那native层的Surface是在那里创建的呢？</p><p>[-&gt;Session.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">                (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">createSurfaceControl</span><span class="params">(Surface outSurface, <span class="keyword">int</span> result, WindowState win,</span></span></span><br><span class="line"><span class="function"><span class="params">        WindowStateAnimator winAnimator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!win.mHasSurface) &#123;</span><br><span class="line">        result |= RELAYOUT_RES_SURFACE_CHANGED;</span><br><span class="line">    &#125;</span><br><span class="line">    WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked();</span><br><span class="line">    <span class="keyword">if</span> (surfaceController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        surfaceController.getSurface(outSurface);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        outSurface.release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowSurfaceController.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getSurface</span><span class="params">(Surface outSurface)</span> </span>&#123;</span><br><span class="line">    outSurface.copyFrom(mSurfaceControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowStateAnimator.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">WindowSurfaceController <span class="title">createSurfaceLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mSurfaceController = <span class="keyword">new</span> WindowSurfaceController(mSession.mSurfaceSession,</span><br><span class="line">                attrs.getTitle().toString(),</span><br><span class="line">                width, height, format, flags, <span class="keyword">this</span>);</span><br><span class="line">        w.setHasSurface(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mSurfaceController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;WindowSurfaceController.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WindowSurfaceController</span><span class="params">(SurfaceSession s,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags, WindowStateAnimator animator)</span> </span>&#123;</span><br><span class="line">    mAnimator = animator;</span><br><span class="line">    mSurfaceW = w;</span><br><span class="line">    mSurfaceH = h;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (animator.mWin.isChildWindow() &amp;&amp;</span><br><span class="line">            animator.mWin.mSubLayer &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            animator.mWin.mAppToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mSurfaceControl = <span class="keyword">new</span> SurfaceControl(</span><br><span class="line">                s, name, w, h, format, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-12、Surface创建过程"><a href="#2-12、Surface创建过程" class="headerlink" title="2.12、Surface创建过程"></a>2.12、Surface创建过程</h4><p>[-&gt;SurfaceControl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SurfaceControl</span><span class="params">(SurfaceSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mNativeObject = nativeCreate(session, name, w, h, format, flags);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_SurfaceControl.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreate</span><span class="params">(JNIEnv* env, jclass clazz, jobject sessionObj,</span></span></span><br><span class="line"><span class="function"><span class="params">    jstring nameStr, jint w, jint h, jint format, jint flags)</span> </span>&#123;</span><br><span class="line"><span class="function">ScopedUtfChars <span class="title">name</span><span class="params">(env, nameStr)</span></span>;</span><br><span class="line">sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));</span><br><span class="line">sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface(</span><br><span class="line">        String8(name.c_str()), w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (surface == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    jniThrowException(env, OutOfResourcesException, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">surface-&gt;incStrong((<span class="keyword">void</span> *)nativeCreate);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先得到前面创建好的SurfaceComposerClient对象，通过该对象向SurfaceFlinger端的Client对象发送创建Surface的请求，最后得到一个SurfaceControl对象。 [-&gt;SurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface(</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">    <span class="keyword">uint32_t</span> w,</span><br><span class="line">    <span class="keyword">uint32_t</span> h,</span><br><span class="line">    PixelFormat format,</span><br><span class="line">    <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    &#123;</span><br><span class="line">sp&lt;SurfaceControl&gt; sur;</span><br><span class="line"><span class="keyword">if</span> (mStatus == NO_ERROR) &#123;</span><br><span class="line">    sp&lt;IBinder&gt; handle;</span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; gbp;</span><br><span class="line">    <span class="keyword">status_t</span> err = mClient-&gt;createSurface(name, w, h, format, flags,</span><br><span class="line">            &amp;handle, &amp;gbp);</span><br><span class="line">    ALOGE_IF(err, <span class="string">"SurfaceComposerClient::createSurface error %s"</span>, strerror(-err));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        sur = <span class="keyword">new</span> SurfaceControl(<span class="keyword">this</span>, handle, gbp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceComposerClient将Surface创建请求转交给保存在其成员变量中的Bp SurfaceComposerClient对象来完成，在SurfaceFlinger端的Client本地对象会返回一个ISurface代理对象给应用程序，通过该代理对象为应用程序当前创建的Surface创建一个SurfaceControl对象。 [ISurfaceComposerClient.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">createSurface</span><span class="params">(<span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> width,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IBinder&gt;* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">        sp&lt;IGraphicBufferProducer&gt;* gbp)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    ......</span><br><span class="line">    remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply);</span><br><span class="line">    *handle = reply.readStrongBinder();</span><br><span class="line">    *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder());</span><br><span class="line">    <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Client.cpp] MessageCreateSurface消息是专门为应用程序请求创建Surface而定义的一种消息类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle,</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">     * have access to the GL context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">        SurfaceFlinger* flinger;</span><br><span class="line">        Client* client;</span><br><span class="line">        sp&lt;IBinder&gt;* handle;</span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">        <span class="keyword">status_t</span> result;</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">        <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">        PixelFormat format;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">                <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">                <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">                sp&lt;IBinder&gt;* handle,</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">            : flinger(flinger), client(client),</span><br><span class="line">              handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">              name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                    handle, gbp);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">            name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">    mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">    &#125;</span><br><span class="line">Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。</span><br><span class="line">[-&gt;SurfaceFlinger.cpp]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> SurfaceFlinger::createLayer(</span><br><span class="line">        <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">        <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">        sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">    <span class="comment">//ALOGD("createLayer for (%d x %d), name=%s", w, h, name.string());</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result = NO_ERROR;</span><br><span class="line"></span><br><span class="line">    sp&lt;Layer&gt; layer;</span><br><span class="line">    <span class="comment">////根据flags创建不同类型的layer</span></span><br><span class="line">    <span class="keyword">switch</span> (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceNormal:</span><br><span class="line">            result = createNormalLayer(client,</span><br><span class="line">                    name, w, h, flags, format,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ISurfaceComposerClient::eFXSurfaceDim:</span><br><span class="line">            result = createDimLayer(client,</span><br><span class="line">                    name, w, h, flags,</span><br><span class="line">                    handle, gbp, &amp;layer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = BAD_VALUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将创建好的Layer对象保存在Client中  </span></span><br><span class="line">    result = addClientLayer(client, *handle, *gbp, layer);</span><br><span class="line">    <span class="keyword">if</span> (result != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setTransactionFlags(eTransactionNeeded);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger根据标志位创建对应类型的Surface，当前系统定义了2种类型的Layer: [-&gt;ISurfaceComposerClient.h]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eFXSurfaceNormal    = 0x00000000,</span><br><span class="line">eFXSurfaceDim       = 0x00020000,</span><br></pre></td></tr></table></figure><p>[-&gt;SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::createNormalLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags, PixelFormat&amp; format,</span><br><span class="line">    sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;</span><br><span class="line"><span class="comment">// initialize the surfaces</span></span><br><span class="line"><span class="keyword">switch</span> (format) &#123;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSPARENT:</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_TRANSLUCENT:</span><br><span class="line">    format = PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PIXEL_FORMAT_OPAQUE:</span><br><span class="line">    format = PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在SurfaceFlinger端为应用程序的Surface创建对应的Layer对象  </span></span><br><span class="line">*outLayer = <span class="keyword">new</span> Layer(<span class="keyword">this</span>, client, name, w, h, flags);</span><br><span class="line"><span class="keyword">status_t</span> err = (*outLayer)-&gt;setBuffers(w, h, format, flags);</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    *handle = (*outLayer)-&gt;getHandle();</span><br><span class="line">    *gbp = (*outLayer)-&gt;getProducer();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGE_IF(err, <span class="string">"createNormalLayer() failed (%s)"</span>, strerror(-err));</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger服务端为应用程序创建的Surface创建对应的Layer对象。应用程序请求创建Surface过程如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N12-Android-addWindow-createSurface.png" alt="Markdown"></p><p>第一次强引用Layer对象时，onFirstRef()函数被回调 [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFirstRef() &#123;</span><br><span class="line"><span class="comment">// Creates a custom BufferQueue for SurfaceFlingerConsumer to use</span></span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line"><span class="comment">//创建BufferQueue对象</span></span><br><span class="line">BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">mProducer = <span class="keyword">new</span> MonitoredProducer(producer, mFlinger);</span><br><span class="line">mSurfaceFlingerConsumer = <span class="keyword">new</span> SurfaceFlingerConsumer(consumer, mTextureName,</span><br><span class="line">        <span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(<span class="number">0</span>));</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setContentsChangedListener(<span class="keyword">this</span>);</span><br><span class="line">mSurfaceFlingerConsumer-&gt;setName(mName);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TARGET_DISABLE_TRIPLE_BUFFERING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> <span class="meta-string">"disabling triple buffering"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">mProducer-&gt;setMaxDequeuedBufferCount(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());</span><br><span class="line">updateTransformHint(hw);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据buffer可用监听器的注册过程，我们知道，当生产者也就是应用程序填充好图形buffer数据后，通过回调方式通知消费者的</p><h4 id="BufferQueue构造过程"><a href="#BufferQueue构造过程" class="headerlink" title="BufferQueue构造过程"></a>BufferQueue构造过程</h4><p>[-&gt;BufferQueue.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer,</span><br><span class="line">    sp&lt;IGraphicBufferConsumer&gt;* outConsumer,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">sp&lt;BufferQueueCore&gt; core(<span class="keyword">new</span> BufferQueueCore(allocator));</span><br><span class="line">sp&lt;IGraphicBufferProducer&gt; producer(<span class="keyword">new</span> BufferQueueProducer(core));</span><br><span class="line">sp&lt;IGraphicBufferConsumer&gt; consumer(<span class="keyword">new</span> BufferQueueConsumer(core));</span><br><span class="line">*outProducer = producer;</span><br><span class="line">*outConsumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;BufferQueueCore.cpp] 所以核心都是这个BufferQueueCore，他是管理图形缓冲区的中枢。这里举一个SurfaceTexture的例子，来看看他们之间的关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N13-Android-addWindow-BufferQueue.jpg" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BufferQueueCore::BufferQueueCore(<span class="keyword">const</span> sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :</span><br><span class="line">mAllocator(allocator),</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (allocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService());</span><br><span class="line">    mAllocator = composer-&gt;createGraphicBufferAlloc();</span><br><span class="line">    <span class="keyword">if</span> (mAllocator == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        BQ_LOGE(<span class="string">"createGraphicBufferAlloc failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numStartingBuffers = getMaxBufferCountLocked();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; numStartingBuffers; s++) &#123;</span><br><span class="line">    mFreeSlots.insert(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS;</span><br><span class="line">        s++) &#123;</span><br><span class="line">    mUnusedSlots.push_front(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferQueueCore类中定义了一个64项的数据mSlots，是一个容量大小为64的数组，因此BufferQueueCore可以管理最多64块的GraphicBuffer。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N14-Android-addWindow-slot.jpg" alt="Markdown"></p><p>[-&gt;ISurfaceComposer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">virtual</span> sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()</span><br><span class="line">&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());</span><br><span class="line">    remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply);</span><br><span class="line">    <span class="keyword">return</span> interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()</span><br><span class="line">&#123;</span><br><span class="line">sp&lt;GraphicBufferAlloc&gt; gba(<span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"><span class="keyword">return</span> gba;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GraphicBufferAlloc构造过程"><a href="#GraphicBufferAlloc构造过程" class="headerlink" title="GraphicBufferAlloc构造过程"></a>GraphicBufferAlloc构造过程</h4><p>[-&gt;GraphicBufferAlloc.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(<span class="keyword">uint32_t</span> width,</span><br><span class="line">    <span class="keyword">uint32_t</span> height, PixelFormat format, <span class="keyword">uint32_t</span> usage,</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> requestorName, <span class="keyword">status_t</span>* error) &#123;</span><br><span class="line">sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(</span><br><span class="line">        width, height, format, usage, <span class="built_in">std</span>::move(requestorName)));</span><br><span class="line"><span class="keyword">status_t</span> err = graphicBuffer-&gt;initCheck();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> graphicBuffer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图形缓冲区创建过程"><a href="#图形缓冲区创建过程" class="headerlink" title="图形缓冲区创建过程"></a>图形缓冲区创建过程</h4><p>[-&gt;GraphicBuffer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer(<span class="keyword">uint32_t</span> inWidth, <span class="keyword">uint32_t</span> inHeight,</span><br><span class="line">    PixelFormat inFormat, <span class="keyword">uint32_t</span> inUsage, <span class="built_in">std</span>::<span class="built_in">string</span> requestorName)</span><br><span class="line">: BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),</span><br><span class="line">  mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">width  =</span><br><span class="line">height =</span><br><span class="line">stride =</span><br><span class="line">format =</span><br><span class="line">usage  = <span class="number">0</span>;</span><br><span class="line">handle = <span class="literal">NULL</span>;</span><br><span class="line">mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage,</span><br><span class="line">        <span class="built_in">std</span>::move(requestorName));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>根据图形buffer的宽高、格式等信息为图形缓冲区分配存储空间。</p><p>使用GraphicBufferAllocator对象来为图形缓冲区分配内存空间，GraphicBufferAllocator是对Gralloc模块中的gpu设备的封装类。关于GraphicBufferAllocator内存分配过程请查看<a href="http://blog.csdn.net/yangwen123/article/details/12231687" target="_blank" rel="noopener">Android图形缓冲区分配过程源码分析</a>图形缓冲区分配完成后，还会映射到SurfaceFlinger服务进程的虚拟地址空间。</p><h4 id="Android图形缓冲区分配过程源码分析"><a href="#Android图形缓冲区分配过程源码分析" class="headerlink" title="Android图形缓冲区分配过程源码分析"></a>Android图形缓冲区分配过程源码分析</h4><p>[-&gt;Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Layer::Layer(SurfaceFlinger* flinger, <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> String8&amp; name, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">:   contentDirty(<span class="literal">false</span>),</span><br><span class="line">    sequence(<span class="keyword">uint32_t</span>(android_atomic_inc(&amp;sSequence))),</span><br><span class="line">    mFlinger(flinger),</span><br><span class="line">    mTextureName(<span class="number">-1U</span>),</span><br><span class="line">    mPremultipliedAlpha(<span class="literal">true</span>),</span><br><span class="line">    mName(<span class="string">"unnamed"</span>),</span><br><span class="line">    mFormat(PIXEL_FORMAT_NONE),</span><br><span class="line">    ......&#123;</span><br><span class="line">mCurrentCrop.makeInvalid();</span><br><span class="line">mFlinger-&gt;getRenderEngine().genTextures(<span class="number">1</span>, &amp;mTextureName);</span><br><span class="line">mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此才算真正创建了一个可用于绘图的Surface (Layer)，从上面的分析我们可以看出，在WMS服务进程端，其实创建了两个Java层的Surface对象，第一个Surface使用了无参构造函数，仅仅构造一个Surface对象而已，而第二个Surface却使用了有参构造函数，参数指定了图象宽高等信息，这个Java层Surface对象还会在native层请求SurfaceFlinger创建一个真正能用于绘制图象的native层Surface。最后通过浅拷贝的方式将第二个Surface复制到第一个Surface中，最后通过writeToParcel方式写回到应用程序进程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N15-Android-addWindow-createSurface-Layer.png" alt="Markdown"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(SurfaceControl other)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> surfaceControlPtr = other.mNativeObject;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">long</span> newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mNativeObject != <span class="number">0</span>) &#123;</span><br><span class="line">            nativeRelease(mNativeObject);</span><br><span class="line">        &#125;</span><br><span class="line">        setNativeObjectLocked(newNativeObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2号Surface引用到了3号Surface的SurfaceControl对象后，通过writeToParcel()函数写会到应用程序进程。 [Surface.java]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        @Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dest == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"dest must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        dest.writeString(mName);</span><br><span class="line">        dest.writeInt(mIsSingleBuffered ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        nativeWriteToParcel(mNativeObject, dest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != <span class="number">0</span>) &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWriteToParcel</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject parcelObj)</span> </span>&#123;</span><br><span class="line">Parcel* parcel = parcelForJavaObject(env, parcelObj);</span><br><span class="line"><span class="keyword">if</span> (parcel == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    doThrowNPE(env);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;Surface&gt; self(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line">android::view::Surface surfaceShim;</span><br><span class="line"><span class="keyword">if</span> (self != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Calling code in Surface.java has already written the name of the Surface</span></span><br><span class="line"><span class="comment">// to the Parcel</span></span><br><span class="line">surfaceShim.writeToParcel(parcel, <span class="comment">/*nameAlreadyWritten*/</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == null) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"source must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        <span class="comment">// nativeReadFromParcel() will either return mNativeObject, or</span></span><br><span class="line">        <span class="comment">// create a new native Surface and return it after reducing</span></span><br><span class="line">        <span class="comment">// the reference count on mNativeObject.  Either way, it is</span></span><br><span class="line">        <span class="comment">// not necessary to call nativeRelease() here.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        mName = source.readString();</span><br><span class="line">        mIsSingleBuffered = source.readInt() != <span class="number">0</span>;</span><br><span class="line">        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用程序进程中的1号Surface按相反顺序读取WMS服务端返回过来的Binder对象等数据，并构造一个native层的Surface对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeCreateFromSurfaceControl</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong surfaceControlNativeObj)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is used by the WindowManagerService just after constructing</span></span><br><span class="line"><span class="comment"> * a Surface and is necessary for returning the Surface reference to</span></span><br><span class="line"><span class="comment"> * the caller. At this point, we should only have a SurfaceControl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">sp&lt;SurfaceControl&gt; ctrl(<span class="keyword">reinterpret_cast</span>&lt;SurfaceControl *&gt;(surfaceControlNativeObj));</span><br><span class="line">sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());</span><br><span class="line"><span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    surface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(surface.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Activity可以有一个或多个Surface，默认情况下一个Activity只有一个Surface，当Activity中使用SurfaceView时，就存在多个Surface。Activity默认surface是在relayoutWindow过程中由WMS服务创建的，然后回传给应用程序进程，我们知道一个Surface其实就是应用程序端的本地窗口，关于Surface的初始化过程这里就不在介绍。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N16-Android-addWindow-surface-create-client.png" alt="Markdown"></p><h4 id="应用程序本地窗口Surface创建过程"><a href="#应用程序本地窗口Surface创建过程" class="headerlink" title="应用程序本地窗口Surface创建过程"></a>应用程序本地窗口Surface创建过程</h4><p>从前面分析可知，SurfaceFlinger在处理应用程序请求创建Surface中，在SurfaceFlinger服务端仅仅创建了Layer对象，那么应用程序本地窗口Surface在什么时候、什么地方创建呢？</p><p>为应用程序创建好了Layer对象并返回ISurface的代理对象给应用程序，应用程序通过该代理对象创建了一个SurfaceControl对象，Java层Surface需要通过android_view_Surface.cpp中的JNI函数来操作native层的Surface，在操作native层Surface前，首先需要获取到native的Surface，应用程序本地窗口Surface就是在这个时候创建的。 [-&gt;SurfaceControl.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;Surface&gt; SurfaceControl::getSurface() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">Mutex::Autolock _l(mLock);</span><br><span class="line"><span class="keyword">if</span> (mSurfaceData == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// This surface is always consumed by SurfaceFlinger, so the</span></span><br><span class="line">    <span class="comment">// producerControlledByApp value doesn't matter; using false.</span></span><br><span class="line">    mSurfaceData = <span class="keyword">new</span> Surface(mGraphicBufferProducer, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mSurfaceData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Surface::Surface(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer,</span><br><span class="line">    <span class="keyword">bool</span> controlledByApp)</span><br><span class="line">: mGraphicBufferProducer(bufferProducer),</span><br><span class="line">  mCrop(Rect::EMPTY_RECT),</span><br><span class="line">  mGenerationNumber(<span class="number">0</span>),</span><br><span class="line">  mSharedBufferMode(<span class="literal">false</span>),</span><br><span class="line">  mAutoRefresh(<span class="literal">false</span>),</span><br><span class="line">  mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT),</span><br><span class="line">  mSharedBufferHasBeenQueued(<span class="literal">false</span>),</span><br><span class="line">  mNextFrameNumber(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// Initialize the ANativeWindow function pointers.</span></span><br><span class="line">ANativeWindow::setSwapInterval  = hook_setSwapInterval;</span><br><span class="line">ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;</span><br><span class="line">ANativeWindow::cancelBuffer     = hook_cancelBuffer;</span><br><span class="line">ANativeWindow::queueBuffer      = hook_queueBuffer;</span><br><span class="line">ANativeWindow::query            = hook_query;</span><br><span class="line">ANativeWindow::perform          = hook_perform;</span><br><span class="line"></span><br><span class="line">ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;</span><br><span class="line">ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::minSwapInterval) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(ANativeWindow::maxSwapInterval) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mReqWidth = <span class="number">0</span>;</span><br><span class="line">mReqHeight = <span class="number">0</span>;</span><br><span class="line">mReqFormat = <span class="number">0</span>;</span><br><span class="line">mReqUsage = <span class="number">0</span>;</span><br><span class="line">mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;</span><br><span class="line">mDataSpace = HAL_DATASPACE_UNKNOWN;</span><br><span class="line">mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;</span><br><span class="line">mTransform = <span class="number">0</span>;</span><br><span class="line">mStickyTransform = <span class="number">0</span>;</span><br><span class="line">mDefaultWidth = <span class="number">0</span>;</span><br><span class="line">mDefaultHeight = <span class="number">0</span>;</span><br><span class="line">mUserWidth = <span class="number">0</span>;</span><br><span class="line">mUserHeight = <span class="number">0</span>;</span><br><span class="line">mTransformHint = <span class="number">0</span>;</span><br><span class="line">mConsumerRunningBehind = <span class="literal">false</span>;</span><br><span class="line">mConnectedToCpu = <span class="literal">false</span>;</span><br><span class="line">mProducerControlledByApp = controlledByApp;</span><br><span class="line">mSwapIntervalZero = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建完应用程序本地窗口Surface后，想要在该Surface上绘图，首先需要为该Surface分配图形buffer。我们前面介绍了Android应用程序图形缓冲区的分配都是由SurfaceFlinger服务进程来完成，在请求创建Surface时，在服务端创建了一个BufferQueue本地Binder对象，该对象负责管理应用程序一个本地窗口Surface的图形缓冲区。</p><h5 id="3、执行窗口布局performLayout"><a href="#3、执行窗口布局performLayout" class="headerlink" title="3、执行窗口布局performLayout()"></a>3、执行窗口布局performLayout()</h5><p>[-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// requestLayout() was called during layout.</span></span><br><span class="line">            <span class="comment">// If no layout-request flags are set on the requesting views, there is no problem.</span></span><br><span class="line">            <span class="comment">// If some requests are still pending, then we need to clear those flags and do</span></span><br><span class="line">            <span class="comment">// a full request/measure/layout pass to handle this situation.</span></span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Set this flag to indicate that any further requests are happening during</span></span><br><span class="line">                <span class="comment">// the second pass, which may result in posting those requests to the next</span></span><br><span class="line">                <span class="comment">// frame instead</span></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Process fresh layout requests, then measure and layout</span></span><br><span class="line">                <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                            <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check the valid requests again, this time without checking/clearing the</span></span><br><span class="line">                <span class="comment">// layout flags, since requests happening during the second pass get noop'd</span></span><br><span class="line">                validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                    <span class="comment">// Post second-pass requests to the next frame</span></span><br><span class="line">                    getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; &#125;);&#125; &#125; &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-执行窗口绘制performDraw"><a href="#4-执行窗口绘制performDraw" class="headerlink" title="4.执行窗口绘制performDraw()"></a>4.执行窗口绘制performDraw()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ViewRootImpl.java]</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          draw(fullRedrawNeeded);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">          Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Android是怎样将View画出来的？ [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mAttachInfo.mTreeObserver.dispatchOnDraw();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xOffset = -mCanvasOffsetX;</span><br><span class="line">    <span class="keyword">int</span> yOffset = -mCanvasOffsetY + curScrollY;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams params = mWindowAttributes;</span><br><span class="line">    <span class="keyword">final</span> Rect surfaceInsets = params != <span class="keyword">null</span> ? params.surfaceInsets : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (surfaceInsets != <span class="keyword">null</span>) &#123;</span><br><span class="line">        xOffset -= surfaceInsets.left;</span><br><span class="line">        yOffset -= surfaceInsets.top;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Offset dirty rect for surface insets.</span></span><br><span class="line">        dirty.offset(surfaceInsets.left, surfaceInsets.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> accessibilityFocusDirty = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Drawable drawable = mAttachInfo.mAccessibilityFocusDrawable;</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = mAttachInfo.mTmpInvalRect;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasFocus = getAccessibilityFocusedRect(bounds);</span><br><span class="line">        <span class="keyword">if</span> (!hasFocus) &#123;</span><br><span class="line">            bounds.setEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bounds.equals(drawable.getBounds())) &#123;</span><br><span class="line">            accessibilityFocusDirty = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAttachInfo.mDrawingTime =</span><br><span class="line">            mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            <span class="comment">// If accessibility focus moved, always invalidate the root.</span></span><br><span class="line">            <span class="keyword">boolean</span> invalidateRoot = accessibilityFocusDirty || mInvalidateRootRequested;</span><br><span class="line">            mInvalidateRootRequested = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Draw with hardware renderer.</span></span><br><span class="line">            mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</span><br><span class="line">                mHardwareYOffset = yOffset;</span><br><span class="line">                mHardwareXOffset = xOffset;</span><br><span class="line">                invalidateRoot = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invalidateRoot) &#123;</span><br><span class="line">                mAttachInfo.mHardwareRenderer.invalidateRoot();</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">                requestDrawWindow();</span><br><span class="line">            &#125;</span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    !mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.isRequested()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.initializeIfNeeded(</span><br><span class="line">                            mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</span><br><span class="line">                    handleOutOfResourcesException(e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (animating) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于绘制这个流程很复杂，我们后续章节再分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N17-Android-addWindow-Render.JPG" alt="Markdown"></p><p>参考博客：<a href="http://blog.csdn.net/luoshengyang/article/details/45601143" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染技术简要介绍和学习计划</a></p><p>这里我们因为要分析Surface机制，所以只分析ViewRootImpl的draw流程。（如果开启了硬件加速功能，则会使用hwui硬件绘制功能，这里我们忽略这个，使用默认的软件绘制流程drawSoftware）。 [-&gt;ViewRootImpl.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line">        ......</span><br><span class="line">    &#125; ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">           ......</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看Surface的lockCanvas方法： [-&gt;Surface.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mCanvas 变量直接赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Canvas mCanvas = <span class="keyword">new</span> CompatibleCanvas();</span><br><span class="line"><span class="function"><span class="keyword">public</span> Canvas <span class="title">lockCanvas</span><span class="params">(Rect inOutDirty)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Surface.OutOfResourcesException, IllegalArgumentException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    checkNotReleasedLocked();</span><br><span class="line">    ......</span><br><span class="line">    mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty);</span><br><span class="line">    <span class="keyword">return</span> mCanvas;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeLockCanvas</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj, jobject dirtyRectObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取java层的Surface保存的long型句柄</span></span><br><span class="line">sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Rect <span class="title">dirtyRect</span><span class="params">(Rect::EMPTY_RECT)</span></span>;</span><br><span class="line">Rect* dirtyRectPtr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取java层dirty Rect的位置大小信息</span></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    dirtyRect.left   = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left);</span><br><span class="line">    dirtyRect.top    = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top);</span><br><span class="line">    dirtyRect.right  = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right);</span><br><span class="line">    dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom);</span><br><span class="line">    dirtyRectPtr = &amp;dirtyRect;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ANativeWindow_Buffer outBuffer;</span><br><span class="line"> <span class="comment">//调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height,</span><br><span class="line">                                     convertPixelFormat(outBuffer.format),</span><br><span class="line">                                     outBuffer.format == PIXEL_FORMAT_RGBX_8888 ?</span><br><span class="line">                                     kOpaque_SkAlphaType : kPremul_SkAlphaType);</span><br><span class="line"></span><br><span class="line">SkBitmap bitmap;</span><br><span class="line"><span class="comment">//创建一个SkBitmap</span></span><br><span class="line"><span class="comment">//图形缓冲区每一行像素大小</span></span><br><span class="line"><span class="keyword">ssize_t</span> bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);</span><br><span class="line">bitmap.setInfo(info, bpr);</span><br><span class="line"><span class="keyword">if</span> (outBuffer.width &gt; <span class="number">0</span> &amp;&amp; outBuffer.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    bitmap.setPixels(outBuffer.bits);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// be safe with an empty bitmap.</span></span><br><span class="line">    bitmap.setPixels(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(bitmap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectPtr) &#123;</span><br><span class="line">    nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top,</span><br><span class="line">            dirtyRect.right, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dirtyRectObj) &#123;</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left,   dirtyRect.left);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top,    dirtyRect.top);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right,  dirtyRect.right);</span><br><span class="line">    env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">sp&lt;Surface&gt; lockedSurface(surface);</span><br><span class="line">lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);</span><br><span class="line"><span class="keyword">return</span> (jlong) lockedSurface.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这段代码逻辑主要如下：</span><br><span class="line">   1）获取java层dirty 的Rect大小和位置信息；</span><br><span class="line">   2）调用Surface的lock方法,将申请的图形缓冲区赋给outBuffer；</span><br><span class="line">   3）创建一个Skbitmap，填充它用来保存申请的图形缓冲区，并赋值给Java层的Canvas对象；</span><br><span class="line">   4）将剪裁位置大小信息赋给java层Canvas对象。</span><br></pre></td></tr></table></figure><h4 id="unlockCanvasAndPost"><a href="#unlockCanvasAndPost" class="headerlink" title="unlockCanvasAndPost()"></a>unlockCanvasAndPost()</h4><p>Surface绘制完毕后，unlockCanvasAndPost操作。 [-&gt;android_view_Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeUnlockCanvasAndPost</span><span class="params">(JNIEnv* env, jclass clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">    jlong nativeObject, jobject canvasObj)</span> </span>&#123;</span><br><span class="line">sp&lt;Surface&gt; surface(<span class="keyword">reinterpret_cast</span>&lt;Surface *&gt;(nativeObject));</span><br><span class="line"><span class="keyword">if</span> (!isSurfaceValid(surface)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// detach the canvas from the surface</span></span><br><span class="line">Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);</span><br><span class="line">nativeCanvas-&gt;setBitmap(SkBitmap());</span><br><span class="line"></span><br><span class="line"><span class="comment">// unlock surface</span></span><br><span class="line"><span class="keyword">status_t</span> err = surface-&gt;unlockAndPost();</span><br><span class="line"><span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    doThrowIAE(env);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N18-Android-addWindow-LockUnlock-Surfacecycle.jpg" alt="Markdown"></p><h4 id="Surface管理图形缓冲区"><a href="#Surface管理图形缓冲区" class="headerlink" title="Surface管理图形缓冲区"></a>Surface管理图形缓冲区</h4><p>我们上边分析到了申请图形缓冲区，用到了Surface的lock函数，我们继续查看。 [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::lock(</span><br><span class="line">    ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds)</span><br><span class="line">    &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ANativeWindowBuffer* out;</span><br><span class="line"><span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//调用dequeueBuffer函数，申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> err = dequeueBuffer(&amp;out, &amp;fenceFd);</span><br><span class="line">ALOGE_IF(err, <span class="string">"dequeueBuffer failed (%s)"</span>, strerror(-err));</span><br><span class="line"><span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">//获取图形缓冲区区域大小,赋给后备缓冲区变量backBuffer</span></span><br><span class="line">    sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Rect <span class="title">bounds</span><span class="params">(backBuffer-&gt;width, backBuffer-&gt;height)</span></span>;</span><br><span class="line">    Region newDirtyRegion;</span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        <span class="comment">//如果上层指定乐刷新脏矩形区域，则用这个区域和缓冲区区域求交集，</span></span><br><span class="line">        <span class="comment">//然后将交集的结果设给需要去刷新的新区域</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(<span class="keyword">static_cast</span>&lt;Rect <span class="keyword">const</span>&amp;&gt;(*inOutDirtyBounds));</span><br><span class="line">        newDirtyRegion.andSelf(bounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /如果上层没有指定脏矩形区域，所以刷新整个图形缓冲区</span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// figure out if we can copy the frontbuffer back</span></span><br><span class="line">    <span class="comment">//上一次绘制的信息保存在mPostedBuffer中，而这个mPostedBuffer则要在unLockAndPost函数中设置</span></span><br><span class="line">    int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));</span><br><span class="line">    <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> canCopyBack = (frontBuffer != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;</span><br><span class="line">            backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;</span><br><span class="line">            backBuffer-&gt;format == frontBuffer-&gt;format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canCopyBack) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        Region oldDirtyRegion;</span><br><span class="line">        <span class="keyword">if</span>(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123;</span><br><span class="line">            oldDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty())</span><br><span class="line">                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        const Region copyback(oldDirtyRegion.subtract(newDirtyRegion));</span><br><span class="line">        <span class="keyword">if</span> (!copyback.isEmpty())</span><br><span class="line">        <span class="comment">//这里把mPostedBuffer中的旧数据拷贝到BackBuffer中。</span></span><br><span class="line">            <span class="comment">//后续的绘画只要更新脏区域就可以了，这会节约不少资源</span></span><br><span class="line">            copyBlt(backBuffer, frontBuffer, copyback);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// if we can't copy-back anything, modify the user's dirty</span></span><br><span class="line">        <span class="comment">// region to make sure they redraw the whole buffer</span></span><br><span class="line">        <span class="comment">//如果两次图形缓冲区大小不一致，我们就要修改用户指定的dirty区域大小为整个缓冲区大小，</span></span><br><span class="line">        <span class="comment">//然后去更新整个缓冲区</span></span><br><span class="line">        newDirtyRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123;</span><br><span class="line">            mSlots[i].dirtyRegion.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123; <span class="comment">// scope for the lock</span></span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="comment">//将新的dirty赋给这个bufferslot</span></span><br><span class="line">        mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inOutDirtyBounds) &#123;</span><br><span class="line">        *inOutDirtyBounds = newDirtyRegion.getBounds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* vaddr;</span><br><span class="line">     <span class="comment">//lock和unlock分别用来锁定和解锁一个指定的图形缓冲区，在访问一块图形缓冲区的时候，</span></span><br><span class="line">    <span class="comment">//例如，向一块图形缓冲写入内容的时候，需要将该图形缓冲区锁定，用来避免访问冲突,</span></span><br><span class="line">    <span class="comment">//锁定之后，就可以获得由参数参数l、t、w和h所圈定的一块缓冲区的起始地址，保存在输出参数vaddr中</span></span><br><span class="line">    <span class="keyword">status_t</span> res = backBuffer-&gt;lockAsync(</span><br><span class="line">            GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,</span><br><span class="line">            newDirtyRegion.bounds(), &amp;vaddr, fenceFd);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Surface的lock函数用来申请图形缓冲区和一些操作，方法不长，大概工作有： 1）调用connect函数完成一些初始化； 2）调用dequeueBuffer函数，申请图形缓冲区； 3）计算需要绘制的新的dirty区域，旧的区域原样copy数据。 [-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::dequeueBuffer(<span class="keyword">android_native_buffer_t</span>** buffer, <span class="keyword">int</span>* fenceFd) &#123;</span><br><span class="line"><span class="keyword">uint32_t</span> reqWidth;</span><br><span class="line"><span class="keyword">uint32_t</span> reqHeight;</span><br><span class="line">PixelFormat reqFormat;</span><br><span class="line"><span class="keyword">uint32_t</span> reqUsage;</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"><span class="comment">//申请图形缓冲区</span></span><br><span class="line"><span class="keyword">status_t</span> result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence,</span><br><span class="line">        reqWidth, reqHeight, reqFormat, reqUsage);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//根据index获取缓冲区</span></span><br><span class="line">sp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//由于申请的内存是在surfaceflinger进程中，</span></span><br><span class="line">    <span class="comment">//BufferQueue中的图形缓冲区也是通过匿名共享内存和binder传递描述符映射过去的，</span></span><br><span class="line">    <span class="comment">//Surface通过调用requestBuffer将图形缓冲区映射到Surface所在进程</span></span><br><span class="line">    result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="comment">//获取这个这个buffer对象的指针内容</span></span><br><span class="line">*buffer = gbuf.get();</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::requestBuffer(<span class="keyword">int</span> slot, sp&lt;GraphicBuffer&gt;* buf) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line">Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCore-&gt;mMutex)</span></span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mSlots[slot].mRequestBufferCalled = <span class="literal">true</span>;</span><br><span class="line">*buf = mSlots[slot].mGraphicBuffer;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个比较简单，还是很好理解的额，就是根据指定index取出mSlots中的slot中的buffer。</p><h4 id="图形缓冲区入队"><a href="#图形缓冲区入队" class="headerlink" title="图形缓冲区入队"></a>图形缓冲区入队</h4><p>我们前面讲了，省略了第二步绘制流程，因此我们这里分析第三部，绘制完毕后再queueBuffer。 同样，调用了Surface的unlockCanvasAndPost函数，我们查看它的实现： [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Surface::unlockAndPost()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//解锁图形缓冲区，和前面的lockAsync成对出现</span></span><br><span class="line"><span class="keyword">status_t</span> err = mLockedBuffer-&gt;unlockAsync(&amp;fd);</span><br><span class="line"><span class="comment">//queueBuffer去归还图形缓冲区</span></span><br><span class="line">err = queueBuffer(mLockedBuffer.get(), fd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mPostedBuffer = mLockedBuffer;</span><br><span class="line">mLockedBuffer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也比较简单，核心也是分两步： 1）解锁图形缓冲区，和前面的lockAsync成对出现； 2）queueBuffer去归还图形缓冲区； 所以我们还是重点分析第二步，查看queueBuffer的实现： [-&gt;Surface.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Surface::queueBuffer(<span class="keyword">android_native_buffer_t</span>* buffer, <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">status_t</span> err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);</span><br><span class="line">mLastQueueDuration = systemTime() - now;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用BufferQueueProducer的queueBuffer归还缓冲区，将绘制后的图形缓冲区queue回去。 [-&gt;BufferQueueProducer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::queueBuffer(<span class="keyword">int</span> slot,</span><br><span class="line">    <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">// scope for the lock</span></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mCallbackMutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (callbackTicket != mCurrentCallbackTicket) &#123;</span><br><span class="line">        mCallbackCondition.wait(mCallbackMutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 1）从传入的QueueBufferInput ，解析填充一些变量； 2）改变入队Slot的状态为QUEUED，每次推进来，mFrameCounter都加1。这里的slot，上一篇讲分配缓冲区返回最老的FREE状态buffer，就是用这个mFrameCounter最小值判断，就是上一篇LRU算法的判断； 3）创建一个BufferItem来描述GraphicBuffer，用mSlots[slot]中的slot填充BufferItem； 4）将BufferItem塞进mCore的mQueue队列，依照指定规则； 5）然后通知SurfaceFlinger去消费。</p><p>上述lockCanvas和unlockCanvasAndPost可以用下图来总结一下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N19-Android-addWindow-LockUnlock.jpg" alt="Markdown"></p><h3 id="通知SF消费合成"><a href="#通知SF消费合成" class="headerlink" title="通知SF消费合成"></a>通知SF消费合成</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N20-Android-addWindow-SF-Composition.png" alt="Markdown"></p><p>当绘制完毕的GraphicBuffer入队之后，会通知SurfaceFlinger去消费，就是BufferQueueProducer的queueBuffer函数的最后几行，listener-&gt;onFrameAvailable()。 listener最终通过回调，会回到Layer当中，所以最终调用Layer的onFrameAvailable接口，我们看看它的实现： [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; item) &#123;</span><br><span class="line"><span class="comment">// Add this buffer from our internal queue tracker</span></span><br><span class="line">&#123; <span class="comment">// Autolock scope</span></span><br><span class="line">    ......</span><br><span class="line">    mQueueItems.push_back(item);</span><br><span class="line">    android_atomic_inc(&amp;mQueuedFrames);</span><br><span class="line">    <span class="comment">// Wake up any pending callbacks</span></span><br><span class="line">    mLastFrameNumberReceived = item.mFrameNumber;</span><br><span class="line">    mQueueItemCondition.broadcast();</span><br><span class="line">&#125;</span><br><span class="line">mFlinger-&gt;signalLayerUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用SurfaceFlinger的signalLayerUpdate函数，继续查看： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::signalLayerUpdate() &#123;</span><br><span class="line">mEventQueue.invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又调用MessageQueue的invalidate函数： [MessageQueue.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::invalidate() &#123;</span><br><span class="line">mEvents-&gt;requestNextVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>贴一下SurfaceFlinger的初始化请求vsync信号流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N21-Android-addWindow-vsync-surfaceflinger.png" alt="Markdown"></p><p>最终结果会走到SurfaceFlinger的vsync信号接收逻辑，即SurfaceFlinger的onMessageReceived函数： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">switch</span> (what) &#123;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">        <span class="keyword">bool</span> frameMissed = !mHadClientComposition &amp;&amp;</span><br><span class="line">                mPreviousPresentFence != Fence::NO_FENCE &amp;&amp;</span><br><span class="line">                mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX;</span><br><span class="line">        ATRACE_INT(<span class="string">"FrameMissed"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(frameMissed));</span><br><span class="line">        <span class="keyword">if</span> (mPropagateBackpressure &amp;&amp; frameMissed) &#123;</span><br><span class="line">            signalLayerUpdate();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> refreshNeeded = handleMessageTransaction();</span><br><span class="line">        refreshNeeded |= handleMessageInvalidate();</span><br><span class="line">        refreshNeeded |= mRepaintEverything;</span><br><span class="line">        <span class="keyword">if</span> (refreshNeeded) &#123;</span><br><span class="line">            <span class="comment">// Signal a refresh if a transaction modified the window state,</span></span><br><span class="line">            <span class="comment">// a new buffer was latched, or if HWC has requested a full</span></span><br><span class="line">            <span class="comment">// repaint</span></span><br><span class="line">            signalRefresh();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">        handleMessageRefresh();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SurfaceFlinger收到了VSync信号后，调用了handleMessageRefresh函数 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleMessageRefresh() &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">nsecs_t</span> refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line"></span><br><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br><span class="line"></span><br><span class="line">mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);</span><br><span class="line"></span><br><span class="line">mHadClientComposition = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> displayId = <span class="number">0</span>; displayId &lt; mDisplays.size(); ++displayId) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId];</span><br><span class="line">    mHadClientComposition = mHadClientComposition ||</span><br><span class="line">            mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release any buffers which were replaced this frame</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; layer : mLayersWithQueuedFrames) &#123;</span><br><span class="line">    layer-&gt;releasePendingBuffer();</span><br><span class="line">&#125;</span><br><span class="line">mLayersWithQueuedFrames.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要看下下面几个函数。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">preComposition();</span><br><span class="line">rebuildLayerStacks();</span><br><span class="line">setUpHWComposer();</span><br><span class="line">doDebugFlashRegions();</span><br><span class="line">doComposition();</span><br><span class="line">postComposition(refreshStartTime);</span><br></pre></td></tr></table></figure><h4 id="一、preComposition-函数"><a href="#一、preComposition-函数" class="headerlink" title="一、preComposition()函数"></a>一、preComposition()函数</h4><p>我们先来看第一个函数preComposition() [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::preComposition()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> needExtraInvalidate = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (layers[i]-&gt;onPreComposition()) &#123;</span><br><span class="line">        needExtraInvalidate = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needExtraInvalidate) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数先是调用了mDrawingState的layersSortedByZ来得到上次绘图的Layer层列表。并不是所有的Layer都会参与屏幕图像的绘制，因此SurfaceFlinger用state对象来记录参与绘制的Layer对象。 记得我们之前分析过createLayer函数来创建Layer，创建之后会调用addClientLayer函数。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::addClientLayer(<span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; handle,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; gbc,</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; lbc)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// add this layer to the current state list</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mStateLock);</span><br><span class="line">    <span class="keyword">if</span> (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentState.layersSortedByZ.add(lbc);</span><br><span class="line">    mGraphicBufferProducerList.add(IInterface::asBinder(gbc));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// attach this layer to the client</span></span><br><span class="line">client-&gt;attachLayer(handle, lbc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下addClientLayer函数，这里会把Layer对象放在mCurrentState的layersSortedByZ对象中。而mDrawingState和mCurrentState什么关系呢？在后面我们会介绍，mDrawingState代表上一次绘图时的状态，处理完之后会把mCurrentState赋给mDrawingState。 回到preComposition函数，遍历所有的Layer对象，调用其onPreComposition函数来检测Layer层中的图像是否有变化。</p><h4 id="1-1、每个Layer的onFrameAvailable函数"><a href="#1-1、每个Layer的onFrameAvailable函数" class="headerlink" title="1.1、每个Layer的onFrameAvailable函数"></a>1.1、每个Layer的onFrameAvailable函数</h4><p>onPreComposition函数来根据mQueuedFrames来判断图像是否发生了变化，或者是mSidebandStreamChanged、mAutoRefresh。 [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Layer::onPreComposition() &#123;</span><br><span class="line">mRefreshPending = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> mQueuedFrames &gt; <span class="number">0</span> || mSidebandStreamChanged || mAutoRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当Layer所对应的Surface更新图像后，它所对应的Layer对象的onFrameAvailable函数会被调用来通知这种变化。 在SurfaceFlinger的preComposition函数中当有Layer的图像改变了，最后也会调用SurfaceFlinger的signalLayerUpdate函数。 SurfaceFlinger::signalLayerUpdate是调用了MessageQueue的invalidate函数 最后处理还是调用了SurfaceFlinger的onMessageReceived函数。看看SurfaceFlinger的onMessageReceived函数对NVALIDATE的处理 handleMessageInvalidate函数中调用了handlePageFlip函数，这个函数将会处理Layer中的缓冲区，把更新过的图像缓冲区切换到前台，等待VSync信号更新到FrameBuffer。</p><h4 id="1-2、绘制流程"><a href="#1-2、绘制流程" class="headerlink" title="1.2、绘制流程"></a>1.2、绘制流程</h4><p>具体完整的绘制流程如图。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.addwindow/N22-Android-addWindow-SF-Composition.jpg" alt="Markdown"></p><h5 id="二、handleTransaction-handPageFlip更新Layer对象"><a href="#二、handleTransaction-handPageFlip更新Layer对象" class="headerlink" title="二、handleTransaction handPageFlip更新Layer对象"></a>二、handleTransaction handPageFlip更新Layer对象</h5><p>在上一节中的绘图的流程中，我们看到了handleTransaction和handPageFlip这两个函数通常是在用户进程更新Surface图像时会调用，来更新Layer对象。这节就主要讲解这两个函数。</p><h4 id="2-1、handleTransaction函数"><a href="#2-1、handleTransaction函数" class="headerlink" title="2.1、handleTransaction函数"></a>2.1、handleTransaction函数</h4><p>handleTransaction函数的参数是transactionFlags，不过函数中没有使用这个参数，而是通过getTransactionFlags(eTransactionMask)来重新对transactionFlags赋值，然后使用它作为参数来调用函数 handleTransactionLocked。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransaction(<span class="keyword">uint32_t</span> transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">Mutex::Autolock _l(mStateLock);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInTransaction = now;</span><br><span class="line"></span><br><span class="line">transactionFlags = getTransactionFlags(eTransactionMask);</span><br><span class="line">handleTransactionLocked(transactionFlags);</span><br><span class="line"></span><br><span class="line">mLastTransactionTime = systemTime() - now;</span><br><span class="line">mDebugInTransaction = <span class="number">0</span>;</span><br><span class="line">invalidateHwcGeometry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getTransactionFlags函数的参数是eTransactionMask只是屏蔽其他位。 handleTransactionLocked函数会调用每个Layer类的doTransaction函数，在分析handleTransactionLocked函数之前，我们先看看Layer类 的doTransaction函数。</p><h4 id="2-2、Layer的doTransaction函数"><a href="#2-2、Layer的doTransaction函数" class="headerlink" title="2.2、Layer的doTransaction函数"></a>2.2、Layer的doTransaction函数</h4><p>下面是Layer的doTransaction函数代码 [Layer.cpp]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">uint32_t Layer::doTransaction(uint32_t flags) &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line">pushPendingState();<span class="comment">//上次绘制的State对象  </span></span><br><span class="line">Layer::State c = getCurrentState();<span class="comment">//当前使用的State对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layer::State&amp; s(getDrawingState());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool sizeChanged = (c.requested.w != s.requested.w) ||</span><br><span class="line">                         (c.requested.h != s.requested.h);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">    <span class="comment">// the size changed, we need to ask our client to request a new buffer</span></span><br><span class="line">    <span class="comment">//如果Layer的尺寸发生变化，就要改变Surface的缓冲区的尺寸</span></span><br><span class="line">    <span class="comment">// record the new size, form this point on, when the client request</span></span><br><span class="line">    <span class="comment">// a buffer, it'll get the new size.</span></span><br><span class="line">    mSurfaceFlingerConsumer-&gt;setDefaultBufferSize(</span><br><span class="line">            c.requested.w, c.requested.h);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bool resizePending = (c.requested.w != c.active.w) ||</span><br><span class="line">        (c.requested.h != c.active.h);</span><br><span class="line"><span class="keyword">if</span> (!isFixedSize()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resizePending &amp;&amp; mSidebandStream == NULL) &#123;</span><br><span class="line">    <span class="comment">//如果Layer不是固定尺寸的类型，比较它的实际大小和要求的改变大小  </span></span><br><span class="line">        flags |= eDontUpdateGeometryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果没有eDontUpdateGeometryState标志，更新active的值为request  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; eDontUpdateGeometryState)  &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Layer::State&amp; editCurrentState(getCurrentState());</span><br><span class="line">    <span class="keyword">if</span> (mFreezePositionUpdates) &#123;</span><br><span class="line">        <span class="keyword">float</span> tx = c.active.transform.tx();</span><br><span class="line">        <span class="keyword">float</span> ty = c.active.transform.ty();</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">        c.active.transform.set(tx, ty);</span><br><span class="line">        editCurrentState.active = c.active;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        editCurrentState.active = editCurrentState.requested;</span><br><span class="line">        c.active = c.requested;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果当前state的active和以前的State的active不等，设置更新标志  </span></span><br><span class="line"><span class="keyword">if</span> (s.active != c.active) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= Layer::eVisibleRegion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果当前state的sequence和以前state的sequence不等，设置更新标志</span></span><br><span class="line"><span class="keyword">if</span> (c.sequence != s.sequence) &#123;</span><br><span class="line">    <span class="comment">// invalidate and recompute the visible regions if needed</span></span><br><span class="line">    flags |= eVisibleRegion;</span><br><span class="line">    <span class="keyword">this</span>-&gt;contentDirty = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we may use linear filtering, if the matrix scales us</span></span><br><span class="line">    <span class="keyword">const</span> uint8_t type = c.active.transform.getType();</span><br><span class="line">    mNeedsFiltering = (!c.active.transform.preserveRects() ||</span><br><span class="line">            (type &gt;= Transform::SCALE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If the layer is hidden, signal and clear out all local sync points so</span></span><br><span class="line"><span class="comment">// that transactions for layers depending on this layer's frames becoming</span></span><br><span class="line"><span class="comment">// visible are not blocked</span></span><br><span class="line"><span class="keyword">if</span> (c.flags &amp; layer_state_t::eLayerHidden) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLocalSyncPointMutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (auto&amp; point : mLocalSyncPoints) &#123;</span><br><span class="line">        point-&gt;setFrameAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    mLocalSyncPoints.clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line">commitTransaction(c);</span><br><span class="line"><span class="keyword">return</span> flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Layer类中的两个类型为Layer::State的成员变量mDrawingState、mCurrentState，这里为什么要两个对象呢？Layer对象在绘制图形时，使用的是mDrawingState变量，用户调用接口设置Layer对象属性是，设置的值保存在mCurrentState对象中，这样就不会因为用户的操作而干扰Layer对象的绘制了。 Layer的doTransaction函数据你是比较这两个变量，如果有不同的地方，说明在上次绘制以后，用户改变的Layer的设置，要把这种变化通过flags返回。 State的结构中有两个Geometry字段，active和requested。他们表示layer的尺寸，其中requested保存是用户设置的尺寸，而active保存的值通过计算后的实际尺寸。 State中的z字段的值就是Layer在显示轴的位置，值越小位置越靠下。 layerStack字段是用户指定的一个值，用户可以给DisplayDevice也指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备上输出，这样的好处是可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放视频的Surface窗口，但不显示Activity窗口。 sequence字段是个序列值，每当用户调用了Layer的接口，例如setAlpha、setSize或者setLayer等改变Layer对象属性的哈数，这个值都会加1。因此在doTransaction函数中能通过比较sequence值来判断Layer的属性值有没有变化。 doTransaction函数最后会调用commitTransaction函数，就是把mCurrentState赋值给mDrawingState [Layer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Layer::commitTransaction(<span class="keyword">const</span> State&amp; stateToCommit) &#123;</span><br><span class="line">mDrawingState = stateToCommit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、handleTransactionLocked函数"><a href="#2-3、handleTransactionLocked函数" class="headerlink" title="2.3、handleTransactionLocked函数"></a>2.3、handleTransactionLocked函数</h5><p>下面我们来分析handleTransactionLocked函数，这个函数比较长，我们分段分析</p><p>2.3.1 处理Layer的事务 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::handleTransactionLocked(<span class="keyword">uint32_t</span> transactionFlags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">currentLayers</span><span class="params">(mCurrentState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Notify all layers of available frames</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    currentLayers[i]-&gt;notifyAvailableFrames();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">        <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">        <span class="keyword">if</span> (!trFlags) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">            mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在SurfaceFlinger中也有两个类型为State的变量mCurrentState和mDrawingState，但是和Layer中的不要混起来。它的名字相同而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    LayerVector layersSortedByZ;</span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构layersSortedByZ字段保存所有参与绘制的Layer对象，而字段displays保存的是所有输出设备的DisplayDeviceState对象 这里用两个变量的目的是和Layer中使用两个变量是一样的。 上面代码根据eTraversalNeeded标志来决定是否要检查所有的Layer对象。如果某个Layer对象中有eTransactionNeeded标志，将调用它的doTransaction函数。Layer的doTransaction函数返回的flags如果有eVisibleRegion，说明这个Layer需要更新，就把mVisibleRegionsDirty设置为true</p><h5 id="2-3-2、处理显示设备的变化"><a href="#2-3-2、处理显示设备的变化" class="headerlink" title="2.3.2、处理显示设备的变化"></a>2.3.2、处理显示设备的变化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eDisplayTransactionNeeded) &#123;</span><br><span class="line">    <span class="comment">// here we take advantage of Vector's copy-on-write semantics to</span></span><br><span class="line">    <span class="comment">// improve performance by skipping the transaction entirely when</span></span><br><span class="line">    <span class="comment">// know that the lists are identical</span></span><br><span class="line">    <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays);</span><br><span class="line">    <span class="keyword">const</span> KeyedVector&lt;  wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays);</span><br><span class="line">    <span class="keyword">if</span> (!curr.isIdenticalTo(draw)) &#123;</span><br><span class="line">        mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> cc = curr.size();</span><br><span class="line">              <span class="keyword">size_t</span> dc = draw.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find the displays that were removed</span></span><br><span class="line">        <span class="comment">// (ie: in drawing state but not in current state)</span></span><br><span class="line">        <span class="comment">// also handle displays that changed</span></span><br><span class="line">        <span class="comment">// (ie: displays that are in both lists)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;dc ; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">ssize_t</span> j = curr.indexOfKey(draw.keyAt(i));</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// in drawing state but not in current state</span></span><br><span class="line">                <span class="keyword">if</span> (!draw[i].isMainDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Call makeCurrent() on the primary display so we can</span></span><br><span class="line">                    <span class="comment">// be sure that nothing associated with this display</span></span><br><span class="line">                    <span class="comment">// is current.</span></span><br><span class="line">                    <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice());</span><br><span class="line">                    defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i)));</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    <span class="keyword">if</span> (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES)</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(draw[i].type, <span class="literal">false</span>);</span><br><span class="line">                    mDisplays.removeItem(draw.keyAt(i));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGW(<span class="string">"trying to remove the main display"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// this display is in both lists. see if something changed.</span></span><br><span class="line">                <span class="keyword">const</span> DisplayDeviceState&amp; state(curr[j]);</span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; display(curr.keyAt(j));</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface);</span><br><span class="line">                <span class="keyword">const</span> sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface);</span><br><span class="line">                <span class="keyword">if</span> (state_binder != draw_binder) &#123;</span><br><span class="line">                    <span class="comment">// changing the surface is like destroying and</span></span><br><span class="line">                    <span class="comment">// recreating the DisplayDevice, so we just remove it</span></span><br><span class="line">                    <span class="comment">// from the drawing state, so that it get re-added</span></span><br><span class="line">                    <span class="comment">// below.</span></span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display));</span><br><span class="line">                    <span class="keyword">if</span> (hw != <span class="literal">NULL</span>)</span><br><span class="line">                        hw-&gt;disconnect(getHwComposer());</span><br><span class="line">                    mDisplays.removeItem(display);</span><br><span class="line">                    mDrawingState.displays.removeItemsAt(i);</span><br><span class="line">                    dc--; i--;</span><br><span class="line">                    <span class="comment">// at this point we must loop to the next item</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display));</span><br><span class="line">                <span class="keyword">if</span> (disp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (state.layerStack != draw[i].layerStack) &#123;</span><br><span class="line">                        disp-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((state.orientation != draw[i].orientation)</span><br><span class="line">                            || (state.viewport != draw[i].viewport)</span><br><span class="line">                            || (state.frame != draw[i].frame))</span><br><span class="line">                    &#123;</span><br><span class="line">                        disp-&gt;setProjection(state.orientation,</span><br><span class="line">                                state.viewport, state.frame);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (state.width != draw[i].width || state.height != draw[i].height) &#123;</span><br><span class="line">                        disp-&gt;setDisplaySize(state.width, state.height);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find displays that were added</span></span><br><span class="line">        <span class="comment">// (ie: in current state but not in drawing state)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;cc ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (draw.indexOfKey(curr.keyAt(i)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> DisplayDeviceState&amp; <span class="title">state</span><span class="params">(curr[i])</span></span>;</span><br><span class="line"></span><br><span class="line">                sp&lt;DisplaySurface&gt; dispSurface;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">                sp&lt;IGraphicBufferProducer&gt; bqProducer;</span><br><span class="line">                sp&lt;IGraphicBufferConsumer&gt; bqConsumer;</span><br><span class="line">                BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer,</span><br><span class="line">                        <span class="keyword">new</span> GraphicBufferAlloc());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int32_t</span> hwcDisplayId = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                    <span class="comment">// Virtual displays without a surface are dormant:</span></span><br><span class="line">                    <span class="comment">// they have external state (layer stack, projection,</span></span><br><span class="line">                    <span class="comment">// etc.) but no internal state (i.e. a DisplayDevice).</span></span><br><span class="line">                    <span class="keyword">if</span> (state.surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">                        DisplayUtils* displayUtils = DisplayUtils::getInstance();</span><br><span class="line">                        <span class="keyword">int</span> status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_WIDTH, &amp;width);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">"Unable to query width (%d)"</span>, status);</span><br><span class="line">                        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">                        status = state.surface-&gt;query(</span><br><span class="line">                            NATIVE_WINDOW_HEIGHT, &amp;height);</span><br><span class="line">                        ALOGE_IF(status != NO_ERROR,</span><br><span class="line">                            <span class="string">"Unable to query height (%d)"</span>, status);</span><br><span class="line">                        <span class="keyword">if</span> (MAX_VIRTUAL_DISPLAY_DIMENSION == <span class="number">0</span> ||</span><br><span class="line">                            (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp;</span><br><span class="line">                             height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123;</span><br><span class="line">                            <span class="keyword">int</span> usage = <span class="number">0</span>;</span><br><span class="line">                            status = state.surface-&gt;query(</span><br><span class="line">                                NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage);</span><br><span class="line">                            ALOGW_IF(status != NO_ERROR,</span><br><span class="line">                                <span class="string">"Unable to query usage (%d)"</span>, status);</span><br><span class="line">                            <span class="keyword">if</span> ( (status == NO_ERROR) &amp;&amp;</span><br><span class="line">                                  displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123;</span><br><span class="line">                                hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface,</span><br><span class="line">                                dispSurface, producer, bqProducer, bqConsumer,</span><br><span class="line">                                state.displayName, state.isSecure, state.type);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGE_IF(state.surface!=<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="string">"adding a supported display, but rendering "</span></span><br><span class="line">                            <span class="string">"surface is provided (%p), ignoring it"</span>,</span><br><span class="line">                            state.surface.get());</span><br><span class="line">                    hwcDisplayId = allocateHwcDisplayId(state.type);</span><br><span class="line">                    <span class="comment">// for supported (by hwc) displays we provide our</span></span><br><span class="line">                    <span class="comment">// own rendering surface</span></span><br><span class="line">                    dispSurface = <span class="keyword">new</span> FramebufferSurface(*mHwc, state.type,</span><br><span class="line">                            bqConsumer);</span><br><span class="line">                    producer = bqProducer;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> wp&lt;IBinder&gt;&amp; display(curr.keyAt(i));</span><br><span class="line">                <span class="keyword">if</span> (dispSurface != <span class="literal">NULL</span> &amp;&amp; producer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    sp&lt;DisplayDevice&gt; hw = <span class="keyword">new</span> DisplayDevice(<span class="keyword">this</span>,</span><br><span class="line">                            state.type, hwcDisplayId,</span><br><span class="line">                            mHwc-&gt;getFormat(hwcDisplayId), state.isSecure,</span><br><span class="line">                            display, dispSurface, producer,</span><br><span class="line">                            mRenderEngine-&gt;getEGLConfig());</span><br><span class="line">                    hw-&gt;setLayerStack(state.layerStack);</span><br><span class="line">                    hw-&gt;setProjection(state.orientation,</span><br><span class="line">                            state.viewport, state.frame);</span><br><span class="line">                    hw-&gt;setDisplayName(state.displayName);</span><br><span class="line">                    <span class="comment">// When a new display device is added update the active</span></span><br><span class="line">                    <span class="comment">// config by querying HWC otherwise the default config</span></span><br><span class="line">                    <span class="comment">// (config 0) will be used.</span></span><br><span class="line">                    <span class="keyword">if</span> (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp;</span><br><span class="line">                            hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123;</span><br><span class="line">                        <span class="keyword">int</span> activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId);</span><br><span class="line">                        <span class="keyword">if</span> (activeConfig &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            hw-&gt;setActiveConfig(activeConfig);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDisplays.add(display, hw);</span><br><span class="line">                    <span class="keyword">if</span> (state.isVirtualDisplay()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (hwcDisplayId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId,</span><br><span class="line">                                    hw-&gt;getWidth(), hw-&gt;getHeight(),</span><br><span class="line">                                    hw-&gt;getFormat());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mEventThread-&gt;onHotplugReceived(state.type, <span class="literal">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是处理显示设备的变化，分成3种情况： 1.显示设备减少了，需要把显示设备对应的DisplayDevice移除 2.显示设备发生了变化，例如用户设置了Surface、重新设置了layerStack、旋转了屏幕等，这就需要重新设置显示对象的属性 3.显示设备增加了，创建新的DisplayDevice加入系统中。</p><h5 id="2-3-3、设置TransfromHit"><a href="#2-3-3、设置TransfromHit" class="headerlink" title="2.3.3、设置TransfromHit"></a>2.3.3、设置TransfromHit</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; disp;</span><br><span class="line">    <span class="keyword">uint32_t</span> currentlayerStack = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;count; i++) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> we rely on the fact that layers are sorted by</span></span><br><span class="line">        <span class="comment">// layerStack first (so we don't have to traverse the list</span></span><br><span class="line">        <span class="comment">// of displays for every layer).</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">        <span class="keyword">uint32_t</span> layerStack = layer-&gt;getDrawingState().layerStack;</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> || currentlayerStack != layerStack) &#123;</span><br><span class="line">            currentlayerStack = layerStack;</span><br><span class="line">            <span class="comment">// figure out if this layerstack is mirrored</span></span><br><span class="line">            <span class="comment">// (more than one display) if so, pick the default display,</span></span><br><span class="line">            <span class="comment">// if not, pick the only display it's on.</span></span><br><span class="line">            disp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">                sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">                <span class="keyword">if</span> (hw-&gt;getLayerStack() == currentlayerStack) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        disp = hw;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        disp = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (disp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> TEMPORARY FIX ONLY. Real fix should cause layers to</span></span><br><span class="line">            <span class="comment">// redraw after transform hint changes. See bug 8508397.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// could be null when this layer is using a layerStack</span></span><br><span class="line">            <span class="comment">// that is not visible on any display. Also can occur at</span></span><br><span class="line">            <span class="comment">// screen off/on times.</span></span><br><span class="line">            disp = getDefaultDisplayDevice();</span><br><span class="line">        &#125;</span><br><span class="line">        layer-&gt;updateTransformHint(disp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的作用是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看Layer的layerStack是否和DisplayDevice的layerStack）的TransformHint（主要指设备的显示方向orientation）。</p><h5 id="2-3-4、处理Layer增加情况"><a href="#2-3-4、处理Layer增加情况" class="headerlink" title="2.3.4、处理Layer增加情况"></a>2.3.4、处理Layer增加情况</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Perform our own transaction if needed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (currentLayers.size() &gt; layers.size()) &#123;</span><br><span class="line">    <span class="comment">// layers have been added</span></span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// some layers might have been removed, so</span></span><br><span class="line"><span class="comment">// we need to update the regions they're exposing.</span></span><br><span class="line"><span class="keyword">if</span> (mLayersRemoved) &#123;</span><br><span class="line">    mLayersRemoved = <span class="literal">false</span>;</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">        <span class="keyword">if</span> (currentLayers.indexOf(layer) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// this layer is not visible anymore</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could traverse the tree from front to back and</span></span><br><span class="line">            <span class="comment">//       compute the actual visible region</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> we could cache the transformed region</span></span><br><span class="line">            const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">            Region visibleReg = s.active.transform.transform(</span><br><span class="line">                    Region(Rect(s.active.w, s.active.h)));</span><br><span class="line">            invalidateLayerStack(s.layerStack, visibleReg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码处理Layer的增加情况，如果Layer增加了，需要重新计算设备的更新区域，因此把mVisibleRegionsDirty设为true，如果Layer删除了，需要把Layer的可见区域加入到系统需要更新的区域中。</p><h5 id="2-3-5、设置mDrawingState"><a href="#2-3-5、设置mDrawingState" class="headerlink" title="2.3.5、设置mDrawingState"></a>2.3.5、设置mDrawingState</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    commitTransaction();</span><br><span class="line">updateCursorAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用commitTransaction和updateCursorAsync函数 commitTransaction函数作用是把mDrawingState的值设置成mCurrentState的值。而updateCursorAsync函数会更新所有显示设备中光标的位置。</p><p>2.3.6 小结 handleTransaction函数的作用的就是处理系统在两次刷新期间的各种变化。SurfaceFlinger模块中不管是SurfaceFlinger类还是Layer类，都采用了双缓冲的方式来保存他们的属性，这样的好处是刚改变SurfaceFlinger对象或者Layer类对象的属性是，不需要上锁，大大的提高了系统效率。只有在最后的图像输出是，才进行一次上锁，并进行内存的属性变化处理。正因此，应用进程必须收到VSync信号才开始改变Surface的内容。</p><h4 id="2-4、handlePageFlip函数"><a href="#2-4、handlePageFlip函数" class="headerlink" title="2.4、handlePageFlip函数"></a>2.4、handlePageFlip函数</h4><p>handlePageFlip函数代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SurfaceFlinger::handlePageFlip()</span><br><span class="line">&#123;</span><br><span class="line">Region dirtyRegion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visibleRegions = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line"><span class="keyword">bool</span> frameQueued = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Store the set of layers that need updates. This set must not change as</span></span><br><span class="line"><span class="comment">// buffers are being latched, as this could result in a deadlock.</span></span><br><span class="line"><span class="comment">// Example: Two producers share the same command stream and:</span></span><br><span class="line"><span class="comment">// 1.) Layer 0 is latched</span></span><br><span class="line"><span class="comment">// 2.) Layer 0 gets a new frame</span></span><br><span class="line"><span class="comment">// 2.) Layer 1 gets a new frame</span></span><br><span class="line"><span class="comment">// 3.) Layer 1 is latched.</span></span><br><span class="line"><span class="comment">// Display is now waiting on Layer 1's frame, which is behind layer 0's</span></span><br><span class="line"><span class="comment">// second frame. But layer 0's second frame could be waiting on display.</span></span><br><span class="line">Vector&lt;Layer*&gt; layersWithQueuedFrames;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layers.size(); i&lt;count ; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">    <span class="keyword">if</span> (layer-&gt;hasQueuedFrame()) &#123;</span><br><span class="line">        frameQueued = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123;</span><br><span class="line">            layersWithQueuedFrames.push_back(layer.get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            layer-&gt;useEmptyDamage();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layer-&gt;useEmptyDamage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123;</span><br><span class="line">    Layer* layer = layersWithQueuedFrames[i];</span><br><span class="line">    const Region dirty(layer-&gt;latchBuffer(visibleRegions));</span><br><span class="line">    layer-&gt;useSurfaceDamage();</span><br><span class="line">    const Layer::State&amp; s(layer-&gt;getDrawingState());</span><br><span class="line">    invalidateLayerStack(s.layerStack, dirty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mVisibleRegionsDirty |= visibleRegions;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we will need to wake up at some time in the future to deal with a</span></span><br><span class="line"><span class="comment">// queued frame that shouldn't be displayed during this vsync period, wake</span></span><br><span class="line"><span class="comment">// up during the next vsync period to check again.</span></span><br><span class="line"><span class="keyword">if</span> (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123;</span><br><span class="line">    signalLayerUpdate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Only continue with the refresh if there is actually new work to do</span></span><br><span class="line"><span class="keyword">return</span> !layersWithQueuedFrames.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handlePageFlip函数先调用每个Layer对象的hasQueuedFrame函数，确定这个Layer对象是否有需要更新的图层，然后把需要更新的Layer对象放到layersWithQueuedFrames中。 我们先来看Layer的hasQueuedFrame方法就是看其mQueuedFrames是否大于0 和mSidebandStreamChanged。前面小节分析只要Surface有数据写入，就会调用Layer的onFrameAvailable函数，然后mQueuedFrames值加1. 继续看handlePageFlip函数，接着调用需要更新的Layer对象的latchBuffer函数，然后根据返回的更新区域调用invalidateLayerStack函数来设置更新设备对象的更新区域。 下面我们看看latchBuffer函数</p><p>LatchBuffer函数调用updateTextImage来得到需要的图像。这里参数r是Reject对象，其作用是判断在缓冲区的尺寸是否符合要求。调用updateTextImage函数如果得到的结果是PRESENT_LATER,表示推迟处理，然后调用signalLayerUpdate函数来发送invalidate消息，这次绘制过程就不处理这个Surface的图像了。 如果不需要推迟处理，把mQueuedFrames的值减1. 最后LatchBuffer函数调用mSurfaceFlingerConsumer的getCurrentBuffer来取回当前的图像缓冲区指针，保存在mActiveBuffer中。</p><h5 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h5><p>这样经过handleTransaction handlePageFlip两个函数处理，SurfaceFlinger中无论是Layer属性的变化还是图像的变化都处理好了，只等VSync信号到来就可以输出了。</p><h4 id="三、rebuildLayerStacks函数"><a href="#三、rebuildLayerStacks函数" class="headerlink" title="三、rebuildLayerStacks函数"></a>三、rebuildLayerStacks函数</h4><p>前面介绍，VSync信号到来后，先是调用了rebuildLayerStacks函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::rebuildLayerStacks() &#123;</span><br><span class="line">updateExtendedMode();</span><br><span class="line"><span class="comment">// rebuild the visible layer list per screen</span></span><br><span class="line"><span class="keyword">if</span> (CC_UNLIKELY(mVisibleRegionsDirty)) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mVisibleRegionsDirty = <span class="literal">false</span>;</span><br><span class="line">    invalidateHwcGeometry();</span><br><span class="line">    <span class="comment">//计算每个显示设备上可见的Layer  </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> LayerVector&amp; <span class="title">layers</span><span class="params">(mDrawingState.layersSortedByZ)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        Region opaqueRegion;</span><br><span class="line">        Region dirtyRegion;</span><br><span class="line">        Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">        const Transform&amp; tr(hw-&gt;getTransform());</span><br><span class="line">        const Rect bounds(hw-&gt;getBounds());</span><br><span class="line">        <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">            <span class="comment">//计算每个layer的可见区域，确定设备需要重新绘制的区域  </span></span><br><span class="line">            computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers,</span><br><span class="line">                    hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = layers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;count ; i++) &#123;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(layers[i]);</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//只需要和显示设备的LayerStack相同的layer  </span></span><br><span class="line">                    <span class="function">Region <span class="title">drawRegion</span><span class="params">(tr.transform(</span></span></span><br><span class="line">                            layer-&gt;visibleNonTransparentRegion));</span><br><span class="line">                    drawRegion.andSelf(bounds);</span><br><span class="line">                    <span class="keyword">if</span> (!drawRegion.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//如果Layer的显示区域和显示设备的窗口有交集  </span></span><br><span class="line">                        <span class="comment">//把Layer加入列表中</span></span><br><span class="line">                        layersSortedByZ.add(layer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置显示设备的可见Layer列表  </span></span><br><span class="line">        hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ);</span><br><span class="line">        hw-&gt;undefinedRegion.<span class="built_in">set</span>(bounds);</span><br><span class="line">        hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion));</span><br><span class="line">        hw-&gt;dirtyRegion.orSelf(dirtyRegion);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rebuildLayerStacks函数的作用是重建每个显示设备的可见layer对象列表。对于按显示轴（Z轴）排列的Layer对象，排在最前面的当然会优先显示，但是Layer图像可能有透明域，也可能有尺寸没有覆盖整个屏幕，因此下面的layer也有显示的机会。rebuildLayerStacks函数对每个显示设备，先计算和显示设备具有相同layerStack值的Layer对象在该显示设备上的可见区域。然后将可见区域和显示设备的窗口区域有交集的layer组成一个新的列表，最后把这个列表设置到显示设备对象中。 computeVisibleRegions函数首先计算每个Layer在设备上的可见区域visibleRegion。计算方法就是用整个Layer的区域减去上层所有不透明区域aboveOpaqueLayers。而上层所有不透明区域值是一个逐层累计的过程，每层都需要把自己的不透明区域累加到aboveOpaqueLayers中。 而每层的不透明区域的计算方法：如果Layer的alpha的值为255，并且layer的isOpaque函数为true，则本层的不透明区域等于Layer所在区域，否则为0.这样一层层算下来，就很容易得到每层的可见区域大小了。 其次，计算整个显示设备需要更新的区域outDirtyRegion。outDirtyRegion的值也是累计所有层的需要重回的区域得到的。如果Layer中的显示内容发生了变化，则整个可见区域visibleRegion都需要更新，同时还要包括上一次的可见区域，然后在去掉被上层覆盖后的区域得到的就是Layer需要更新的区域。如果Layer显示的内容没有变化，但是考虑到窗口大小的变化或者上层窗口的变化，因此Layer中还是有区域可以需要重绘的地方。这种情况下最简单的算法是用Layer计算出可见区域减去以前的可见区域就可以了。但是在computeVisibleRegions函数还引入了被覆盖区域，通常被覆盖区域和可见区域并不重复，因此函数中计算暴露区域是用可见区域减去被覆盖区域的。</p><h5 id="四、setUpHWComposer函数"><a href="#四、setUpHWComposer函数" class="headerlink" title="四、setUpHWComposer函数"></a>四、setUpHWComposer函数</h5><p>setUpHWComposer函数的作用是更新HWComposer对象中图层对象列表以及图层属性。 [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::setUpHWComposer() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">bool</span> dirty = !mDisplays[dpy]-&gt;getDirtyRegion(<span class="literal">false</span>).isEmpty();</span><br><span class="line">    <span class="keyword">bool</span> empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">bool</span> mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mDisplays[dpy]-&gt;beginFrame(mustRecompose);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mustRecompose) &#123;</span><br><span class="line">        mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到系统HWComposer对象  </span></span><br><span class="line">HWComposer&amp; hwc(getHwComposer());</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="comment">// build the h/w work list</span></span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(mHwWorkListDirty)) &#123;</span><br><span class="line">        mHwWorkListDirty = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">            sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">            <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                    hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">                <span class="comment">//根据Layer数量在HWComposer中创建hwc_layer_list_t列表  </span></span><br><span class="line">                <span class="keyword">if</span> (hwc.createWorkList(id, count) == NO_ERROR) &#123;</span><br><span class="line">                    HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">                    <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                        <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                        layer-&gt;setGeometry(hw, *cur);</span><br><span class="line">                        <span class="keyword">if</span> (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123;</span><br><span class="line">                            cur-&gt;setSkip(<span class="literal">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the per-frame data</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">bool</span> freezeSurfacePresent = <span class="literal">false</span>;</span><br><span class="line">            isfreezeSurfacePresent(freezeSurfacePresent, hw, id);</span><br><span class="line">            <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * update the per-frame h/w composer data for each layer</span></span><br><span class="line"><span class="comment">                 * and build the transparent region of the FB</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                <span class="comment">//将Layer的mActiveBuffer设置到HWComposer中</span></span><br><span class="line">                layer-&gt;setPerFrameData(hw, *cur);</span><br><span class="line">                setOrientationEventControl(freezeSurfacePresent,id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If possible, attempt to use the cursor overlay on each display.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">        <span class="keyword">if</span> (id &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(</span><br><span class="line">                hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">            HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">            <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123;</span><br><span class="line">                <span class="keyword">const</span> sp&lt;Layer&gt;&amp; layer(currentLayers[i]);</span><br><span class="line">                <span class="keyword">if</span> (layer-&gt;isPotentialCursor()) &#123;</span><br><span class="line">                    cur-&gt;setIsCursorLayerHint();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dumpDrawCycle(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = hwc.prepare();</span><br><span class="line">    ALOGE_IF(err, <span class="string">"HWComposer::prepare failed (%s)"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">        sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">        hw-&gt;prepareFrame(hwc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HWComposer中有一个类型为DisplayData结构的数组mDisplayData，它维护着每个显示设备的信息。DisplayData结构中有一个类型为hwc_display_contents_l字段list，这个字段又有一个hwc_layer_l类型的数组hwLayers，记录该显示设备所有需要输出的Layer信息。 setUpHWComposer函数调用HWComposer的createWorkList函数就是根据每种显示设备的Layer数量，创建和初始化hwc_display_contents_l对象和hwc_layer_l数组 创建完HWComposer中的列表后，接下来是对每个Layer对象调用它的setPerFrameData函数，参数是HWComposer和HWCLayerInterface。setPerFrameData函数将Layer对象的当前图像缓冲区mActiveBuffer设置到HWCLayerInterface对象对应的hwc_layer_l对象中。 HWComposer类中除了前面介绍的Gralloc还管理着Composer模块，这个模块实现了硬件的图像合成功能。setUpHWComposer函数接下来调用HWComposer类的prepare函数，而prepare函数会调用Composer模块的prepare接口。最后到各个厂家的实现hwc_prepare函数将每种HWComposer中的所有图层的类型都设置为HWC_FRAMEBUFFER就结束了。</p><h5 id="五、合成所有层的图像-（doComposition-函数）"><a href="#五、合成所有层的图像-（doComposition-函数）" class="headerlink" title="五、合成所有层的图像 （doComposition()函数）"></a>五、合成所有层的图像 （doComposition()函数）</h5><p>doComposition函数是合成所有层的图像，代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doComposition() &#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> repaintEverything = android_atomic_and(<span class="number">0</span>, &amp;mRepaintEverything);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    <span class="keyword">const</span> sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">if</span> (hw-&gt;isDisplayOn()) &#123;</span><br><span class="line">        <span class="comment">// transform the dirty region into this screen's coordinate space</span></span><br><span class="line">        const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// repaint the framebuffer (if needed)</span></span><br><span class="line">        doDisplayComposition(hw, dirtyRegion);</span><br><span class="line"></span><br><span class="line">        hw-&gt;dirtyRegion.clear();</span><br><span class="line">        hw-&gt;flip(hw-&gt;swapRegion);</span><br><span class="line">        hw-&gt;swapRegion.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// inform the h/w that we're done compositing</span></span><br><span class="line">    hw-&gt;compositionComplete();</span><br><span class="line">&#125;</span><br><span class="line">postFramebuffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doComposition函数针对每种显示设备调用doDisplayComposition函数来合成，合成后调用postFramebuffer函数，我们先来看看doDisplayComposition函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::doDisplayComposition(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> DisplayDevice&gt;&amp; hw,</span><br><span class="line">    <span class="keyword">const</span> Region&amp; inDirtyRegion)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// We only need to actually compose the display if:</span></span><br><span class="line"><span class="comment">// 1) It is being handled by hardware composer, which may need this to</span></span><br><span class="line"><span class="comment">//    keep its virtual display state machine in sync, or</span></span><br><span class="line"><span class="comment">// 2) There is work to be done (the dirty region isn't empty)</span></span><br><span class="line"><span class="keyword">bool</span> isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123;</span><br><span class="line">    ALOGV(<span class="string">"Skipping display composition"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ALOGV(<span class="string">"doDisplayComposition"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Region <span class="title">dirtyRegion</span><span class="params">(inDirtyRegion)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compute the invalid region</span></span><br><span class="line"><span class="comment">//swapRegion设置为需要更新的区域  </span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flags = hw-&gt;getFlags();<span class="comment">//获得显示设备支持的更新方式标志  </span></span><br><span class="line"><span class="keyword">if</span> (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123;</span><br><span class="line">    <span class="comment">// we can redraw only what's dirty, but since SWAP_RECTANGLE only</span></span><br><span class="line">    <span class="comment">// takes a rectangle, we must make sure to update that whole</span></span><br><span class="line">    <span class="comment">// rectangle in that case</span></span><br><span class="line">    dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;<span class="comment">//支持部分更新  </span></span><br><span class="line">        <span class="comment">// We need to redraw the rectangle that will be updated</span></span><br><span class="line">        <span class="comment">// (pushed to the framebuffer).</span></span><br><span class="line">        <span class="comment">// This is needed because PARTIAL_UPDATES only takes one</span></span><br><span class="line">        <span class="comment">// rectangle instead of a region (see DisplayDevice::flip())</span></span><br><span class="line">        <span class="comment">//将更新区域调整为整个窗口大小  </span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;swapRegion.bounds());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// we need to redraw everything (the whole screen)</span></span><br><span class="line">        dirtyRegion.<span class="built_in">set</span>(hw-&gt;bounds());</span><br><span class="line">        hw-&gt;swapRegion = dirtyRegion;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合成  </span></span><br><span class="line"><span class="keyword">if</span> (!doComposeSurfaces(hw, dirtyRegion)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// update the swap region and clear the dirty region</span></span><br><span class="line">hw-&gt;swapRegion.orSelf(dirtyRegion);</span><br><span class="line"><span class="comment">//没有硬件composer的情况，输出图像</span></span><br><span class="line"><span class="comment">// swap buffers (presentation)</span></span><br><span class="line">hw-&gt;swapBuffers(getHwComposer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doDisplayComposition函数根据显示设备支持的更新方式，重新设置需要更新区域的大小。 真正的合成工作是在doComposerSurfaces函数中完成，这个函数在layer的类型为HWC_FRAMEBUFFER,或者不支持硬件的composer的情况下，调用layer的draw函数来一层一层低合成最后的图像。 合成完后，doDisplayComposition函数调用了hw的swapBuffers函数，这个函数前面介绍过了，它将在系统不支持硬件的composer情况下调用eglSwapBuffers来输出图像到显示设备。</p><h5 id="六、postFramebuffer函数"><a href="#六、postFramebuffer函数" class="headerlink" title="六、postFramebuffer函数"></a>六、postFramebuffer函数</h5><p>上一节的doComposition函数最后调用了postFramebuffer函数，代码如下： [SurfaceFlinger.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::postFramebuffer()</span><br><span class="line">&#123;</span><br><span class="line">ATRACE_CALL();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nsecs_t</span> now = systemTime();</span><br><span class="line">mDebugInSwapBuffers = now;</span><br><span class="line"></span><br><span class="line">HWComposer&amp; hwc(getHwComposer());</span><br><span class="line"><span class="keyword">if</span> (hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwc.supportsFramebufferTarget()) &#123;</span><br><span class="line">        <span class="comment">// EGL spec says:</span></span><br><span class="line">        <span class="comment">//   "surface must be bound to the calling thread's current context,</span></span><br><span class="line">        <span class="comment">//    for the current rendering API."</span></span><br><span class="line">        getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line">    &#125;</span><br><span class="line">    hwc.commit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make the default display current because the VirtualDisplayDevice code cannot</span></span><br><span class="line"><span class="comment">// deal with dequeueBuffer() being called outside of the composition loop; however</span></span><br><span class="line"><span class="comment">// the code below can call glFlush() which is allowed (and does in some case) call</span></span><br><span class="line"><span class="comment">// dequeueBuffer().</span></span><br><span class="line">getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> dpy=<span class="number">0</span> ; dpy&lt;mDisplays.size() ; dpy++) &#123;</span><br><span class="line">    sp&lt;<span class="keyword">const</span> DisplayDevice&gt; hw(mDisplays[dpy]);</span><br><span class="line">    <span class="keyword">const</span> Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ());</span><br><span class="line">    hw-&gt;onSwapBuffersCompleted(hwc);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> count = currentLayers.size();</span><br><span class="line">    <span class="keyword">int32_t</span> id = hw-&gt;getHwcDisplayId();</span><br><span class="line">    <span class="keyword">if</span> (id &gt;=<span class="number">0</span> &amp;&amp; hwc.initCheck() == NO_ERROR) &#123;</span><br><span class="line">        HWComposer::LayerListIterator cur = hwc.begin(id);</span><br><span class="line">        <span class="keyword">const</span> HWComposer::LayerListIterator end = hwc.end(id);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            currentLayers[i]-&gt;onLayerDisplayed(hw, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mLastSwapBufferTime = systemTime() - now;</span><br><span class="line">mDebugInSwapBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();</span><br><span class="line"><span class="keyword">if</span> (flipCount % LOG_FRAME_STATS_PERIOD == <span class="number">0</span>) &#123;</span><br><span class="line">    logFrameStats();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>postFramebuffer先判断系统是否支持composer，如果不支持，我们知道图像已经在doComposition函数时调用hw-&gt;swapBuffers输出了，就返回了。如果支持硬件composer，postFramebuffer函数将调用HWComposer的commit函数继续执行。 [HWComposer.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> HWComposer::commit() &#123;</span><br><span class="line"><span class="keyword">int</span> err = NO_ERROR;</span><br><span class="line"><span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123;</span><br><span class="line">        <span class="comment">// On version 1.0, the OpenGL ES target surface is communicated</span></span><br><span class="line">        <span class="comment">// by the (dpy, sur) fields and we are guaranteed to have only</span></span><br><span class="line">        <span class="comment">// a single display.</span></span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;dpy = eglGetCurrentDisplay();</span><br><span class="line">        mLists[<span class="number">0</span>]-&gt;sur = eglGetCurrentSurface(EGL_DRAW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (disp.outbufHandle) &#123;</span><br><span class="line">            mLists[i]-&gt;outbuf = disp.outbufHandle;</span><br><span class="line">            mLists[i]-&gt;outbufAcquireFenceFd =</span><br><span class="line">                    disp.outbufAcquireFence-&gt;dup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = mHwc-&gt;<span class="built_in">set</span>(mHwc, mNumDisplays, mLists);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span> ; i&lt;mNumDisplays ; i++) &#123;</span><br><span class="line">        <span class="function">DisplayData&amp; <span class="title">disp</span><span class="params">(mDisplayData[i])</span></span>;</span><br><span class="line">        disp.lastDisplayFence = disp.lastRetireFence;</span><br><span class="line">        disp.lastRetireFence = Fence::NO_FENCE;</span><br><span class="line">        <span class="keyword">if</span> (disp.<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (disp.<span class="built_in">list</span>-&gt;retireFenceFd != <span class="number">-1</span>) &#123;</span><br><span class="line">                disp.lastRetireFence = <span class="keyword">new</span> Fence(disp.<span class="built_in">list</span>-&gt;retireFenceFd);</span><br><span class="line">                disp.<span class="built_in">list</span>-&gt;retireFenceFd = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            disp.<span class="built_in">list</span>-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">status_t</span>)err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>/<strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong>Vsync<strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong><em>**</em><strong><strong>**</strong></strong>/</p><h2 id="参考文档（特别感谢）："><a href="#参考文档（特别感谢）：" class="headerlink" title="参考文档（特别感谢）："></a>参考文档（特别感谢）：</h2><p><a href="http://blog.csdn.net/kc58236582/article/details/52778333" target="_blank" rel="noopener">Android6.0 显示系统（六） 图像的输出过程 - kc58236582的博客 - CSDN博客</a><br><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">startActivity启动过程分析</a><br><a href="https://dev.qq.com/topic/5923ef85bdc9739041a4a798" target="_blank" rel="noopener">浅析Android的窗口 - DEV CLUB</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">Android源码解析之（十四）–&gt;Activity启动流程</a><br><a href="http://blog.csdn.net/yanbober/article/details/45970721" target="_blank" rel="noopener">Android应用setContentView与LayoutInflater加载解析机制源码分析</a><br><a href="http://blog.csdn.net/yangwen123/article/details/35987609" target="_blank" rel="noopener">Android应用程序窗口设计框架介绍 - 深入剖析Android系统 - CSDN博客</a><br><a href="http://blog.csdn.net/yangwen123/article/details/22647255" target="_blank" rel="noopener">Android显示系统设计框架介绍 - 深入剖析Android系统 - CSDN博客</a><br><a href="http://www.cnblogs.com/samchen2009/p/3367496.html" target="_blank" rel="noopener">图解Android - Android GUI 系统 (2) - 窗口管理 (View, Canvas, Window Manager) - 漫天尘沙 - 博客园</a><br><a href="http://windrunnerlihuan.com/2017/05/25/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E4%BA%94-VSync-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路(五)—-VSync 工作原理 | April is your lie</a><br><a href="http://blog.csdn.net/armwind/article/details/73436532" target="_blank" rel="noopener">Android graphics 学习－生产者、消费者、BufferQueue介绍 - armwind的专栏 - CSDN博客 Graphics DEMO Bingo</a><br><a href="https://toutiao.io/posts/n0wr4e/preview" target="_blank" rel="noopener">Android 图形系统概述</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Activity 启动流程 （AMS）分析</title>
      <link href="/2017/10/01/Android-7-1-2-Android-N-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2017/10/01/Android-7-1-2-Android-N-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>Activity启动流程概述：<br>● 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；<br>● system_server进程接收到请求后，向zygote进程发送创建进程的请求；<br>● Zygote进程fork出新的子进程，即App进程；<br>● App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；<br>● system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；<br>● App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；<br>● 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 <a id="more"></a></p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>基于Android 7.1.2的源码剖析， 分析Android Activity启动流程，相关源码：</p><hr><p><strong>frameworks/base/services/core/java/com/android/server/am/</strong><br>● ActivityManagerService.java<br>● ActivityStackSupervisor.java<br>● ActivityStack.java<br>● ActivityRecord.java<br>● ProcessRecord.java<br>● TaskRecord.java</p><p><strong>frameworks/base/services/core/java/com/android/server/pm/</strong><br>● PackageManagerService.java</p><p><strong>frameworks/base/core/java/android/os/</strong><br>● Process.java</p><p><strong>frameworks/base/core/java/android/app/</strong><br>● IActivityManager.java<br>● ActivityManagerNative.java (内含AMP)<br>● ActivityManager.java<br>● Activity.java<br>● ActivityThread.java<br>● Instrumentation.java<br>● IApplicationThread.java<br>● ApplicationThreadNative.java (内含ATP)<br>● ActivityThread.java (内含ApplicationThread)<br>● ContextImpl.java</p><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.startactivity" target="_blank" rel="noopener">博客原图链接</a></h2><blockquote><p><strong>主要对象功能介绍：</strong><br>● ActivityManagerService，简称AMS，服务端对象，负责系统中所有Activity的生命周期。<br>● ActivityManagerNative继承Java的Binder类，同时实现了IActivityManager接口，即ActivityManagerNative将作为Binder通信的服务端为用户提供支持。<br>● ActivityManagerProxy：在ActivityManagerNative类中定义了内部类ActivityManagerProxy，该类同样实现了IActivityManager接口，将作为客户端使用的服务端代理。<br>● ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作<br>● ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。<br>● ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。<br>● Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。<br>● ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。<br>● ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。<br>● TaskRecord，AMS抽象出来的一个”任务”的概念，是记录ActivityRecord的栈，一个”Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</p></blockquote><hr><p><strong>相关类的类图：</strong><br>（1）IActivityManager相关类<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/N1-Android-startActivity-IAM-class.png" alt="Markdown"><br>（2）IApplicationThread相关类<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/N2-Android-startActivity-AMS-class.png" alt="Markdown"><br>（3）ActivityManagerService相关类<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/N3-Android-startActivity-IAP-class.png" alt="Markdown"></p><h3 id="1-1、Task和Stack"><a href="#1-1、Task和Stack" class="headerlink" title="1.1、Task和Stack"></a>1.1、Task和Stack</h3><p>Android系统中的每一个Activity都位于一个Task中。一个Task可以包含多个Activity，同一个Activity也可能有多个实例。 在AndroidManifest.xml中，我们可以通过android:launchMode来控制Activity在Task中的实例。</p><p>另外，在startActivity的时候，我们也可以通过setFlag 来控制启动的Activity在Task中的实例。</p><p>Task管理的意义还在于近期任务列表以及Back栈。 当你通过多任务键（有些设备上是长按Home键，有些设备上是专门提供的多任务键）调出多任务时，其实就是从ActivityManagerService获取了最近启动的Task列表。</p><p>Back栈管理了当你在Activity上点击Back键，当前Activity销毁后应该跳转到哪一个Activity的逻辑。关于Task和Back栈，请参见这里：<a href="https://developer.android.com/guide/components/tasks-and-back-stack.html" target="_blank" rel="noopener">Tasks and Back Stack</a>。</p><p>其实在ActivityManagerService与WindowManagerService内部管理中，在Task之外，还有一层容器，这个容器应用开发者和用户可能都不会感觉到或者用到，但它却非常重要，那就是Stack。 下文中，我们将看到，Android系统中的多窗口管理，就是建立在Stack的数据结构上的。 一个Stack中包含了多个Task，一个Task中包含了多个Activity（Window），下图描述了它们的关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/Android-_Activity-task_stack.png" alt="Markdown"><br> 另外还有一点需要注意的是，ActivityManagerService和WindowManagerService中的Task和Stack结构是一一对应的，对应关系对于如下：</p><p>ActivityStack &lt;–&gt; TaskStack TaskRecord &lt;–&gt; Task 即，ActivityManagerService中的每一个ActivityStack或者TaskRecord在WindowManagerService中都有对应的TaskStack和Task，这两类对象都有唯一的id（id是int类型），它们通过id进行关联。</p><h4 id="1-2、小结："><a href="#1-2、小结：" class="headerlink" title="1.2、小结："></a>1.2、小结：</h4><blockquote><p>用户从Launcher程序点击应用图标可启动应用的入口Activity，Activity启动时需要多个进程之间的交互，Android系统中有一个zygote进程专用于孵化Android框架层和应用层程序的进程。还有一个system_server进程，该进程里运行了很多binder service，例如ActivityManagerService，PackageManagerService，WindowManagerService，这些binder service分别运行在不同的线程中，其中ActivityManagerService负责管理Activity栈，应用进程，task。 用户在Launcher程序里点击应用图标时，会通知ActivityManagerService启动应用的入口Activity，ActivityManagerService发现这个应用还未启动，则会通知Zygote进程孵化出应用进程，然后在这个应用进程里执行ActivityThread的main方法。应用进程接下来通知ActivityManagerService应用进程已启动，ActivityManagerService保存应用进程的一个代理对象，这样ActivityManagerService可以通过这个代理对象控制应用进程，然后ActivityManagerService通知应用进程创建入口Activity的实例，并执行它的生命周期方法。</p></blockquote><h4 id="总体启动流程图："><a href="#总体启动流程图：" class="headerlink" title="总体启动流程图："></a><strong>总体启动流程图：</strong></h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/N4-Android-startActivity-flow.png" alt="Markdown"></p><h3 id="二、-开始请求执行启动Activity"><a href="#二、-开始请求执行启动Activity" class="headerlink" title="二、 开始请求执行启动Activity"></a>二、 开始请求执行启动Activity</h3><blockquote><p>Activity.startActivity()<br>Activity.startActivityForResult()<br>Instrumentation.execStartActivity()<br>ActivityManagerProxy.startActivity()<br>ActivityManagerNative.onTransact()<br>ActivityManagerService.startActivity()</p></blockquote><h4 id="2-1、Activity-startActivity"><a href="#2-1、Activity-startActivity" class="headerlink" title="2.1、Activity.startActivity()"></a>2.1、Activity.startActivity()</h4><p>从Launcher启动应用的时候，经过调用会执行Activity中的startActivity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; Activity.java]</span><br><span class="line">......</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2、Activity-startActivityForResult"><a href="#2-2、Activity-startActivityForResult" class="headerlink" title="2.2、Activity.startActivityForResult()"></a>2.2、Activity.startActivityForResult()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; Activity.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String who, Intent intent, <span class="keyword">int</span> requestCode, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    Instrumentation.ActivityResult ar =</span><br><span class="line">        mInstrumentation.execStartActivity(</span><br><span class="line">            <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, who,</span><br><span class="line">            intent, requestCode, options);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现execStartActivity方法传递的几个参数： this，为启动Activity的对象； contextThread，为Binder对象，是主进程的context对象； token，也是一个Binder对象，指向了服务端一个ActivityRecord对象； target，为启动的Activity； intent，启动的Intent对象； requestCode，请求码； options，参数；</p><h4 id="2-3、Instrumentation-execStartActivity"><a href="#2-3、Instrumentation-execStartActivity" class="headerlink" title="2.3、Instrumentation.execStartActivity()"></a>2.3、Instrumentation.execStartActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; Instrumentation.java]</span><br><span class="line">    ......</span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Context who, IBinder contextThread, IBinder token, String target,</span></span></span><br><span class="line"><span class="function"><span class="params">    Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="keyword">int</span> result = ActivityManagerNative.getDefault()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 ActivityManagerNative.getDefault()返回的是?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;ActivityManagerNative.java]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retrieve the system's default/global activity manager.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gDefault.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回的是gDefault.get()，那么gDefault又是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityManagerNative.java]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IBinder b = ServiceManager.getService(<span class="string">"activity"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service binder = "</span> + b);</span><br><span class="line">        &#125;</span><br><span class="line">        IActivityManager am = asInterface(b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Log.v(<span class="string">"ActivityManager"</span>, <span class="string">"default service = "</span> + am);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> am;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现启动过asInterface()方法创建，然后我们继续看一下asInterface方法的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IActivityManager <span class="title">asInterface</span><span class="params">(IBinder obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    IActivityManager in =</span><br><span class="line">        (IActivityManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">    <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActivityManagerProxy(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后直接返回一个对象， 此处startActivity()的共有10个参数, 下面说说每个参数传递AMP.startActivity()每一项的对应值:</p><p>caller: 当前应用的ApplicationThread对象mAppThread; callingPackage: 调用当前ContextImpl.getBasePackageName(),获取当前Activity所在包名; intent: 这便是启动Activity时,传递过来的参数; resolvedType: 调用intent.resolveTypeIfNeeded而获取; resultTo: 来自于当前Activity.mToken resultWho: 来自于当前Activity.mEmbeddedID requestCode = -1; startFlags = 0; profilerInfo = null; options = null;</p><p>好吧，最后直接返回一个对象，而继承与IActivityManager，到了这里就引出了我们android系统中很重要的一个概念：Binder机制。我们知道应用进程与SystemServer进程属于两个不同的进程，进程之间需要通讯，android系统采取了自身设计的Binder机制，这里的和ActivityManagerNative都是继承与IActivityManager的而SystemServer进程中的ActivityManagerService对象则继承与ActivityManagerNative。简单的表示： Binder接口 –&gt; ActivityManagerNative/ –&gt; ActivityManagerService；</p><p>这样，ActivityManagerNative与相当于一个Binder的客户端而ActivityManagerService相当于Binder的服务端，这样当ActivityManagerNative调用接口方法的时候底层通过Binder driver就会将请求数据与请求传递给server端，并在server端执行具体的接口逻辑。需要注意的是Binder机制是单向的，是异步的，也就是说只能通过client端向server端传递数据与请求而不用等待服务端的返回，也无法返回，那如果SystemServer进程想向应用进程传递数据怎么办？这时候就需要重新定义一个Binder请求以SystemServer为client端，以应用进程为server端，这样就是实现了两个进程之间的双向通讯。</p><p>好了，说了这么多我们知道这里的ActivityManagerNative是ActivityManagerService在应用进程的一个client就好了，通过它就可以滴啊用ActivityManagerService的方法了。</p><h4 id="2-4、ActivityManagerProxy-startActivity"><a href="#2-4、ActivityManagerProxy-startActivity" class="headerlink" title="2.4、ActivityManagerProxy.startActivity()"></a>2.4、ActivityManagerProxy.startActivity()</h4><p>ActivityManagerNative.getDefault()方法会返回一个对象，那么我们看一下对象的startActivity方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityManagerNative.java :: ActivityManagerProxy]</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ActivityManagerProxy</span> <span class="keyword">implements</span> <span class="title">IActivityManager</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle options)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5、ActivityManagerNative-onTransact"><a href="#2-5、ActivityManagerNative-onTransact" class="headerlink" title="2.5、ActivityManagerNative.onTransact()"></a>2.5、ActivityManagerNative.onTransact()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityManagerNative.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> START_ACTIVITY_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> result = startActivity(app, callingPackage, intent, resolvedType,</span><br><span class="line">                resultTo, resultWho, requestCode, startFlags, profilerInfo, options);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里就涉及到了具体的Binder数据传输机制了，我们不做过多的分析，知道通过数据传输之后就会调用SystemServer进程的ActivityManagerService的startActivity就好了。</p><p>以上其实都是发生在应用进程中，下面开始调用的ActivityManagerService的执行时发生在SystemServer进程。</p><h3 id="三、-ActivityManagerService接收启动Activity的请求"><a href="#三、-ActivityManagerService接收启动Activity的请求" class="headerlink" title="三、 ActivityManagerService接收启动Activity的请求"></a>三、 ActivityManagerService接收启动Activity的请求</h3><blockquote><p>ActivityManagerService.startActivity()<br>ActivityStarter.startActivityMayWait()<br>ActivityStarter.startActivityLocked()<br>ActivityStarter.startActivityUnchecked()<br>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() ActivityStack.resumeTopActivityUncheckedLocked()<br>ActivityStack.resumeTopActivityInnerLocked()<br>–&gt;ActivityStackSupervisor.pauseBackStacks() [if (mResumedActivity != null)] –&gt;ActivityStackSupervisor.startSpecificActivityLocked() [if (mResumedActivity == null)]</p><h5 id="3-1、ActivityManagerService-startActivity"><a href="#3-1、ActivityManagerService-startActivity" class="headerlink" title="3.1、ActivityManagerService.startActivity()"></a>3.1、ActivityManagerService.startActivity()</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsCaller</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = mActivityStarter.startActivityMayWait(<span class="keyword">null</span>, targetUid, targetPackage, intent,</span><br><span class="line">                resolvedType, <span class="keyword">null</span>, <span class="keyword">null</span>, resultTo, resultWho, requestCode, startFlags, <span class="keyword">null</span>,</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>, bOptions, ignoreTargetSecurity, userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(Intent intent, ActivityStackSupervisor.ActivityContainer container)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"ActivityContainer.startActivity"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = mUserController.handleIncomingUser(Binder.getCallingPid(),</span><br><span class="line">            Binder.getCallingUid(), mStackSupervisor.mCurrentUser, <span class="keyword">false</span>,</span><br><span class="line">            ActivityManagerService.ALLOW_FULL_ONLY, <span class="string">"ActivityContainer"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> mActivityStarter.startActivityMayWait(<span class="keyword">null</span>, -<span class="number">1</span>, <span class="keyword">null</span>, intent, mimeType, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, userId, container, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里只是进行了一些关于userid的逻辑判断，然后就调用mStackSupervisor.startActivityMayWait方法，此处mStackSupervisor的数据类型为ActivityStackSupervisor。 当程序运行到这里时, ASS.startActivityMayWait的各个参数取值如下:</p><p>caller = ApplicationThreadProxy, 用于跟调用者进程ApplicationThread进行通信的binder代理类. callingUid = -1; callingPackage = ContextImpl.getBasePackageName(),获取调用者Activity所在包名 intent: 这是启动Activity时传递过来的参数; resolvedType = intent.resolveTypeIfNeeded voiceSession = null; voiceInteractor = null; resultTo = Activity.mToken, 其中Activity是指调用者所在Activity, mToken对象保存自己所处的ActivityRecord信息 resultWho = Activity.mEmbeddedID, 其中Activity是指调用者所在Activity requestCode = -1; startFlags = 0; profilerInfo = null; outResult = null; config = null; options = null; ignoreTargetSecurity = false; userId = AMS.handleIncomingUser, 当调用者userId跟当前处于同一个userId,则直接返回该userId;当不相等时则根据调用者userId来决定是否需要将callingUserId转换为mCurrentUserId. iContainer = null; inTask = null;</p><p>下面我们来看一下这个方法的具体实现：</p><h4 id="3-2、ActivityStarter-startActivityMayWait"><a href="#3-2、ActivityStarter-startActivityMayWait" class="headerlink" title="3.2、ActivityStarter.startActivityMayWait()"></a>3.2、ActivityStarter.startActivityMayWait()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        IActivityContainer iContainer, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Save a copy in case ephemeral needs it</span></span><br><span class="line">    <span class="keyword">final</span> Intent ephemeralIntent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line">    <span class="comment">// Don't modify the client's object!</span></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line"></span><br><span class="line">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">    ActivityOptions options = ActivityOptions.fromBundle(bOptions);</span><br><span class="line">    ActivityStackSupervisor.ActivityContainer container =</span><br><span class="line">            (ActivityStackSupervisor.ActivityContainer)iContainer;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> ActivityRecord[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">                aInfo, rInfo, voiceSession, voiceInteractor,</span><br><span class="line">                resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">                options, ignoreTargetSecurity, componentSpecified, outRecord, container,</span><br><span class="line">                inTask);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该过程主要功能：通过resolveActivity来获取ActivityInfo信息, 然后再进入ASS.startActivityLocked().先来看看</p><h4 id="3-2-1、ActivityStackSupervisor-resolveActivity"><a href="#3-2-1、ActivityStackSupervisor-resolveActivity" class="headerlink" title="3.2.1、ActivityStackSupervisor.resolveActivity()"></a>3.2.1、ActivityStackSupervisor.resolveActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line">        <span class="function">ResolveInfo <span class="title">resolveIntent</span><span class="params">(Intent intent, String resolvedType, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resolveIntent(intent, resolvedType, userId, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ResolveInfo <span class="title">resolveIntent</span><span class="params">(Intent intent, String resolvedType, <span class="keyword">int</span> userId, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> AppGlobals.getPackageManager().resolveIntent(intent, resolvedType,</span><br><span class="line">                PackageManager.MATCH_DEFAULT_ONLY | flags</span><br><span class="line">                | ActivityManagerService.STOCK_PM_FLAGS, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ActivityInfo <span class="title">resolveActivity</span><span class="params">(Intent intent, String resolvedType, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResolveInfo rInfo = resolveIntent(intent, resolvedType, userId);</span><br><span class="line">    <span class="keyword">return</span> resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、PackageManagerService-resolveIntent"><a href="#3-2-2、PackageManagerService-resolveIntent" class="headerlink" title="3.2.2、PackageManagerService.resolveIntent()"></a>3.2.2、PackageManagerService.resolveIntent()</h4><p>AppGlobals.getPackageManager()经过函数层层调用，获取的是ApplicationPackageManager对象。经过binder IPC调用，最终会调用PackageManagerService对象。故此时调用方法为PMS.resolveIntent().</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; PackageManagerService.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResolveInfo <span class="title">resolveIntent</span><span class="params">(Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">final</span> List&lt;ResolveInfo&gt; query = queryIntentActivitiesInternal(intent, resolvedType,</span><br><span class="line">                flags, userId);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ResolveInfo bestChoice =</span><br><span class="line">                chooseBestActivity(intent, resolvedType, flags, query, userId);</span><br><span class="line">        <span class="keyword">return</span> bestChoice;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="meta">@NonNull</span> <span class="function">List&lt;ResolveInfo&gt; <span class="title">queryIntentActivitiesInternal</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    ComponentName comp = intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (comp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.getSelector() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent = intent.getSelector();</span><br><span class="line">            comp = intent.getComponent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> ActivityInfo ai = getActivityInfo(comp, flags, userId);</span><br><span class="line">        <span class="keyword">if</span> (ai != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ResolveInfo ri = <span class="keyword">new</span> ResolveInfo();</span><br><span class="line">            ri.activityInfo = ai;</span><br><span class="line">            list.add(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ActivityStackSupervisor.resolveActivity()方法的核心功能是找到相应的Activity组件，并保存到intent对象。</p><h4 id="3-3、ActivityStarter-startActivityLocked"><a href="#3-3、ActivityStarter-startActivityLocked" class="headerlink" title="3.3、ActivityStarter.startActivityLocked()"></a>3.3、ActivityStarter.startActivityLocked()</h4><p>继续ActivityStarter.startActivityMayWait()个方法中执行了启动Activity的一些其他逻辑判断，在经过判断逻辑之后调用startActivityLocked方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityLocked</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container,</span></span></span><br><span class="line"><span class="function"><span class="params">        TaskRecord inTask)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingUid, callingPackage,</span><br><span class="line">            intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho,</span><br><span class="line">            requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, container,</span><br><span class="line">            options, sourceRecord);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">                <span class="keyword">true</span>, options, inTask);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中主要构造了ActivityManagerService端的Activity对象–&gt;ActivityRecord，并根据Activity的启动模式执行了相关逻辑。然后调用了startActivityUncheckedLocked方法：</p><h4 id="3-4、ActivityStarter-startActivityUnchecked"><a href="#3-4、ActivityStarter-startActivityUnchecked" class="headerlink" title="3.4、ActivityStarter.startActivityUnchecked()"></a>3.4、ActivityStarter.startActivityUnchecked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStarter.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    ......</span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mLaunchTaskBehind) &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            mService.setFocusedActivityLocked(mStartActivity, <span class="string">"startedActivity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// .......</span></span><br><span class="line">            mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//3.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()</span></span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mTargetStack.addRecentActivityLocked(mStartActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(</span><br><span class="line">            mStartActivity.task, preferredLaunchStackId, mTargetStack.mStackId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到或创建新的Activit所属于的Task对象，之后调用ActivityStack.startActivityLocked()</p><h4 id="3-4-1、ActivityStack-startActivityLocked"><a href="#3-4-1、ActivityStack-startActivityLocked" class="headerlink" title="3.4.1、ActivityStack.startActivityLocked()"></a>3.4.1、ActivityStack.startActivityLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityStack.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startActivityLocked</span><span class="params">(ActivityRecord r, <span class="keyword">boolean</span> newTask, <span class="keyword">boolean</span> keepCurTransition,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If this is the first activity, don't do any fancy animations,</span></span><br><span class="line">        <span class="comment">// because there is nothing for it to animate on top of.</span></span><br><span class="line">        addConfigOverride(r, task);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addConfigOverride</span><span class="params">(ActivityRecord r, TaskRecord task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Rect bounds = task.updateOverrideConfigurationFromLaunchBounds();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> VI deal with activity</span></span><br><span class="line">    mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken,</span><br><span class="line">            r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen,</span><br><span class="line">            (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != <span class="number">0</span>, r.userId, r.info.configChanges,</span><br><span class="line">            task.voiceSession != <span class="keyword">null</span>, r.mLaunchTaskBehind, bounds, task.mOverrideConfig,</span><br><span class="line">            task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(),</span><br><span class="line">            r.appInfo.targetSdkVersion, r.mRotationAnimationHint);</span><br><span class="line">    r.taskConfigOverride = task.mOverrideConfig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5、ActivityStackSupervisor-resumeFocusedStackTopActivityLocked"><a href="#3-5、ActivityStackSupervisor-resumeFocusedStackTopActivityLocked" class="headerlink" title="3.5、ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()"></a>3.5、ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.state != RESUMED) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6、ActivityStack-resumeTopActivityUncheckedLocked"><a href="#3-6、ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="3.6、ActivityStack.resumeTopActivityUncheckedLocked()"></a>3.6、ActivityStack.resumeTopActivityUncheckedLocked()</h4><p>inResumeTopActivity用于保证每次只有一个Activity执行resumeTopActivityLocked()操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStack.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123;</span><br><span class="line">            mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN;</span><br><span class="line">            mService.updateSleepIfNeededLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7、ActivityStack-resumeTopActivityInnerLocked"><a href="#3-7、ActivityStack-resumeTopActivityInnerLocked" class="headerlink" title="3.7、ActivityStack.resumeTopActivityInnerLocked()"></a>3.7、ActivityStack.resumeTopActivityInnerLocked()</h4><p>说明：启动一个新Activity时，如果界面还存在其它的Activity，那么必须先中断其它的Activity。 因此，除了第一个启动的Home界面对应的Activity外，其它的Activity均需要进行此操作，当系统启动第一个Activity，即Home时，mResumedActivity的值才会为null。 经过一系列处理逻辑之后最终调用了startPausingLocked方法，这个方法作用就是让系统中栈中的Activity执行onPause方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStack.java]</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span>       </span>&#123;</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need to start pausing the current activity so the top one can be resumed...</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dontWaitForPause = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, dontWaitForPause);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8、ActivityStackSupervisor-pauseBackStacks"><a href="#3-8、ActivityStackSupervisor-pauseBackStacks" class="headerlink" title="3.8、ActivityStackSupervisor.pauseBackStacks()"></a>3.8、ActivityStackSupervisor.pauseBackStacks()</h4><p>暂停所有处于后台栈的所有Activity。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">pauseBackStacks</span><span class="params">(<span class="keyword">boolean</span> userLeaving, ActivityRecord resuming, <span class="keyword">boolean</span> dontWait)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> someActivityPaused = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">            <span class="keyword">if</span> (!isFocusedStack(stack) &amp;&amp; stack.mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ......</span><br><span class="line">                someActivityPaused |= stack.startPausingLocked(userLeaving, <span class="keyword">false</span>, resuming,</span><br><span class="line">                        dontWait);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> someActivityPaused;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、执行栈顶Activity的onPause方法"><a href="#四、执行栈顶Activity的onPause方法" class="headerlink" title="四、执行栈顶Activity的onPause方法"></a>四、执行栈顶Activity的onPause方法</h3><blockquote><p>ActivityStack.startPausingLocked()<br>ActivityThread.schedulePauseActivity()<br>ActivityThread.sendMessage()<br>ActivityThread.H.sendMessage()<br>ActivityThread.H.handleMessage()<br>–&gt; -&gt;ActivityThread.handlePauseActivity()<br>–&gt;ActivityThread.performPauseActivity()<br>—-&gt;ActivityThread.performPauseActivityIfNeeded()<br>—-&gt; Instrumentation.callActivityOnPause()<br>—-&gt; Activity.performPause()<br>—-&gt; Activity.onPause()<br>–&gt;ActivityManagerService.activityPaused()<br>—-&gt;ActivityStack.activityPausedLocked()<br>—-&gt;ActivityStack.completePauseLocked()<br>—-&gt;ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() —-&gt;ActivityStack.resumeTopActivityUncheckedLocked()<br>—-&gt;ActivityStack.resumeTopActivityInnerLocked()<br>—-&gt;ActivityStackSupervisor.startSpecificActivityLocked()</p></blockquote><h4 id="4-1、ActivityStack-startPausingLocked"><a href="#4-1、ActivityStack-startPausingLocked" class="headerlink" title="4.1、ActivityStack.startPausingLocked()"></a>4.1、ActivityStack.startPausingLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStack.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityRecord resuming, <span class="keyword">boolean</span> dontWait)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            mService.updateUsageStats(prev, <span class="keyword">false</span>);</span><br><span class="line">            prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing,</span><br><span class="line">                    userLeaving, prev.configChangeFlags, dontWait);</span><br><span class="line">        &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里执行了pre.app.thread.schedulePauseActivity方法，通过分析不难发现这里的thread是一个IApplicationThread类型的对象，而在ActivityThread中也定义了一个ApplicationThread的类，其继承了IApplicationThread，并且都是Binder对象，不难看出这里的IAppcation是一个Binder的client端而ActivityThread中的ApplicationThread是一个Binder对象的server端，所以通过这里的thread.schedulePauseActivity实际上调用的就是ApplicationThread的schedulePauseActivity方法。</p><p><code>这里的ApplicationThread可以和ActivityManagerNative对于一下： 通过ActivityManagerNative –&gt; ActivityManagerService实现了应用进程与SystemServer进程的通讯 通过AppicationThread &lt;– IApplicationThread实现了SystemServer进程与应用进程的通讯</code></p><p>然后我们继续看一下ActivityThread中schedulePauseActivity的具体实现：</p><h4 id="4-2、ActivityThread-schedulePauseActivity"><a href="#4-2、ActivityThread-schedulePauseActivity" class="headerlink" title="4.2、ActivityThread.schedulePauseActivity()"></a>4.2、ActivityThread.schedulePauseActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seq = getLifecycleSeq();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORDER) Slog.d(TAG, <span class="string">"pauseActivity "</span> + ActivityThread.<span class="keyword">this</span></span><br><span class="line">            + <span class="string">" operation received seq: "</span> + seq);</span><br><span class="line">    sendMessage(</span><br><span class="line">            finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,</span><br><span class="line">            token,</span><br><span class="line">            (userLeaving ? USER_LEAVING : <span class="number">0</span>) | (dontReport ? DONT_REPORT : <span class="number">0</span>),</span><br><span class="line">            configChanges,</span><br><span class="line">            seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3、ActivityThread-sendMessage"><a href="#4-3、ActivityThread-sendMessage" class="headerlink" title="4.3、ActivityThread.sendMessage()"></a>4.3、ActivityThread.sendMessage()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用了mH的sendMessage方法，mH是在ActivityThread中定义的一个Handler对象，主要处理SystemServer进程的消息，我们看一下其handleMessge方法的实现：</p><h4 id="4-4、-ActivityThread-handleMessage-mH"><a href="#4-4、-ActivityThread-handleMessage-mH" class="headerlink" title="4.4、[ActivityThread.handleMessage() : mH]"></a>4.4、[ActivityThread.handleMessage() : mH]</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityThread.java : mH]</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">     ......</span><br><span class="line">     <span class="keyword">case</span> PAUSE_ACTIVITY: &#123;</span><br><span class="line">         Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityPause"</span>);</span><br><span class="line">         SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">         handlePauseActivity((IBinder) args.arg1, <span class="keyword">false</span>,</span><br><span class="line">                 (args.argi1 &amp; USER_LEAVING) != <span class="number">0</span>, args.argi2,</span><br><span class="line">                 (args.argi1 &amp; DONT_REPORT) != <span class="number">0</span>, args.argi3);</span><br><span class="line">         maybeSnapshot();</span><br><span class="line">         Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>可以发现其调用了handlePauseActivity方法：</p><h4 id="4-5、ActivityThread-handlePauseActivity"><a href="#4-5、ActivityThread-handlePauseActivity" class="headerlink" title="4.5、ActivityThread.handlePauseActivity()"></a>4.5、ActivityThread.handlePauseActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityThread.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges, <span class="keyword">boolean</span> dontReport, <span class="keyword">int</span> seq)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    ......</span><br><span class="line">        performPauseActivity(token, finished, r.isPreHoneycomb(), <span class="string">"handlePauseActivity"</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Tell the activity manager we have paused.</span></span><br><span class="line">        <span class="keyword">if</span> (!dontReport) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityPaused(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在方法体内部通过调用performPauseActivity方法来实现对栈顶Activity的onPause生命周期方法的回调，可以具体看一下他的实现：</p><h4 id="4-6、ActivityThread-performPauseActivity"><a href="#4-6、ActivityThread-performPauseActivity" class="headerlink" title="4.6、ActivityThread.performPauseActivity()"></a>4.6、ActivityThread.performPauseActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> saveState, String reason)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样回到了mInstrumentation的callActivityOnPuase方法：</p><h4 id="4-7、Instrumentation-callActivityOnPuase"><a href="#4-7、Instrumentation-callActivityOnPuase" class="headerlink" title="4.7、Instrumentation.callActivityOnPuase()"></a>4.7、Instrumentation.callActivityOnPuase()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;Instrumentation.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.performPause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来最终回调到了Activity的performPause方法：</p><h4 id="4-7、Activity-performPause"><a href="#4-7、Activity-performPause" class="headerlink" title="4.7、Activity.performPause()"></a>4.7、Activity.performPause()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Activity.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onPause();</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于，太不容易了，回调到了Activity的onPause方法，哈哈，Activity生命周期中的第一个生命周期方法终于被我们找到了。。。。也就是说我们在启动一个Activity的时候最先被执行的是栈顶的Activity的onPause方法。记住这点吧，面试的时候经常会问到类似的问题。</p><p>然后回到我们的handlePauseActivity方法，在该方法的最后面执行了ActivityManagerNative.getDefault().activityPaused(token);方法，这是应用进程告诉服务进程，栈顶Activity已经执行完成onPause方法了，通过前面我们的分析，我们知道这句话最终会被ActivityManagerService的activityPaused方法执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  [-&gt;ActivityManagerService.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityPaused</span><span class="params">(IBinder token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.activityPausedLocked(token, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以发现，该方法内部会调用ActivityStack的activityPausedLocked方法，好吧，看一下activityPausedLocked方法的实现，然后执行了completePauseLocked方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">completePauseLocked</span><span class="params">(<span class="keyword">boolean</span> resumeNext, ActivityRecord resuming)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (resumeNext) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack topStack = mStackSupervisor.getFocusedStack();</span><br><span class="line">        <span class="keyword">if</span> (!mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStackSupervisor.checkReadyForSleepLocked();</span><br><span class="line">            ActivityRecord top = topStack.topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">if</span> (top == <span class="keyword">null</span> || (prev != <span class="keyword">null</span> &amp;&amp; top != prev)) &#123;</span><br><span class="line">                <span class="comment">// If there are no more activities available to run, do resume anyway to start</span></span><br><span class="line">                <span class="comment">// something. Also if the top activity on the stack is not the just paused</span></span><br><span class="line">                <span class="comment">// activity, we need to go ahead and resume it to ensure we complete an</span></span><br><span class="line">                <span class="comment">// in-flight app switch.</span></span><br><span class="line">                mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过了一系列的逻辑之后，又调用了resumeTopActivitiesLocked方法，又回到了第三步中解析的方法中了，这样经过</p><blockquote><p>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()<br>–&gt; ActivityStack.resumeTopActivityUncheckedLocked()<br>–&gt; ActivityStack.resumeTopActivityInnerLocked()<br>–&gt; ActivityStackSupervisor.startSpecificActivityLocked()</p></blockquote><p>好吧，我们看一下startSpecificActivityLocked的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStack.java]</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    r.task.stack.setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在这个方法中，首先会判断一下需要启动的Activity所需要的应用进程是否已经启动，若启动的话，则直接调用realStartAtivityLocked方法，否则调用startProcessLocked方法，用于启动应用进程。 这样关于启动Activity时的第三步骤就已经执行完成了，这里主要是实现了对栈顶Activity执行onPause 方法，而这个方法首先判断需要启动的Activity所属的进程是否已经启动，若已经启动则直接调用启动Activity的方法，否则将先启动Activity的应用进程，然后在启动该Activity。</p><h3 id="五、创建Activity所属的应用进程"><a href="#五、创建Activity所属的应用进程" class="headerlink" title="五、创建Activity所属的应用进程"></a>五、创建Activity所属的应用进程</h3><blockquote><p>ActivityManagerService.startProcessLocked()<br>-&gt; Process.start()<br>-&gt; 创建进程 Process.startViaZygote()<br>-&gt; 创建进程 Process.zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote)<br>-&gt; 创建进程 ActivityThread.main()<br>ActivityThread.attach()<br>ActivityManagerProxy.attachApplication()<br>ActivityManagerNative.onTransact()<br>ActivityManagerService.attachApplication()<br>ActivityManagerService.attachApplicationLocked() ApplicationThreadNative.ApplicationThreadProxy.bindApplication()<br>ApplicationThreadNative.onTransact()<br>ActivityThread.ApplicationThread.bindApplication()<br>ActivityThread.sendMessage()<br>ActivityThread.H.sendMessage()<br>ActivityThread.H.handleMessage()<br>ActivityThread.handleBindApplication()</p></blockquote><h4 id="5-1、ActivityManagerService-startProcessLocked"><a href="#5-1、ActivityManagerService-startProcessLocked" class="headerlink" title="5.1、ActivityManagerService.startProcessLocked()"></a>5.1、ActivityManagerService.startProcessLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityManagerService.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>,</span><br><span class="line">            <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">                    <span class="comment">// Start the process.  It will either succeed and return a result containing</span></span><br><span class="line">        <span class="comment">// the PID of the new process, or else throw a RuntimeException.</span></span><br><span class="line">        <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                app.processName);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                app.info.dataDir, entryPointArgs);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>可以发现其经过一系列的初始化操作之后调用了Process.start方法，并且传入了启动的类名”android.app.ActivityThread”:</p><h4 id="5-2、Process-start"><a href="#5-2、Process-start" class="headerlink" title="5.2、Process.start()"></a>5.2、Process.start()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;Process.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用了startViaZygote方法：</p><h4 id="5-3、Process-startViaZygote"><a href="#5-3、Process-startViaZygote" class="headerlink" title="5.3、Process.startViaZygote()"></a>5.3、Process.startViaZygote()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;Process.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                              <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续查看一下zygoteSendArgsAndGetResult方法的实现：</p><h4 id="5-4、Process-zygoteSendArgsAndGetResult"><a href="#5-4、Process-zygoteSendArgsAndGetResult" class="headerlink" title="5.4、Process.zygoteSendArgsAndGetResult()"></a>5.4、Process.zygoteSendArgsAndGetResult()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;Process.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Should there be a timeout on this?</span></span><br><span class="line">        ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always read the entire result from the input stream to avoid leaving</span></span><br><span class="line">        <span class="comment">// bytes in the stream for future process starts to accidentally stumble</span></span><br><span class="line">        <span class="comment">// upon.</span></span><br><span class="line">        <span class="comment">//等待socket服务端（即zygote）返回新创建的进程pid;</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要功能是通过socket通道向Zygote进程发送一个参数列表，然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。</p><h4 id="5-5、Process-openZygoteSocketIfNeeded"><a href="#5-5、Process-openZygoteSocketIfNeeded" class="headerlink" title="5.5、Process.openZygoteSocketIfNeeded()"></a>5.5、Process.openZygoteSocketIfNeeded()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   [-&gt;Process.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//向主zygote发起connect()操作</span></span><br><span class="line">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The primary zygote didn't match. Try the secondary.</span></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作</span></span><br><span class="line">        secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>openZygoteSocketIfNeeded(abi)方法是根据当前的abi来选择与zygote还是zygote64来进行通信。 既然system_server进程的zygoteSendArgsAndGetResult()方法通过socket向Zygote进程发送消息，这是便会唤醒Zygote进程，来响应socket客户端的请求（即system_server端) 具体详细过程可参考大神博客<a href="http://gityuan.com/2016/03/26/app-process-create/" target="_blank" rel="noopener">理解Android进程创建流程</a> 和 <a href="http://gityuan.com/2016/10/09/app-process-create-2/" target="_blank" rel="noopener">Android四大组件与进程启动的关系</a> 大神是基于Android M，之后我会跟着大神的脚步站在巨人的肩膀上，完成Android N进程创建流程，估计变化不大加深自己理解。 进程创建流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/Android-_Start_Activity-process-create.jpg" alt="Markdown"></p><p>总结： 可以发现其最终调用了Zygote并通过socket通信的方式让Zygote进程fork除了一个新的进程，并根据我们刚刚传递的”android.app.ActivityThread”字符串，反射出该对象并执行ActivityThread的main方法。这样我们所要启动的应用进程这时候其实已经启动了，但是还没有执行相应的初始化操作。</p><p>我们平时App-Crash常见的log就是从ActivityThread.main()抛出异常的,可参考文档：Android 7.1.2(Android N) Android系统启动流程。</p><blockquote><p>java.lang.RuntimeException: Unable to start activity ComponentInfo{……} at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1477)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">&gt; at android.os.Looper.loop(Looper.java:154)</span><br><span class="line">&gt; at android.app.ActivityThread.main(ActivityThread.java:6119)</span><br><span class="line">&gt; at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">&gt; at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:892)</span><br><span class="line">&gt; at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:782)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>为什么我们平时都将ActivityThread称之为ui线程或者是主线程，这里可以看出，应用进程被创建之后首先执行的是ActivityThread的main方法，所以我们将ActivityThread成为主线程。</p><p>好了，这时候我们看一下ActivityThread的main方法的实现逻辑。</p><h4 id="5-6、ActivityThread-main"><a href="#5-6、ActivityThread-main" class="headerlink" title="5.6、ActivityThread.main()"></a>5.6、ActivityThread.main()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    ......</span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中主要执行了一些初始化的逻辑，并且创建了一个UI线程消息队列，这也就是为什么我们可以在主线程中随意的创建Handler而不会报错的原因，这里提出一个问题，大家可以思考一下：子线程可以创建Handler么？可以的话应该怎么做？ 然后执行了ActivityThread的attach方法，这里我们看一下attach方法执行了那些逻辑操作。</p><h4 id="5-7、ActivityThread-attach"><a href="#5-7、ActivityThread-attach" class="headerlink" title="5.7、ActivityThread.attach()"></a>5.7、ActivityThread.attach()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//此时进程名还是"&lt;pre-initialized&gt;"</span></span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用基于IActivityManager接口的Binder通道</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-8、ActivityManagerProxy-attachApplication"><a href="#5-8、ActivityManagerProxy-attachApplication" class="headerlink" title="5.8、ActivityManagerProxy .attachApplication()"></a>5.8、ActivityManagerProxy .attachApplication()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityManagerNative.java::ActivityManagerProxy]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread app)</span> <span class="keyword">throws</span> RemoteException</span>&#123;</span><br><span class="line">Parcel data = Parcel.obtain();</span><br><span class="line">Parcel reply = Parcel.obtain();</span><br><span class="line">data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">data.writeStrongBinder(app.asBinder());</span><br><span class="line">mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">reply.readException();</span><br><span class="line">data.recycle();</span><br><span class="line">reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-9、ActivityManagerNative-onTransact"><a href="#5-9、ActivityManagerNative-onTransact" class="headerlink" title="5.9、ActivityManagerNative.onTransact()"></a>5.9、ActivityManagerNative.onTransact()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityManagerNative.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (code) &#123;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">case</span> ATTACH_APPLICATION_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    <span class="comment">//获取ApplicationThread的binder代理类 ApplicationThreadProxy</span></span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(</span><br><span class="line">            data.readStrongBinder());</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        attachApplication(app); <span class="comment">//此处是ActivityManagerService类中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚我们已经分析过对象是ActivityManagerService的Binder client，所以这里调用了attachApplication实际上就是通过Binder机制调用了ActivityManagerService的attachApplication，具体调用的过程，我们看一下ActivityManagerService是如何实现的：</p><h4 id="5-10、ActivityManagerService-attachApplication"><a href="#5-10、ActivityManagerService-attachApplication" class="headerlink" title="5.10、ActivityManagerService.attachApplication()"></a>5.10、ActivityManagerService.attachApplication()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityManagerService.java]</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="comment">//此处的thread便是ApplicationThreadProxy对象,用于跟前面通过Process.start()所创建的进程中ApplicationThread对象进行通信.</span></span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据pid获取ProcessRecord</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            app = mPidsSelfLocked.get(pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//获取应用appInfo</span></span><br><span class="line">        ApplicationInfo appInfo = app.instrumentationInfo != <span class="keyword">null</span></span><br><span class="line">                ? app.instrumentationInfo : app.info;</span><br><span class="line">        app.compat = compatibilityInfoForPackageLocked(appInfo);</span><br><span class="line">        <span class="keyword">if</span> (profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            profileFd = profileFd.dup();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//绑定应用</span></span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                               mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125; ......</span><br><span class="line">    <span class="comment">// See if the top visible activity is waiting to run in this process...</span></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown launching activities in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面,再来说说thread.bindApplication的过程.</p><h4 id="5-11、ApplicationThreadProxy-bindApplication"><a href="#5-11、ApplicationThreadProxy-bindApplication" class="headerlink" title="5.11、ApplicationThreadProxy.bindApplication()"></a>5.11、ApplicationThreadProxy.bindApplication()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ApplicationThreadNative.java ::ApplicationThreadProxy]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String packageName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle testArgs, IInstrumentationWatcher testWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection uiAutomationConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation, <span class="keyword">boolean</span> restrictedBackupMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> persistent, Configuration config, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mRemote.transact(BIND_APPLICATION_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-12、ApplicationThreadNative-onTransact"><a href="#5-12、ApplicationThreadNative-onTransact" class="headerlink" title="5.12、ApplicationThreadNative.onTransact()"></a>5.12、ApplicationThreadNative.onTransact()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ApplicationThreadNative.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (code) &#123;</span><br><span class="line">...</span><br><span class="line">       <span class="keyword">case</span> BIND_APPLICATION_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        ......</span><br><span class="line">        bindApplication(packageName, info, providers, testName, profilerInfo, testArgs,</span><br><span class="line">                testWatcher, uiAutomationConnection, testMode, enableBinderTracking,</span><br><span class="line">                trackAllocation, restrictedBackupMode, persistent, config, compatInfo, services,</span><br><span class="line">                coreSettings);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-13、ApplicationThread-bindApplication"><a href="#5-13、ApplicationThread-bindApplication" class="headerlink" title="5.13、ApplicationThread.bindApplication()"></a>5.13、ApplicationThread.bindApplication()</h4><p>[-&gt; ActivityThread.java ::ApplicationThread]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (services != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Setup the service cache in the ServiceManager</span></span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData();</span><br><span class="line">    ......</span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-14、ActivityThread-handleBindApplication"><a href="#5-14、ActivityThread-handleBindApplication" class="headerlink" title="5.14、ActivityThread.handleBindApplication()"></a>5.14、ActivityThread.handleBindApplication()</h4><p>当主线程收到H.BIND_APPLICATION,则调用handleBindApplication</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt; ActivityThread.java ::H]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    mConfiguration = <span class="keyword">new</span> Configuration(data.config);</span><br><span class="line">    mCompatConfiguration = <span class="keyword">new</span> Configuration(data.config);</span><br><span class="line">    <span class="comment">//设置进程名, 也就是说进程名是在进程真正创建以后的BIND_APPLICATION过程中才取名</span></span><br><span class="line">    <span class="comment">// send up app name; do this *before* waiting for debugger</span></span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName,</span><br><span class="line">                                            UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    获取LoadedApk对象</span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">    <span class="comment">//创建ContextImpl上下文</span></span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// If the app is being launched for full backup or restore, bring it up in</span></span><br><span class="line">        <span class="comment">// a restricted environment with the base application class.</span></span><br><span class="line">        <span class="comment">// 此处data.info是指LoadedApk, 通过反射创建目标应用Application对象</span></span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// Do this after providers, since instrumentation tests generally start their</span></span><br><span class="line">        <span class="comment">// test thread at this point, and we don't want that racing.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在handleBindApplication()的过程中,会同时设置以下两个值:</p><p>LoadedApk.mApplication AT.mInitialApplication</p><p>图示总结：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/N5-Android-startActivity-AMS-AT.png" alt="Markdown"></p><h3 id="六、执行启动Acitivity"><a href="#六、执行启动Acitivity" class="headerlink" title="六、执行启动Acitivity"></a>六、执行启动Acitivity</h3><blockquote><p>ActivityStackSupervisor.attachApplicationLocked()<br>ActivityStackSupervisor.realStartActivityLocked()<br>IApplicationThread.scheduleLaunchActivity()<br>ActivityThread.ApplicationThread.scheduleLaunchActivity()<br>ActivityThread.sendMessage()<br>ActivityThread.H.handleMessage()<br>ActivityThread.handleLauncherActivity()<br>ActivityThread.performLauncherActivity()<br>Instrumentation.callActivityOnCreate()<br>-&gt; Activity.performCreate() Activity.onCreate()</p></blockquote><p>在第五节AMS.startProcessLocked()整个过程，创建完新进程后会在新进程中调用AMP.attachApplication ，该方法经过binder ipc后调用到AMS.attachApplicationLocked。该方法执行了一系列的初始化操作，在执行完bindApplication()之后进入ActivityStackSupervisor.attachApplicationLocked()，这样我们整个应用进程已经启动起来了。终于可以开始activity的启动逻辑了。 关系图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/N6-Android-startActivity-arc.jpg" alt="Markdown"><br><a href="http://blog.csdn.net/myarrow/article/details/14223493" target="_blank" rel="noopener">ActivityThread简介</a> 首先看一下attachApplicationLocked方法的实现：</p><h4 id="6-1、ActivityStackSupervisor-attachApplicationLocked"><a href="#6-1、ActivityStackSupervisor-attachApplicationLocked" class="headerlink" title="6.1、ActivityStackSupervisor.attachApplicationLocked()"></a>6.1、ActivityStackSupervisor.attachApplicationLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = mActivityDisplays.size() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stackNdx = stacks.size() - <span class="number">1</span>; stackNdx &gt;= <span class="number">0</span>; --stackNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = stacks.get(stackNdx);</span><br><span class="line">            <span class="keyword">if</span> (!isFocusedStack(stack)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ActivityRecord hr = stack.topRunningActivityLocked();</span><br><span class="line">            <span class="keyword">if</span> (hr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hr.app == <span class="keyword">null</span> &amp;&amp; app.uid == hr.info.applicationInfo.uid</span><br><span class="line">                        &amp;&amp; processName.equals(hr.processName)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (realStartActivityLocked(hr, app, <span class="keyword">true</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                            didSomething = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; ......</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其内部调用了realStartActivityLocked方法，通过名字可以知道这个方法应该就是用来启动Activity的，看一下这个方法的实现逻辑：</p><h4 id="6-2、ActivityStackSupervisor-realStartActivityLocked"><a href="#6-2、ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="6.2、ActivityStackSupervisor.realStartActivityLocked()"></a>6.2、ActivityStackSupervisor.realStartActivityLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;ActivityStackSupervisor.java]</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">        app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">        app.thread.scheduleLaunchActivity(<span class="keyword">new</span> Intent(r.intent), r.appToken,</span><br><span class="line">                System.identityHashCode(r), r.info, <span class="keyword">new</span> Configuration(mService.mConfiguration),</span><br><span class="line">                <span class="keyword">new</span> Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage,</span><br><span class="line">                task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results,</span><br><span class="line">                newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现与第四节执行栈顶Activity onPause时类似，这里也是通过调用IApplicationThread的方法实现的，这里调用的是scheduleLaunchActivity方法，所以真正执行的是ActivityThread中的scheduleLaunchActivity。</p><h4 id="6-3、ApplicationThread-scheduleLaunchActivity"><a href="#6-3、ApplicationThread-scheduleLaunchActivity" class="headerlink" title="6.3、ApplicationThread.scheduleLaunchActivity()"></a>6.3、ApplicationThread.scheduleLaunchActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java :ApplicationThread]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityInfo info, Configuration curConfig, Configuration overrideConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> procState, Bundle state, PersistableBundle persistentState,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward, ProfilerInfo profilerInfo)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        updateProcessState(procState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        updatePendingConfiguration(curConfig);</span><br><span class="line"></span><br><span class="line">        sendMessage(H.LAUNCH_ACTIVITY, r);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="6-4、H-handleMessage"><a href="#6-4、H-handleMessage" class="headerlink" title="6.4、H.handleMessage"></a>6.4、H.handleMessage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java ::H]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityClientRecord r = (ActivityClientRecord) msg.obj;</span><br><span class="line"></span><br><span class="line">                r.packageInfo = getPackageInfoNoCheck(</span><br><span class="line">                        r.activityInfo.applicationInfo, r.compatInfo);</span><br><span class="line">                handleLaunchActivity(r, <span class="keyword">null</span>, <span class="string">"LAUNCH_ACTIVITY"</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ......</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h4 id="6-5、ActivityThread-handleLaunchActivity"><a href="#6-5、ActivityThread-handleLaunchActivity" class="headerlink" title="6.5、ActivityThread.handleLaunchActivity()"></a>6.5、ActivityThread.handleLaunchActivity()</h4><p>ActivityThread接收到SystemServer进程的消息之后会通过其内部的Handler对象分发消息，经过一系列的分发之后调用了ActivityThread的handleLaunchActivity方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        Bundle oldState = r.state;</span><br><span class="line">        handleResumeActivity(r.token, <span class="keyword">false</span>, r.isForward,</span><br><span class="line">                !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason);</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里调用了performLauncherActivity，看名字应该就是执行Activity的启动操作了……</p><h4 id="6-6、ActivityThread-performLaunchActivity"><a href="#6-6、ActivityThread-performLaunchActivity" class="headerlink" title="6.6、ActivityThread.performLaunchActivity()"></a>6.6、ActivityThread.performLaunchActivity()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = r.packageInfo.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; ......</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Context appContext = createBaseContextForActivity(r, activity);</span><br><span class="line">            ......</span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window);</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">//生命周期onStart、onresume</span></span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里我们需要的Activity对象终于是创建出来了，然后在代码中其调用Instrumentation的callActivityOnCreate方法。</p><h4 id="6-7、Instrumentation-callActivityOnCreate"><a href="#6-7、Instrumentation-callActivityOnCreate" class="headerlink" title="6.7、Instrumentation.callActivityOnCreate()"></a>6.7、Instrumentation.callActivityOnCreate()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    [-&gt;Instrumentation.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle,</span></span></span><br><span class="line"><span class="function"><span class="params">        PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle, persistentState);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行activity的performCreate方法……</p><h4 id="6-8、Activity-performCreate"><a href="#6-8、Activity-performCreate" class="headerlink" title="6.8、Activity.performCreate()"></a>6.8、Activity.performCreate()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    onCreate(icicle, persistentState);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line">    performCreateCommon();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简要说明剩余生命周期： 回到我们的performLaunchActivity方法，其在调用了mInstrumentation.callActivityOnCreate方法之后又调用了activity.performStart()方法，看一下他的实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Activity.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onStart()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">    mFragments.reportLoaderStart();</span><br><span class="line">    ......</span><br><span class="line">    mActivityTransitionState.enterReady(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是通过Instrumentation调用callActivityOnStart方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Instrumentation.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.onStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是直接调用activity的onStart方法，第三个生命周期方法出现了，O(∩_∩)O</p><p>还是回到我们刚刚的handleLaunchActivity方法，在调用完performLaunchActivity方法之后，其有吊用了handleResumeActivity方法，好吧，看名字应该是回调Activity的onResume方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">                    <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">                    <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">                    <span class="comment">// callbacks may have changed.</span></span><br><span class="line">                    ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                    <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        impl.notifyChildRebuilt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123;</span><br><span class="line">                    a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                    wm.addView(decor, l);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">            <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">            <span class="comment">// window visible.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">                r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (!r.onlyLocalRequest) &#123;</span><br><span class="line">                r.nextIdle = mNewActivities;</span><br><span class="line">                mNewActivities = r;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Scheduling idle handler for "</span> + r);</span><br><span class="line">                    <span class="comment">//线程空闲，也就是activity创建完毕之后，它会执行queueIdle里面的代码。</span></span><br><span class="line">                Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现其resumeActivity的逻辑调用到了performResumeActivity方法，我们来看一下performResumeActivity是如何实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; ActivityThread.java]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> clearHide, String reason)</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing resume of "</span> + r</span><br><span class="line">                + <span class="string">" finished="</span> + r.activity.mFinished);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; !r.activity.mFinished) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ......</span><br><span class="line">                r.activity.performResume();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = mRelaunchingActivities.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ActivityClientRecord relaunching = mRelaunchingActivities.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (relaunching.token == r.token</span><br><span class="line">                            &amp;&amp; relaunching.onlyLocalRequest &amp;&amp; relaunching.startsNotResumed) &#123;</span><br><span class="line">                        relaunching.startsNotResumed = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(),</span><br><span class="line">                        r.activity.getComponentName().getClassName(), reason);</span><br><span class="line">                r.paused = <span class="keyword">false</span>;</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">                r.state = <span class="keyword">null</span>;</span><br><span class="line">                r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">            &#125; ......</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在方法体中，最终调用了r.activity.performResume()方法，好吧，这个方法是Activity中定义的方法，我们需要在Activity中查看这个方法的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt; Activity.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        performRestart();</span><br><span class="line">        ...</span><br><span class="line">        mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到第一个分支走了performRestart()，这个方法即时onRestart()生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mInstrumentation.callActivityOnRestart(<span class="keyword">this</span>);</span><br><span class="line">    performStart();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mFragments.noteStateNotSaved();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mToken != <span class="keyword">null</span> &amp;&amp; mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No need to check mStopped, the roots will check if they were actually stopped.</span></span><br><span class="line">            WindowManagerGlobal.getInstance().setStoppedState(mToken, <span class="keyword">false</span> <span class="comment">/* stopped */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStopped) &#123;</span><br><span class="line">            mStopped = <span class="keyword">false</span>;</span><br><span class="line">            ......</span><br><span class="line">            mCalled = <span class="keyword">false</span>;</span><br><span class="line">            mInstrumentation.callActivityOnRestart(<span class="keyword">this</span>);</span><br><span class="line">            ......</span><br><span class="line">            performStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到首先判断当前activity是否为Stopped状态，是才会走OnRestart()-&gt;Onstart()生命周期。</p><p>继续看下performResume()第二个分支，又是熟悉的味道，通过Instrumentation来调用了callActivityOnResume方法。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Instrumentation.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnResume</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.mResumed = <span class="keyword">true</span>;</span><br><span class="line">        activity.onResume();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                    am.match(activity, activity, activity.getIntent());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>O(∩_∩)O，第四个生命周期方法出现了，onResume方法。。。</p><p>终于回调onResume方法了，这时候我们的界面应该已经展示出来了，照理来说我们的Activity应该已经启动完成了，但是还没有。</p><p>有一个问题，Activity a 启动 Activity b 会触发那些生命周期方法？ 你可能会回答？b的onCreate onStart方法，onResume方法 a的onPause方法和onStop方法，onStop方法还没回调，O(∩_∩)O，对了缺少的就是对onStop方法的回调。</p><h3 id="七、栈顶Activity执行onStop方法"><a href="#七、栈顶Activity执行onStop方法" class="headerlink" title="七、栈顶Activity执行onStop方法"></a>七、栈顶Activity执行onStop方法</h3><blockquote><p>Looper.myQueue().addIdleHandler(new Idler())<br>-&gt; Idler.queueIdle()<br>ActivityManagerNative.getDefault().activityIdle()<br>ActivityManagerService.activityIdle()<br>ActivityStackSupervisor.activityIdleInternalLocked()<br>ActivityStack.stopActivityLocked()<br>IApplicationThread.scheduleStopActivity()<br>ActivityThread.scheduleStopActivity()<br>-&gt; ActivityThread.sendMessage()<br>ActivityThread.H.sendMessage()<br>-&gt; ActivityThread.H.handleMessage()<br>ActivityThread.handleStopActivity()<br>ActivityThread.performStopActivityInner()<br>ActivityThread.callCallActivityOnSaveInstanceState()<br>Instrumentation.callActivityOnSaveInstanceState()<br>Activity.performSaveInstanceState()<br>-&gt; Activity.onSaveInstanceState()<br>Activity.performStop()<br>-&gt; Instrumentation.callActivityOnStop()<br>Activity.onStop()</p></blockquote><p>回到我们的handleResumeActivity方法，在方法体最后有这样的一代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br></pre></td></tr></table></figure><p>这段代码是异步消息机制相关的代码，我们可以看一下Idler对象的具体实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private class Idler implements MessageQueue.IdleHandler &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public final boolean queueIdle() &#123;</span><br><span class="line">            ActivityClientRecord a = mNewActivities;</span><br><span class="line">            .....</span><br><span class="line">            if (a != null) &#123;</span><br><span class="line">                mNewActivities = null;</span><br><span class="line">                IActivityManager am = ActivityManagerNative.getDefault();</span><br><span class="line">                ActivityClientRecord prev;</span><br><span class="line">                do &#123;</span><br><span class="line">                    ......</span><br><span class="line">                    if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                            a.createdConfig = null;</span><br><span class="line">                        &#125; catch (RemoteException ex) &#123;</span><br><span class="line">                            // Ignore</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = a;</span><br><span class="line">                    a = a.nextIdle;</span><br><span class="line">                    prev.nextIdle = null;</span><br><span class="line">                &#125; while (a != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样当Messagequeue执行add方法之后就会回调其queueIdle()方法，我们可以看到在方法体中其调用了ActivityManagerNative.getDefault().activityIdle()，好吧，熟悉了Binder机制以后我们知道这段代码会执行到ActivityManagerService的activityIdle方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ActivityRecord r =</span><br><span class="line">                    mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span>, config);</span><br><span class="line">            <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; (mProfileFd != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mProfileFd.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    clearProfilerLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在activityIdle方法中又调用了ActivityStackSupervisor.activityIdleInternalLocked方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityStackSupervisor.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">            Configuration config)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NS; i++) &#123;</span><br><span class="line">            r = stops.get(i);</span><br><span class="line">            <span class="keyword">final</span> ActivityStack stack = r.task.stack;</span><br><span class="line">            <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                    stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.stopActivityLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现在其中又调用了ActivityStack.stopActivityLocked方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></span><br><span class="line">                || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span>) &#123;</span><br><span class="line">            ...</span><br><span class="line">                r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags);</span><br><span class="line">             ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好吧，又是相同的逻辑通过IApplicationThread.scheduleStopActivity,最终调用了ActivityThread.scheduleStopActivity()方法。。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> showWindow,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> configChanges)</span> </span>&#123;</span><br><span class="line">           sendMessage(</span><br><span class="line">                showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE,</span><br><span class="line">                token, <span class="number">0</span>, configChanges);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>然后执行sendMessage方法，最终执行H（Handler）的sendMessage方法，并被H的handleMessge方法接收执行handleStopActivity方法。。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        performStopActivityInner(r, info, show, <span class="keyword">true</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们看一下performStopActivityInner的实现逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;ActivityThread.java]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            StopInfo info, <span class="keyword">boolean</span> keepShown, <span class="keyword">boolean</span> saveState)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (!keepShown) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    r.activity.performStop();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">                r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看一下performStopActivityInner中调用到的Activity方法的performStop方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStopped) &#123;</span><br><span class="line">            ......</span><br><span class="line">            mFragments.dispatchStop();</span><br><span class="line">            mCalled = <span class="keyword">false</span>;</span><br><span class="line">            mInstrumentation.callActivityOnStop(<span class="keyword">this</span>);</span><br><span class="line">            ......</span><br><span class="line">            mStopped = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mResumed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>还是通过Instrumentation来实现的，调用了它的callActivityOnStop方法。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStop</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.onStop();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>生命周期方法onStop()出来了。</p><p>我们来看一下Activity 的生命周期：</p><blockquote><p><strong>protected void onCreate();</strong><br><strong>protected void onRestart();</strong><br><strong>protected void onStart();</strong><br><strong>protected void onResume();</strong><br><strong>protected void onPause();</strong><br><strong>protected void onStop();</strong><br><strong>protected void onDestory();</strong></p></blockquote><p>前面我们分析了onCreate()、onStart()、onRestart() 、onResume()、onPause()、onStop()。 Activity 销毁时的 onDestroy() 回调都与前面的过程大同小异，这里就只列举相应的方法栈，不再继续描述。</p><blockquote><p>Activity.finish()<br>ActivityManagerNative.getDefault().finishActivity()<br>ActivityManagerService.finishActivity()<br>ActivityStack.requestFinishActivityLocked()<br>ActivityStack.finishActivityLocked()<br>ActivityStack.startPausingLocked()<br>参考：<a href="http://blog.csdn.net/qq_23547831/article/details/51232309" target="_blank" rel="noopener">Android源码解析之（十五）–&gt;Activity销毁流程</a></p></blockquote><h4 id="启动流程："><a href="#启动流程：" class="headerlink" title="启动流程："></a>启动流程：</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.startactivity/Android-start_activity_process.jpg" alt="Markdown"></p><p>1、点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求；<br>2、system_server进程接收到请求后，向zygote进程发送创建进程的请求；<br>3、Zygote进程fork出新的子进程，即App进程；<br>4、App进程，通过Binder IPC向sytem_server进程发起attachApplication请求；<br>5、system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求；<br>6、App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息；<br>7、主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。</p><p>到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续介绍窗口加载渲染过程，可参考文档：【Android 7.1.2 (Android N) Activity-Window加载显示流程分析】</p><h3 id="参考文档-特别感谢-："><a href="#参考文档-特别感谢-：" class="headerlink" title="参考文档(特别感谢)："></a>参考文档(特别感谢)：</h3><p><a href="http://blog.csdn.net/qq_23547831/article/details/51224992" target="_blank" rel="noopener">Android源码解析之（十四）–&gt;Activity启动流程</a><br><a href="http://gityuan.com/2016/03/12/start-activity/" target="_blank" rel="noopener">Android Activity启动过程分析</a><br><a href="http://blog.csdn.net/qq_23547831/article/details/51232309" target="_blank" rel="noopener">Android源码解析之（十五）–&gt;Activity销毁流程</a><br><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/49428287" target="_blank" rel="noopener">凯子哥带你学Framework–Activity启动过程全解析</a><br><a href="http://www.cloudchou.com/android/post-788.html" target="_blank" rel="noopener">深入理解Activity启动流程(一)–Activity启动的概要流程</a><br><a href="http://blog.csdn.net/Gaugamela/article/category/6383486" target="_blank" rel="noopener">Android 7.0 ActivityManagerService 启动Activity的过程 系列</a><br><a href="http://blog.csdn.net/yalinfendou/article/details/46909173" target="_blank" rel="noopener">Activity生命周期的回调，你应该知道得更多！–Android源码剖析（上）</a><br><a href="http://blog.csdn.net/yalinfendou/article/details/46910811" target="_blank" rel="noopener">Activity生命周期的回调，你应该知道得更多！–Android源码剖析（下）</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Android 系统启动流程 分析</title>
      <link href="/2017/09/01/Android-7-1-2-Android-N-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/09/01/Android-7-1-2-Android-N-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><p><strong>system/core/rootdir/</strong></p><ul><li>init.rc</li><li>init.zygote64.rc</li></ul><p><strong>system/core/init/</strong></p><ul><li>init.cpp</li><li>init_parser.cpp</li><li>signal_handler.cpp</li></ul><p><strong>frameworks/base/cmds/app_process/</strong></p><ul><li>App_main.cpp</li></ul><p><strong>frameworks/base/core/jni/</strong></p><ul><li>AndroidRuntime.cpp</li></ul><p><strong>frameworks/base/core/java/com/android/internal/os/</strong></p><ul><li>ZygoteInit.java</li><li>Zygote.java</li><li>ZygoteConnection.java</li></ul><p><strong>frameworks/base/core/java/com/android/internal/os/</strong></p><ul><li>ZygoteInit.java</li><li>RuntimeInit.java</li><li>Zygote.java</li></ul><p><strong>frameworks/base/core/services/java/com/android/server/</strong></p><ul><li>SystemServer.java</li></ul><p><strong>frameworks/base/core/jni/</strong></p><ul><li>com_android_internal_os_Zygote.cpp</li><li>AndroidRuntime.cpp</li></ul><p><strong>frameworks/base/services/java/com/android/server/</strong></p><ul><li>SystemServer.java</li></ul><p><strong>frameworks/base/services/core/java/com/android/server/</strong></p><ul><li>SystemServiceManager.java</li><li>ServiceThread.java</li><li>am/ActivityManagerService.java</li></ul><p><strong>frameworks/base/core/java/android/app/</strong></p><ul><li>ActivityThread.java</li><li>LoadedApk.java</li><li>ContextImpl.java</li></ul><p><strong>frameworks/base/core/java/android/app/</strong></p><ul><li>ActivityThread.java</li><li>LoadedApk.java</li><li>ContextImpl.java</li></ul><p><strong>frameworks/base/services/java/com/android/server/</strong></p><ul><li>SystemServer.java</li></ul><p><strong>frameworks/base/services/core/java/com/android/server/</strong></p><ul><li>SystemServiceManager.java</li><li>ServiceThread.java</li><li>pm/Installer.java</li><li>am/ActivityManagerService.java</li></ul><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.boot" target="_blank" rel="noopener">博客原图链接</a></h2><h3 id="一、Android概述"><a href="#一、Android概述" class="headerlink" title="一、Android概述"></a>一、Android概述</h3><p>Android系统非常庞大，底层是采用Linux作为基底，上层采用带有虚拟机的Java层，通过通过JNI技术，将上下打通，融为一体。下图是Google提供的一张经典的4层架构图，从下往上，依次分为Linux内核，系统库和Android Runtime，应用框架层，应用程序层这4层架构，每一层都包含大量的子模块或子系统。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N01-android-system-start-arch.png" alt="Markdown"></p><h3 id="二、系统启动"><a href="#二、系统启动" class="headerlink" title="二、系统启动"></a>二、系统启动</h3><p>Google提供的4层架构图，是非常经典，但只是如垒砖般的方式，简单地分层，而不足表达Android整个系统的启动过程，环环相扣的连接关系，本文更多的是以进程的视角，以分层的架构来诠释Android系统的全貌。 系统启动架构图<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N02-android-system-start-arch.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N03-android-system-start-arch.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N04-android-system-start-arch.png" alt="Markdown"></p><h3 id="三、设备启动过程"><a href="#三、设备启动过程" class="headerlink" title="三、设备启动过程"></a>三、设备启动过程</h3><h4 id="3-1、Bootloader引导"><a href="#3-1、Bootloader引导" class="headerlink" title="3.1、Bootloader引导"></a>3.1、Bootloader引导</h4><p>Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设出代码开始执行，然后加载引导程序到RAM；</p><p>Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件设备（如CPU、内存、Flash等）并且通过建立内存空间映射，为装载Linux内核准备合适的环境。一旦Linux内核装载完毕，Bootloader将会从内存中清除掉。 如果用户在Bootloader运行期间，按下预定义的组合健，可以进入系统的更新模块。Android的下载更新可以选择进入Fastboot模式或者Recovery模式。</p><p>Fastboot是Android设计的一套通过USB来更新手机分区映像的协议，方便开发人员能快速更新指定的手机分区。但是一般的零售机上往往去掉了Fastboot，Google销售的开发机则带有Fastboot模块。 Recovery模式是Android特有的升级系统。利用Recovery模式，手机可以进行恢复出厂设置或进行OTA、补丁和固件升级。进入Recovery模式实际上是启动了一个文本模式的Linux。</p><h4 id="3-2、装载和启动Linux内核"><a href="#3-2、装载和启动Linux内核" class="headerlink" title="3.2、装载和启动Linux内核"></a>3.2、装载和启动Linux内核</h4><p>到这里才刚刚开始进入Android系统.</p><p>启动Kernel的0号进程：初始化进程管理、内存管理，加载Display,Camera Driver，Binder Driver等相关工作； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。</p><p>Android的boot.img存放的就是Linux内核和一个根文件系统。Bootloader会把boot.img映像装载进内存。然后Linux内核会执行整个系统的初始化，完成后装载根文件系统，最后启动Init进程。</p><h4 id="3-3、启动Init进程"><a href="#3-3、启动Init进程" class="headerlink" title="3.3、启动Init进程"></a>3.3、启动Init进程</h4><p>Linux内核加载完毕后，会首先启动Init进程，Init进程是系统的第一个进程。在Init进程的启动过程中，会解析Linux的配置脚本init.rc文件，根据init.rc文件的内容，Init进程会装载Android的文件系统、创建系统目录。初始 化属性系统、启动Android系统重要的守护进程，这些进程包括USB守护进程、adb守护进程、vold守护进程、rild守护进程。</p><p>启动init进程(pid=1),是Linux系统的用户进程，init进程是所有用户进程的鼻祖。</p><p>init进程启动Media Server(多媒体服务)、servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程还会孵化出installd、ueventd、adbd、等用户守护进程； init进程孵化出Zygote进程，Zygote进程是Android系统的首个Java进程，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 <a href="http://blog.csdn.net/sunao2002002/article/details/52454878" target="_blank" rel="noopener">Android 7.0 init.rc的一点改变 - 哈哈的个人专栏 - CSDN博客</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/system/core/rootdir/init.rc</span><br><span class="line">.....</span><br><span class="line">service ueventd /sbin/ueventd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class"><span class="title">critical</span></span></span><br><span class="line">seclabel u:r:ueventd:s0</span><br><span class="line"></span><br><span class="line">service healthd /sbin/healthd</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class"><span class="title">critical</span></span></span><br><span class="line">seclabel u:r:healthd:s0</span><br><span class="line">group root system wakelock</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h4 id="3-4、启动Zygote进程"><a href="#3-4、启动Zygote进程" class="headerlink" title="3.4、启动Zygote进程"></a>3.4、启动Zygote进程</h4><p>init进程初始化结束时，会启动Zygote进程。Zygote进程负责fork出应用进程，是所有应用进程的父进程。Zygote进程初始化时会创建Dalivik虚拟机、预装系统的资源文件和Java类。所有从Zygote进程fork出的用户进程将继承和共享这些预加载的资源，不用浪费时间重新加载，加快了应用程序的启动过程。启动结束后，Zygote进程也将变成守护进程，负责响应和启动APK应用程序的请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/system/core/rootdir/init.zygote64.rc</span><br><span class="line">service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class"><span class="title">socket</span> <span class="title">zygote</span> <span class="title">stream</span> 660 <span class="title">root</span> <span class="title">system</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">android_power</span>/<span class="title">request_state</span> <span class="title">wake</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">write</span> /<span class="title">sys</span>/<span class="title">power</span>/<span class="title">state</span> <span class="title">on</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class"><span class="title">onrestart</span> <span class="title">restart</span> <span class="title">netd</span></span></span><br><span class="line"><span class="class"><span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">foreground</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure><h4 id="3-5、启动SystemServer"><a href="#3-5、启动SystemServer" class="headerlink" title="3.5、启动SystemServer"></a>3.5、启动SystemServer</h4><p>SystemServer是Zygote进程fork出的第一个进程，也是整个Android系统的核心进程。在SystemServer中运行着系统大部分的Binder服务，SystemServer首先启动本地服务SensorService；接着启动ActivityManagerService、WindowManagerService、PackageManagerService在内的所有Java服务。</p><p>Zygote进程fork出System Server进程，System Server是Zygote孵化的第一个进程，地位非常重要； System Server进程：负责启动和管理整个Java framework，包含ActivityManager，PowerManager等服务。 Media Server进程：负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/java/com/android/server/SystemServer.java</span><br><span class="line">SystemServer().run()</span><br></pre></td></tr></table></figure><h4 id="3-6、启动ActivityManagerService"><a href="#3-6、启动ActivityManagerService" class="headerlink" title="3.6、启动ActivityManagerService"></a>3.6、启动ActivityManagerService</h4><h4 id="3-7、启动Launcher-Activity"><a href="#3-7、启动Launcher-Activity" class="headerlink" title="3.7、启动Launcher(Activity)"></a>3.7、启动Launcher(Activity)</h4><p>SystemServer加载完所有的Java服务后，最后会调用ActivityManagerService的SystemReady()方法，在这个方法的执行中，会发出Intent”android.intent.category.HOME”。凡是响应这个Intent的APK都会运行起来，Launcher应用就是Android系统默认的桌面应用，一般只有它会响应这个Intent，因此，系统开机后，第一个运行的应用就是Launcher。 Zygote进程孵化出的第一个App进程是Launcher；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</span><br><span class="line">startHomeActivityLocked(mCurrentUserId, <span class="string">"systemReady"</span>);</span><br></pre></td></tr></table></figure><h3 id="四、设备启动过程详细分析"><a href="#四、设备启动过程详细分析" class="headerlink" title="四、设备启动过程详细分析"></a>四、设备启动过程详细分析</h3><h3 id="（1）、启动Init进程"><a href="#（1）、启动Init进程" class="headerlink" title="（1）、启动Init进程"></a>（1）、启动Init进程</h3><p>概述： init是Linux系统中用户空间的第一个进程，进程号为1。Kernel启动后，在用户空间，启动init进程，并调用init中的main()方法执行init进程的职责。对于init进程的功能分为4部分：</p><p>分析和运行所有的init.rc文件; 生成设备驱动节点; （通过rc文件创建） 处理子进程的终止(signal方式); 提供属性服务。 接下来从main()方法说起。</p><h4 id="4-1-1、main"><a href="#4-1-1、main" class="headerlink" title="4.1.1、main()"></a>4.1.1、main()</h4><p>[-&gt; init.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"watchdogd"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> watchdogd_main(argc, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear the umask.</span></span><br><span class="line"><span class="comment">//设置文件属性0777</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--second-stage"</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line"><span class="comment">// on / and then we'll let the rc file figure out the rest.</span></span><br><span class="line"><span class="comment">//创建文件系统目录并挂载相关的文件系统</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">    mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">    mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">    mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</span><br><span class="line">    mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We must have some place other than / to create the device nodes for</span></span><br><span class="line"><span class="comment">// kmsg and null, otherwise we won't be able to remount / read-only</span></span><br><span class="line"><span class="comment">// later on. Now that tmpfs is mounted on /dev, we can actually talk</span></span><br><span class="line"><span class="comment">// to the outside world.</span></span><br><span class="line"><span class="comment">//屏蔽标准的输入输出</span></span><br><span class="line">open_devnull_stdio();</span><br><span class="line"> <span class="comment">//初始化kernel log，位于设备节点/dev/kmsg</span></span><br><span class="line">klog_init();</span><br><span class="line"> <span class="comment">//设置输出的log级别</span></span><br><span class="line">klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line"> <span class="comment">// 输出init启动阶段的log</span></span><br><span class="line">NOTICE(<span class="string">"init %s started!\n"</span>, is_first_stage ? <span class="string">"first stage"</span> : <span class="string">"second stage"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!is_first_stage) &#123;</span><br><span class="line">    <span class="comment">// Indicate that booting is in progress to background fw loaders, etc.</span></span><br><span class="line">    close(open(<span class="string">"/dev/.booting"</span>, O_WRONLY | O_CREAT | O_CLOEXEC, <span class="number">0000</span>));</span><br><span class="line">    <span class="comment">//创建一块共享的内存空间，用于属性服务</span></span><br><span class="line">    property_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If arguments are passed both on the command line and in DT,</span></span><br><span class="line">    <span class="comment">// properties set in DT always have priority over the command-line ones.</span></span><br><span class="line">    process_kernel_dt();</span><br><span class="line">    process_kernel_cmdline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Propagate the kernel variables to internal variables</span></span><br><span class="line">    <span class="comment">// used by init as well as the current required properties.</span></span><br><span class="line">    export_kernel_boot_props();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.</span></span><br><span class="line">selinux_initialize(is_first_stage);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we're in the kernel domain, re-exec init to transition to the init domain now</span></span><br><span class="line"><span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">    <span class="keyword">if</span> (restorecon(<span class="string">"/init"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"restorecon failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">char</span>* args[] = &#123; path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"--second-stage"</span>), <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (execv(path, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"execv(\"%s\") failed: %s\n"</span>, path, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These directories were necessarily created before initial policy load</span></span><br><span class="line"><span class="comment">// and therefore need their security context restored to the proper value.</span></span><br><span class="line"><span class="comment">// This must happen before /dev is populated by ueventd.</span></span><br><span class="line">NOTICE(<span class="string">"Running restorecon...\n"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev/socket"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev/__properties__"</span>);</span><br><span class="line">restorecon(<span class="string">"/property_contexts"</span>);</span><br><span class="line">restorecon_recursive(<span class="string">"/sys"</span>);</span><br><span class="line"></span><br><span class="line">epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"epoll_create1 failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化子进程退出的信号处理过程</span></span><br><span class="line">signal_handler_init();</span><br><span class="line"></span><br><span class="line">property_load_boot_defaults();</span><br><span class="line">export_oem_lock_status();</span><br><span class="line">start_property_service();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line"></span><br><span class="line">ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">am.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line"><span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">"set_mmap_rnd_bits"</span>);</span><br><span class="line">am.QueueBuiltinAction(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">am.QueueBuiltinAction(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line"><span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bootmode = property_get(<span class="string">"ro.bootmode"</span>);</span><br><span class="line"><span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">        am.ExecuteOneCommand();</span><br><span class="line">        restart_processes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">        timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bootchart_sample(&amp;timeout);</span><br><span class="line"></span><br><span class="line">    epoll_event ev;</span><br><span class="line">    <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"epoll_wait failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">        ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-1-2、创建文件系统目录并挂载相关的文件系统"><a href="#4-1-2、创建文件系统目录并挂载相关的文件系统" class="headerlink" title="4.1.2、创建文件系统目录并挂载相关的文件系统"></a>4.1.2、创建文件系统目录并挂载相关的文件系统</h4><p>此时android的log系统还没有启动，采用kernel的log系统，打开的设备节点/dev/kmsg， 那么可通过cat /dev/kmsg来获取内核log。</p><p>接下来，设置log的输出级别为KLOG_NOTICE_LEVEL(5)，当log级别小于5时则会输出到kernel log， 默认值为3.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add_environment(<span class="string">"PATH"</span>, _PATH_DEFPATH);</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is_first_stage = (argc == <span class="number">1</span>) || (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"--second-stage"</span>) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the basic filesystem setup we need put together in the initramdisk</span></span><br><span class="line"><span class="comment">// on / and then we'll let the rc file figure out the rest.</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line">    mount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, MS_NOSUID, <span class="string">"mode=0755"</span>);</span><br><span class="line">    mkdir(<span class="string">"/dev/pts"</span>, <span class="number">0755</span>);</span><br><span class="line">    mkdir(<span class="string">"/dev/socket"</span>, <span class="number">0755</span>);</span><br><span class="line">    mount(<span class="string">"devpts"</span>, <span class="string">"/dev/pts"</span>, <span class="string">"devpts"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAKE_STR(x) __STRING(x)</span></span><br><span class="line">    mount(<span class="string">"proc"</span>, <span class="string">"/proc"</span>, <span class="string">"proc"</span>, <span class="number">0</span>, <span class="string">"hidepid=2,gid="</span> MAKE_STR(AID_READPROC));</span><br><span class="line">    mount(<span class="string">"sysfs"</span>, <span class="string">"/sys"</span>, <span class="string">"sysfs"</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该部分主要用于创建和挂载启动所需的文件目录。 需要注意的是，在编译Android系统源码时，在生成的根文件系统中，并不存在这些目录，它们是系统运行时的目录，即当系统终止时，就会消失。</p><p>在init初始化过程中，Android分别挂载了tmpfs，devpts，proc，sysfs这4类文件系统。</p><p>tmpfs是一种虚拟内存文件系统，它会将所有的文件存储在虚拟内存中，如果你将tmpfs文件系统卸载后，那么其下的所有的内容将不复存在。 tmpfs既可以使用RAM，也可以使用交换分区，会根据你的实际需要而改变大小。tmpfs的速度非常惊人，毕竟它是驻留在RAM中的，即使用了交换分区，性能仍然非常卓越。 由于tmpfs是驻留在RAM的，因此它的内容是不持久的。断电后，tmpfs的内容就消失了，这也是被称作tmpfs的根本原因。</p><p>devpts文件系统为伪终端提供了一个标准接口，它的标准挂接点是/dev/ pts。只要pty的主复合设备/dev/ptmx被打开，就会在/dev/pts下动态的创建一个新的pty设备文件。</p><p>proc文件系统是一个非常重要的虚拟文件系统，它可以看作是内核内部数据结构的接口，通过它我们可以获得系统的信息，同时也能够在运行时修改特定的内核参数。</p><p>与proc文件系统类似，sysfs文件系统也是一个不占有任何磁盘空间的虚拟文件系统。它通常被挂接在/sys目录下。sysfs文件系统是Linux2.6内核引入的，它把连接在系统上的设备和总线组织成为一个分级的文件，使得它们可以在用户空间存取。</p><h4 id="4-1-4、屏蔽标准的输入输出"><a href="#4-1-4、屏蔽标准的输入输出" class="headerlink" title="4.1.4、屏蔽标准的输入输出"></a>4.1.4、屏蔽标准的输入输出</h4><p>[-&gt; init.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">open_devnull_stdio</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Try to avoid the mknod() call if we can. Since SELinux makes</span></span><br><span class="line"><span class="comment">// a /dev/null replacement available for free, let's use it.</span></span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/sys/fs/selinux/null"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// OOPS, /sys/fs/selinux/null isn't available, likely because</span></span><br><span class="line">    <span class="comment">// /sys/fs/selinux isn't mounted. Fall back to mknod.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="string">"/dev/__null__"</span>;</span><br><span class="line">    <span class="keyword">if</span> (mknod(name, S_IFCHR | <span class="number">0600</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | <span class="number">3</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        fd = open(name, O_RDWR);</span><br><span class="line">        unlink(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dup2(fd, <span class="number">0</span>);</span><br><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line">dup2(fd, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &gt; <span class="number">2</span>) &#123;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前文生成/dev目录后，init进程将调用open_devnull_stdio函数，屏蔽标准的输入输出。 open_devnull_stdio函数会在/dev目录下生成<strong>null</strong>设备节点文件，并将标准输入、标准输出、标准错误输出全部重定向到<strong>null</strong>设备中。 open_devnull_stdio函数定义于system/core/init/util.cpp中。</p><p>这里需要说明的是，dup2函数的作用是用来复制一个文件的描述符，通常用来重定向进程的stdin、stdout和stderr。它的函数原形是：</p><p>int dup2(int oldfd, int targetfd)</p><p>该函数执行后，targetfd将变成oldfd的复制品。</p><p>因此上述过程其实就是：创建出<strong>null</strong>设备后，将0、1、2绑定到<strong>null</strong>设备上。因此init进程调用open_devnull_stdio函数后，通过标准的输入输出无法输出信息。</p><h4 id="4-1-5、初始化内核log系统"><a href="#4-1-5、初始化内核log系统" class="headerlink" title="4.1.5、初始化内核log系统"></a>4.1.5、初始化内核log系统</h4><p>我们继续回到init进程的main函数，init进程通过klog_init函数，提供输出log信息的设备。 [-&gt; init.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">klog_init();</span><br><span class="line">klog_set_level(KLOG_NOTICE_LEVEL);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">klog_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (klog_fd &gt;= <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">/* Already initialized */</span></span><br><span class="line"></span><br><span class="line">klog_fd = open(<span class="string">"/dev/kmsg"</span>, O_WRONLY | O_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (klog_fd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"/dev/__kmsg__"</span>;</span><br><span class="line"><span class="keyword">if</span> (mknod(name, S_IFCHR | <span class="number">0600</span>, (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) | <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    klog_fd = open(name, O_WRONLY | O_CLOEXEC);</span><br><span class="line">    unlink(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>klog_init函数定义于system/core/libcutils/klog.c中。通过klog_init函数，init进程生成kmsg设备节点文件。该设备可以调用内核信息输出函数printk，以输出log信息。</p><h4 id="4-1-6、初始化属性域"><a href="#4-1-6、初始化属性域" class="headerlink" title="4.1.6、初始化属性域"></a>4.1.6、初始化属性域</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!is_first_stage) &#123;</span><br><span class="line">.......</span><br><span class="line">property_init();</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用property_init初始化属性域。在Android平台中，为了让运行中的所有进程共享系统运行时所需要的各种设置值，系统开辟了属性存储区域，并提供了访问该区域的API。</p><p>这里存在一个问题是，在init进程中有部分代码块以is_first_stage标志进行区分，决定是否需要进行初始化。 is_first_stage的值，由init进程main函数的入口参数决定，之前不太明白具体的含义。 后来写博客后，有朋友留言，在引入selinux机制后，有些操作必须要在内核态才能完成； 但init进程作为android的第一个进程，又是运行在用户态的。 于是，最终设计为用is_first_stage进行区分init进程的运行状态。init进程在运行的过程中，会完成从内核态到用户态的切换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (__system_property_area_init()) &#123;</span><br><span class="line">    ERROR(<span class="string">"Failed to initialize property area\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>property_init函数定义于system/core/init/property_service.cpp中，如上面代码所示，最终调用_system_property_area_init函数初始化属性域。</p><h4 id="4-1-7、完成SELinux相关工作"><a href="#4-1-7、完成SELinux相关工作" class="headerlink" title="4.1.7、完成SELinux相关工作"></a>4.1.7、完成SELinux相关工作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.</span></span><br><span class="line">selinux_initialize(is_first_stage);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selinux_initialize</span><span class="params">(<span class="keyword">bool</span> in_kernel_domain)</span> </span>&#123;</span><br><span class="line">Timer t;</span><br><span class="line"></span><br><span class="line">selinux_callback cb;</span><br><span class="line"><span class="comment">//用于打印log的回调函数</span></span><br><span class="line">cb.func_log = selinux_klog_callback;</span><br><span class="line">selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"><span class="comment">//用于检查权限的回调函数</span></span><br><span class="line">cb.func_audit = audit_callback;</span><br><span class="line">selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_kernel_domain) &#123;</span><br><span class="line">   <span class="comment">//内核态处理流程</span></span><br><span class="line">    INFO(<span class="string">"Loading SELinux policy...\n"</span>);</span><br><span class="line">    <span class="comment">//用于加载sepolicy文件。该函数最终将sepolicy文件传递给kernel，这样kernel就有了安全策略配置文件，后续的MAC才能开展起来。</span></span><br><span class="line">    <span class="keyword">if</span> (selinux_android_load_policy() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"failed to load policy: %s\n"</span>, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内核中读取的信息</span></span><br><span class="line">    <span class="keyword">bool</span> kernel_enforcing = (security_getenforce() == <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//命令行中得到的数据</span></span><br><span class="line">    <span class="keyword">bool</span> is_enforcing = selinux_is_enforcing();</span><br><span class="line">    <span class="keyword">if</span> (kernel_enforcing != is_enforcing) &#123;</span><br><span class="line">        <span class="comment">//用于设置selinux的工作模式。selinux有两种工作模式：</span></span><br><span class="line">        <span class="comment">//1、”permissive”，所有的操作都被允许（即没有MAC），但是如果违反权限的话，会记录日志</span></span><br><span class="line">        <span class="comment">//2、”enforcing”，所有操作都会进行权限检查。在一般的终端中，应该工作于enforing模式</span></span><br><span class="line">        <span class="keyword">if</span> (security_setenforce(is_enforcing)) &#123;</span><br><span class="line">            ERROR(<span class="string">"security_setenforce(%s) failed: %s\n"</span>,</span><br><span class="line">                  is_enforcing ? <span class="string">"true"</span> : <span class="string">"false"</span>, strerror(errno));</span><br><span class="line">            <span class="comment">//将重启进入recovery mode</span></span><br><span class="line">            security_failure();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (write_file(<span class="string">"/sys/fs/selinux/checkreqprot"</span>, <span class="string">"0"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NOTICE(<span class="string">"(Initializing SELinux %s took %.2fs.)\n"</span>,</span><br><span class="line">           is_enforcing ? <span class="string">"enforcing"</span> : <span class="string">"non-enforcing"</span>, t.duration());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    selinux_init_all_handles();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init进程进程调用selinux_initialize启动SELinux。从注释来看，init进程的运行确实是区分用户态和内核态的。</p><h4 id="4-1-8、重新设置属性"><a href="#4-1-8、重新设置属性" class="headerlink" title="4.1.8、重新设置属性"></a>4.1.8、重新设置属性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we're in the kernel domain, re-exec init to transition to the init domain now</span></span><br><span class="line"><span class="comment">// that the SELinux policy has been loaded.</span></span><br><span class="line"><span class="keyword">if</span> (is_first_stage) &#123;</span><br><span class="line"><span class="comment">//按selinux policy要求，重新设置init文件属性</span></span><br><span class="line">    <span class="keyword">if</span> (restorecon(<span class="string">"/init"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"restorecon failed: %s\n"</span>, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* path = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">char</span>* args[] = &#123; path, <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(<span class="string">"--second-stage"</span>), <span class="literal">nullptr</span> &#125;;</span><br><span class="line">    <span class="comment">//这里就是前面所说的，启动用户态的init进程，即second-stage</span></span><br><span class="line">    <span class="keyword">if</span> (execv(path, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"execv(\"%s\") failed: %s\n"</span>, path, strerror(errno));</span><br><span class="line">        security_failure();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These directories were necessarily created before initial policy load</span></span><br><span class="line"><span class="comment">// and therefore need their security context restored to the proper value.</span></span><br><span class="line"><span class="comment">// This must happen before /dev is populated by ueventd.</span></span><br><span class="line">NOTICE(<span class="string">"Running restorecon...\n"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev/socket"</span>);</span><br><span class="line">restorecon(<span class="string">"/dev/__properties__"</span>);</span><br><span class="line">restorecon(<span class="string">"/property_contexts"</span>);</span><br><span class="line">restorecon_recursive(<span class="string">"/sys"</span>);</span><br></pre></td></tr></table></figure><p>上述文件节点在加载Sepolicy之前已经被创建了，因此在加载完Sepolicy后，需要重新设置相关的属性。</p><h4 id="4-1-9、创建epoll句柄"><a href="#4-1-9、创建epoll句柄" class="headerlink" title="4.1.9、创建epoll句柄"></a>4.1.9、创建epoll句柄</h4><p>如下面代码所示，init进程调用epoll_create1创建epoll句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epoll_fd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line"><span class="keyword">if</span> (epoll_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"epoll_create1 failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在linux的网络编程中，很长的时间都在使用select来做事件触发。在linux新的内核中，有了一种替换它的机制，就是epoll。相比于select，epoll最大的好处在于它不会随着监听fd数目的增长而降低效率。因为在内核中的select实现中，它是采用轮询来处理的，轮询的fd数目越多，自然耗时越多。</p><p>epoll机制一般使用epoll_create(int size)函数创建epoll句柄，size用来告诉内核这个句柄可监听的fd的数目。注意这个参数不同于select()中的第一个参数，在select中需给出最大监听数加1的值。 此外，当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，能够看到创建出的fd，因此在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。 上述代码使用的epoll_create1(EPOLLCLOEXEC)来创建epoll句柄，该标志位表示生成的epoll fd具有”执行后关闭”特性。</p><h4 id="4-1-10、装载子进程信号处理器"><a href="#4-1-10、装载子进程信号处理器" class="headerlink" title="4.1.10、装载子进程信号处理器"></a>4.1.10、装载子进程信号处理器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_handler_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create a signalling mechanism for SIGCHLD.</span></span><br><span class="line"><span class="keyword">int</span> s[<span class="number">2</span>];</span><br><span class="line"><span class="comment">//利用socketpair创建出已经连接的两个socket，分别作为信号的读、写端</span></span><br><span class="line"><span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="number">0</span>, s) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"socketpair failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">signal_write_fd = s[<span class="number">0</span>];</span><br><span class="line">signal_read_fd = s[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write to signal_write_fd if we catch SIGCHLD.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;act, <span class="number">0</span>, <span class="keyword">sizeof</span>(act));</span><br><span class="line"><span class="comment">//信号处理器为SIGCHLD_handler，其被存在sigaction结构体中，负责处理SIGCHLD消息</span></span><br><span class="line">act.sa_handler = SIGCHLD_handler;</span><br><span class="line">act.sa_flags = SA_NOCLDSTOP;</span><br><span class="line"><span class="comment">//调用信号安装函数sigaction，将监听的信号及对应的信号处理器注册到内核中</span></span><br><span class="line">sigaction(SIGCHLD, &amp;act, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//相对于6.0的代码，进一步作了封装，用于终止出现问题的子进程，详细代码于后文分析。</span></span><br><span class="line">ServiceManager::GetInstance().ReapAnyOutstandingChildren();</span><br><span class="line"></span><br><span class="line">register_epoll_handler(signal_read_fd, handle_signal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux进程通过互相发送接收消息来实现进程间的通信，这些消息被称为”信号”。每个进程在处理其它进程发送的信号时都要注册处理者，处理者被称为信号处理器。</p><p>注意到sigaction结构体的sa_flags为SA_NOCLDSTOP。由于系统默认在子进程暂停时也会发送信号SIGCHLD，init需要忽略子进程在暂停时发出的SIGCHLD信号，因此将act.sa_flags 置为SA_NOCLDSTOP，该标志位表示仅当进程终止时才接受SIGCHLD信号。</p><p>我们来看看SIGCHLD_handler的具体工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SIGCHLD_handler</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (TEMP_FAILURE_RETRY(write(signal_write_fd, <span class="string">"1"</span>, <span class="number">1</span>)) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"write(signal_write_fd) failed: %s\n"</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码我们知道，init进程是所有进程的父进程，当其子进程终止产生SIGCHLD信号时，SIGCHLD_handler对signal_write_fd执行写操作。由于socketpair的绑定关系，这将触发信号对应的signal_read_fd收到数据。</p><p>在装载信号监听器的最后，signal_handler_init调用register_epoll_handler，其代码如下所示，传入参数分别为signal_read_fd和handle_signal。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void register_epoll_handler(int fd, void (*fn)()) &#123;</span><br><span class="line">epoll_event ev;</span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(fn);</span><br><span class="line"><span class="comment">//epoll_fd增加一个监听对象fd,fd上有数据到来时，调用fn处理</span></span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"epoll_ctl failed: %s\n"</span>, strerror(errno));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码，我们知道：当epoll句柄监听到signal_read_fd中有数据可读时，将调用handle_signal进行处理。</p><p>至此，结合上文我们知道：当init进程调用signal_handler_init后，一旦收到子进程终止带来的SIGCHLD消息后，将利用信号处理者SIGCHLD_handler向signal_write_fd写入信息； epoll句柄监听到signal_read_fd收消息后，将调用handle_signal进行处理。整个过程如下图所示。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N05-android-system-start-signal_handler.jpg" alt="Markdown"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Clear outstanding requests.</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">read(signal_read_fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">ServiceManager::GetInstance().ReapAnyOutstandingChildren();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，handle_signal只是清空signal_read_fd中的数据，然后调用ServiceManager::GetInstance().ReapAnyOutstandingChildren()。</p><p>ServiceManager定义于system/core/init/service.cpp中，是一个单例对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">............</span><br><span class="line"><span class="comment">//C++中默认是private属性</span></span><br><span class="line">ServiceManager::ServiceManager() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ServiceManager&amp; ServiceManager::GetInstance() &#123;</span><br><span class="line"><span class="keyword">static</span> ServiceManager instance;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ServiceManager::ReapAnyOutstandingChildren() &#123;</span><br><span class="line"><span class="keyword">while</span> (ReapOneProcess()) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">............</span><br></pre></td></tr></table></figure><p>ReapAnyOutstandingChildren函数实际上调用了ReapOneProcess。 我们结合代码，看看ReapOneProcess的具体工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ServiceManager::ReapOneProcess() &#123;</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"><span class="comment">//用waitpid函数获取状态发生变化的子进程pid</span></span><br><span class="line"><span class="comment">//waitpid的标记为WNOHANG，即非阻塞，返回为正值就说明有进程挂掉了</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = TEMP_FAILURE_RETRY(waitpid(<span class="number">-1</span>, &amp;status, WNOHANG));</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"waitpid failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用FindServiceByPid函数，找到pid对应的服务。</span></span><br><span class="line"><span class="comment">//FindServiceByPid主要通过轮询解析init.rc生成的service_list，找到pid与参数一致的srvc。</span></span><br><span class="line">Service* svc = FindServiceByPid(pid);</span><br><span class="line"><span class="comment">//输出服务结束的原因</span></span><br><span class="line">.........</span><br><span class="line"><span class="keyword">if</span> (!svc) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束服务，相对于6.0作了进一步的封装</span></span><br><span class="line"><span class="keyword">if</span> (svc-&gt;Reap()) &#123;</span><br><span class="line">    waiting_for_exec = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//移除服务对应的信息</span></span><br><span class="line">    RemoveService(*svc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> Service::Reap() &#123;</span><br><span class="line"><span class="comment">//清理未携带SVC_ONESHOT 或 携带了SVC_RESTART标志的srvc的子进程</span></span><br><span class="line"><span class="keyword">if</span> (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">    NOTICE(<span class="string">"Service '%s' (pid %d) killing any children in process group\n"</span>, name_.c_str(), pid_);</span><br><span class="line">    kill(-pid_, SIGKILL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清除srvc中创建出的socket</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; si : sockets_) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> tmp = StringPrintf(ANDROID_SOCKET_DIR <span class="string">"/%s"</span>, si.name.c_str());</span><br><span class="line">    unlink(tmp.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flags_ &amp; SVC_EXEC) &#123;</span><br><span class="line">    INFO(<span class="string">"SVC_EXEC pid %d finished...\n"</span>, pid_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pid_ = <span class="number">0</span>;</span><br><span class="line">flags_ &amp;= (~SVC_RUNNING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于携带了SVC_ONESHOT并且未携带SVC_RESTART的srvc，将这类服务的标志置为SVC_DISABLED，不再启动</span></span><br><span class="line"><span class="keyword">if</span> ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">    flags_ |= SVC_DISABLED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Disabled and reset processes do not get restarted automatically.</span></span><br><span class="line"><span class="keyword">if</span> (flags_ &amp; (SVC_DISABLED | SVC_RESET))  &#123;</span><br><span class="line">    svc-&gt;NotifyStateChange(<span class="string">"stopped"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">time_t</span> now = gettime();</span><br><span class="line"><span class="comment">//未携带SVC_RESTART的关键服务，在规定的间隔内，crash字数过多时，会导致整机重启；</span></span><br><span class="line"><span class="keyword">if</span> ((flags_ &amp; SVC_CRITICAL) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (time_crashed_ + CRITICAL_CRASH_WINDOW &gt;= now) &#123;</span><br><span class="line">        <span class="keyword">if</span> (++nr_crashed_ &gt; CRITICAL_CRASH_THRESHOLD) &#123;</span><br><span class="line">            ..........</span><br><span class="line">            android_reboot(ANDROID_RB_RESTART2, <span class="number">0</span>, <span class="string">"recovery"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        time_crashed_ = now;</span><br><span class="line">        nr_crashed_ = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将待重启srvc的标志位置为SVC_RESTARTING（init进程将根据该标志位，重启服务）</span></span><br><span class="line">flags_ &amp;= (~SVC_RESTART);</span><br><span class="line">flags_ |= SVC_RESTARTING;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute all onrestart commands for this service.</span></span><br><span class="line"><span class="comment">//重启在init.rc文件中带有onrestart选项的服务，相对于6.0，此处也增加了封装性</span></span><br><span class="line">onrestart_.ExecuteAllCommands();</span><br><span class="line"></span><br><span class="line">svc-&gt;NotifyStateChange(<span class="string">"restarting"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Action::ExecuteAllCommands() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : commands_) &#123;</span><br><span class="line">    ExecuteCommand(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Action::ExecuteCommand(<span class="keyword">const</span> Command&amp; command) <span class="keyword">const</span> &#123;</span><br><span class="line">Timer t;</span><br><span class="line"><span class="comment">//服务重启时，将执行对应的选项</span></span><br><span class="line"><span class="keyword">int</span> result = command.InvokeFunc();</span><br><span class="line"><span class="comment">//打印log</span></span><br><span class="line">........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitpid的函数原型为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options)</span><br></pre></td></tr></table></figure><p>其中，第一个参数pid为预等待的子进程的识别码，pid=-1表示等待任何子进程是否发出SIGCHLD。第二个参数status，用于返回子进程的结束状态。第三个参数决定waitpid函数是否处于阻塞处理方式，WNOHANG表示若pid指定的子进程没有结束，则waitpid()函数返回0，不予等待；若子进程结束，则返回子进程的pid。waitpid如果出错，则返回-1。</p><p>总结一下：整个signal_handler_init其实就是为了重启子进程用的，上述过程其实最终可以简化为下图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N06-android-system-start-signal.jpg" alt="Markdown"></p><h4 id="4-1-11、设置默认系统属性"><a href="#4-1-11、设置默认系统属性" class="headerlink" title="4.1.11、设置默认系统属性"></a>4.1.11、设置默认系统属性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">property_load_boot_defaults();</span><br></pre></td></tr></table></figure><p>接下来，进程调用property_load_boot_defaults进行默认属性配置相关的工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">property_load_boot_defaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如代码所示，property_load_boot_defaults实际上就是调用load_properties_from_file解析配置文件；然后根据解析的结果，设置系统属性。该部分功能较为单一，不再深入分析。</p><h4 id="4-1-12、配置属性的服务端"><a href="#4-1-12、配置属性的服务端" class="headerlink" title="4.1.12、配置属性的服务端"></a>4.1.12、配置属性的服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">start_property_service();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_property_service</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建了一个非阻塞socket</span></span><br><span class="line">property_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, <span class="number">0666</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (property_set_fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    ERROR(<span class="string">"start_property_service socket creation failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用listen函数监听property_set_fd， 于是该socket变成一个server</span></span><br><span class="line">listen(property_set_fd, <span class="number">8</span>);</span><br><span class="line"><span class="comment">//监听server socket上是否有数据到来</span></span><br><span class="line">register_epoll_handler(property_set_fd,  handle_property_set_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，在create_socket函数返回套接字property_set_fd时，property_set_fd是一个主动连接的套接字。此时，系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接。</p><p>由于在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接，于是需要调用listen函数使用主动连接套接字变为被连接套接字，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程。</p><p>因此，调用listen后，init进程成为一个服务进程，其它进程可以通过property_set_fd连接init进程，提交设置系统属性的申请。</p><p>listen函数的第二个参数，涉及到一些网络的细节。</p><p>在进程处理一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态。有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。</p><p>因此，内核会在自己的进程空间里维护一个队列，以跟踪那些已完成连接但服务器进程还没有接手处理的用户，或正在进行的连接的用户。这样的一个队列不可能任意大，所以必须有一个上限。listen的第二个参数就是告诉内核使用这个数值作为上限。因此，init进程作为系统属性设置的服务器，最多可以同时为8个试图设置属性的用户提供服务。</p><p>在启动配置属性服务的最后，调用函数register_epoll_handler。根据上文所述，我们知道该函数将利用之前创建出的epoll句柄监听property_set_fd。当property_set_fd中有数据到来时，init进程将利用handle_property_set_fd函数进行处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_property_set_fd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ..........</span><br><span class="line">    <span class="keyword">if</span> ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ........</span><br><span class="line">    r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, <span class="keyword">sizeof</span>(msg), MSG_DONTWAIT));</span><br><span class="line">    .........</span><br><span class="line">    <span class="keyword">switch</span>(msg.cmd) &#123;</span><br><span class="line">    .........</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>handle_propery_set_fd函数实际上是调用accept函数监听连接请求，接收property_set_fd中到来的数据，然后利用recv函数接受到来的数据，最后根据到来数据的类型，进行设置系统属性等相关操作，在此不做深入分析。</p><p>在这一部分的最后，我们简单举例介绍一下，系统属性改变的一些用途。 在init.rc中定义了一些与属性相关的触发器。当某个条件相关的属性被改变时，与该条件相关的触发器就会被触发。举例来说，如下面代码所示，debuggable属性变为1时，将执行启动console进程等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on property:ro.debuggable=<span class="number">1</span></span><br><span class="line"># Give writes to anyone <span class="keyword">for</span> the trace folder on debug builds.</span><br><span class="line"># The folder is used to store method traces.</span><br><span class="line">chmod <span class="number">0773</span> /data/misc/trace</span><br><span class="line">start console</span><br></pre></td></tr></table></figure><p>总结一下，其它进程修改系统属性时，大致的流程如下图所示：其它的进程像init进程发送请求后，由init进程检查权限后，修改共享内存区。</p><h4 id="4-1-12、解析init-rc文件"><a href="#4-1-12、解析init-rc文件" class="headerlink" title="4.1.12、解析init.rc文件"></a>4.1.12、解析init.rc文件</h4><p>关于解析init.rc的代码，Android 7.0相对于6.0，作了巨大的修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里将Action的function_map_替换为BuiltinFunctionMap</span></span><br><span class="line"><span class="comment">//下文将通过BuiltinFuntionMap的map方法，获取keyword对应的处理函数</span></span><br><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造出解析文件用的parser对象</span></span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line"><span class="comment">//为一些类型的关键字，创建特定的parser</span></span><br><span class="line">parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line"><span class="comment">//开始实际的解析过程</span></span><br><span class="line">parser.ParseConfig(<span class="string">"/init.rc"</span>);</span><br><span class="line">........</span><br></pre></td></tr></table></figure><p>在解析init.rc文件的过程前，我们先来简单介绍一下init.rc文件。 init.rc文件是在init进程启动后执行的启动脚本，文件中记录着init进程需执行的操作。在Android系统中，使用init.rc和init.{ hardware }.rc两个文件。</p><p>其中init.rc文件在Android系统运行过程中用于通用的环境设置与进程相关的定义，init.{hardware}.rc（例如，高通有init.qcom.rc，MTK有init.mediatek.rc）用于定义Android在不同平台下的特定进程和环境设置等。</p><p>此处解析函数传入的参数为”/init.rc”，解析的是运行时与init进程同在根目录下的init.rc文件。该文件在编译前，定义于system/core/rootdir/init.rc中（与平台相关的rc文件不在这里加载）。</p><p>init.rc文件大致分为两大部分，一部分是以”on”关键字开头的动作列表（action list）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    # Set init <span class="keyword">and</span> its forked children's oom_adj.</span><br><span class="line">    write /proc/<span class="number">1</span>/oom_score_adj <span class="number">-1000</span></span><br><span class="line">    .........</span><br><span class="line">    start ueventd</span><br></pre></td></tr></table></figure><p>另一部分是以”service”关键字开头的服务列表（service list）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service ueventd /sbin/ueventd</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span></span></span><br><span class="line"><span class="class">    <span class="title">seclabel</span> <span class="title">u</span>:</span>r:ueventd:s0</span><br></pre></td></tr></table></figure><p>借助系统环境变量或Linux命令，动作列表用于创建所需目录，以及为某些特定文件指定权限，而服务列表用来记录init进程需要启动的一些子进程。如上面代码所示，service关键字后的第一个字符串表示服务（子进程）的名称，第二个字符串表示服务的执行路径。</p><p>接下来，我们从ParseConfig函数入手，逐步分析整个解析过程(函数定义于system/core/init/ init_parser.cpp中)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Parser::ParseConfig(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_dir(path.c_str())) &#123;</span><br><span class="line">        <span class="comment">//传入参数为目录地址</span></span><br><span class="line">        <span class="keyword">return</span> ParseConfigDir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入参数为文件地址</span></span><br><span class="line">    <span class="keyword">return</span> ParseConfigFile(path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Parser::ParseConfigDir(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DIR, <span class="keyword">int</span>(*)(DIR*)&gt; config_dir(opendir(path.c_str()), closedir);</span><br><span class="line">    ..........</span><br><span class="line">    <span class="comment">//看起来很复杂，其实就是递归目录</span></span><br><span class="line">    <span class="keyword">while</span> ((current_file = readdir(config_dir.get()))) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> current_path = android::base::StringPrintf(<span class="string">"%s/%s"</span>, path.c_str(), current_file-&gt;d_name);</span><br><span class="line">        <span class="keyword">if</span> (current_file-&gt;d_type == DT_REG) &#123;</span><br><span class="line">            <span class="comment">//最终还是靠ParseConfigFile来解析实际的文件</span></span><br><span class="line">            <span class="keyword">if</span> (!ParseConfigFile(current_path)) &#123;</span><br><span class="line">                .............</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，解析init.rc文件的函数是ParseConfigFile：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Parser::ParseConfigFile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path) &#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line">    <span class="comment">//读取路径指定文件中的内容，保存为字符串形式</span></span><br><span class="line">    <span class="keyword">if</span> (!read_file(path.c_str(), &amp;data)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">    <span class="comment">//解析获取的字符串</span></span><br><span class="line">    ParseData(path, data);</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ParseData函数定义于system/core/init/init_parser.cpp中，根据关键字解析出服务和动作。动作与服务会以链表节点的形式注册到service_list与action_list中，service_list与action_list是init进程中声明的全局结构体，其中的关键代码下所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Parser::ParseData(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; data) &#123;</span><br><span class="line">.......</span><br><span class="line">parse_state state;</span><br><span class="line">.......</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; args;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">//next_token以行为单位分割参数传递过来的字符串</span></span><br><span class="line">    <span class="comment">//最先走到T_TEXT分支</span></span><br><span class="line">    <span class="keyword">switch</span> (next_token(&amp;state)) &#123;</span><br><span class="line">    <span class="keyword">case</span> T_EOF:</span><br><span class="line">        <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">            <span class="comment">//EOF,解析结束</span></span><br><span class="line">            section_parser-&gt;EndSection();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> T_NEWLINE:</span><br><span class="line">        state.line++;</span><br><span class="line">        <span class="keyword">if</span> (args.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在前文创建parser时，我们为service，on，import定义了对应的parser</span></span><br><span class="line">        <span class="comment">//这里就是根据第一个参数，判断是否有对应的parser</span></span><br><span class="line">        <span class="keyword">if</span> (section_parsers_.count(args[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">                <span class="comment">//结束上一个parser的工作，将构造出的对象加入到对应的service_list与action_list中</span></span><br><span class="line">                section_parser-&gt;EndSection();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取参数对应的parser</span></span><br><span class="line">            section_parser = section_parsers_[args[<span class="number">0</span>]].get();</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">            <span class="comment">//调用实际parser的ParseSection函数</span></span><br><span class="line">            <span class="keyword">if</span> (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123;</span><br><span class="line">                parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</span><br><span class="line">                section_parser = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (section_parser) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> ret_err;</span><br><span class="line">            <span class="comment">//如果第一个参数不是service，on，import</span></span><br><span class="line">            <span class="comment">//则调用前一个parser的ParseLineSection函数</span></span><br><span class="line">            <span class="comment">//这里相当于解析一个参数块的子项</span></span><br><span class="line">            <span class="keyword">if</span> (!section_parser-&gt;ParseLineSection(args, state.filename, state.line, &amp;ret_err)) &#123;</span><br><span class="line">                parse_error(&amp;state, <span class="string">"%s\n"</span>, ret_err.c_str());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空本次解析的数据</span></span><br><span class="line">        args.clear();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> T_TEXT:</span><br><span class="line">        <span class="comment">//将本次解析的内容写入到args中</span></span><br><span class="line">        args.emplace_back(state.text);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的解析看起来比较复杂，在6.0以前的版本中，整个解析是面向过程的。init进程统一调用一个函数来进行解析，然后在该函数中利用switch-case的形式，根据解析的内容进行相应的处理。 在Android 7.0中，为了更好地封装及面向对象，对于不同的关键字定义了不同的parser对象，每个对象通过多态实现自己的解析操作。</p><p>我们现在回忆一下init进程main函数中，创建parser的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...........</span><br><span class="line">Parser&amp; parser = Parser::GetInstance();</span><br><span class="line">parser.AddSectionParser(<span class="string">"service"</span>,<span class="built_in">std</span>::make_unique&lt;ServiceParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"on"</span>, <span class="built_in">std</span>::make_unique&lt;ActionParser&gt;());</span><br><span class="line">parser.AddSectionParser(<span class="string">"import"</span>, <span class="built_in">std</span>::make_unique&lt;ImportParser&gt;());</span><br><span class="line">...........</span><br></pre></td></tr></table></figure><p>看看三个Parser的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServiceParser</span> :</span> <span class="keyword">public</span> SectionParser &#123;......&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionParser</span> :</span> <span class="keyword">public</span> SectionParser &#123;......&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImportParser</span> :</span> <span class="keyword">public</span> SectionParser &#123;.......&#125;</span><br></pre></td></tr></table></figure><p>可以看到三个Parser均是继承SectionParser，具体的实现各有不同，我们以比较常用的ServiceParser和ActionParser为例，看看解析的结果如何处理。</p><h5 id="4-1-12-1-ServiceParser"><a href="#4-1-12-1-ServiceParser" class="headerlink" title="4.1.12..1 ServiceParser"></a>4.1.12..1 ServiceParser</h5><p>ServiceParser定义于system/core/init/service.cpp中。从前面的代码，我们知道，解析一个service块，首先需要调用ParseSection函数，接着利用ParseLineSection处理子块，解析完所有数据后，调用EndSection。 因此，我们着重看看ServiceParser的这三个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">bool</span> ServiceParser::ParseSection(.....) &#123;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name = args[<span class="number">1</span>];</span><br><span class="line">    .......</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; str_args(args.begin() + <span class="number">2</span>, args.end());</span><br><span class="line">    <span class="comment">//主要根据参数，构造出一个service对象</span></span><br><span class="line">    service_ = <span class="built_in">std</span>::make_unique&lt;Service&gt;(name, <span class="string">"default"</span>, str_args);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意这里已经在解析子项了</span></span><br><span class="line"><span class="keyword">bool</span> ServiceParser::ParseLineSection(......) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">//调用service对象的HandleLine</span></span><br><span class="line">    <span class="keyword">return</span> service_ ? service_-&gt;HandleLine(args, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Service::HandleLine(.....) &#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//OptionHandlerMap继承自keywordMap&lt;OptionHandler&gt;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> OptionHandlerMap handler_map;</span><br><span class="line">    <span class="comment">//根据子项的内容，找到对应的handler函数</span></span><br><span class="line">    <span class="comment">//FindFunction定义与keyword模块中,FindFunction方法利用子类生成对应的map中，然后通过通用的查找方法，即比较键值找到对应的处理函数</span></span><br><span class="line">    <span class="keyword">auto</span> handler = handler_map.FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用handler函数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;*handler)(args, err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span>:</span>:OptionHandlerMap : <span class="keyword">public</span> KeywordMap&lt;OptionHandler&gt; &#123;</span><br><span class="line">    ...........</span><br><span class="line">    Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map option_handlers = &#123;</span><br><span class="line">        &#123;<span class="string">"class"</span>,       &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleClass&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"console"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleConsole&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"critical"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleCritical&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"disabled"</span>,    &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleDisabled&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"group"</span>,       &#123;<span class="number">1</span>,     NR_SVC_SUPP_GIDS + <span class="number">1</span>, &amp;Service::HandleGroup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ioprio"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleIoprio&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"keycodes"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleKeycodes&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"oneshot"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    &amp;Service::HandleOneshot&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"onrestart"</span>,   &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleOnrestart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"seclabel"</span>,    &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleSeclabel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setenv"</span>,      &#123;<span class="number">2</span>,     <span class="number">2</span>,    &amp;Service::HandleSetenv&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"socket"</span>,      &#123;<span class="number">3</span>,     <span class="number">6</span>,    &amp;Service::HandleSocket&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"user"</span>,        &#123;<span class="number">1</span>,     <span class="number">1</span>,    &amp;Service::HandleUser&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"writepid"</span>,    &#123;<span class="number">1</span>,     kMax, &amp;Service::HandleWritepid&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> option_handlers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以class对应的处理函数为例，可以看出其实就是填充service对象对应的域</span></span><br><span class="line"><span class="keyword">bool</span> Service::HandleClass(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; args, <span class="built_in">std</span>::<span class="built_in">string</span>* err) &#123;</span><br><span class="line">    classname_ = args[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意此时service对象已经处理完毕</span></span><br><span class="line"><span class="keyword">void</span> ServiceParser::EndSection() &#123;</span><br><span class="line">    <span class="keyword">if</span> (service_) &#123;</span><br><span class="line">        ServiceManager::GetInstance().AddService(<span class="built_in">std</span>::move(service_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ServiceManager::AddService(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Service&gt; service) &#123;</span><br><span class="line">    Service* old_service = FindServiceByName(service-&gt;name());</span><br><span class="line">    <span class="keyword">if</span> (old_service) &#123;</span><br><span class="line">        ERROR(<span class="string">"ignored duplicate definition of service '%s'"</span>,</span><br><span class="line">              service-&gt;name().c_str());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将service对象加入到services_里</span></span><br><span class="line">    <span class="comment">//7.0里，services_已经是个vector了</span></span><br><span class="line">    services_.emplace_back(<span class="built_in">std</span>::move(service));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的一系列代码，我们可以看出ServiceParser其实就是：首先根据第一行的名字和参数创建出service对象，然后根据选项域的内容填充service对象，最后将创建出的service对象加入到vector类型的service链表中。</p><h4 id="4-1-12-2-ActionParser"><a href="#4-1-12-2-ActionParser" class="headerlink" title="4.1.12.2 ActionParser"></a>4.1.12.2 ActionParser</h4><p>ActionParser定义于system/core/init/action.cpp中。Action的解析过程，其实与Service一样，也是先后调用ParseSection， ParseLineSection和EndSection。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ActionParser::ParseSection(....) &#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//创建出新的action对象</span></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//根据参数，填充action的trigger域，不详细分析了</span></span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;InitTriggers(triggers, err)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    .........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ActionParser::ParseLineSection(.......) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">//构造Action对象的command域</span></span><br><span class="line">    <span class="keyword">return</span> action_ ? action_-&gt;AddCommand(args, filename, line, err) : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Action::AddCommand(.....) &#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//找出action对应的执行函数</span></span><br><span class="line">    <span class="keyword">auto</span> function = function_map_-&gt;FindFunction(args[<span class="number">0</span>], args.size() - <span class="number">1</span>, err);</span><br><span class="line">    ........</span><br><span class="line">    <span class="comment">//利用所有信息构造出command，加入到action对象中</span></span><br><span class="line">    AddCommand(function, args, filename, line);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Action::AddCommand(......) &#123;</span><br><span class="line">    commands_.emplace_back(f, args, filename, line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ActionParser::EndSection() &#123;</span><br><span class="line">    <span class="keyword">if</span> (action_ &amp;&amp; action_-&gt;NumCommands() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ActionManager::GetInstance().AddAction(<span class="built_in">std</span>::move(action_));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ActionManager::AddAction(.....) &#123;</span><br><span class="line">    ........</span><br><span class="line">    <span class="keyword">auto</span> old_action_it = <span class="built_in">std</span>::find_if(actions_.begin(),</span><br><span class="line">                     actions_.end(),</span><br><span class="line">                     [&amp;action] (<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123;</span><br><span class="line">                         <span class="keyword">return</span> action-&gt;TriggersEqual(*a);</span><br><span class="line">                     &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (old_action_it != actions_.end()) &#123;</span><br><span class="line">        (*old_action_it)-&gt;CombineAction(*action);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//加入到action链表中，类型也是vector，其中装的是指针</span></span><br><span class="line">        actions_.emplace_back(<span class="built_in">std</span>::move(action));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，加载action块的逻辑和service一样，不同的是需要填充trigger和command域。当然，最后解析出的action也需要加入到action链表中。</p><p>这里最后还剩下一个问题，那就是哪里定义了Action中command对应处理函数？ 实际上，前文已经出现了过了，在init.cpp的main函数中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line"><span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line">Action::set_function_map(&amp;function_map);</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p>因此，Action中调用function<em>map</em>-&gt;FindFunction时，实际上调用的是BuiltinFunctionMap的FindFunction函数。我们已经知道FindFunction是keyword定义的通用函数，重点是重构的map函数。我们看看system/core/init/builtins.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::<span class="built_in">map</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> kMax = <span class="built_in">std</span>::numeric_limits&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;::max();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Map builtin_functions = &#123;</span><br><span class="line">        &#123;<span class="string">"bootchart_init"</span>,          &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_bootchart_init&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chmod"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_chmod&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"chown"</span>,                   &#123;<span class="number">2</span>,     <span class="number">3</span>,    do_chown&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_reset"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_reset&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_start"</span>,             &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"class_stop"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_class_stop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"copy"</span>,                    &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_copy&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"domainname"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_domainname&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"enable"</span>,                  &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_enable&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"exec"</span>,                    &#123;<span class="number">1</span>,     kMax, do_exec&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"export"</span>,                  &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_export&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"hostname"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_hostname&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"ifup"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_ifup&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"init_user0"</span>,              &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_init_user0&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"insmod"</span>,                  &#123;<span class="number">1</span>,     kMax, do_insmod&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"installkey"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_installkey&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_persist_props"</span>,      &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_load_persist_props&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"load_system_props"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_load_system_props&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"loglevel"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_loglevel&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mkdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">4</span>,    do_mkdir&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount_all"</span>,               &#123;<span class="number">1</span>,     kMax, do_mount_all&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"mount"</span>,                   &#123;<span class="number">3</span>,     kMax, do_mount&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"powerctl"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_powerctl&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restart"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_restart&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon"</span>,              &#123;<span class="number">1</span>,     kMax, do_restorecon&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"restorecon_recursive"</span>,    &#123;<span class="number">1</span>,     kMax, do_restorecon_recursive&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rm"</span>,                      &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_rm&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"rmdir"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_rmdir&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setprop"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_setprop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"setrlimit"</span>,               &#123;<span class="number">3</span>,     <span class="number">3</span>,    do_setrlimit&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"start"</span>,                   &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_start&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"stop"</span>,                    &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_stop&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"swapon_all"</span>,              &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_swapon_all&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"symlink"</span>,                 &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_symlink&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"sysclktz"</span>,                &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_sysclktz&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"trigger"</span>,                 &#123;<span class="number">1</span>,     <span class="number">1</span>,    do_trigger&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_load_state"</span>,       &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_verity_load_state&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"verity_update_state"</span>,     &#123;<span class="number">0</span>,     <span class="number">0</span>,    do_verity_update_state&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"wait"</span>,                    &#123;<span class="number">1</span>,     <span class="number">2</span>,    do_wait&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">"write"</span>,                   &#123;<span class="number">2</span>,     <span class="number">2</span>,    do_write&#125;&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> builtin_functions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的第四项就是Action每个command对应的执行函数。</p><h4 id="4-1-13、向执行队列中添加其它action"><a href="#4-1-13、向执行队列中添加其它action" class="headerlink" title="4.1.13、向执行队列中添加其它action"></a>4.1.13、向执行队列中添加其它action</h4><p>介绍完init进程解析init.rc文件的过程后，我们继续将视角拉回到init进程的main函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ActionManager&amp; am = ActionManager::GetInstance();</span><br><span class="line"></span><br><span class="line">am.QueueEventTrigger(<span class="string">"early-init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...</span></span><br><span class="line">m.QueueBuiltinAction(wait_for_coldboot_done_action, <span class="string">"wait_for_coldboot_done"</span>);</span><br><span class="line"><span class="comment">// ... so that we can start queuing up actions that require stuff from /dev.</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line">am.QueueBuiltinAction(set_mmap_rnd_bits_action, <span class="string">"set_mmap_rnd_bits"</span>);</span><br><span class="line">am.QueueBuiltinAction(keychord_init_action, <span class="string">"keychord_init"</span>);</span><br><span class="line">am.QueueBuiltinAction(console_init_action, <span class="string">"console_init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger all the boot actions to get us started.</span></span><br><span class="line">am.QueueEventTrigger(<span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random</span></span><br><span class="line"><span class="comment">// wasn't ready immediately after wait_for_coldboot_done</span></span><br><span class="line">am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, <span class="string">"mix_hwrng_into_linux_rng"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't mount filesystems or start core system services in charger mode.</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> bootmode = property_get(<span class="string">"ro.bootmode"</span>);</span><br><span class="line"><span class="keyword">if</span> (bootmode == <span class="string">"charger"</span>) &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"charger"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    am.QueueEventTrigger(<span class="string">"late-init"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run all property triggers based on current state of the properties.</span></span><br><span class="line">    am.QueueBuiltinAction(queue_property_triggers_action, <span class="string">"queue_property_triggers"</span>);</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，接下来init进程中调用了大量的QueueEventTrigger和QueueBuiltinAction函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ActionManager::QueueEventTrigger(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; trigger) &#123;</span><br><span class="line">    trigger_queue_.push(<span class="built_in">std</span>::make_unique&lt;EventTrigger&gt;(trigger));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处QueueEventTrigger函数就是利用参数构造EventTrigger，然后加入到trigger<em>queue</em>中。后续init进程处理trigger事件时，将会触发相应的操作。根据前文的分析，我们知道实际上就是将action_list中，对应trigger与第一个参数匹配的action，加入到运行队列action_queue中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ActionManager::QueueBuiltinAction(BuiltinFunction func, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) &#123;</span><br><span class="line">    <span class="comment">//创建action</span></span><br><span class="line">    <span class="keyword">auto</span> action = <span class="built_in">std</span>::make_unique&lt;Action&gt;(<span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; name_vector&#123;name&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保证唯一性</span></span><br><span class="line">    <span class="keyword">if</span> (!action-&gt;InitSingleTrigger(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建action的cmd，指定执行函数和参数</span></span><br><span class="line">    action-&gt;AddCommand(func, name_vector);</span><br><span class="line"></span><br><span class="line">    trigger_queue_.push(<span class="built_in">std</span>::make_unique&lt;BuiltinTrigger&gt;(action.get()));</span><br><span class="line">    actions_.emplace_back(<span class="built_in">std</span>::move(action));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueueBuiltinAction函数中构造新的action加入到actions_中，第一个参数作为新建action携带cmd的执行函数；第二个参数既作为action的trigger name，也作为action携带cmd的参数。</p><h4 id="4-1-14、处理添加到运行队列的事件"><a href="#4-1-14、处理添加到运行队列的事件" class="headerlink" title="4.1.14、处理添加到运行队列的事件"></a>4.1.14、处理添加到运行队列的事件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否有事件需要处理</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting_for_exec) &#123;</span><br><span class="line">        <span class="comment">//依次执行每个action中携带command对应的执行函数</span></span><br><span class="line">        am.ExecuteOneCommand();</span><br><span class="line">        <span class="comment">//重启一些挂掉的进程</span></span><br><span class="line">        restart_processes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下决定timeout的时间，将影响while循环的间隔</span></span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//有进程需要重启时，等待该进程重启</span></span><br><span class="line">    <span class="keyword">if</span> (process_needs_restart) &#123;</span><br><span class="line">        timeout = (process_needs_restart - gettime()) * <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">            timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有action待处理，不等待</span></span><br><span class="line">    <span class="keyword">if</span> (am.HasMoreCommands()) &#123;</span><br><span class="line">        timeout = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bootchart_sample应该是进行性能数据采样</span></span><br><span class="line">    bootchart_sample(&amp;timeout);</span><br><span class="line"></span><br><span class="line">    epoll_event ev;</span><br><span class="line">    <span class="comment">//没有事件到来的话，最多阻塞timeout时间</span></span><br><span class="line">    <span class="keyword">int</span> nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, <span class="number">1</span>, timeout));</span><br><span class="line">    <span class="keyword">if</span> (nr == <span class="number">-1</span>) &#123;</span><br><span class="line">        ERROR(<span class="string">"epoll_wait failed: %s\n"</span>, strerror(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nr == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//有事件到来，执行对应处理函数</span></span><br><span class="line">        <span class="comment">//根据上文知道，epoll句柄（即epoll_fd）主要监听子进程结束，及其它进程设置系统属性的请求。</span></span><br><span class="line">        ((<span class="keyword">void</span> (*)()) ev.data.ptr)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出，init进程将所有需要操作的action加入运行队列后， 进入无限循环过程，不断处理运行队列中的事件，同时进行重启service等操作。</p><p>ExecuteOneCommand中的主要部分如下图所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ActionManager::ExecuteOneCommand() &#123;</span><br><span class="line">    <span class="comment">// Loop through the trigger queue until we have an action to execute</span></span><br><span class="line">    <span class="comment">//当有可执行action或trigger queue为空时结束</span></span><br><span class="line">    <span class="keyword">while</span> (current_executing_actions_.empty() &amp;&amp; !trigger_queue_.empty()) &#123;</span><br><span class="line">        <span class="comment">//轮询actions链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; action : actions_) &#123;</span><br><span class="line">            <span class="comment">//依次查找trigger表</span></span><br><span class="line">            <span class="keyword">if</span> (trigger_queue_.front()-&gt;CheckTriggers(*action)) &#123;</span><br><span class="line">                <span class="comment">//当action与trigger对应时，就可以执行当前action</span></span><br><span class="line">                <span class="comment">//一个trigger可以对应多个action，均加入current_executing_actions_</span></span><br><span class="line">                current_executing_actions_.emplace(action.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//trigger event出队</span></span><br><span class="line">        trigger_queue_.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_executing_actions_.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次只执行一个action，下次init进程while循环时，跳过上面的while循环，接着执行</span></span><br><span class="line">    <span class="keyword">auto</span> action = current_executing_actions_.front();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current_command_ == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> trigger_name = action-&gt;BuildTriggersString();</span><br><span class="line">        INFO(<span class="string">"processing action (%s)\n"</span>, trigger_name.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实际的执行过程，此处仅处理当前action中的一个cmd</span></span><br><span class="line">    action-&gt;ExecuteOneCommand(current_command_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适当地清理工作，注意只有当前action中所有的command均执行完毕后，才会将该action从current_executing_actions_移除</span></span><br><span class="line">    <span class="comment">// If this was the last command in the current action, then remove</span></span><br><span class="line">    <span class="comment">// the action from the executing list.</span></span><br><span class="line">    <span class="comment">// If this action was oneshot, then also remove it from actions_.</span></span><br><span class="line">    ++current_command_;</span><br><span class="line">    <span class="keyword">if</span> (current_command_ == action-&gt;NumCommands()) &#123;</span><br><span class="line">        current_executing_actions_.pop();</span><br><span class="line">        current_command_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (action-&gt;oneshot()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> eraser = [&amp;action] (<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Action&gt;&amp; a) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.get() == action;</span><br><span class="line">            &#125;;</span><br><span class="line">            actions_.erase(<span class="built_in">std</span>::remove_if(actions_.begin(), actions_.end(), eraser));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Action::ExecuteCommand(<span class="keyword">const</span> Command&amp; command) <span class="keyword">const</span> &#123;</span><br><span class="line">    Timer t;</span><br><span class="line">    <span class="comment">//执行该command对应的处理函数</span></span><br><span class="line">    <span class="keyword">int</span> result = command.InvokeFunc();</span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，当while循环不断调用ExecuteOneCommand函数时，将按照trigger表的顺序，依次取出action链表中与trigger匹配的action。 每次均执行一个action中的一个command对应函数（一个action可能携带多个command）。 当一个action所有的command均执行完毕后，再执行下一个action。 当一个trigger对应的action均执行完毕后，再执行下一个trigger对应action。</p><p>restart_processes函数负责按需重启service，代码如下图所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restart_processes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    process_needs_restart = <span class="number">0</span>;</span><br><span class="line">    ServiceManager::GetInstance().ForEachServiceWithFlags(</span><br><span class="line">        SVC_RESTARTING,</span><br><span class="line">        [] (Service* s) &#123;</span><br><span class="line">            s-&gt;RestartIfNeeded(process_needs_restart);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，该函数轮询service对应的链表，对于有SVC_RESTARING标志的service执行RestartIfNeeded（如上文所述，当子进程终止时，init进程会将可被重启进程的服务标志位置为SVC_RESTARTING）。</p><p>如下面代码所示，restart_service_if_needed可以重新启动服务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Service::RestartIfNeeded(<span class="keyword">time_t</span>&amp; process_needs_restart)(struct service *svc)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">time_t</span> next_start_time = svc-&gt;time_started + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两次服务启动时间的间隔要大于5s</span></span><br><span class="line">    <span class="keyword">if</span> (next_start_time &lt;= gettime()) &#123;</span><br><span class="line">        svc-&gt;flags &amp;= (~SVC_RESTARTING);</span><br><span class="line">        <span class="comment">//满足时间间隔的要求后，重启服务</span></span><br><span class="line">        <span class="comment">//Start将会重新fork服务进程，并做相应的配置</span></span><br><span class="line">        Start(svc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新main函数中，while循环需要等待的时间</span></span><br><span class="line">    <span class="keyword">if</span> ((next_start_time &lt; process_needs_restart) ||</span><br><span class="line">        (process_needs_restart == <span class="number">0</span>)) &#123;</span><br><span class="line">        process_needs_restart = next_start_time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查阅资料发现：Bootchart 是一个能对 GNU/Linux boot 过程进行性能分析并把结果直观化的工具。它在 boot 过程中搜集资源利用情况及进程信息然后以PNG, SVG或EPS格式来显示结果。BootChart 包含数据收集工具和图像产生工具。数据收集工具在原始的BootChart中是独立的shell程序，但在Android中，数据收集工具被集成到了init 程序中。资料与代码基本吻合。</p><h3 id="（2）、启动Zygote进程"><a href="#（2）、启动Zygote进程" class="headerlink" title="（2）、启动Zygote进程"></a>（2）、启动Zygote进程</h3><h4 id="4-2-1、概述"><a href="#4-2-1、概述" class="headerlink" title="4.2.1、概述"></a>4.2.1、概述</h4><p>Zygote是由init进程通过解析init.zygote.rc文件而创建的，zygote所对应的可执行程序app_process，所对应的源文件是App_main.cpp，进程名为zygote。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote</span><br><span class="line">    class main</span><br><span class="line">    socket zygote stream <span class="number">660</span> root system</span><br><span class="line">    onrestart write /sys/android_power/request_state wake</span><br><span class="line">    onrestart write /sys/power/state on</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart netd</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br><span class="line"></span><br><span class="line">service zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary</span><br><span class="line">    class main</span><br><span class="line">    socket zygote_secondary stream <span class="number">660</span> root system</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    writepid /dev/cpuset/foreground/tasks</span><br></pre></td></tr></table></figure><p>Zygote进程能够重启的地方:</p><p>servicemanager进程被杀; (onresart) surfaceflinger进程被杀; (onresart) Zygote进程自己被杀; (oneshot=false) system_server进程被杀; (waitpid) 从App_main()开始，Zygote启动过程的函数调用类大致流程如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N07-android-system-start-zygote_process.jpg" alt="Markdown"></p><h4 id="4-2-2、Zygote启动过程"><a href="#4-2-2、Zygote启动过程" class="headerlink" title="4.2.2、Zygote启动过程"></a>4.2.2、Zygote启动过程</h4><h5 id="4-2-2-1、App-main-main"><a href="#4-2-2-1、App-main-main" class="headerlink" title="4.2.2.1、App_main.main()"></a>4.2.2.1、App_main.main()</h5><p>[-&gt; App_main.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Older kernels don't understand PR_SET_NO_NEW_PRIVS and return</span></span><br><span class="line">        <span class="comment">// EINVAL. Don't die on such kernels.</span></span><br><span class="line">        <span class="keyword">if</span> (errno != EINVAL) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"PR_SET_NO_NEW_PRIVS failed: %s"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传到的参数argv为“-Xzygote /system/bin --zygote --start-system-server”</span></span><br><span class="line">    AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv));</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0] //忽略第一个参数</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">0</span>] != <span class="string">'-'</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argv[i][<span class="number">1</span>] == <span class="string">'-'</span> &amp;&amp; argv[i][<span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            ++i; <span class="comment">// Skip --.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        runtime.addOption(strdup(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse runtime arguments.  Stop at first unrecognized option.</span></span><br><span class="line">    <span class="comment">//参数解析</span></span><br><span class="line">    <span class="keyword">bool</span> zygote = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> startSystemServer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> application = <span class="literal">false</span>;</span><br><span class="line">    String8 niceName;</span><br><span class="line">    String8 className;</span><br><span class="line"></span><br><span class="line">    ++i;  <span class="comment">// Skip unused "parent dir" argument.</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; argc) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* arg = argv[i++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--zygote"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            zygote = <span class="literal">true</span>;</span><br><span class="line">            niceName = ZYGOTE_NICE_NAME;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--start-system-server"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            startSystemServer = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(arg, <span class="string">"--application"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            application = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--nice-name="</span>, <span class="number">12</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            niceName.setTo(arg + <span class="number">12</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strncmp</span>(arg, <span class="string">"--"</span>, <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            className.setTo(arg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector&lt;String8&gt; args;</span><br><span class="line">    <span class="keyword">if</span> (!className.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// We're not in zygote mode, the only argument we need to pass</span></span><br><span class="line">        <span class="comment">// to RuntimeInit is the application argument.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The Remainder of args get passed to startup class main(). Make</span></span><br><span class="line">        <span class="comment">// copies of them before we overwrite them with the process name.</span></span><br><span class="line">        <span class="comment">// 运行application或tool程序</span></span><br><span class="line">        args.add(application ? String8(<span class="string">"application"</span>) : String8(<span class="string">"tool"</span>));</span><br><span class="line">        runtime.setClassNameAndArgs(className, argc - i, argv + i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We're in zygote mode.</span></span><br><span class="line">         <span class="comment">//进入zygote模式，创建 /data/dalvik-cache路径</span></span><br><span class="line">        maybeCreateDalvikCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (startSystemServer) &#123;</span><br><span class="line">            args.add(String8(<span class="string">"start-system-server"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> prop[PROP_VALUE_MAX];</span><br><span class="line">        <span class="keyword">if</span> (property_get(ABI_LIST_PROPERTY, prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOG_ALWAYS_FATAL(<span class="string">"app_process: Unable to determine ABI list from property %s."</span>,</span><br><span class="line">                ABI_LIST_PROPERTY);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">String8 <span class="title">abiFlag</span><span class="params">(<span class="string">"--abi-list="</span>)</span></span>;</span><br><span class="line">        abiFlag.append(prop);</span><br><span class="line">        args.add(abiFlag);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// In zygote mode, pass all remaining arguments to the zygote</span></span><br><span class="line">        <span class="comment">// main() method.</span></span><br><span class="line">        <span class="keyword">for</span> (; i &lt; argc; ++i) &#123;</span><br><span class="line">            args.add(String8(argv[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置进程名</span></span><br><span class="line">    <span class="keyword">if</span> (!niceName.isEmpty()) &#123;</span><br><span class="line">        runtime.setArgv0(niceName.<span class="built_in">string</span>());</span><br><span class="line">        set_process_name(niceName.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">       <span class="comment">// 启动AppRuntime</span></span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//没有指定类名或zygote，参数错误</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-2、AndroidRuntime-start"><a href="#4-2-2-2、AndroidRuntime-start" class="headerlink" title="4.2.2.2、AndroidRuntime.start()"></a>4.2.2.2、AndroidRuntime.start()</h4><p>[-&gt; AndroidRuntime.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AndroidRuntime::start(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line">ALOGD(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</span><br><span class="line">        className != <span class="literal">NULL</span> ? className : <span class="string">"(unknown)"</span>, getuid());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 'startSystemServer == true' means runtime is obsolete and not run from</span></span><br><span class="line"><span class="comment"> * init.rc anymore, so we print out the boot start event here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (options[i] == startSystemServer) &#123;</span><br><span class="line">       <span class="comment">/* track our progress through the boot sequence */</span></span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">int</span> LOG_BOOT_PROGRESS_START = <span class="number">3000</span>;</span><br><span class="line">       LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START,  ns2ms(systemTime(SYSTEM_TIME_MONOTONIC)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* rootDir = getenv(<span class="string">"ANDROID_ROOT"</span>);</span><br><span class="line"><span class="keyword">if</span> (rootDir == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    rootDir = <span class="string">"/system"</span>;</span><br><span class="line">    <span class="keyword">if</span> (!hasDir(<span class="string">"/system"</span>)) &#123;</span><br><span class="line">        LOG_FATAL(<span class="string">"No root directory specified, and /android does not exist."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setenv(<span class="string">"ANDROID_ROOT"</span>, rootDir, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const char* kernelHack = getenv("LD_ASSUME_KERNEL");</span></span><br><span class="line"><span class="comment">//ALOGD("Found LD_ASSUME_KERNEL='%s'\n", kernelHack);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* start the virtual machine */</span></span><br><span class="line">JniInvocation jni_invocation;</span><br><span class="line">jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">JNIEnv* env;</span><br><span class="line"><span class="comment">// 虚拟机创建</span></span><br><span class="line"><span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">onVmCreated(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Register android functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">// JNI方法注册</span></span><br><span class="line"><span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We want to call main() with a String array with arguments in it.</span></span><br><span class="line"><span class="comment"> * At present we have two arguments, the class name and an option string.</span></span><br><span class="line"><span class="comment"> * Create an array to hold them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">jclass stringClass;</span><br><span class="line">jobjectArray strArray;</span><br><span class="line">jstring classNameStr;</span><br><span class="line"><span class="comment">//等价 strArray= new String[options.size() + 1];</span></span><br><span class="line">stringClass = env-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">assert(stringClass != <span class="literal">NULL</span>);</span><br><span class="line">strArray = env-&gt;NewObjectArray(options.size() + <span class="number">1</span>, stringClass, <span class="literal">NULL</span>);</span><br><span class="line">assert(strArray != <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等价 strArray[0] = "com.android.internal.os.ZygoteInit"</span></span><br><span class="line">classNameStr = env-&gt;NewStringUTF(className);</span><br><span class="line">assert(classNameStr != <span class="literal">NULL</span>);</span><br><span class="line">env-&gt;SetObjectArrayElement(strArray, <span class="number">0</span>, classNameStr);</span><br><span class="line"><span class="comment">//等价 strArray[1] = "start-system-server"；</span></span><br><span class="line"><span class="comment">//    strArray[2] = "--abi-list=xxx"；</span></span><br><span class="line"><span class="comment">//其中xxx为系统响应的cpu架构类型，比如arm64-v8a.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; options.size(); ++i) &#123;</span><br><span class="line">    jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).<span class="built_in">string</span>());</span><br><span class="line">    assert(optionsStr != <span class="literal">NULL</span>);</span><br><span class="line">    env-&gt;SetObjectArrayElement(strArray, i + <span class="number">1</span>, optionsStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment"> * not return until the VM exits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//将"com.android.internal.os.ZygoteInit"转换为"com/android/internal/os/ZygoteInit"</span></span><br><span class="line"><span class="keyword">char</span>* slashClassName = toSlashClassName(className);</span><br><span class="line">jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line"><span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">    <span class="comment">/* keep going */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">        <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">    <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用ZygoteInit.main()方法</span></span><br><span class="line">        env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (env-&gt;ExceptionCheck())</span><br><span class="line">            threadExitUncaughtException(env);</span><br><span class="line">            <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(slashClassName);</span><br><span class="line"></span><br><span class="line">ALOGD(<span class="string">"Shutting down VM\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (mJavaVM-&gt;DetachCurrentThread() != JNI_OK)</span><br><span class="line">    ALOGW(<span class="string">"Warning: unable to detach main thread\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (mJavaVM-&gt;DestroyJavaVM() != <span class="number">0</span>)</span><br><span class="line">    ALOGW(<span class="string">"Warning: VM did not shut down cleanly\n"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-3、AndroidRuntime-startVm"><a href="#4-2-2-3、AndroidRuntime-startVm" class="headerlink" title="4.2.2.3、AndroidRuntime.startVm()"></a>4.2.2.3、AndroidRuntime.startVm()</h5><p>[–&gt; AndroidRuntime.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="keyword">bool</span> zygote)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// JNI检测功能，用于native层调用jni函数时进行常规检测，比较弱字符串格式是否符合要求，资源是否正确释放。该功能一般用于早期系统调试或手机Eng版，对于User版往往不会开启，引用该功能比较消耗系统CPU资源，降低系统性能。</span></span><br><span class="line">   <span class="keyword">bool</span> checkJni = <span class="literal">false</span>;</span><br><span class="line">property_get(<span class="string">"dalvik.vm.checkjni"</span>, propBuf, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">"true"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    checkJni = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(propBuf, <span class="string">"false"</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* property is neither true nor false; fall back on kernel parameter */</span></span><br><span class="line">    property_get(<span class="string">"ro.kernel.android.checkjni"</span>, propBuf, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (propBuf[<span class="number">0</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        checkJni = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ALOGD(<span class="string">"CheckJNI is %s\n"</span>, checkJni ? <span class="string">"ON"</span> : <span class="string">"OFF"</span>);</span><br><span class="line"><span class="keyword">if</span> (checkJni) &#123;</span><br><span class="line">    addOption(<span class="string">"-Xcheck:jni"</span>)</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"> <span class="comment">//虚拟机产生的trace文件，主要用于分析系统问题，路径默认为/data/anr/traces.txt</span></span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.stack-trace-file"</span>, stackTraceFileBuf, <span class="string">"-Xstacktracefile:"</span>);</span><br><span class="line"><span class="comment">//对于不同的软硬件环境，这些参数往往需要调整、优化，从而使系统达到最佳性能</span></span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.heapstartsize"</span>, heapstartsizeOptsBuf, <span class="string">"-Xms"</span>, <span class="string">"4m"</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.heapsize"</span>, heapsizeOptsBuf, <span class="string">"-Xmx"</span>, <span class="string">"16m"</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.heapgrowthlimit"</span>, heapgrowthlimitOptsBuf, <span class="string">"-XX:HeapGrowthLimit="</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.heapminfree"</span>, heapminfreeOptsBuf, <span class="string">"-XX:HeapMinFree="</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.heapmaxfree"</span>, heapmaxfreeOptsBuf, <span class="string">"-XX:HeapMaxFree="</span>);</span><br><span class="line">parseRuntimeOption(<span class="string">"dalvik.vm.heaptargetutilization"</span>,</span><br><span class="line">                   heaptargetutilizationOptsBuf, <span class="string">"-XX:HeapTargetUtilization="</span>);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//preloaded-classes文件内容是由WritePreloadedClassFile.java生成的，</span></span><br><span class="line"><span class="comment">//在ZygoteInit类中会预加载工作将其中的classes提前加载到内存，以提高系统性能</span></span><br><span class="line"><span class="keyword">if</span> (!hasFile(<span class="string">"/system/etc/preloaded-classes"</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化虚拟机</span></span><br><span class="line"><span class="keyword">if</span> (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"JNI_CreateJavaVM failed\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建Java虚拟机方法的主要篇幅是关于虚拟机参数的设置，下面只列举部分在调试优化过程中常用参数。</p><h4 id="4-2-2-4、AndroidRuntime-startReg"><a href="#4-2-2-4、AndroidRuntime-startReg" class="headerlink" title="4.2.2.4、AndroidRuntime.startReg()"></a>4.2.2.4、AndroidRuntime.startReg()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> AndroidRuntime::startReg(JNIEnv* env)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置线程创建方法为javaCreateThreadEtc</span></span><br><span class="line">    androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc);</span><br><span class="line"></span><br><span class="line">    env-&gt;PushLocalFrame(<span class="number">200</span>);</span><br><span class="line">    <span class="comment">//进程NI方法的注册</span></span><br><span class="line">    <span class="keyword">if</span> (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    env-&gt;PopLocalFrame(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-4-1、Threads-androidSetCreateThreadFunc"><a href="#4-2-2-4-1、Threads-androidSetCreateThreadFunc" class="headerlink" title="4.2.2.4.1、Threads.androidSetCreateThreadFunc()"></a>4.2.2.4.1、Threads.androidSetCreateThreadFunc()</h4><p>[-&gt; Threads.cpp]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">androidSetCreateThreadFunc</span><span class="params">(android_create_thread_fn func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gCreateThreadFn = func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机启动后startReg()过程，会设置线程创建函数指针gCreateThreadFn指向javaCreateThreadEtc.</p><h4 id="4-2-2-4-2、register-jni-procs"><a href="#4-2-2-4-2、register-jni-procs" class="headerlink" title="4.2.2.4.2、register_jni_procs()"></a>4.2.2.4.2、register_jni_procs()</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">register_jni_procs</span><span class="params">(<span class="keyword">const</span> RegJNIRec <span class="built_in">array</span>[], <span class="keyword">size_t</span> count, JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i].mProc(env) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-4-3、gRegJNI-mProc"><a href="#4-2-2-4-3、gRegJNI-mProc" class="headerlink" title="4.2.2.4.3、gRegJNI.mProc"></a>4.2.2.4.3、gRegJNI.mProc</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> RegJNIRec gRegJNI[] = &#123;</span><br><span class="line">    REG_JNI(register_com_android_internal_os_RuntimeInit),</span><br><span class="line">    REG_JNI(register_android_os_Binder)，</span><br><span class="line">    ...</span><br><span class="line">&#125;；*</span><br></pre></td></tr></table></figure><p>array[i]是指gRegJNI数组, 该数组有100多个成员。其中每一项成员都是通过REG_JNI宏定义的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REG_JNI(name)      &#123; name &#125;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RegJNIRec</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> (*mProc)(JNIEnv*);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可见，调用mProc，就等价于调用其参数名所指向的函数。 例如REG_JNI(register_com_android_internal_os_RuntimeInit).mProc也就是指进入register_com_android_internal_os_RuntimeInit方法，接下来就继续以此为例来说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_com_android_internal_os_RuntimeInit</span><span class="params">(JNIEnv* env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jniRegisterNativeMethods(env, <span class="string">"com/android/internal/os/RuntimeInit"</span>,</span><br><span class="line">        gMethods, NELEM(gMethods));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//gMethods：java层方法名与jni层的方法的一一映射关系</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JNINativeMethod gMethods[] = &#123;</span><br><span class="line">    &#123; <span class="string">"nativeFinishInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeZygoteInit"</span>, <span class="string">"()V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeSetExitWithoutCleanup"</span>, <span class="string">"(Z)V"</span>,</span><br><span class="line">        (<span class="keyword">void</span>*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N08-android-system-start-ZygoteInit.main.png" alt="Markdown"></p><h4 id="4-2-2-5、进入Java层"><a href="#4-2-2-5、进入Java层" class="headerlink" title="4.2.2.5、进入Java层"></a>4.2.2.5、进入Java层</h4><p>AndroidRuntime.start()执行到最后通过反射调用到ZygoteInit.main(),见下文:</p><h5 id="4-2-2-5-1、ZygoteInit-main"><a href="#4-2-2-5-1、ZygoteInit-main" class="headerlink" title="4.2.2.5.1、ZygoteInit.main()"></a>4.2.2.5.1、ZygoteInit.main()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;Init<span class="string">");</span></span><br><span class="line"><span class="string">    //开启DDMS功能</span></span><br><span class="line"><span class="string">    RuntimeInit.enableDdms();</span></span><br><span class="line"><span class="string">    SamplingProfilerIntegration.start();</span></span><br><span class="line"><span class="string">    boolean startSystemServer = false;</span></span><br><span class="line"><span class="string">    String socketName = "</span>zygote<span class="string">";</span></span><br><span class="line"><span class="string">    String abiList = null;</span></span><br><span class="line"><span class="string">    for (int i = 1; i &lt; argv.length; i++) &#123;</span></span><br><span class="line"><span class="string">        if ("</span>start-system-server<span class="string">".equals(argv[i])) &#123;</span></span><br><span class="line"><span class="string">            startSystemServer = true;</span></span><br><span class="line"><span class="string">        &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123;</span></span><br><span class="line"><span class="string">            abiList = argv[i].substring(ABI_LIST_ARG.length());</span></span><br><span class="line"><span class="string">        &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123;</span></span><br><span class="line"><span class="string">            socketName = argv[i].substring(SOCKET_NAME_ARG.length());</span></span><br><span class="line"><span class="string">        &#125; else &#123;</span></span><br><span class="line"><span class="string">            throw new RuntimeException("</span>Unknown command line argument: <span class="string">" + argv[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    //为Zygote注册socket</span></span><br><span class="line"><span class="string">    registerZygoteSocket(socketName);</span></span><br><span class="line"><span class="string">    preload();// 预加载类和资源</span></span><br><span class="line"><span class="string">    SamplingProfilerIntegration.writeZygoteSnapshot();</span></span><br><span class="line"><span class="string">    gcAndFinalize();//GC操作</span></span><br><span class="line"><span class="string">    Zygote.nativeUnmountStorageOnInit();</span></span><br><span class="line"><span class="string">    ZygoteHooks.stopZygoteNoThreadCreation();</span></span><br><span class="line"><span class="string">    if (startSystemServer) &#123;//启动system_server</span></span><br><span class="line"><span class="string">        startSystemServer(abiList, socketName);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    runSelectLoop(abiList);//进入循环模式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    closeServerSocket();</span></span><br><span class="line"><span class="string">&#125; catch (MethodAndArgsCaller caller) &#123;</span></span><br><span class="line"><span class="string">    caller.run();</span></span><br><span class="line"><span class="string">&#125; catch (Throwable ex) &#123;</span></span><br><span class="line"><span class="string">    closeServerSocket();</span></span><br><span class="line"><span class="string">    throw ex;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在异常捕获后调用的方法caller.run()，会在后续的system_server文章会讲到。</p><h5 id="4-2-2-5-2、ZygoteInit-registerZygoteSocket"><a href="#4-2-2-5-2、ZygoteInit-registerZygoteSocket" class="headerlink" title="4.2.2.5.2、ZygoteInit.registerZygoteSocket()"></a>4.2.2.5.2、ZygoteInit.registerZygoteSocket()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerZygoteSocket</span><span class="params">(String socketName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sServerSocket == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> fileDesc;</span><br><span class="line">    <span class="keyword">final</span> String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String env = System.getenv(fullSocketName);</span><br><span class="line">        fileDesc = Integer.parseInt(env);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileDescriptor fd = <span class="keyword">new</span> FileDescriptor();</span><br><span class="line">        fd.setInt$(fileDesc); <span class="comment">//设置文件描述符</span></span><br><span class="line">        sServerSocket = <span class="keyword">new</span> LocalServerSocket(fd); <span class="comment">//创建Socket的本地服务端</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-5-2、ZygoteInit-preload"><a href="#4-2-2-5-2、ZygoteInit-preload" class="headerlink" title="4.2.2.5.2、ZygoteInit.preload()"></a>4.2.2.5.2、ZygoteInit.preload()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//预加载位于/system/etc/preloaded-classes文件中的类</span></span><br><span class="line">    preloadClasses();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载资源，包含drawable和color资源</span></span><br><span class="line">    preloadResources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载OpenGL</span></span><br><span class="line">    preloadOpenGL();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过System.loadLibrary()方法，</span></span><br><span class="line">    <span class="comment">//预加载"android","compiler_rt","jnigraphics"这3个共享库</span></span><br><span class="line">    preloadSharedLibraries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预加载  文本连接符资源</span></span><br><span class="line">    preloadTextResources();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅用于zygote进程，用于内存共享的进程</span></span><br><span class="line">    WebViewFactory.prepareWebViewInZygote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行Zygote进程的初始化,对于类加载，采用反射机制Class.forName()方法来加载。对于资源加载，主要是 com.android.internal.R.array.preloaded_drawables和com.android.internal.R.array.preloaded_color_state_lists，在应用程序中以com.android.internal.R.xxx开头的资源，便是此时由Zygote加载到内存的。</p><p>zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N09-android-system-start-zygote_fork.jpg" alt="Markdown"></p><h5 id="4-2-2-5-3、ZygoteInit-startSystemServer"><a href="#4-2-2-5-3、ZygoteInit-startSystemServer" class="headerlink" title="4.2.2.5.3、ZygoteInit.startSystemServer()"></a>4.2.2.5.3、ZygoteInit.startSystemServer()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> capabilities = posixCapabilitiesAsBits(</span><br><span class="line">        OsConstants.CAP_BLOCK_SUSPEND,</span><br><span class="line">        OsConstants.CAP_KILL,</span><br><span class="line">        OsConstants.CAP_NET_ADMIN,</span><br><span class="line">        OsConstants.CAP_NET_BIND_SERVICE,</span><br><span class="line">        OsConstants.CAP_NET_BROADCAST,</span><br><span class="line">        OsConstants.CAP_NET_RAW,</span><br><span class="line">        OsConstants.CAP_SYS_MODULE,</span><br><span class="line">        OsConstants.CAP_SYS_NICE,</span><br><span class="line">        OsConstants.CAP_SYS_RESOURCE,</span><br><span class="line">        OsConstants.CAP_SYS_TIME,</span><br><span class="line">        OsConstants.CAP_SYS_TTY_CONFIG</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//参数准备</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//用于解析参数，生成目标格式</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fork子进程，用于运行system_server</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入子进程system_server</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成system_server进程剩余的工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。</p><h5 id="4-2-2-5-4、ZygoteInit-runSelectLoop"><a href="#4-2-2-5-4、ZygoteInit-runSelectLoop" class="headerlink" title="4.2.2.5.4、ZygoteInit.runSelectLoop()"></a>4.2.2.5.4、ZygoteInit.runSelectLoop()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line">    <span class="comment">//sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]</span></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">//处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里</span></span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">//采用I/O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；</span></span><br><span class="line">            <span class="comment">// 否则进入continue，跳出本次循环。</span></span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求；</span></span><br><span class="line">                <span class="comment">// 则创建ZygoteConnection对象,并添加到fds。</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor()); <span class="comment">//添加到fds.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i); <span class="comment">//处理完则从fds中移除该文件描述符</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求。</p><h5 id="4-2-2-5-4、ZygoteConnection-runOnce"><a href="#4-2-2-5-4、ZygoteConnection-runOnce" class="headerlink" title="4.2.2.5.4、ZygoteConnection.runOnce()"></a>4.2.2.5.4、ZygoteConnection.runOnce()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">String args[];</span><br><span class="line">Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//读取socket客户端发送过来的参数列表</span></span><br><span class="line">    args = readArgumentList();</span><br><span class="line">    descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//将binder客户端传递过来的参数，解析成Arguments对象格式</span></span><br><span class="line">    parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line">    ...</span><br><span class="line">    pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">            parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">            parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">            parsedArgs.appDataDir);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//子进程执行</span></span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">        serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//进入子进程流程</span></span><br><span class="line">        handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//父进程执行</span></span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">    IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-2-2-6、总结"><a href="#4-2-2-6、总结" class="headerlink" title="4.2.2.6、总结"></a>4.2.2.6、总结</h5><p>Zygote启动过程的调用流程图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N10-android-system-start-zygote_start.jpg" alt="Markdown"></p><blockquote><p>1、解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法；<br>2、 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数；<br>3、通过JNI方式调用ZygoteInit.main()，第一次进入Java世界；<br>4、registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求；<br>5、preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率；<br>6、zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。<br>7、 zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N11-android-system-start-System_Server.png" alt="Markdown"></p></blockquote><h3 id="（3）、启动SystemServer上篇"><a href="#（3）、启动SystemServer上篇" class="headerlink" title="（3）、启动SystemServer上篇"></a>（3）、启动SystemServer上篇</h3><h4 id="4-3-1、启动流程"><a href="#4-3-1、启动流程" class="headerlink" title="4.3.1、启动流程"></a>4.3.1、启动流程</h4><p>SystemServer的在Android体系中所处的地位，SystemServer由Zygote fork生成的，进程名为system_server，该进程承载着framework的核心服务。 Android系统启动-zygote篇中讲到Zygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， 启动流程图如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N12-android-system-start-system_server_.jpg" alt="Markdown"></p><h4 id="4-3-2、ZygoteInit-startSystemServer"><a href="#4-3-2、ZygoteInit-startSystemServer" class="headerlink" title="4.3.2、ZygoteInit.startSystemServer()"></a>4.3.2、ZygoteInit.startSystemServer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">startSystemServer</span><span class="params">(String abiList, String socketName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> MethodAndArgsCaller, RuntimeException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//参数准备</span></span><br><span class="line">    String args[] = &#123;</span><br><span class="line">        <span class="string">"--setuid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgid=1000"</span>,</span><br><span class="line">        <span class="string">"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007"</span>,</span><br><span class="line">        <span class="string">"--capabilities="</span> + capabilities + <span class="string">","</span> + capabilities,</span><br><span class="line">        <span class="string">"--nice-name=system_server"</span>,</span><br><span class="line">        <span class="string">"--runtime-args"</span>,</span><br><span class="line">        <span class="string">"com.android.server.SystemServer"</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ZygoteConnection.Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//用于解析参数，生成目标格式</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> ZygoteConnection.Arguments(args);</span><br><span class="line">        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fork子进程，该进程是system_server进程</span></span><br><span class="line">        pid = Zygote.forkSystemServer(</span><br><span class="line">                parsedArgs.uid, parsedArgs.gid,</span><br><span class="line">                parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags,</span><br><span class="line">                <span class="keyword">null</span>,</span><br><span class="line">                parsedArgs.permittedCapabilities,</span><br><span class="line">                parsedArgs.effectiveCapabilities);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入子进程system_server</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasSecondZygote(abiList)) &#123;</span><br><span class="line">            waitForSecondaryZygote(socketName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完成system_server进程剩余的工作</span></span><br><span class="line">        handleSystemServerProcess(parsedArgs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>准备参数并fork新进程，从上面可以看出system server进程参数信息为uid=1000,gid=1000,进程名为sytem_server，从zygote进程fork新进程后，需要关闭zygote原有的socket。另外，对于有两个zygote进程情况，需等待第2个zygote创建完成。</p><h4 id="4-3-3、Zygote-forkSystemServer"><a href="#4-3-3、Zygote-forkSystemServer" class="headerlink" title="4.3.3、Zygote. forkSystemServer()"></a>4.3.3、Zygote. forkSystemServer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkSystemServer</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] rlimits, <span class="keyword">long</span> permittedCapabilities, <span class="keyword">long</span> effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    <span class="comment">// 调用native方法fork system_server进程</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkSystemServer(</span><br><span class="line">            uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nativeForkSystemServer()方法在AndroidRuntime.cpp中注册的，调用com_android_internal_os_Zygote.cpp中的register_com_android_internal_os_Zygote()方法建立native方法的映射关系，所以接下来进入如下方法。</p><h4 id="4-3-4、com-android-internal-os-Zygote-nativeForkSystemServer"><a href="#4-3-4、com-android-internal-os-Zygote-nativeForkSystemServer" class="headerlink" title="4.3.4、com_android_internal_os_Zygote.nativeForkSystemServer()"></a>4.3.4、com_android_internal_os_Zygote.nativeForkSystemServer()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkSystemServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong effectiveCapabilities)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//fork子进程，</span></span><br><span class="line">  pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,</span><br><span class="line">                                      debug_flags, rlimits,</span><br><span class="line">                                      permittedCapabilities, effectiveCapabilities,</span><br><span class="line">                                      MOUNT_EXTERNAL_DEFAULT, NULL, NULL, <span class="keyword">true</span>, NULL,</span><br><span class="line">                                      NULL, NULL);</span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// zygote进程，检测system_server进程是否创建</span></span><br><span class="line">      gSystemServerPid = pid;</span><br><span class="line">      <span class="keyword">int</span> status;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(pid, &amp;status, WNOHANG) == pid) &#123;</span><br><span class="line">          <span class="comment">//当system_server进程死亡后，重启zygote进程</span></span><br><span class="line">          RuntimeAbort(env);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当system_server进程创建失败时，将会重启zygote进程。这里需要注意，对于Android 5.0以上系统，有两个zygote进程，分别是zygote、zygote64两个进程，system_server的父进程，一般来说64位系统其父进程是zygote64进程</p><p>当kill system_server进程后，只重启zygote64和system_server，不重启zygote; 当kill zygote64进程后，只重启zygote64和system_server，也不重启zygote； 当kill zygote进程，则重启zygote、zygote64以及system_server。</p><h4 id="4-3-5、com-android-internal-os-Zygote-ForkAndSpecializeCommon"><a href="#4-3-5、com-android-internal-os-Zygote-ForkAndSpecializeCommon" class="headerlink" title="4.3.5、com_android_internal_os_Zygote.ForkAndSpecializeCommon()"></a>4.3.5、com_android_internal_os_Zygote.ForkAndSpecializeCommon()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint debug_flags, jobjectArray javaRlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     bool is_system_server, jintArray fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  SetSigChldHandler(); <span class="comment">//设置子进程的signal信号处理函数</span></span><br><span class="line">  pid_t pid = fork(); <span class="comment">//fork子进程</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入子进程</span></span><br><span class="line">    DetachDescriptors(env, fdsToClose); <span class="comment">//关闭并清除文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">        <span class="comment">//对于非system_server子进程，则创建进程组</span></span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    SetGids(env, javaGids); <span class="comment">//设置设置group</span></span><br><span class="line">    SetRLimits(env, javaRlimits); <span class="comment">//设置资源limit</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line"></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    SetSchedulerPolicy(env); <span class="comment">//设置调度策略</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//selinux上下文</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str); <span class="comment">//设置线程名为system_server，方便调试</span></span><br><span class="line">    &#125;</span><br><span class="line">    UnsetSigChldHandler(); <span class="comment">//设置子进程的signal信号处理函数为默认函数</span></span><br><span class="line">    <span class="comment">//等价于调用zygote.callPostForkChildHooks()</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server ? NULL : instructionSet);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//进入父进程，即zygote进程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fork()创建新进程，采用copy on write方式，这是linux创建进程的标准方法，会有两次return,对于pid==0为子进程的返回，对于pid&gt;0为父进程的返回。 到此system_server进程已完成了创建的所有工作，接下来开始了system_server进程的真正工作。在前面startSystemServer()方法中，zygote进程执行完forkSystemServer()后，新创建出来的system_server进程便进入handleSystemServerProcess()方法。</p><h4 id="4-3-5、ZygoteInit-handleSystemServerProcess"><a href="#4-3-5、ZygoteInit-handleSystemServerProcess" class="headerlink" title="4.3.5、ZygoteInit.handleSystemServerProcess()"></a>4.3.5、ZygoteInit.handleSystemServerProcess()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleSystemServerProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteConnection.Arguments parsedArgs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    closeServerSocket(); <span class="comment">//关闭父进程zygote复制而来的Socket</span></span><br><span class="line"></span><br><span class="line">    Os.umask(S_IRWXG | S_IRWXO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Process.setArgV0(parsedArgs.niceName); <span class="comment">//设置当前进程名为"system_server"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String systemServerClasspath = Os.getenv(<span class="string">"SYSTEMSERVERCLASSPATH"</span>);</span><br><span class="line">    <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//执行dex优化操作</span></span><br><span class="line">        performSystemServerDexOpt(systemServerClasspath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] args = parsedArgs.remainingArgs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String[] amendedArgs = <span class="keyword">new</span> String[args.length + <span class="number">2</span>];</span><br><span class="line">            amendedArgs[<span class="number">0</span>] = <span class="string">"-cp"</span>;</span><br><span class="line">            amendedArgs[<span class="number">1</span>] = systemServerClasspath;</span><br><span class="line">            System.arraycopy(parsedArgs.remainingArgs, <span class="number">0</span>, amendedArgs, <span class="number">2</span>, parsedArgs.remainingArgs.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//启动应用进程</span></span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(), <span class="keyword">null</span>, args);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ClassLoader cl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (systemServerClasspath != <span class="keyword">null</span>) &#123;</span><br><span class="line">            创建类加载器，并赋予当前线程</span><br><span class="line">            cl = <span class="keyword">new</span> PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader());</span><br><span class="line">            Thread.currentThread().setContextClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//system_server故进入此分支</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* should never reach here */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处systemServerClasspath环境变量主要有/system/framework/目录下的services.jar，ethernet-service.jar, wifi-service.jar这3个文件</p><h4 id="4-3-6、ZygoteInit-performSystemServerDexOpt"><a href="#4-3-6、ZygoteInit-performSystemServerDexOpt" class="headerlink" title="4.3.6、ZygoteInit.performSystemServerDexOpt()"></a>4.3.6、ZygoteInit.performSystemServerDexOpt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performSystemServerDexOpt</span><span class="params">(String classPath)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String[] classPathElements = classPath.split(<span class="string">":"</span>);</span><br><span class="line">    <span class="comment">//创建一个与installd的建立socket连接</span></span><br><span class="line">    <span class="keyword">final</span> InstallerConnection installer = <span class="keyword">new</span> InstallerConnection();</span><br><span class="line">    <span class="comment">//执行ping操作，直到与installd服务端连通为止</span></span><br><span class="line">    installer.waitForConnection();</span><br><span class="line">    <span class="keyword">final</span> String instructionSet = VMRuntime.getRuntime().vmInstructionSet();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String classPathElement : classPathElements) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> dexoptNeeded = DexFile.getDexOptNeeded(</span><br><span class="line">                    classPathElement, <span class="string">"*"</span>, instructionSet, <span class="keyword">false</span> <span class="comment">/* defer */</span>);</span><br><span class="line">            <span class="keyword">if</span> (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123;</span><br><span class="line">                <span class="comment">//以system权限，执行dex文件优化</span></span><br><span class="line">                installer.dexopt(classPathElement, Process.SYSTEM_UID, <span class="keyword">false</span>,</span><br><span class="line">                        instructionSet, dexoptNeeded);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Error starting system_server"</span>, ioe);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        installer.disconnect(); <span class="comment">//断开与installd的socket连接</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将classPath字符串中的apk，分别进行dex优化操作。真正执行优化工作通过socket通信将相应的命令参数，发送给installd来完成。</p><h4 id="4-3-7、RuntimeInit-zygoteInit"><a href="#4-3-7、RuntimeInit-zygoteInit" class="headerlink" title="4.3.7、RuntimeInit.zygoteInit()"></a>4.3.7、RuntimeInit.zygoteInit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams(); <span class="comment">//重定向log输出</span></span><br><span class="line"></span><br><span class="line">    commonInit(); <span class="comment">// 通用的一些初始化</span></span><br><span class="line">    nativeZygoteInit(); <span class="comment">// zygote初始化</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader); <span class="comment">// 应用初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-8、RuntimeInit-commonInit"><a href="#4-3-8、RuntimeInit-commonInit" class="headerlink" title="4.3.8、RuntimeInit.commonInit()"></a>4.3.8、RuntimeInit.commonInit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置默认的未捕捉异常处理方法</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置市区，中国时区为"Asia/Shanghai"</span></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置log配置</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置默认的HTTP User-agent格式,用于 HttpURLConnection。</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket的tag，用于网络流量统计</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的HTTP User-agent格式，例如：</p><p>“Dalvik/1.1.0 (Linux; U; Android 6.0.1；LenovoX3c70 Build/LMY47V)”.</p><h4 id="4-3-9、AndroidRuntime-nativeZygoteInit"><a href="#4-3-9、AndroidRuntime-nativeZygoteInit" class="headerlink" title="4.3.9、AndroidRuntime.nativeZygoteInit()"></a>4.3.9、AndroidRuntime.nativeZygoteInit()</h4><p>nativeZygoteInit()方法在AndroidRuntime.cpp中，进行了jni映射，对应下面的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//此处的gCurRuntime为AppRuntime，是在AndroidRuntime.cpp中定义的</span></span><br><span class="line">    gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[–&gt;app_main.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    proc-&gt;startThreadPool(); <span class="comment">//启动新binder线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProcessState::self()是单例模式，主要工作是调用open()打开/dev/binder驱动设备，再利用mmap()映射内核的地址空间，将Binder驱动的fd赋值ProcessState对象中的变量mDriverFD，用于交互操作。startThreadPool()是创建一个新的binder线程，不断进行talkWithDriver()，在binder系列文章中的<a href="http://gityuan.com/2015/11/14/binder-add-service/" target="_blank" rel="noopener">注册服务(addService)</a>详细这两个方法的执行原理。</p><h4 id="4-3-10、RuntimeInit-applicationInit"><a href="#4-3-10、RuntimeInit-applicationInit" class="headerlink" title="4.3.10、RuntimeInit.applicationInit()"></a>4.3.10、RuntimeInit.applicationInit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">//true代表应用程序退出时不调用AppRuntime.onExit()，否则会在退出前调用</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置虚拟机的内存利用率参数值为0.75</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv); <span class="comment">//解析参数</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用startClass的static方法 main()</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在startSystemServer()方法中通过硬编码初始化参数，可知此处args.startClass为”com.android.server.SystemServer”。</p><h4 id="4-3-11、RuntimeInit-invokeStaticMain"><a href="#4-3-11、RuntimeInit-invokeStaticMain" class="headerlink" title="4.3.11、RuntimeInit.invokeStaticMain()"></a>4.3.11、RuntimeInit.invokeStaticMain()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过抛出异常，回到ZygoteInit.main()。这样做好处是能清空栈帧，提高栈帧利用率。</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-12、MethodAndArgsCaller-run"><a href="#4-3-12、MethodAndArgsCaller-run" class="headerlink" title="4.3.12、MethodAndArgsCaller.run()"></a>4.3.12、MethodAndArgsCaller.run()</h4><p>在Zygote中遗留了一个问题没有讲解，如下：</p><p>[–&gt;ZygoteInit.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startSystemServer(abiList, socketName);<span class="comment">//启动system_server</span></span><br><span class="line">        ....</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在已经很明显了，是invokeStaticMain()方法中抛出的异常MethodAndArgsCaller，从而进入caller.run()方法。</p><p>[–&gt;ZygoteInit.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据传递过来的参数，可知此处通过反射机制调用的是SystemServer.main()方法</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，总算是进入到了SystemServer类的main()方法， 在文章Android系统启动-SystemServer下篇中会紧接着这里开始讲述。</p><h3 id="（4）、启动SystemServer下篇"><a href="#（4）、启动SystemServer下篇" class="headerlink" title="（4）、启动SystemServer下篇"></a>（4）、启动SystemServer下篇</h3><p>上篇文章Android系统启动-systemServer上篇 从Zygote一路启动到SystemServer的过程。 简单回顾下，在RuntimeInit.java中invokeStaticMain方法通过创建并抛出异常ZygoteInit.MethodAndArgsCaller，在ZygoteInit.java中的main()方法会捕捉该异常，并调用caller.run()，再通过反射便会调用到SystemServer.main()方法，该方法主要执行流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SystemServer.main</span><br><span class="line">    SystemServer.run</span><br><span class="line">        createSystemContext</span><br><span class="line">        startBootstrapServices();</span><br><span class="line">        startCoreServices();</span><br><span class="line">        startOtherServices();</span><br><span class="line">        Looper.loop();</span><br></pre></td></tr></table></figure><p>接下来，从其main方法说起。</p><h4 id="4-4-1、SystemServer-main"><a href="#4-4-1、SystemServer-main" class="headerlink" title="4.4.1、SystemServer.main()"></a>4.4.1、SystemServer.main()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先初始化SystemServer对象，再调用对象的run()方法</span></span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-2、SystemServer-run"><a href="#4-4-2、SystemServer-run" class="headerlink" title="4.4.2、SystemServer.run()"></a>4.4.2、SystemServer.run()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当系统时间比1970年更早，就设置当前系统时间为1970年</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123;</span><br><span class="line">        SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//变更虚拟机的库文件，对于Android 6.0默认采用的是libart.so</span></span><br><span class="line">    SystemProperties.set(<span class="string">"persist.sys.dalvik.vm.lib.2"</span>, VMRuntime.getRuntime().vmLibrary());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SamplingProfilerIntegration.isEnabled()) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除vm内存增长上限，由于启动过程需要较多的虚拟机内存空间</span></span><br><span class="line">    VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置内存的可能有效使用率为0.8</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.8f</span>);</span><br><span class="line">    <span class="comment">// 针对部分设备依赖于运行时就产生指纹信息，因此需要在开机完成前已经定义</span></span><br><span class="line">    Build.ensureFingerprintProperty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问环境变量前，需要明确地指定用户</span></span><br><span class="line">    Environment.setUserRequired(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//确保当前系统进程的binder调用，总是运行在前台优先级(foreground priority)</span></span><br><span class="line">    BinderInternal.disableBackgroundScheduling(<span class="keyword">true</span>);</span><br><span class="line">    android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND);</span><br><span class="line">    android.os.Process.setCanSelfBackground(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程looper就在当前线程运行</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载android_servers.so库，该库包含的源码在frameworks/base/services/目录下</span></span><br><span class="line">    System.loadLibrary(<span class="string">"android_servers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测上次关机过程是否失败，该方法可能不会返回</span></span><br><span class="line">    performPendingShutdown();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化系统上下文</span></span><br><span class="line">    createSystemContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建系统服务管理</span></span><br><span class="line">    mSystemServiceManager = <span class="keyword">new</span> SystemServiceManager(mSystemContext);</span><br><span class="line">    <span class="comment">//将mSystemServiceManager添加到本地服务的成员sLocalServiceObjects</span></span><br><span class="line">    LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动各种系统服务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices(); <span class="comment">// 启动引导服务</span></span><br><span class="line">        startCoreServices();      <span class="comment">// 启动核心服务</span></span><br><span class="line">        startOtherServices();     <span class="comment">// 启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于debug版本，将log事件不断循环地输出到dropbox（用于分析）</span></span><br><span class="line">    <span class="keyword">if</span> (StrictMode.conditionallyEnableDebugLogging()) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Enabled StrictMode for system server main thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一直循环执行</span></span><br><span class="line">    Looper.loop();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LocalServices通过用静态Map变量sLocalServiceObjects，来保存以服务类名为key，以具体服务对象为value的Map结构。</p><h4 id="4-4-3、SystemServer-performPendingShutdown"><a href="#4-4-3、SystemServer-performPendingShutdown" class="headerlink" title="4.4.3、SystemServer.performPendingShutdown()"></a>4.4.3、SystemServer.performPendingShutdown()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPendingShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String shutdownAction = SystemProperties.get(</span><br><span class="line">            ShutdownThread.SHUTDOWN_ACTION_PROPERTY, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">if</span> (shutdownAction != <span class="keyword">null</span> &amp;&amp; shutdownAction.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> reboot = (shutdownAction.charAt(<span class="number">0</span>) == <span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String reason;</span><br><span class="line">        <span class="keyword">if</span> (shutdownAction.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            reason = shutdownAction.substring(<span class="number">1</span>, shutdownAction.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reason = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当"sys.shutdown.requested"值不为空,则会重启或者关机</span></span><br><span class="line">        ShutdownThread.rebootOrShutdown(<span class="keyword">null</span>, reboot, reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-4、SystemServer-createSystemContext"><a href="#4-4-4、SystemServer-createSystemContext" class="headerlink" title="4.4.4、SystemServer.createSystemContext()"></a>4.4.4、SystemServer.createSystemContext()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createSystemContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建system_server进程的上下文信息</span></span><br><span class="line">    ActivityThread activityThread = ActivityThread.systemMain();</span><br><span class="line">    mSystemContext = activityThread.getSystemContext();</span><br><span class="line">    <span class="comment">//设置主题</span></span><br><span class="line">    mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://gityuan.com/2017/04/02/android-application/" target="_blank" rel="noopener">理解Application创建过程</a>已介绍过createSystemContext()过程， 该过程会创建对象有ActivityThread，Instrumentation, ContextImpl，LoadedApk，Application。</p><h4 id="4-4-5、SystemServer-startBootstrapServices"><a href="#4-4-5、SystemServer-startBootstrapServices" class="headerlink" title="4.4.5、SystemServer.startBootstrapServices()"></a>4.4.5、SystemServer.startBootstrapServices()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞等待与installd建立socket通道</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务ActivityManagerService</span></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务PowerManagerService</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化power management</span></span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务LightsService</span></span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务DisplayManagerService</span></span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Phase100: 在初始化package manager之前，需要默认的显示.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当设备正在加密时，仅运行核心</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务PackageManagerService</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    mPackageManager = mSystemContext.getPackageManager();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动服务UserManagerService，新建目录/data/user/</span></span><br><span class="line">    ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance());</span><br><span class="line"></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置AMS</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动传感器服务</span></span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法所创建的服务：ActivityManagerService, PowerManagerService, LightsService, DisplayManagerService， PackageManagerService， UserManagerService， sensor服务.</p><h4 id="4-4-5、SystemServer-startCoreServices"><a href="#4-4-5、SystemServer-startCoreServices" class="headerlink" title="4.4.5、SystemServer.startCoreServices()"></a>4.4.5、SystemServer.startCoreServices()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void startCoreServices() &#123;</span><br><span class="line">    //启动服务BatteryService，用于统计电池电量，需要LightService.</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    //启动服务UsageStatsService，用于统计应用使用情况</span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    mPackageManagerService.getUsageStatsIfNoPackageUsageInfo();</span><br><span class="line"></span><br><span class="line">    //启动服务WebViewUpdateService</span><br><span class="line">    mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动服务BatteryService，UsageStatsService，WebViewUpdateService。</p><h4 id="4-4-6-SystemServer-startOtherServices"><a href="#4-4-6-SystemServer-startOtherServices" class="headerlink" title="4.4.6 SystemServer.startOtherServices()"></a>4.4.6 SystemServer.startOtherServices()</h4><p>该方法比较长，有近千行代码，逻辑很简单，主要是启动一系列的服务，这里就不具体列举源码了，在第四节直接对其中的服务进行一个简单分类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">       SystemConfig.getInstance();</span><br><span class="line">       mContentResolver = context.getContentResolver(); <span class="comment">// resolver</span></span><br><span class="line">       ...</span><br><span class="line">       mActivityManagerService.installSystemProviders(); <span class="comment">//provider</span></span><br><span class="line">       mSystemServiceManager.startService(AlarmManagerService.class); <span class="comment">// alarm</span></span><br><span class="line">       <span class="comment">// watchdog</span></span><br><span class="line">       watchdog.init(context, mActivityManagerService);</span><br><span class="line">       inputManager = <span class="keyword">new</span> InputManagerService(context); <span class="comment">// input</span></span><br><span class="line">       wm = WindowManagerService.main(...); <span class="comment">// window</span></span><br><span class="line">       inputManager.start();  <span class="comment">//启动input</span></span><br><span class="line">       mDisplayManagerService.windowManagerAndInputReady();</span><br><span class="line">       ...</span><br><span class="line">       mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); <span class="comment">// mount</span></span><br><span class="line">       mPackageManagerService.performBootDexOpt();  <span class="comment">// dexopt操作</span></span><br><span class="line">       ActivityManagerNative.getDefault().showBootMessage(...); <span class="comment">//显示启动界面</span></span><br><span class="line">       ...</span><br><span class="line">       statusBar = <span class="keyword">new</span> StatusBarManagerService(context, wm); <span class="comment">//statusBar</span></span><br><span class="line">       <span class="comment">//dropbox</span></span><br><span class="line">       ServiceManager.addService(Context.DROPBOX_SERVICE,</span><br><span class="line">                   <span class="keyword">new</span> DropBoxManagerService(context, <span class="keyword">new</span> File(<span class="string">"/data/system/dropbox"</span>)));</span><br><span class="line">        mSystemServiceManager.startService(JobSchedulerService.class); <span class="comment">//JobScheduler</span></span><br><span class="line">        lockSettings.systemReady(); <span class="comment">//lockSettings</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//phase480 和phase500</span></span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">       mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">       ...</span><br><span class="line">       <span class="comment">// 准备好window, power, package, display服务</span></span><br><span class="line">       wm.systemReady();</span><br><span class="line">       mPowerManagerService.systemReady(...);</span><br><span class="line">       mPackageManagerService.systemReady();</span><br><span class="line">       mDisplayManagerService.systemReady(...);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//重头戏</span></span><br><span class="line">       mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-7、服务启动阶段"><a href="#4-4-7、服务启动阶段" class="headerlink" title="4.4.7、服务启动阶段"></a>4.4.7、服务启动阶段</h4><p>SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N13-android-system-start-system_server_boot_process.jpg" alt="Markdown"></p><p>其中PHASE_BOOT_COMPLETED=1000，该阶段是发生在Boot完成和home应用启动完毕。系统服务更倾向于监听该阶段，而不是注册广播ACTION_BOOT_COMPLETED，从而降低系统延迟。</p><p>各个启动阶段所在源码的大致位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//phase100</span></span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//phase480 &amp;&amp; 500</span></span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//phase550</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">//phase600</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来再说说简单每个阶段的大概完成的工作：</p><h5 id="4-4-7-1、Phase0"><a href="#4-4-7-1、Phase0" class="headerlink" title="4.4.7.1、Phase0"></a>4.4.7.1、Phase0</h5><p>创建四大引导服务:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ActivityManagerService</span><br><span class="line">PowerManagerService</span><br><span class="line">LightsService</span><br><span class="line">DisplayManagerService</span><br></pre></td></tr></table></figure><h5 id="4-4-7-1-2、Phase100"><a href="#4-4-7-1-2、Phase100" class="headerlink" title="4.4.7.1.2、Phase100"></a>4.4.7.1.2、Phase100</h5><p>进入阶段PHASE_WAIT_FOR_DEFAULT_DISPLAY=100回调服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">DisplayManagerService</span><br></pre></td></tr></table></figure><p>然后创建大量服务下面列举部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PackageManagerService</span><br><span class="line">WindowManagerService</span><br><span class="line">InputManagerService</span><br><span class="line">NetworkManagerService</span><br><span class="line">DropBoxManagerService</span><br><span class="line">FingerprintService</span><br><span class="line">LauncherAppsService</span><br><span class="line">…</span><br></pre></td></tr></table></figure><h5 id="4-4-7-1-3、Phase480"><a href="#4-4-7-1-3、Phase480" class="headerlink" title="4.4.7.1.3、Phase480"></a>4.4.7.1.3、Phase480</h5><p>进入阶段PHASE_LOCK_SETTINGS_READY=480回调服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">480</span>)</span><br><span class="line"></span><br><span class="line">DevicePolicyManagerService</span><br></pre></td></tr></table></figure><p>阶段480后马上就进入阶段500.</p><h5 id="4-4-7-1-4、Phase500"><a href="#4-4-7-1-4、Phase500" class="headerlink" title="4.4.7.1.4、Phase500"></a>4.4.7.1.4、Phase500</h5><p>PHASE_SYSTEM_SERVICES_READY=500，进入该阶段服务能安全地调用核心系统服务.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">AlarmManagerService</span><br><span class="line">JobSchedulerService</span><br><span class="line">NotificationManagerService</span><br><span class="line">BackupManagerService</span><br><span class="line">UsageStatsService</span><br><span class="line">DeviceIdleController</span><br><span class="line">TrustManagerService</span><br><span class="line">UiModeManagerService</span><br><span class="line">BluetoothService</span><br><span class="line">BluetoothManagerService</span><br><span class="line">EthernetService</span><br><span class="line">WifiP2pService</span><br><span class="line">WifiScanningService</span><br><span class="line">WifiService</span><br><span class="line">RttService</span><br></pre></td></tr></table></figure><p>各大服务执行systemReady():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WindowManagerService.systemReady():</span><br><span class="line">PowerManagerService.systemReady():</span><br><span class="line">PackageManagerService.systemReady():</span><br><span class="line">DisplayManagerService.systemReady():</span><br></pre></td></tr></table></figure><p>接下来就绪AMS.systemReady方法.</p><h5 id="4-4-7-1-5、Phase550"><a href="#4-4-7-1-5、Phase550" class="headerlink" title="4.4.7.1.5、Phase550"></a>4.4.7.1.5、Phase550</h5><p>PHASE_ACTIVITY_MANAGER_READY=550， AMS.mSystemReady=true, 已准备就绪,进入该阶段服务能广播Intent;但是system_server主线程并没有就绪.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">onBootPhase(<span class="number">550</span>)</span><br><span class="line"></span><br><span class="line">MountService</span><br><span class="line">TelecomLoaderService</span><br><span class="line">UsbService</span><br><span class="line">WebViewUpdateService</span><br><span class="line">DockObserver</span><br><span class="line">BatteryService</span><br></pre></td></tr></table></figure><p>接下来执行: (AMS启动native crash监控, 加载WebView，启动SystemUI等),如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">WebViewFactory.prepareWebViewInSystemServer();</span><br><span class="line">startSystemUi(context);</span><br><span class="line">networkScoreF.systemReady();</span><br><span class="line">networkManagementF.systemReady();</span><br><span class="line">networkStatsF.systemReady();</span><br><span class="line">networkPolicyF.systemReady();</span><br><span class="line">connectivityF.systemReady();</span><br><span class="line">audioServiceF.systemReady();</span><br><span class="line">Watchdog.getInstance().start();</span><br></pre></td></tr></table></figure><h5 id="4-4-7-1-6、Phase600"><a href="#4-4-7-1-6、Phase600" class="headerlink" title="4.4.7.1.6、Phase600"></a>4.4.7.1.6、Phase600</h5><p>PHASE_THIRD_PARTY_APPS_CAN_START=600</p><p>onBootPhase(600)</p><blockquote><p>JobSchedulerService<br>NotificationManagerService<br>BackupManagerService<br>AppWidgetService<br>GestureLauncherService<br>DreamManagerService<br>TrustManagerService<br>VoiceInteractionManagerService</p></blockquote><p>接下来,各种服务的systemRunning过程:</p><p>WallpaperManagerService、InputMethodManagerService、LocationManagerService、CountryDetectorService、NetworkTimeUpdateService、CommonTimeManagementService、TextServicesManagerService、AssetAtlasService、InputManagerService、TelephonyRegistry、MediaRouterService、MmsServiceBroker这些服务依次执行其systemRunning()方法。</p><h5 id="4-4-7-1-7、Phase1000"><a href="#4-4-7-1-7、Phase1000" class="headerlink" title="4.4.7.1.7、Phase1000"></a>4.4.7.1.7、Phase1000</h5><p>在经过一系列流程，再调用AMS.finishBooting()时，则进入阶段Phase1000。</p><p>到此，系统服务启动阶段完成就绪，system_server进程启动完成则进入Looper.loop()状态，随时待命，等待消息队列MessageQueue中的消息到来，则马上进入执行状态。</p><h4 id="4-4-8、服务类别"><a href="#4-4-8、服务类别" class="headerlink" title="4.4.8、服务类别"></a>4.4.8、服务类别</h4><p>system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。 以下这些系统服务的注册过程, 见Android系统服务的注册方式</p><p>引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService； 核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService； 其他服务(70个+)：AlarmManagerService、VibratorService等。 合计总大约80个系统服务：</p><blockquote><p>ActivityManagerService PackageManagerService WindowManagerService PowerManagerService BatteryService BatteryStatsService DreamManagerService DropBoxManagerService SamplingProfilerService UsageStatsService DiskStatsService DeviceStorageMonitorService SchedulingPolicyService AlarmManagerService DeviceIdleController ThermalObserver JobSchedulerService AccessibilityManagerService DisplayManagerService LightsService GraphicsStatsService StatusBarManagerService NotificationManagerService WallpaperManagerService UiModeManagerService AppWidgetService LauncherAppsService TextServicesManagerService ContentService LockSettingsService InputMethodManagerService InputManagerService MountService FingerprintService TvInputManagerService DockObserver NetworkManagementService NetworkScoreService NetworkStatsService NetworkPolicyManagerService ConnectivityService BluetoothService WifiP2pService WifiService WifiScanningService AudioService MediaRouterService VoiceInteractionManagerService MediaProjectionManagerService MediaSessionService<br><br>DevicePolicyManagerService PrintManagerService BackupManagerService UserManagerService AccountManagerService TrustManagerService SensorService LocationManagerService VibratorService CountryDetectorService GestureLauncherService PersistentDataBlockService EthernetService WebViewUpdateService ClipboardService TelephonyRegistry TelecomLoaderService NsdService UpdateLockService SerialService SearchManagerService CommonTimeManagementService AssetAtlasService ConsumerIrService MidiServiceCameraService TwilightService RestrictionsManagerService MmsServiceBroker RttService UsbService</p></blockquote><p>Service类别众多，其中表中加粗项是指博主挑选的较重要或者较常见的Service，并且在本博客中已经展开或者计划展开讲解的Service，当然如果有精力会讲解更多service，后续再更新。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N15-android-system-start-AMS.jpg" alt="Markdown"></p><h3 id="（5）、启动ActivityManagerService"><a href="#（5）、启动ActivityManagerService" class="headerlink" title="（5）、启动ActivityManagerService"></a>（5）、启动ActivityManagerService</h3><h4 id="4-5-1、概述"><a href="#4-5-1、概述" class="headerlink" title="4.5.1、概述"></a>4.5.1、概述</h4><p>ActivityManagerService(AMS)是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用程序的管理和调度等工作。</p><p>AMS通信结构如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N14-android-system-start-.png" alt="Markdown"></p><h4 id="4-5-2、SystemServer-startBootstrapServices"><a href="#4-5-2、SystemServer-startBootstrapServices" class="headerlink" title="4.5.2、SystemServer.startBootstrapServices()"></a>4.5.2、SystemServer.startBootstrapServices()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//启动AMS服务</span></span><br><span class="line">mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">        ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置AMS的系统服务管理器</span></span><br><span class="line">mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line"><span class="comment">//设置AMS的APP安装器</span></span><br><span class="line">mActivityManagerService.setInstaller(installer);</span><br><span class="line"><span class="comment">//初始化AMS相关的PMS</span></span><br><span class="line">mActivityManagerService.initPowerManagement();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置SystemServer</span></span><br><span class="line">mActivityManagerService.setSystemProcess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-3、启动AMS服务"><a href="#4-5-3、启动AMS服务" class="headerlink" title="4.5.3、启动AMS服务"></a>4.5.3、启动AMS服务</h4><p>SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要：</p><p>创建ActivityManagerService.Lifecycle对象； 调用Lifecycle.onStart()方法。</p><h4 id="4-5-4、启动AMS服务"><a href="#4-5-4、启动AMS服务" class="headerlink" title="4.5.4、启动AMS服务"></a>4.5.4、启动AMS服务</h4><p><strong>4.5.4.1 AMS.Lifecycle</strong> [-&gt; ActivityManagerService.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> <span class="keyword">extends</span> <span class="title">SystemService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Lifecycle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    <span class="comment">//创建ActivityManagerService</span></span><br><span class="line">    mService = <span class="keyword">new</span> ActivityManagerService(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mService.start();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityManagerService <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该过程：创建AMS内部类的Lifecycle，已经创建AMS对象，并调用AMS.start();</p><p><strong>4.5.4.2 AMS创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line">mContext = systemContext;</span><br><span class="line">mFactoryTest = FactoryTest.getMode();<span class="comment">//默认为FACTORY_TEST_OFF</span></span><br><span class="line">mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建名为"ActivityManager"的前台线程，并获取mHandler</span></span><br><span class="line">mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span>);</span><br><span class="line">mHandlerThread.start();</span><br><span class="line"></span><br><span class="line">mHandler = <span class="keyword">new</span> MainHandler(mHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过UiThread类，创建名为"android.ui"的线程</span></span><br><span class="line">mUiHandler = <span class="keyword">new</span> UiHandler();</span><br><span class="line"></span><br><span class="line"><span class="comment">//前台广播接收器，在运行超过10s将放弃执行</span></span><br><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//后台广播接收器，在运行超过60s将放弃执行</span></span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line">mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建ActiveServices，其中非低内存手机mMaxStartingBackground为8</span></span><br><span class="line">mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>);</span><br><span class="line">mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建目录/data/system</span></span><br><span class="line">File dataDir = Environment.getDataDirectory();</span><br><span class="line">File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);</span><br><span class="line">systemDir.mkdirs();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务BatteryStatsService</span></span><br><span class="line">mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemDir, mHandler);</span><br><span class="line">mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建进程统计服务，信息保存在目录/data/system/procstats，</span></span><br><span class="line">mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">"procstats"</span>));</span><br><span class="line"></span><br><span class="line">mAppOpsService = <span class="keyword">new</span> AppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">"appops.xml"</span>), mHandler);</span><br><span class="line">mGrantFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(systemDir, <span class="string">"urigrants.xml"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// User 0是第一个，也是唯一的一个开机过程中运行的用户</span></span><br><span class="line">mStartedUsers.put(UserHandle.USER_OWNER, <span class="keyword">new</span> UserState(UserHandle.OWNER, <span class="keyword">true</span>));</span><br><span class="line">mUserLru.add(UserHandle.USER_OWNER);</span><br><span class="line">updateStartedUserArrayLocked();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//CPU使用情况的追踪器执行初始化</span></span><br><span class="line">mProcessCpuTracker.init();</span><br><span class="line">...</span><br><span class="line">mRecentTasks = <span class="keyword">new</span> RecentTasks(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 创建ActivityStackSupervisor对象</span></span><br><span class="line">mStackSupervisor = <span class="keyword">new</span> ActivityStackSupervisor(<span class="keyword">this</span>, mRecentTasks);</span><br><span class="line">mTaskPersister = <span class="keyword">new</span> TaskPersister(systemDir, mStackSupervisor, mRecentTasks);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建名为"CpuTracker"的线程</span></span><br><span class="line">mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">"CpuTracker"</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">              <span class="keyword">long</span> nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">              <span class="keyword">long</span> nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">              <span class="keyword">if</span> (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                  nextCpuDelay = nextWriteDelay;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (nextCpuDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                  mProcessCpuMutexFree.set(<span class="keyword">true</span>);</span><br><span class="line">                  <span class="keyword">this</span>.wait(nextCpuDelay);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">          updateCpuStatsNow(); <span class="comment">//更新CPU状态</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.5.4.3、AMS的start函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成统计前的复位工作</span></span><br><span class="line">    Process.removeAllProcessGroups();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始监控进程的CPU使用情况</span></span><br><span class="line">    mProcessCpuThread.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册服务</span></span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    Slog.d(<span class="string">"AppOps"</span>, <span class="string">"AppOpsService published"</span>);</span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br></pre></td></tr></table></figure><p>AMS的start函数比较简单，主要是： 1、启动CPU监控线程。该线程将会开始统计不同进程使用CPU的情况。 2、发布一些服务，如BatteryStatsService、AppOpsService(权限管理相关)和本地实现的继承ActivityManagerInternal的服务。</p><p><strong>4.5.5 AMS.setSystemProcess()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"processinfo"</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line">        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">                <span class="string">"android"</span>, STOCK_PM_FLAGS);</span><br><span class="line"></span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//创建ProcessRecord对象</span></span><br><span class="line">            ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">            app.persistent = <span class="keyword">true</span>; <span class="comment">//设置为persistent进程</span></span><br><span class="line">            app.pid = MY_PID;</span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);<span class="comment">//维护进程lru</span></span><br><span class="line">            updateOomAdjLocked(); <span class="comment">//更新adj</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要工作是注册各种服务。</p><p><strong>4.5.5.1 AT.installSystemApplicationInfo()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        getSystemContext().installSystemApplicationInfo(info, classLoader);</span><br><span class="line">        <span class="comment">//创建用于性能统计的Profiler对象</span></span><br><span class="line">        mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用ContextImpl的nstallSystemApplicationInfo()方法，最终调用LoadedApk的installSystemApplicationInfo，加载名为”android”的package</p><p><strong>4.5.5.2 installSystemApplicationInfo()</strong> [-&gt; LoadedApk.java]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> info.packageName.equals(<span class="string">"android"</span>);</span><br><span class="line">    mApplicationInfo = info; <span class="comment">//将包名为"android"的应用信息保存到mApplicationInfo</span></span><br><span class="line">    mClassLoader = classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.5.6 startOtherServices()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//安装系统Provider</span></span><br><span class="line">  mActivityManagerService.installSystemProviders();</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">//phase480 &amp;&amp; 500</span></span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY);</span><br><span class="line">  mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY);</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//phase550</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_ACTIVITY_MANAGER_READY);</span><br><span class="line">         ...</span><br><span class="line">         <span class="comment">//phase600</span></span><br><span class="line">         mSystemServiceManager.startBootPhase(</span><br><span class="line">                 SystemService.PHASE_THIRD_PARTY_APPS_CAN_START);</span><br><span class="line">         ...</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.5.6.1 AMS.installSystemProviders()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ProcessRecord app = mProcessNames.get(<span class="string">"system"</span>, Process.SYSTEM_UID);</span><br><span class="line">        providers = generateApplicationProvidersLocked(app);</span><br><span class="line">        <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=providers.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProviderInfo pi = (ProviderInfo)providers.get(i);</span><br><span class="line">                <span class="comment">//移除非系统的provider</span></span><br><span class="line">                <span class="keyword">if</span> ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//安装所有的系统provider</span></span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建核心Settings Observer，用于监控Settings的改变。</span></span><br><span class="line">    mCoreSettingsObserver = <span class="keyword">new</span> CoreSettingsObserver(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-7、AMS-systemReady"><a href="#4-5-7、AMS-systemReady" class="headerlink" title="4.5.7、AMS.systemReady()"></a>4.5.7、AMS.systemReady()</h4><h4 id="4-5-7-1、阶段一"><a href="#4-5-7-1、阶段一" class="headerlink" title="4.5.7.1、阶段一"></a>4.5.7.1、阶段一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        ..........</span><br><span class="line">        <span class="comment">//这一部分主要是调用一些关键服务SystemReady相关的函数，</span></span><br><span class="line">        <span class="comment">//进行一些等待AMS初始完，才能进行的工作</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure we have the current profile info, since it is needed for security checks.</span></span><br><span class="line">        mUserController.onSystemReady();</span><br><span class="line"></span><br><span class="line">        mRecentTasks.onSystemReadyLocked();</span><br><span class="line">        mAppOpsService.systemReady();</span><br><span class="line">        mSystemReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procsToKill = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(mPidsSelfLocked) &#123;</span><br><span class="line">        <span class="comment">//mPidsSelfLocked中保存当前正在运行的所有进程的信息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mPidsSelfLocked.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProcessRecord proc = mPidsSelfLocked.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在AMS启动完成前，如果没有FLAG_PERSISTENT标志的进程已经启动了，</span></span><br><span class="line">            <span class="comment">//就将这个进程加入到procsToKill中</span></span><br><span class="line">            <span class="keyword">if</span> (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">                <span class="keyword">if</span> (procsToKill == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    procsToKill = <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                procsToKill.add(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//利用removeProcessLocked关闭procsToKill中的进程</span></span><br><span class="line">        <span class="keyword">if</span> (procsToKill != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=procsToKill.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProcessRecord proc = procsToKill.get(i);</span><br><span class="line">                Slog.i(TAG, <span class="string">"Removing system update proc: "</span> + proc);</span><br><span class="line">                removeProcessLocked(proc, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"system update done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that we have cleaned up any update processes, we</span></span><br><span class="line">        <span class="comment">// are ready to start launching real processes and know that</span></span><br><span class="line">        <span class="comment">// we won't trample on them any more.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//至此系统准备完毕</span></span><br><span class="line">        mProcessesReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">    <span class="comment">//根据数据库和资源文件，获取一些配置参数</span></span><br><span class="line">    retrieveSettings();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//得到当前的用户ID</span></span><br><span class="line">        currentUserId = mUserController.getCurrentUserIdLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取urigrants.xml，为其中定义的ContentProvider配置对指定Uri数据的访问/修改权限</span></span><br><span class="line">        <span class="comment">//原生代码中，似乎没有urigrants.xml文件</span></span><br><span class="line">        <span class="comment">//实际使用的grant-uri-permission是分布式定义的</span></span><br><span class="line">        readGrantedUriPermissionsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ..........</span><br></pre></td></tr></table></figure><p>这一部分的工作主要是调用一些关键服务的初始化函数， 然后杀死那些没有FLAG_PERSISTENT却在AMS启动完成前已经存在的进程， 同时获取一些配置参数。 需要注意的是，由于只有Java进程才会向AMS注册，而一般的Native进程不会向AMS注册，因此此处杀死的进程是Java进程。</p><h4 id="4-5-7-2、阶段二"><a href="#4-5-7-2、阶段二" class="headerlink" title="4.5.7.2、阶段二"></a>4.5.7.2、阶段二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、调用参数传入的runnable对象，SystemServer中有具体的定义</span></span><br><span class="line"><span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line">..............</span><br><span class="line"><span class="comment">//调用所有系统服务的onStartUser接口</span></span><br><span class="line">mSystemServiceManager.startUser(currentUserId);</span><br><span class="line">.............</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// Only start up encryption-aware persistent apps; once user is</span></span><br><span class="line">    <span class="comment">// unlocked we'll come back around and start unaware apps</span></span><br><span class="line">    <span class="number">2</span>、启动persistent为<span class="number">1</span>的application所在的进程</span><br><span class="line">    startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start up initial activity.</span></span><br><span class="line">    mBooting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable home activity for system user, so that the system can always boot</span></span><br><span class="line">    <span class="comment">//当isSplitSystemUser返回true时，意味者system user和primary user是分离的</span></span><br><span class="line">    <span class="comment">//这里应该是让system user也有启动home activity的权限吧</span></span><br><span class="line">    <span class="keyword">if</span> (UserManager.isSplitSystemUser()) &#123;</span><br><span class="line">        ComponentName cName = <span class="keyword">new</span> ComponentName(mContext, SystemUserHomeActivity.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AppGlobals.getPackageManager().setComponentEnabledSetting(cName,</span><br><span class="line">                    PackageManager.COMPONENT_ENABLED_STATE_ENABLED, <span class="number">0</span>,</span><br><span class="line">                    UserHandle.USER_SYSTEM);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、启动Home</span></span><br><span class="line">    startHomeActivityLocked(currentUserId, <span class="string">"systemReady"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发送消息，触发处理Uid错误的Application</span></span><br><span class="line">        <span class="keyword">if</span> (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123;</span><br><span class="line">            ..........</span><br><span class="line">            mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送一些广播信息</span></span><br><span class="line">    ............</span><br><span class="line">    <span class="comment">//这里暂时先不深入，等进一步了解Activity的启动过程后，再做了解</span></span><br><span class="line">    mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br><span class="line">.............</span><br></pre></td></tr></table></figure><p>从部分代码来看，主要的工作就是通知一些服务可以进行systemReady相关的工作，并进行启动服务或应用进程的工作。</p><h4 id="2-1、调用回调接口"><a href="#2-1、调用回调接口" class="headerlink" title="2.1、调用回调接口"></a>2.1、调用回调接口</h4><p>回调接口的具体内容定义与SystemServer.java中，其中会调用大量服务的onBootPhase函数、一些对象的systemReady函数或systemRunning函数。 此处，我们仅截取一些比较特别的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ............</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动NativeCrashListener监听"/data/system/ndebugsocket"中的信息</span></span><br><span class="line">        <span class="comment">//实际上是监听debuggerd传入的信息</span></span><br><span class="line">        mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"observing native crashes"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//启动SystemUi</span></span><br><span class="line">        startSystemUi(context);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"starting System UI"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">    <span class="comment">//这个以前分析过，启动Watchdog</span></span><br><span class="line">    Watchdog.getInstance().start();</span><br><span class="line">    ....................</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回调接口中的内容较多，不做一一分析。</p><h4 id="2-2、启动persistent标志的进程"><a href="#2-2、启动persistent标志的进程" class="headerlink" title="2.2、启动persistent标志的进程"></a>2.2、启动persistent标志的进程</h4><p>我们看看startPersistentApps对应的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPersistentApps</span><span class="params">(<span class="keyword">int</span> matchFlags)</span> </span>&#123;</span><br><span class="line">    .............</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//从PKMS中得到persistent为1的ApplicationInfo</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager()</span><br><span class="line">                    .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo app : apps) &#123;</span><br><span class="line">                <span class="comment">//由于framework-res.apk已经由系统启动，所以此处不再启动它</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"android"</span>.equals(app.packageName)) &#123;</span><br><span class="line">                    <span class="comment">//addAppLocked中将启动application所在进程</span></span><br><span class="line">                    addAppLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进一下addAppLocked函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">addAppLocked</span><span class="params">(ApplicationInfo info, <span class="keyword">boolean</span> isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">        String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以下是取出或构造出ApplicationInfo对应的ProcessRecord</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(info.processName, info.uid, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app = newProcessRecordLocked(info, <span class="keyword">null</span>, isolated, <span class="number">0</span>);</span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="comment">// This package really, really can not be stopped.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过PKMS将package对应数据结构的StoppedState置为fasle</span></span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                info.packageName, <span class="keyword">false</span>, UserHandle.getUserId(app.uid));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + info.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        app.persistent = <span class="keyword">true</span>;</span><br><span class="line">        app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mPersistentStartingProcesses.add(app);</span><br><span class="line">        <span class="comment">//启动应用所在进程，将发送消息给zygote，后者fork出进程</span></span><br><span class="line">        startProcessLocked(app, <span class="string">"added application"</span>, app.processName, abiOverride,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终将通过startProcessLocked函数，启动实际的应用进程。 正如之前分析zygote进程时，提过的一样，zygote中的server socket将接收消息，然后为应用fork出进程。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>对于整个AMS启动过程而言，博客中涉及的内容可能只是极小的一部分。 但即使我们尽可能的简化，整个过程的内容还是非常多。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.boot/N16-android-system-start-flow.jpg" alt="Markdown"><br>不过我们回头看看整个过程，还是能比较清晰地将AMS的启动过程分为四步，如上图所示： 1、创建出SystemServer进程的Android运行环境。 在这一部分，SystemServer进程主要创建出对应的ActivityThread和ContextImpl，构成Android运行环境。 AMS的后续工作依赖于SystemServer在此创建出的运行环境。</p><p>2、完成AMS的初始化和启动。 在这一部分，单纯地调用AMS的构造函数和start函数，完成AMS的一些初始化工作。</p><p>3、将SystemServer进程纳入到AMS的管理体系中。 AMS作为Java世界的进程管理和调度中心，要对所有Java进程一视同仁，因此SystemServer进程也必须被AMS管理。 在这个过程中，AMS加载了SystemServer中framework-res.apk的信息，并启动和注册了SettingsProvider.apk。</p><p>4、开始执行AMS启动完毕后才能进行的工作。 系统中的一些服务和进程，必须等待AMS完成启动后，才能展开后续工作。 在这一部分，AMS通过调用systemReady函数，通知系统中的其它服务和进程，可以进行对应工作了。 在这个过程中，值得我们关注的是：Home Activity被启动了。当该Activity被加载完成后，最终会触发ACTION_BOOT_COMPLETED广播。</p><h4 id="（6）、启动Launcher-Activity"><a href="#（6）、启动Launcher-Activity" class="headerlink" title="（6）、启动Launcher(Activity)"></a>（6）、启动Launcher(Activity)</h4><p>看看启动Home Activity对应的startHomeActivityLocked函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    ..............</span><br><span class="line">    Intent intent = getHomeIntent();</span><br><span class="line">    <span class="comment">//根据intent中携带的ComponentName，利用PKMS得到ActivityInfo</span></span><br><span class="line">    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时home对应进程应该还没启动，app为null</span></span><br><span class="line">        ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            <span class="comment">//启动home</span></span><br><span class="line">            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ..........</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暂时先不深究Home Activity启动的具体过程。 从手头的资料来看，当Home Activity启动后， ActivityStackSupervisor中的activityIdleInternalLocked函数将被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config)</span> </span>&#123;</span><br><span class="line">    ...........</span><br><span class="line">    <span class="keyword">if</span> (isFocusedStack(r.task.stack) || fromTimeout) &#123;</span><br><span class="line">        booting = checkFinishBootingLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在checkFinishBootingLocked函数中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFinishBootingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mService为AMS，mBooting变量在AMS回调SystemServer中定义的Runnable时，置为了true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> booting = mService.mBooting;</span><br><span class="line">    <span class="keyword">boolean</span> enableScreen = <span class="keyword">false</span>;</span><br><span class="line">    mService.mBooting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooted) &#123;</span><br><span class="line">        mService.mBooted = <span class="keyword">true</span>;</span><br><span class="line">        enableScreen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (booting || enableScreen) &#123;、</span><br><span class="line">        <span class="comment">//调用AMS的接口，发送消息</span></span><br><span class="line">        mService.postFinishBooting(booting, enableScreen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> booting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，AMS的finishBooting函数将被调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishBooting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .........</span><br><span class="line">    <span class="comment">//以下是注册广播接收器，用于处理需要重启的package</span></span><br><span class="line">    IntentFilter pkgFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</span><br><span class="line">    pkgFilter.addDataScheme(<span class="string">"package"</span>);</span><br><span class="line">    mContext.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);</span><br><span class="line">            <span class="keyword">if</span> (pkgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String pkg : pkgs) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (forceStopPackageLocked(pkg, -<span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                                <span class="number">0</span>, <span class="string">"query restart"</span>)) &#123;</span><br><span class="line">                            setResultCode(Activity.RESULT_OK);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;, pkgFilter);</span><br><span class="line">    ...........</span><br><span class="line">    <span class="comment">// Let system services know.</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是启动那些等待启动的进程</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// Ensure that any processes we had put on hold are now started</span></span><br><span class="line">        <span class="comment">// up.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NP = mProcessesOnHold.size();</span><br><span class="line">            <span class="keyword">if</span> (NP &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ArrayList&lt;ProcessRecord&gt; procs =</span><br><span class="line">                        <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ip=<span class="number">0</span>; ip&lt;NP; ip++) &#123;</span><br><span class="line">                    .................</span><br><span class="line">                    startProcessLocked(procs.get(ip), <span class="string">"on-hold"</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ..............</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="comment">// Start looking for apps that are abusing wake locks.</span></span><br><span class="line">        <span class="comment">//每15min检查一次系统各应用进程使用电量的情况，如果某个进程使用WakeLock的时间过长</span></span><br><span class="line">        <span class="comment">//AMS将关闭该进程</span></span><br><span class="line">        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">        mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Tell anyone interested that we are done booting!</span></span><br><span class="line">        SystemProperties.set(<span class="string">"sys.boot_completed"</span>, <span class="string">"1"</span>);</span><br><span class="line">        .................</span><br><span class="line">        <span class="comment">//此处从代码来看发送的是ACTION_LOCKED_BOOT_COMPLETED广播</span></span><br><span class="line">        <span class="comment">//在进行unlock相关的工作后，mUserController将调用finishUserUnlocking，发送SYSTEM_USER_UNLOCK_MSG消息给AMS</span></span><br><span class="line">        <span class="comment">//AMS收到消息后，调用mUserController的finishUserUnlocked函数，经过相应的处理后，</span></span><br><span class="line">        <span class="comment">//在mUserController的finishUserUnlockedCompleted中，最终将会发送ACTION_BOOT_COMPLETED广播</span></span><br><span class="line">        mUserController.sendBootCompletedLocked(.........);</span><br><span class="line">        .................</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，当AMS启动Home Activity结束，并发送ACTION_BOOT_COMPLETED广播时，AMS的启动过程告一段落。</p><p>具体启动流程请参考：【Android 7.1.2 (Android N) Activity启动流程分析】</p><h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a href="http://blog.csdn.net/Gaugamela/article/category/6383486" target="_blank" rel="noopener">Android 7.0 ActivityManagerService 1 - 10</a><br><a href="http://blog.leanote.com/post/jay_richard/Android-Init%E8%BF%9B%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Android Init进程源码分析(1) - jay_richard</a><br><a href="http://blog.leanote.com/post/jay_richard/Android-Init%E8%BF%9B%E7%A8%8B%E4%B9%8B%E8%A7%A3%E6%9E%90init.rc" target="_blank" rel="noopener">Android Init进程源码分析(2) - jay_richard</a><br><a href="http://blog.leanote.com/post/jay_richard/Android-Zygote%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Android Zygote进程分析 - jay_richard</a><br><a href="http://www.cnblogs.com/samchen2009/p/3294713.html" target="_blank" rel="noopener">图解Android - Zygote, System Server 启动分析 - 漫天尘沙 - 博客园</a><br><a href="http://blog.csdn.net/gaugamela/article/details/52133186" target="_blank" rel="noopener">Android7.0 init进程源码分析 - ZhangJian的博客 - CSDN博客</a><br><a href="http://gityuan.com/2016/02/20/android-system-server/" target="_blank" rel="noopener">Android系统启动-SystemServer上篇 - Gityuan博客 | 袁辉辉博客</a><br><a href="http://gityuan.com/2016/02/05/android-init/" target="_blank" rel="noopener">Android系统启动-Init篇 - Gityuan博客 | 袁辉辉博客</a><br><a href="http://gityuan.com/2016/02/13/android-zygote/" target="_blank" rel="noopener">Android系统启动-zygote篇 - Gityuan博客 | 袁辉辉博客</a><br><a href="http://gityuan.com/2016/02/20/android-system-server-2/" target="_blank" rel="noopener">Android系统启动-SystemServer下篇 - Gityuan博客 | 袁辉辉博客</a><br><a href="http://gityuan.com/2016/02/21/activity-manager-service/" target="_blank" rel="noopener">ActivityManagerService启动过程 - Gityuan博客 | 袁辉辉博客</a><br><a href="http://blog.csdn.net/yangwen123/article/details/9029959" target="_blank" rel="noopener">Android Init进程源码分析 - 深入剖析Android系统 - CSDN博客</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 7.1.2 (Android N) Android消息处理机制分析（从JAVA层到NATIVE层）– Handler、Looper、Message</title>
      <link href="/2017/08/01/Android-7-1-2-Android-N-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%93Handler%E3%80%81Looper%E3%80%81Message/"/>
      <url>/2017/08/01/Android-7-1-2-Android-N-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%93Handler%E3%80%81Looper%E3%80%81Message/</url>
      <content type="html"><![CDATA[<blockquote><p>● framework/base/core/java/andorid/os/Handler.java</p><p>● framework/base/core/java/andorid/os/Looper.java</p><p>● framework/base/core/java/andorid/os/Message.java</p><p>● framework/base/core/java/andorid/os/MessageQueue.java</p><p>● framework/base/core/java/andorid/os/MessageQueue.java</p><p>● framework/base/core/jni/android_os_MessageQueue.cpp</p><p>● framework/base/core/java/andorid/os/Looper.java (Java层）</p><p>● system/core/libutils/Looper.cpp ( Native层)</p><p>● framework/base/native/android/looper.cpp (ALoop对象)</p><p>● framework/native/include/android/looper.h</p></blockquote><h2 id="博客原图链接"><a href="#博客原图链接" class="headerlink" title="博客原图链接"></a><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.message" target="_blank" rel="noopener">博客原图链接</a></h2><h2 id="Ⅰ、Android消息机制-Java层"><a href="#Ⅰ、Android消息机制-Java层" class="headerlink" title="Ⅰ、Android消息机制(Java层)"></a>Ⅰ、Android消息机制(Java层)</h2><h3 id="一、Android消息机制相关类、概念（Java层）"><a href="#一、Android消息机制相关类、概念（Java层）" class="headerlink" title="一、Android消息机制相关类、概念（Java层）"></a>一、Android消息机制相关类、概念（Java层）</h3><p><strong>主线程（UI线程）</strong> 定义：当程序第一次启动时，Android会同时启动一条主线程（Main Thread） 作用：主线程主要负责处理与UI相关的事件</p><p><strong>Message（消息）</strong> 定义：Handler接收和处理的消息对象（Bean对象） 作用：通信时相关信息的存放和传递</p><p><strong>ThreadLocal</strong> 定义：线程内部的数据存储类 作用：负责存储和获取本线程的Looper</p><p><strong>MessageQueue（消息队列）</strong> 定义：采用单链表的数据结构来存储消息列表 作用：用来存放通过Handler发过来的Message，按照先进先出执行</p><p><strong>Handler（处理者）</strong> 定义：Message的主要处理者 作用：负责发送Message到消息队列&amp;处理Looper分派过来的Message</p><p><strong>Looper（循环器）</strong> 定义：扮演Message Queue和Handler之间桥梁的角色 作用： 消息循环：循环取出Message Queue的Message 消息派发：将取出的Message交付给相应的Handler</p><h3 id="二、类关系图（Java层）"><a href="#二、类关系图（Java层）" class="headerlink" title="二、类关系图（Java层）"></a>二、类关系图（Java层）</h3><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/01-android-handler-looper-message.jpg" alt="Markdown"></p><blockquote><p>● Looper有一个MessageQueue消息队列；<br>● MessageQueue有一组待处理的Message；<br>●Message中有一个用于处理消息的Handler；<br>● Handler中有Looper和MessageQueue。</p></blockquote><h4 id="典型实例"><a href="#典型实例" class="headerlink" title="典型实例:"></a>典型实例:</h4><p>先展示一个典型的关于Handler/Looper的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Handler mHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Looper.prepare();</span><br><span class="line"></span><br><span class="line">        mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//TODO 定义消息处理逻辑.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，围绕着这个实例展开详细分析。</p><h3 id="三、Looper源码分析（Java层）"><a href="#三、Looper源码分析（Java层）" class="headerlink" title="三、Looper源码分析（Java层）"></a>三、Looper源码分析（Java层）</h3><p>对于无参的情况，默认调用prepare(true)，表示的是这个Looper运行退出，而对于false的情况则表示当前Looper不运行退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Looper对象，并保存到当前线程的TLS区域</span></span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-知识：ThreadLocal介绍"><a href="#3-1-知识：ThreadLocal介绍" class="headerlink" title="3.1 知识：ThreadLocal介绍"></a>3.1 知识：ThreadLocal介绍</h3><p>这里的sThreadLocal是ThreadLocal类型，下面，先说说ThreadLocal。</p><p>ThreadLocal： 线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。TLS常用的操作方法：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/02-android-handler-looper-message-_Thread_Local.png" alt="Markdown"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.set(T value)：将value存储到当前线程的TLS区域，源码如下：</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">      Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">      <span class="keyword">if</span> (values == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//当线程本地存储区，尚未存储该线程相关信息时，则创建Values对象</span></span><br><span class="line">          values = initializeValues(currentThread);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//保存数据value到当前线程this</span></span><br><span class="line">      values.put(<span class="keyword">this</span>, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal.get()：获取当前线程TLS区域的数据，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread currentThread = Thread.currentThread(); <span class="comment">//获取当前线程</span></span><br><span class="line">    Values values = values(currentThread); <span class="comment">//查找当前线程的本地储存区</span></span><br><span class="line">    <span class="keyword">if</span> (values != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Object[] table = values.table;</span><br><span class="line">        <span class="keyword">int</span> index = hash &amp; values.mask;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reference == table[index]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) table[index + <span class="number">1</span>]; <span class="comment">//返回当前线程储存区中的数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建Values对象</span></span><br><span class="line">        values = initializeValues(currentThread);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) values.getAfterMiss(<span class="keyword">this</span>); <span class="comment">//从目标线程存储区没有查询是则返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal的get()和set()方法操作的类型都是泛型，接着回到前面提到的sThreadLocal变量，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;()</span><br></pre></td></tr></table></figure><p>可见sThreadLocal的get()和set()操作的类型都是Looper类型。</p><h3 id="1-Looper-prepare"><a href="#1-Looper-prepare" class="headerlink" title="(1) Looper.prepare()"></a>(1) Looper.prepare()</h3><p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p><p>对于Looper类型的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);  <span class="comment">//创建MessageQueue对象.</span></span><br><span class="line">    mThread = Thread.currentThread();  <span class="comment">//记录当前线程.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，与prepare()相近功能的，还有一个prepareMainLooper()方法，该方法主要在ActivityThread类中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">//设置不允许退出的Looper</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="comment">//将当前的Looper保存为主Looper，每个线程只允许执行一次。</span></span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.prepare()在每个线程只允许执行一次，该方法会创建Looper对象，Looper的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程TLS。</p><p>对于Looper类型的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);  <span class="comment">//创建MessageQueue对象.稍后详细介绍</span></span><br><span class="line">    mThread = Thread.currentThread();  <span class="comment">//记录当前线程.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，与prepare()相近功能的，还有一个prepareMainLooper()方法，该方法主要在主线程（UI线程）ActivityThread类中使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">//设置不允许退出的Looper</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="comment">//将当前的Looper保存为主Looper，每个线程只允许执行一次。</span></span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（2）创建MessageQueue"><a href="#（2）创建MessageQueue" class="headerlink" title="（2）创建MessageQueue()"></a>（2）创建MessageQueue()</h3><p>MessageQueue是消息机制的Java层和C++层的连接纽带，大部分核心方法都交给native层来处理，其中MessageQueue类中涉及的native方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>关于这些native方法的介绍，见第二节：Android消息机制(native篇)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">//通过native方法初始化消息队列，其中mPtr是供native代码使用</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>MessageQueue创建过程总结</strong>：</p><p><strong>1、Looper的prepare或者prepareMainLooper静态方法被调用，将一个Looper对象保存在ThreadLocal里面。</strong><br><strong>2、Looper对象的初始化方法里，首先会新建一个MessageQueue对象。</strong><br><strong>3、MessageQueue对象的初始化方法通过JNI初始化C++层的NativeMessageQueue对象。</strong><br><strong>4、NativeMessageQueue对象在创建过程中，会初始化一个C++层的Looper对象。</strong><br><strong>5、C++层的Looper对象在创建的过程中，会在内部创建一个管道（pipe），并将这个管道的读写fd都保存在 mWakeReadPipeFd和mWakeWritePipeFd中。然后新建一个epoll实例，并将两个fd注册进去。</strong><br><strong>6、利用epoll的机制，可以做到当管道没有消息时，线程睡眠在读端的fd上，当其他线程往管道写数据时，本线程便会被唤醒以进行消息处理。</strong></p></blockquote><h3 id="3-Looper-loop"><a href="#3-Looper-loop" class="headerlink" title="(3) Looper.loop()"></a>(3) Looper.loop()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();  <span class="comment">//获取TLS存储的Looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;  <span class="comment">//获取Looper对象中的消息队列</span></span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="comment">//确保在权限检查时基于本地进程，而不是基于最初调用进程。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//进入loop的主循环方法</span></span><br><span class="line">        Message msg = queue.next(); <span class="comment">//可能会阻塞 May be block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123; <span class="comment">//没有消息，则退出循环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Printer logging = me.mLogging;  <span class="comment">//默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg); <span class="comment">//用于分发Message</span></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity(); <span class="comment">//确保分发过程中identity不会损坏</span></span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">             <span class="comment">//打印identity改变的log，在分发消息过程中是不希望身份被改变的。</span></span><br><span class="line">        &#125;</span><br><span class="line">        msg.recycleUnchecked();  <span class="comment">//将Message放入消息池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop()进入循环模式，不断重复下面的操作，直到没有消息时退出循环</p><p>读取MessageQueue的下一条Message；把Message分发给相应的target； A1：Looper.loop()循环中的msg.target是什么时候被赋值的？handler.sendMessage()最终会进入MessageQueue.enqueueMessage()，就是在这里面复制的。 稍后再handler.sendMessage()详细介绍。 再把分发后的Message回收到消息池，以便重复利用。Looper.loop()是消息处理的核心部分。</p><h4 id="3-1-MessageQueue-next"><a href="#3-1-MessageQueue-next" class="headerlink" title="3.1 MessageQueue.next()"></a>3.1 MessageQueue.next()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123; <span class="comment">//当消息循环已经退出，则直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// 循环迭代的首次为-1</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，则退出循环。</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">//当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 获取一条消息，并返回</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//设置消息的使用状态，即flags |= FLAG_IN_USE</span></span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;   <span class="comment">//成功地获取MessageQueue中的下一条即将要执行的消息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没有消息</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//消息正在退出，返回null</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当消息队列为空，或者是消息队列的第一个消息时</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span> &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没有idle handlers 需要运行，则循环并等待。</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">//去掉handler的引用</span></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();  <span class="comment">//idle时执行的方法</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重置idle handler个数为0，以保证不会再次重复运行</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nativePollOnce()在native做了大量的工作，Android消息机制(native篇)稍后详细分析。</p><blockquote><p><strong>消息循环Looper.loop()总结：</strong></p><p><strong>首先通过调用Looper的loop方法开始消息监听。loop方法里会调用MessageQueue的next方法。next方法会堵塞线程直到有消息到来为止。</strong></p><p><strong>next方法通过调用nativePollOnce方法来监听事件。next方法内部逻辑如下所示(简化)：</strong></p><p><strong>a.进入死循环，以参数timout=0调用nativePollOnce方法。</strong></p><p><strong>b.如果消息队列中有消息，nativePollOnce方法会将消息保存在mMessage成员中。nativePollOnce方法返回后立刻检查mMessage成员是否为空。</strong></p><p><strong>c.如果mMessage不为空，那么检查它指定的运行时间。如果比当前时间要前，那么马上返回这个mMessage，否则设置&gt; timeout为两者之差，进入下一次循环。</strong></p><p><strong>d. 如果mMessage为空，那么设置timeout为-1，即下次循环nativePollOnce永久堵塞。 nativePollOnce方法内部利用epoll机制在之前建立的管道上等待数据写入。接收到数据后马上读取并返回结果。</strong></p></blockquote><p>这里先提一下为什么会阻塞，稍后再Android消息处理(Native层)分析，主要是底层使用了Linux epoll： <a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></p><h4 id="3-2-Looper-quit"><a href="#3-2-Looper-quit" class="headerlink" title="3.2 Looper.quit()"></a>3.2 Looper.quit()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>); <span class="comment">//消息移除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>); <span class="comment">//安全地消息移除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Looper.quit()方法的实现最终调用的是MessageQueue.quit()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue.quit()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123; <span class="comment">//防止多次执行退出操作</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mQuitting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">                removeAllFutureMessagesLocked(); <span class="comment">//移除尚未触发的所有消息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                removeAllMessagesLocked(); <span class="comment">//移除所有的消息</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//mQuitting=false，那么认定为 mPtr != 0</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>消息退出的方式：</p><p>当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除； 当safe =flase时，移除所有的消息</p><p>前面构造了Looper 、MessageQueue，假设此时没有message处理，Looper.loop()会阻塞在MessageQueue.next()。 接下来讲一下Handler如何发送和处理消息。</p><h3 id="四、异步处理大师-Handler"><a href="#四、异步处理大师-Handler" class="headerlink" title="四、异步处理大师 Handler()"></a>四、异步处理大师 Handler()</h3><h3 id="1-构造Handler"><a href="#1-构造Handler" class="headerlink" title="(1) 构造Handler()"></a>(1) 构造Handler()</h3><h3 id="1-1-无参构造Handler"><a href="#1-1-无参构造Handler" class="headerlink" title="1.1 无参构造Handler()"></a>1.1 无参构造Handler()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span></span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//必须先执行Looper.prepare()，才能获取Looper对象，否则为null.</span></span><br><span class="line">    mLooper = Looper.myLooper();  <span class="comment">//从当前线程的TLS中获取Looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue; <span class="comment">//消息队列，来自Looper对象</span></span><br><span class="line">    mCallback = callback;  <span class="comment">//回调方法</span></span><br><span class="line">    mAsynchronous = async; <span class="comment">//设置消息是否为异步处理方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。</p><h3 id="1-2-有参构造Handler"><a href="#1-2-有参构造Handler" class="headerlink" title="1.2 有参构造Handler()"></a>1.2 有参构造Handler()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(looper, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper;</span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler类在构造方法中，可指定Looper，Callback回调方法以及消息的处理方式(同步或异步)，对于无参的handler，默认是当前线程的Looper。</p><h3 id="2-使用-Handler发送消息Handler-sendMessage-、Handler-post-Ruunable-r"><a href="#2-使用-Handler发送消息Handler-sendMessage-、Handler-post-Ruunable-r" class="headerlink" title="(2) 使用 Handler发送消息Handler.sendMessage()、Handler.post(Ruunable r)"></a>(2) 使用 Handler发送消息Handler.sendMessage()、Handler.post(Ruunable r)</h3><p>第一种方式：sendMessage(Message msg)</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/03-android-handler-looper-message-java-sendmessage.png" alt="Markdown"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从这里开始</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendEmptyMessageDelayed(what, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下追踪</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下追踪</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往下追踪</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//直接获取MessageQueue</span></span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用sendMessage方法其实最后是调用了enqueueMessage方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为msg.target赋值为this，也就是把当前的handler作为msg的target属性</span></span><br><span class="line">    <span class="comment">//如果大家还记得Looper的loop()方法会取出每个msg然后执行msg.target.dispatchMessage(msg)去处理消息，其实就是派发给相应的Handler</span></span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最终调用queue的enqueueMessage的方法，也就是说handler发出的消息，最终会保存到消息队列中去</span></span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enqueueMessage()方法中将msg.target赋值为this，也就是把当前的handler作为msg的target属性 //如果大家还记得Looper的loop()方法会取出每个msg然后执行msg.target.dispatchMessage(msg)去处理消息，其实就是派发给相应的Handler</p><h3 id="2-1-MessageQueue-enqueueMessage-添加一条消息到消息队列"><a href="#2-1-MessageQueue-enqueueMessage-添加一条消息到消息队列" class="headerlink" title="2.1 MessageQueue.enqueueMessage() 添加一条消息到消息队列"></a>2.1 MessageQueue.enqueueMessage() 添加一条消息到消息队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每一个普通Message必须有一个target</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;  <span class="comment">//正在退出时，回收msg，加入到消息池</span></span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">//p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">//当阻塞时需要唤醒</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非</span></span><br><span class="line">            <span class="comment">//消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息没有退出，我们认为此时mPtr != 0</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><p>第二种方式：post(Ruunable r)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实post()方法最终也会保存到消息队列中去，和上面不同的是它传进来的一个Runnable对象，执行了getPostMessage()方法，我们往下追踪</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实质上就是将这个Runnable保存在Message的变量中，这就导致了我们下面处理消息的时候有两种不同方案</p><blockquote><p><strong>Handler发送消息总结：</strong></p><p><strong>1、Handler对象在创建时会保存当前线程的looper和MessageQueue，如果传入Callback的话也会保存起来。</strong><br><strong>2、用户调用handler对象的sendMessage方法，传入msg对象。handler通过调用MessageQueue的enqueueMessage方法将消息压入MessageQueue。</strong><br><strong>3、enqueueMessage方法会将传入的消息对象根据触发时间（when）插入到message queue中。然后判断是否要唤醒等待中的队列。</strong><br><strong>a. 如果插在队列中间。说明该消息不需要马上处理，不需要由这个消息来唤醒队列。</strong><br><strong>b. 如果插在队列头部（或者when=0），则表明要马上处理这个消息。如果当前队列正在堵塞，则需要唤醒它进行处理。</strong><br><strong>4、如果需要唤醒队列，则通过nativeWake方法，往前面提到的管道中写入一个”W”字符，令nativePollOnce方法返回。</strong></p></blockquote><h3 id="4-Handler处理消息"><a href="#4-Handler处理消息" class="headerlink" title="(4) Handler处理消息"></a>(4) Handler处理消息</h3><p>在Looper.loop()中，当发现有消息时，调用消息的目标handler，执行dispatchMessage()方法来分发消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1\. post()方法的处理方法</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2\. sendMessage()方法的处理方法</span></span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1\. post()方法的最终处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2\. sendMessage()方法的最终处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>处理消息总结：</strong></p><p><strong>Looper对象的loop方法里面的queue.next方法如果返回了message，那么handler的dispatchMessage会被调用。</strong><br><strong>a. 如果新建Handler的时候传入了callback实例，那么callback的handleMessage方法会被调用。</strong><br><strong>b.如果是通过post方法向handler传入runnable对象的，那么runnable对象的run方法会被调用。</strong><br><strong>c.其他情况下，handler方法的handleMessage会被调用。</strong></p></blockquote><h3 id="五-总结"><a href="#五-总结" class="headerlink" title="(五)总结"></a>(五)总结</h3><p><strong>（1）简洁总结图示：</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/05-android-handler-looper-message-java.jpg" alt="Markdown"></p><p>图解：</p><p>● Handler通过sendMessage()发送Message到MessageQueue队列；<br>● Looper通过loop()，不断提取出达到触发条件的Message，并将Message交给target来处理；<br>● 经过dispatchMessage()后，交回给Handler的handleMessage()来进行相应地处理。<br>● 将Message加入MessageQueue时，处往管道写入字符，可以会唤醒loop线程；如果MessageQueue中没有Message，并处于Idle状态，则会执行IdelHandler接口中的方法，往往用于做一些清理性地工作。</p><p>消息分发的优先级：</p><p>1、Message的回调方法：message.callback.run()，优先级最高； 2、Handler的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1； 3、Handler的默认方法：Handler.handleMessage(msg)，优先级最低。</p><p><strong>详细总结图示：</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/06-android-handler-looper-message-detail.jpg" alt="Markdown"></p><p>● Looper调用prepare()进行初始化，创建了一个与当前线程对应的Looper对象（通过ThreadLocal实现），并且初始化了一个与当前Looper对应的MessageQueue对象。</p><p>● Looper调用静态方法loop()开始消息循环，通过MessageQueue.next()方法获取Message对象。</p><p>● 当获取到一个Message对象时，让Message的发送者（target）去处理它。</p><p>● Message对象包括数据，发送者（Handler），可执行代码段（Runnable）三个部分组成。</p><p>● Handler可以在一个已经Looper.prepare()的线程中初始化，如果线程没有初始化Looper，创建Handler对象会失败</p><p>● 一个线程的执行流中可以构造多个Handler对象，它们都往同一个MessageQueue中发消息，消息也只会分发给对应的Handler处理。</p><p>● Handler将消息发送到MessageQueue中，Message的target域会引用自己的发送者，Looper从MessageQueue中取出来后，再交给发送这个Message的Handler去处理。</p><p>● Message可以直接添加一个Runnable对象，当这条消息被处理的时候，直接执行Runnable.run()方法。</p><hr><h2 id="Ⅱ、Android消息机制-Native层"><a href="#Ⅱ、Android消息机制-Native层" class="headerlink" title="Ⅱ、Android消息机制(Native层)"></a>Ⅱ、Android消息机制(Native层)</h2><p>在前面讲解了Java层的消息处理机制，其中MessageQueue类里面涉及到多个native方法，除了MessageQueue的native方法，native层本身也有一套完整的消息机制，用于处理native的消息。在整个消息机制中，而MessageQueue是连接Java层和Native层的纽带，换言之，Java层可以向MessageQueue消息队列中添加消息，Native层也可以向MessageQueue消息队列中添加消息。</p><p>Native层类的关系图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/07-android-handler-looper-message-native-message.png" alt="Markdown"></p><h3 id="一-MessageQueue-初始化（Native-层）"><a href="#一-MessageQueue-初始化（Native-层）" class="headerlink" title="(一) MessageQueue 初始化（Native 层）"></a>(一) MessageQueue 初始化（Native 层）</h3><p>接着从Java层MessageQueue初始化开始分析：</p><h3 id="Step-1：MessageQueue"><a href="#Step-1：MessageQueue" class="headerlink" title="Step 1：MessageQueue()"></a>Step 1：MessageQueue()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    <span class="comment">//通过native方法初始化消息队列，其中mPtr是供native代码使用</span></span><br><span class="line">    mPtr = nativeInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/08-android-handler-looper-message-native_init.png" alt="Markdown"></p><h3 id="Step-2：android-os-MessageQueue-nativeInit"><a href="#Step-2：android-os-MessageQueue-nativeInit" class="headerlink" title="Step 2：android_os_MessageQueue_nativeInit()"></a>Step 2：android_os_MessageQueue_nativeInit()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">==&gt; android_os_MessageQueue.cpp</span><br><span class="line"><span class="keyword">static</span> jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue(); <span class="comment">//初始化native消息队列 【3】</span></span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在nativeInit中，new了一个Native层的MessageQueue的对象</p><h3 id="Step-3：NativeMessageQueue"><a href="#Step-3：NativeMessageQueue" class="headerlink" title="Step 3：NativeMessageQueue()"></a>Step 3：NativeMessageQueue()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==&gt; android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line">NativeMessageQueue::NativeMessageQueue() : mPollEnv(<span class="literal">NULL</span>), mPollObj(<span class="literal">NULL</span>), mExceptionObj(<span class="literal">NULL</span>) &#123;</span><br><span class="line">    mLooper = Looper::getForThread(); <span class="comment">//获取TLS中的Looper对象</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>); <span class="comment">//创建native层的Looper</span></span><br><span class="line">        Looper::setForThread(mLooper); <span class="comment">//保存native层的Looper到TLS中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在NativeMessageQueue的构造函数中获得了一个Native层的Looper对象，Native层的Looper也使用了线程本地存储，注意new Looper时传入了参数false。</p><p>Looper::getForThread()，功能类比于Java层的Looper.myLooper(); Looper::setForThread(mLooper)，功能类比于Java层的ThreadLocal.set();</p><p>MessageQueue是在Java层与Native层有着紧密的联系，但是此次Native层的Looper与Java层的Looper没有任何的关系，可以发现native基本等价于用C++重写了Java的Looper逻辑，故可以发现很多功能类似的地方。</p><h3 id="二-Looper初始化（Native层）"><a href="#二-Looper初始化（Native层）" class="headerlink" title="(二) Looper初始化（Native层）"></a>(二) Looper初始化（Native层）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Looper::Looper(<span class="keyword">bool</span> allowNonCallbacks) :</span><br><span class="line">        mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(<span class="literal">false</span>),</span><br><span class="line">        mPolling(<span class="literal">false</span>), mEpollFd(<span class="number">-1</span>), mEpollRebuildRequired(<span class="literal">false</span>),</span><br><span class="line">        mNextRequestSeq(<span class="number">0</span>), mResponseIndex(<span class="number">0</span>), mNextMessageUptime(LLONG_MAX) &#123;</span><br><span class="line">    mWakeEventFd = eventfd(<span class="number">0</span>, EFD_NONBLOCK); <span class="comment">//构造唤醒事件的fd</span></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line">    rebuildEpollLocked();  <span class="comment">//重建Epoll事件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::rebuildEpollLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mEpollFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(mEpollFd); <span class="comment">//关闭旧的epoll实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEpollFd = epoll_create(EPOLL_SIZE_HINT); <span class="comment">//创建新的epoll实例，并注册wake管道</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp; eventItem, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event)); <span class="comment">//把未使用的数据区域进行置0操作</span></span><br><span class="line">    eventItem.events = EPOLLIN; <span class="comment">//可读事件</span></span><br><span class="line">    eventItem.data.fd = mWakeEventFd;</span><br><span class="line">    <span class="comment">//将唤醒事件(mWakeEventFd)添加到epoll实例(mEpollFd)</span></span><br><span class="line">    <span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mRequests.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> Request&amp; request = mRequests.valueAt(i);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">        request.initEventItem(&amp;eventItem);</span><br><span class="line">        <span class="comment">//将request队列的事件，分别添加到epoll实例</span></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d"</span>, request.fd, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过eventfd创建mWakeEventFd用于线程间通信去唤醒Looper的，当需要唤醒Looper时，就往里面写1 创建用于监听epoll_event的mEpollFd，并初始化mEpollFd要监听的epoll_event类型 通过epoll_ctl将mWakeEventFd注册到mEpollFd中，当mWakeEventFd有事件可读则唤醒Looper 如果mRequests不为空的话，说明前面注册了有要监听的fd，则遍历mRequests中的Request，将它初始化为epoll_event并通过epoll_ctl注册到mEpollFd中，当有可读事件同样唤醒Looper</p><h3 id="三-nativePollOnce"><a href="#三-nativePollOnce" class="headerlink" title="(三) nativePollOnce()"></a>(三) nativePollOnce()</h3><p>我们从前面分析知道，Looper.loop()方法被调用后，会启动一个无限循环，而在这个循环中，调用了MessageQueue的next()方法以获取下一条消息，而next()方法中会首先调用nativePollOnce()方法，这个方法的作用在之前说过是阻塞，达到超时时间或有新的消息到达时得到eventFd的通知再唤醒消息队列，其实这个方法也是native消息处理的开始。</p><p>nativePollOnce用于提取消息队列中的消息，提取消息的调用链，如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/09-android-handler-looper-message-poll_once.png" alt="Markdown"></p><p>下面来进一步来看看调用链的过程：</p><h3 id="Step-1：MessageQueue-next"><a href="#Step-1：MessageQueue-next" class="headerlink" title="Step 1：MessageQueue.next()"></a>Step 1：MessageQueue.next()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">==&gt; MessageQueue.java</span><br><span class="line"></span><br><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis); <span class="comment">//阻塞操作</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2：android-os-MessageQueue-nativePollOnce"><a href="#Step-2：android-os-MessageQueue-nativePollOnce" class="headerlink" title="Step 2：android_os_MessageQueue_nativePollOnce()"></a>Step 2：android_os_MessageQueue_nativePollOnce()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">==&gt; android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123;</span><br><span class="line">    <span class="comment">//将Java层传递下来的mPtr转换为nativeMessageQueue</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3：NativeMessageQueue-pollOnce"><a href="#Step-3：NativeMessageQueue-pollOnce" class="headerlink" title="Step 3：NativeMessageQueue::pollOnce()"></a>Step 3：NativeMessageQueue::pollOnce()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">==&gt; android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-4：Looper-pollOnce"><a href="#Step-4：Looper-pollOnce" class="headerlink" title="Step 4：Looper::pollOnce()"></a>Step 4：Looper::pollOnce()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Looper::pollOnce(<span class="keyword">int</span> timeoutMillis, <span class="keyword">int</span>* outFd, <span class="keyword">int</span>* outEvents, <span class="keyword">void</span>** outData) &#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 先处理没有Callback方法的 Response事件</span></span><br><span class="line">        <span class="keyword">while</span> (mResponseIndex &lt; mResponses.size()) &#123;</span><br><span class="line">            <span class="keyword">const</span> Response&amp; response = mResponses.itemAt(mResponseIndex++);</span><br><span class="line">            <span class="keyword">int</span> ident = response.request.ident;</span><br><span class="line">            <span class="keyword">if</span> (ident &gt;= <span class="number">0</span>) &#123; <span class="comment">//ident大于0，则表示没有callback, 因为POLL_CALLBACK = -2,</span></span><br><span class="line">                <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">                <span class="keyword">int</span> events = response.events;</span><br><span class="line">                <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">                <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = fd;</span><br><span class="line">                <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = events;</span><br><span class="line">                <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = data;</span><br><span class="line">                <span class="keyword">return</span> ident;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (outFd != <span class="literal">NULL</span>) *outFd = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outEvents != <span class="literal">NULL</span>) *outEvents = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (outData != <span class="literal">NULL</span>) *outData = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再处理内部轮询</span></span><br><span class="line">        result = pollInner(timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-5-：Looper-pollInner-："><a href="#Step-5-：Looper-pollInner-：" class="headerlink" title="Step 5 ：Looper::pollInner()："></a>Step 5 ：Looper::pollInner()：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Looper.cpp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::awoken() &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> counter;</span><br><span class="line">    <span class="comment">//不断读取管道数据，目的就是为了清空管道内容</span></span><br><span class="line">    TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">    mResponses.clear();</span><br><span class="line">    mResponseIndex = <span class="number">0</span>;</span><br><span class="line">    mPolling = <span class="literal">true</span>; <span class="comment">//即将处于idle状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span> <span class="comment">//fd最大个数为16</span></span><br><span class="line">    <span class="comment">//等待事件发生或者超时，在nativeWake()方法，向管道写端写入字符，则该方法会返回；</span></span><br><span class="line">    <span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line"></span><br><span class="line">    mPolling = <span class="literal">false</span>; <span class="comment">//不再处于idle状态</span></span><br><span class="line">    mLock.lock();  <span class="comment">//请求锁</span></span><br><span class="line">    <span class="keyword">if</span> (mEpollRebuildRequired) &#123;</span><br><span class="line">        mEpollRebuildRequired = <span class="literal">false</span>;</span><br><span class="line">        rebuildEpollLocked();  <span class="comment">// epoll重建，直接跳转Done;</span></span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eventCount &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">        result = POLL_ERROR; <span class="comment">// epoll事件个数小于0，发生错误，直接跳转Done;</span></span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (eventCount == <span class="number">0</span>) &#123;  <span class="comment">//epoll事件个数等于0，发生超时，直接跳转Done;</span></span><br><span class="line">        result = POLL_TIMEOUT;</span><br><span class="line">        <span class="keyword">goto</span> Done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环遍历，处理所有的事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">        <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">        <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">                awoken(); <span class="comment">//已经唤醒了，则读取并清空管道数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">            <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">                <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">                <span class="comment">//处理request，生成对应的reponse对象，push到响应数组</span></span><br><span class="line">                pushResponse(events, mRequests.valueAt(requestIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">Done: ;</span><br><span class="line">    <span class="comment">//再处理Native的Message，调用相应回调方法</span></span><br><span class="line">    mNextMessageUptime = LLONG_MAX;</span><br><span class="line">    <span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">        <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">                Message message = messageEnvelope.message;</span><br><span class="line">                mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">                mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">                mLock.unlock();  <span class="comment">//释放锁</span></span><br><span class="line">                handler-&gt;handleMessage(message);  <span class="comment">// 处理消息事件</span></span><br><span class="line">            &#125;</span><br><span class="line">            mLock.lock();  <span class="comment">//请求锁</span></span><br><span class="line">            mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">            result = POLL_CALLBACK; <span class="comment">// 发生回调</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mLock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理带有Callback()方法的Response事件，执行Reponse相应的回调方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">        Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">            <span class="keyword">int</span> events = response.events;</span><br><span class="line">            <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">            <span class="comment">// 处理请求的回调方法</span></span><br><span class="line">            <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">            <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">                removeFd(fd, response.request.seq); <span class="comment">//移除fd</span></span><br><span class="line">            &#125;</span><br><span class="line">            response.request.callback.clear(); <span class="comment">//清除reponse引用的回调方法</span></span><br><span class="line">            result = POLL_CALLBACK;  <span class="comment">// 发生回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pollInner()方法比较长也是native消息机制的核心，我们拆成几个部分看。</p><h3 id="5-1-Request-与-Response"><a href="#5-1-Request-与-Response" class="headerlink" title="5.1 Request 与 Response"></a>5.1 Request 与 Response</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = POLL_WAKE;</span><br><span class="line">mResponses.clear();</span><br><span class="line">mResponseIndex = <span class="number">0</span>;</span><br><span class="line">mPolling = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItems</span>[<span class="title">EPOLL_MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span> eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);<span class="comment">// 第7行</span></span><br><span class="line">mPolling = <span class="literal">false</span>;</span><br><span class="line">mLock.lock();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;<span class="comment">//第11行</span></span><br><span class="line">    <span class="keyword">int</span> fd = eventItems[i].data.fd;</span><br><span class="line">    <span class="keyword">uint32_t</span> epollEvents = eventItems[i].events;</span><br><span class="line">    <span class="keyword">if</span> (fd == mWakeEventFd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) &#123;</span><br><span class="line">            awoken();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on wake event fd."</span>, epollEvents);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> events = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR;</span><br><span class="line">            <span class="keyword">if</span> (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP;</span><br><span class="line">            pushResponse(events, mRequests.valueAt(requestIndex));<span class="comment">// 第28行</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGW(<span class="string">"Ignoring unexpected epoll events 0x%x on fd %d that is "</span></span><br><span class="line">                    <span class="string">"no longer registered."</span>, epollEvents, fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第7行系统调用epoll_wait()返回时，说明因注册的fd有消息或达到超时，在第11行就对收到的唤醒events进行遍历，首先判断有消息的fd是不是用于唤醒的mWakeEventFd，如果不是的话，说明是系统调用addFd()方法设置的自定义fd（后面会讲）。那么我们需要对这个事件作出响应。</p><p>第21到28行就对这个event做处理，首先，我们以这个fd为key从mRequests中找到他的索引，这个mRequests是我们在addFd()方法一并注册的以fd为key，Request为value的映射表。找到request之后，28行调用pushResponse()方法去建立response：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::pushResponse(<span class="keyword">int</span> events, <span class="keyword">const</span> Request&amp; request) &#123;</span><br><span class="line">    Response response;</span><br><span class="line">    response.events = events;</span><br><span class="line">    response.request = request;</span><br><span class="line">    mResponses.push(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们要处理的任务已经被封装成了一个Response对象，等待被处理，那么真正的处理在哪里呢？</p><p>在上面的代码与处理response的代码中间夹着的是处理MessageEnvelope的代码，我们后面再讲这段，现在到处理response的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mResponses.size(); i++) &#123;</span><br><span class="line">    Response&amp; response = mResponses.editItemAt(i);</span><br><span class="line">    <span class="keyword">if</span> (response.request.ident == POLL_CALLBACK) &#123;</span><br><span class="line">        <span class="keyword">int</span> fd = response.request.fd;</span><br><span class="line">        <span class="keyword">int</span> events = response.events;</span><br><span class="line">        <span class="keyword">void</span>* data = response.request.data;</span><br><span class="line">        <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">        <span class="keyword">if</span> (callbackResult == <span class="number">0</span>) &#123;</span><br><span class="line">            removeFd(fd, response.request.seq);</span><br><span class="line">        &#125;</span><br><span class="line">        response.request.callback.clear();</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历所有response对象，取出之前注册的request对象的信息，然后调用了request.callback-&gt;handleEvent()方法进行回调，如果该回调返回0，则调用removeFd()方法取消这个fd的注册。</p><blockquote><p><strong>再梳理一遍这个过程：注册的自定义fd被消息唤醒，从mRequests中以fd为key找到对应的注册好的request对象然后生成response对象，在MessageEnvelop处理完毕之后处理response，调用request中的callback的handleEvent()方法。</strong></p></blockquote><p>那么addFd()注册自定义fd与removeFd()取消注册是如何实现的呢？</p><h3 id="5-2-addFd"><a href="#5-2-addFd" class="headerlink" title="5.2 addFd()"></a>5.2 addFd()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::addFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> ident, <span class="keyword">int</span> events, <span class="keyword">const</span> sp&lt;LooperCallback&gt;&amp; callback, <span class="keyword">void</span>* data) &#123;</span><br><span class="line">...</span><br><span class="line">&#123; <span class="comment">// acquire lock</span></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    Request request;<span class="comment">//第6-13行</span></span><br><span class="line">    request.fd = fd;</span><br><span class="line">    request.ident = ident;</span><br><span class="line">    request.events = events;</span><br><span class="line">    request.seq = mNextRequestSeq++;</span><br><span class="line">    request.callback = callback;</span><br><span class="line">    request.data = data; <span class="comment">// 第6-13行 end</span></span><br><span class="line">    <span class="keyword">if</span> (mNextRequestSeq == <span class="number">-1</span>) mNextRequestSeq = <span class="number">0</span>; <span class="comment">// reserve sequence number -1</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">eventItem</span>;</span></span><br><span class="line">    request.initEventItem(&amp;eventItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">    <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123; <span class="comment">// 第19行</span></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); <span class="comment">//第20行</span></span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error adding epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRequests.add(fd, request); <span class="comment">//第25行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); <span class="comment">// 第27行</span></span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ENOENT) &#123;</span><br><span class="line">                epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem);</span><br><span class="line">                <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ALOGE(<span class="string">"Error modifying or adding epoll events for fd %d: %s"</span>,</span><br><span class="line">                            fd, strerror(errno));</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                scheduleEpollRebuildLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error modifying epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mRequests.replaceValueAt(requestIndex, request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// release lock</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第6-13行使用传入的参数初始化了request对象，然后16行由request来初始化注册epoll使用的event。19行根据mRequests.indexOfKey()方法取出的值来判断fd是否已经注册，如果未注册，则在20行进行系统调用epoll_ctl()注册新监听并在25行将fd与request存入mRequest，如果已注册，则在27行更新注册并在42行更新request。</p><p>这就是自定义fd设置的过程：保存request并使用epoll_ctl系统调用注册fd的监听。</p><h3 id="5-3-removeFd"><a href="#5-3-removeFd" class="headerlink" title="5.3 removeFd()"></a>5.3 removeFd()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Looper::removeFd(<span class="keyword">int</span> fd, <span class="keyword">int</span> seq) &#123;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="keyword">ssize_t</span> requestIndex = mRequests.indexOfKey(fd);</span><br><span class="line">        <span class="keyword">if</span> (requestIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (seq != <span class="number">-1</span> &amp;&amp; mRequests.valueAt(requestIndex).seq != seq) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRequests.removeItemsAt(requestIndex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_DEL, fd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (epollResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seq != <span class="number">-1</span> &amp;&amp; (errno == EBADF || errno == ENOENT)) &#123;</span><br><span class="line">                scheduleEpollRebuildLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error removing epoll events for fd %d: %s"</span>, fd, strerror(errno));</span><br><span class="line">                scheduleEpollRebuildLocked();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解除的过程相反，在第11行删除mRequests中的键值对，然后在第13行系统调用epoll_ctl()解除fd的epoll注册。</p><h3 id="MessageEnvelope消息处理"><a href="#MessageEnvelope消息处理" class="headerlink" title="MessageEnvelope消息处理"></a>MessageEnvelope消息处理</h3><p>之前说到，在request生成response到response的处理中间有一段代码执行了MessageEnvelop消息的处理，这个顺序保证了MessageEnvelop优先于fd引起的request的处理。</p><p>现在我们来看这段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mNextMessageUptime = LLONG_MAX;</span><br><span class="line"><span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>); <span class="comment">// 第4行</span></span><br><span class="line">    <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;</span><br><span class="line">        &#123; <span class="comment">// obtain handler</span></span><br><span class="line">            sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;</span><br><span class="line">            Message message = messageEnvelope.message;</span><br><span class="line">            mMessageEnvelopes.removeAt(<span class="number">0</span>);</span><br><span class="line">            mSendingMessage = <span class="literal">true</span>;</span><br><span class="line">            mLock.unlock();</span><br><span class="line">            handler-&gt;handleMessage(message);</span><br><span class="line">        &#125; <span class="comment">// release handler</span></span><br><span class="line"></span><br><span class="line">        mLock.lock();</span><br><span class="line">        mSendingMessage = <span class="literal">false</span>;</span><br><span class="line">        result = POLL_CALLBACK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNextMessageUptime = messageEnvelope.uptime;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到mMessageEnvelopes容器中存储了所有的消息，第4行从首位置取出一条消息，随后进行时间判断，如果时间到达，先移出容器，与java层比较相似都是调用了handler的handleMessage()来进行消息的处理。</p><p>那么MessageEnvelope是如何添加的呢？</p><p>Native Looper提供了一套与java层MessageQueue类似的方法，用于添加MessageEnvelope：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageAtTime(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span><br><span class="line">        <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">// acquire lock</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.size();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// release lock</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结: 现在我们看到，其实Native中的消息机制有两个方面，一方面是通过addFd()注册的自定义fd触发消息处理，通过mRequests保存的request对象中的callback进行消息处理。另一方面是通过与java层类似的MessageEnvelop消息对象进行处理，调用的是该对象handler域的handleMessage()方法，与java层非常类似。优先级是先处理MessageEnvelop再处理request。</p><p>一些思考 现在消息机制全部内容分析下来，我们可以看到android的消息机制不算复杂，分为native与java两个部分，这两个部分分别有自己的消息处理机制，其中关键的超时与唤醒部分是借助了linux系统epoll机制来实现的。</p><p>连接java与native层消息处理过程的是next()方法中的nativePollOnce()，java层消息循环先调用它，自身阻塞，进入native的消息处理，在native消息处理完毕后返回，再进行java层的消息处理，正是因为如此，如果我们在处理java层消息的时候执行了耗时或阻塞的任务（甚至阻塞了整个主线程），整个java层的消息循环就会阻塞，也无法进一步进入native层的消息处理，也就无法响应例如触摸事件这样的消息，导致ANR的发生。这也就是我们不应在主线程中执行这类任务的原因。</p><h3 id="四-唤醒-nativeWake"><a href="#四-唤醒-nativeWake" class="headerlink" title="(四) 唤醒 nativeWake()"></a>(四) 唤醒 nativeWake()</h3><p>在添加消息到消息队列enqueueMessage(), 或者把消息从消息队列中全部移除quit()，再有需要时都会调用 nativeWake方法。包含唤醒过程的添加消息的调用链，nativeWake用于唤醒功能，如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/10-android-handler-looper-message-native_wake.png" alt="Markdown"></p><p>下面来进一步来看看调用链的过程：</p><h3 id="Step-1-：MessageQueue-enqueueMessage"><a href="#Step-1-：MessageQueue-enqueueMessage" class="headerlink" title="Step 1 ：MessageQueue.enqueueMessage()"></a>Step 1 ：MessageQueue.enqueueMessage()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">==&gt; MessageQueue.java</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    ... <span class="comment">//将Message按时间顺序插入MessageQueue</span></span><br><span class="line">    <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>往消息队列添加Message时，需要根据mBlocked情况来决定是否需要调用nativeWake。</p><h3 id="Step-2-：android-os-MessageQueue-nativeWake"><a href="#Step-2-：android-os-MessageQueue-nativeWake" class="headerlink" title="Step 2 ：android_os_MessageQueue_nativeWake()"></a>Step 2 ：android_os_MessageQueue_nativeWake()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==&gt; android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-3-：NativeMessageQueue-wake"><a href="#Step-3-：NativeMessageQueue-wake" class="headerlink" title="Step 3 ：NativeMessageQueue::wake()"></a>Step 3 ：NativeMessageQueue::wake()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt; android_os_MessageQueue.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::wake() &#123;</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-4-：Looper-wake"><a href="#Step-4-：Looper-wake" class="headerlink" title="Step 4 ：Looper::wake()"></a>Step 4 ：Looper::wake()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">==&gt; Looper.cpp</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Looper::wake() &#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> inc = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 向管道mWakeEventFd写入字符1</span></span><br><span class="line">    <span class="keyword">ssize_t</span> nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)));</span><br><span class="line">    <span class="keyword">if</span> (nWrite != <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Could not write wake signal, errno=%d"</span>, errno);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">其中TEMP_FAILURE_RETRY 是一个宏定义， 当执行write失败后，会不断重复执行，直到执行成功为止。</span><br></pre></td></tr></table></figure><h3 id="五-发送消息sendMessage（Native层）"><a href="#五-发送消息sendMessage（Native层）" class="headerlink" title="(五) 发送消息sendMessage（Native层）"></a>(五) 发送消息sendMessage（Native层）</h3><p>在前面Android消息机制(Java层)文中，讲述了Java层如何向MessageQueue类中添加消息，那么接下来讲讲Native层如何向MessageQueue发送消息。</p><h3 id="Step-1-：sendMessage"><a href="#Step-1-：sendMessage" class="headerlink" title="Step 1 ：sendMessage()"></a>Step 1 ：sendMessage()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessage(<span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler, <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    sendMessageAtTime(now, handler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Step-2-：sendMessageDelayed"><a href="#Step-2-：sendMessageDelayed" class="headerlink" title="Step 2 ：sendMessageDelayed()"></a>Step 2 ：sendMessageDelayed()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageDelayed(<span class="keyword">nsecs_t</span> uptimeDelay, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span><br><span class="line">        <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);</span><br><span class="line">    sendMessageAtTime(now + uptimeDelay, handler, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendMessage(),sendMessageDelayed() 都是调用sendMessageAtTime()来完成消息插入。</p><h3 id="Step-3-：sendMessageAtTime"><a href="#Step-3-：sendMessageAtTime" class="headerlink" title="Step 3 ：sendMessageAtTime()"></a>Step 3 ：sendMessageAtTime()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageAtTime(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,</span><br><span class="line">        <span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123; <span class="comment">//请求锁</span></span><br><span class="line">        AutoMutex _l(mLock);</span><br><span class="line">        <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.size();</span><br><span class="line">        <span class="comment">//找到message应该插入的位置i</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;</span><br><span class="line">        mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果当前正在发送消息，那么不再调用wake()，直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (mSendingMessage) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">//释放锁</span></span><br><span class="line">    <span class="comment">//当把消息加入到消息队列的头部时，需要唤醒poll循环。</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六-处理消息MessageHandler-handleMessage-amp-amp-LooperCallback-handleEvent-（Native层）"><a href="#六-处理消息MessageHandler-handleMessage-amp-amp-LooperCallback-handleEvent-（Native层）" class="headerlink" title="(六) 处理消息MessageHandler.handleMessage() &amp;&amp; LooperCallback.handleEvent()（Native层）"></a>(六) 处理消息MessageHandler.handleMessage() &amp;&amp; LooperCallback.handleEvent()（Native层）</h3><p>其实Native中的消息机制有两个方面，一方面是通过addFd()注册的自定义fd触发消息处理，通过mRequests保存的request对象中的callback进行消息处理。即调用LooperCallback的handleEvent()处理</p><p>另一方面是通过与java层类似的MessageEnvelop消息对象进行处理，调用的是该对象handler域的handleMessage()方法，与java层非常类似。优先级是先处理MessageEnvelop再处理request。即调用MessageHandler类的handleMessage()处理</p><p>6.1 MessageHandler类：调用MessageHandler类的handleMessage()处理消息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~MessageHandler() &#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="keyword">const</span> Message&amp; message)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>6.2 LooperCallback.handleEvent)：用于处理指定的文件描述符的poll事件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LooperCallback类</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperCallback</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~LooperCallback() &#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//用于处理指定的文件描述符的poll事件</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> events, <span class="keyword">void</span>* data)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="七-Native消息机制使用实例：SurfaceFlinger-Native消息处理"><a href="#七-Native消息机制使用实例：SurfaceFlinger-Native消息处理" class="headerlink" title="(七) Native消息机制使用实例：SurfaceFlinger Native消息处理"></a>(七) Native消息机制使用实例：SurfaceFlinger Native消息处理</h3><p>在 【Android 7.1.2(Android N) Activity-Window加载显示流程】中讲到 App请求创建Surface创建过程中，SurfaceFlinger会处理Native消息，此处便是Native消息机制使用的一个具体实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> Client::createSurface(</span><br><span class="line">       <span class="keyword">const</span> String8&amp; name,</span><br><span class="line">       <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">       sp&lt;IBinder&gt;* handle,</span><br><span class="line">       sp&lt;IGraphicBufferProducer&gt;* gbp)&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * createSurface must be called from the GL thread so that it can</span></span><br><span class="line"><span class="comment">    * have access to the GL context.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">MessageCreateLayer</span> :</span> <span class="keyword">public</span> MessageBase &#123;</span><br><span class="line">       SurfaceFlinger* flinger;</span><br><span class="line">       Client* client;</span><br><span class="line">       sp&lt;IBinder&gt;* handle;</span><br><span class="line">       sp&lt;IGraphicBufferProducer&gt;* gbp;</span><br><span class="line">       <span class="keyword">status_t</span> result;</span><br><span class="line">       <span class="keyword">const</span> String8&amp; name;</span><br><span class="line">       <span class="keyword">uint32_t</span> w, h;</span><br><span class="line">       PixelFormat format;</span><br><span class="line">       <span class="keyword">uint32_t</span> flags;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       MessageCreateLayer(SurfaceFlinger* flinger,</span><br><span class="line">               <span class="keyword">const</span> String8&amp; name, Client* client,</span><br><span class="line">               <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format, <span class="keyword">uint32_t</span> flags,</span><br><span class="line">               sp&lt;IBinder&gt;* handle,</span><br><span class="line">               sp&lt;IGraphicBufferProducer&gt;* gbp)</span><br><span class="line">           : flinger(flinger), client(client),</span><br><span class="line">             handle(handle), gbp(gbp), result(NO_ERROR),</span><br><span class="line">             name(name), w(w), h(h), format(format), flags(flags) &#123;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">status_t</span> getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           result = flinger-&gt;createLayer(name, client, w, h, format, flags,</span><br><span class="line">                   handle, gbp);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   sp&lt;MessageBase&gt; msg = <span class="keyword">new</span> MessageCreateLayer(mFlinger.get(),</span><br><span class="line">           name, <span class="keyword">this</span>, w, h, format, flags, handle, gbp);</span><br><span class="line">   mFlinger-&gt;postMessageSync(msg);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>Client将应用程序创建Surface的请求转换为异步消息投递到SurfaceFlinger的消息队列中，将创建Surface的任务转交给SurfaceFlinger。 函数首先将请求创建的Surface参数封装为MessageCreateSurface对象，然后调用SurfaceFlinger的postMessageSync函数往SurfaceFlinger的消息队列中发送一个同步消息，当消息处理完后，通过调用消息msg的getResult()函数来得到创建的Surface。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::postMessageSync(<span class="keyword">const</span> sp&lt;MessageBase&gt;&amp; msg,  </span><br><span class="line">    <span class="keyword">nsecs_t</span> reltime, <span class="keyword">uint32_t</span> flags) &#123;  </span><br><span class="line"><span class="comment">//往消息队列中发送一个消息  </span></span><br><span class="line"><span class="keyword">status_t</span> res = mEventQueue.postMessage(msg, reltime);  </span><br><span class="line"><span class="comment">//消息发送成功后，当前线程等待消息处理  </span></span><br><span class="line"><span class="keyword">if</span> (res == NO_ERROR) &#123;  </span><br><span class="line">    msg-&gt;wait();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> MessageQueue::postMessage(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;MessageBase&gt;&amp; messageHandler, <span class="keyword">nsecs_t</span> relTime)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">const</span> Message dummyMessage;</span><br><span class="line"><span class="comment">//将messageHandler对象和dummyMessage消息对象发送到消息循环Looper对象中</span></span><br><span class="line"><span class="keyword">if</span> (relTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    mLooper-&gt;sendMessageDelayed(relTime, messageHandler, dummyMessage);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mLooper-&gt;sendMessage(messageHandler, dummyMessage);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于消息循环Looper对象的消息发送函数sendMessage的调用流程请看前面讲解。 这里再次贴上关于消息插入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Looper::sendMessageAtTime(<span class="keyword">nsecs_t</span> uptime, <span class="keyword">const</span> sp&lt;MessageHandler&gt;&amp; handler,  </span><br><span class="line">    <span class="keyword">const</span> Message&amp; message) &#123;  </span><br><span class="line"><span class="keyword">size_t</span> i = <span class="number">0</span>;  </span><br><span class="line">&#123; <span class="comment">// acquire lock  </span></span><br><span class="line">    AutoMutex _l(mLock);  </span><br><span class="line">    <span class="comment">//获取消息队列中保存的消息个数  </span></span><br><span class="line">    <span class="keyword">size_t</span> messageCount = mMessageEnvelopes.size();  </span><br><span class="line">    <span class="comment">//按时间排序，查找当前消息应该插入的位置  </span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123;  </span><br><span class="line">        i += <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//将Message消息及消息处理Handler封装为MessageEnvelope对象，并插入到消息队列mMessageEnvelopes中  </span></span><br><span class="line">    <span class="function">MessageEnvelope <span class="title">messageEnvelope</span><span class="params">(uptime, handler, message)</span></span>;  </span><br><span class="line">    mMessageEnvelopes.insertAt(messageEnvelope, i, <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">if</span> (mSendingMessage) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; <span class="comment">// release lock  </span></span><br><span class="line"><span class="comment">//唤醒消息循环线程以及时处理消息  </span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">0</span>) &#123;  </span><br><span class="line">    wake();  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此消息发送就完成了，由于发送的是一个同步消息，因此消息发送线程此刻进入睡眠等待状态，而消息循环线程被唤醒起来处理消息，消息处理过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所有C++层的消息都封装为MessageEnvelope类型的变量并保存到mMessageEnvelopes链表中  </span></span><br><span class="line"><span class="keyword">while</span> (mMessageEnvelopes.size() != <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="keyword">nsecs_t</span> now = systemTime(SYSTEM_TIME_MONOTONIC);  </span><br><span class="line">    <span class="keyword">const</span> MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(<span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//处理当前时刻之前的所有消息  </span></span><br><span class="line">    <span class="keyword">if</span> (messageEnvelope.uptime &lt;= now) &#123;  </span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">//取出处理该消息的Hanlder  </span></span><br><span class="line">            sp&lt;MessageHandler&gt; handler = messageEnvelope.handler;  </span><br><span class="line">            <span class="comment">//取出该消息描述符  </span></span><br><span class="line">            Message message = messageEnvelope.message;  </span><br><span class="line">            <span class="comment">//从mMessageEnvelopes链表中移除该消息  </span></span><br><span class="line">            mMessageEnvelopes.removeAt(<span class="number">0</span>);  </span><br><span class="line">            <span class="comment">//表示当前消息循环线程正在处理消息，处于唤醒状态，因此消息发送线程无需唤醒消息循环线程  </span></span><br><span class="line">            mSendingMessage = <span class="literal">true</span>;  </span><br><span class="line">            mLock.unlock();  </span><br><span class="line">            <span class="comment">//调用该消息Handler对象的handleMessage函数来处理该消息  </span></span><br><span class="line">            handler-&gt;handleMessage(message);  </span><br><span class="line">        &#125; <span class="comment">// release handler  </span></span><br><span class="line">        mLock.lock();  </span><br><span class="line">        mSendingMessage = <span class="literal">false</span>;  </span><br><span class="line">        result = ALOOPER_POLL_CALLBACK;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// The last message left at the head of the queue determines the next wakeup time.  </span></span><br><span class="line">        mNextMessageUptime = messageEnvelope.uptime;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息处理过程就是调用该消息的Handler对象的handleMessage函数来完成，由于创建Surface时，往消息队列中发送的Handler对象类型为MessageCreateSurface，因此必定会调用该类的handleMessage函数来处理Surface创建消息。但该类并未实现 handleMessage函数，同时该类继承于MessageBase，由此可见其父类MessageBase必定实现了handleMessage函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageBase::handleMessage(<span class="keyword">const</span> Message&amp;) &#123;  </span><br><span class="line">    <span class="keyword">this</span>-&gt;handler();  </span><br><span class="line">    barrier.open();  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该函数首先调用其子类的handler()函数处理消息，然后唤醒消息发送线程，表明发往消息队列中的消息已得到处理，消息发送线程可以往下执行了。由于MessageCreateSurface是MessageBase的子类，因此该类必定实现了handler()函数来处理Surface创建消息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageCreateSurface</span> :</span> <span class="keyword">public</span> MessageBase &#123;  </span><br><span class="line">    sp&lt;ISurface&gt; result;  </span><br><span class="line">    SurfaceFlinger* flinger;  </span><br><span class="line">    ISurfaceComposerClient::<span class="keyword">surface_data_t</span>* params;  </span><br><span class="line">    Client* client;  </span><br><span class="line">    <span class="keyword">const</span> String8&amp; name;  </span><br><span class="line">    DisplayID display;  </span><br><span class="line">    <span class="keyword">uint32_t</span> w, h;  </span><br><span class="line">    PixelFormat format;  </span><br><span class="line">    <span class="keyword">uint32_t</span> flags;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    MessageCreateSurface(SurfaceFlinger* flinger,  </span><br><span class="line">            ISurfaceComposerClient::<span class="keyword">surface_data_t</span>* params,  </span><br><span class="line">            <span class="keyword">const</span> String8&amp; name, Client* client,  </span><br><span class="line">            DisplayID display, <span class="keyword">uint32_t</span> w, <span class="keyword">uint32_t</span> h, PixelFormat format,  </span><br><span class="line">            <span class="keyword">uint32_t</span> flags)  </span><br><span class="line">        : flinger(flinger), params(params), client(client), name(name),  </span><br><span class="line">          display(display), w(w), h(h), format(format), flags(flags)  </span><br><span class="line">    &#123;  </span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;ISurface&gt; getResult() <span class="keyword">const</span> &#123; <span class="keyword">return</span> result; &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">handler</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        result = flinger-&gt;createSurface(params, name, client,display, w, h, format, flags);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里又调用SurfaceFlinger的createSurface函数来创建Surface。绕了一圈又回到SurfaceFlinger，为什么要这么做呢？因为在同一时刻可以有多个应用程序请求SurfaceFlinger为其创建Surface，通过消息队列可以实现请求排队，然后SurfaceFlinger依次为应用程序创建Surface。<br> <strong>图解：</strong><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/11-android-handler-looper-message-java-c.png" alt="Markdown"></p><p>红色虚线关系：Java层和Native层的MessageQueue通过JNI建立关联，彼此之间能相互调用，搞明白这个互调关系，也就搞明白了Java如何调用C++代码，C++代码又是如何调用Java代码。 蓝色虚线关系：Handler/Looper/Message这三大类Java层与Native层并没有任何的真正关联，只是分别在Java层和Native层的handler消息模型中具有相似的功能。都是彼此独立的，各自实现相应的逻辑。 WeakMessageHandler继承于MessageHandler类，NativeMessageQueue继承于MessageQueue类 另外，消息处理流程是先处理Native Message，再处理Native Request，最后处理Java Message。理解了该流程，也就明白有时上层消息很少，但响应时间却较长的真正原因。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.message/12-android-handler-looper-message-structure.png" alt="Markdown"></p><h2 id="参考文档（特别感谢）："><a href="#参考文档（特别感谢）：" class="headerlink" title="参考文档（特别感谢）："></a>参考文档（特别感谢）：</h2><p><a href="http://www.cnblogs.com/angeldevil/p/3340644.html" target="_blank" rel="noopener">Android消息处理机制(Handler、Looper、MessageQueue与Message)</a><br><a href="http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html" target="_blank" rel="noopener">android的消息处理机制（图+源码分析）—-Looper,Handler,Message</a><br><a href="http://blog.csdn.net/qq_30379689/article/details/53394061" target="_blank" rel="noopener">Android进阶—-Android消息机制之Looper、Handler、MessageQueen</a><br><a href="https://www.diycode.cc/topics/671" target="_blank" rel="noopener">Handler、Looper、Message、MessageQueue 基础流程分析图解</a><br><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Android 中线程间通信原理分析：Looper, MessageQueue, Handler</a><br><a href="http://gityuan.com/2015/12/26/handler-message-framework/" target="_blank" rel="noopener">Android消息机制1-Handler(Java层)</a><br><a href="http://gityuan.com/2015/12/27/handler-message-native/" target="_blank" rel="noopener">Android消息机制2-Handler(Native层)</a><br><a href="http://www.cheelok.com/aosp/196" target="_blank" rel="noopener">ANDROID消息机制，从JAVA层到NATIVE层剖析</a> <a href="https://segmentfault.com/a/1190000002982318" target="_blank" rel="noopener">Android应用程序消息处理机制</a><br><a href="http://www.hustmeituan.club/android-xiao-xi-ji-zhi-san-nativeceng-xiao-xi-ji-zhi.html" target="_blank" rel="noopener">Android 消息机制（三）Native层消息机制</a></p>]]></content>
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo - Hello World</title>
      <link href="/2015/07/01/hello-world/"/>
      <url>/2015/07/01/hello-world/</url>
      <content type="html"><![CDATA[<p><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody</a> <a href="https://molunerfinn.com/hexo-theme-melody-doc/#/?id=hexo-theme-melody" target="_blank" rel="noopener">hexo-theme-melody-documentation</a> <a id="more"></a></p><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h2 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h2 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h2 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h2 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo Deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
