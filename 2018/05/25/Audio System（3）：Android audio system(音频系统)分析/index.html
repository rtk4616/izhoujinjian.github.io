<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Audio System（3）：Android audio system(音频系统)分析 | ๑Charles✦ˑ̫✦Vincent๑</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑"><meta name="designer" content="minfive"><meta name="keywords" content="zhoujinjian, zhoujinjian blog, Android, 源代码, ActivityManagerService, AMS, WindowManagerService, WMS , zygote ，InputManagerService , SurfaceFlinger, SystemServer , Binder , Graphics , Kernel , Linux"><meta name="description" content="嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta name="baidu-site-verification" content="7AVr5WpX72"><link rel="canonical" href="http://zhoujinjian.cc/2018/05/25/Audio System（3）：Android audio system(音频系统)分析/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="๑Charles✦ˑ̫✦Vincent๑"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c54bda95ff8b34e8be2edd1d138812c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117331438-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-117331438-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading-small.gif)"></div><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="๑Charles✦ˑ̫✦Vincent๑" alt="๑Charles✦ˑ̫✦Vincent๑"><img src="/img/Logo.png" alt="๑Charles✦ˑ̫✦Vincent๑"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><div id="page" class="page js-hidden"><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.15.jpg" alt="Audio System（3）：Android audio system(音频系统)分析"></div><header class="post__info"><h1 class="post__title">Audio System（3）：Android audio system(音频系统)分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/izhoujinjian">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-05-25</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></header><div class="post__content"><div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一-、深入剖析Android音频之AudioFlinger"><span class="toc-text">(一)、深入剖析Android音频之AudioFlinger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-0、总体框架图"><span class="toc-text">1.0、总体框架图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1、AudioFlinger"><span class="toc-text">1.1、AudioFlinger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-AudioFlinger服务的启动和运行"><span class="toc-text">1.1.1 AudioFlinger服务的启动和运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2、音频设备的管理"><span class="toc-text">1.2、音频设备的管理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1、加载设备loadHwModule"><span class="toc-text">1.2.1、加载设备loadHwModule()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2、打开音频输出通道openOutput"><span class="toc-text">1.2.2、打开音频输出通道openOutput()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l"><span class="toc-text">1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-2、创建音频输出流openOutputStream"><span class="toc-text">1.2.2.2、创建音频输出流openOutputStream()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream"><span class="toc-text">1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-3、创建播放线程-PlaybackThread"><span class="toc-text">1.2.2.3、创建播放线程(PlaybackThread)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3、AudioFlinger-音频流管理"><span class="toc-text">1.2.3、AudioFlinger 音频流管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二-、深入剖析Android音频之AudioPolicyService"><span class="toc-text">(二)、深入剖析Android音频之AudioPolicyService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、Step-1-创建AudioCommandThread线程"><span class="toc-text">2.1、Step 1:创建AudioCommandThread线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager"><span class="toc-text">2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、创建AudioPolicyManager"><span class="toc-text">2.3、创建AudioPolicyManager()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件"><span class="toc-text">2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled"><span class="toc-text">2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3、加载audio-policy硬件抽象库loadHwModule"><span class="toc-text">2.3.3、加载audio policy硬件抽象库loadHwModule()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4、打开对应的outputStream和inputStream"><span class="toc-text">2.3.4、打开对应的outputStream和inputStream</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs"><span class="toc-text">2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4、总结"><span class="toc-text">2.4、总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三-、深入剖析Android音频之AudioTrack"><span class="toc-text">(三)、深入剖析Android音频之AudioTrack</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-AudioTrack-amp-AudioFlinger-相关类"><span class="toc-text">3.1. AudioTrack &amp; AudioFlinger 相关类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-AudioTrack-构造过程"><span class="toc-text">3.2. AudioTrack 构造过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-AudioTrack-数据写入"><span class="toc-text">3.3. AudioTrack 数据写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-AudioTrack-写数据流程"><span class="toc-text">3.3. 1. AudioTrack 写数据流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-AudioFlinger-读数据流程"><span class="toc-text">3.3. 2. AudioFlinger 读数据流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-3-环形-FIFO-管理"><span class="toc-text">3.3. 3. 环形 FIFO 管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四-、深入剖析MediaPlayer播放音频流程"><span class="toc-text">(四)、深入剖析MediaPlayer播放音频流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（五）、参考资料-特别感谢各位前辈的分析和图示-："><span class="toc-text">（五）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div><hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">【特别感谢 - 林学森的Android专栏】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Yangwen123 - 深入剖析Android音频系统】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Zyuanyun - Android 音频系统：从 AudioTrack 到 AudioFlinger】</a><br>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br><a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br><a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener">Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio 高通HAL 源码)</strong></p><p>• <strong>/libhardware/modules/audio/ – (Audio 原生HAL 源码)</strong></p><p>• <strong>/external/tinyalsa/ – (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/hardware/libhardware_legacy/audio – (Audio legacy 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><h4 id="一-、深入剖析Android音频之AudioFlinger"><a href="#一-、深入剖析Android音频之AudioFlinger" class="headerlink" title="(一)、深入剖析Android音频之AudioFlinger"></a>(一)、深入剖析Android音频之AudioFlinger</h4><h5 id="1-0、总体框架图"><a href="#1-0、总体框架图" class="headerlink" title="1.0、总体框架图"></a>1.0、总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/31-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><p>系统启动时将执行 /system/etc/init/audioserver.rc ，运行 /system/bin/ 目录下的 audioserver 服务。audioserver.rc 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\audioserver.rc]</span><br><span class="line">service audioserver /system/bin/audioserver</span><br><span class="line">    class main</span><br><span class="line">    user audioserver</span><br><span class="line">    # media gid needed for /dev/fm (radio ) and for  /data/misc/media (tee)</span><br><span class="line">    group audio radio camera drmpc inet media mediarm net_bt net_bt_admin net_bw_acct</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    writepid /dev/cpuset/forground/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure><p>audioserver 是由同目录下main_audioserver编译生成的。</p><h5 id="1-1、AudioFlinger"><a href="#1-1、AudioFlinger" class="headerlink" title="1.1、AudioFlinger"></a>1.1、AudioFlinger</h5><p>AudioFlinger是整个音频系统的核心与难点。作为Android系统中的音频中枢，它同时也是一个系统服务，启到承上(为上层提供访问接口)启下(通过HAL来管理音频设备)的作用。只有理解了AudioFlinger，才能以此为基础更好地深入到其它模块，并且Audioserver最先启动的也是AudioFlinger，因而我们把它放在前面进行分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。<br>AudioFlinger注册名为”media.audio_flinger”的服务。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_flinger"</span>; &#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="1-1-1-AudioFlinger服务的启动和运行"><a href="#1-1-1-AudioFlinger服务的启动和运行" class="headerlink" title="1.1.1 AudioFlinger服务的启动和运行"></a>1.1.1 AudioFlinger服务的启动和运行</h5><p>AudioFlinger的构造函数，发现它只是简单地为内部一些变量做了初始化，除此之外就没有任何代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::AudioFlinger()</span><br><span class="line">    : BnAudioFlinger(),</span><br><span class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</span><br><span class="line">      mHardwareStatus(AUDIO_HW_IDLE),</span><br><span class="line">      mMasterVolume(<span class="number">1.0f</span>),</span><br><span class="line">      mMasterMute(<span class="literal">false</span>),</span><br><span class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></span><br><span class="line">      mMode(AUDIO_MODE_INVALID),</span><br><span class="line">      mBtNrecIsOff(<span class="literal">false</span>),</span><br><span class="line">      mIsLowRamDevice(<span class="literal">true</span>),</span><br><span class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</span><br><span class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</span><br><span class="line">      mSystemReady(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// unsigned instead of audio_unique_id_use_t, because ++ operator is unavailable for enum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> use = AUDIO_UNIQUE_ID_USE_UNSPECIFIED; use &lt; AUDIO_UNIQUE_ID_USE_MAX; use++) &#123;</span><br><span class="line">        <span class="comment">// zero ID has a special meaning, so unavailable</span></span><br><span class="line">        mNextUniqueIds[use] = AUDIO_UNIQUE_ID_USE_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BnAudioFlinger是由RefBase层层继承而来的，并且IServiceManager::addService的第二个参数实际上是一个强指针引用(constsp<ibinder>&amp;),因而AudioFlinger具备了强指针被第一次引用时调用onFirstRef的程序逻辑。</ibinder></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> move all this work into an Init() function */</span></span><br><span class="line">    <span class="keyword">char</span> val_str[PROPERTY_VALUE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"ro.audio.flinger_standbytime_ms"</span>, val_str, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> int_val;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">sscanf</span>(val_str, <span class="string">"%u"</span>, &amp;int_val)) &#123;</span><br><span class="line">            mStandbyTimeInNsecs = milliseconds(int_val);</span><br><span class="line">            ALOGI(<span class="string">"Using %u mSec as standby time."</span>, int_val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs;</span><br><span class="line">            ALOGI(<span class="string">"Using default %u mSec as standby time."</span>,</span><br><span class="line">                    (<span class="keyword">uint32_t</span>)(mStandbyTimeInNsecs / <span class="number">1000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mMode = AUDIO_MODE_NORMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这时开始，AudioFlinger就是一个“有意义”的实体了</p><h5 id="1-2、音频设备的管理"><a href="#1-2、音频设备的管理" class="headerlink" title="1.2、音频设备的管理"></a>1.2、音频设备的管理</h5><p>虽然AudioFlinger实体已经成功创建并初始化，但到目前为止它还是一块静态的内存空间，没有涉及到具体的工作。</p><p>从职能分布上来讲，AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。</p><p>目前Audio系统中支持的音频设备接口(Audio Interface)分为三大类，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">static const char * const audio_interfaces[] = &#123;</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_PRIMARY,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_A2DP,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_USB,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种音频设备接口由一个对应的so库提供支持。那么AudioFlinger怎么会知道当前设备中支持上述的哪些接口，每种接口又支持哪些具体的音频设备呢？这是AudioPolicyService的责任之一，即根据用户配置来指导AudioFlinger加载设备接口。</p><p>当AudioPolicyManagerBase(AudioPolicyService中持有的Policy管理者，后面小节有详细介绍)构造时，它会读取厂商关于音频设备的描述文件(audio_policy.conf)，然后据此来打开以上三类音频接口(如果存在的话)。这一过程最终会调用loadHwModule@AudioFlinger，如下所示：</p><h5 id="1-2-1、加载设备loadHwModule"><a href="#1-2-1、加载设备loadHwModule" class="headerlink" title="1.2.1、加载设备loadHwModule()"></a>1.2.1、加载设备loadHwModule()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">/*name就是前面audio_interfaces 数组成员中的字符串*/</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    if (name == NULL) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!settingsAllowed()) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    return loadHwModule_l(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数没有做实质性的工作，只是执行了加锁动作，然后接着调用下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">// loadHwModule_l() must be called with AudioFlinger::mLock held</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* Step 1. 是否已经添加了这个interface ? */</span><br><span class="line">    for (size_t i = 0; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">        if (strncmp(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, strlen(name)) == 0) &#123;</span><br><span class="line">            ALOGW(&quot;loadHwModule() module %s already loaded&quot;, name);</span><br><span class="line">            return mAudioHwDevs.keyAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_hw_device_t *dev;</span><br><span class="line">    /* Step 2. 加载audio interface */</span><br><span class="line">    int rc = load_audio_interface(name, &amp;dev);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /* Step 3. 初始化 */</span><br><span class="line">    mHardwareStatus = AUDIO_HW_INIT;</span><br><span class="line">    rc = dev-&gt;init_check(dev);</span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    /* Step 4. 添加到全局变量中 */</span><br><span class="line">    audio_module_handle_t handle = (audio_module_handle_t) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</span><br><span class="line">    mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags));</span><br><span class="line"></span><br><span class="line">    return handle;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1@ loadHwModule_l. 首先查找mAudioHwDevs是否已经添加了变量name所指示的audio interface，如果是的话直接返回。第一次进入时mAudioHwDevs的size为0，所以还会继续往下执行。</p><p>Step2@ loadHwModule_l. 加载指定的audiointerface，比如“primary”、“a2dp”或者“usb”。函数load_audio_interface用来加载设备所需的库文件，然后打开设备并创建一个audio_hw_device_t实例。音频接口设备所对应的库文件名称是有一定格式的，比如a2dp的模块名可能是audio.a2dp.so或者audio.a2dp.default.so等等。查找路径主要有两个，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\hardware.c]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">"/system/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">"/vendor/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH3 <span class="meta-string">"/odm/lib64/hw"</span></span></span><br></pre></td></tr></table></figure><p>当然，因为Android是完全开源的，各开发商可以根据自己的需要来进行相应的修改，比如下面是Google pixel 设备的音频库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell &amp;&amp; cd system/lib64/hw &amp;&amp; ls -l</span><br><span class="line">-rw-r--r-- 1 root root   30440 2009-01-01 00:00 audio.a2dp.default.so</span><br><span class="line">-rw-r--r-- 1 root root   18156 2009-01-01 00:00 audio.primary.default.so</span><br><span class="line">-rw-r--r-- 1 root root  275612 2009-01-01 00:00 audio.primary.msm8996.so</span><br><span class="line">-rw-r--r-- 1 root root   34540 2009-01-01 00:00 audio.r_submix.default.so</span><br><span class="line">-rw-r--r-- 1 root root   22248 2009-01-01 00:00 audio.usb.default.so</span><br><span class="line">-rw-r--r-- 1 root root   96096 2009-01-01 00:00 audio_policy.default.so</span><br><span class="line">-rw-r--r-- 1 root root 1637208 2009-01-01 00:00 bluetooth.default.so</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>Step3@ loadHwModule_l，进行初始化操作。其中init_check是为了确定这个audio interface是否已经成功初始化，0是成功，其它值表示失败。接下来如果这个device支持主音量，我们还需要通过set_master_volume进行设置。在每次操作device前，都要先改变mHardwareStatus的状态值，操作结束后将其复原为AUDIO_HW_IDLE(根据源码中的注释，这样做是为了方便dump时正确输出内部状态，这里我们就不去深究了)。</p><p>Step4@ loadHwModule_l. 把加载后的设备添加入mAudioHwDevs键值对中，其中key的值是由nextUniqueId生成的，这样做保证了这个audiointerface拥有全局唯一的id号。</p><p>完成了audiointerface的模块加载只是万里长征的第一步。因为每一个interface包含的设备通常不止一个，Android系统目前支持的音频设备如下列表所示：<br>Android系统支持的音频设备列表(输出)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</span><br><span class="line">static uint32_t audio_device_conv_table[][HAL_API_REV_NUM] =</span><br><span class="line">&#123;</span><br><span class="line">    /* output devices */</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_EARPIECE, AUDIO_DEVICE_OUT_EARPIECE &#125;,//</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_SPEAKER, AUDIO_DEVICE_OUT_SPEAKER &#125;,//SPEAKER</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADSET, AUDIO_DEVICE_OUT_WIRED_HEADSET &#125;,//HEADSET</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADPHONE, AUDIO_DEVICE_OUT_WIRED_HEADPHONE &#125;,//HEADPHONE</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO, AUDIO_DEVICE_OUT_BLUETOOTH_SCO &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_AUX_DIGITAL, AUDIO_DEVICE_OUT_AUX_DIGITAL &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET, AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET, AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DEFAULT, AUDIO_DEVICE_OUT_DEFAULT &#125;,//默认设备</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可能会有疑问：</p><p>Ø 这么多的输出设备，那么当我们回放音频流(录音也是类似的情况)时，该选择哪一种呢？</p><p>Ø 而且当前系统中audio interface也很可能不止一个，应该如何选择？</p><p>显然这些决策工作将由AudioPolicyService来完成，我们会在下一小节做详细阐述。这里先给大家分析下，AudioFlinger是如何打开一个Output通道的(一个audiointerface可能包含若干个output)。</p><h5 id="1-2-2、打开音频输出通道openOutput"><a href="#1-2-2、打开音频输出通道openOutput" class="headerlink" title="1.2.2、打开音频输出通道openOutput()"></a>1.2.2、打开音频输出通道openOutput()</h5><p>打开音频输出通道(output)在AudioFlinger中对应的接口是openOutput()，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                  <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</span><br><span class="line">                                  <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</span><br><span class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</span><br><span class="line">        *latencyMs = thread-&gt;latency();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notify client processes of the new output creation</span></span><br><span class="line">        thread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the first primary output opened designates the primary hw device</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Using module %d has the primary audio interface"</span>, <span class="keyword">module</span>);</span><br><span class="line">            mPrimaryHardwareDev = thread-&gt;getOutput()-&gt;audioHwDev;</span><br><span class="line"></span><br><span class="line">            <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</span><br><span class="line">            mHardwareStatus = AUDIO_HW_SET_MODE;</span><br><span class="line">            mPrimaryHardwareDev-&gt;hwDevice()-&gt;set_mode(mPrimaryHardwareDev-&gt;hwDevice(), mMode);</span><br><span class="line">            mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用 openOutput_l()函数从处理。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                                            <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">                                                            <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Step 1. 查找相应的audio interface</span></span><br><span class="line"><span class="comment">    AudioHwDevice *outHwDev = findSuitableHwDev_l(module, devices);</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    AudioStreamOut *outputStream = NULL;</span></span><br><span class="line"><span class="comment">     /*Step 2. 为设备打开一个输出流*/</span></span><br><span class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    <span class="comment">/*Step 3.创建PlaybackThread*/</span></span><br><span class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面这段代码中，颜色加深的部分是我们接下来分析的重点，主要还是围绕outHwDev这个变量所做的一系列操作，即：</p><p>· 查找合适的音频接口设备( findSuitableHwDev_l() )</p><p>· 创建音频输出流( 通过openOutputStream()创建AudioStreamOut )</p><p>· 创建播放线程( PlaybackThread )</p><p>outHwDev用于记录一个打开的音频接口设备，它的数据类型是audio_hw_device_t，是由HAL规定的一个音频接口设备所应具有的属性集合，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioHwDevice</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">audio_module_handle_t</span> handle() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHandle; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">moduleName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mModuleName; &#125;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> *hwDevice() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice; &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> version() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice-&gt;common.version; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> openOutputStream(</span><br><span class="line">            AudioStreamOut **ppStreamOut,</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> handle,</span><br><span class="line">            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">            <span class="keyword">audio_output_flags_t</span> flags,</span><br><span class="line">            struct audio_config *config,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *address);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">audio_module_handle_t</span> mHandle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span>          mModuleName;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> * <span class="keyword">const</span>   mHwDevice;</span><br><span class="line">    <span class="keyword">const</span> Flags                 mFlags;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中common代表了HAL层所有设备的共有属性;set_master_volume、set_mode、open_output_stream分别为我们设置audio interface的主音量、设置音频模式类型(比如AUDIO_MODE_RINGTONE、AUDIO_MODE_IN_CALL等等)、打开输出数据流提供了接口。</p><p>接下来我们分步来阐述。</p><h5 id="1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l"><a href="#1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l" class="headerlink" title="1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()"></a>1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()</h5><p>Step1@ AudioFlinger::openOutput. 在openOutput中，设备outHwDev是通过查找当前系统来得到的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioHwDevice* AudioFlinger::findSuitableHwDev_l(</span><br><span class="line">        <span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">        <span class="keyword">audio_devices_t</span> devices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if module is 0, the request comes from an old policy manager and we should load</span></span><br><span class="line">    <span class="comment">// well known modules</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"findSuitableHwDev_l() loading well know audio hw modules"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(audio_interfaces); i++) &#123;</span><br><span class="line">            loadHwModule_l(audio_interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then try to find a module supporting the requested device.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">            AudioHwDevice *audioHwDevice = mAudioHwDevs.valueAt(i);</span><br><span class="line">            <span class="keyword">audio_hw_device_t</span> *dev = audioHwDevice-&gt;hwDevice();</span><br><span class="line">            <span class="keyword">if</span> ((dev-&gt;get_supported_devices != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (dev-&gt;get_supported_devices(dev) &amp; devices) == devices)</span><br><span class="line">                <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// check a match for the requested module handle</span></span><br><span class="line">        AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">if</span> (audioHwDevice != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量module值为0的情况，是为了兼容之前的Audio Policy而特别做的处理。当module等于0时，首先加载所有已知的音频接口设备，然后再根据devices来确定其中符合要求的。入参devices的值实际上来源于“ Android系统支持的音频设备列表(输出)”所示的设备。可以看到，enum中每个设备类型都对应一个特定的比特位，因而上述代码段中可以通过“与运算”来找到匹配的设备。</p><p>当modules为非0值时，说明Audio Policy指定了具体的设备id号，这时就通过查找全局的mAudioHwDevs变量来确认是否存在符合要求的设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.h]</span><br><span class="line">DefaultKeyedVector&lt;audio_module_handle_t, AudioHwDevice*&gt;  mAudioHwDevs;</span><br></pre></td></tr></table></figure><p>变量mAudioHwDevs是一个Vector，以audio_module_handle_t为key，每一个handle值唯一确定了已经添加的音频设备。那么在什么时候添加设备呢？</p><p>一种情况就是前面看到的modules为0时，会load所有潜在设备，另一种情况就是AudioPolicyManagerBase在构造时会预加载所有audio_policy.conf中所描述的output。不管是哪一种情况，最终都会调用loadHwModuleàloadHwModule_l，这个函数我们开头就分析过了。</p><p>如果modules为非0，且从mAudioHwDevs中也找不到符合要求的设备，程序并不会就此终结——它会退而求其次，遍历数组中的所有元素寻找支持devices的任何一个audio interface。</p><h5 id="1-2-2-2、创建音频输出流openOutputStream"><a href="#1-2-2-2、创建音频输出流openOutputStream" class="headerlink" title="1.2.2.2、创建音频输出流openOutputStream()"></a>1.2.2.2、创建音频输出流openOutputStream()</h5><p>Step2@ AudioFlinger::openOutput，调用openOutputStream()函数打开一个AudioStreamOut 。源码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.cpp]</span><br><span class="line">status_t AudioHwDevice::openOutputStream(</span><br><span class="line">        AudioStreamOut **ppStreamOut,</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        audio_output_flags_t flags,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct audio_config originalConfig = *config;</span><br><span class="line">    AudioStreamOut *outputStream = new AudioStreamOut(this, flags);</span><br><span class="line">    </span><br><span class="line">    status_t status = outputStream-&gt;open(handle, devices, config, address);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    *ppStreamOut = outputStream;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成AudioStreamOut对象并赋值给ppStreamOut ，进一步调用了AudioStreamOut-&gt;open()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioStreamOut.cpp]</span><br><span class="line">status_t AudioStreamOut::open(</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line">    audio_stream_out_t *outStream;</span><br><span class="line">    .......</span><br><span class="line">    int status = hwDev()-&gt;open_output_stream(</span><br><span class="line">            hwDev(),</span><br><span class="line">            handle,</span><br><span class="line">            devices,</span><br><span class="line">            customFlags,</span><br><span class="line">            config,</span><br><span class="line">            &amp;outStream,</span><br><span class="line">            address);</span><br><span class="line">    ......</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即会通过audio_hw_device_t-&gt;-&gt;open_output_stream()创建音频输出流</p><h5 id="1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream"><a href="#1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream" class="headerlink" title="1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()"></a>1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()</h5><p>我们先看一下HAL层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open(const hw_module_t *module, const char *name,</span><br><span class="line">                     hw_device_t **device)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    adev = calloc(1, sizeof(struct audio_device));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;adev-&gt;lock, (const pthread_mutexattr_t *) NULL);</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    adev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    adev-&gt;device.common.module = (struct hw_module_t *)module;</span><br><span class="line">    adev-&gt;device.common.close = adev_close;</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    adev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    adev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    adev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    adev-&gt;device.set_master_mute = adev_set_master_mute;</span><br><span class="line">    adev-&gt;device.get_master_mute = adev_get_master_mute;</span><br><span class="line">    adev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    adev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    adev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    adev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    adev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    adev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    adev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    adev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    adev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    adev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当调用open_output_stream 就会调用adev_open_output_stream。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open_output_stream(struct audio_hw_device *dev,</span><br><span class="line">                                   audio_io_handle_t handle,</span><br><span class="line">                                   audio_devices_t devices,</span><br><span class="line">                                   audio_output_flags_t flags,</span><br><span class="line">                                   struct audio_config *config,</span><br><span class="line">                                   struct audio_stream_out **stream_out,</span><br><span class="line">                                   const char *address __unused)</span><br><span class="line">&#123;</span><br><span class="line">    struct audio_device *adev = (struct audio_device *)dev;</span><br><span class="line">    struct stream_out *out;</span><br><span class="line">    int i, ret;</span><br><span class="line">    </span><br><span class="line">    *stream_out = NULL;</span><br><span class="line">    out = (struct stream_out *)calloc(1, sizeof(struct stream_out));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    out-&gt;stream.common.get_sample_rate = out_get_sample_rate;</span><br><span class="line">    out-&gt;stream.common.set_sample_rate = out_set_sample_rate;</span><br><span class="line">    out-&gt;stream.common.get_buffer_size = out_get_buffer_size;</span><br><span class="line">    out-&gt;stream.common.get_channels = out_get_channels;</span><br><span class="line">    out-&gt;stream.common.get_format = out_get_format;</span><br><span class="line">    out-&gt;stream.common.set_format = out_set_format;</span><br><span class="line">    out-&gt;stream.common.standby = out_standby;</span><br><span class="line">    out-&gt;stream.common.dump = out_dump;</span><br><span class="line">    out-&gt;stream.common.set_parameters = out_set_parameters;</span><br><span class="line">    out-&gt;stream.common.get_parameters = out_get_parameters;</span><br><span class="line">    out-&gt;stream.common.add_audio_effect = out_add_audio_effect;</span><br><span class="line">    out-&gt;stream.common.remove_audio_effect = out_remove_audio_effect;</span><br><span class="line">    out-&gt;stream.get_latency = out_get_latency;</span><br><span class="line">    out-&gt;stream.set_volume = out_set_volume;</span><br><span class="line">#ifdef NO_AUDIO_OUT</span><br><span class="line">    out-&gt;stream.write = out_write_for_no_output;</span><br><span class="line">#else</span><br><span class="line">    out-&gt;stream.write = out_write;</span><br><span class="line">#endif</span><br><span class="line">    out-&gt;stream.get_render_position = out_get_render_position;</span><br><span class="line">    out-&gt;stream.get_next_write_timestamp = out_get_next_write_timestamp;</span><br><span class="line">    out-&gt;stream.get_presentation_position = out_get_presentation_position;</span><br><span class="line"></span><br><span class="line">    out-&gt;af_period_multiplier  = out-&gt;realtime ? af_period_multiplier : 1;</span><br><span class="line">    out-&gt;standby = 1;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    *stream_out = &amp;out-&gt;stream;</span><br><span class="line">    ALOGV(&quot;%s: exit&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据音频流的熟悉做一系列初始化操作。转了一大圈，继续看看</p><h5 id="1-2-2-3、创建播放线程-PlaybackThread"><a href="#1-2-2-3、创建播放线程-PlaybackThread" class="headerlink" title="1.2.2.3、创建播放线程(PlaybackThread)"></a>1.2.2.3、创建播放线程(PlaybackThread)</h5><p>Step3@ AudioFlinger::openOutput. 既然通道已经打开，那么由谁来往通道里放东西呢？这就是PlaybackThread。这里分三种不同的情况：<br>· OffloadThread</p><p>· DirectOutput</p><p>如果不需要混音</p><p>· Mixer</p><p>需要混音</p><p>这三种情况分别对应DirectOutputThread、OffloadThread和MixerThread两种线程。我们以后者为例来分析下PlaybackThread的工作模式，也会后面小节打下基础。回放线程（PlaybackThread 及其派生的子类）和录制线程（RecordThread）进行的，先简单看看回放线程和录制线程类关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/32-Audio-system-mixerthread.jpg" alt="Alt text"></p><p>· ThreadBase：PlaybackThread 和 RecordThread 的基类<br>· RecordThread：录制线程类，由 ThreadBase 派生<br>· PlaybackThread：回放线程基类，同由 ThreadBase 派生<br>· MixerThread：混音回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流，MixerThread 可以把多个音轨的数据混音后再输出<br>· DirectOutputThread：直输回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_DIRECT 的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可<br>· DuplicatingThread：复制回放线程类，由 MixerThread 派生，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB 声卡设备同时输出<br>· OffloadThread：硬解回放线程类，由 DirectOutputThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流，这种音频流未经软件解码的（一般是 MP3、AAC 等格式的数据），需要输出到硬件解码器，由硬件解码器解码成 PCM 数据</p><p>PlaybackThread 中有个极为重要的函数 threadLoop()，当 PlaybackThread 被强引用时，threadLoop() 会真正运行起来进入循环主体，处理音频流数据相关事务，threadLoop() 大致流程如下（以 MixerThread 为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\Threads.cpp]</span><br><span class="line">bool AudioFlinger::PlaybackThread::threadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    while (!exitPending())</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        &#123; // scope for mLock</span><br><span class="line"></span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">            processConfigEvents_l();</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line"></span><br><span class="line">            if ((!mActiveTracks.size() &amp;&amp; systemTime() &gt; mStandbyTimeNs) ||</span><br><span class="line">                                   isSuspended()) &#123;</span><br><span class="line">                // put audio hardware into standby after short delay</span><br><span class="line">                if (shouldStandby_l()) &#123;</span><br><span class="line"></span><br><span class="line">                    threadLoop_standby();</span><br><span class="line"></span><br><span class="line">                    mStandby = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // mMixerStatusIgnoringFastTracks is also updated internally</span><br><span class="line">            mMixerStatus = prepareTracks_l(&amp;tracksToRemove);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125; // mLock scope ends</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (mBytesRemaining == 0) &#123;</span><br><span class="line">            mCurrentWriteLength = 0;</span><br><span class="line">            if (mMixerStatus == MIXER_TRACKS_READY) &#123;</span><br><span class="line">                // threadLoop_mix() sets mCurrentWriteLength</span><br><span class="line">                threadLoop_mix();</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!waitingAsyncCallback()) &#123;</span><br><span class="line">            // mSleepTimeUs == 0 means we must write to audio hardware</span><br><span class="line">            if (mSleepTimeUs == 0) &#123;</span><br><span class="line">                // ......</span><br><span class="line">                if (mBytesRemaining) &#123;</span><br><span class="line">                    // FIXME rewrite to reduce number of system calls</span><br><span class="line">                    ret = threadLoop_write();</span><br><span class="line">                    lastWriteFinished = systemTime();</span><br><span class="line">                    delta = lastWriteFinished - mLastWriteTime;</span><br><span class="line">                    if (ret &lt; 0) &#123;</span><br><span class="line">                        mBytesRemaining = 0;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBytesWritten += ret;</span><br><span class="line">                        mBytesRemaining -= ret;</span><br><span class="line">                        mFramesWritten += ret / mFrameSize;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally let go of removed track(s), without the lock held</span><br><span class="line">        // since we can&apos;t guarantee the destructors won&apos;t acquire that</span><br><span class="line">        // same lock.  This will also mutate and push a new fast mixer state.</span><br><span class="line">        threadLoop_removeTracks(tracksToRemove);</span><br><span class="line">        tracksToRemove.clear();</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadLoop_exit();</span><br><span class="line"></span><br><span class="line">    if (!mStandby) &#123;</span><br><span class="line">        threadLoop_standby();</span><br><span class="line">        mStandby = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLoop() 循环的条件是 exitPending() 返回 false，如果想要 PlaybackThread 结束循环，则可以调用 requestExit() 来请求退出；<br>processConfigEvents_l() ：处理配置事件；当有配置改变的事件发生时，需要调用 sendConfigEvent_l() 来通知 PlaybackThread，这样 PlaybackThread 才能及时处理配置事件；常见的配置事件是切换音频通路；<br>检查此时此刻是否符合 standby 条件，比如当前并没有 ACTIVE 状态的 Track（mActiveTracks.size() = 0），那么调用 threadLoop_standby() 关闭音频硬件设备以节省能耗；<br>prepareTracks_l()： 准备音频流和混音器，该函数非常复杂，这里不详细分析了，仅列一下流程要点：<br>遍历 mActiveTracks，逐个处理 mActiveTracks 上的 Track，检查该 Track 是否为 ACTIVE 状态；<br>如果 Track 设置是 ACTIVE 状态，则再检查该 Track 的数据是否准备就绪了；<br>根据音频流的音量值、格式、声道数、音轨的采样率、硬件设备的采样率，配置好混音器参数；<br>如果 Track 的状态是 PAUSED 或 STOPPED，则把该 Track 添加到 tracksToRemove 向量中；<br>threadLoop_mix()：读取所有置了 ACTIVE 状态的音频流数据，混音器开始处理这些数据；<br>threadLoop_write()： 把混音器处理后的数据写到输出流设备；<br>threadLoop_removeTracks()： 把 tracksToRemove 上的所有 Track 从 mActiveTracks 中移除出来；这样下一次循环时就不会处理这些 Track 了。<br>这里说说 PlaybackThread 与输出流设备的关系：PlaybackThread 实例与输出流设备是一一对应的，比方说 OffloadThread 只会将音频数据输出到 compress_offload 设备中，MixerThread(with FastMixer) 只会将音频数据输出到 low_latency 设备中。</p><p>从 Audio HAL 中，我们通常看到如下 4 种输出流设备，分别对应着不同的播放场景：</p><p>primary_out：主输出流设备，用于铃声类声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_PRIMARY 的音频流和一个 MixerThread 回放线程实例<br>low_latency：低延迟输出流设备，用于按键音、游戏背景音等对时延要求高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_FAST 的音频流和一个 MixerThread 回放线程实例<br>deep_buffer：音乐音轨输出流设备，用于音乐等对时延要求不高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流和一个 MixerThread 回放线程实例<br>compress_offload：硬解输出流设备，用于需要硬件解码的数据输出，对应着标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流和一个 OffloadThread 回放线程实例<br>其中 primary_out 设备是必须声明支持的，而且系统启动时就已经打开 primary_out 设备并创建好对应的 MixerThread 实例。其他类型的输出流设备并非必须声明支持的，主要是看硬件上有无这个能力。</p><p>可能有人产生这样的疑问：既然 primary_out 设备一直保持打开，那么能耗岂不是很大？这里阐释一个概念：输出流设备属于逻辑设备，并不是硬件设备。所以即使输出流设备一直保持打开，只要硬件设备不工作，那么就不会影响能耗。那么硬件设备什么时候才会打开呢？答案是 PlaybackThread 将音频数据写入到输出流设备时。</p><p>下图简单描述 AudioTrack、PlaybackThread、输出流设备三者的对应关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/33-Audio-system-Audio-playback-.png" alt="Alt text"></p><p>我们可以这么说：输出流设备决定了它对应的 PlaybackThread 是什么类型。怎么理解呢？意思是说：只有支持了该类型的输出流设备，那么该类型的 PlaybackThread 才有可能被创建。举个例子：只有硬件上具备硬件解码器，系统才建立 compress_offload 设备，然后播放 mp3 格式的音乐文件时，才会创建 OffloadThread 把数据输出到 compress_offload 设备上；反之，如果硬件上并不具备硬件解码器，系统则不应该建立 compress_offload 设备，那么播放 mp3 格式的音乐文件时，通过 MixerThread 把数据输出到其他输出流设备上。</p><p>那么有无可能出现这种情况：底层并不支持 compress_offload 设备，但偏偏有个标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流送到 AudioFlinger 了呢？这是不可能的。系统启动时，会检查并保存输入输出流设备的支持信息；播放器在播放 mp3 文件时，首先看 compress_offload 设备是否支持了，如果支持，那么不进行软件解码，直接把数据标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD；如果不支持，那么先进行软件解码，然后把解码好的数据标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER，前提是 deep_buffer 设备是支持了的；如果 deep_buffer 设备也不支持，那么把数据标识为 AUDIO_OUTPUT_FLAG_PRIMARY。</p><p>系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 MixerThread 了；而此时 DirectOutputThread 与 OffloadThread 不会被创建，直到标识为 AUDIO_OUTPUT_FLAG_DIRECT/AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流需要输出时，才开始创建 DirectOutputThread/OffloadThread 和打开 direct_out/compress_offload 设备。这一点请参考如下代码，注释非常清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    // ......</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span><br><span class="line">    // open all output streams needed to access attached devices</span><br><span class="line">    // ......</span><br><span class="line">    for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        // ......</span><br><span class="line">        // open all output streams needed to access attached devices</span><br><span class="line">        // except for direct output streams that are only opened when they are actually</span><br><span class="line">        // required by an app.</span><br><span class="line">        // This also validates mAvailableOutputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            if ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">            audio_io_handle_t output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        // open input streams needed to access attached devices to validate</span><br><span class="line">        // mAvailableInputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            status_t status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mpClientInterface-&gt;openOutput() 最终会调用到 AudioFlinger::openOutput()：打开输出流设备，并创建 PlaybackThread 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t AudioFlinger::openOutput(audio_module_handle_t module,</span><br><span class="line">                                  audio_io_handle_t *output,</span><br><span class="line">                                  audio_config_t *config,</span><br><span class="line">                                  audio_devices_t *devices,</span><br><span class="line">                                  const String8&amp; address,</span><br><span class="line">                                  uint32_t *latencyMs,</span><br><span class="line">                                  audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags);</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module,</span><br><span class="line">                                                            audio_io_handle_t *output,</span><br><span class="line">                                                            audio_config_t *config,</span><br><span class="line">                                                            audio_devices_t devices,</span><br><span class="line">                                                            const String8&amp; address,</span><br><span class="line">                                                            audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line">    // 分配全局唯一的 audio_io_handle_t，可以理解它是回放线程的索引号</span><br><span class="line">    if (*output == AUDIO_IO_HANDLE_NONE) &#123;</span><br><span class="line">        *output = nextUniqueId(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 打开音频输出流设备，HAL 层根据 flags 选择打开相关类型的输出流设备</span><br><span class="line">    AudioStreamOut *outputStream = NULL;</span><br><span class="line">    status_t status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.string());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line"></span><br><span class="line">    if (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 音频流，创建 OffloadThread 实例</span><br><span class="line">            thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created offload output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_DIRECT 音频流，创建 DirectOutputThread 实例</span><br><span class="line">            thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created direct output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他标识的音频流，创建 MixerThread 实例</span><br><span class="line">            thread = new MixerThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created mixer output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        // 把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中</span><br><span class="line">        // 键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一</span><br><span class="line">        // 一对应的关系，所以拿到一个 audio_io_handle_t，就能找到它对应的 PlaybackThread</span><br><span class="line">        // 所以可以理解 audio_io_handle_t 为 PlaybackThread 的索引号</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-3、AudioFlinger-音频流管理"><a href="#1-2-3、AudioFlinger-音频流管理" class="headerlink" title="1.2.3、AudioFlinger 音频流管理"></a>1.2.3、AudioFlinger 音频流管理</h5><p>AudioFlinger 音频流管理由 AudioFlinger::PlaybackThread::Track 实现，Track 与 AudioTrack 是一对一的关系，一个 AudioTrack 创建后，那么 AudioFlinger 会创建一个 Track 与之对应；PlaybackThread 与 AudioTrack/Track 是一对多的关系，一个 PlaybackThread 可以挂着多个 Track。</p><p>具体来说：AudioTrack 创建后，AudioPolicyManager 根据 AudioTrack 的输出标识和流类型，找到对应的输出流设备和 PlaybackThread（如果没有找到的话，则系统会打开对应的输出流设备并新建一个 PlaybackThread），然后创建一个 Track 并挂到这个 PlaybackThread 下面。</p><p>PlaybackThread 有两个私有成员向量与此强相关：</p><p>· mTracks：该 PlaybackThread 创建的所有 Track 均添加保存到这个向量中<br>· mActiveTracks：只有需要播放（设置了 ACTIVE 状态）的 Track 会添加到这个向量中；PlaybackThread 会从该向量上找到所有设置了 ACTIVE 状态的 Track，把这些 Track 数据混音后写到输出流设备<br>音频流控制最常用的三个接口：</p><p>AudioFlinger::PlaybackThread::Track::start：开始播放：把该 Track 置 ACTIVE 状态，然后添加到 mActiveTracks 向量中，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>· AudioFlinger::PlaybackThread::Track::stop：停止播放：把该 Track 置 STOPPED 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>· AudioFlinger::PlaybackThread::Track::pause：暂停播放：把该 Track 置 PAUSING 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>· AudioFlinger::PlaybackThread::threadLoop() 得悉情况有变后，调用 prepareTracks_l() 重新准备音频流和混音器：ACTIVE 状态的 Track 会添加到 mActiveTracks，此外的 Track 会从 mActiveTracks 上移除出来，然后重新准备 AudioMixer。</p><p>可见这三个音频流控制接口是非常简单的，主要是设置一下 Track 的状态，然后发个事件通知 PlaybackThread 就行，复杂的处理都在 AudioFlinger::PlaybackThread::threadLoop() 中了。</p><h4 id="二-、深入剖析Android音频之AudioPolicyService"><a href="#二-、深入剖析Android音频之AudioPolicyService" class="headerlink" title="(二)、深入剖析Android音频之AudioPolicyService"></a>(二)、深入剖析Android音频之AudioPolicyService</h4><p>AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。AudioPolicyService根据用户配置来指导AudioFlinger加载设备接口，起到路由功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_policy"</span>; &#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService注册名为”media.audio_policy”的服务。<br>首先看看AudioPolicyService的onFirstRef()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"></span><br><span class="line">AudioPolicyService::AudioPolicyService()</span><br><span class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        <span class="comment">/* Step 1:创建AudioCommandThread线程 */</span></span><br><span class="line">        <span class="comment">// start tone playback thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start audio commands thread</span></span><br><span class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start output activity command thread</span></span><br><span class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_LEGACY_AUDIO_POLICY</span></span><br><span class="line">         <span class="comment">// 使用老版本的 audio policy 初始化方式</span></span><br><span class="line">        ....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 使用最新的 audio policy 初始化方式</span></span><br><span class="line">        ALOGI(<span class="string">"AudioPolicyService CSTOR in new mode"</span>);</span><br><span class="line">        <span class="comment">/* Step 2:创建AudioPolicyClient、 AudioPolicyManager */</span></span><br><span class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</span><br><span class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load audio processing modules</span></span><br><span class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        mAudioPolicyEffects = audioPolicyEffects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看总体时序图：</p><h5 id="2-1、Step-1-创建AudioCommandThread线程"><a href="#2-1、Step-1-创建AudioCommandThread线程" class="headerlink" title="2.1、Step 1:创建AudioCommandThread线程"></a>2.1、Step 1:创建AudioCommandThread线程</h5><p>在AudioPolicyService对象构造过程中，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程：</p><p>1、 ApmTone用于播放tone音；</p><p>2、 ApmAudio用于执行audio命令；</p><p>3、ApmOutput用于执行输出命令；</p><p>在第一次强引用AudioCommandThread线程对象时，AudioCommandThread的onFirstRef函数被回调，在此启动线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。</p><h5 id="2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager"><a href="#2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager" class="headerlink" title="2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager"></a>2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager</h5><p>首先创建AudioPolicyClient</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioPolicyClient</span> :</span> <span class="keyword">public</span> AudioPolicyClientInterface</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        AudioPolicyClient(AudioPolicyService *service) : mAudioPolicyService(service) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~AudioPolicyClient() &#123;&#125;</span><br><span class="line">        <span class="comment">// loads a HW module.</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_module_handle_t <span class="title">loadHwModule</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> status_t <span class="title">openOutput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_io_handle_t</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">uint32_t</span> *latencyMs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_output_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// opens an audio input</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_io_handle_t <span class="title">openInput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_io_handle_t</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_source_t</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_input_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        AudioPolicyService *mAudioPolicyService;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>createAudioPolicyManager() 函数的实现位于 frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cpp文件中。查看源码后我们会发现它实际上是直接调用了 AudioPolicyManager 的构造函数。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\manager\AudioPolicyFactory.cpp]</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">AudioPolicyInterface* <span class="title">createAudioPolicyManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AudioPolicyClientInterface *clientInterface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AudioPolicyManager(clientInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、创建AudioPolicyManager"><a href="#2-3、创建AudioPolicyManager" class="headerlink" title="2.3、创建AudioPolicyManager()"></a>2.3、创建AudioPolicyManager()</h5><p>总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/34-Audio-system-CreateAudioPolicyManager.png" alt="Alt text"></p><p>AudioPolicyManager 的构造函数将解析音频策略配置文件，从而获取到设备所支持的音频设备信息（包括设备是否支持 Offload、Direct 模式输出，各输入输出 profile 所支持的采样率、通道数、数据格式等），加载全部 HwModule，为之创建所有非 direct 输出类型的 outputStream 和所有 inputStream，并创建相应的 playbackThread 或 recordThread 线程。需要注意的是，Android 7.0上的音频策略配置文件开始使用 XML 格式，其文件名为 audio_policy_configuration.xml，</p><p>而在之前的版本上音频策略配置文件为 audio_policy.conf。frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp 中 AudioPolicyManager 构造函数的关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    :</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AUDIO_POLICY_TEST</span></span><br><span class="line">    Thread(<span class="literal">false</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//AUDIO_POLICY_TEST</span></span></span><br><span class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</span><br><span class="line">    mA2dpSuspended(<span class="literal">false</span>),</span><br><span class="line">    mAudioPortGeneration(<span class="number">1</span>),</span><br><span class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconMuted(<span class="literal">false</span>),</span><br><span class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</span><br><span class="line">    mMasterMono(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy_configuration.xml</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></span><br><span class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</span><br><span class="line">    PolicySerializer serializer;</span><br><span class="line">    <span class="comment">// 解析 xml 配置文件，将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> (serializer.deserialize(AUDIO_POLICY_XML_CONFIG_FILE, config) != NO_ERROR) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy.conf</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</span><br><span class="line">    <span class="comment">// 优先解析 vendor 目录下的 conf 配置文件，然后解析 device 目录下的 conf 配置文件。</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</span><br><span class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</span><br><span class="line">        config.setDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></span><br><span class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);    <span class="comment">// 设置音量调节曲线</span></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 依次加载 HwModule 并打开其所含 profile 的 outputStream 及 inputStream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</span><br><span class="line">        <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"could not open HW module %s"</span>, mHwModules[i]-&gt;getName());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open all output streams needed to access attached devices</span></span><br><span class="line">        <span class="comment">// except for direct output streams that are only opened when they are actually</span></span><br><span class="line">        <span class="comment">// required by an app.</span></span><br><span class="line">        <span class="comment">// This also validates mAvailableOutputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有非 direct 类型 profile 的 outputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 如果当前操作的 module.profile 是 direct 类型，则不为其打开 outputStream</span></span><br><span class="line">            <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            sp&lt;SwAudioOutputDescriptor&gt; outputDesc = <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile,</span><br><span class="line">                                                                                 mpClientInterface);</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;devicesForType = supportedDevices.getDevicesFromType(profileType);</span><br><span class="line">            String8 address = devicesForType.size() &gt; <span class="number">0</span> ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            outputDesc-&gt;mDevice = profileType;</span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = outputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = outputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = outputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 outputStream 并创建 playbackThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open input streams needed to access attached devices to validate</span></span><br><span class="line">        <span class="comment">// mAvailableInputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有 profile 的 inputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; inProfile = mHwModules[i]-&gt;mInputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            sp&lt;AudioInputDescriptor&gt; inputDesc =</span><br><span class="line">                    <span class="keyword">new</span> AudioInputDescriptor(inProfile);</span><br><span class="line"></span><br><span class="line">            inputDesc-&gt;mDevice = profileType;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            <span class="comment">// find the address</span></span><br><span class="line">            DeviceVector inputDevices = mAvailableInputDevices.getDevicesFromType(profileType);</span><br><span class="line">            <span class="comment">//   the inputs vector must be of size 1, but we don't want to crash here</span></span><br><span class="line">            String8 address = inputDevices.size() &gt; <span class="number">0</span> ? inputDevices.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line">            ALOGV(<span class="string">"  for input device 0x%x using address %s"</span>, profileType, address.<span class="built_in">string</span>());</span><br><span class="line">            ALOGE_IF(inputDevices.size() == <span class="number">0</span>, <span class="string">"Input device list is empty!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = inputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = inputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = inputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> input = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 inputStream 并创建 recordThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();    <span class="comment">// 更新系统缓存的音频输出设备信息</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyManager对象构造过程中主要完成以下几个步骤：</p><p>1、 加载audio_policy_configuration.xml或者audio_policy.conf配置文件</p><p>2、 初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</p><p>3、 加载audio policy硬件抽象库：mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;mName)</p><p>4、 打开对应的outputStream和inputStream ： mpClientInterface-&gt;openOutput()、mpClientInterface-&gt;openInput</p><p>5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</p><h5 id="2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件"><a href="#2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件" class="headerlink" title="2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件"></a>2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件</h5><p><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/audio_policy_configuration.xml" target="_blank" rel="noopener">audio_policy_configuration.xml</a><br>audio_policy.conf同时定义了多个audio 接口，每一个audio 接口包含若干output和input，而每个output和input又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/35-Audio-system-audio_policy.conf.png" alt="Alt text"></p><h5 id="2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled"><a href="#2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled" class="headerlink" title="2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)"></a>2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</h5><p>在AudioPolicyManagerBase中定义了音量调节对应的音频流描述符数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//audio_policy_volumes.xml</span><br><span class="line">const AudioPolicyManagerBase::VolumeCurvePoint</span><br><span class="line">            *AudioPolicyManagerBase::sVolumeProfiles[AudioSystem::NUM_STREAM_TYPES]</span><br><span class="line">                                                   [AudioPolicyManagerBase::DEVICE_CATEGORY_CNT] = &#123;</span><br><span class="line">    &#123; // AUDIO_STREAM_VOICE_CALL</span><br><span class="line">        sDefaultVoiceVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sSpeakerVoiceVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultVoiceVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; // AUDIO_STREAM_SYSTEM</span><br><span class="line">        sHeadsetSystemVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sDefaultSystemVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultSystemVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>initializeVolumeCurves()函数就是初始化该数组元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManagerBase::initializeVolumeCurves()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AudioSystem::NUM_STREAM_TYPES; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DEVICE_CATEGORY_CNT; j++) &#123;</span><br><span class="line">            mStreams[i].mVolumeCurve[j] =</span><br><span class="line">                    sVolumeProfiles[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check availability of DRC on speaker path: if available, override some of the speaker curves</span></span><br><span class="line">    <span class="keyword">if</span> (mSpeakerDrcEnabled) &#123;</span><br><span class="line">        mStreams[AUDIO_STREAM_SYSTEM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sDefaultSystemVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_RING].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_ALARM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_NOTIFICATION].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3、加载audio-policy硬件抽象库loadHwModule"><a href="#2-3-3、加载audio-policy硬件抽象库loadHwModule" class="headerlink" title="2.3.3、加载audio policy硬件抽象库loadHwModule()"></a>2.3.3、加载audio policy硬件抽象库loadHwModule()</h5><p>我们直接分析AudioFlinger::loadHwModule_l()中的load_audio_interface()函数<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int load_audio_interface(const char *if_name, audio_hw_device_t **dev)</span><br><span class="line">&#123;</span><br><span class="line">    const hw_module_t *mod;</span><br><span class="line">    int rc;</span><br><span class="line">    //根据名字加载audio_module模块  </span><br><span class="line">    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t load audio hw module %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    //打开audio_device设备</span><br><span class="line">    rc = audio_hw_device_open(mod, dev);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t open audio hw device in %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">audio_hw_device_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct audio_hw_device** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, AUDIO_HARDWARE_INTERFACE,</span><br><span class="line">                                 (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int legacy_adev_open(const hw_module_t* module, const char* name,</span><br><span class="line">                            hw_device_t** device)</span><br><span class="line">&#123;</span><br><span class="line">    struct legacy_audio_device *ladev;</span><br><span class="line">    int ret;</span><br><span class="line">    ladev = (struct legacy_audio_device *)calloc(1, sizeof(*ladev));</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    ladev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    ladev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module);</span><br><span class="line">    ladev-&gt;device.common.close = legacy_adev_close;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    ladev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    ladev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    ladev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    ladev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    ladev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    ladev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    ladev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    ladev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    ladev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    ladev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    ladev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    ladev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    ladev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ladev-&gt;device.dump = adev_dump;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;hwif = createAudioHardware();</span><br><span class="line"></span><br><span class="line">    *device = &amp;ladev-&gt;device.common;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此就加载完系统定义的所有音频接口，并生成相应的数据对象，如下图所示：’<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/36-Audio-system-audiohwdevice.png" alt="Alt text"></p><h5 id="2-3-4、打开对应的outputStream和inputStream"><a href="#2-3-4、打开对应的outputStream和inputStream" class="headerlink" title="2.3.4、打开对应的outputStream和inputStream"></a>2.3.4、打开对应的outputStream和inputStream</h5><p>前面一小节已经分析过outputStream，这里不再分析了<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/37-Audio-system-AudioStreamOut.png" alt="Alt text"></p><p>打开音频输出后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/38-Audio-system-audiohwdevice-openoutput.png" alt="Alt text"></p><p>打开音频输入:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/39-Audio-system-AudioStreamIn.png" alt="Alt text"><br>打开音频输入后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/310-Audio-system-audiohwdevice-openinput.png" alt="Alt text"></p><h5 id="2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs"><a href="#2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs" class="headerlink" title="2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()"></a>2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManager::updateDevicesAndOutputs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_STRATEGIES; i++) &#123;</span><br><span class="line">        mDeviceForStrategy[i] = getDeviceForStrategy((routing_strategy)i, <span class="literal">false</span> <span class="comment">/*fromCache*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPreviousOutputs = mOutputs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h5><p>-&gt;打开音频输出时创建一个audio_stream_out通道，并创建AudioStreamOut对象以及新建PlaybackThread播放线程。</p><p>-&gt; 打开音频输入时创建一个audio_stream_in通道，并创建AudioStreamIn对象以及创建RecordThread录音线程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/311-Audio-system-audio_stream_in-out.png" alt="Alt text"></p><h4 id="三-、深入剖析Android音频之AudioTrack"><a href="#三-、深入剖析Android音频之AudioTrack" class="headerlink" title="(三)、深入剖析Android音频之AudioTrack"></a>(三)、深入剖析Android音频之AudioTrack</h4><p>现在我们开始分析 AudioTrack 的创建过程，特别留意 AudioTrack 与 AudioFlinger 如何建立联系、用于 AudioTrack 与 AudioFlinger 交换数据的匿名共享内存如何分配。</p><h5 id="3-1-AudioTrack-amp-AudioFlinger-相关类"><a href="#3-1-AudioTrack-amp-AudioFlinger-相关类" class="headerlink" title="3.1. AudioTrack &amp; AudioFlinger 相关类"></a>3.1. AudioTrack &amp; AudioFlinger 相关类</h5><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/312-Audio-system-create_audiotrack-flow.png" alt="Alt text"></p><p>首先看一下 AudioTrack &amp; AudioFlinger 的类图，理一下 AudioFlinger 的主要类及其关系、AudioTrack 与 AudioFlinger 之间的联系，后面将以该图为脉络展开分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/313-Audio-system-create_audiotrack.jpg" alt="Alt text"></p><p>☯ AudioFlinger::PlaybackThread：回放线程基类，不同输出标识的音频流对应不同类型的 PlaybackThread 实例（分为四种：MixerThread、DirectOutputThread、DuplicatingThread、OffloadThread），具体见 3.4. AudioFlinger 回放录制线程 小节，所有的 PlaybackThread 实例都会添加到 AudioFlinger.mPlaybackThreads 向量中；这个向量的定义： DefaultKeyedVector&lt; audio_io_handle_t, sp<playbackthread>&gt; mPlaybackThreads;，可见 audio_io_handle_t 是与 PlaybackThread 是一一对应的，由已知的 audio_io_handle_t 就能找到对应的 PlaybackThread；audio_io_handle_t 在创建 PlaybackThread 时由系统分配，这个值是全局唯一的<br>☯ AudioFlinger::PlaybackThread::Track：音频流管理类，创建一块匿名共享内存用于 AudioTrack 与 AudioFlinger 之间的数据交换（方便起见，这块匿名共享内存，以后均简单称为 FIFO），同时实现 start()、stop()、pause() 等音频流常用控制手段；注意，多个 Track 对象可能都注册到同一个 PlaybackThread 中（尤其对于 MixerThread 而言，一个 MixerThread 往往挂着多个 Track 对象），这多个 Track 对象都会添加到 PlaybackThread.mTracks 向量中统一管理<br>☯ AudioFlinger::TrackHandle：Track 对象只负责音频流管理业务，对外并没有提供跨进程的 Binder 调用接口，而应用进程又需要对音频流进行控制，所以需要一个对象来代理 Track 的跨进程通讯，这个角色就是 TrackHandle，AudioTrack 通过它与 Track 交互<br>☯ AudioTrack：Android 音频系统对外提供的一个 API 类，负责音频流数据输出；每个音频流对应着一个 AudioTrack 实例，不同输出标识的 AudioTrack 会匹配到不同的 AudioFlinger::PlaybackThread；AudioTrack 与 AudioFlinger::PlaybackThread 之间通过 FIFO 来交换音频数据，AudioTrack 是 FIFO 生产者，AudioFlinger::PlaybackThread 是 FIFO 消费者<br>☯ AudioTrack::AudioTrackThread：数据传输模式为 TRANSFER_CALLBACK 时，需要创建该线程，它通过调用 audioCallback 回调函数主动从用户进程处索取数据并填充到 FIFO 上；数据传输模式为 TRANSFER_SYNC 时，则不需要创建这个线程，因为用户进程会持续调用 AudioTrack.write() 填充数据到 FIFO；数据传输模式为 TRANSFER_SHARED 时，也不需要创建这个线程，因为用户进程会创建一块匿名共享内存，并把要播放的音频数据一次性拷贝到这块匿名共享内存上了<br>☯ IAudioTrack：IAudioTrack 是链结 AudioTrack 与 AudioFlinger 的桥梁；它在 AudioTrack 端的对象是 BpAudioTrack，在 AudioFlinger 端的对象是 BnAudioTrack，从图中不难看出，AudioFlinger::TrackHandle 继承自 BnAudioTrack，而 AudioFlinger::TrackHandle 恰恰是AudioFlinger::PlaybackThread::Track 的代理对象，所以 AudioTrack 得到 IAudioTrack 实例后，就可以调用 IAudioTrack 的接口与 AudioFlinger::PlaybackThread::Track 交互</playbackthread></p><p><strong>audio_io_handle_t：</strong></p><p>这里再详细说明一下 audio_io_handle_t，它是 AudioTrack/AudioRecord/AudioSystem、AudioFlinger、AudioPolicyManager 之间一个重要的链结点。3.4. AudioFlinger 回放录制线程 小节在 AudioFlinger::openOutput_l() 注释中大致说明了它的来历及其作用，现在回顾下：当打开输出流设备及创建 PlaybackThread 时，系统会分配一个全局唯一的值作为 audio_io_handle_t，并把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一一对应的关系，因此拿到一个 audio_io_handle_t，就能遍历键值对向量 mPlaybackThreads 找到它对应的 PlaybackThread，可以简单理解 audio_io_handle_t 为 PlaybackThread 的索引号或线程 id。由于 audio_io_handle_t 具有 PlaybackThread 索引特性，所以应用进程想获取 PlaybackThread 某些信息的话，只需要传入对应的 audio_io_handle_t 即可。例如 AudioFlinger::format(audio_io_handle_t output)，这是 AudioFlinger 的一个服务接口，用户进程可以通过该接口获取某个 PlaybackThread 配置的音频格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">audio_format_t</span> AudioFlinger::format(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">// checkPlaybackThread_l() 根据传入的 audio_io_handle_t，从键值对向量</span></span><br><span class="line">    <span class="comment">// mPlaybackThreads 中找到它对应的 PlaybackThread</span></span><br><span class="line">    PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"format() unknown thread %d"</span>, output);</span><br><span class="line">        <span class="keyword">return</span> AUDIO_FORMAT_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread-&gt;format();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::PlaybackThread *AudioFlinger::checkPlaybackThread_l(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlaybackThreads.valueFor(output).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-AudioTrack-构造过程"><a href="#3-2-AudioTrack-构造过程" class="headerlink" title="3.2. AudioTrack 构造过程"></a>3.2. AudioTrack 构造过程</h5><p>当我们构造一个 AudioTrack 实例时（以 MODE_STREAM/TRANSFER_SYNC 模式为例，这也是最常用的模式了，此时 sharedBuffer 为空），系统都发生了什么事？阐述下大致流程：</p><p>如果 cbf（audioCallback 回调函数）非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数（MODE_STREAM 模式时，cbf 为空）；<br>根据 streamType（流类型）、flags（输出标识）等参数调用 AudioSystem::getOutputForAttr()；经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()：<br>如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相应的 PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；<br>如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；别忘了在 3.4. AudioFlinger 回放录制线程 小节中提到：系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 PlaybackThread 了；<br>通过 Binder 机制调用 AudioFlinger::createTrack()（注意 step2 中 AudioTrack 已经拿到一个 audio_io_handle_t 了，此时把这个 audio_io_handle_t 传入给 createTrack()）：<br>根据传入的 audio_io_handle_t 找到它对应的 PlaybackThread；<br>PlaybackThread 新建一个音频流管理对象 Track；Track 构造时会分配一块匿名共享内存用于 AudioFlinger 与 AudioTrack 的数据交换缓冲区（FIFO）及其控制块（audio_track_cblk_t），并创建一个 AudioTrackServerProxy 对象（PlaybackThread 将使用它从 FIFO 上取得可读数据的位置）；<br>最后新建一个 Track 的通讯代理 TrackHandle，并以 IAudioTrack 作为返回值给 AudioTrack（TrackHandle、BnAudioTrack、BpAudioTrack、IAudioTrack 的关系见上一个小节）；<br>通过 IAudioTrack 接口，取得 AudioFlinger 中的 FIFO 控制块（audio_track_cblk_t），由此再计算得到 FIFO 的首地址；<br>创建一个 AudioTrackClientProxy 对象（AudioTrack 将使用它从 FIFO 上取得可用空间的位置）；<br>AudioTrack 由此建立了和 AudioFlinger 的全部联系工作：</p><p>通过 IAudioTrack 接口可以控制该音轨的状态，例如 start、stop、pause<br>持续写入数据到 FIFO 上，实现音频连续播放<br>通过 audio_io_handle_t，可以找到它对应的 PlaybackThread，从而查询该 PlaybackThread 的相关信息，如所设置的采样率、格式等等<br>构造 1 个 AudioTrack 实例时，AudioFlinger 会有 1 个 PlaybackThread 实例、1 个 Track 实例、1 个 TrackHandle 实例、1 个 AudioTrackServerProxy 实例、1 块 FIFO 与之对应。</p><p>当同时构造 1 个 AudioTrack with AUDIO_OUTPUT_FLAG_PRIMARY、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_FAST、3 个 AudioTrack with AUDIO_OUTPUT_FLAG_DEEP_BUFFER、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_DIRECT 时（事实上，Android 音频策略不允许出现这种情形的），AudioFlinger 拥有的 PlaybackThread、Track、TrackHandle 实例如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/314-Audio-system-PlaybackThread-Track-TrackHandle.png" alt="Alt text"></p><p>最后附上相关代码的流程分析，我本意是不多贴代码的，但不上代码总觉得缺点什么，这里我尽量把代码精简，提取主干，忽略细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">AudioTrack::AudioTrack(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,    <span class="comment">// 音频流类型：如 Music、Voice-Call、DTMF、Alarm 等等</span></span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,               <span class="comment">// 采样率：如 16KHz、44.1KHz、48KHz 等等</span></span><br><span class="line">        <span class="keyword">audio_format_t</span> format,             <span class="comment">// 音频格式：如 PCM、MP3、AAC 等等</span></span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,  <span class="comment">// 声道数：如 Mono（单声道）、Stereo（双声道）</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,   <span class="comment">// 共享内存缓冲区：数据模式是 MODE_STATIC 时使用，数据模式是 MODE_STREAM 时为空</span></span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        <span class="comment">// 输出标识位，详见 AUDIO_OUTPUT_FLAG 描述</span></span><br><span class="line">        <span class="keyword">callback_t</span> cbf,                    <span class="comment">// 回调函数</span></span><br><span class="line">        <span class="keyword">void</span>* user,                        <span class="comment">// 回调函数的参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,        <span class="comment">// 数据传输类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">    : mStatus(NO_INIT),</span><br><span class="line">      mIsTimed(<span class="literal">false</span>),</span><br><span class="line">      mPreviousPriority(ANDROID_PRIORITY_NORMAL),</span><br><span class="line">      mPreviousSchedulingGroup(SP_DEFAULT),</span><br><span class="line">      mPausedPosition(<span class="number">0</span>),</span><br><span class="line">      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    mStatus = <span class="built_in">set</span>(streamType, sampleRate, format, channelMask,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/*frameCount*/</span>, flags, cbf, user, notificationFrames,</span><br><span class="line">            sharedBuffer, <span class="literal">false</span> <span class="comment">/*threadCanCallJava*/</span>, sessionId, transferType, offloadInfo,</span><br><span class="line">            uid, pid, pAttributes, doNotReconnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::<span class="built_in">set</span>(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">        <span class="keyword">audio_format_t</span> format,</span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">        <span class="keyword">size_t</span> frameCount,</span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        </span><br><span class="line">        <span class="keyword">callback_t</span> cbf,</span><br><span class="line">        <span class="keyword">void</span>* user,</span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        <span class="keyword">bool</span> threadCanCallJava,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数格式合法性检查、音轨音量初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 cbf 非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (cbf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioTrackThread = <span class="keyword">new</span> AudioTrackThread(*<span class="keyword">this</span>, threadCanCallJava);</span><br><span class="line">        mAudioTrackThread-&gt;run(<span class="string">"AudioTrack"</span>, ANDROID_PRIORITY_AUDIO, <span class="number">0</span> <span class="comment">/*stack*/</span>);</span><br><span class="line">        <span class="comment">// thread begins in paused state, and will not reference us until start()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the IAudioTrack</span></span><br><span class="line">    <span class="keyword">status_t</span> status = createTrack_l();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::createTrack_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 IAudioFlinger，通过 binder 请求 AudioFlinger 服务</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger();</span><br><span class="line">    <span class="keyword">if</span> (audioFlinger == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get audioflinger"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioSystem::getOutputForAttr() 经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()</span></span><br><span class="line">    <span class="comment">// 如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，</span></span><br><span class="line">    <span class="comment">// 那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相关的</span></span><br><span class="line">    <span class="comment">// PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；</span></span><br><span class="line">    <span class="comment">// 如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该</span></span><br><span class="line">    <span class="comment">// PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack</span></span><br><span class="line">    <span class="keyword">audio_io_handle_t</span> output;</span><br><span class="line">    status = AudioSystem::getOutputForAttr(attr, &amp;output,</span><br><span class="line">                                           (<span class="keyword">audio_session_t</span>)mSessionId, &amp;streamType, mClientUid,</span><br><span class="line">                                           mSampleRate, mFormat, mChannelMask,</span><br><span class="line">                                           mFlags, mSelectedDeviceId, mOffloadInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 AudioFlinger 发出 createTrack 请求</span></span><br><span class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</span><br><span class="line">                                                      mSampleRate,</span><br><span class="line">                                                      mFormat,</span><br><span class="line">                                                      mChannelMask,</span><br><span class="line">                                                      &amp;temp,</span><br><span class="line">                                                      &amp;trackFlags,</span><br><span class="line">                                                      mSharedBuffer,</span><br><span class="line">                                                      output,</span><br><span class="line">                                                      tid,</span><br><span class="line">                                                      &amp;mSessionId,</span><br><span class="line">                                                      mClientUid,</span><br><span class="line">                                                      &amp;status);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioFlinger 创建 Track 对象时会分配一个 FIFO，这里获取 FIFO 的控制块</span></span><br><span class="line">    sp&lt;IMemory&gt; iMem = track-&gt;getCblk();</span><br><span class="line">    <span class="keyword">if</span> (iMem == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匿名共享内存首地址</span></span><br><span class="line">    <span class="keyword">void</span> *iMemPointer = iMem-&gt;pointer();</span><br><span class="line">    <span class="keyword">if</span> (iMemPointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    mAudioTrack = track; <span class="comment">// 保存 AudioFlinger::PlaybackThread::Track 的代理对象 IAudioTrack</span></span><br><span class="line">    mCblkMemory = iMem; <span class="comment">// 保存匿名共享内存首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制块位于 AudioFlinger 分配的匿名共享内存的首部</span></span><br><span class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span>*&gt;(iMemPointer);</span><br><span class="line">    mCblk = cblk;</span><br><span class="line">    mOutput = output; <span class="comment">// 保存返回的 audio_io_handle_t，用它可以找到对应的 PlaybackThread</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update proxy</span></span><br><span class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 为空，意味着音轨数据模式为 MODE_STREAM，那么创建 AudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy.clear();</span><br><span class="line">        mProxy = <span class="keyword">new</span> AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 非空，意味着音轨数据模式为 MODE_STATIC，那么创建 StaticAudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy = <span class="keyword">new</span> StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">        mProxy = mStaticProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger::createTrack()，顾名思义，创建一个 Track 对象，将用于音频流的控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;IAudioTrack&gt; AudioFlinger::createTrack(</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *frameCount,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        audio_io_handle_t output,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int *sessionId,</span><br><span class="line">        int clientUid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;PlaybackThread::Track&gt; track;</span><br><span class="line">    sp&lt;TrackHandle&gt; trackHandle;</span><br><span class="line">    sp&lt;Client&gt; client;</span><br><span class="line">    status_t lStatus;</span><br><span class="line">    int lSessionId;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        // 根据传入来的 audio_io_handle_t，找到对应的 PlaybackThread</span><br><span class="line">        PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">        if (thread == NULL) &#123;</span><br><span class="line">            ALOGE(&quot;no playback thread found for output handle %d&quot;, output);</span><br><span class="line">            lStatus = BAD_VALUE;</span><br><span class="line">            goto Exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // 在 PlaybackThread 上创建一个音频流管理对象 Track</span><br><span class="line">        track = thread-&gt;createTrack_l(client, streamType, sampleRate, format,</span><br><span class="line">                channelMask, frameCount, sharedBuffer, lSessionId, flags, tid, clientUid, &amp;lStatus);</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        setAudioHwSyncForSession_l(thread, (audio_session_t)lSessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 创建 Track 的通讯代理 TrackHandle 并返回它</span><br><span class="line">    trackHandle = new TrackHandle(track);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return trackHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l(</span><br><span class="line">        const sp&lt;AudioFlinger::Client&gt;&amp; client,</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *pFrameCount,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        int sessionId,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int uid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    size_t frameCount = *pFrameCount;</span><br><span class="line">    sp&lt;Track&gt; track;</span><br><span class="line">    status_t lStatus;</span><br><span class="line"></span><br><span class="line">    bool isTimed = (*flags &amp; IAudioFlinger::TRACK_TIMED) != 0;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    &#123; // scope for mLock</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!isTimed) &#123;</span><br><span class="line">            // 创建 Track，等会再看看 Track 构造函数干些啥</span><br><span class="line">            track = new Track(this, client, streamType, sampleRate, format,</span><br><span class="line">                              channelMask, frameCount, NULL, sharedBuffer,</span><br><span class="line">                              sessionId, uid, *flags, TrackBase::TYPE_DEFAULT);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建 TimedTrack，带时间戳的 Track？这里不深究</span><br><span class="line">            track = TimedTrack::create(this, client, streamType, sampleRate, format,</span><br><span class="line">                    channelMask, frameCount, sharedBuffer, sessionId, uid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        // 把创建的 Track 添加到 mTracks 向量中，方便 PlaybackThread 统一管理</span><br><span class="line">        mTracks.add(track);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lStatus = NO_ERROR;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return track;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------------------------</span><br><span class="line">// 如下是 TrackHandle 的相关代码，可以看到，TrackHandle 其实就是一个壳子，是 Track 的包装类</span><br><span class="line">// 所有 TrackHandle 接口都是调向 Track 的</span><br><span class="line">// Google 为什么要搞这么一则？Track 是 PlaybackThread 内部使用的，不适宜对外暴露，但应用进程</span><br><span class="line">// 又确实需要控制音频流的状态（start、stop、pause），所以就采取这么一种方式实现</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::TrackHandle(const sp&lt;AudioFlinger::PlaybackThread::Track&gt;&amp; track)</span><br><span class="line">    : BnAudioTrack(),</span><br><span class="line">      mTrack(track)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::~TrackHandle() &#123;</span><br><span class="line">    // just stop the track on deletion, associated resources</span><br><span class="line">    // will be freed from the main thread once all pending buffers have</span><br><span class="line">    // been played. Unless it&apos;s not in the active track list, in which</span><br><span class="line">    // case we free everything now...</span><br><span class="line">    mTrack-&gt;destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IMemory&gt; AudioFlinger::TrackHandle::getCblk() const &#123;</span><br><span class="line">    return mTrack-&gt;getCblk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t AudioFlinger::TrackHandle::start() &#123;</span><br><span class="line">    return mTrack-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::stop() &#123;</span><br><span class="line">    mTrack-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::flush() &#123;</span><br><span class="line">    mTrack-&gt;flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::pause() &#123;</span><br><span class="line">    mTrack-&gt;pause();</span><br><span class="line">&#125;</span><br><span class="line">// ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>最后，我们看看 Track 的构造过程，主要分析数据 FIFO 及它的控制块是如何分配的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::PlaybackThread::Track::Track(</span><br><span class="line">            PlaybackThread *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> uid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   TrackBase(thread, client, sampleRate, format, channelMask, frameCount,</span><br><span class="line">                  (sharedBuffer != <span class="number">0</span>) ? sharedBuffer-&gt;pointer() : buffer,</span><br><span class="line">                  sessionId, uid, flags, <span class="literal">true</span> <span class="comment">/*isOut*/</span>,</span><br><span class="line">                  (type == TYPE_PATCH) ? ( buffer == <span class="literal">NULL</span> ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK,</span><br><span class="line">                  type),</span><br><span class="line">    mFillingUpStatus(FS_INVALID),</span><br><span class="line">    <span class="comment">// mRetryCount initialized later when needed</span></span><br><span class="line">    mSharedBuffer(sharedBuffer),</span><br><span class="line">    mStreamType(streamType),</span><br><span class="line">    mName(<span class="number">-1</span>),  <span class="comment">// see note below</span></span><br><span class="line">    mMainBuffer(thread-&gt;mixBuffer()),</span><br><span class="line">    mAuxBuffer(<span class="literal">NULL</span>),</span><br><span class="line">    mAuxEffectId(<span class="number">0</span>), mHasVolumeController(<span class="literal">false</span>),</span><br><span class="line">    mPresentationCompleteFrames(<span class="number">0</span>),</span><br><span class="line">    mFastIndex(<span class="number">-1</span>),</span><br><span class="line">    mCachedVolume(<span class="number">1.0</span>),</span><br><span class="line">    mIsInvalid(<span class="literal">false</span>),</span><br><span class="line">    mAudioTrackServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">    mResumeToStopping(<span class="literal">false</span>),</span><br><span class="line">    mFlushHwPending(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// client == 0 implies sharedBuffer == 0</span></span><br><span class="line">    ALOG_ASSERT(!(client == <span class="number">0</span> &amp;&amp; sharedBuffer != <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ALOGV_IF(sharedBuffer != <span class="number">0</span>, <span class="string">"sharedBuffer: %p, size: %d"</span>, sharedBuffer-&gt;pointer(),</span><br><span class="line">            sharedBuffer-&gt;size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 FIFO 控制块（audio_track_cblk_t）是否分配好了，上面代码并未分配 audio_track_cblk_t</span></span><br><span class="line">    <span class="comment">// 因此只可能是构造 TrackBase 时分配的，等下再看看 TrackBase 的构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STREAM 模式，创建一个 AudioTrackServerProxy 对象</span></span><br><span class="line">        <span class="comment">// PlaybackThread 将持续使用它从 FIFO 上取得可读数据的位置</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> AudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize, !isExternalTrack(), sampleRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STATIC 模式，创建一个 StaticAudioTrackServerProxy 对象</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize);</span><br><span class="line">    &#125;</span><br><span class="line">    mServerProxy = mAudioTrackServerProxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 Track 分配一个名称，AudioMixer 会根据 TrackName 找到对应的 Track</span></span><br><span class="line">    mName = thread-&gt;getTrackName_l(channelMask, format, sessionId);</span><br><span class="line">    <span class="keyword">if</span> (mName &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"no more track names available"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::ThreadBase::TrackBase::TrackBase(</span><br><span class="line">            ThreadBase *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> clientUid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            <span class="keyword">bool</span> isOut,</span><br><span class="line">            alloc_type alloc,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   RefBase(),</span><br><span class="line">        mThread(thread),</span><br><span class="line">        mClient(client),</span><br><span class="line">        mCblk(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="comment">// mBuffer</span></span><br><span class="line">        mState(IDLE),</span><br><span class="line">        mSampleRate(sampleRate),</span><br><span class="line">        mFormat(format),</span><br><span class="line">        mChannelMask(channelMask),</span><br><span class="line">        mChannelCount(isOut ?</span><br><span class="line">                audio_channel_count_from_out_mask(channelMask) :</span><br><span class="line">                audio_channel_count_from_in_mask(channelMask)),</span><br><span class="line">        mFrameSize(audio_is_linear_pcm(format) ?</span><br><span class="line">                mChannelCount * audio_bytes_per_sample(format) : <span class="keyword">sizeof</span>(<span class="keyword">int8_t</span>)),</span><br><span class="line">        mFrameCount(frameCount),</span><br><span class="line">        mSessionId(sessionId),</span><br><span class="line">        mFlags(flags),</span><br><span class="line">        mIsOut(isOut),</span><br><span class="line">        mServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">        mId(android_atomic_inc(&amp;nextTrackId)),</span><br><span class="line">        mTerminated(<span class="literal">false</span>),</span><br><span class="line">        mType(type),</span><br><span class="line">        mThreadIoHandle(thread-&gt;id())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGD("Creating track with %d buffers @ %d bytes", bufferCount, bufferSize);</span></span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">    <span class="keyword">size_t</span> bufferSize = (buffer == <span class="literal">NULL</span> ? roundup(frameCount) : frameCount) * mFrameSize;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span> &amp;&amp; alloc == ALLOC_CBLK) &#123;</span><br><span class="line">        <span class="comment">// 这个 size 将是分配的匿名共享内存的大小</span></span><br><span class="line">        <span class="comment">// 等于控制块的大小（sizeof(audio_track_cblk_t)加上数据 FIFO的大小（bufferSize）</span></span><br><span class="line">        <span class="comment">// 待会看到这块内存的结构，就明白这样分配的意义了</span></span><br><span class="line">        size += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块匿名共享内存</span></span><br><span class="line">        mCblkMemory = client-&gt;heap()-&gt;allocate(size);</span><br><span class="line">        <span class="keyword">if</span> (mCblkMemory == <span class="number">0</span> ||</span><br><span class="line">                (mCblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span> *&gt;(mCblkMemory-&gt;pointer())) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"not enough memory for AudioTrack size=%u"</span>, size);</span><br><span class="line">            client-&gt;heap()-&gt;dump(<span class="string">"AudioTrack"</span>);</span><br><span class="line">            mCblkMemory.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// this syntax avoids calling the audio_track_cblk_t constructor twice</span></span><br><span class="line">        mCblk = (<span class="keyword">audio_track_cblk_t</span> *) <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size];</span><br><span class="line">        <span class="comment">// assume mCblk != NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the shared structure in-place.</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是 C++ 的 placement new（定位创建对象）语法：new(@BUFFER) @CLASS();</span></span><br><span class="line">        <span class="comment">// 可以在特定内存位置上构造一个对象</span></span><br><span class="line">        <span class="comment">// 这里，在匿名共享内存首地址上构造了一个 audio_track_cblk_t 对象</span></span><br><span class="line">        <span class="comment">// 这样 AudioTrack 与 AudioFlinger 都能访问这个 audio_track_cblk_t 对象了</span></span><br><span class="line">        <span class="keyword">new</span>(mCblk) <span class="keyword">audio_track_cblk_t</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如下分配数据 FIFO，将用于 AudioTrack 与 AudioFlinger 的数据交换</span></span><br><span class="line">        <span class="keyword">switch</span> (alloc) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> ALLOC_CBLK:</span><br><span class="line">            <span class="comment">// clear all buffers</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STREAM/TRANSFER_SYNC 时，数据 FIFO 的分配</span></span><br><span class="line">                <span class="comment">// 数据 FIFO 的首地址紧靠控制块（audio_track_cblk_t）之后</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   | -------------------&gt; mCblkMemory &lt;--------------------- |</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |             Buffer                 |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                    ^</span></span><br><span class="line">                <span class="comment">//   |                    |</span></span><br><span class="line">                <span class="comment">//   mCblk               mBuffer</span></span><br><span class="line">                mBuffer = (<span class="keyword">char</span>*)mCblk + <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">                <span class="built_in">memset</span>(mBuffer, <span class="number">0</span>, bufferSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STATIC/TRANSFER_SHARED 时，直接指向 sharedBuffer</span></span><br><span class="line">                <span class="comment">// sharedBuffer 是应用进程分配的匿名共享内存，应用进程已经一次性把数据</span></span><br><span class="line">                <span class="comment">// 写到 sharedBuffer 来了，AudioFlinger 可以直接从这里读取</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |    |            sharedBuffer           |</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                         ^</span></span><br><span class="line">                <span class="comment">//   |                         |</span></span><br><span class="line">                <span class="comment">//   mCblk                    mBuffer</span></span><br><span class="line">                mBuffer = buffer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-AudioTrack-数据写入"><a href="#3-3-AudioTrack-数据写入" class="headerlink" title="3.3. AudioTrack 数据写入"></a>3.3. AudioTrack 数据写入</h5><p>AudioTrack 实例构造后，应用程序接着可以写入音频数据了。如之前所描述：AudioTrack 与 AudioFlinger 是 生产者-消费者 的关系：</p><p>☯ AudioTrack：AudioTrack 在 FIFO 中找到一块可用空间，把用户传入的音频数据写入到这块可用空间上，然后更新写位置（对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据了）；如果用户传入的数据量比可用空间要大，那么要把用户传入的数据拆分多次写入到 FIFO 中（AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地读取数据，所以 FIFO 可用空间是在不停变化的）<br>☯ AudioFlinger：AudioFlinger 在 FIFO 中找到一块可读数据块，把可读数据拷贝到目的缓冲区上，然后更新读位置（对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间了）；如果FIFO 上可读数据量比预期的要小，那么要进行多次的读取，才能积累到预期的数据量（AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地写入数据，所以 FIFO 可读的数据量是在不停变化的）<br>上面的过程中，如果 AudioTrack 总能及时生产数据，并且 AudioFlinger 总能及时消耗掉这些数据，那么整个过程将是非常和谐的；但系统可能会发生异常，出现如下的状态：</p><p>☯ Block：AudioFlinger 长时间不读取 FIFO 上的可读数据，使得 AudioTrack 长时间获取不到可用空间，无法写入数据；这种情况的根本原因大多是底层驱动发生阻塞异常，导致 AudioFlinger 无法继续写数据到硬件设备中，AudioFlinger 本身并没有错<br>☯ Underrun：AudioTrack 写入数据的速度跟不上 AudioFlinger 读取数据的速度，使得 AudioFlinger 不能及时获取到预期的数据量，反映到现实的后果就是声音断续；这种情况的根本原因大多是应用程序不能及时写入数据或者缓冲区分配过小，AudioTrack 本身并没有错；AudioFlinger 针对这点做了容错处理：当发现 underrun 时，先陷入短时间的睡眠，不急着读取数据，让应用程序准备更多的数据（如果某一天做应用的哥们意识到自己的错误原来由底层的兄弟默默埋单了，会不会感动得哭了^_^）</p><h5 id="3-3-1-AudioTrack-写数据流程"><a href="#3-3-1-AudioTrack-写数据流程" class="headerlink" title="3.3. 1. AudioTrack 写数据流程"></a>3.3. 1. AudioTrack 写数据流程</h5><p>我们看一下 AudioTrack 写数据的代码，流程很简单：obtainBuffer() 在 FIFO 中找到一块可用区间，memcpy() 把用户传入的音频数据拷贝到这个可用区间上，releaseBuffer() 更新写位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">ssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)</span><br><span class="line">&#123;</span><br><span class="line">    if (mTransfer != TRANSFER_SYNC) &#123;</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDirect()) &#123;</span><br><span class="line">        AutoMutex lock(mLock);</span><br><span class="line">        int32_t flags = android_atomic_and(</span><br><span class="line">                            ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END),</span><br><span class="line">                            &amp;mCblk-&gt;mFlags);</span><br><span class="line">        if (flags &amp; CBLK_INVALID) &#123;</span><br><span class="line">            return DEAD_OBJECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ssize_t(userSize) &lt; 0 || (buffer == NULL &amp;&amp; userSize != 0)) &#123;</span><br><span class="line">        // Sanity-check: user is most-likely passing an error code, and it would</span><br><span class="line">        // make the return value ambiguous (actualSize vs error).</span><br><span class="line">        ALOGE(&quot;AudioTrack::write(buffer=%p, size=%zu (%zd)&quot;, buffer, userSize, userSize);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t written = 0;</span><br><span class="line">    Buffer audioBuffer;</span><br><span class="line"></span><br><span class="line">    while (userSize &gt;= mFrameSize) &#123;</span><br><span class="line">        // 单帧数据量 frameSize = channelCount * bytesPerSample</span><br><span class="line">        //   对于双声道，16位采样的音频数据来说，frameSize = 2 * 2 = 4(bytes)</span><br><span class="line">        // 用户传入的数据帧数 frameCount = userSize / frameSize</span><br><span class="line">        audioBuffer.frameCount = userSize / mFrameSize;</span><br><span class="line"></span><br><span class="line">        // obtainBuffer() 从 FIFO 上得到一块可用区间</span><br><span class="line">        status_t err = obtainBuffer(&amp;audioBuffer,</span><br><span class="line">                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);</span><br><span class="line">        if (err &lt; 0) &#123;</span><br><span class="line">            if (written &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (err == TIMED_OUT || err == -EINTR) &#123;</span><br><span class="line">                err = WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            return ssize_t(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // toWrite 是 FIFO 可用区间的大小，可能比 userSize（用户传入数据的大小）要小</span><br><span class="line">        //   因此用户传入的数据可能要拆分多次拷贝到 FIFO 上</span><br><span class="line">        // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地</span><br><span class="line">        //   消耗数据，所以 FIFO 可用区间是在不停变化的</span><br><span class="line">        size_t toWrite = audioBuffer.size;</span><br><span class="line">        memcpy(audioBuffer.i8, buffer, toWrite); // 把用户数据拷贝到 FIFO 可用区间</span><br><span class="line">        buffer = ((const char *) buffer) + toWrite; // 未拷贝数据的位置</span><br><span class="line">        userSize -= toWrite; // 未拷贝数据的大小</span><br><span class="line">        written += toWrite; // 已拷贝数据的大小</span><br><span class="line"></span><br><span class="line">        // releaseBuffer() 更新 FIFO 写位置</span><br><span class="line">        // 对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据</span><br><span class="line">        releaseBuffer(&amp;audioBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (written &gt; 0) &#123;</span><br><span class="line">        mFramesWritten += written / mFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-AudioFlinger-读数据流程"><a href="#3-3-2-AudioFlinger-读数据流程" class="headerlink" title="3.3. 2. AudioFlinger 读数据流程"></a>3.3. 2. AudioFlinger 读数据流程</h5><p>AudioFlinger 消费数据的流程稍微复杂一点，3.4. AudioFlinger 回放录制线程 小节中描述了 AudioFlinger::PlaybackThread::threadLoop() 工作流程，这里不累述了，我们把焦点放在“如何从 FIFO 读取数据”节点上。</p><p>我们以 DirectOutputThread/OffloadThread 为例说明（MixerThread 读数据也是类似的过程，只不过是在 AudioMixer 中进行的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">void AudioFlinger::DirectOutputThread::threadLoop_mix()</span><br><span class="line">&#123;</span><br><span class="line">    // mFrameCount 是硬件设备（PCM 设备）处理单个数据块的帧数（周期大小）</span><br><span class="line">    //   上层必须积累了足够多（mFrameCount）的数据，才写入到 PCM 设备</span><br><span class="line">    //   所以 mFrameCount 也就是 AudioFlinger 预期的数据量</span><br><span class="line">    size_t frameCount = mFrameCount;</span><br><span class="line">    // mSinkBuffer 目的缓冲区，threadLoop_write() 会把 mSinkBuffer 上的数据写到 PCM 设备</span><br><span class="line">    int8_t *curBuf = (int8_t *)mSinkBuffer;</span><br><span class="line">    // output audio to hardware</span><br><span class="line">    // FIFO 上可读的数据量可能要比预期的要小，因此可能需要多次读取才能积累足够的数据量</span><br><span class="line">    // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地生产数据</span><br><span class="line">    //   所以 FIFO 可读的数据量是在不停变化的</span><br><span class="line">    while (frameCount) &#123;</span><br><span class="line">        AudioBufferProvider::Buffer buffer;</span><br><span class="line">        buffer.frameCount = frameCount;</span><br><span class="line">        // getNextBuffer() 从 FIFO 上获取可读数据块</span><br><span class="line">        status_t status = mActiveTrack-&gt;getNextBuffer(&amp;buffer);</span><br><span class="line">        if (status != NO_ERROR || buffer.raw == NULL) &#123;</span><br><span class="line">            memset(curBuf, 0, frameCount * mFrameSize);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // memcpy() 把 FIFO 可读数据拷贝到 mSinkBuffer 目的缓冲区</span><br><span class="line">        memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize);</span><br><span class="line">        frameCount -= buffer.frameCount;</span><br><span class="line">        curBuf += buffer.frameCount * mFrameSize;</span><br><span class="line">        // releaseBuffer() 更新 FIFO 读位置</span><br><span class="line">        // 对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间</span><br><span class="line">        mActiveTrack-&gt;releaseBuffer(&amp;buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentWriteLength = curBuf - (int8_t *)mSinkBuffer;</span><br><span class="line">    mSleepTimeUs = 0;</span><br><span class="line">    mStandbyTimeNs = systemTime() + mStandbyDelayNs;</span><br><span class="line">    mActiveTrack.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-3-环形-FIFO-管理"><a href="#3-3-3-环形-FIFO-管理" class="headerlink" title="3.3. 3. 环形 FIFO 管理"></a>3.3. 3. 环形 FIFO 管理</h5><p>在上述过程中，不知大家有无意识到：整个过程中，最难的是如何协调生产者与消费者之间的步调。上文所说的 FIFO 是环形 FIFO，AudioTrack 写指针、AudioFlinger 读指针都是基于 FIFO 当前的读写位置来计算的。</p><p>☯AudioTrack 与 AudioFlinger 不在同一个进程上，怎么保证读写指针的线程安全<br>☯读写指针越过 FIFO 后，怎么处理<br>☯AudioTrack 写数据完成后，需要同步状态给 AudioFlinger，让 AudioFlinger 知道当前有可读数据了，而 AudioFlinger 读数据完成后，也需要同步状态给 AudioTrack，让 AudioTrack 知道当前有可用空间了；这里采取什么同步机制<br>我们回顾下创建 AudioTrack 对象时，FIFO 及其控制块的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MODE_STREAM 模式下的匿名共享内存结构：</span><br><span class="line">  |                                                         |</span><br><span class="line">  | -------------------&gt; mCblkMemory &lt;--------------------- |</span><br><span class="line">  |                                                         |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  | audio_track_cblk_t |               FIFO                 |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  ^                    ^</span><br><span class="line">  |                    |</span><br><span class="line">mCblk               mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = static_cast&lt;audio_track_cblk_t *&gt;(mCblkMemory-&gt;pointer());</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = (char*)mCblk + sizeof(audio_track_cblk_t);</span><br></pre></td></tr></table></figure><p>☯MODE_STATIC 模式下的匿名共享内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  | audio_track_cblk_t |    |         FIFO (sharedBuffer)       |</span><br><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  ^                         ^</span><br><span class="line">  |                         |</span><br><span class="line">mCblk                    mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = (audio_track_cblk_t *) new uint8_t[size];</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = sharedBuffer-&gt;pointer()</span><br></pre></td></tr></table></figure><p>FIFO 管理相关的类图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/315-Audio-system-FIFO.jpg" alt="Alt text"></p><p>☯AudioTrackClientProxy：MODE_STREAM 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯AudioTrackServerProxy：MODE_STREAM 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯StaticAudioTrackClientProxy：MODE_STATIC 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯StaticAudioTrackServerProxy：MODE_STATIC 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯AudioRecordClientProxy：消费者 AudioRecord 使用它在 FIFO 中找到可读数据的位置<br>☯AudioTrackServerProxy：生产者 AudioFlinger::RecordThread 使用它在 FIFO 中找到可用空间的位置<br>到这里，我决定结束本文了。环形 FIFO 管理是 Android 音频系统的精髓，一个小节并不足以描述其原理及实现细节；Android 环形 FIFO 的实现可说得上精妙绝伦，其他项目如果要用到环形 FIFO，不妨多借鉴它。</p><h4 id="四-、深入剖析MediaPlayer播放音频流程"><a href="#四-、深入剖析MediaPlayer播放音频流程" class="headerlink" title="(四)、深入剖析MediaPlayer播放音频流程"></a>(四)、深入剖析MediaPlayer播放音频流程</h4><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/316-Audio-system-mediaplayer-playback.png" alt="Alt text"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p></div><div class="post-announce">Thank you for reading, this article belongs to <a href="http://zhoujinjian.cc">๑Charles✦ˑ̫✦Vincent๑</a> copyright, if reproduced, please indicate the source：๑Charles✦ˑ̫✦Vincent๑（<a href="http://zhoujinjian.cc/2018/05/25/Audio System（3）：Android audio system(音频系统)分析/">http://zhoujinjian.cc/2018/05/25/Audio System（3）：Android audio system(音频系统)分析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/05/15/Audio System（2）：Linux ALSA音频系统分析/" title="Audio System（2）：Linux ALSA音频系统分析"><i class="iconfont icon-prev"></i>Audio System（2）：Linux ALSA音频系统分析</a></div><div class="post__prev post__prev--right"><a href="/2018/06/01/Android Video System（1）：Video System(视频系统)框架分析/" title="Android Video System（1）：Video System(视频系统)框架分析">Android Video System（1）：Video System(视频系统)框架分析<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。</p></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/Hexo/">Hexo</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">17</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/07/10/Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析/" title="Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.19.jpg" alt="Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析"></div><div class="item__info"><h3 class="item__title">Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析</h3><span class="item__text">2018-07-10</span></div></a></li><li class="latest-post-item"><a href="/2018/06/30/Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析/" title="Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.18.jpg" alt="Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析"></div><div class="item__info"><h3 class="item__title">Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析</h3><span class="item__text">2018-06-30</span></div></a></li><li class="latest-post-item"><a href="/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/" title="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.17.jpg" alt="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析"></div><div class="item__info"><h3 class="item__title">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</h3><span class="item__text">2018-06-06</span></div></a></li><li class="latest-post-item"><a href="/2018/06/01/Android Video System（1）：Video System(视频系统)框架分析/" title="Android Video System（1）：Video System(视频系统)框架分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" alt="Android Video System（1）：Video System(视频系统)框架分析"></div><div class="item__info"><h3 class="item__title">Android Video System（1）：Video System(视频系统)框架分析</h3><span class="item__text">2018-06-01</span></div></a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">开始的开始亦是结束•结束的结束亦是开始</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Room 103, Building 5, No. 5 Jiangtai Road, Shouxin Building, Chaoyang District, Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>zhou.jinjian@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/DreamWorks_2016_Stacked-MI-512x512.png" alt="logo" title="๑Charles✦ˑ̫✦Vincent๑"></div><div class="footer-top__item"><h3 class="item__title">Friend Links</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://keyin.me/" title="World of Forks" target="_blank">World of Forks</a></li><li class="list-item"><a href="https://molunerfinn.com/" title="MARKSZのBlog" target="_blank">MARKSZのBlog</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Hexo-theme-skapp" target="_blank">Hexo-theme-skapp</a></li><li class="list-item"><a href="http://zhoujinjian.cc/" title="๑Charles✦ˑ̫✦Vincent๑" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">Build Tools</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://dribbble.com/" title="Dribbble" target="_blank">Dribbble</a></li><li class="list-item"><a href="https://pages.github.com/" title="Blog Framework" target="_blank">Github-Pages</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Made by <a href="https://github.com/izhoujinjian" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/izhoujinjian" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:zhou.jinjian@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>🍀<span class="post-count">282.7k</span> </span><span>| </span><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>