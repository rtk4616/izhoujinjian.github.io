<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Audio System（1）：Linux && Android Audio 系统框架分析 | ๑Charles✦ˑ̫✦Vincent๑</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑"><meta name="designer" content="minfive"><meta name="keywords" content="zhoujinjian, zhoujinjian blog, Android, 源代码, ActivityManagerService, AMS, WindowManagerService, WMS , zygote ，InputManagerService , SurfaceFlinger, SystemServer , Binder , Graphics , Kernel , Linux"><meta name="description" content="嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta name="baidu-site-verification" content="7AVr5WpX72"><link rel="canonical" href="http://zhoujinjian.cc/2018/05/01/Audio System（1）：Linux && Android Audio 系统框架分析/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="๑Charles✦ˑ̫✦Vincent๑"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c54bda95ff8b34e8be2edd1d138812c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117331438-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-117331438-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading-small.gif)"></div><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="๑Charles✦ˑ̫✦Vincent๑" alt="๑Charles✦ˑ̫✦Vincent๑"><img src="/img/Logo.png" alt="๑Charles✦ˑ̫✦Vincent๑"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><div id="page" class="page js-hidden"><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.13.jpg" alt="Audio System（1）：Linux && Android Audio 系统框架分析"></div><header class="post__info"><h1 class="post__title">Audio System（1）：Linux && Android Audio 系统框架分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/izhoujinjian">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-05-01</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></header><div class="post__content"><div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）、音频基础知识"><span class="toc-text">（一）、音频基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1、响度-Loudness"><span class="toc-text">1.1、响度(Loudness)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2、音调-Pitch"><span class="toc-text">1.2、音调(Pitch)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3、音色-Quality"><span class="toc-text">1.3、音色(Quality)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-4、样本-Sample"><span class="toc-text">1.4、样本(Sample)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-5、采样器-Sampler"><span class="toc-text">1.5、采样器(Sampler)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-6、量化-Quantization"><span class="toc-text">1.6、量化(Quantization)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-7、编码-Coding"><span class="toc-text">1.7、编码(Coding)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-8、采样率（samplerate）"><span class="toc-text">1.8、采样率（samplerate）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-9、量化精度（位宽）"><span class="toc-text">1.9、量化精度（位宽）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-10、-声道数（channels）"><span class="toc-text">1.10、 声道数（channels）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-11、音频帧（frame）"><span class="toc-text">1.11、音频帧（frame）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-12、常见的音频编码方式有哪些？"><span class="toc-text">1.12、常见的音频编码方式有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-13、常见的音频压缩格式有哪些？"><span class="toc-text">1.13、常见的音频压缩格式有哪些？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-14、奈奎斯特采样理论"><span class="toc-text">1.14、奈奎斯特采样理论</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-15、总结（音频处理和播放过程）："><span class="toc-text">1.15、总结（音频处理和播放过程）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）、Audio-系统框架"><span class="toc-text">（二）、Audio 系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#总体Audio框架图"><span class="toc-text">总体Audio框架图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、APP"><span class="toc-text">2.1、APP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、Framework"><span class="toc-text">2.2、Framework</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、Libraries"><span class="toc-text">2.3、Libraries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4、HAL"><span class="toc-text">2.4、HAL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5、Tinyalsa"><span class="toc-text">2.5、Tinyalsa</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6、Kernel部分"><span class="toc-text">2.6、Kernel部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-1、ALSA-和-ASoC"><span class="toc-text">2.6.1、ALSA 和 ASoC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2、ASoC"><span class="toc-text">2.6.2、ASoC</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-1、Machine"><span class="toc-text">2.6.2.1、Machine</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-2、Platform"><span class="toc-text">2.6.2.2、Platform</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-2-3、Codec"><span class="toc-text">2.6.2.3、Codec</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-3、DAPM"><span class="toc-text">2.6.3、DAPM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-6-4、DPCM"><span class="toc-text">2.6.4、DPCM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-7、Audio-devices"><span class="toc-text">2.7、Audio devices</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）、Qualcomm平台-Audio系统框架"><span class="toc-text">（三）、Qualcomm平台 - Audio系统框架</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、Qualcomm-Audio系统总体框架图"><span class="toc-text">3.1、Qualcomm Audio系统总体框架图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2、ASoC-driver"><span class="toc-text">3.2、ASoC driver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1、Machine-driver"><span class="toc-text">3.2.1、Machine driver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-2、Platform-driver"><span class="toc-text">3.2.2、Platform driver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-3、CPU-driver"><span class="toc-text">3.2.3、CPU driver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-4、Codec-driver"><span class="toc-text">3.2.4、Codec driver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3、DSP-driver"><span class="toc-text">3.3、DSP driver</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4、User-Space"><span class="toc-text">3.4、User Space</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（四）、参考资料-特别感谢各位前辈的分析和图示-："><span class="toc-text">（四）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div><hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br><a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br><a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener">Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><h4 id="（一）、音频基础知识"><a href="#（一）、音频基础知识" class="headerlink" title="（一）、音频基础知识"></a>（一）、音频基础知识</h4><p>理解音频的一些基础知识，对于我们分析整个音频系统是大有裨益的。它可以让我们从实现的层面去思考，音频系统的目的是什么，然后才是怎么样去完成这个目的</p><p>#####（1）声音有哪些重要属性呢？</p><h5 id="1-1、响度-Loudness"><a href="#1-1、响度-Loudness" class="headerlink" title="1.1、响度(Loudness)"></a>1.1、响度(Loudness)</h5><p>响度就是人类可以感知到的各种声音的大小，也就是音量。响度与声波的振幅有直接关系。</p><h5 id="1-2、音调-Pitch"><a href="#1-2、音调-Pitch" class="headerlink" title="1.2、音调(Pitch)"></a>1.2、音调(Pitch)</h5><p>音调与声音的频率有关系，当声音的频率越大时，人耳所感知到的音调就越高，否则就越低。</p><h5 id="1-3、音色-Quality"><a href="#1-3、音色-Quality" class="headerlink" title="1.3、音色(Quality)"></a>1.3、音色(Quality)</h5><p>同一种乐器，使用不同的材质来制作，所表现出来的音色效果是不一样的，这是由物体本身的结构特性所决定的。</p><p>如何将各种媒体源数字化呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/11-Audio-system-1024px-A-D-A_Flow.svg.png" alt="Alt text"></p><p>将声波波形信号通过ADC转换成计算机支持的二进制的过程叫做音频采样(Audio Sampling)。采样(Sampling)的核心是把连续的模拟信号转换成离散的数字信号。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/12-Audio-system-sampling.png" alt="Alt text"></p><h5 id="1-4、样本-Sample"><a href="#1-4、样本-Sample" class="headerlink" title="1.4、样本(Sample)"></a>1.4、样本(Sample)</h5><p>这是我们进行采样的初始资料，比如一段连续的声音波形。</p><h5 id="1-5、采样器-Sampler"><a href="#1-5、采样器-Sampler" class="headerlink" title="1.5、采样器(Sampler)"></a>1.5、采样器(Sampler)</h5><p>采样器是将样本转换成终态信号的关键。它可以是一个子系统，也可以指一个操作过程，甚至是一个算法，取决于不同的信号处理场景。理想的采样器要求尽可能不产生信号失真。</p><h5 id="1-6、量化-Quantization"><a href="#1-6、量化-Quantization" class="headerlink" title="1.6、量化(Quantization)"></a>1.6、量化(Quantization)</h5><p>采样后的值还需要通过量化，也就是将连续值近似为某个范围内有限多个离散值的处理过程。因为原始数据是模拟的连续信号，而数字信号则是离散的，它的表达范围是有限的，所以量化是必不可少的一个步骤。</p><h5 id="1-7、编码-Coding"><a href="#1-7、编码-Coding" class="headerlink" title="1.7、编码(Coding)"></a>1.7、编码(Coding)</h5><p>计算机的世界里，所有数值都是用二进制表示的，因而我们还需要把量化值进行二进制编码。这一步通常与量化同时进行。</p><h5 id="1-8、采样率（samplerate）"><a href="#1-8、采样率（samplerate）" class="headerlink" title="1.8、采样率（samplerate）"></a>1.8、采样率（samplerate）</h5><p>采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用0101来表示的数字信号，示意图如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/13-Audio-system-sampling-rate.png.png" alt="Alt text"></p><p>蓝色代表模拟音频信号，红色的点代表采样得到的量化数值。</p><p>采样频率越高，红色的间隔就越密集，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。</p><p>根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。</p><p>通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。</p><h5 id="1-9、量化精度（位宽）"><a href="#1-9、量化精度（位宽）" class="headerlink" title="1.9、量化精度（位宽）"></a>1.9、量化精度（位宽）</h5><p>上图（1.8）中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。</p><p>常见的位宽是：8bit 或者 16bit</p><h5 id="1-10、-声道数（channels）"><a href="#1-10、-声道数（channels）" class="headerlink" title="1.10、 声道数（channels）"></a>1.10、 声道数（channels）</h5><p>由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。</p><p>单声道（Mono）和双声道（Stereo）比较常见，顾名思义，前者的声道数为1，后者为2</p><h5 id="1-11、音频帧（frame）"><a href="#1-11、音频帧（frame）" class="headerlink" title="1.11、音频帧（frame）"></a>1.11、音频帧（frame）</h5><p>这个概念在应用开发中非常重要，网上很多文章都没有专门介绍这个概念。</p><p>音频跟视频很不一样，视频每一帧就是一张图像，而从上面的正玄波可以看出，音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。</p><p>这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：</p><p>假设某音频信号是采样率为8kHz、双通道、位宽为16bit，20ms一帧，则一帧音频数据的大小为：</p><p>int size = 8000 x 2 x 16bit x 0.02s = 5120 bit = 640 byte</p><h5 id="1-12、常见的音频编码方式有哪些？"><a href="#1-12、常见的音频编码方式有哪些？" class="headerlink" title="1.12、常见的音频编码方式有哪些？"></a>1.12、常见的音频编码方式有哪些？</h5><p>上面提到过，模拟的音频信号转换为数字信号需要经过采样和量化，量化的过程被称之为编码，根据不同的量化策略，产生了许多不同的编码方式，常见的编码方式有：PCM 和 ADPCM，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。</p><p>我们在音频开发过程中，会经常涉及到WAV文件的读写，以验证采集、传输、接收的音频数据的正确性。</p><h5 id="1-13、常见的音频压缩格式有哪些？"><a href="#1-13、常见的音频压缩格式有哪些？" class="headerlink" title="1.13、常见的音频压缩格式有哪些？"></a>1.13、常见的音频压缩格式有哪些？</h5><p>首先简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。</p><p>（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。</p><p>（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。</p><p>下面简单列出常见的音频压缩格式：</p><p>MP3，AAC，OGG，WMA，Opus，FLAC，APE，M4A，AMR，等等</p><h5 id="1-14、奈奎斯特采样理论"><a href="#1-14、奈奎斯特采样理论" class="headerlink" title="1.14、奈奎斯特采样理论"></a>1.14、奈奎斯特采样理论</h5><p>“当对被采样的模拟信号进行还原时，其最高频率只有采样频率的一半”。<br>换句话说，如果我们要完整重构原始的模拟信号，则采样频率就必须是它的两倍以上。比如人的声音范围是2~ 20kHZ,那么选择的采样频率就应该在40kHZ左右，数值太小则声音将产生失真现象，而数值太大也无法明显提升人耳所能感知的音质。</p><h5 id="1-15、总结（音频处理和播放过程）："><a href="#1-15、总结（音频处理和播放过程）：" class="headerlink" title="1.15、总结（音频处理和播放过程）："></a>1.15、总结（音频处理和播放过程）：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/14-Audio-system-how-audio-works.png" alt="Alt text"></p><h4 id="（二）、Audio-系统框架"><a href="#（二）、Audio-系统框架" class="headerlink" title="（二）、Audio 系统框架"></a>（二）、Audio 系统框架</h4><h5 id="总体Audio框架图"><a href="#总体Audio框架图" class="headerlink" title="总体Audio框架图"></a>总体Audio框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/15-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><h5 id="2-1、APP"><a href="#2-1、APP" class="headerlink" title="2.1、APP"></a>2.1、APP</h5><p>音乐播放器软件等等。</p><h5 id="2-2、Framework"><a href="#2-2、Framework" class="headerlink" title="2.2、Framework"></a>2.2、Framework</h5><p>Android也提供了另两个相似功能的类，即AudioTrack和AudioRecorder，MediaPlayerService内部的实现就是通过它们来完成的,只不过MediaPlayer/MediaRecorder提供了更强大的控制功能，相比前者也更易于使用。除此以外，Android系统还为我们控制音频系统提供了AudioManager、AudioService及AudioSystem类。这些都是framework为便利上层应用开发所设计的。</p><h5 id="2-3、Libraries"><a href="#2-3、Libraries" class="headerlink" title="2.3、Libraries"></a>2.3、Libraries</h5><p>framework只是向应用程序提供访问Android库的桥梁，具体功能实现放在库中完成。比如上面的AudioTrack、AudioRecorder、MediaPlayer和MediaRecorder等等在库中都能找到相对应的类。</p><p>1、frameworks/av/media/libmedia【libmedia.so】<br>2、frameworks/av/services/audioflinger【libaudioflinger.so】<br>3、frameworks/av/media/libmediaplayerservice【libmediaplayerservice.so】</p><h5 id="2-4、HAL"><a href="#2-4、HAL" class="headerlink" title="2.4、HAL"></a>2.4、HAL</h5><p>从设计上来看，硬件抽象层是AudioFlinger直接访问的对象。这说明了两个问题，一方面AudioFlinger并不直接调用底层的驱动程序;另一方面，AudioFlinger上层模块只需要与它进行交互就可以实现音频相关的功能了。因而我们可以认为AudioFlinger是Android音频系统中真正的“隔离板”，无论下面如何变化，上层的实现都可以保持兼容。</p><p>音频方面的硬件抽象层主要分为两部分，即AudioFlinger和AudioPolicyService。实际上后者并不是一个真实的设备，只是采用虚拟设备的方式来让厂商可以方便地定制出自己的策略。抽象层的任务是将AudioFlinger/AudioPolicyService真正地与硬件设备关联起来，但又必须提供灵活的结构来应对变化——特别是对于Android这个更新相当频繁的系统。比如以前Android系统中的Audio系统依赖于ALSA-lib，但后期就变为了tinyalsa，这样的转变不应该对上层造成破坏。因而Audio HAL提供了统一的接口来定义它与AudioFlinger/AudioPolicyService之间的通信方式，这就是audio_hw_device、audio_stream_in及audio_stream_out等等存在的目的，这些Struct数据类型内部大多只是函数指针的定义，是一些“壳”。当AudioFlinger/AudioPolicyService初始化时，它们会去寻找系统中最匹配的实现(这些实现驻留在以audio.primary.<em>,audio.a2dp.</em>为名的各种库中)来填充这些“壳”。根据产品的不同，音频设备存在很大差异，在Android的音频架构中，这些问题都是由HAL层的audio.primary等等库来解决的，而不需要大规模地修改上层实现。换句话说，厂商在定制时的重点就是如何提供这部分库的高效实现了。</p><h5 id="2-5、Tinyalsa"><a href="#2-5、Tinyalsa" class="headerlink" title="2.5、Tinyalsa"></a>2.5、Tinyalsa</h5><p>源码在external/tinyalsa目录下<br>Tinyalsa：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制</p><h5 id="2-6、Kernel部分"><a href="#2-6、Kernel部分" class="headerlink" title="2.6、Kernel部分"></a>2.6、Kernel部分</h5><h5 id="2-6-1、ALSA-和-ASoC"><a href="#2-6-1、ALSA-和-ASoC" class="headerlink" title="2.6.1、ALSA 和 ASoC"></a>2.6.1、ALSA 和 ASoC</h5><p>Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><h5 id="2-6-2、ASoC"><a href="#2-6-2、ASoC" class="headerlink" title="2.6.2、ASoC"></a>2.6.2、ASoC</h5><p>ASoC被分为Machine、Platform和Codec三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p><h5 id="2-6-2-1、Machine"><a href="#2-6-2-1、Machine" class="headerlink" title="2.6.2.1、Machine"></a>2.6.2.1、<strong>Machine</strong></h5><p>用于描述设备组件信息和特定的控制如耳机/外放等。</p><blockquote><p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。</p></blockquote><p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p><h5 id="2-6-2-2、Platform"><a href="#2-6-2-2、Platform" class="headerlink" title="2.6.2.2、Platform"></a>2.6.2.2、<strong>Platform</strong></h5><p>用于实现平台相关的DMA驱动和音频接口等。</p><blockquote><p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p></blockquote><p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：DMA引擎和SoC集成的PCM、I2S或AC ‘97数字接口控制。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：snd_soc_platform_driver和snd_soc_dai_driver。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p><h5 id="2-6-2-3、Codec"><a href="#2-6-2-3、Codec" class="headerlink" title="2.6.2.3、Codec"></a>2.6.2.3、<strong>Codec</strong></h5><p>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</p><blockquote><p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p></blockquote><p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p><p>1、对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。<br>2、对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。<br>3、对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。<br>4、对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</p><p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/16-Audio-system-asoc-pcm-control.png" alt="Alt text"></p><p>ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p><p>☁ Codec驱动向ASoC注册snd_soc_codec和snd_soc_dai设备。<br>☁ Platform驱动向ASoC注册snd_soc_platform和snd_soc_dai设备。<br>☁ Machine驱动通过snd_soc_dai_link绑定codec/dai/platform。</p><p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p><p>☁ path描述与其它widget的连接关系。<br>☁ event用于通知该widget的上下电状态。<br>☁ power指示当前的上电状态。<br>☁ control实现空间用户接口用于控制widget的音量/通路切换等。</p><p>对驱动开者来说，就可以很好的解耦了：</p><p>☁ codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了;<br>☁ soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等;<br>☁ 板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。</p><h5 id="2-6-3、DAPM"><a href="#2-6-3、DAPM" class="headerlink" title="2.6.3、DAPM"></a>2.6.3、<strong>DAPM</strong></h5><p>DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><h5 id="2-6-4、DPCM"><a href="#2-6-4、DPCM" class="headerlink" title="2.6.4、DPCM"></a>2.6.4、<strong>DPCM</strong></h5><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/sound/soc/dpcm.rst?h=v4.16-rc5" target="_blank" rel="noopener">Dynamic PCM</a></p><h5 id="2-7、Audio-devices"><a href="#2-7、Audio-devices" class="headerlink" title="2.7、Audio devices"></a>2.7、Audio devices</h5><p>具体的Audio硬件设备。</p><h4 id="（三）、Qualcomm平台-Audio系统框架"><a href="#（三）、Qualcomm平台-Audio系统框架" class="headerlink" title="（三）、Qualcomm平台 - Audio系统框架"></a>（三）、Qualcomm平台 - Audio系统框架</h4><p>由于接下来的一系列Android &amp;&amp; kernel 源码分析都是基于Qualcomm 平台的，十分有必要介绍Qualcomm 平台的Audio 系统框架。硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><h5 id="3-1、Qualcomm-Audio系统总体框架图"><a href="#3-1、Qualcomm-Audio系统总体框架图" class="headerlink" title="3.1、Qualcomm Audio系统总体框架图"></a>3.1、Qualcomm Audio系统总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/17-MSM8996-Linux-Android-Audio-Software-Overview-Architecture.png" alt="Alt text"></p><h5 id="3-2、ASoC-driver"><a href="#3-2、ASoC-driver" class="headerlink" title="3.2、ASoC driver"></a>3.2、ASoC driver</h5><p>ALSA 片上系统 (ASoC) 驱动程序将音频系统分为四个组成部分Machine driver、Platform driver、CPU driver、Codec driver。</p><h5 id="3-2-1、Machine-driver"><a href="#3-2-1、Machine-driver" class="headerlink" title="3.2.1、Machine driver"></a>3.2.1、Machine driver</h5><p>将平台、CPU 和编解码驱动程序整合在一起<br>kernel/sound/soc/msm/<chipset>.c<br>定义Frontend (FE) and Backend (BE), Digital Audio Interface (DAI) links</chipset></p><h5 id="3-2-2、Platform-driver"><a href="#3-2-2、Platform-driver" class="headerlink" title="3.2.2、Platform driver"></a>3.2.2、Platform driver</h5><p>包含用于流数据传输与路由的平台特定的控件（control）， 细分为 FE 和 BE 平台驱动程序<br><strong>FE</strong><br> Audio – 实例化 PCM 播放和录制会话；借助 ASM 接口，将 PCM 数据从用户空间传输到 DSP 进行播放<br>以及从 DSP 传输到用户空间进行录制 – 在 kernel/sound/soc/msm-pcm-q6-v2.c 中实现<br> Voice – 初始化/取消初始化语音呼叫设置 – 在 kernel/sound/soc/msm-pcm-voice-v2.c 中实现<br> VoIP – 初始化/取消初始化 MVS 接口以传输自/至 DSP 的 PCM 数据 – 在kernel/sound/soc/msm-pcmvoip-v2.c<br>中实现<br> Compressed offload – 支持将压缩数据发送到 DSP 进行压缩分流播放 – 在 kernel/sound/soc/msm-compress-q6-<br>v2.c 中实现<br><strong>BE</strong><br> 路由 – 执行音频路由任务 – 在 /kernel/sound/soc/msm-pcm-routing-v2.c 中实现</p><h5 id="3-2-3、CPU-driver"><a href="#3-2-3、CPU-driver" class="headerlink" title="3.2.3、CPU driver"></a>3.2.3、CPU driver</h5><p><strong>FE</strong><br> 向 ASoC 框架提供关于 FE PCM 设备的信息<br> ASoC 框架与平台驱动程序提供的路由表共同将 PCM 播放/捕获从 FE 传递至 BE<br> 没有针对播放和录制的内置逻辑<br> 定义 FE CPU DAI – 在 kernel/sound/soc/msm/msm-dai-fe.c 中实现<br><strong>BE</strong><br> 要在初始化 PCM 播放/捕获时激活所需音频硬件端口，则配置 DSP AFE 模块<br> 定义 BE CPU DAI – 在 kernel/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c 中实现</p><h5 id="3-2-4、Codec-driver"><a href="#3-2-4、Codec-driver" class="headerlink" title="3.2.4、Codec driver"></a>3.2.4、Codec driver</h5><p>与平台无关，其中包含音频控制、音频接口功能、编解码器 DAPM 定义以及编解<br>码器输入输出功能<br> 此外，实现 MBHC 状态机，用于检测有线耳机插入/拔出、附件类型、连接器类型<br>和多按钮检测</p><h5 id="3-3、DSP-driver"><a href="#3-3、DSP-driver" class="headerlink" title="3.3、DSP driver"></a>3.3、DSP driver</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/18-MSM8996-Linux-Android-Audio-ADSP-Architecture.png" alt="Alt text"></p><p><strong>ASM（Audio Stream Manager）</strong><br> 用于与 DSP ASM 模块通信的接口<br> 提供将 PCM 数据路由至 DSP 的机制，支持按数据流进行后期处理/预处理<br><strong>ADM（Audio Device Manager）</strong><br> 允许在 DSP 中使用 ADM 服务<br> 配置 COPP 和路由矩阵<br> 与音频校准数据库 (ACDB) 进行通信，使用正确的校准数据配置 COPP<br> 将 ASM 会话 ID 路由至 ADM 会话<br><strong>AFE（Audio Front-End）</strong><br> 允许在 DSP 中使用 AFE 服务<br> 激活/禁用音频硬件端口<br> 子系统管理器 – 发生 MDSP 复位事件时，通知音频和语音驱动程序关闭待处理<br>会话、执行清理操作并等待一个指示 MDSP 已启动的事件<br><strong>APR（Asynchronous Packet Router）</strong><br> 为处理器间通信提供异步框架<br> 用于与 Hexagon 和调制解调器处理器进行通信<br> Image loader PIL – 载入 MDSP 图像</p><h5 id="3-4、User-Space"><a href="#3-4、User-Space" class="headerlink" title="3.4、User Space"></a>3.4、User Space</h5><p> Audio Hardware Abstraction Layer (AHAL) – 通过 tinyALSA 将 AudioFlinger<br>调用映射至ASoC 驱动程序的硬件抽象层。<br> ACDB loader – 检索特定设备的校准信息，并写入 PMEM。ACDB 驱动程<br>序在启动过程中分配该 PMEM。在设备切换时，此校准将被发送到 DSP。<br> tinyALSA – 连接至内核 ASoC 驱动程序的接口，供音频 HAL 使用。提供用<br>于音频流和设备管理的基本 PCM 和混音控件 API。<br> Audio route – 此模块会从一个 .xml 文件读取 ALSA 混音控件，并根据音频<br>HAL 所选的设备设置混音控件。<br> Concurrency Manager - 在MSM8x10中，视频解码和编码在DSP中完成; 因此，有<br>对可支持的并发性有一些限制。MSM8x10中引入的并发管理器管理并发性<br>可以支持涉及语音和音频的不同用例</p><p>Multimedia framework – Stagefright<br> 支持标准音频格式的播放/录制<br> 与解码器/编码器库以及 OpenMAX IL 组件通信，以便进行解码和编码</p><p>Audio service<br> 由系统服务器启动并由服务管理器管理的运行时服务之一<br> 意图注册；当从各种应用程序（HDMI、蓝牙等）接收到这些意图时，通知音频<br>系统</p><p>AudioFlinger<br> 通过 libaudio 接口、蓝牙 A2DP 接口管理所有音频输出/输入设备<br> 将多个音频流处理为单一的 PCM 音频；混合后的输出被传送到输出设备<br> 播放音乐流时的音量</p><p>Audio Policy Manager (APM)<br> 定义多个音频用例之间的并发规则<br> 用例示例 – 电话通话、音乐播放、系统声音和通知<br> 定义播放的音频（例如：语音、播放、铃声）以及播放的设备（蓝牙、扬声器<br>和耳机）<br>APM 用途：<br> 管理各种输入输出设备接口<br> 管理各种输入输出设备，例如：麦克风、扬声器、耳机、听筒、A2DP、蓝牙 SCO<br> 基于音频流、模式和方法选择和定义适当的路由策略<br> 管理每个音频流的音量/静音设置（在它们激活或禁用时）</p><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p></div><div class="post-announce">Thank you for reading, this article belongs to <a href="http://zhoujinjian.cc">๑Charles✦ˑ̫✦Vincent๑</a> copyright, if reproduced, please indicate the source：๑Charles✦ˑ̫✦Vincent๑（<a href="http://zhoujinjian.cc/2018/05/01/Audio System（1）：Linux && Android Audio 系统框架分析/">http://zhoujinjian.cc/2018/05/01/Audio System（1）：Linux && Android Audio 系统框架分析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/04/20/Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功/" title="Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功 [i.wonder~]"><i class="iconfont icon-prev"></i>Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功 [i.wonder~]</a></div><div class="post__prev post__prev--right"><a href="/2018/05/15/Audio System（2）：Linux ALSA音频系统分析/" title="Audio System（2）：Linux ALSA音频系统分析">Audio System（2）：Linux ALSA音频系统分析<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。</p></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/Hexo/">Hexo</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">21</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/08/30/Android Display System（5）：Android Display System 系统分析之Display Driver Architecture/" title="Android Display System（5）：Android Display System 系统分析之Display Driver Architecture"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.23.jpg" alt="Android Display System（5）：Android Display System 系统分析之Display Driver Architecture"></div><div class="item__info"><h3 class="item__title">Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</h3><span class="item__text">2018-08-30</span></div></a></li><li class="latest-post-item"><a href="/2018/08/16/Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析/" title="Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.22.jpg" alt="Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"></div><div class="item__info"><h3 class="item__title">Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析</h3><span class="item__text">2018-08-16</span></div></a></li><li class="latest-post-item"><a href="/2018/08/01/Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析/" title="Android Display System（3）：Android Display System 系统分析 之  HardwareRenderer.draw()绘制流程分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.21.jpg" alt="Android Display System（3）：Android Display System 系统分析 之  HardwareRenderer.draw()绘制流程分析"></div><div class="item__info"><h3 class="item__title">Android Display System（3）：Android Display System 系统分析 之 HardwareRenderer.draw()绘制流程分析</h3><span class="item__text">2018-08-01</span></div></a></li><li class="latest-post-item"><a href="/2018/07/20/Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL/" title="Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.20.jpg" alt="Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL"></div><div class="item__info"><h3 class="item__title">Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL</h3><span class="item__text">2018-07-20</span></div></a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">开始的开始亦是结束•结束的结束亦是开始</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Room 103, Building 5, No. 5 Jiangtai Road, Shouxin Building, Chaoyang District, Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>zhou.jinjian@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/DreamWorks_2016_Stacked-MI-512x512.png" alt="logo" title="๑Charles✦ˑ̫✦Vincent๑"></div><div class="footer-top__item"><h3 class="item__title">Friend Links</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://keyin.me/" title="World of Forks" target="_blank">World of Forks</a></li><li class="list-item"><a href="https://molunerfinn.com/" title="MARKSZのBlog" target="_blank">MARKSZのBlog</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Hexo-theme-skapp" target="_blank">Hexo-theme-skapp</a></li><li class="list-item"><a href="http://zhoujinjian.cc/" title="๑Charles✦ˑ̫✦Vincent๑" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">Build Tools</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://dribbble.com/" title="Dribbble" target="_blank">Dribbble</a></li><li class="list-item"><a href="https://pages.github.com/" title="Blog Framework" target="_blank">Github-Pages</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Made by <a href="https://github.com/izhoujinjian" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/izhoujinjian" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:zhou.jinjian@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>🍀<span class="post-count">327.5k</span> </span><span>| </span><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>