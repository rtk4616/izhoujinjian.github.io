<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Android Video System（9）：Android Multimedia Codecs - H264编解码分析 | ๑Charles✦ˑ̫✦Vincent๑</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑"><meta name="designer" content="minfive"><meta name="keywords" content="zhoujinjian, zhoujinjian blog, Android, 源代码, ActivityManagerService, AMS, WindowManagerService, WMS , zygote ，InputManagerService , SurfaceFlinger, SystemServer , Binder , Graphics , Kernel , Linux"><meta name="description" content="嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta name="baidu-site-verification" content="7AVr5WpX72"><link rel="canonical" href="http://zhoujinjian.cc/2018/10/06/Android Video System（9）：Android Multimedia Codecs - H264编解码分析/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="๑Charles✦ˑ̫✦Vincent๑"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c54bda95ff8b34e8be2edd1d138812c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117331438-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-117331438-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading-small.gif)"></div><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="๑Charles✦ˑ̫✦Vincent๑" alt="๑Charles✦ˑ̫✦Vincent๑"><img src="/img/Logo.png" alt="๑Charles✦ˑ̫✦Vincent๑"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><div id="page" class="page js-hidden"><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.31.jpg" alt="Android Video System（9）：Android Multimedia Codecs - H264编解码分析"></div><header class="post__info"><h1 class="post__title">Android Video System（9）：Android Multimedia Codecs - H264编解码分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/izhoujinjian">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-10-06</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></header><div class="post__content"><div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）、从零了解H264结构（概览）"><span class="toc-text">（一）、从零了解H264结构（概览）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-0、前言"><span class="toc-text">1.0、前言</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1、原理"><span class="toc-text">1.1、原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1-NAL-Header"><span class="toc-text">1.1.1. NAL Header</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2-RBSP"><span class="toc-text">1.1.2. RBSP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2、从NALU出发了解H-264里面的专业词语"><span class="toc-text">1.2、从NALU出发了解H.264里面的专业词语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-1-Slice-片"><span class="toc-text">1.2.1. Slice(片)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-2-宏块-Macroblock"><span class="toc-text">1.2.2. 宏块(Macroblock)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-图像-场和帧"><span class="toc-text">1.2.3. 图像,场和帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-4-I-P-B帧与pts-dts"><span class="toc-text">1.2.4. I,P,B帧与pts/dts</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-5-GOP"><span class="toc-text">1.2.5. GOP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-6-IDR"><span class="toc-text">1.2.6 . IDR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-帧内预测和帧间预测"><span class="toc-text">1.3. 帧内预测和帧间预测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-帧内预测（也叫帧内压缩）"><span class="toc-text">1.3. 1. 帧内预测（也叫帧内压缩）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-帧间预测（也叫帧间压缩）"><span class="toc-text">1.3. 2. 帧间预测（也叫帧间压缩）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）、Android-H264编码"><span class="toc-text">（二）、Android H264编码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、SoftAVC-initEncoder"><span class="toc-text">2.1、SoftAVC::initEncoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、SoftAVC-onQueueFilled"><span class="toc-text">2.2、SoftAVC::onQueueFilled()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、ih264e-encode"><span class="toc-text">2.3、ih264e_encode()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）、Android-H264解码"><span class="toc-text">（三）、Android H264解码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、SoftAVC-initDecoder"><span class="toc-text">3.1、SoftAVC::initDecoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2、SoftAVC-onQueueFilled"><span class="toc-text">3.2、SoftAVC::onQueueFilled()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3、WORD32-ih264d-video-decode"><span class="toc-text">3.3、WORD32 ih264d_video_decode()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（四）、libavc库分析"><span class="toc-text">（四）、libavc库分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（五）、Others编解码"><span class="toc-text">（五）、Others编解码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（六）、参考资料-特别感谢各位前辈的分析和图示-："><span class="toc-text">（六）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div><hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/android.codecs" target="_blank" rel="noopener">【博客原图链接】</a></p><p>首先感谢：</p><p><a href="http://www.iosxxx.com/blog/2017-08-09-%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3H264%E7%BB%93%E6%9E%84.html" target="_blank" rel="noopener">【从零了解H264结构】</a></p><p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，再次感谢！！！</p><p>Google Pixel、Pixel XL 内核代码（==<strong>文章基于 Kernel-3.x</strong>==）：<br><a href="https://github.com/nathanchance/wahoo" target="_blank" rel="noopener">Kernel source for Pixel 2 (walleye) and Pixel 2 XL (taimen) - GitHub</a></p><p>AOSP 源码（==<strong>文章基于 Android 7.x</strong>==）：<br><a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener">Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\frameworks\av\media\libstagefright\omx\SoftOMXPlugin.cpp</span><br><span class="line">kComponents[] = &#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123; <span class="string">"OMX.google.h264.decoder"</span>, <span class="string">"avcdec"</span>, <span class="string">"video_decoder.avc"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"OMX.google.h264.encoder"</span>, <span class="string">"avcenc"</span>, <span class="string">"video_encoder.avc"</span> &#125;,</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>==源码（部分）==：</p><blockquote><p>PATH : \frameworks\av\media\libstagefright\codecs （Android Codecs）</p></blockquote><ul><li>avc</li><li>avcdec</li><li>avcenc</li></ul><blockquote><p>\external\libavc（libavc 库）</p></blockquote><ul><li>encoder</li><li>decoder</li><li>common</li></ul><blockquote><p>hardware\qcom\media（Qcom）</p></blockquote><ul><li>mm-core</li><li>libstagefrighthw</li><li>mm-video-v4l2</li></ul><p>Log：<br><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/H264-Decorder-Google-log.md" target="_blank" rel="noopener">H264-Decorder-Google-log.md</a><br><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/H264-Encorder-QCom-log.md" target="_blank" rel="noopener">H264-Encorder-QCom-log.md</a></p><hr><h4 id="（一）、从零了解H264结构（概览）"><a href="#（一）、从零了解H264结构（概览）" class="headerlink" title="（一）、从零了解H264结构（概览）"></a>（一）、从零了解H264结构（概览）</h4><h5 id="1-0、前言"><a href="#1-0、前言" class="headerlink" title="1.0、前言"></a>1.0、前言</h5><p>为什么需要编码呢？比如当前屏幕是1280*720.一秒24张图片.那么我们一秒的视频数据是</p><blockquote><p>1280<em>720(位像素)</em>24(张) / 8(1字节8位)(结果:B) / 1024(结果:KB) / 1024 (结果:MB) = 2.64MB</p></blockquote><p>一秒的数据有2.64MB数据量。1分钟就会有100多MB。这对用户来说真心是灾难。所以现在我们需要一种压缩方式减小数据的大小.在更低 比特率(bps)的情况下依然提供清晰的视频。<br>H264: H264/AVC是广泛采用的一种编码方式。我们这边会带大家了解。从大到小排序依次是 序列，图像，片组，片，NALU，宏块，亚宏块，块，像素。</p><h5 id="1-1、原理"><a href="#1-1、原理" class="headerlink" title="1.1、原理"></a>1.1、原理</h5><p>H.264原始码流(裸流)是由一个接一个NALU组成，它的功能分为两层，VCL(视频编码层)和 NAL(网络提取层).</p><blockquote><p>VCL(Video Coding Layer) + NAL(Network Abstraction Layer).</p></blockquote><p>1.VCL：包括核心压缩引擎和块，宏块和片的语法级别定义，设计目标是尽可能地独立于网络进行高效的编码；<br>2.NAL：负责将VCL产生的比特字符串适配到各种各样的网络和多元环境中，覆盖了所有片级以上的语法级别。</p><p>在VCL进行数据传输或存储之前，这些编码的VCL数据，被映射或封装进NAL单元。（NALU）。</p><blockquote><p>一个NALU = 一组对应于视频编码的NALU头部信息 + 一个原始字节序列负荷(RBSP,Raw Byte Sequence Payload).</p></blockquote><p>如图所示，下图中的NALU的头 + RBSP 就相当于一个NALU(Nal Unit),每个单元都按独立的NALU传送。H.264的结构全部都是以NALU为主，理解了NALU，就理解了H.264的结构。<br>一个原始的H.264 NALU 单元常由 [StartCode] [NALU Header] [NALU Payload] 三部分组成，其中 Start Code 用于标示这是一个NALU 单元的开始，必须是”00 00 00 01” 或”00 00 01”<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-01-H264 NALU headerRBSP.png" alt="Alt text | center"></p><h5 id="1-1-1-NAL-Header"><a href="#1-1-1-NAL-Header" class="headerlink" title="1.1.1. NAL Header"></a>1.1.1. NAL Header</h5><p>由三部分组成，forbidden_bit(1bit)，nal_reference_bit(2bits)（优先级），nal_unit_type(5bits)（类型）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-02-H264.NAL Header.png" alt="Alt text | center"></p><p>举例来说：</p><blockquote><p>00 00 00 01 06: SEI信息<br>00 00 00 01 67: 0x67&amp;0x1f = 0x07 :SPS<br>00 00 00 01 68: 0x68&amp;0x1f = 0x08 :PPS<br>00 00 00 01 65: 0x65&amp;0x1f = 0x05: IDR Slice</p></blockquote><h5 id="1-1-2-RBSP"><a href="#1-1-2-RBSP" class="headerlink" title="1.1.2. RBSP"></a>1.1.2. RBSP</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-03-H264.RBSP.png" alt="Alt text | center"></p><p>图 6.69 RBSP 序列举例</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-04-H264.RBSP.describle.png" alt="Alt text | center"></p><p><strong>SODB与RBSP</strong><br>SODB 数据比特串 -&gt; 是编码后的原始数据.<br>RBSP 原始字节序列载荷 -&gt; 在原始编码数据的后面添加了 结尾比特。一个 bit“1”若干比特“0”，以便字节对齐。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-05-H264.RBSP.SODB.png" alt="Alt text | center"></p><h5 id="1-2、从NALU出发了解H-264里面的专业词语"><a href="#1-2、从NALU出发了解H-264里面的专业词语" class="headerlink" title="1.2、从NALU出发了解H.264里面的专业词语"></a>1.2、从NALU出发了解H.264里面的专业词语</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-06-H264.Slice.Layer.png" alt="Alt text | center"></p><blockquote><p>1帧 = n个片<br>1片 = n个宏块<br>1宏块 = 16x16yuv数据</p></blockquote><h5 id="1-2-1-Slice-片"><a href="#1-2-1-Slice-片" class="headerlink" title="1.2.1. Slice(片)"></a>1.2.1. Slice(片)</h5><p>如图所示，NALU的主体中包含了Slice(片).</p><blockquote><p>一个片 = Slice Header + Slice Data</p></blockquote><p>片是H.264提出的新概念，通过编码图片后切分通过高效的方式整合出来的概念。一张图片有一个或者多个片，而片由NALU装载并进行网络传输的。但是NALU不一定是切片，这是充分不必要条件，因为 NALU 还有可能装载着其他用作描述视频的信息.</p><p>那么为什么要设置片呢?<br>设置片的目的是为了限制误码的扩散和传输，应使编码片相互间是独立的。某片的预测不能以其他片中的宏块为参考图像，这样某一片中的预测误差才不会传播到其他片中。</p><p>可以看到上图中，每个图像中，若干宏块(Macroblock)被排列成片。一个视频图像可编程一个或更多个片，每片包含整数个宏块 (MB),每片至少包含一个宏块。<br>片有一下五种类型:</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-07-H264.I.P.B..png" alt="Alt text | center"></p><h5 id="1-2-2-宏块-Macroblock"><a href="#1-2-2-宏块-Macroblock" class="headerlink" title="1.2.2. 宏块(Macroblock)"></a>1.2.2. 宏块(Macroblock)</h5><p>刚才在片中提到了宏块.那么什么是宏块呢？<br>宏块是视频信息的主要承载者。一个编码图像通常划分为多个宏块组成.包含着每一个像素的亮度和色度信息。视频解码最主要的工作则是提供高效的方式从码流中获得宏块中像素阵列。</p><blockquote><p>一个宏块 = 一个16*16的亮度像素 + 一个8×8Cb + 一个8×8Cr彩色像素块组成。(YCbCr 是属于 YUV<br>家族的一员,在YCbCr 中 Y 是指亮度分量，Cb 指蓝色色度分量，而 Cr 指红色色度分量)</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-08-H264.Macroblock.png" alt="Alt text | center"></p><p>分层结构,在 H.264 中，句法元素共被组织成 序列、图像、片、宏块、子宏块五个层次。<br>句法元素的分层结构有助于更有效地节省码流。例如，再一个图像中，经常会在各个片之间有相同的数据，如果每个片都同时携带这些数据，势必会造成码流的浪费。更为有效的做法是将该图像的公共信息抽取出来，形成图像一级的句法元素，而在片级只携带该片自身独有的句法元素。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-09-H264.slice.header.data.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-10-H264.slice.header.data-detail.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-11-H264.Macroblock_type.png.png" alt="Alt text | center"></p><h5 id="1-2-3-图像-场和帧"><a href="#1-2-3-图像-场和帧" class="headerlink" title="1.2.3. 图像,场和帧"></a>1.2.3. 图像,场和帧</h5><p>图像是个集合概念，顶 场、底场、帧都可以称为图像。对于H.264 协议来说，我们平常所熟悉的那些称呼，例如： I 帧、P 帧、B帧等等，实际上都是我们把图像这个概念具体化和细小化了。我们 在 H.264里提到的“帧”通常就是指不分场的图像；</p><p>视频的一场或一帧可用来产生一个编码图像。一帧通常是一个完整的图像。当采集视频信号时，如果采用隔行扫描(奇.偶数行),则扫描下来的一帧图像就被分为了两个部分,这每一部分就被称为 [场],根据次序氛围: [顶场] 和 [底场]。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-12-H264.zuoyongyu.png" alt="Alt text | center"></p><h5 id="1-2-4-I-P-B帧与pts-dts"><a href="#1-2-4-I-P-B帧与pts-dts" class="headerlink" title="1.2.4. I,P,B帧与pts/dts"></a>1.2.4. I,P,B帧与pts/dts</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-13-H264.PTS.DTS.png" alt="Alt text | center"></p><p>DTS与PTS的不同:<br>DTS主要用户视频的解码，在解码阶段使用。PTS主要用于视频的同步和输出，在display的时候使用。再没有B frame的时候输出顺序一样。</p><h5 id="1-2-5-GOP"><a href="#1-2-5-GOP" class="headerlink" title="1.2.5. GOP"></a>1.2.5. GOP</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-14-H264.GOP.png" alt="Alt text | center"></p><p>GOP是画面组，一个GOP是一组连续的画面。<br>GOP一般有两个数字，如M=3，N=12.M制定I帧与P帧之间的距离，N指定两个I帧之间的距离。那么现在的GOP结构是</p><blockquote><p>I BBP BBP BBP BB I</p></blockquote><p>增大图片组能有效的减少编码后的视频体积，但是也会降低视频质量，至于怎么取舍，得看需求了</p><h5 id="1-2-6-IDR"><a href="#1-2-6-IDR" class="headerlink" title="1.2.6 . IDR"></a>1.2.6 . IDR</h5><p>一个序列的第一个图像叫做 IDR 图像（立即刷新图像），IDR 图像都是 I 帧图像。<br>I和IDR帧都使用帧内预测。I帧不用参考任何帧，但是之后的P帧和B帧是有可能参考这个I帧之前的帧的。IDR就不允许这样。<br>比如这种情况:<br>IDR1 P4 B2 B3 P7 B5 B6 I10 B8 B9 P13 B11 B12 P16 B14 B15 这里的B8可以跨过I10去参考P7</p><p>核心作用：<br>H.264 引入 IDR 图像是为了解码的重同步，当解码器解码到 IDR 图像时，立即将参考帧队列清空，将已解码的数据全部输出或抛弃，重新查找参数集，开始一个新的序列。这样，如果前一个序列出现重大错误，在这里可以获得重新同步的机会。IDR图像之后的图像永远不会使用IDR之前的图像的数据来解码。</p><h5 id="1-3-帧内预测和帧间预测"><a href="#1-3-帧内预测和帧间预测" class="headerlink" title="1.3. 帧内预测和帧间预测"></a>1.3. 帧内预测和帧间预测</h5><h5 id="1-3-1-帧内预测（也叫帧内压缩）"><a href="#1-3-1-帧内预测（也叫帧内压缩）" class="headerlink" title="1.3. 1. 帧内预测（也叫帧内压缩）"></a>1.3. 1. 帧内预测（也叫帧内压缩）</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-15-H264.zenjianyuce.png" alt="Alt text | center"></p><p>我们可以通过第 1、2、3、4、5 块的编码来推测和计算第 6 块的编码，因此就不需要对第 6 块进行编码了，从而压缩了第 6 块，节省了空间</p><h5 id="1-3-2-帧间预测（也叫帧间压缩）"><a href="#1-3-2-帧间预测（也叫帧间压缩）" class="headerlink" title="1.3. 2. 帧间预测（也叫帧间压缩）"></a>1.3. 2. 帧间预测（也叫帧间压缩）</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-16-H264.zenjianyasuo.png" alt="Alt text | center"></p><p>可以看到前后两帧的差异其实是很小的，这时候用帧间压缩就很有意义。<br>这里涉及到几个重要的概念：块匹配，残差，运动搜索(运动估计),运动补偿.</p><p>帧间压缩最常用的方式就是块匹配(Block Matching)。找找看前面已经编码的几帧里面，和我当前这个块最类似的一个块，这样我不用编码当前块的内容了，只需要编码当前块和我找到的快的差异(残差)即可。找最想的块的过程叫运动搜索(Motion Search),又叫运动估计。用残差和原来的块就能推算出当前块的过程叫运动补偿(Motion Compensation).</p><h4 id="（二）、Android-H264编码"><a href="#（二）、Android-H264编码" class="headerlink" title="（二）、Android  H264编码"></a>（二）、Android H264编码</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-17-H264-Encoder-google.png" alt="Alt text | center"></p><p>由于博主的手机为Qcom平台，支持h264编解码，博主保留了Qcom h264 Encoder ，将Decoder使用Google的，但分析主要还是以Google的H264 Encoder/Decoder 为主。<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[/system/etc/media_codecs.xml]</span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Decoder capabilities for thorium</span></span><br><span class="line"><span class="comment">   _________________________________________________________________________</span></span><br><span class="line"><span class="comment">  | Codec    | W       H       fps     Mbps    MB/s    | Encode Secure-dec |</span></span><br><span class="line"><span class="comment">  |__________|_________________________________________|___________________|</span></span><br><span class="line"><span class="comment">  | h264     | 1920    1088    30      20      244800  |  Y       N        |</span></span><br><span class="line"><span class="comment">  | hevc     | 1920    1088    30      20      244800  |  N       N        |</span></span><br><span class="line"><span class="comment">  | mpeg4    | 1920    1088    30      6       244800  |  Y       N        |</span></span><br><span class="line"><span class="comment">  | vp8      | 1920    1088    30      20      244800  |  N       N        |</span></span><br><span class="line"><span class="comment">  | div4/5/6 | 1920    1088    30      6       244800  |  N       N        |</span></span><br><span class="line"><span class="comment">  | h263     |  864     480    30      2       48600   |  Y       N        |</span></span><br><span class="line"><span class="comment">  |__________|_________________________________________|___________________|</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  Encoder capabilities for thorium</span></span><br><span class="line"><span class="comment">   ____________________________________________________</span></span><br><span class="line"><span class="comment">  | Codec    | W       H       fps     Mbps    MB/s    |</span></span><br><span class="line"><span class="comment">  |__________|_________________________________________|</span></span><br><span class="line"><span class="comment">  | h264     | 1920    1088    30      20      244800  |</span></span><br><span class="line"><span class="comment">  | mpeg4    | 864      480    30       2       48600  |</span></span><br><span class="line"><span class="comment">  | h263     | 864      480    30       2       48600  |</span></span><br><span class="line"><span class="comment">  |____________________________________________________|</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">MediaCodecs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">"media_codecs_google_audio.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">"media_codecs_google_telephony.xml"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Setting</span> <span class="attr">name</span>=<span class="string">"max-video-encoder-input-buffers"</span> <span class="attr">value</span>=<span class="string">"9"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Encoders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Video Hardware  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qcom.video.encoder.avc"</span> <span class="attr">type</span>=<span class="string">"video/avc"</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Quirk</span> <span class="attr">name</span>=<span class="string">"requires-loaded-to-idle-after-allocation"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">min</span>=<span class="string">"96x96"</span> <span class="attr">max</span>=<span class="string">"1920x1088"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"alignment"</span> <span class="attr">value</span>=<span class="string">"2x2"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"block-size"</span> <span class="attr">value</span>=<span class="string">"16x16"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"blocks-per-second"</span> <span class="attr">min</span>=<span class="string">"1"</span> <span class="attr">max</span>=<span class="string">"244800"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"bitrate"</span> <span class="attr">range</span>=<span class="string">"1-20000000"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Limit</span> <span class="attr">name</span>=<span class="string">"concurrent-instances"</span> <span class="attr">max</span>=<span class="string">"8"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Feature</span> <span class="attr">name</span>=<span class="string">"can-swap-width-height"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">MediaCodec</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Encoders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Decoders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Audio Software  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">MediaCodec</span> <span class="attr">name</span>=<span class="string">"OMX.qti.audio.decoder.flac"</span> <span class="attr">type</span>=<span class="string">"audio/flac"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Decoders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Include</span> <span class="attr">href</span>=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">MediaCodecs</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>以下分析以’OMX.google.h264.decoder’为主：</p><h5 id="2-1、SoftAVC-initEncoder"><a href="#2-1、SoftAVC-initEncoder" class="headerlink" title="2.1、SoftAVC::initEncoder()"></a>2.1、SoftAVC::initEncoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcenc\SoftAVCEnc.cpp]</span><br><span class="line">OMX_ERRORTYPE SoftAVC::initEncoder() &#123;</span><br><span class="line">    IV_STATUS_T status;</span><br><span class="line">    WORD32 level;</span><br><span class="line">    <span class="keyword">uint32_t</span> displaySizeY;</span><br><span class="line"></span><br><span class="line">    CHECK(!mStarted);</span><br><span class="line"></span><br><span class="line">    OMX_ERRORTYPE errType = OMX_ErrorNone;</span><br><span class="line"></span><br><span class="line">    displaySizeY = mWidth * mHeight;</span><br><span class="line">    <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">1920</span> * <span class="number">1088</span>)) &#123;</span><br><span class="line">        level = <span class="number">50</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">1280</span> * <span class="number">720</span>)) &#123;</span><br><span class="line">        level = <span class="number">40</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">720</span> * <span class="number">576</span>)) &#123;</span><br><span class="line">        level = <span class="number">31</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">624</span> * <span class="number">320</span>)) &#123;</span><br><span class="line">        level = <span class="number">30</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (displaySizeY &gt; (<span class="number">352</span> * <span class="number">288</span>)) &#123;</span><br><span class="line">        level = <span class="number">21</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        level = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAVCEncLevel = MAX(level, mAVCEncLevel);</span><br><span class="line"></span><br><span class="line">    mStride = mWidth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputDataIsMeta) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_CONVERSION_BUFFERS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mConversionBuffers[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">free</span>(mConversionBuffers[i]);</span><br><span class="line">                mConversionBuffers[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="keyword">uint64_t</span>)mStride * mHeight) &gt; ((<span class="keyword">uint64_t</span>)INT32_MAX / <span class="number">3</span>)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Buffer size is too big."</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">            &#125;</span><br><span class="line">            mConversionBuffers[i] = (<span class="keyword">uint8_t</span> *)<span class="built_in">malloc</span>(mStride * mHeight * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mConversionBuffers[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Allocating conversion buffer failed."</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mConversionBuffersFree[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mColorFormat) &#123;</span><br><span class="line">        <span class="keyword">case</span> OMX_COLOR_FormatYUV420SemiPlanar:</span><br><span class="line">            mIvVideoColorFormat = IV_YUV_420SP_UV;</span><br><span class="line">            ALOGV(<span class="string">"colorFormat YUV_420SP"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> OMX_COLOR_FormatYUV420Planar:</span><br><span class="line">            mIvVideoColorFormat = IV_YUV_420P;</span><br><span class="line">            ALOGV(<span class="string">"colorFormat YUV_420P"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"Params width %d height %d level %d colorFormat %d"</span>, mWidth,</span><br><span class="line">            mHeight, mAVCEncLevel, mIvVideoColorFormat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Getting Number of MemRecords */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">iv_num_mem_rec_ip_t</span> s_num_mem_rec_ip;</span><br><span class="line">        <span class="keyword">iv_num_mem_rec_op_t</span> s_num_mem_rec_op;</span><br><span class="line"></span><br><span class="line">        s_num_mem_rec_ip.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_num_mem_rec_ip_t</span>);</span><br><span class="line">        s_num_mem_rec_op.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_num_mem_rec_op_t</span>);</span><br><span class="line"></span><br><span class="line">        s_num_mem_rec_ip.e_cmd = IV_CMD_GET_NUM_MEM_REC;</span><br><span class="line"></span><br><span class="line">        status = ive_api_function(<span class="number">0</span>, &amp;s_num_mem_rec_ip, &amp;s_num_mem_rec_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status != IV_SUCCESS) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Get number of memory records failed = 0x%x\n"</span>,</span><br><span class="line">                    s_num_mem_rec_op.u4_error_code);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mNumMemRecords = s_num_mem_rec_op.u4_num_mem_rec;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate array to hold memory records */</span></span><br><span class="line">    <span class="keyword">if</span> (mNumMemRecords &gt; SIZE_MAX / <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"requested memory size is too big."</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">    &#125;</span><br><span class="line">    mMemRecords = (<span class="keyword">iv_mem_rec_t</span> *)<span class="built_in">malloc</span>(mNumMemRecords * <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == mMemRecords) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unable to allocate memory for hold memory records: Size %zu"</span>,</span><br><span class="line">                mNumMemRecords * <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>));</span><br><span class="line">        mSignalledError = <span class="literal">true</span>;</span><br><span class="line">        notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">iv_mem_rec_t</span> *ps_mem_rec;</span><br><span class="line">        ps_mem_rec = mMemRecords;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNumMemRecords; i++) &#123;</span><br><span class="line">            ps_mem_rec-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_mem_rec_t</span>);</span><br><span class="line">            ps_mem_rec-&gt;pv_base = <span class="literal">NULL</span>;</span><br><span class="line">            ps_mem_rec-&gt;u4_mem_size = <span class="number">0</span>;</span><br><span class="line">            ps_mem_rec-&gt;u4_mem_alignment = <span class="number">0</span>;</span><br><span class="line">            ps_mem_rec-&gt;e_mem_type = IV_NA_MEM_TYPE;</span><br><span class="line"></span><br><span class="line">            ps_mem_rec++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Getting MemRecords Attributes */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">iv_fill_mem_rec_ip_t</span> s_fill_mem_rec_ip;</span><br><span class="line">        <span class="keyword">iv_fill_mem_rec_op_t</span> s_fill_mem_rec_op;</span><br><span class="line"></span><br><span class="line">        s_fill_mem_rec_ip.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_fill_mem_rec_ip_t</span>);</span><br><span class="line">        s_fill_mem_rec_op.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_fill_mem_rec_op_t</span>);</span><br><span class="line"></span><br><span class="line">        s_fill_mem_rec_ip.e_cmd = IV_CMD_FILL_NUM_MEM_REC;</span><br><span class="line">        s_fill_mem_rec_ip.ps_mem_rec = mMemRecords;</span><br><span class="line">        s_fill_mem_rec_ip.u4_num_mem_rec = mNumMemRecords;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_wd = mWidth;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_ht = mHeight;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_level = mAVCEncLevel;</span><br><span class="line">        s_fill_mem_rec_ip.e_color_format = DEFAULT_INP_COLOR_FORMAT;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_ref_cnt = DEFAULT_MAX_REF_FRM;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_reorder_cnt = DEFAULT_MAX_REORDER_FRM;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_srch_rng_x = DEFAULT_MAX_SRCH_RANGE_X;</span><br><span class="line">        s_fill_mem_rec_ip.u4_max_srch_rng_y = DEFAULT_MAX_SRCH_RANGE_Y;</span><br><span class="line"></span><br><span class="line">        status = ive_api_function(<span class="number">0</span>, &amp;s_fill_mem_rec_ip, &amp;s_fill_mem_rec_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status != IV_SUCCESS) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Fill memory records failed = 0x%x\n"</span>,</span><br><span class="line">                    s_fill_mem_rec_op.u4_error_code);</span><br><span class="line">            mSignalledError = <span class="literal">true</span>;</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocating Memory for Mem Records */</span></span><br><span class="line">    &#123;</span><br><span class="line">        WORD32 total_size;</span><br><span class="line">        <span class="keyword">iv_mem_rec_t</span> *ps_mem_rec;</span><br><span class="line">        total_size = <span class="number">0</span>;</span><br><span class="line">        ps_mem_rec = mMemRecords;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mNumMemRecords; i++) &#123;</span><br><span class="line">            ps_mem_rec-&gt;pv_base = ive_aligned_malloc(</span><br><span class="line">                    ps_mem_rec-&gt;u4_mem_alignment, ps_mem_rec-&gt;u4_mem_size);</span><br><span class="line">            <span class="keyword">if</span> (ps_mem_rec-&gt;pv_base == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Allocation failure for mem record id %zu size %u\n"</span>, i,</span><br><span class="line">                        ps_mem_rec-&gt;u4_mem_size);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorUndefined;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            total_size += ps_mem_rec-&gt;u4_mem_size;</span><br><span class="line"></span><br><span class="line">            ps_mem_rec++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Codec Instance Creation */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ive_init_ip_t</span> s_init_ip;</span><br><span class="line">        <span class="keyword">ive_init_op_t</span> s_init_op;</span><br><span class="line"></span><br><span class="line">        mCodecCtx = (<span class="keyword">iv_obj_t</span> *)mMemRecords[<span class="number">0</span>].pv_base;</span><br><span class="line">        mCodecCtx-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_obj_t</span>);</span><br><span class="line">        mCodecCtx-&gt;pv_fxns = (<span class="keyword">void</span> *)ive_api_function;</span><br><span class="line"></span><br><span class="line">        s_init_ip.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ive_init_ip_t</span>);</span><br><span class="line">        s_init_op.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ive_init_op_t</span>);</span><br><span class="line"></span><br><span class="line">        s_init_ip.e_cmd = IV_CMD_INIT;</span><br><span class="line">        s_init_ip.u4_num_mem_rec = mNumMemRecords;</span><br><span class="line">        s_init_ip.ps_mem_rec = mMemRecords;</span><br><span class="line">        s_init_ip.u4_max_wd = mWidth;</span><br><span class="line">        s_init_ip.u4_max_ht = mHeight;</span><br><span class="line">        s_init_ip.u4_max_ref_cnt = DEFAULT_MAX_REF_FRM;</span><br><span class="line">        s_init_ip.u4_max_reorder_cnt = DEFAULT_MAX_REORDER_FRM;</span><br><span class="line">        s_init_ip.u4_max_level = mAVCEncLevel;</span><br><span class="line">        s_init_ip.e_inp_color_fmt = mIvVideoColorFormat;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReconEnable || mPSNREnable) &#123;</span><br><span class="line">            s_init_ip.u4_enable_recon = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s_init_ip.u4_enable_recon = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s_init_ip.e_recon_color_fmt = DEFAULT_RECON_COLOR_FORMAT;</span><br><span class="line">        s_init_ip.e_rc_mode = DEFAULT_RC_MODE;</span><br><span class="line">        s_init_ip.u4_max_framerate = DEFAULT_MAX_FRAMERATE;</span><br><span class="line">        s_init_ip.u4_max_bitrate = DEFAULT_MAX_BITRATE;</span><br><span class="line">        s_init_ip.u4_num_bframes = mBframes;</span><br><span class="line">        s_init_ip.e_content_type = IV_PROGRESSIVE;</span><br><span class="line">        s_init_ip.u4_max_srch_rng_x = DEFAULT_MAX_SRCH_RANGE_X;</span><br><span class="line">        s_init_ip.u4_max_srch_rng_y = DEFAULT_MAX_SRCH_RANGE_Y;</span><br><span class="line">        s_init_ip.e_slice_mode = mSliceMode;</span><br><span class="line">        s_init_ip.u4_slice_param = mSliceParam;</span><br><span class="line">        s_init_ip.e_arch = mArch;</span><br><span class="line">        s_init_ip.e_soc = DEFAULT_SOC;</span><br><span class="line"></span><br><span class="line">        status = ive_api_function(mCodecCtx, &amp;s_init_ip, &amp;s_init_op);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get Codec Version */</span></span><br><span class="line">    logVersion();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* set processor details */</span></span><br><span class="line">    setNumCores();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Frame dimensions */</span></span><br><span class="line">    setDimensions();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Frame rates */</span></span><br><span class="line">    setFrameRate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set IPE Params */</span></span><br><span class="line">    setIpeParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Bitrate */</span></span><br><span class="line">    setBitRate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set QP */</span></span><br><span class="line">    setQp();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set AIR params */</span></span><br><span class="line">    setAirParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set VBV params */</span></span><br><span class="line">    setVbvParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Motion estimation params */</span></span><br><span class="line">    setMeParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set GOP params */</span></span><br><span class="line">    setGopParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Deblock params */</span></span><br><span class="line">    setDeblockParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set Profile params */</span></span><br><span class="line">    setProfileParams();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Video control Set in Encode header mode */</span></span><br><span class="line">    setEncMode(IVE_ENC_MODE_HEADER);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"init_codec successfull"</span>);</span><br><span class="line"></span><br><span class="line">    mSpsPpsHeaderReceived = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OMX_ErrorNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、SoftAVC-onQueueFilled"><a href="#2-2、SoftAVC-onQueueFilled" class="headerlink" title="2.2、SoftAVC::onQueueFilled()"></a>2.2、SoftAVC::onQueueFilled()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcenc\SoftAVCEnc.cpp]</span><br><span class="line"><span class="keyword">void</span> SoftAVC::onQueueFilled(OMX_U32 portIndex) &#123;</span><br><span class="line">    IV_STATUS_T status;</span><br><span class="line">    WORD32 timeDelay, timeTaken;</span><br><span class="line"></span><br><span class="line">    UNUSED(portIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize encoder if not already initialized</span></span><br><span class="line">    <span class="keyword">if</span> (mCodecCtx == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (OMX_ErrorNone != initEncoder()) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Failed to initialize encoder"</span>);</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span> <span class="comment">/* arg2 */</span>, <span class="literal">NULL</span> <span class="comment">/* data */</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSignalledError) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;inQueue = getPortQueue(<span class="number">0</span>);</span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;outQueue = getPortQueue(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mSawOutputEOS &amp;&amp; !outQueue.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        OMX_ERRORTYPE error;</span><br><span class="line">        <span class="keyword">ive_video_encode_ip_t</span> s_encode_ip;</span><br><span class="line">        <span class="keyword">ive_video_encode_op_t</span> s_encode_op;</span><br><span class="line">        BufferInfo *outputBufferInfo = *outQueue.begin();</span><br><span class="line">        OMX_BUFFERHEADERTYPE *outputBufferHeader = outputBufferInfo-&gt;mHeader;</span><br><span class="line"></span><br><span class="line">        BufferInfo *inputBufferInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *inputBufferHeader;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSawInputEOS) &#123;</span><br><span class="line">            inputBufferHeader = <span class="literal">NULL</span>;</span><br><span class="line">            inputBufferInfo = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!inQueue.empty()) &#123;</span><br><span class="line">            inputBufferInfo = *inQueue.begin();</span><br><span class="line">            inputBufferHeader = inputBufferInfo-&gt;mHeader;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outputBufferHeader-&gt;nTimeStamp = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nFlags = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nFilledLen = <span class="number">0</span>;</span><br><span class="line">        outputBufferHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputBufferHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags = inputBufferHeader-&gt;nFlags;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint8_t</span> *outPtr = (<span class="keyword">uint8_t</span> *)outputBufferHeader-&gt;pBuffer;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mSpsPpsHeaderReceived) &#123;</span><br><span class="line">            error = setEncodeArgs(&amp;s_encode_ip, &amp;s_encode_op, <span class="literal">NULL</span>, outputBufferHeader);</span><br><span class="line">            <span class="keyword">if</span> (error != OMX_ErrorNone) &#123;</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            status = ive_api_function(mCodecCtx, &amp;s_encode_ip, &amp;s_encode_op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (IV_SUCCESS != status) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Encode Frame failed = 0x%x\n"</span>,</span><br><span class="line">                        s_encode_op.u4_error_code);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGV(<span class="string">"Bytes Generated in header %d\n"</span>,</span><br><span class="line">                        s_encode_op.s_out_buf.u4_bytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSpsPpsHeaderReceived = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            outputBufferHeader-&gt;nFlags = OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">            outputBufferHeader-&gt;nFilledLen = s_encode_op.s_out_buf.u4_bytes;</span><br><span class="line">            <span class="keyword">if</span> (inputBufferHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                outputBufferHeader-&gt;nTimeStamp = inputBufferHeader-&gt;nTimeStamp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            outQueue.erase(outQueue.begin());</span><br><span class="line">            outputBufferInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            DUMP_TO_FILE(</span><br><span class="line">                    mOutFile, outputBufferHeader-&gt;pBuffer,</span><br><span class="line">                    outputBufferHeader-&gt;nFilledLen);</span><br><span class="line">            notifyFillBufferDone(outputBufferHeader);</span><br><span class="line"></span><br><span class="line">            setEncMode(IVE_ENC_MODE_PICTURE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mUpdateFlag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mUpdateFlag &amp; kUpdateBitrate) &#123;</span><br><span class="line">                setBitRate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mUpdateFlag &amp; kRequestKeyFrame) &#123;</span><br><span class="line">                setFrameType(IV_IDR_FRAME);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mUpdateFlag &amp; kUpdateAIRMode) &#123;</span><br><span class="line">                setAirParams();</span><br><span class="line">                notify(OMX_EventPortSettingsChanged, kOutputPortIndex,</span><br><span class="line">                        OMX_IndexConfigAndroidIntraRefresh, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mUpdateFlag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((inputBufferHeader != <span class="literal">NULL</span>)</span><br><span class="line">                &amp;&amp; (inputBufferHeader-&gt;nFlags &amp; OMX_BUFFERFLAG_EOS)) &#123;</span><br><span class="line">            mSawInputEOS = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* In normal mode, store inputBufferInfo and this will be returned</span></span><br><span class="line"><span class="comment">           when encoder consumes this input */</span></span><br><span class="line">        <span class="keyword">if</span> (!mInputDataIsMeta &amp;&amp; (inputBufferInfo != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_INPUT_BUFFER_HEADERS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">NULL</span> == mInputBufferInfo[i]) &#123;</span><br><span class="line">                    mInputBufferInfo[i] = inputBufferInfo;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        error = setEncodeArgs(</span><br><span class="line">                &amp;s_encode_ip, &amp;s_encode_op, inputBufferHeader, outputBufferHeader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error != OMX_ErrorNone) &#123;</span><br><span class="line">            mSignalledError = <span class="literal">true</span>;</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DUMP_TO_FILE(</span><br><span class="line">                mInFile, s_encode_ip.s_inp_buf.apv_bufs[<span class="number">0</span>],</span><br><span class="line">                (mHeight * mStride * <span class="number">3</span> / <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">        GETTIME(&amp;mTimeStart, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Compute time elapsed between end of previous decode()</span></span><br><span class="line"><span class="comment">         * to start of current decode() */</span></span><br><span class="line">        TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);</span><br><span class="line">        status = ive_api_function(mCodecCtx, &amp;s_encode_ip, &amp;s_encode_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IV_SUCCESS != status) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Encode Frame failed = 0x%x\n"</span>,</span><br><span class="line">                    s_encode_op.u4_error_code);</span><br><span class="line">            mSignalledError = <span class="literal">true</span>;</span><br><span class="line">            notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GETTIME(&amp;mTimeEnd, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">/* Compute time taken for decode() */</span></span><br><span class="line">        TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);</span><br><span class="line"></span><br><span class="line">        ALOGV(<span class="string">"timeTaken=%6d delay=%6d numBytes=%6d"</span>, timeTaken, timeDelay,</span><br><span class="line">                s_encode_op.s_out_buf.u4_bytes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* In encoder frees up an input buffer, mark it as free */</span></span><br><span class="line">        <span class="keyword">if</span> (s_encode_op.s_inp_buf.apv_bufs[<span class="number">0</span>] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mInputDataIsMeta) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_CONVERSION_BUFFERS; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mConversionBuffers[i] == s_encode_op.s_inp_buf.apv_bufs[<span class="number">0</span>]) &#123;</span><br><span class="line">                        mConversionBuffersFree[i] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* In normal mode, call EBD on inBuffeHeader that is freed by the codec */</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; MAX_INPUT_BUFFER_HEADERS; i++) &#123;</span><br><span class="line">                    <span class="keyword">uint8_t</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line">                    OMX_BUFFERHEADERTYPE *bufHdr = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mInputBufferInfo[i] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        bufHdr = mInputBufferInfo[i]-&gt;mHeader;</span><br><span class="line">                        buf = bufHdr-&gt;pBuffer + bufHdr-&gt;nOffset;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (s_encode_op.s_inp_buf.apv_bufs[<span class="number">0</span>] == buf) &#123;</span><br><span class="line">                        mInputBufferInfo[i]-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                        notifyEmptyBufferDone(bufHdr);</span><br><span class="line">                        mInputBufferInfo[i] = <span class="literal">NULL</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outputBufferHeader-&gt;nFilledLen = s_encode_op.s_out_buf.u4_bytes;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (IV_IDR_FRAME == s_encode_op.u4_encoded_frame_type) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags |= OMX_BUFFERFLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inputBufferHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            inQueue.erase(inQueue.begin());</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If in meta data, call EBD on input */</span></span><br><span class="line">            <span class="comment">/* In case of normal mode, EBD will be done once encoder</span></span><br><span class="line"><span class="comment">            releases the input buffer */</span></span><br><span class="line">            <span class="keyword">if</span> (mInputDataIsMeta) &#123;</span><br><span class="line">                inputBufferInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                notifyEmptyBufferDone(inputBufferHeader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_encode_op.u4_is_last) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags |= OMX_BUFFERFLAG_EOS;</span><br><span class="line">            mSawOutputEOS = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outputBufferHeader-&gt;nFlags &amp;= ~OMX_BUFFERFLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outputBufferHeader-&gt;nFilledLen || s_encode_op.u4_is_last) &#123;</span><br><span class="line">            outputBufferHeader-&gt;nTimeStamp = s_encode_op.u4_timestamp_high;</span><br><span class="line">            outputBufferHeader-&gt;nTimeStamp &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">            outputBufferHeader-&gt;nTimeStamp |= s_encode_op.u4_timestamp_low;</span><br><span class="line">            outputBufferInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">            outQueue.erase(outQueue.begin());</span><br><span class="line">            DUMP_TO_FILE(mOutFile, outputBufferHeader-&gt;pBuffer,</span><br><span class="line">                    outputBufferHeader-&gt;nFilledLen);</span><br><span class="line">            notifyFillBufferDone(outputBufferHeader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s_encode_op.u4_is_last == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、ih264e-encode"><a href="#2-3、ih264e-encode" class="headerlink" title="2.3、ih264e_encode()"></a>2.3、ih264e_encode()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\Ph55c74\PH55C74\android\external\libavc\encoder\ih264e_encode.c]</span><br><span class="line"><span class="function">WORD32 <span class="title">ih264e_encode</span><span class="params">(<span class="keyword">iv_obj_t</span> *ps_codec_obj, <span class="keyword">void</span> *pv_api_ip, <span class="keyword">void</span> *pv_api_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* error status */</span></span><br><span class="line">    IH264E_ERROR_T error_status = IH264E_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* codec ctxt */</span></span><br><span class="line">    <span class="keyword">codec_t</span> *ps_codec = (<span class="keyword">codec_t</span> *)ps_codec_obj-&gt;pv_codec_handle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* input frame to encode */</span></span><br><span class="line">    <span class="keyword">ih264e_video_encode_ip_t</span> *ps_video_encode_ip = pv_api_ip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* output buffer to write stream */</span></span><br><span class="line">    <span class="keyword">ih264e_video_encode_op_t</span> *ps_video_encode_op = pv_api_op;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* i/o structures */</span></span><br><span class="line">    <span class="keyword">inp_buf_t</span> s_inp_buf;</span><br><span class="line">    <span class="keyword">out_buf_t</span> s_out_buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* temp var */</span></span><br><span class="line">    WORD32 ctxt_sel = <span class="number">0</span>, i, i4_rc_pre_enc_skip;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/********************************************************************/</span></span><br><span class="line">    <span class="comment">/*                            BEGIN INIT                            */</span></span><br><span class="line">    <span class="comment">/********************************************************************/</span></span><br><span class="line">    <span class="comment">/* reset output structure */</span></span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.u4_error_code = IV_SUCCESS;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.output_present  = <span class="number">0</span>;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.dump_recon = <span class="number">0</span>;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.u4_encoded_frame_type = IV_NA_FRAME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for output memory allocation size */</span></span><br><span class="line">    <span class="keyword">if</span> (ps_video_encode_ip-&gt;s_ive_ip.s_out_buf.u4_bufsize &lt; MIN_STREAM_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">        error_status |= IH264E_INSUFFICIENT_OUTPUT_BUFFER;</span><br><span class="line">        SET_ERROR_ON_RETURN(error_status,</span><br><span class="line">                            IVE_UNSUPPORTEDPARAM,</span><br><span class="line">                            ps_video_encode_op-&gt;s_ive_op.u4_error_code,</span><br><span class="line">                            IV_FAIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy output info. to internal structure */</span></span><br><span class="line">    s_out_buf.s_bits_buf = ps_video_encode_ip-&gt;s_ive_ip.s_out_buf;</span><br><span class="line">    s_out_buf.u4_is_last = <span class="number">0</span>;</span><br><span class="line">    s_out_buf.u4_timestamp_low = ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_low;</span><br><span class="line">    s_out_buf.u4_timestamp_high = ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* api call cnt */</span></span><br><span class="line">    ps_codec-&gt;i4_encode_api_call_cnt += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* codec context selector */</span></span><br><span class="line">    ctxt_sel = ps_codec-&gt;i4_encode_api_call_cnt % MAX_CTXT_SETS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reset status flags */</span></span><br><span class="line">    ps_codec-&gt;ai4_pic_cnt[ctxt_sel] = <span class="number">-1</span>;</span><br><span class="line">    ps_codec-&gt;s_rate_control.post_encode_skip[ctxt_sel] = <span class="number">0</span>;</span><br><span class="line">    ps_codec-&gt;s_rate_control.pre_encode_skip[ctxt_sel] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* pass output buffer to codec */</span></span><br><span class="line">    ps_codec-&gt;as_out_buf[ctxt_sel] = s_out_buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize codec ctxt with default params for the first encode api call */</span></span><br><span class="line">    <span class="keyword">if</span> (ps_codec-&gt;i4_encode_api_call_cnt == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ih264e_codec_init(ps_codec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* parse configuration params */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ACTIVE_CONFIG_PARAMS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">cfg_params_t</span> *ps_cfg = &amp;ps_codec-&gt;as_cfg[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == ps_cfg-&gt;u4_is_valid)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( ((ps_cfg-&gt;u4_timestamp_high == ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_high) &amp;&amp;</span><br><span class="line">                            (ps_cfg-&gt;u4_timestamp_low == ps_video_encode_ip-&gt;s_ive_ip.u4_timestamp_low)) ||</span><br><span class="line">                            ((WORD32)ps_cfg-&gt;u4_timestamp_high == <span class="number">-1</span>) ||</span><br><span class="line">                            ((WORD32)ps_cfg-&gt;u4_timestamp_low == <span class="number">-1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                error_status |= ih264e_codec_update_config(ps_codec, ps_cfg);</span><br><span class="line">                SET_ERROR_ON_RETURN(error_status,</span><br><span class="line">                                    IVE_UNSUPPORTEDPARAM,</span><br><span class="line">                                    ps_video_encode_op-&gt;s_ive_op.u4_error_code,</span><br><span class="line">                                    IV_FAIL);</span><br><span class="line"></span><br><span class="line">                ps_cfg-&gt;u4_is_valid = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Send the input to encoder so that it can free it if possible */</span></span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.s_out_buf = s_out_buf.s_bits_buf;</span><br><span class="line">    ps_video_encode_op-&gt;s_ive_op.s_inp_buf = s_inp_buf.s_raw_buf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == s_inp_buf.u4_is_last)</span><br><span class="line">    &#123;</span><br><span class="line">        ps_video_encode_op-&gt;s_ive_op.output_present = <span class="number">0</span>;</span><br><span class="line">        ps_video_encode_op-&gt;s_ive_op.dump_recon = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IV_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到编码过程极其复杂…精髓在libavc库里面，第四节详细分析（Todo）。</p><h4 id="（三）、Android-H264解码"><a href="#（三）、Android-H264解码" class="headerlink" title="（三）、Android  H264解码"></a>（三）、Android H264解码</h4><h5 id="3-1、SoftAVC-initDecoder"><a href="#3-1、SoftAVC-initDecoder" class="headerlink" title="3.1、SoftAVC::initDecoder()"></a>3.1、SoftAVC::initDecoder()</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/android.codecs/VS9-18-H264-Decoder-google.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcdec\SoftAVCDec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> SoftAVC::initDecoder() &#123;</span><br><span class="line">    IV_API_CALL_STATUS_T status;</span><br><span class="line"></span><br><span class="line">    mNumCores = GetCPUCoreCount();</span><br><span class="line">    mCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mStride = outputBufferWidth();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize the decoder */</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ivdext_create_ip_t</span> s_create_ip;</span><br><span class="line">        <span class="keyword">ivdext_create_op_t</span> s_create_op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> *dec_fxns = (<span class="keyword">void</span> *)ivdec_api_function;</span><br><span class="line"></span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ivdext_create_ip_t</span>);</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.e_cmd = IVD_CMD_CREATE;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.u4_share_disp_buf = <span class="number">0</span>;</span><br><span class="line">        s_create_op.<span class="keyword">s_ivd_create_op_t</span>.u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ivdext_create_op_t</span>);</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.e_output_format = mIvColorFormat;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.pf_aligned_alloc = ivd_aligned_malloc;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.pf_aligned_free = ivd_aligned_free;</span><br><span class="line">        s_create_ip.<span class="keyword">s_ivd_create_ip_t</span>.pv_mem_ctxt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        status = ivdec_api_function(mCodecCtx, (<span class="keyword">void</span> *)&amp;s_create_ip, (<span class="keyword">void</span> *)&amp;s_create_op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (status != IV_SUCCESS) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Error in create: 0x%x"</span>,</span><br><span class="line">                    s_create_op.<span class="keyword">s_ivd_create_op_t</span>.u4_error_code);</span><br><span class="line">            deInitDecoder();</span><br><span class="line">            mCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecCtx = (<span class="keyword">iv_obj_t</span>*)s_create_op.<span class="keyword">s_ivd_create_op_t</span>.pv_handle;</span><br><span class="line">        mCodecCtx-&gt;pv_fxns = dec_fxns;</span><br><span class="line">        mCodecCtx-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">iv_obj_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reset the plugin state */</span></span><br><span class="line">    resetPlugin();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the run time (dynamic) parameters */</span></span><br><span class="line">    setParams(mStride);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set number of cores/threads to be used by the codec */</span></span><br><span class="line">    setNumCores();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get codec version */</span></span><br><span class="line">    logVersion();</span><br><span class="line"></span><br><span class="line">    mFlushNeeded = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2、SoftAVC-onQueueFilled"><a href="#3-2、SoftAVC-onQueueFilled" class="headerlink" title="3.2、SoftAVC::onQueueFilled()"></a>3.2、SoftAVC::onQueueFilled()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\MediaLearing\frameworks\av\media\libstagefright\codecs\avcdec\SoftAVCDec.cpp]</span><br><span class="line"><span class="keyword">void</span> SoftAVC::onQueueFilled(OMX_U32 portIndex) &#123;</span><br><span class="line">    UNUSED(portIndex);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span> (outputBufferWidth() != mStride) &#123;</span><br><span class="line">        <span class="comment">/* Set the run-time (dynamic) parameters */</span></span><br><span class="line">        mStride = outputBufferWidth();</span><br><span class="line">        setParams(mStride);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;inQueue = getPortQueue(kInputPortIndex);</span><br><span class="line">    List&lt;BufferInfo *&gt; &amp;outQueue = getPortQueue(kOutputPortIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!outQueue.empty()) &#123;</span><br><span class="line">        BufferInfo *inInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *inHeader;</span><br><span class="line"></span><br><span class="line">        BufferInfo *outInfo;</span><br><span class="line">        OMX_BUFFERHEADERTYPE *outHeader;</span><br><span class="line">        <span class="keyword">size_t</span> timeStampIx;</span><br><span class="line"></span><br><span class="line">        inInfo = <span class="literal">NULL</span>;</span><br><span class="line">        inHeader = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        outInfo = *outQueue.begin();</span><br><span class="line">        outHeader = outInfo-&gt;mHeader;</span><br><span class="line">        outHeader-&gt;nFlags = <span class="number">0</span>;</span><br><span class="line">        outHeader-&gt;nTimeStamp = <span class="number">0</span>;</span><br><span class="line">        outHeader-&gt;nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Get a free slot in timestamp array to hold input timestamp */</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> i;</span><br><span class="line">            timeStampIx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_TIME_STAMPS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mTimeStampsValid[i]) &#123;</span><br><span class="line">                    timeStampIx = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (inHeader != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mTimeStampsValid[timeStampIx] = <span class="literal">true</span>;</span><br><span class="line">                mTimeStamps[timeStampIx] = inHeader-&gt;nTimeStamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">ivd_video_decode_ip_t</span> s_dec_ip;</span><br><span class="line">            <span class="keyword">ivd_video_decode_op_t</span> s_dec_op;</span><br><span class="line">            WORD32 timeDelay, timeTaken;</span><br><span class="line">            <span class="keyword">size_t</span> sizeY, sizeUV;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!setDecodeArgs(&amp;s_dec_ip, &amp;s_dec_op, inHeader, outHeader, timeStampIx)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Decoder arg setup failed"</span>);</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUndefined, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// If input dump is enabled, then write to file</span></span><br><span class="line">            DUMP_TO_FILE(mInFile, s_dec_ip.pv_stream_buffer, s_dec_ip.u4_num_Bytes);</span><br><span class="line"></span><br><span class="line">            GETTIME(&amp;mTimeStart, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* Compute time elapsed between end of previous decode()</span></span><br><span class="line"><span class="comment">             * to start of current decode() */</span></span><br><span class="line">            TIME_DIFF(mTimeEnd, mTimeStart, timeDelay);</span><br><span class="line"></span><br><span class="line">            IV_API_CALL_STATUS_T status;</span><br><span class="line">            status = ivdec_api_function(mCodecCtx, (<span class="keyword">void</span> *)&amp;s_dec_ip, (<span class="keyword">void</span> *)&amp;s_dec_op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> unsupportedResolution =</span><br><span class="line">                (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == (s_dec_op.u4_error_code &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Check for unsupported dimensions */</span></span><br><span class="line">            <span class="keyword">if</span> (unsupportedResolution) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Unsupported resolution : %dx%d"</span>, mWidth, mHeight);</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> allocationFailed = (IVD_MEM_ALLOC_FAILED == (s_dec_op.u4_error_code &amp; <span class="number">0xFF</span>));</span><br><span class="line">            <span class="keyword">if</span> (allocationFailed) &#123;</span><br><span class="line">                ALOGE(<span class="string">"Allocation failure in decoder"</span>);</span><br><span class="line">                notify(OMX_EventError, OMX_ErrorUnsupportedSetting, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">                mSignalledError = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> resChanged = (IVD_RES_CHANGED == (s_dec_op.u4_error_code &amp; <span class="number">0xFF</span>));</span><br><span class="line"></span><br><span class="line">            getVUIParams();</span><br><span class="line"></span><br><span class="line">            GETTIME(&amp;mTimeEnd, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">/* Compute time taken for decode() */</span></span><br><span class="line">            TIME_DIFF(mTimeStart, mTimeEnd, timeTaken);</span><br><span class="line"></span><br><span class="line">            PRINT_TIME(<span class="string">"timeTaken=%6d delay=%6d numBytes=%6d"</span>, timeTaken, timeDelay,</span><br><span class="line">                   s_dec_op.u4_num_bytes_consumed);</span><br><span class="line">            <span class="keyword">if</span> (s_dec_op.u4_frame_decoded_flag &amp;&amp; !mFlushNeeded) &#123;</span><br><span class="line">                mFlushNeeded = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((inHeader != <span class="literal">NULL</span>) &amp;&amp; (<span class="number">1</span> != s_dec_op.u4_frame_decoded_flag)) &#123;</span><br><span class="line">                <span class="comment">/* If the input did not contain picture data, then ignore</span></span><br><span class="line"><span class="comment">                 * the associated timestamp */</span></span><br><span class="line">                mTimeStampsValid[timeStampIx] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If the decoder is in the changing resolution mode and there is no output present,</span></span><br><span class="line">            <span class="comment">// that means the switching is done and it's ready to reset the decoder and the plugin.</span></span><br><span class="line">            <span class="keyword">if</span> (mChangingResolution &amp;&amp; !s_dec_op.u4_output_present) &#123;</span><br><span class="line">                mChangingResolution = <span class="literal">false</span>;</span><br><span class="line">                resetDecoder();</span><br><span class="line">                resetPlugin();</span><br><span class="line">                mStride = outputBufferWidth();</span><br><span class="line">                setParams(mStride);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resChanged) &#123;</span><br><span class="line">                mChangingResolution = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (mFlushNeeded) &#123;</span><br><span class="line">                    setFlushMode();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Combine the resolution change and coloraspects change in one PortSettingChange event</span></span><br><span class="line">            <span class="comment">// if necessary.</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">0</span> &lt; s_dec_op.u4_pic_wd) &amp;&amp; (<span class="number">0</span> &lt; s_dec_op.u4_pic_ht)) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> width = s_dec_op.u4_pic_wd;</span><br><span class="line">                <span class="keyword">uint32_t</span> height = s_dec_op.u4_pic_ht;</span><br><span class="line">                <span class="keyword">bool</span> portWillReset = <span class="literal">false</span>;</span><br><span class="line">                handlePortSettingsChange(&amp;portWillReset, width, height);</span><br><span class="line">                <span class="keyword">if</span> (portWillReset) &#123;</span><br><span class="line">                    resetDecoder();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mUpdateColorAspects) &#123;</span><br><span class="line">                notify(OMX_EventPortSettingsChanged, kOutputPortIndex,</span><br><span class="line">                    kDescribeColorAspectsIndex, <span class="literal">NULL</span>);</span><br><span class="line">                mUpdateColorAspects = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s_dec_op.u4_output_present) &#123;</span><br><span class="line">                outHeader-&gt;nFilledLen = (outputBufferWidth() * outputBufferHeight() * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                outHeader-&gt;nTimeStamp = mTimeStamps[s_dec_op.u4_ts];</span><br><span class="line">                mTimeStampsValid[s_dec_op.u4_ts] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                outInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                outQueue.erase(outQueue.begin());</span><br><span class="line">                outInfo = <span class="literal">NULL</span>;</span><br><span class="line">                notifyFillBufferDone(outHeader);</span><br><span class="line">                outHeader = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsInFlush) &#123;</span><br><span class="line">                <span class="comment">/* If in flush mode and no output is returned by the codec,</span></span><br><span class="line"><span class="comment">                 * then come out of flush mode */</span></span><br><span class="line">                mIsInFlush = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* If EOS was recieved on input port and there is no output</span></span><br><span class="line"><span class="comment">                 * from the codec, then signal EOS on output port */</span></span><br><span class="line">                <span class="keyword">if</span> (mReceivedEOS) &#123;</span><br><span class="line">                    outHeader-&gt;nFilledLen = <span class="number">0</span>;</span><br><span class="line">                    outHeader-&gt;nFlags |= OMX_BUFFERFLAG_EOS;</span><br><span class="line"></span><br><span class="line">                    outInfo-&gt;mOwnedByUs = <span class="literal">false</span>;</span><br><span class="line">                    outQueue.erase(outQueue.begin());</span><br><span class="line">                    outInfo = <span class="literal">NULL</span>;</span><br><span class="line">                    notifyFillBufferDone(outHeader);</span><br><span class="line">                    outHeader = <span class="literal">NULL</span>;</span><br><span class="line">                    resetPlugin();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3、WORD32-ih264d-video-decode"><a href="#3-3、WORD32-ih264d-video-decode" class="headerlink" title="3.3、WORD32 ih264d_video_decode()"></a>3.3、WORD32 ih264d_video_decode()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;Z:\Ph55c74\PH55C74\android\external\libavc\decoder\ih264d_api.c]</span><br><span class="line"><span class="function">WORD32 <span class="title">ih264d_video_decode</span><span class="params">(<span class="keyword">iv_obj_t</span> *dec_hdl, <span class="keyword">void</span> *pv_api_ip, <span class="keyword">void</span> *pv_api_op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* ! */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">dec_struct_t</span> * ps_dec = (<span class="keyword">dec_struct_t</span> *)(dec_hdl-&gt;pv_codec_handle);</span><br><span class="line"></span><br><span class="line">    WORD32 i4_err_status = <span class="number">0</span>;</span><br><span class="line">    UWORD8 *pu1_buf = <span class="literal">NULL</span>;</span><br><span class="line">    WORD32 buflen;</span><br><span class="line">    UWORD32 u4_max_ofst, u4_length_of_start_code = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    UWORD32 bytes_consumed = <span class="number">0</span>;</span><br><span class="line">    UWORD32 cur_slice_is_nonref = <span class="number">0</span>;</span><br><span class="line">    UWORD32 u4_next_is_aud;</span><br><span class="line">    UWORD32 u4_first_start_code_found = <span class="number">0</span>;</span><br><span class="line">    WORD32 ret = <span class="number">0</span>,api_ret_value = IV_SUCCESS;</span><br><span class="line">    WORD32 header_data_left = <span class="number">0</span>,frame_data_left = <span class="number">0</span>;</span><br><span class="line">    UWORD8 *pu1_bitstrm_buf;</span><br><span class="line">    <span class="keyword">ivd_video_decode_ip_t</span> *ps_dec_ip;</span><br><span class="line">    <span class="keyword">ivd_video_decode_op_t</span> *ps_dec_op;</span><br><span class="line"></span><br><span class="line">    ithread_set_name((<span class="keyword">void</span>*)<span class="string">"Parse_thread"</span>);</span><br><span class="line"></span><br><span class="line">    ps_dec_ip = (<span class="keyword">ivd_video_decode_ip_t</span> *)pv_api_ip;</span><br><span class="line">    ps_dec_op = (<span class="keyword">ivd_video_decode_op_t</span> *)pv_api_op;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        UWORD32 u4_size;</span><br><span class="line">        u4_size = ps_dec_op-&gt;u4_size;</span><br><span class="line">        <span class="built_in">memset</span>(ps_dec_op, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">ivd_video_decode_op_t</span>));</span><br><span class="line">        ps_dec_op-&gt;u4_size = u4_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;pv_dec_out = ps_dec_op;</span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;init_done != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Data memory barries instruction,so that bitstream write by the application is complete*/</span></span><br><span class="line">    DATA_SYNC();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;u1_flushfrm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ps_dec_ip-&gt;pv_stream_buffer == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;</span><br><span class="line">            <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ps_dec_ip-&gt;u4_num_Bytes &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= IVD_DEC_NUMBYTES_INV;</span><br><span class="line">            <span class="keyword">return</span> IV_FAIL;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ps_dec-&gt;u1_pic_decode_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec_op-&gt;u4_num_bytes_consumed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;ps_out_buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec_ip-&gt;u4_size</span><br><span class="line">                    &gt;= offsetof(<span class="keyword">ivd_video_decode_ip_t</span>, s_out_buffer))</span><br><span class="line">        ps_dec-&gt;ps_out_buffer = &amp;ps_dec_ip-&gt;s_out_buffer;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_fmt_conv_cur_row = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_output_present = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;s_disp_op.u4_error_code = <span class="number">1</span>;</span><br><span class="line">    ps_dec-&gt;u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;u4_share_disp_buf</span><br><span class="line">                    &amp;&amp; ps_dec-&gt;i4_decode_header == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UWORD32 i;</span><br><span class="line">        <span class="keyword">if</span>((ps_dec-&gt;ps_out_buffer-&gt;u4_num_bufs == <span class="number">0</span>) ||</span><br><span class="line">           (ps_dec-&gt;ps_out_buffer-&gt;u4_num_bufs &gt; IVD_VIDDEC_MAX_IO_BUFFERS))</span><br><span class="line">        &#123;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;</span><br><span class="line">            <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ps_dec-&gt;ps_out_buffer-&gt;u4_num_bufs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;ps_out_buffer-&gt;pu1_bufs[i] == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;</span><br><span class="line">                <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;ps_out_buffer-&gt;u4_min_out_buf_size[i] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |=</span><br><span class="line">                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;</span><br><span class="line">                <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u4_total_frames_decoded &gt;= NUM_FRAMES_LIMIT)</span><br><span class="line">    &#123;</span><br><span class="line">        ps_dec_op-&gt;u4_error_code = ERROR_FRAME_LIMIT_OVER;</span><br><span class="line">        <span class="keyword">return</span> IV_FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ! */</span></span><br><span class="line">    ps_dec-&gt;u4_ts = ps_dec_ip-&gt;u4_ts;</span><br><span class="line"></span><br><span class="line">    ps_dec_op-&gt;u4_error_code = <span class="number">0</span>;</span><br><span class="line">    ps_dec_op-&gt;e_pic_type = <span class="number">-1</span>;</span><br><span class="line">    ps_dec_op-&gt;u4_output_present = <span class="number">0</span>;</span><br><span class="line">    ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;i4_frametype = <span class="number">-1</span>;</span><br><span class="line">    ps_dec-&gt;i4_content_type = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_slice_start_code_found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In case the deocder is not in flush mode(in shared mode),</span></span><br><span class="line"><span class="comment">     then decoder has to pick up a buffer to write current frame.</span></span><br><span class="line"><span class="comment">     Check if a frame is available in such cases */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u1_init_dec_flag == <span class="number">1</span> &amp;&amp; ps_dec-&gt;u4_share_disp_buf == <span class="number">1</span></span><br><span class="line">                    &amp;&amp; ps_dec-&gt;u1_flushfrm == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UWORD32 i;</span><br><span class="line"></span><br><span class="line">        WORD32 disp_avail = <span class="number">0</span>, free_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if at least one buffer is available with the codec */</span></span><br><span class="line">        <span class="comment">/* If not then return to application with error */</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; ps_dec-&gt;u1_pic_bufs; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;u4_disp_buf_mapping[i]</span><br><span class="line">                            || <span class="number">1</span> == ps_dec-&gt;u4_disp_buf_to_be_freed[i])</span><br><span class="line">            &#123;</span><br><span class="line">                disp_avail = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == disp_avail)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* If something is queued for display wait for that buffer to be returned */</span></span><br><span class="line"></span><br><span class="line">            ps_dec_op-&gt;u4_error_code = IVD_DEC_REF_BUF_NULL;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">pic_buffer_t</span> *ps_pic_buf;</span><br><span class="line">            ps_pic_buf = (<span class="keyword">pic_buffer_t</span> *)ih264_buf_mgr_get_next_free(</span><br><span class="line">                            (<span class="keyword">buf_mgr_t</span> *)ps_dec-&gt;pv_pic_buf_mgr, &amp;free_id);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ps_pic_buf == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                UWORD32 i, display_queued = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* check if any buffer was given for display which is not returned yet */</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; (MAX_DISP_BUFS_NEW); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">0</span> != ps_dec-&gt;u4_disp_buf_mapping[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        display_queued = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* If some buffer is queued for display, then codec has to singal an error and wait</span></span><br><span class="line"><span class="comment">                 for that buffer to be returned.</span></span><br><span class="line"><span class="comment">                 If nothing is queued for display then codec has ownership of all display buffers</span></span><br><span class="line"><span class="comment">                 and it can reuse any of the existing buffers and continue decoding */</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> == display_queued)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* If something is queued for display wait for that buffer to be returned */</span></span><br><span class="line">                    ps_dec_op-&gt;u4_error_code = IVD_DEC_REF_BUF_NULL;</span><br><span class="line">                    ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span></span><br><span class="line">                                    &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">                    <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* If the buffer is with display, then mark it as in use and then look for a buffer again */</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span> == ps_dec-&gt;u4_disp_buf_mapping[free_id])</span><br><span class="line">                &#123;</span><br><span class="line">                    ih264_buf_mgr_set_status(</span><br><span class="line">                                    (<span class="keyword">buf_mgr_t</span> *)ps_dec-&gt;pv_pic_buf_mgr,</span><br><span class="line">                                    free_id,</span><br><span class="line">                                    BUF_MGR_IO);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  Found a free buffer for present call. Release it now.</span></span><br><span class="line"><span class="comment">                     *  Will be again obtained later.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    ih264_buf_mgr_release((<span class="keyword">buf_mgr_t</span> *)ps_dec-&gt;pv_pic_buf_mgr,</span><br><span class="line">                                          free_id,</span><br><span class="line">                                          BUF_MGR_IO);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u1_flushfrm)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ps_dec-&gt;u1_init_dec_flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*Come out of flush mode and return*/</span></span><br><span class="line">            ps_dec-&gt;u1_flushfrm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ih264d_get_next_display_field(ps_dec, ps_dec-&gt;ps_out_buffer,</span><br><span class="line">                                      &amp;(ps_dec-&gt;s_disp_op));</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;s_disp_op.u4_error_code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* check output buffer size given by the application */</span></span><br><span class="line">            <span class="keyword">if</span>(check_app_out_buf_size(ps_dec) != IV_SUCCESS)</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code= IVD_DISP_FRM_ZERO_OP_BUF_SIZE;</span><br><span class="line">                <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ps_dec-&gt;u4_fmt_conv_cur_row = <span class="number">0</span>;</span><br><span class="line">            ps_dec-&gt;u4_fmt_conv_num_rows = ps_dec-&gt;s_disp_frame_info.u4_y_ht;</span><br><span class="line">            ih264d_format_convert(ps_dec, &amp;(ps_dec-&gt;s_disp_op),</span><br><span class="line">                                  ps_dec-&gt;u4_fmt_conv_cur_row,</span><br><span class="line">                                  ps_dec-&gt;u4_fmt_conv_num_rows);</span><br><span class="line">            ps_dec-&gt;u4_fmt_conv_cur_row += ps_dec-&gt;u4_fmt_conv_num_rows;</span><br><span class="line">            ps_dec-&gt;u4_output_present = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        ih264d_release_display_field(ps_dec, &amp;(ps_dec-&gt;s_disp_op));</span><br><span class="line"></span><br><span class="line">        ps_dec_op-&gt;u4_pic_wd = (UWORD32)ps_dec-&gt;u2_disp_width;</span><br><span class="line">        ps_dec_op-&gt;u4_pic_ht = (UWORD32)ps_dec-&gt;u2_disp_height;</span><br><span class="line"></span><br><span class="line">        ps_dec_op-&gt;u4_new_seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ps_dec_op-&gt;u4_output_present = ps_dec-&gt;u4_output_present;</span><br><span class="line">        ps_dec_op-&gt;u4_progressive_frame_flag =</span><br><span class="line">                        ps_dec-&gt;s_disp_op.u4_progressive_frame_flag;</span><br><span class="line">        ps_dec_op-&gt;e_output_format =</span><br><span class="line">                        ps_dec-&gt;s_disp_op.e_output_format;</span><br><span class="line">        ps_dec_op-&gt;s_disp_frm_buf = ps_dec-&gt;s_disp_op.s_disp_frm_buf;</span><br><span class="line">        ps_dec_op-&gt;e4_fld_type = ps_dec-&gt;s_disp_op.e4_fld_type;</span><br><span class="line">        ps_dec_op-&gt;u4_ts = ps_dec-&gt;s_disp_op.u4_ts;</span><br><span class="line">        ps_dec_op-&gt;u4_disp_buf_id = ps_dec-&gt;s_disp_op.u4_disp_buf_id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*In the case of flush ,since no frame is decoded set pic type as invalid*/</span></span><br><span class="line">        ps_dec_op-&gt;u4_is_ref_flag = <span class="number">-1</span>;</span><br><span class="line">        ps_dec_op-&gt;e_pic_type = IV_NA_FRAME;</span><br><span class="line">        ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == ps_dec-&gt;s_disp_op.u4_error_code)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (IV_SUCCESS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ps_dec-&gt;u1_res_changed == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*if resolution has changed and all buffers have been flushed, reset decoder*/</span></span><br><span class="line">        ih264d_init_decoder(ps_dec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_prev_nal_skipped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u2_cur_mb_addr = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u2_total_mbs_coded = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u2_cur_slice_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;cur_dec_mb_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;cur_recon_mb_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_first_slice_in_pic = <span class="number">1</span>;</span><br><span class="line">    ps_dec-&gt;u1_slice_header_done = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u1_dangling_field = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_dec_thread_created = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_bs_deblk_thread_created = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_cur_bs_mb_num = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_start_recon_deblk  = <span class="number">0</span>;</span><br><span class="line">    ps_dec-&gt;u4_sps_cnt_in_process = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    DEBUG_THREADS_PRINTF(<span class="string">" Starting process call\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ps_dec-&gt;u4_pic_buf_got = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        WORD32 buf_size;</span><br><span class="line"></span><br><span class="line">        pu1_buf = (UWORD8*)ps_dec_ip-&gt;pv_stream_buffer</span><br><span class="line">                        + ps_dec_op-&gt;u4_num_bytes_consumed;</span><br><span class="line"></span><br><span class="line">        u4_max_ofst = ps_dec_ip-&gt;u4_num_Bytes</span><br><span class="line">                        - ps_dec_op-&gt;u4_num_bytes_consumed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If dynamic bitstream buffer is not allocated and</span></span><br><span class="line"><span class="comment">         * header decode is done, then allocate dynamic bitstream buffer</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>((<span class="literal">NULL</span> == ps_dec-&gt;pu1_bits_buf_dynamic) &amp;&amp;</span><br><span class="line">           (ps_dec-&gt;i4_header_decoded &amp; <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            WORD32 size;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">void</span> *pv_buf;</span><br><span class="line">            <span class="keyword">void</span> *pv_mem_ctxt = ps_dec-&gt;pv_mem_ctxt;</span><br><span class="line">            size = MAX(<span class="number">256000</span>, ps_dec-&gt;u2_pic_wd * ps_dec-&gt;u2_pic_ht * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">            pv_buf = ps_dec-&gt;pf_aligned_alloc(pv_mem_ctxt, <span class="number">128</span>,</span><br><span class="line">                                              size + EXTRA_BS_OFFSET);</span><br><span class="line">            RETURN_IF((<span class="literal">NULL</span> == pv_buf), IV_FAIL);</span><br><span class="line">            ps_dec-&gt;pu1_bits_buf_dynamic = pv_buf;</span><br><span class="line">            ps_dec-&gt;u4_dynamic_bits_buf_size = size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ps_dec-&gt;pu1_bits_buf_dynamic)</span><br><span class="line">        &#123;</span><br><span class="line">            pu1_bitstrm_buf = ps_dec-&gt;pu1_bits_buf_dynamic;</span><br><span class="line">            buf_size = ps_dec-&gt;u4_dynamic_bits_buf_size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pu1_bitstrm_buf = ps_dec-&gt;pu1_bits_buf_static;</span><br><span class="line">            buf_size = ps_dec-&gt;u4_static_bits_buf_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u4_next_is_aud = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        buflen = ih264d_find_start_code(pu1_buf, <span class="number">0</span>, u4_max_ofst,</span><br><span class="line">                                               &amp;u4_length_of_start_code,</span><br><span class="line">                                               &amp;u4_next_is_aud);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buflen == <span class="number">-1</span>)</span><br><span class="line">            buflen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Ignore bytes beyond the allocated size of intermediate buffer */</span></span><br><span class="line">        <span class="comment">/* Since 8 bytes are read ahead, ensure 8 bytes are free at the</span></span><br><span class="line"><span class="comment">        end of the buffer, which will be memset to 0 after emulation prevention */</span></span><br><span class="line">        buflen = MIN(buflen, buf_size - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        bytes_consumed = buflen + u4_length_of_start_code;</span><br><span class="line">        ps_dec_op-&gt;u4_num_bytes_consumed += bytes_consumed;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            UWORD8 u1_firstbyte, u1_nal_ref_idc;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;i4_app_skip_mode == IVD_SKIP_B)</span><br><span class="line">            &#123;</span><br><span class="line">                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);</span><br><span class="line">                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));</span><br><span class="line">                <span class="keyword">if</span>(u1_nal_ref_idc == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*skip non reference frames*/</span></span><br><span class="line">                    cur_slice_is_nonref = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="number">1</span> == cur_slice_is_nonref)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">/*We have encountered a referenced frame,return to app*/</span></span><br><span class="line">                        ps_dec_op-&gt;u4_num_bytes_consumed -=</span><br><span class="line">                                        bytes_consumed;</span><br><span class="line">                        ps_dec_op-&gt;e_pic_type = IV_B_FRAME;</span><br><span class="line">                        ps_dec_op-&gt;u4_error_code =</span><br><span class="line">                                        IVD_DEC_FRM_SKIPPED;</span><br><span class="line">                        ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span></span><br><span class="line">                                        &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">                        ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line">                        ps_dec_op-&gt;u4_size =</span><br><span class="line">                                        <span class="keyword">sizeof</span>(<span class="keyword">ivd_video_decode_op_t</span>);</span><br><span class="line">                        <span class="comment">/*signal the decode thread*/</span></span><br><span class="line">                        ih264d_signal_decode_thread(ps_dec);</span><br><span class="line">                        <span class="comment">/* close deblock thread if it is not closed yet*/</span></span><br><span class="line">                        <span class="keyword">if</span>(ps_dec-&gt;u4_num_cores == <span class="number">3</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            ih264d_signal_bs_deblk_thread(ps_dec);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(buflen)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,</span><br><span class="line">                   buflen);</span><br><span class="line">            <span class="comment">/* Decoder may read extra 8 bytes near end of the frame */</span></span><br><span class="line">            <span class="keyword">if</span>((buflen + <span class="number">8</span>) &lt; buf_size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>(pu1_bitstrm_buf + buflen, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            u4_first_start_code_found = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*start code not found*/</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(u4_first_start_code_found == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*no start codes found in current process call*/</span></span><br><span class="line"></span><br><span class="line">                ps_dec-&gt;i4_error_code = ERROR_START_CODE_NOT_FOUND;</span><br><span class="line">                ps_dec_op-&gt;u4_error_code |= <span class="number">1</span> &lt;&lt; IVD_INSUFFICIENTDATA;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ps_dec-&gt;u4_pic_buf_got == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    ih264d_fill_output_struct_from_context(ps_dec,</span><br><span class="line">                                                           ps_dec_op);</span><br><span class="line"></span><br><span class="line">                    ps_dec_op-&gt;u4_error_code = ps_dec-&gt;i4_error_code;</span><br><span class="line">                    ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    ps_dec-&gt;u1_pic_decode_done = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* a start code has already been found earlier in the same process call*/</span></span><br><span class="line">                frame_data_left = <span class="number">0</span>;</span><br><span class="line">                header_data_left = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ps_dec-&gt;u4_return_to_app = <span class="number">0</span>;</span><br><span class="line">        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,</span><br><span class="line">                              pu1_bitstrm_buf, buflen);</span><br><span class="line">        <span class="keyword">if</span>(ret != OK)</span><br><span class="line">        &#123;</span><br><span class="line">            UWORD32 error =  ih264d_map_error(ret);</span><br><span class="line">            ps_dec_op-&gt;u4_error_code = error | ret;</span><br><span class="line">            api_ret_value = IV_FAIL;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((ret == IVD_RES_CHANGED)</span><br><span class="line">                            || (ret == IVD_MEM_ALLOC_FAILED)</span><br><span class="line">                            || (ret == ERROR_UNAVAIL_PICBUF_T)</span><br><span class="line">                            || (ret == ERROR_UNAVAIL_MVBUF_T)</span><br><span class="line">                            || (ret == ERROR_INV_SPS_PPS_T)</span><br><span class="line">                            || (ret == IVD_DISP_FRM_ZERO_OP_BUF_SIZE))</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec-&gt;u4_slice_start_code_found = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))</span><br><span class="line">            &#123;</span><br><span class="line">                ps_dec_op-&gt;u4_num_bytes_consumed -= bytes_consumed;</span><br><span class="line">                api_ret_value = IV_FAIL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(ret == ERROR_IN_LAST_SLICE_OF_PIC)</span><br><span class="line">            &#123;</span><br><span class="line">                api_ret_value = IV_FAIL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ps_dec-&gt;u4_return_to_app)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*We have encountered a referenced frame,return to app*/</span></span><br><span class="line">            ps_dec_op-&gt;u4_num_bytes_consumed -= bytes_consumed;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code = IVD_DEC_FRM_SKIPPED;</span><br><span class="line">            ps_dec_op-&gt;u4_error_code |= (<span class="number">1</span> &lt;&lt; IVD_UNSUPPORTEDPARAM);</span><br><span class="line">            ps_dec_op-&gt;u4_frame_decoded_flag = <span class="number">0</span>;</span><br><span class="line">            ps_dec_op-&gt;u4_size = <span class="keyword">sizeof</span>(<span class="keyword">ivd_video_decode_op_t</span>);</span><br><span class="line">            <span class="comment">/*signal the decode thread*/</span></span><br><span class="line">            ih264d_signal_decode_thread(ps_dec);</span><br><span class="line">            <span class="comment">/* close deblock thread if it is not closed yet*/</span></span><br><span class="line">            <span class="keyword">if</span>(ps_dec-&gt;u4_num_cores == <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ih264d_signal_bs_deblk_thread(ps_dec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (IV_FAIL);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        header_data_left = ((ps_dec-&gt;i4_decode_header == <span class="number">1</span>)</span><br><span class="line">                        &amp;&amp; (ps_dec-&gt;i4_header_decoded != <span class="number">3</span>)</span><br><span class="line">                        &amp;&amp; (ps_dec_op-&gt;u4_num_bytes_consumed</span><br><span class="line">                                        &lt; ps_dec_ip-&gt;u4_num_Bytes));</span><br><span class="line">        frame_data_left = (((ps_dec-&gt;i4_decode_header == <span class="number">0</span>)</span><br><span class="line">                        &amp;&amp; ((ps_dec-&gt;u1_pic_decode_done == <span class="number">0</span>)</span><br><span class="line">                                        || (u4_next_is_aud == <span class="number">1</span>)))</span><br><span class="line">                        &amp;&amp; (ps_dec_op-&gt;u4_num_bytes_consumed</span><br><span class="line">                                        &lt; ps_dec_ip-&gt;u4_num_Bytes));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(( header_data_left == <span class="number">1</span>)||(frame_data_left == <span class="number">1</span>));</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码还是超级多，就不详细分析了，，，编解码知识需要长时间积累再做第四节分析了。</p><h4 id="（四）、libavc库分析"><a href="#（四）、libavc库分析" class="headerlink" title="（四）、libavc库分析"></a>（四）、libavc库分析</h4><p><strong>Todo—</strong></p><blockquote><p>\external\libavc（libavc 库）</p><ul><li>encoder</li><li>decoder</li><li>common</li></ul></blockquote><h4 id="（五）、Others编解码"><a href="#（五）、Others编解码" class="headerlink" title="（五）、Others编解码"></a>（五）、Others编解码</h4><p>由于播放流程基本一致，区别每个编解码用的库不一样，其他的编解码暂时不分析了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">\frameworks\av\media\libstagefright\omx\SoftOMXPlugin.cpp</span><br><span class="line">kComponents[] = &#123;</span><br><span class="line">    &#123; &quot;OMX.google.aac.decoder&quot;, &quot;aacdec&quot;, &quot;audio_decoder.aac&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.aac.encoder&quot;, &quot;aacenc&quot;, &quot;audio_encoder.aac&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.amrnb.decoder&quot;, &quot;amrdec&quot;, &quot;audio_decoder.amrnb&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.amrnb.encoder&quot;, &quot;amrnbenc&quot;, &quot;audio_encoder.amrnb&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.amrwb.decoder&quot;, &quot;amrdec&quot;, &quot;audio_decoder.amrwb&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.amrwb.encoder&quot;, &quot;amrwbenc&quot;, &quot;audio_encoder.amrwb&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.h264.decoder&quot;, &quot;avcdec&quot;, &quot;video_decoder.avc&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.h264.encoder&quot;, &quot;avcenc&quot;, &quot;video_encoder.avc&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.hevc.decoder&quot;, &quot;hevcdec&quot;, &quot;video_decoder.hevc&quot; &#125;, /* todo start */</span><br><span class="line">    &#123; &quot;OMX.google.g711.alaw.decoder&quot;, &quot;g711dec&quot;, &quot;audio_decoder.g711alaw&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.g711.mlaw.decoder&quot;, &quot;g711dec&quot;, &quot;audio_decoder.g711mlaw&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.mpeg2.decoder&quot;, &quot;mpeg2dec&quot;, &quot;video_decoder.mpeg2&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.h263.decoder&quot;, &quot;mpeg4dec&quot;, &quot;video_decoder.h263&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.h263.encoder&quot;, &quot;mpeg4enc&quot;, &quot;video_encoder.h263&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.mpeg4.decoder&quot;, &quot;mpeg4dec&quot;, &quot;video_decoder.mpeg4&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.mpeg4.encoder&quot;, &quot;mpeg4enc&quot;, &quot;video_encoder.mpeg4&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.mp3.decoder&quot;, &quot;mp3dec&quot;, &quot;audio_decoder.mp3&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.vorbis.decoder&quot;, &quot;vorbisdec&quot;, &quot;audio_decoder.vorbis&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.opus.decoder&quot;, &quot;opusdec&quot;, &quot;audio_decoder.opus&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.vp8.decoder&quot;, &quot;vpxdec&quot;, &quot;video_decoder.vp8&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.vp9.decoder&quot;, &quot;vpxdec&quot;, &quot;video_decoder.vp9&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.vp8.encoder&quot;, &quot;vpxenc&quot;, &quot;video_encoder.vp8&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.raw.decoder&quot;, &quot;rawdec&quot;, &quot;audio_decoder.raw&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.flac.encoder&quot;, &quot;flacenc&quot;, &quot;audio_encoder.flac&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.google.gsm.decoder&quot;, &quot;gsmdec&quot;, &quot;audio_decoder.gsm&quot; &#125;,</span><br><span class="line">#ifdef QTI_FLAC_DECODER</span><br><span class="line">    &#123; &quot;OMX.qti.audio.decoder.flac&quot;, &quot;flacdec&quot;, &quot;audio_decoder.flac&quot; &#125;,</span><br><span class="line">#endif</span><br><span class="line">#ifdef DOLBY_ENABLE</span><br><span class="line">    &#123; &quot;OMX.dolby.ac3.decoder&quot;, &quot;ddpdec&quot;, &quot;audio_decoder.ac3&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.dolby.eac3.decoder&quot;, &quot;ddpdec&quot;, &quot;audio_decoder.eac3&quot; &#125;,</span><br><span class="line">    &#123; &quot;OMX.dolby.eac3_joc.decoder&quot;, &quot;ddpdec&quot;, &quot;audio_decoder.eac3_joc&quot; &#125;, /* todo end*/</span><br><span class="line">#endif // DOLBY_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.iosxxx.com/blog/2017-08-09-%E4%BB%8E%E9%9B%B6%E4%BA%86%E8%A7%A3H264%E7%BB%93%E6%9E%84.html" target="_blank" rel="noopener">从零了解H264结构</a><br><a href="http://read.pudn.com/downloads147/ebook/635957/%E6%96%B0%E4%B8%80%E4%BB%A3%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81%E6%A0%87%E5%87%86H.264.pdf" target="_blank" rel="noopener">新一代视频压缩编码标准H.264</a></p></div><div class="post-announce">Thank you for reading, this article belongs to <a href="http://zhoujinjian.cc">๑Charles✦ˑ̫✦Vincent๑</a> copyright, if reproduced, please indicate the source：๑Charles✦ˑ̫✦Vincent๑（<a href="http://zhoujinjian.cc/2018/10/06/Android Video System（9）：Android Multimedia Codecs - H264编解码分析/">http://zhoujinjian.cc/2018/10/06/Android Video System（9）：Android Multimedia Codecs - H264编解码分析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/10/03/Android Video System（8）：Android Multimedia Codecs - AMR编解码分析/" title="Android Video System（8）：Android Multimedia Codecs - AMR编解码分析"><i class="iconfont icon-prev"></i>Android Video System（8）：Android Multimedia Codecs - AMR编解码分析</a></div><div class="post__prev post__prev--right"><a href="/2088/08/08/zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】/" title="zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】">zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。</p></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/Hexo/">Hexo</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">30</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2088/08/08/zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】/" title="zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2088.08.08.jpg" alt="zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】"></div><div class="item__info"><h3 class="item__title">zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】</h3><span class="item__text">2088-08-08</span></div></a></li><li class="latest-post-item"><a href="/2018/10/06/Android Video System（9）：Android Multimedia Codecs - H264编解码分析/" title="Android Video System（9）：Android Multimedia Codecs - H264编解码分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.31.jpg" alt="Android Video System（9）：Android Multimedia Codecs - H264编解码分析"></div><div class="item__info"><h3 class="item__title">Android Video System（9）：Android Multimedia Codecs - H264编解码分析</h3><span class="item__text">2018-10-06</span></div></a></li><li class="latest-post-item"><a href="/2018/10/03/Android Video System（8）：Android Multimedia Codecs - AMR编解码分析/" title="Android Video System（8）：Android Multimedia Codecs - AMR编解码分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.30.jpg" alt="Android Video System（8）：Android Multimedia Codecs - AMR编解码分析"></div><div class="item__info"><h3 class="item__title">Android Video System（8）：Android Multimedia Codecs - AMR编解码分析</h3><span class="item__text">2018-10-03</span></div></a></li><li class="latest-post-item"><a href="/2018/10/01/Android Video System（7）：Android Multimedia Codecs - AAC编解码分析/" title="Android Video System（7）：Android Multimedia Codecs - AAC编解码分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.29.jpg" alt="Android Video System（7）：Android Multimedia Codecs - AAC编解码分析"></div><div class="item__info"><h3 class="item__title">Android Video System（7）：Android Multimedia Codecs - AAC编解码分析</h3><span class="item__text">2018-10-01</span></div></a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">开始的开始亦是结束•结束的结束亦是开始</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>izhoujinjian@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/DreamWorks_2016_Stacked-MI-512x512.png" alt="logo" title="๑Charles✦ˑ̫✦Vincent๑"></div><div class="footer-top__item"><h3 class="item__title">Friend Links</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://keyin.me/" title="World of Forks" target="_blank">World of Forks</a></li><li class="list-item"><a href="https://molunerfinn.com/" title="MARKSZのBlog" target="_blank">MARKSZのBlog</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Hexo-theme-skapp" target="_blank">Hexo-theme-skapp</a></li><li class="list-item"><a href="http://zhoujinjian.cc/" title="๑Charles✦ˑ̫✦Vincent๑" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">Build Tools</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://dribbble.com/" title="Dribbble" target="_blank">Dribbble</a></li><li class="list-item"><a href="https://pages.github.com/" title="Blog Framework" target="_blank">Github-Pages</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Made by <a href="https://github.com/izhoujinjian" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/izhoujinjian" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:izhoujinjian@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>🍀<span class="post-count">396.1k</span> </span><span>| </span><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>