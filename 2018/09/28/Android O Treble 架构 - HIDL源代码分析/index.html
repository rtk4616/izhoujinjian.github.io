<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Android O Treble 架构 - HIDL源代码分析 | ๑Charles✦ˑ̫✦Vincent๑</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑"><meta name="designer" content="minfive"><meta name="keywords" content="zhoujinjian, zhoujinjian blog, Android, 源代码, ActivityManagerService, AMS, WindowManagerService, WMS , zygote ，InputManagerService , SurfaceFlinger, SystemServer , Binder , Graphics , Kernel , Linux"><meta name="description" content="嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta name="baidu-site-verification" content="7AVr5WpX72"><link rel="canonical" href="http://zhoujinjian.cc/2018/09/28/Android O Treble 架构 - HIDL源代码分析/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="๑Charles✦ˑ̫✦Vincent๑"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c54bda95ff8b34e8be2edd1d138812c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117331438-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-117331438-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading-small.gif)"></div><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="๑Charles✦ˑ̫✦Vincent๑" alt="๑Charles✦ˑ̫✦Vincent๑"><img src="/img/Logo.png" alt="๑Charles✦ˑ̫✦Vincent๑"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><div id="page" class="page js-hidden"><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.28.jpg" alt="Android O Treble 架构 - HIDL源代码分析"></div><header class="post__info"><h1 class="post__title">Android O Treble 架构 - HIDL源代码分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/izhoujinjian">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-09-28</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></header><div class="post__content"><div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）、Android-O-Treble-架构介绍"><span class="toc-text">（一）、Android O Treble 架构介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-0、Android整体架构变化（VNDK、VINTF、HIDL）"><span class="toc-text">1.0、Android整体架构变化（VNDK、VINTF、HIDL）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-1、Binder通信域变化"><span class="toc-text">1.1、Binder通信域变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2、vndbinder-amp-amp-vndservicemanager"><span class="toc-text">1.2、vndbinder &amp;&amp; vndservicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-1、vndbinder"><span class="toc-text">1.2.1、vndbinder</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-2、vndservicemanager"><span class="toc-text">1.2.2、vndservicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-3、servicemanager"><span class="toc-text">1.2.3、servicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-3、hwservicemanager"><span class="toc-text">1.3、hwservicemanager</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-4、Binder库变化"><span class="toc-text">1.4、Binder库变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-5、Binder通信框架变化"><span class="toc-text">1.5、Binder通信框架变化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-6、框架层Binder对象变化"><span class="toc-text">1.6、框架层Binder对象变化</span></a></li></ol></li></ol><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译"><span class="toc-text">（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、生成子Android-mk和Android-bp文件"><span class="toc-text">2.1、生成子Android.mk和Android.bp文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、hidl-gen工具"><span class="toc-text">2.2、hidl-gen工具</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）、Android-O-Treble-之-hwservicemanager-启动过程"><span class="toc-text">（三）、Android O Treble 之 hwservicemanager 启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、创建BnHwServiceManager"><span class="toc-text">3.1、创建BnHwServiceManager</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2、IPCThreadState-gt-setTheContextObject-service"><span class="toc-text">3.2、IPCThreadState-&gt;setTheContextObject(service)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3、BinderCallback"><span class="toc-text">3.3、BinderCallback</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4、hwservicemanager-继续关系"><span class="toc-text">3.4、hwservicemanager 继续关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程"><span class="toc-text">（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#4-1、ILight-registerAsService"><span class="toc-text">4.1、ILight::registerAsService()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-2、sm-gt-add-serviceName-c-str-this-添加light-service"><span class="toc-text">4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-3、joinRpcThreadpool"><span class="toc-text">4.3、joinRpcThreadpool()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程"><span class="toc-text">（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1、服务查询-hidl-get"><span class="toc-text">5.1、服务查询_hidl_get()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2、接口转换IXXX-castFrom"><span class="toc-text">5.2、接口转换IXXX::castFrom()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（六）、Android-O-Treble-之-HIDL服务Java框架实现"><span class="toc-text">（六）、Android O Treble 之 HIDL服务Java框架实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-1、Java-hidl服务创建过程"><span class="toc-text">6.1、Java hidl服务创建过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-2、Java层服务注册（add）查询（get）过程"><span class="toc-text">6.2、Java层服务注册（add）查询（get）过程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（七）、参考资料-特别感谢各位前辈的分析和图示-："><span class="toc-text">（七）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></div><hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/o.hidl.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p>首先感谢：</p><p><a href="https://blog.csdn.net/yangwen123" target="_blank" rel="noopener">【YANGWEN123】Android O Treble架构（系列分析文章）</a><br><a href="https://www.slideshare.net/opersys/androids-hidl-treble-in-the-hal" target="_blank" rel="noopener">【Karim Yaghmour】Android’s HIDL: Treble in the HAL - SlideShare</a></p><p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，再次感谢！！！</p><p>Google Pixel、Pixel XL 内核代码（==<strong>文章基于 Kernel-4.x</strong>==）：<br><a href="https://github.com/izhoujinjian/wahoo" target="_blank" rel="noopener">Kernel source for Pixel 2 (walleye) and Pixel 2 XL (taimen) - GitHub</a></p><p>AOSP 源码（==<strong>文章基于 Android 8.x</strong>==）：<br><a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener">Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>==源码（部分）==：</p><blockquote><p>Java框架</p></blockquote><p>/frameworks/base/core/java/android/os/（JAVA）</p><ul><li>IHwInterface.java</li><li>HwBinder.java</li><li>HwRemoteBinder.java</li><li>IHwBinder.java</li><li>HwParcel.java</li></ul><p>/frameworks/base/core/jni/（JNI）</p><ul><li>android_os_HwRemoteBinder.cpp</li><li>android_os_HwBinder.cpp</li><li>android_os_HwParcel.cpp</li></ul><blockquote><p>Native框架</p></blockquote><p>/system/libhwbinder/</p><ul><li>Binder.cpp</li><li>BpHwBinder.cpp</li><li>IInterface.cpp</li><li>IPCThreadState.cpp</li><li>Parcel.cpp</li><li>ProcessState.cpp</li></ul><p>/system/libhidl/transport/</p><ul><li>HidlBinderSupport.cpp</li><li>HidlTransportSupport.cpp</li><li>ServiceManagement.cpp</li><li>/manager/1.0/IServiceManager.hal</li><li>/manager/1.0/IServiceNotification.hal</li></ul><p>/system/hwservicemanager/</p><ul><li>HidlService.cpp</li><li>hwservicemanager.rc</li><li>ServiceManager.cpp</li><li>service.cpp</li></ul><blockquote><p>Binder Driver（Kernel）</p></blockquote><p>/drivers/android/</p><ul><li>binder.c</li><li>binder_alloc.c</li></ul><blockquote><p>源码编译生成路径（Java）：</p></blockquote><p>\out\target\common\gen\JAVA_LIBRARIES</p><ul><li>android.hardware.light-V2.0-java_intermediates</li><li>android.hidl.manager-V1.0-java_intermediates</li><li>……</li></ul><blockquote><p>源码编译生成路径（hardware/interfaces/）：</p></blockquote><p>\out\soong.intermediates\system\</p><ul><li>libhidl\transport\manager\1.1\android.hidl.manager@1.1_genc++</li></ul><p>\out\soong.intermediates\hardware\interfaces*</p><ul><li>light\2.0\android.hardware.light@2.0_genc++</li><li>audio\2.0\android.hardware.audio@2.0_genc++</li><li>camera*</li><li>graphics*</li><li>media*</li><li>wifi*</li><li>……</li></ul><hr><blockquote><p>注：文中图文许多参考<a href="https://blog.csdn.net/yangwen123/" target="_blank" rel="noopener">快乐安卓</a>，由于博主有点小小的强迫症，把图片水印都去掉了，请各位见谅！</p></blockquote><h4 id="（一）、Android-O-Treble-架构介绍"><a href="#（一）、Android-O-Treble-架构介绍" class="headerlink" title="（一）、Android O Treble 架构介绍"></a>（一）、Android O Treble 架构介绍</h4><h6 id="1-0、Android整体架构变化（VNDK、VINTF、HIDL）"><a href="#1-0、Android整体架构变化（VNDK、VINTF、HIDL）" class="headerlink" title="1.0、Android整体架构变化（VNDK、VINTF、HIDL）"></a>1.0、Android整体架构变化（VNDK、VINTF、HIDL）</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-01-HIDL-treble-after.png.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-02-HIDL-treble-architecture.png.png" alt="Alt text | center"></p><p>AndroidO引入Treble架构后的变化:</p><ol><li><p>增加了2个服务管家，Android O 之前版本有且只有一个servicemanager，现在增加到3个(servicemanager、hwservicemanager、vndservicemanager)，他们分管不同的服务。</p></li><li><p>增加了binder通信库，这是为了适配binder域的扩展。</p></li><li><p>增加了binder域，系统定义了3个binder设备节点，binder驱动分别处理这3个binder设备节点上的binder通信事件。</p></li></ol><h6 id="1-1、Binder通信域变化"><a href="#1-1、Binder通信域变化" class="headerlink" title="1.1、Binder通信域变化"></a>1.1、Binder通信域变化</h6><p>Treble架构的引入足以说明Binder通信的重要性，之前APP和Framework之间通过binder实现跨进程调用，当然这个调用对开发者来说是透明的，相当于函数本地调用。Treble引入后，Framework和HAL又实现了进程分离，Framework和HAL之间依然使用binder通信，通过HIDL来定义通信接口。那binder通信有什么变化呢？ 在Treble中，引入了多个binder域，主要是增加了多个binder设备，binder驱动实现原理基本没变，变化了一些细节。增加binder设备应该是为了实现更换的权限控制，使用不同binder设备的主体和客体之间的selinux权限有所不同，同时，Android 框架和 HAL 现在使用 Binder 互相通信。由于这种通信方式极大地增加了 Binder 流量。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-03-HIDL-Binder-enhancement.png" alt="Alt text | center"></p><p>为了明确地拆分框架（与设备无关）和供应商（与具体设备相关）代码之间的 Binder 流量，Android O 引入了“Binder 上下文”这一概念。每个 Binder 上下文都有自己的设备节点和上下文（服务）管理器。您只能通过上下文管理器所属的设备节点对其进行访问，并且在通过特定上下文传递 Binder 节点时，只能由另一个进程从相同的上下文访问上下文管理器，从而确保这些域完全互相隔离。为了显示 /dev/vndbinder，请确保内核配置项 CONFIG_ANDROID_BINDER_DEVICES 设为”binder,hwbinder,vndbinder”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;kernel/android/configs/android-base.cfg]</span><br><span class="line">CONFIG_ANDROID_BINDER_DEVICES=binder,hwbinder,vndbinder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[-&gt;kernel/drivers/android/binder.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span><br><span class="line">module_param_named(devices, binder_devices_param, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Copy the module_parameter string, because we don't want to</span></span><br><span class="line"><span class="comment">	 * tokenize it in-place.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">	......</span><br><span class="line">	<span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">","</span>))) &#123;</span><br><span class="line">		ret = init_binder_device(device_name);</span><br><span class="line">		......</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">	binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">	......</span><br><span class="line">	ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">	......</span><br><span class="line">	hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以kernel参数形式得到配置的binder设备节点名称，然后在binder驱动中创建不同的binder设备：<br>这样在驱动中就创建了binder、vndbinder、hwbinder三个驱动设备，并保存在binder设备列表binder_devices中。/dev/binder 设备节点成为了框架进程的专属节点，这意味着oem进程将无法再访问该节点。oem进程可以访问 /dev/hwbinder，但必须将其 AIDL 接口转为使用 HIDL。</p><h6 id="1-2、vndbinder-amp-amp-vndservicemanager"><a href="#1-2、vndbinder-amp-amp-vndservicemanager" class="headerlink" title="1.2、vndbinder &amp;&amp; vndservicemanager"></a>1.2、vndbinder &amp;&amp; vndservicemanager</h6><p>一直以来，供应商进程都使用 Binder 进程间通信 (IPC) 技术进行通信。在 Android O 中，/dev/binder 设备节点成为了框架进程的专属节点，这意味着供应商进程将无法再访问该节点。供应商进程可以访问 /dev/hwbinder，但必须将其 AIDL 接口转为使用 HIDL。对于想要继续在供应商进程之间使用 AIDL 接口的供应商，Android 会按以下方式支持 Binder IPC。</p><h6 id="1-2-1、vndbinder"><a href="#1-2-1、vndbinder" class="headerlink" title="1.2.1、vndbinder"></a>1.2.1、vndbinder</h6><p>Android O 支持供应商服务使用新的 Binder 域，这可通过使用 /dev/vndbinder（而非 /dev/binder）进行访问。添加 /dev/vndbinder 后，Android 现在拥有以下 3 个 IPC 域：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-04-HIDL-hwbinder-vndbinder.png" alt="Alt text | center"></p><p>通常，供应商进程不直接打开 Binder 驱动程序，而是链接到打开 Binder 驱动程序的 libbinder 用户空间库。为 ::android::ProcessState() 添加方法可为 libbinder 选择 Binder 驱动程序。供应商进程应该在调用 ProcessState,、IPCThreadState 或发出任何普通 Binder 调用之前调用此方法。要使用该方法，请在供应商进程（客户端和服务器）的 main() 后放置以下调用：</p><p>ProcessState::initWithDriver(“/dev/vndbinder”);</p><h6 id="1-2-2、vndservicemanager"><a href="#1-2-2、vndservicemanager" class="headerlink" title="1.2.2、vndservicemanager"></a>1.2.2、vndservicemanager</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-05-HIDL-hwservicemanager.png" alt="Alt text | center"></p><p>以前，Binder 服务通过 servicemanager 注册，其他进程可从中检索这些服务。在 Android O 中，servicemanager 现在专用于框架和应用进程，供应商进程无法再对其进行访问。</p><p>不过，供应商服务现在可以使用 vndservicemanager，这是一个使用 /dev/vndbinder（<strong>作为构建基础的源代码与框架 servicemanager 相同/frameworks/native/cmds/servicemanager/</strong>）而非 /dev/binder 的 servicemanager 的新实例。供应商进程无需更改即可与 vndservicemanager 通信；当供应商进程打开 /dev/vndbinder 时，服务查询会自动转至 vndservicemanager。</p><p>vndservicemanager 二进制文件包含在 Android 的默认设备 Makefile 中。<br>servicemanager和vndservicemanager使用的是同一份代码，都是由service_manager.c编译而来。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/]</span><br><span class="line">Android.bp</span><br><span class="line">bctest.c</span><br><span class="line">binder.c</span><br><span class="line">binder.h</span><br><span class="line">service_manager.c</span><br><span class="line">servicemanager.rc</span><br><span class="line">vndservicemanager.rc</span><br><span class="line"></span><br><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/service_manager.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>]; <span class="comment">/* /dev/vndbinder */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">    sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在启动servicemanager 时，并没有传参，而启动vndservicemanager时，传递了binder设备节点。</p><blockquote><p>service servicemanager /system/bin/servicemanager<br>service vndservicemanager /vendor/bin/vndservicemanager ==<strong>/dev/vndbinder</strong>==<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/vndservicemanager.rc]</span><br><span class="line">service vndservicemanager /vendor/bin/vndservicemanager /dev/vndbinder</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br></pre></td></tr></table></figure><p></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/servicemanager.rc]</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span> <span class="title">animation</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">healthd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">surfaceflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">inputflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">drm</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">keystore</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">gatekeeperd</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br></pre></td></tr></table></figure><h6 id="1-2-3、servicemanager"><a href="#1-2-3、servicemanager" class="headerlink" title="1.2.3、servicemanager"></a>1.2.3、servicemanager</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-05-HIDL-servicemanager.png.png" alt="Alt text | center"></p><h6 id="1-3、hwservicemanager"><a href="#1-3、hwservicemanager" class="headerlink" title="1.3、hwservicemanager"></a>1.3、hwservicemanager</h6><p>hwservicemanager用于管理hidl服务，因此其实现和servicemanager完全不同，使用的binder库也完全不同。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-05-HIDL-vndservicemanager.png.png" alt="Alt text | center"></p><h6 id="1-4、Binder库变化"><a href="#1-4、Binder库变化" class="headerlink" title="1.4、Binder库变化"></a>1.4、Binder库变化</h6><p>servicemanager和vndservicemanager都使用libbinder库，只是他们使用的binder驱动不同而已，而hwservicemanager使用libhwbinder库，binder驱动也不同。</p><p>libbinder库源码(\frameworks\native\libs\binder)<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-06-libbinder-sourcecode.png" alt="Alt text | center"></p><p>libhwbinder库源码：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-07-libhwbinder-sourcecode.png" alt="Alt text | center"></p><p>文件对比：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-08-HIDL-binder-hwbinder-file-compare.png" alt="Alt text | center"></p><h6 id="1-5、Binder通信框架变化"><a href="#1-5、Binder通信框架变化" class="headerlink" title="1.5、Binder通信框架变化"></a>1.5、Binder通信框架变化</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-09-HIDL-binder-binder_ipc_process.jpg" alt="Alt text | center"></p><p>1.在普通Java Binder框架中，Client端Proxy类完成数据打包，然后交给mRemotebinder代理来完成数据传输。Server端Stub类完成数据解析，然后交给其子类实现。</p><p>2.在普通Native Binder框架中，Client端BpXXX类完成数据打包，然后交给mRemoteBpBinder来完成数据传输。Server端BnXXX类完成数据解析，然后交个其子类实现。</p><ol><li>在HwBinder框架中，Client端的BpHwXXX类完成数据打包，然后交给mRemoteBpHwBinder来完成数据传输。Server端的BnHwXXX类完成数据解析，然后交给_hidl_mImpl来实现。</li></ol><h6 id="1-6、框架层Binder对象变化"><a href="#1-6、框架层Binder对象变化" class="headerlink" title="1.6、框架层Binder对象变化"></a>1.6、框架层Binder对象变化</h6><p>参考：<a href="https://blog.csdn.net/yangwen123/article/details/79836109" target="_blank" rel="noopener">【AndroidO Treble架构下的变化】</a><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-10-HIDL-binder-hwbinder-fw-compare.png" alt="Alt text | center"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-11-HIDL-hwbinder-object.png" alt="Alt text | center"></p><h4 id="（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译"><a href="#（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译" class="headerlink" title="（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译"></a>（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译</h4><p>HIDL是一种接口定义语言，描述了HAL和它的用户之间的接口。同aidi类似，我们只需要为hal定义相关接口，然后通过hidl-gen工具即可自动编译生成对应的C++或者java源文件，定义hal接口的文件命名为xxx.hal，为了编译这些.hal文件，需要编写相应的Android.bp或者Android.mk文件:</p><ol><li><p>Android.bp文件用于编译C++；</p></li><li><p>Android.mk文件用于编译Java；</p></li></ol><h5 id="2-1、生成子Android-mk和Android-bp文件"><a href="#2-1、生成子Android-mk和Android-bp文件" class="headerlink" title="2.1、生成子Android.mk和Android.bp文件"></a>2.1、生成子Android.mk和Android.bp文件</h5><p>所有的HIDL Interface 都是通过一个.hal文件来描述，为了方便编译生成每一个子hal。Google在系统默认提供了一个脚本update-makefiles.sh，位于hardware/interfaces/、frameworks/hardware/interfaces/、system/hardware/interfaces/、system/libhidl/。以hardware/interfaces/里面的代码为实例做介绍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">source system/tools/hidl/update-makefiles-helper.sh</span><br><span class="line"> </span><br><span class="line">do_makefiles_update \</span><br><span class="line">  <span class="string">"android.hardware:hardware/interfaces"</span> \</span><br></pre></td></tr></table></figure><p>这个脚本的主要作用：根据hal文件生成Android.mk(makefile)和Android.bp(blueprint)文件。在hardware/interfaces的子目录里面，存在.hal文件的目录，都会产生Android.bp和Android.mk文件。详细分析如下：</p><ol><li>source system/tools下面的update-makefiles-helper.sh，然后执行do_makefiles_update</li><li>解析传入进去的参数。参数android.hardware:hardware/interfaces:<br>android.hardware: android.hardware表示包名。<br>hardware/interfaces：表示相对于根目录的文件路径。<br>会输出如下LOG：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Updating makefiles <span class="keyword">for</span> android.hardware in hardware/interfaces.</span><br><span class="line">Updating ….</span><br></pre></td></tr></table></figure><p>3.获取所有的包名。通过function get_packages()函数，获取hardware/interfaces路径下面的所有hal文件所在的目录路径，比如子目录Light里面的hal文件的路径是\hardware\interfaces\light\2.0，加上当前的参数包名hardware/interfaces，通过点的方式连接，将light/2.0+hardware/interfaces里面的斜线转换成点,最终获取的包名就是 android.hardware.light@2.0，依次类推获取所有的包名。<br>4.执行hidl-gen命令.将c步骤里面获取的参数和包名还有类名传入hidl-gen命令，在\hardware\interfaces\light\2.0目录下产生Android.mk和Android.bp文件。<br>Android.mk: hidl-gen -Lmakefile -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport android.hardware.light@2.0</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-12-HIDL-android-hal-make.png" alt="Alt text | center"></p><p>编译最终在./out/target/common/gen/JAVA_LIBRARIES目录下生成Java源文件。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-13-HIDL-android-make-java.png" alt="Alt text | center"></p><pre><code>Android.bp: hidl-gen -Landroidbp -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport android.hidl.manager@1.0
</code></pre><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-14-HIDL-android-hal-manager.png" alt="Alt text | center"></p><p>编译最终在./out/soong/.intermediates/hardware/interfaces目录下生成C++源文件。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-15-HIDL-android-hal-manager-gen-c++.png" alt="Alt text | center"></p><p>5.在hardware/interfaces的每个子目录下面产生Android.bp文件，文件内容主要是subdirs的初始化，存放当前目录需要包含的子目录。比如hardware/interfaces/light/下面的Android.bp文件。</p><p>经过以上步骤，就会在对应的子目录产生Android.mk和Android.bp文件。这样以后我们就可以执行正常的编译命令进行编译了。比如mmm hardware/interfaces/light/,默认情况下，在源码中，Android.mk和Android.bp文件已经存在。</p><h5 id="2-2、hidl-gen工具"><a href="#2-2、hidl-gen工具" class="headerlink" title="2.2、hidl-gen工具"></a>2.2、hidl-gen工具</h5><p>在Treble架构中，系统定义的所有的.hal接口，都是通过hidl-gen工具转换成对应的代码。比如\hardware\interfaces\light\2.0\ILight.hal，会通过hidl-gen转换成\out\soong.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++\gen\android\hardware\light\2.0\LightAll.cpp文件。<br>hidl-gen源码路径：system/tools/hidl，是在ubuntu上可执行的二进制文件。<br>使用方法：hidl-gen -o output-path -L language (-r interface-root) fqname<br>参数含义：<br>-L： 语言类型，包括c++, c++-headers, c++-sources, export-header, c++-impl, java, java-constants, vts, makefile, androidbp, androidbp-impl, hash等。hidl-gen可根据传入的语言类型产生不同的文件。fqname：完全限定名称的输入文件。比如本例中android.hardware.light@2.0，要求在源码目录下必须有hardware/interfaces/light/2.0/目录。<br>对于单个文件来说，格式如下：package@version::fileName，比如android.hardware.light@1.0::types.Feature。<br>对于目录来说。格式如下package@version，比如android.hardware.light@2.0。<br>-r： 格式package:path，可选，对fqname对应的文件来说，用来指定包名和文件所在的目录到Android系统源码根目录的路径。如果没有制定，前缀默认是：android.hardware，目录是Android源码的根目录。<br>-o ： 存放hidl-gen产生的中间文件的路径。我们查看\hardware\interfaces\light\2.0\Android.bp，可以看到，-o参数都是写的$(genDir),一般都是在\out\soong.intermediates\hardware\interfaces\light\2.0\下面，根据-L的不同，后面产生的路径可能不太一样，比如c++，那么就会就是\out\soong.intermediates\hardware\interfaces\light\2.0\gen，如果是c++-headers，那么就是\out\soong.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++_headers\gen。</p><p>对于实例来说，fqname是：android.hardware.light@2.0，包名是android.hardware，文件所在的目录是hardware/interfaces。例子中的命令会在\out\soong.intermediates\hardware\interfaces\light\2.0\下面产生对应的c++文件。</p><p>在\hardware\interfaces\light\2.0\目录下mm编译将生成：</p><p>\system\lib64\android.hardware.light@2.0.so<br>\symbols\vendor\lib64\hw\android.hardware.light@2.0-impl.so<br>\vendor\etc\init\android.hardware.light@2.0-service.rc<br>\vendor\bin\hw\android.hardware.light@2.0-service</p><p>android.hardware.light@2.0-service为hal进程的可执行文件，在android.hardware.light@2.0-service.rc是hal进程启动的配置脚本文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\android.hardware.light@<span class="number">2.0</span>-service.rc]</span><br><span class="line"></span><br><span class="line">service light-hal<span class="number">-2</span><span class="number">-0</span> /vendor/bin/hw/android.hardware.light@<span class="number">2.0</span>-service</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hal</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br></pre></td></tr></table></figure><p>也就是说AndroidO的Treble架构下，所有hal都运行在独立的进程空间：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-16-HIDL-hal-process-.png" alt="Alt text | center"></p><h4 id="（三）、Android-O-Treble-之-hwservicemanager-启动过程"><a href="#（三）、Android-O-Treble-之-hwservicemanager-启动过程" class="headerlink" title="（三）、Android O Treble 之 hwservicemanager 启动过程"></a>（三）、Android O Treble 之 hwservicemanager 启动过程</h4><p>hwservicemanager是hidl服务管理中心，负责管理系统中的所有hidl服务，由init进程启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/rootdir/init.rc]</span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop <span class="keyword">and</span></span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    <span class="meta"># start essential services</span></span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanager</span><br></pre></td></tr></table></figure><p>可以看到在文件系统刚初始化没多久，就启动了系统非常重要的三个管理服务，接下来分析hwservicemanager的启动流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\hwservicemanager\hwservicemanager.rc]</span><br><span class="line">service hwservicemanager /system/bin/hwservicemanager</span><br><span class="line">    user system</span><br><span class="line">    disabled</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart setprop hwservicemanager.ready <span class="literal">false</span></span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">animation</span></span></span><br></pre></td></tr></table></figure><p>hwservicemanager的源码位于system\hwservicemanager\s。<br>我们从system\hwservicemanager\service.cpp 的main()入口函数开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\hwservicemanager\service.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    configureRpcThreadpool(<span class="number">1</span>, <span class="literal">true</span> <span class="comment">/* callerWillJoin */</span>);</span><br><span class="line">	<span class="comment">//创建ServiceManager对象</span></span><br><span class="line">    ServiceManager *manager = <span class="keyword">new</span> ServiceManager();</span><br><span class="line">	<span class="comment">//将ServiceManager对象自身注册到mServiceMap表中</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, manager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register hwservicemanager with itself."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//创建TokenManager对象</span></span><br><span class="line">    TokenManager *tokenManager = <span class="keyword">new</span> TokenManager();</span><br><span class="line">	<span class="comment">//将TokenManager对象自身注册到mServiceMap表中</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, tokenManager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register ITokenManager with hwservicemanager."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//建立消息循环</span></span><br><span class="line">    sp&lt;Looper&gt; looper(Looper::prepare(<span class="number">0</span> <span class="comment">/* opts */</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line">	<span class="comment">//将主线程加入binder线程池，并得到/dev/hwbinder句柄</span></span><br><span class="line">    IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">    <span class="keyword">if</span> (binder_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to aquire binder FD. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">    <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">	<span class="comment">//主线程监听EVENT_INPUT，通过回调BinderCallback处理</span></span><br><span class="line">    sp&lt;BinderCallback&gt; cb(<span class="keyword">new</span> BinderCallback);</span><br><span class="line">    <span class="keyword">if</span> (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,</span><br><span class="line">            <span class="literal">nullptr</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to add hwbinder FD to Looper. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//创建BnHwServiceManager对象</span></span><br><span class="line">    <span class="comment">// Tell IPCThreadState we're the service manager</span></span><br><span class="line">    sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line">    <span class="comment">// Then tell binder kernel</span></span><br><span class="line">    ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Only enable FIFO inheritance for hwbinder</span></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> remove define when in the kernel</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_INHERIT_FIFO_PRIO    _IO(<span class="meta-string">'b'</span>, 10)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rc = ioctl(binder_fd, BINDER_SET_INHERIT_FIFO_PRIO);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        ALOGE(<span class="string">"BINDER_SET_INHERIT_FIFO_PRIO failed with error %d\n"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//通过属性方式告知其他进程，hwservicemanager已经就绪</span></span><br><span class="line">    rc = property_set(<span class="string">"hwservicemanager.ready"</span>, <span class="string">"true"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to set \"hwservicemanager.ready\" (error %d). "</span>\</span><br><span class="line">              <span class="string">"HAL services will not start!\n"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//进入消息循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span> <span class="comment">/* timeoutMillis */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hwservicemanager启动过程比较简单，最重要的就是以下几行：</p><h5 id="3-1、创建BnHwServiceManager"><a href="#3-1、创建BnHwServiceManager" class="headerlink" title="3.1、创建BnHwServiceManager"></a>3.1、创建BnHwServiceManager</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line"><span class="comment">// Then tell binder kernel</span></span><br><span class="line">ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听请求</span></span><br><span class="line">sp&lt;BinderCallback&gt; cb(<span class="keyword">new</span> BinderCallback);</span><br><span class="line">looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,<span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure><p>这里创建一个binder本地对象BnHwServiceManager，然后注册到binder驱动中，让其他client进程都可以找到这个binder本地对象，然后为其创建binder代理对象。需要注意的是BnHwServiceManager的成员变量_hidl_mImpl保存的是ServiceManager实例，ServiceManager类实现了IServiceManager接口。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\1.1\android.hidl.manager@1.1_genc++\gen\android\hidl\manager\1.1\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">BnHwServiceManager::BnHwServiceManager(const ::android::sp&lt;IServiceManager&gt; &amp;_hidl_impl)</span><br><span class="line">        : ::android::hidl::base::V1_0::BnHwBase(_hidl_impl, &quot;android.hidl.manager@1.1&quot;, &quot;IServiceManager&quot;) &#123; </span><br><span class="line">            _hidl_mImpl = _hidl_impl;</span><br><span class="line">            auto prio = ::android::hardware::details::gServicePrioMap.get(_hidl_impl, &#123;SCHED_NORMAL, 0&#125;);</span><br><span class="line">            mSchedPolicy = prio.sched_policy;</span><br><span class="line">            mSchedPriority = prio.prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="3-2、IPCThreadState-gt-setTheContextObject-service"><a href="#3-2、IPCThreadState-gt-setTheContextObject-service" class="headerlink" title="3.2、IPCThreadState-&gt;setTheContextObject(service)"></a>3.2、IPCThreadState-&gt;setTheContextObject(service)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将BnHwServiceManager设置到IPCThreadState内部对象当中：</span></span><br><span class="line">sp&lt;BHwBinder&gt;         mContextObject;</span><br><span class="line"><span class="keyword">void</span> IPCThreadState::setTheContextObject(sp&lt;BHwBinder&gt; obj)</span><br><span class="line">&#123;</span><br><span class="line">    mContextObject = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3、BinderCallback"><a href="#3-3、BinderCallback" class="headerlink" title="3.3、BinderCallback"></a>3.3、BinderCallback</h5><p>通过循环监听binder_fd，当有请求时会回调BinderCallback的handleEvent()函数，这部分的知识请参考<br><a href="http://zhoujinjian.cc/2017/08/01/Android-7-1-2-Android-N-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%93Handler%E3%80%81Looper%E3%80%81Message/">【Android 7.1.2 (Android N) Android消息机制–Handler、Looper、Message 分析】</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\core\libutils\Looper.cpp]</span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理请求 handlePolledCommands<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinderCallback() &#123;&#125;</span><br><span class="line">    ~BinderCallback() override &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> override </span>&#123;</span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>进一步通过talkWithDriver() 和 executeCommand(cmd) 处理请求，这一部分跟普通的binder通信就没有区别了，这里就不做分析了。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\IPCThreadState.cpp]</span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::handlePolledCommands()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize());</span><br><span class="line"></span><br><span class="line">    processPendingDerefs();</span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        .......</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="3-4、hwservicemanager-继续关系"><a href="#3-4、hwservicemanager-继续关系" class="headerlink" title="3.4、hwservicemanager 继续关系"></a>3.4、hwservicemanager 继续关系</h5><p>hwservicemanager进程中的servicemanager作为hidl服务，同样适用了hwbinder框架，其类继承关系图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-17-HIDL-binder-bnservicemanager.png" alt="Alt text | center"></p><h4 id="（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程"><a href="#（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程" class="headerlink" title="（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程"></a>（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程</h4><p>这里以light模块为例子（其他模块类似）:</p><blockquote><p><a href="https://blog.csdn.net/ly890700/article/details/62424821" target="_blank" rel="noopener">Android 7.0 init.rc的一点改变</a><br>在Android 7之前的版本中，系统Native服务，不管它们的可执行文件位于系统什么位置都定义在根分区的init.*.rc文件中。这造成init＊.rc文件臃肿庞大，给维护带来了一些不便，而且其中定义的一些服务的二进制文件根本不存在。</p><p>但在Android 7.0中，对该机制做了一些改变 。</p><p>单一的init＊.rc，被拆分，服务根据其二进制文件的位置（/system，/vendor，/odm）定义到对应分区的etc/init目录中，每个服务一个rc文件。与该服务相关的触发器、操作等也定义在同一rc文件中。</p><ul><li>/system/etc/init，包含系统核心服务的定义，如SurfaceFlinger、MediaServer、Logcatd等。</li><li>/vendor/etc/init， SOC厂商针对SOC核心功能定义的一些服务。比如高通、MTK某一款SOC的相关的服务。</li><li>/odm/etc/init，OEM/ODM厂商如小米、华为、OPP其产品所使用的外设以及差异化功能相关的服务。</li></ul><p>这样的目录结构拆分，也与Android产品的开发流程相吻合，减轻了维护的负担。下图为Android7.0<br>模拟器/system/etc/init中定义的服务。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[源代码路径]</span><br><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\android.hardware.light@<span class="number">2.0</span>-service.rc]</span><br><span class="line">service light-hal<span class="number">-2</span><span class="number">-0</span> /vendor/bin/hw/android.hardware.light@<span class="number">2.0</span>-service</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hal</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">[编译生成路径（真机 /<span class="title">vendor</span>/<span class="title">etc</span>/<span class="title">init</span>）]</span></span><br><span class="line"><span class="class">[-&gt;\<span class="title">out</span>\<span class="title">target</span>\<span class="title">product</span>\<span class="title">msm8909go</span>\<span class="title">vendor</span>\<span class="title">etc</span>\<span class="title">init</span>\<span class="title">android</span>.<span class="title">hardware</span>.<span class="title">light</span>@2.0-<span class="title">service</span>.<span class="title">rc</span>]</span></span><br></pre></td></tr></table></figure><p>开机会注册android.hardware.light@2.0-service， 直接看main()函数<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\service.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;ILight&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着调用defaultPassthroughServiceImplementation<ilight>()模板函数</ilight></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\include\hidl\LegacySupport.h]</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">"default"</span>) &#123;</span><br><span class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">std</span>:</span>:<span class="built_in">string</span> name,</span><br><span class="line">                                            <span class="keyword">size_t</span> maxThreads = <span class="number">1</span>) &#123;</span><br><span class="line">    configureRpcThreadpool(maxThreads, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line">    ......</span><br><span class="line">    joinRpcThreadpool();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">size_t</span> <span class="title">maxThreads</span> = 1) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;Interface&gt;(<span class="string">"default"</span>, maxThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++\gen\android\hardware\light\2.0\LightAll.cpp]</span><br><span class="line">// static</span><br><span class="line">::android::sp&lt;ILight&gt; ILight::getService(const std::string &amp;serviceName, const bool getStub) &#123;</span><br><span class="line">    using ::android::hardware::defaultServiceManager;</span><br><span class="line">    using ::android::hardware::details::waitForHwService;</span><br><span class="line">    using ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    using ::android::hardware::Return;</span><br><span class="line">    using ::android::sp;</span><br><span class="line">    using Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line"></span><br><span class="line">    sp&lt;ILight&gt; iface = nullptr;</span><br><span class="line"></span><br><span class="line">    const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(ILight::descriptor, serviceName);</span><br><span class="line">    </span><br><span class="line">    Transport transport = transportRet;</span><br><span class="line">    const bool vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    const bool vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line">    ......</span><br><span class="line">    if (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        if (pm != nullptr) &#123;</span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                    pm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line">            if (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</span><br><span class="line">                if (baseInterface != nullptr) &#123;</span><br><span class="line">                    iface = ILight::castFrom(baseInterface);</span><br><span class="line">                    if (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface = new BsLight(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return iface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp<interface>service = Interface::getService(name, true /<em> getStub </em>/)所以getStub=true. 这里通过PassthroughServiceManager来获取ILight对象。其实所有的Hal 进程都是通过PassthroughServiceManager来得到hidl服务对象的，而作为Hal进程的Client端Framework进程在获取hidl服务对象时，需要通过hal的Transport类型来选择获取方式。</interface></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[\device\qcom\xxx\manifest.xml]</span><br><span class="line">    &lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.light&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;ILight&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">    &lt;/hal&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-18-HIDL-treble_cpp_legacy_hal_progression.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\libhidl\transport\ServiceManagement.cpp]</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager1_0&gt; getPassthroughServiceManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> getPassthroughServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager1_1&gt; getPassthroughServiceManager1_1() &#123;</span><br><span class="line">    <span class="keyword">static</span> sp&lt;PassthroughServiceManager&gt; manager(<span class="keyword">new</span> PassthroughServiceManager());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassthroughServiceManager</span> :</span> IServiceManager1_1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openLibs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fqName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span> <span class="comment">/* continue */</span>(<span class="keyword">void</span>* <span class="comment">/* handle */</span>,</span></span></span><br><span class="line">                const std::string&amp; /* lib */, const std::string&amp; /* sym */)&gt; eachLib) &#123;</span><br><span class="line">        <span class="comment">//fqName looks like android.hardware.foo@1.0::IFoo</span></span><br><span class="line">        <span class="keyword">size_t</span> idx = fqName.find(<span class="string">"::"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> packageAndVersion = fqName.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName = fqName.substr(idx + <span class="built_in">strlen</span>(<span class="string">"::"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> prefix = packageAndVersion + <span class="string">"-impl"</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sym = <span class="string">"HIDL_FETCH_"</span> + ifaceName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dlMode = RTLD_LAZY;</span><br><span class="line">        <span class="keyword">void</span> *handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; paths = &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR,</span><br><span class="line">                                          HAL_LIBRARY_PATH_VNDK_SP, HAL_LIBRARY_PATH_SYSTEM&#125;;</span><br><span class="line">                                          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path : paths) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; libs = search(path, prefix, <span class="string">".so"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib : libs) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = path + lib;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path != HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                    handle = android_load_sphal_library(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    handle = dlopen(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (!eachLib(handle, lib, sym)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的创建了一个PassthroughServiceManager对象。PassthroughServiceManager也实现了IServiceManager接口。然后通过PassthroughServiceManager询服务：</p><p>根据传入的fqName获取当前的接口名ILight，拼接出后面需要查找的函数名HIDL_FETCH_ILight和库名字android.hardware.light@2.0-impl.so,然后查找”/system/lib64/hw/“、”/vendor/lib64/hw/“、”/odm/lib64/hw/“下是否有对应的so库。接着通过dlopen载入/vendor/lib/hw/android.hardware.light@2.0-impl.so，然后通过dlsym查找并调用HIDL_FETCH_ILight函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\Light.cpp]</span><br><span class="line"><span class="function">ILight* <span class="title">HIDL_FETCH_ILight</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;Type, <span class="keyword">light_device_t</span>*&gt; lights;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span> &amp;pair : kLogicalLights) &#123;</span><br><span class="line">        Type type = pair.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = pair.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">light_device_t</span>* light = getLightDevice(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (light != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lights[type] = light;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lights.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Log information, but still return new Light.</span></span><br><span class="line">        <span class="comment">// Some devices may not have any lights.</span></span><br><span class="line">        ALOGI(<span class="string">"Could not open any lights."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Light(<span class="built_in">std</span>::move(lights));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-19-HIDL-binder-ILight-so-dlopen.png" alt="Alt text | center"></p><h6 id="4-1、ILight-registerAsService"><a href="#4-1、ILight-registerAsService" class="headerlink" title="4.1、ILight::registerAsService()"></a>4.1、ILight::registerAsService()</h6><p>首先会调用registerAsService()注册服务，然后joinRpcThreadpool()加入线程池<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> ILight::registerAsService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName) &#123;</span><br><span class="line">    ::android::hardware::details::onRegistration(<span class="string">"android.hardware.light@2.0"</span>, <span class="string">"ILight"</span>, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm</span><br><span class="line">            = ::android::hardware::defaultServiceManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ::android::INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; ret = sm-&gt;add(serviceName.c_str(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过defaultServiceManager()获取IServiceManager，接着add()添加服务</p><p>首先根据属性”hwservicemanager.ready”值判断hwservicemanager进程是否启动就绪，如果hwservicemanager已经启动，那么通过fromBinder<iservicemanager , bphwservicemanager,="" bnhwservicemanager="">( ProcessState::self()-&gt;getContextObject(NULL))来获取hwservicemanager的代理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\ServiceManagement.cpp]</span><br><span class="line">sp&lt;IServiceManager1_0&gt; defaultServiceManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IServiceManager1_1&gt; defaultServiceManager1_1() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(details::gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (details::gDefaultServiceManager != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access(<span class="string">"/dev/hwbinder"</span>, F_OK|R_OK|W_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitForHwServiceManager();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            details::gDefaultServiceManager =</span><br><span class="line">                    fromBinder&lt;IServiceManager1_1, BpHwServiceManager, BnHwServiceManager&gt;(</span><br><span class="line">                        ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></iservicemanager></p><p>首先看看ProcessState::getContextObject()</p><p>因此通过ProcessState::self()-&gt;getContextObject(NULL)将得到一个BpHwBinder对象，然后通过fromBinder<iservicemanager , bphwservicemanager,="" bnhwservicemanager="">进行转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\ProcessState.cpp]</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpHwBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></iservicemanager></p><p>第一次调用会调用fromBinder()函数，在这里将创建一个BpHwServiceManager对象，ProcessState::self()-&gt;getContextObject(NULL)如果返回的是远程binder对象，那么基于BpHwBinder创建BpHwServiceManager对象，BpHwBinder负责数据传输，而BpHwServiceManager服务数据业务，业务数据在BpHwServiceManager层打包好后，转交给BpHwBinder发送。如果getContextObject(NULL)返回的是本地binder对象，那么将这个本地binder对象强制转换为BnHwBase类型，从上图可知BnHwBase继承BHwBinder类，BHwBinder即是本地binder对象。<br>static_cast<bnhwbase *>(binderIface.get()) 然后通过BnHwBase的getImpl()函数得到其业务实现对象IBase。<br>sp<ibase>base =static_cast<bnhwbase *>(binderIface.get())-&gt;getImpl();</bnhwbase></ibase></bnhwbase></p><p>然后检查业务接口是否相同：<br>if (details::canCastInterface(base.get(),IType::descriptor))<br>如果业务接口类型相同，那么再次将这个本地binder对象转换为孙类BnHwServiceManager类型：<br>BnHwServiceManager<em> stub = static_cast&lt;BnHwServiceManager</em>&gt;(binderIface.get());<br>然后返回业务实现类对象ServiceManager对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\include\hidl\HidlBinderSupport.h]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IType, <span class="keyword">typename</span> ProxyType, <span class="keyword">typename</span> StubType&gt;</span><br><span class="line">sp&lt;IType&gt; fromBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binderIface) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::BnHwBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binderIface.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binderIface-&gt;localBinder() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyType(binderIface);</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;IBase&gt; base = <span class="keyword">static_cast</span>&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl();</span><br><span class="line">    <span class="keyword">if</span> (details::canCastInterface(base.get(), IType::descriptor)) &#123;</span><br><span class="line">        StubType* stub = <span class="keyword">static_cast</span>&lt;StubType*&gt;(binderIface.get());</span><br><span class="line">        <span class="keyword">return</span> stub-&gt;getImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 getImpl()函数实现，返回的是<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++_headers\gen\android\hidl\manager\<span class="number">1.0</span>\BnHwServiceManager.h]</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; _hidl_mImpl;</span><br><span class="line">    </span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; getImpl() &#123; <span class="keyword">return</span> _hidl_mImpl; &#125;;</span><br></pre></td></tr></table></figure><p></p><h6 id="4-2、sm-gt-add-serviceName-c-str-this-添加light-service"><a href="#4-2、sm-gt-add-serviceName-c-str-this-添加light-service" class="headerlink" title="4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service"></a>4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; BpHwServiceManager::add(<span class="keyword">const</span> ::android::hardware::hidl_string&amp; name, <span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; service)&#123;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_add(<span class="keyword">this</span>, <span class="keyword">this</span>, name, service);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; BpHwServiceManager::_hidl_add(::android::hardware::IInterface *_hidl_this, ::android::hardware::details::HidlInstrumentor *_hidl_this_instrumentor, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name, <span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; service) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    ::android::hardware::Parcel _hidl_data;</span><br><span class="line">    ::android::hardware::Parcel _hidl_reply;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err;</span><br><span class="line">    ::android::hardware::Status _hidl_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ::android::hardware::ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    _hidl_err = ::android::hardware::IInterface::asBinder(_hidl_this)-&gt;transact(<span class="number">2</span> <span class="comment">/* add */</span>, _hidl_data, &amp;_hidl_reply);</span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\BpHwBinder.cpp]</span><br><span class="line"><span class="keyword">status_t</span> BpHwBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags, TransactCallback <span class="comment">/*callback*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/libhwbinder/IPCThreadState.cpp]</span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION_SG, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitForResponse()会通过底层binder 驱动进入到服务端，服务端监听消息来到处理过后会调用onTransact()函数</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-20-HIDL-ioctl-kernel.png.png" alt="Alt text | center"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/libhwbinder/Binder.cpp]</span><br><span class="line">status_t BHwBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags, TransactCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">    status_t err = NO_ERROR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        default:</span><br><span class="line">            err = onTransact(code, data, reply, flags,</span><br><span class="line">                    [&amp;](auto &amp;replyParcel) &#123;</span><br><span class="line">                        replyParcel.setDataPosition(0);</span><br><span class="line">                        if (callback != NULL) &#123;</span><br><span class="line">                            callback(replyParcel);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::onTransact(</span><br><span class="line">        <span class="keyword">uint32_t</span> _hidl_code,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        <span class="keyword">uint32_t</span> _hidl_flags,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err = ::android::OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (_hidl_code) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> <span class="comment">/* add */</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> _hidl_is_oneway = _hidl_flags &amp; ::android::hardware::IBinder::FLAG_ONEWAY;</span><br><span class="line">            <span class="keyword">if</span> (_hidl_is_oneway != <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ::android::UNKNOWN_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _hidl_err = ::android::hidl::manager::V1_0::BnHwServiceManager::_hidl_add(<span class="keyword">this</span>, _hidl_data, _hidl_reply, _hidl_cb);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::_hidl_add(</span><br><span class="line">        ::android::hidl::base::V1_0::BnHwBase* _hidl_this,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* name;</span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*name), &amp;_hidl_name_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*name),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl_service_binder;</span><br><span class="line">        _hidl_err = _hidl_data.readNullableStrongBinder(&amp;_hidl_service_binder);</span><br><span class="line">        <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">        service = ::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl_service_binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atrace_begin(ATRACE_TAG_HAL, <span class="string">"HIDL::IServiceManager::add::server"</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _hidl_out_success = <span class="keyword">static_cast</span>&lt;BnHwServiceManager*&gt;(_hidl_this)-&gt;_hidl_mImpl-&gt;add(*name, service);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> _hidl_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的_hidl_mImpl即之前得到的::android::sp<iservicemanager>==_hidl_mImpl== 对象，所以会调用</iservicemanager></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\hwservicemanager\ServiceManager.cpp]</span><br><span class="line">Return&lt;<span class="keyword">bool</span>&gt; ServiceManager::add(<span class="keyword">const</span> hidl_string&amp; name, <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">pid_t</span> pid = IPCThreadState::self()-&gt;getCallingPid();</span><br><span class="line">    <span class="keyword">auto</span> context = mAcl.getContext(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = service-&gt;interfaceChain([&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;interfaceChain) &#123;</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; interfaceChain.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> fqName = interfaceChain[i];</span><br><span class="line"></span><br><span class="line">            PackageInterfaceMap &amp;ifaceMap = mServiceMap[fqName];</span><br><span class="line">            HidlService *hidlService = ifaceMap.lookup(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hidlService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ifaceMap.insertService(</span><br><span class="line">                    <span class="built_in">std</span>::make_unique&lt;HidlService&gt;(fqName, name, service, pid));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hidlService-&gt;getService() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> ret = hidlService-&gt;getService()-&gt;unlinkToDeath(<span class="keyword">this</span>);</span><br><span class="line">                    ret.isOk(); <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                hidlService-&gt;setService(service, pid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ifaceMap.sendPackageRegistrationNotification(fqName, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> linkRet = service-&gt;linkToDeath(<span class="keyword">this</span>, <span class="number">0</span> <span class="comment">/*cookie*/</span>);</span><br><span class="line">        linkRet.isOk(); <span class="comment">// ignore</span></span><br><span class="line">        isValidService = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> isValidService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成插入到PackageInterfaceMap &amp;ifaceMap 对象中，并添加一些监听。之后就可以查询到light service了。</p><h6 id="4-3、joinRpcThreadpool"><a href="#4-3、joinRpcThreadpool" class="headerlink" title="4.3、joinRpcThreadpool()"></a>4.3、joinRpcThreadpool()</h6><p>加入线程池，至此Light service 就启动起来了，可以等待Client的请求了<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\HidlTransportSupport.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinRpcThreadpool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(b/32756130) this should be transport-dependent</span></span><br><span class="line">    joinBinderRpcThreadpool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\system\libhidl\transport\HidlBinderSupport.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinBinderRpcThreadpool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\system\libhwbinder\IPCThreadState.cpp]</span><br><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>到此就完成了hidl服务注册。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-21-HIDL-hwbinder-ILight-add.png" alt="Alt text | center"></p><h4 id="（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程"><a href="#（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程" class="headerlink" title="（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程"></a>（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程</h4><p>这里以light模块为例子（其他模块类似）：<br>通过前面的分析我们知道，Hal进程启动时，会向hwservicemanager进程注册hidl服务，那么当Framework Server需要通过hal访问硬件设备时，首先需要查询对应的hidl服务，那么Client进程是如何查询hidl服务的呢？这篇文章将展开分析，这里再次以ILight为例进行展开。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-22-android-hwservicemanager-get.png" alt="Alt text | center"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/services/core/java/com/android/server/lights/LightsService.java]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(<span class="keyword">int</span> light, <span class="keyword">int</span> color, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS, <span class="keyword">int</span> brightnessMode)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* <span class="comment">/* env */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint light,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint colorARGB,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint flashMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint onMS,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint offMS,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint brightnessMode)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;ILight&gt; hal = LightHal::associate();</span><br><span class="line">    .......</span><br><span class="line">    Type type = <span class="keyword">static_cast</span>&lt;Type&gt;(light);</span><br><span class="line">    LightState state = constructState(</span><br><span class="line">        colorARGB, flashMode, onMS, offMS, brightnessMode);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        android::base::Timer t;</span><br><span class="line">        Return&lt;Status&gt; ret = hal-&gt;setLight(type, state);</span><br><span class="line">        processReturn(ret, type, state);</span><br><span class="line">        <span class="keyword">if</span> (t.duration() &gt; <span class="number">50</span>ms) ALOGD(<span class="string">"Excessive delay setting light"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>associate() 会获取ILight::getService();这里通过ILight::getService()函数来查询ILight这个HIDL服务，由于这里没有传递任何参数，因此函数最终会调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++_headers\gen\android\hardware\light\<span class="number">2.0</span>\ILight.h]</span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;ILight&gt; getService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName=<span class="string">"default"</span>, <span class="keyword">bool</span> getStub=<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>注意，这里的getStub为false，说明加载hidl服务方式是由当前hidl服务的transport类型决定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[\device\qcom\xxx\manifest.xml]</span><br><span class="line">    &lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.light&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;ILight&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">    &lt;/hal&gt;</span><br></pre></td></tr></table></figure><p>由于ILight的transport是hwbinder类型，那么将从hwservicemanager中查询hidl服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">::android::sp&lt;ILight&gt; ILight::getService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::defaultServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::details::waitForHwService;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line">    <span class="keyword">using</span> ::android::sp;</span><br><span class="line">    <span class="keyword">using</span> Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line"></span><br><span class="line">    sp&lt;ILight&gt; iface = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(ILight::descriptor, serviceName);</span><br><span class="line">    </span><br><span class="line">    Transport transport = transportRet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; !getStub &amp;&amp; (vintfHwbinder || (vintfLegacy &amp;&amp; tries == <span class="number">0</span>)); tries++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (vintfHwbinder &amp;&amp; tries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            waitForHwService(ILight::descriptor, serviceName);</span><br><span class="line">        &#125;</span><br><span class="line">        Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                sm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line"></span><br><span class="line">        sp&lt;::android::hidl::base::V1_0::IBase&gt; base = ret;</span><br><span class="line"></span><br><span class="line">        Return&lt;sp&lt;ILight&gt;&gt; castRet = ILight::castFrom(base, <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br><span class="line"></span><br><span class="line">        iface = castRet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> iface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                    pm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line">            <span class="keyword">if</span> (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</span><br><span class="line">                <span class="keyword">if</span> (baseInterface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    iface = ILight::castFrom(baseInterface);</span><br><span class="line">                    <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface = <span class="keyword">new</span> BsLight(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过sm-&gt;get(ILight::descriptor, serviceName)查询ILight这个hidl服务，得到IBase对象后，在通过ILight::castFrom转换为ILight对象。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-23-HIDL-castFrom.png" alt="Alt text | center"></p><h5 id="5-1、服务查询-hidl-get"><a href="#5-1、服务查询-hidl-get" class="headerlink" title="5.1、服务查询_hidl_get()"></a>5.1、服务查询_hidl_get()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.1</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.1</span>\ServiceManagerAll.cpp]</span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; BpHwServiceManager::get(<span class="keyword">const</span> ::android::hardware::hidl_string&amp; fqName, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name)&#123;</span><br><span class="line">    ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_get(<span class="keyword">this</span>, <span class="keyword">this</span>, fqName, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\1.0\android.hidl.manager@1.0_genc++\gen\android\hidl\manager\1.0\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; BpHwServiceManager::_hidl_get(::android::hardware::IInterface *_hidl_this, ::android::hardware::details::HidlInstrumentor *_hidl_this_instrumentor, const ::android::hardware::hidl_string&amp; fqName, const ::android::hardware::hidl_string&amp; name) &#123;</span><br><span class="line">    </span><br><span class="line">    ::android::hardware::Parcel _hidl_data;</span><br><span class="line">    ::android::hardware::Parcel _hidl_reply;</span><br><span class="line">    ::android::status_t _hidl_err;</span><br><span class="line">    ::android::hardware::Status _hidl_status;</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; _hidl_out_service;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeInterfaceToken(BpHwServiceManager::descriptor);</span><br><span class="line"></span><br><span class="line">    size_t _hidl_fqName_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeBuffer(&amp;fqName, sizeof(fqName), &amp;_hidl_fqName_parent);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::writeEmbeddedToParcel(</span><br><span class="line">            fqName,</span><br><span class="line">            &amp;_hidl_data,</span><br><span class="line">            _hidl_fqName_parent,</span><br><span class="line">            0 /* parentOffset */);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    size_t _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeBuffer(&amp;name, sizeof(name), &amp;_hidl_name_parent);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::writeEmbeddedToParcel(</span><br><span class="line">            name,</span><br><span class="line">            &amp;_hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            0 /* parentOffset */);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::IInterface::asBinder(_hidl_this)-&gt;transact(1 /* get */, _hidl_data, &amp;_hidl_reply);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readFromParcel(&amp;_hidl_status, _hidl_reply);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl__hidl_out_service_binder;</span><br><span class="line">        _hidl_err = _hidl_reply.readNullableStrongBinder(&amp;_hidl__hidl_out_service_binder);</span><br><span class="line"></span><br><span class="line">        _hidl_out_service = ::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl__hidl_out_service_binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_status.setFromStatusT(_hidl_err);</span><br><span class="line">    return ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;(_hidl_out_service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个调用过程和hidl 添加服务过程完全一致，就是一个从BpHwServiceManager –&gt; BnHwServiceManager –&gt; ServiceManager的过程。但需要注意，BpHwServiceManager得到BnHwServiceManager返回过来的binder代理后，会通过fromBinder函数进行对象转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl__hidl_out_service_binder)</span><br></pre></td></tr></table></figure><p>hwservicemanager将ILight的binder代理BpHwBinder发给Framework Server进程，Framework Server进程拿到的依然是ILight的binder代理BpHwBinder对象，因此在fromBinder函数中将创建BpHwBase对象来封装BpHwBinder。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::_hidl_get(</span><br><span class="line">        ::android::hidl::base::V1_0::BnHwBase* _hidl_this,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* fqName;</span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_fqName_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*fqName), &amp;_hidl_fqName_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;fqName));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*fqName),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_fqName_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*name), &amp;_hidl_name_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;name));</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*name),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; _hidl_out_service = <span class="keyword">static_cast</span>&lt;BnHwServiceManager*&gt;(_hidl_this)-&gt;_hidl_mImpl-&gt;get(*fqName, *name);</span><br><span class="line"></span><br><span class="line">    ::android::hardware::writeToParcel(::android::hardware::Status::ok(), _hidl_reply);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_out_service == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _hidl_err = _hidl_reply-&gt;writeStrongBinder(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl_binder = ::android::hardware::toBinder&lt;</span><br><span class="line">                ::android::hidl::base::V1_0::IBase&gt;(_hidl_out_service);</span><br><span class="line">        <span class="keyword">if</span> (_hidl_binder.get() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _hidl_err = _hidl_reply-&gt;writeStrongBinder(_hidl_binder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _hidl_err = ::android::UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb(*_hidl_reply);</span><br><span class="line">    <span class="keyword">return</span> _hidl_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BnHwServiceManager通过ServiceManager对象查询到对应的hidl服务，返回IBase对象后，会调用toBinder函数转换为IBinder类型对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::android::hardware::toBinder&lt; ::android::hidl::base::V1_0::IBase&gt;(_hidl_out_service)</span><br></pre></td></tr></table></figure><p>由于在hwservicemanager这边，保存的是ILight的BpHwBase对象，因此在toBinder函数中将调用IInterface::asBinder来得到BpHwBase的成员变量中的BpHwBinder对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ifacePtr-&gt;isRemote()) &#123;</span><br><span class="line">	<span class="keyword">return</span> ::android::hardware::IInterface::asBinder(<span class="keyword">static_cast</span>&lt;ProxyType *&gt;(ifacePtr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务查询过程其实就是根据接口包名及服务名称，从hwservicemanager管理的表中查询对应的IBase服务对象，然后在Client进程空间分别创建BpHwBinder和BpHwBase对象。</p><h5 id="5-2、接口转换IXXX-castFrom"><a href="#5-2、接口转换IXXX-castFrom" class="headerlink" title="5.2、接口转换IXXX::castFrom()"></a>5.2、接口转换IXXX::castFrom()</h5><p>Framework Server进程通过上述hidl服务查询，得到了BpHwBase对象后，需要将其转换为与业务相关的代理对象，这就是通过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;ILight&gt;&gt; ILight::castFrom(<span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; parent, <span class="keyword">bool</span> emitError) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::castInterface&lt;ILight, ::android::hidl::base::V1_0::IBase, BpHwLight&gt;(</span><br><span class="line">            parent, <span class="string">"android.hardware.light@2.0::ILight"</span>, emitError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>system\libhidl\transport\include\hidl\HidlTransportSupport.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cast the interface IParent to IChild.</span></span><br><span class="line"><span class="comment">// Return nonnull if cast successful.</span></span><br><span class="line"><span class="comment">// Return nullptr if:</span></span><br><span class="line"><span class="comment">// 1. parent is null</span></span><br><span class="line"><span class="comment">// 2. cast failed because IChild is not a child type of IParent.</span></span><br><span class="line"><span class="comment">// 3. !emitError, calling into parent fails.</span></span><br><span class="line"><span class="comment">// Return an error Return object if:</span></span><br><span class="line"><span class="comment">// 1. emitError, calling into parent fails.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IChild, <span class="keyword">typename</span> IParent, <span class="keyword">typename</span> BpChild, <span class="keyword">typename</span> BpParent&gt;</span><br><span class="line">Return&lt;sp&lt;IChild&gt;&gt; castInterface(sp&lt;IParent&gt; parent, <span class="keyword">const</span> <span class="keyword">char</span> *childIndicator, <span class="keyword">bool</span> emitError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// casts always succeed with nullptrs.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; canCastRet = details::canCastInterface(parent.get(), childIndicator, emitError);</span><br><span class="line">    <span class="keyword">if</span> (!canCastRet.isOk()) &#123;</span><br><span class="line">        <span class="comment">// call fails, propagate the error if emitError</span></span><br><span class="line">        <span class="keyword">return</span> emitError</span><br><span class="line">                ? details::StatusOf&lt;<span class="keyword">bool</span>, sp&lt;IChild&gt;&gt;(canCastRet)</span><br><span class="line">                : Return&lt;sp&lt;IChild&gt;&gt;(sp&lt;IChild&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!canCastRet) &#123;</span><br><span class="line">        <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="literal">nullptr</span>); <span class="comment">// cast failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO b/32001926 Needs to be fixed for socket mode.</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// binderized mode. Got BpChild. grab the remote and wrap it.</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="keyword">new</span> BpChild(toBinder&lt;IParent, BpParent&gt;(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Passthrough mode. Got BnChild and BsChild.</span></span><br><span class="line">    <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="keyword">static_cast</span>&lt;IChild *&gt;(parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br></pre></td></tr></table></figure><p>这个模板函数展开后如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;sp&lt;ILight&gt;&gt; castInterface(sp&lt;IBase&gt; parent, <span class="keyword">const</span> <span class="keyword">char</span> *childIndicator, <span class="keyword">bool</span> emitError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// casts always succeed with nullptrs.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; canCastRet = details::canCastInterface(parent.get(), childIndicator, emitError);</span><br><span class="line">    <span class="keyword">if</span> (!canCastRet.isOk()) &#123;</span><br><span class="line">        <span class="comment">// call fails, propagate the error if emitError</span></span><br><span class="line">        <span class="keyword">return</span> emitError</span><br><span class="line">                ? details::StatusOf&lt;<span class="keyword">bool</span>, sp&lt;ILight&gt;&gt;(canCastRet)</span><br><span class="line">                : Return&lt;sp&lt;ILight&gt;&gt;(sp&lt;ILight&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!canCastRet) &#123;</span><br><span class="line">        <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="literal">nullptr</span>); <span class="comment">// cast failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO b/32001926 Needs to be fixed for socket mode.</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// binderized mode. Got BpChild. grab the remote and wrap it.</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="keyword">new</span> BpHwLight(toBinder&lt;IBase, BpParent&gt;(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Passthrough mode. Got BnChild and BsChild.</span></span><br><span class="line">    <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="keyword">static_cast</span>&lt;ILight*&gt;(parent.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此最终会创建一个BpHwLight对象。new BpHwLight(toBinder<ibase , bpparent="">(parent))</ibase></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-24-HIDL-binder-bphwxxxx.png" alt="Alt text | center"></p><h4 id="（六）、Android-O-Treble-之-HIDL服务Java框架实现"><a href="#（六）、Android-O-Treble-之-HIDL服务Java框架实现" class="headerlink" title="（六）、Android O Treble 之 HIDL服务Java框架实现"></a>（六）、Android O Treble 之 HIDL服务Java框架实现</h4><p>前面介绍了HIDL服务在native层的实现过程，包括HIDL服务加载创建、服务注册、服务查询过程等，那么Java层是否也实现了相关的服务框架呢？ 通常情况下，所有的Hal都实现在native层面，每个hal进程都是一个native进程，由init进程启动，在hal进程启动时会完成HIDL服务注册，Framework Server进程不一定完全是native进程，比如system_server进程，它运行在虚拟机环境中，由zygote进程fork而来，这时，Java层也需要请求HIDL服务，因此Android不仅在native层HIDL化了hal，在Java层同样也定义了相关的服务框架。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-25-Java-binder.png" alt="Alt text | center"></p><p>上图是Java层binder和hwbinder之间的类基础图对比。当我们定义一个.hal接口文件时，通过hidl-gen编译为Java文件后，将按上图中的类继承关系自动生成代码。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-26-Java-binder-class-inherit.png" alt="Alt text | center"></p><p>如上图所示，当我们定义IXXX.hal文件后，通过编译将在out/target/common/gen/JAVA_LIBRARIES目录下生成对应的IXXX.java，该文件按上述类继承关系自动生成相关代码，我们只需要定义一个XXXImp类，继承Stub并实现所有方法，然后在某个服务进程中创建一个XXXImp对象，并调用registerService（）函数进行hidl服务注册，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XXXImp mXXXImp = <span class="keyword">new</span> XXXImp();</span><br><span class="line">mXXXImp.registerAsService(<span class="string">"XXXImp"</span>);</span><br></pre></td></tr></table></figure><p>这样就完成了一个Java层的hidl服务注册，当然在当前Android系统中，大部分还是native层的hidl服务，Java层的hidl服务还是比较少的。从上述可知，Java层的hidl服务包括2个步骤：</p><ol><li>hidl服务对象创建；</li></ol><p>2.hidl服务注册；</p><h5 id="6-1、Java-hidl服务创建过程"><a href="#6-1、Java-hidl服务创建过程" class="headerlink" title="6.1、Java hidl服务创建过程"></a>6.1、Java hidl服务创建过程</h5><p>从上面的类继承图可知，hidl服务实现类继承于Stub，Stub又继承于HwBinder，因此创建一个XXXImp对象时，会调用HwBinder的构造函数。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-27-HwBinder.java.setup.png" alt="Alt text | center"></p><p>frameworks\base\core\java\android\os\HwBinder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HwBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	native_setup();</span><br><span class="line"> </span><br><span class="line">	sNativeRegistry.registerNativeAllocation(</span><br><span class="line">			<span class="keyword">this</span>,</span><br><span class="line">			mNativeContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">	<span class="keyword">long</span> freeFunction = native_init();</span><br><span class="line"> </span><br><span class="line">	sNativeRegistry = <span class="keyword">new</span> NativeAllocationRegistry(</span><br><span class="line">			HwBinder.class.getClassLoader(),</span><br><span class="line">			freeFunction,</span><br><span class="line">			<span class="number">128</span> <span class="comment">/* size */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建HwBinder对象会首先执行native_init()函数，然后调用native_setup()函数。<br>frameworks\base\core\jni\android_os_HwBinder.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">JHwBinder_native_init</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    JHwBinder::InitClass(env);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;releaseNativeContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JHwBinder_native_setup</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    sp&lt;JHwBinderHolder&gt; context = <span class="keyword">new</span> JHwBinderHolder;</span><br><span class="line">    JHwBinder::SetNativeContext(env, thiz, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建一个JHwBinderHolder 对象，并保存在HwBinder类的mNativeContext变量中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;JHwBinderHolder&gt; JHwBinder::SetNativeContext(</span><br><span class="line">        JNIEnv *env, jobject thiz, <span class="keyword">const</span> sp&lt;JHwBinderHolder&gt; &amp;context) &#123;</span><br><span class="line">    sp&lt;JHwBinderHolder&gt; old =</span><br><span class="line">        (JHwBinderHolder *)env-&gt;GetLongField(thiz, gFields.contextID);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        context-&gt;incStrong(<span class="literal">NULL</span> <span class="comment">/* id */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old-&gt;decStrong(<span class="literal">NULL</span> <span class="comment">/* id */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    env-&gt;SetLongField(thiz, gFields.contextID, (<span class="keyword">long</span>)context.get());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了多个binder类型：HwBinder、JHwBinderHolder、JHwBinder他们的类继承图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-28-Java-binder---.png" alt="Alt text | center"></p><p>红线标识了这3个类对象之间的关系，为了更加清晰地描述他们之间的关联关系，如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-29-HIDL-java-object.png" alt="Alt text | center"></p><h5 id="6-2、Java层服务注册（add）查询（get）过程"><a href="#6-2、Java层服务注册（add）查询（get）过程" class="headerlink" title="6.2、Java层服务注册（add）查询（get）过程"></a>6.2、Java层服务注册（add）查询（get）过程</h5><p>服务注册查询过程本质也是通过Native层的hwservicemanager来进行的。<br>（略）请参考大牛博客：<a href="https://blog.csdn.net/yangwen123/article/details/79876534" target="_blank" rel="noopener">Android O Treble架构下HIDL服务Java框架实现</a><br>到此Treble架构下的hwBinder实现过程就基本介绍完成。<br>总体架构：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-09-HIDL-binder-binder_ipc_process.jpg" alt="Alt text | center"></p><h4 id="（七）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考资料(特别感谢各位前辈的分析和图示)："></a>（七）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/yangwen123" target="_blank" rel="noopener">Android O Treble架构（系列分析文章） - CSDN博客</a><br><a href="http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android 7.1.2 (Android N) Android Binder 系统分析</a></p></div><div class="post-announce">Thank you for reading, this article belongs to <a href="http://zhoujinjian.cc">๑Charles✦ˑ̫✦Vincent๑</a> copyright, if reproduced, please indicate the source：๑Charles✦ˑ̫✦Vincent๑（<a href="http://zhoujinjian.cc/2018/09/28/Android O Treble 架构 - HIDL源代码分析/">http://zhoujinjian.cc/2018/09/28/Android O Treble 架构 - HIDL源代码分析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/09/17/Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议/" title="Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议"><i class="iconfont icon-prev"></i>Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</a></div><div class="post__prev post__prev--right"><a href="/2088/08/08/zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】/" title="zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】">zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。</p></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/Hexo/">Hexo</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">27</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2088/08/08/zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】/" title="zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2088.08.08.jpg" alt="zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】"></div><div class="item__info"><h3 class="item__title">zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】</h3><span class="item__text">2088-08-08</span></div></a></li><li class="latest-post-item"><a href="/2018/09/28/Android O Treble 架构 - HIDL源代码分析/" title="Android O Treble 架构 - HIDL源代码分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.28.jpg" alt="Android O Treble 架构 - HIDL源代码分析"></div><div class="item__info"><h3 class="item__title">Android O Treble 架构 - HIDL源代码分析</h3><span class="item__text">2018-09-28</span></div></a></li><li class="latest-post-item"><a href="/2018/09/17/Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议/" title="Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.27.jpg" alt="Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议"></div><div class="item__info"><h3 class="item__title">Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</h3><span class="item__text">2018-09-17</span></div></a></li><li class="latest-post-item"><a href="/2018/09/12/Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析/" title="Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.26.jpg" alt="Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析"></div><div class="item__info"><h3 class="item__title">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</h3><span class="item__text">2018-09-12</span></div></a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">开始的开始亦是结束•结束的结束亦是开始</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>izhoujinjian@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/DreamWorks_2016_Stacked-MI-512x512.png" alt="logo" title="๑Charles✦ˑ̫✦Vincent๑"></div><div class="footer-top__item"><h3 class="item__title">Friend Links</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://keyin.me/" title="World of Forks" target="_blank">World of Forks</a></li><li class="list-item"><a href="https://molunerfinn.com/" title="MARKSZのBlog" target="_blank">MARKSZのBlog</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Hexo-theme-skapp" target="_blank">Hexo-theme-skapp</a></li><li class="list-item"><a href="http://zhoujinjian.cc/" title="๑Charles✦ˑ̫✦Vincent๑" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">Build Tools</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://dribbble.com/" title="Dribbble" target="_blank">Dribbble</a></li><li class="list-item"><a href="https://pages.github.com/" title="Blog Framework" target="_blank">Github-Pages</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Made by <a href="https://github.com/izhoujinjian" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/izhoujinjian" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:izhoujinjian@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>🍀<span class="post-count">379.4k</span> </span><span>| </span><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>