<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Android Video System（1）：Video System(视频系统)框架分析 | ๑Charles✦ˑ̫✦Vincent๑</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑"><meta name="designer" content="minfive"><meta name="keywords" content="zhoujinjian, zhoujinjian blog, Android, 源代码, ActivityManagerService, AMS, WindowManagerService, WMS , zygote ，InputManagerService , SurfaceFlinger, SystemServer , Binder , Graphics , Kernel , Linux"><meta name="description" content="嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta name="baidu-site-verification" content="7AVr5WpX72"><link rel="canonical" href="http://zhoujinjian.cc/2018/06/01/Android Video System（1）：Video System(视频系统)框架分析/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="๑Charles✦ˑ̫✦Vincent๑"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c54bda95ff8b34e8be2edd1d138812c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117331438-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-117331438-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading-small.gif)"></div><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="๑Charles✦ˑ̫✦Vincent๑" alt="๑Charles✦ˑ̫✦Vincent๑"><img src="/img/Logo.png" alt="๑Charles✦ˑ̫✦Vincent๑"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><div id="page" class="page js-hidden"><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.16.jpg" alt="Android Video System（1）：Video System(视频系统)框架分析"></div><header class="post__info"><h1 class="post__title">Android Video System（1）：Video System(视频系统)框架分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/izhoujinjian">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-06-01</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></header><div class="post__content"><div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一-、Android-Video-Overview"><span class="toc-text">(一)、Android Video Overview</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二-、Android-MediaPlayer-amp-Nuplayer-框架分析"><span class="toc-text">(二)、Android MediaPlayer &amp; Nuplayer 框架分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、MediaPlayer"><span class="toc-text">2.1、MediaPlayer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1、MediaPlayer状态图"><span class="toc-text">2.1.1、MediaPlayer状态图:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-2、MediaPlayer和MediaPlayerService"><span class="toc-text">2.1.2、MediaPlayer和MediaPlayerService</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-3、创建MediaPlayer"><span class="toc-text">2.1.3、创建MediaPlayer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-4、setDataSource-设置播放资源"><span class="toc-text">2.1.4、setDataSource()设置播放资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-5、setDisplay"><span class="toc-text">2.1.5、setDisplay()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-6、播放器基本模型"><span class="toc-text">2.1.6、播放器基本模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、NuPlayer分析"><span class="toc-text">2.2、NuPlayer分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-0、NuPlayer简介"><span class="toc-text">2.2.0、NuPlayer简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-1、NuPlayer整体类关系图"><span class="toc-text">2.2.1、NuPlayer整体类关系图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-2、NuPlayer框架需要关注知识点"><span class="toc-text">2.2.2、NuPlayer框架需要关注知识点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper"><span class="toc-text">(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、AHandler接口分析（消息处理类）"><span class="toc-text">3.1、AHandler接口分析（消息处理类）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2、AMessage接口分析（消息载体）"><span class="toc-text">3.2、AMessage接口分析（消息载体）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3、ALooper接口分析（消息处理循环及后台线程）"><span class="toc-text">3.3、ALooper接口分析（消息处理循环及后台线程）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4、一个调用实例"><span class="toc-text">3.4、一个调用实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四-、NuPlayer源码分析"><span class="toc-text">(四)、NuPlayer源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1、主要接口和核心的类成员"><span class="toc-text">4.1、主要接口和核心的类成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2、setDataSourceAsync-现分析"><span class="toc-text">4.2、setDataSourceAsync()现分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3、prepareAsync"><span class="toc-text">4.3、prepareAsync()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4、setVideoSurfaceTextureAsync"><span class="toc-text">4.4、setVideoSurfaceTextureAsync()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5、start-pause"><span class="toc-text">4.5、start()/pause()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6、小结结和疑问"><span class="toc-text">4.6、小结结和疑问</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-7、Codec-Encoder-、Decoder列表附录"><span class="toc-text">4.7、Codec Encoder 、Decoder列表附录</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（五）、参考资料-特别感谢各位前辈的分析和图示-："><span class="toc-text">（五）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div><hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 - Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 - android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br><a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br><a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener">Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><h4 id="一-、Android-Video-Overview"><a href="#一-、Android-Video-Overview" class="headerlink" title="(一)、Android Video Overview"></a>(一)、Android Video Overview</h4><p>基于 OpenMAX 的视频解码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-01-OpenMax-Based video decode - data flow.png" alt="Alt text"></p><blockquote><p>YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。<a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV</a><br>VPU，Video processing unit</p></blockquote><p>基于 OpenMAX 的视频编码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-02-OpenMax-Based video encode - data flow.png.png" alt="Alt text"></p><p>视频框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-03-Video Architecture Software Stack.png" alt="Alt text"></p><p>组件描述：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-04-Q Component Description.png" alt="Alt text"></p><p>总结：<br>从视频框架可以了解到。视频文件先经Stagefright传到OMX decoder解码（软解或硬解）、OMX decoder将解码后的YUV数据回传到Stagefright，不断循环播放同时经由SurfaceFlinger渲染到LCD屏幕上。</p><h4 id="二-、Android-MediaPlayer-amp-Nuplayer-框架分析"><a href="#二-、Android-MediaPlayer-amp-Nuplayer-框架分析" class="headerlink" title="(二)、Android MediaPlayer &amp; Nuplayer 框架分析"></a>(二)、Android MediaPlayer &amp; Nuplayer 框架分析</h4><h5 id="2-1、MediaPlayer"><a href="#2-1、MediaPlayer" class="headerlink" title="2.1、MediaPlayer"></a>2.1、MediaPlayer</h5><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>通常MediaPlayer的调用逻辑是，构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，按照实际需求还会调用pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法。</p><h5 id="2-1-1、MediaPlayer状态图"><a href="#2-1-1、MediaPlayer状态图" class="headerlink" title="2.1.1、MediaPlayer状态图:"></a>2.1.1、MediaPlayer状态图:</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-05-MediaPlayer-status-turn-.png" alt="Alt text"></p><p>☯ Idle状态<br>调用new或reset()方法创建MediaPlayer后进入空闲<br>☯ End状态<br>调用release()后就结束<br>☯ Error状态<br>播放控制操作出错或无效状态下调用播放控制操作<br>☯ Initialized状态</p><p>调用setDataSource之后完成初始化<br>☯ Prepared状态<br>同步prepare()或异步prepareAsync()完成准备<br>☯ Preparing状态<br>是一种瞬时状态，调用prepareAsync()时会先进入此状态<br>☯ Started 状态<br>要开始播放必须调用start()<br>☯ Paused 状态<br>调用pause()并成功返回后播放可以被暂停<br>☯ Stopped状态<br>调用stop()会停止播放<br>☯ PlaybackCompleted状态<br>当播放到达流末端时，播放完成</p><h5 id="2-1-2、MediaPlayer和MediaPlayerService"><a href="#2-1-2、MediaPlayer和MediaPlayerService" class="headerlink" title="2.1.2、MediaPlayer和MediaPlayerService"></a>2.1.2、MediaPlayer和MediaPlayerService</h5><p>mediaserver 启动后会把media相关一些服务添加到servicemanager中，其中就有mediaPlayerService。这样应用启动前，系统就有了mediaPlayerService这个服务程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\mediaserver\main_mediaserver.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-06-Main_mediaserver.png" alt="Alt text"></p><h5 id="2-1-3、创建MediaPlayer"><a href="#2-1-3、创建MediaPlayer" class="headerlink" title="2.1.3、创建MediaPlayer"></a>2.1.3、创建MediaPlayer</h5><p>☯ Java应用程序中创建MediaPlayer对象<br>MediaPlayer mediaPlayer = new MediaPlayer();<br>☯ MediaPlayer的构造函数中比较重要的就是本地的native函数：native_setup()其对应的JNI函数为<br>android_media_MediaPlayer_native_setup()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-07-android_media_MediaPlayer_native_setup.png" alt="Alt text"></p><p>构造Native层的MediaPlayer对象的时候【MediaPlayer.cpp】，也会构造其父类的对象。在MediaPlayer的父类IMediaDeathNotifier中有个很重要的方法getMediaPlayerService()来获取MediaPlayerService，其关系到MediaPlayer和MediaPlayerService之间的通信。</p><h5 id="2-1-4、setDataSource-设置播放资源"><a href="#2-1-4、setDataSource-设置播放资源" class="headerlink" title="2.1.4、setDataSource()设置播放资源"></a>2.1.4、setDataSource()设置播放资源</h5><p>在整个应用程序的进程中，Mediaplayer.cpp 中 setDataSource会从service manager中获得mediaPlayerService 服务，然后通过服务来创建player，这个player就是播放器的真实实例，同时也使MediaPlayer和MediaPlayerService建立了联系。<br>在java层MediaPlayer.java中的setDataSource最终会调用_setDataSource方法，对应native层MediaPlayer.cpp中的setDataSource方法。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-08-mp_setDataSource.png" alt="Alt text"></p><p>通过 getMediaPlayerService 得到的BpMediaPlayerService类型的service，和mediaPlayerService进程中的BnMediaPlayerService 相对应负责binder通讯。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-09-MediaPlayerService_Create.png" alt="Alt text"></p><p>在create函数中创建了一个MediaPlayerService::Client的实例，是MediaPlayerService的内部类，也就是说MediaPlayerService会为每个client应用进程创建一个相应的MediaPlayerService::Client的实例，来实现播放以及播放过程的控制，向MediaPlayer发事件通知。到这里，在Server端的对象就创建完成了。</p><p>然后在MediaPlayer.cpp中就得到了一个sever端的player实例，它和本地其他类的实例没什么用法上的区别，而实际上则是通过binder机制运行在另外一个进程中的。获得此实例后继续player-&gt;setDataSource操作。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-10-player-setDataSource.png" alt="Alt text"></p><p>小结：<br>Java应用程序中使用MediaPlayer.java的setDataSource()会传递到Native层中MediaPlayer.cpp的setDataSource()去执行，而MediaPlayer.cpp又会把这个方法交给MediaPlayerservice去执行。MediaPlayerService则是使用NuPlayer实现的，最后， setDataSource还是交给了NuPlayer去执行了。这个过程把MediaPlayer和MediaPlayerService之间的联系建立起来，同时又把MediaPlayerService和NuPlayer的关系建立了起来。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-11-GenericSource-setDataSource.png" alt="Alt text"></p><h5 id="2-1-5、setDisplay"><a href="#2-1-5、setDisplay" class="headerlink" title="2.1.5、setDisplay()"></a>2.1.5、setDisplay()</h5><p>下一步就是java层的setDisplay，依然查看java层MediaPlayer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(SurfaceHolder sh)</span> </span>&#123;</span><br><span class="line">        mSurfaceHolder = sh;</span><br><span class="line">        Surface surface;</span><br><span class="line">        <span class="keyword">if</span> (sh != null) &#123;</span><br><span class="line">            surface = sh.getSurface();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            surface = null;</span><br><span class="line">        &#125;</span><br><span class="line">        _setVideoSurface(surface);</span><br><span class="line">        updateSurfaceScreenOn();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后会调用本地方法_setVideoSurface，我们继续找到它的jni实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setVideoSurface(env, thiz, jsurface, <span class="literal">true</span> <span class="comment">/* mediaPlayerMustBeAlive */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);<span class="comment">//获取C++的MediaPlayer</span></span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayerMustBeAlive) &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line">    decVideoSurfaceRef(env, thiz);</span><br><span class="line">	<span class="comment">//IGraphicBufferProducer图层缓冲区合成器</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; new_st;</span><br><span class="line">    <span class="keyword">if</span> (jsurface) &#123;</span><br><span class="line">	    <span class="comment">//得到java层的surface</span></span><br><span class="line">        sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));</span><br><span class="line">        <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	        <span class="comment">//获取IGraphicBufferProducer</span></span><br><span class="line">            new_st = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">if</span> (new_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface does not have a binding SurfaceTexture!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加IGraphicBufferProducer的强引用+1</span></span><br><span class="line">            new_st-&gt;incStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface has been released"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//上面我们在native_init方法中将java层mNativeSurfaceTexture查找给了jni层，正好，在这里将IGraphicBufferProducer赋给它</span></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will fail if the media player has not been initialized yet. This</span></span><br><span class="line">    <span class="comment">// can be the case if setDisplay() on MediaPlayer.java has been called</span></span><br><span class="line">    <span class="comment">// before setDataSource(). The redundant call to setVideoSurfaceTexture()</span></span><br><span class="line">    <span class="comment">// in prepare/prepareAsync covers for this case.</span></span><br><span class="line">    <span class="comment">//如果MediaPlayer没有初始化，这一步会失败。原因可能是setDisplay在setDataSource之前。如果在prepare/prepareAsync 时想规避这个错误而去调用setVideoSurfaceTexture是多余的。</span></span><br><span class="line">    <span class="comment">//最终会调用C++层的setVideoSurfaceTexture方法，下一节在分析</span></span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(new_st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decVideoSurfaceRef</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; old_st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (old_st != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old_st-&gt;decStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要是对图像显示的surface的保存，然后将旧的IGraphicBufferProducer强引用减一，再获得新的IGraphicBufferProducer，最后会调用C++的MediaPlayer的setVideoSurfaceTexture将它折纸进去。</p><p>IGraphicBufferProducer是SurfaceFlinger的内容，一个UI完全显示到diplay的过程，SurfaceFlinger扮演着重要的角色但是它的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上，而其他方面比如各个程序的绘画过程，就由其他东西来担任了。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-12-IGraphicBufferProducer.png" alt="Alt text"></p><p>虽说是三者的关系，但是他们所属的层却只有两个，app属于Java层，BufferQueue/SurfaceFlinger属于native层。也就是说BufferQueue也是隶属SurfaceFlinger，所有工作围绕SurfaceFlinger展开。<br>这里IGraphicBufferProducer就是app和BufferQueue重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。</p><h5 id="2-1-6、播放器基本模型"><a href="#2-1-6、播放器基本模型" class="headerlink" title="2.1.6、播放器基本模型"></a>2.1.6、播放器基本模型</h5><p>NuPlayer不管有多么神秘，说到底还是个播放器。在播放器的基本模型上，他与VCL、mplayer、ffmpeg等开源的结构是一致的。只是组织实现的方式不同。<br>深入了解NuPlayer之前，把播放器的基本模型总结一下，然后按照模型的各个部分来深入研究NuPlayer的实现方式。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-13-source-demux-decoder-output.jpg" alt="Alt text"></p><p>☯ datasource数据源：数据源，数据的来源不一定都是本地file，也有可能是网路上的各种协议例如：http、rtsp、HLS等。source的任务就是把数据源抽象出来，为下一个demux模块提供它需要的稳定的数据流。demux不用关信数据到底是从什么地方来的。</p><p>☯ demuxer解复用：视频文件一般情况下都是把音视频的ES流交织的通过某种规则放在一起。这种规则就是容器规则。现在有很多不同的容器格式。如ts、mp4、flv、mkv、avi、rmvb等等。demux的功能就是把音视频的ES流从容器中剥离出来，然后分别送到不同的解码器中。其实音频和视频本身就是2个独立的系统。容器把它们包在了一起。但是他们都是独立解码的，所以解码之前，需要把它分别 独立出来。demux就是干这活的，他为下一步decoder解码提供了数据流。</p><p>☯ decoder解码：解码器—-播放器的核心模块。分为音频和视频解码器。影像在录制后, 原始的音视频都是占用大量空间, 而且是冗余度较高的数据. 因此, 通常会在制作的时候就会进行某种压缩 ( 压缩技术就是将数据中的冗余信息去除数据之间的相关性 ). 这就是我们熟知的音视频编码格式, 包括MPEG1（VCD）\ MPEG2（DVD）\ MPEG4 \ H.264 等等. 音视频解码器的作用就是把这些压缩了的数据还原成原始的音视频数据. 当然, 编码解码过程基本上都是有损的 .解码器的作用就是把编码后的数据还原成原始数据。</p><p>☯ output输出：输出部分分为音频和视频输出。解码后的音频（pcm）和视频（yuv）的原始数据需要得到音视频的output模块的支持才能真正的让人的感官系统（眼和耳）辨识到。</p><p>所以，播放器大致分成上述4部分。怎么抽象的实现这4大部分、以及找到一种合理的方式将这几部分组织并运动起来。是每个播放器不同的实现方式而已。接下来就围绕这4大部分做深入学习，看看NuPlayer的工作原理。</p><h5 id="2-2、NuPlayer分析"><a href="#2-2、NuPlayer分析" class="headerlink" title="2.2、NuPlayer分析"></a>2.2、NuPlayer分析</h5><h5 id="2-2-0、NuPlayer简介"><a href="#2-2-0、NuPlayer简介" class="headerlink" title="2.2.0、NuPlayer简介"></a>2.2.0、NuPlayer简介</h5><p>Android2.3时引入流媒体框架，而流媒体框架的核心是NuPlayer。在之前的版本中一般认为Local Playback就用Stagefrightplayer+Awesomeplayer，流媒体用NuPlayer。Android4.0之后HttpLive和RTSP协议开始使用NuPlayer播放器，Android5.0（L版本）之后本地播放也开始使用NuPlayer播放器。 Android7.0(N版本)则完全去掉了Awesomeplayer。<br>通俗点说，NuPlayer是AOSP中提供的多媒体播放框架，能够支持本地文件、HTTP（HLS）、RTSP等协议的播放，通常支持H.264、H.265/HEVC、AAC编码格式，支持MP4、MPEG-TS封装。<br>在实现上NuPlayer和Awesomeplayer不同，NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来异步地处理请求，ALooper列队消息请求，AHandler中去处理，所以有更少的Mutex/Lock在NuPlayer中。Awesomeplayer中利用了omxcodec而NuPlayer中利用了Acodec。</p><h5 id="2-2-1、NuPlayer整体类关系图"><a href="#2-2-1、NuPlayer整体类关系图" class="headerlink" title="2.2.1、NuPlayer整体类关系图"></a>2.2.1、NuPlayer整体类关系图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-14-NuPlayer-arc.jpg" alt="Alt text"></p><p>NuPlayer由NuPlayerDriver封装，利用了底层的ALooper/AHandler机制来异步地处理请求，ALooper保存消息请求，然后在AHandler中处理。另外，NuPlayer中利用到了Acodec。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-15-NuPlayer-class.jpg" alt="Alt text"></p><p>☯ NuPlayer::Source<br>解析模块（parser，功能类似FFmpeg的avformat）。其接口与MediaExtractor和<br>MediaSource组合的接口差不多，同时提供了用于快速定位的seekTo接口。</p><p>☯ NuPlayer::Decoder<br>解码模块（decoder，功能类似FFmpeg的avcodec），封装了用于AVC、AAC解码的接口，<br>通过ACodec实现解码（包含OMX硬解码和软解码）。</p><p>☯ NuPlayer::Render<br>渲染模块（render，功能类似声卡驱动和显卡驱动），主要用于音视频渲染和同步，与<br>NativeWindow有关。</p><p>☯ NuPlayer 是播放框架中连接Source、Decoder、Renderer的纽带</p><p>☯ NuPlayerDriver<br>作为NuPlayer类的封装，直接调用NuPlayer。</p><p>NuPlayer框架中最顶层的类是NuPlayerDriver，继承自MediaPlayerInterface，主要提供一个状态转换机制，作为NuPlayer类的Wrapper。NuPlayerDriver类中最重要的成员是以下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; State mState 播放器状体标志 </span><br><span class="line">&gt; sp &lt;ALooper&gt; mLooper 内部消息驱动机制 </span><br><span class="line">&gt; sp &lt;NuPlayer&gt;  mPlayer 真正完成播放器的类</span><br></pre></td></tr></table></figure><p>NuPlayerDriver主要是 构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，实际需求pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法</p><h5 id="2-2-2、NuPlayer框架需要关注知识点"><a href="#2-2-2、NuPlayer框架需要关注知识点" class="headerlink" title="2.2.2、NuPlayer框架需要关注知识点"></a>2.2.2、NuPlayer框架需要关注知识点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NuPlayer的框架，其内部实现逻辑。那么最终就落实到如何从一个类中提取出需要的框架及知识点。那么一个类的对外接口部分通常包括：</span><br><span class="line">--- 构造函数和析构函数</span><br><span class="line">--- 必须调用的接口</span><br><span class="line">--- 可选的调用接口</span><br><span class="line"></span><br><span class="line">在多媒体播放中，通过关注的点有：</span><br><span class="line">--- 如何实现解复用，得到音频、视频、字幕等数据</span><br><span class="line">--- 如何实现解码</span><br><span class="line">--- 如何实现音视频同步</span><br><span class="line">--- 如何渲染视频</span><br><span class="line">--- 如何播放音频</span><br><span class="line">--- 如何实现快速定位</span><br></pre></td></tr></table></figure><h4 id="三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper"><a href="#三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper" class="headerlink" title="(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper"></a>(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper</h4><p>前文中提到过NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来<strong>异步地处理请求</strong>，ALooper保存消息请求，然后调用AHandler接口去处理。<br>实际上在代码中NuPlayer本身继承自AHandler类，而ALooper对象保存在NuPlayerDriver中。<br>ALooper/AHandler机制是模拟的消息循环处理方式，通常有三个主要部分：消息（message，通常包含Handler）、消息队列（queue）、消息处理线程（looper thread）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-16-AHandler-ALooper-AMessage.png" alt="Alt text"></p><p>对于handler消息机制，构成就必须包括一个Loop，message。那么对应的AHandler，也应该有对应的ALooper、AMessage。<br>因此本小节主要涉及到三个类ALooper、AHandler、AMessage。</p><h5 id="3-1、AHandler接口分析（消息处理类）"><a href="#3-1、AHandler接口分析（消息处理类）" class="headerlink" title="3.1、AHandler接口分析（消息处理类）"></a>3.1、AHandler接口分析（消息处理类）</h5><p>下面代码是AHandler接口:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AHandler.h"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AHandler</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AHandler();</span><br><span class="line"></span><br><span class="line">    ALooper::<span class="function">handler_id <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    sp&lt;ALooper&gt; looper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;ALooper&gt; getLooper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;AHandler&gt; getHandler() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>      <span class="comment">// deliverMessage()</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooperRoster</span>;</span> <span class="comment">// setID()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mMessageCounter;</span><br><span class="line">    KeyedVector&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; mMessages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(ALooper::handler_id id, wp&lt;ALooper&gt; looper)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliverMessage</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上面接口，初步印象是AHandler没有直接对外的接口（只有获取成员变量的接口），基本上只有一个onMessageReceived用于子类继承，deliverMessage用于给类AMessage使用，setID用于给友元类ALooperRoster使用。从这点来说，真正代码应该在AMessage里边。</p><h5 id="3-2、AMessage接口分析（消息载体）"><a href="#3-2、AMessage接口分析（消息载体）" class="headerlink" title="3.2、AMessage接口分析（消息载体）"></a>3.2、AMessage接口分析（消息载体）</h5><p>下面代码是AMessage的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AMessage.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AMessage();</span><br><span class="line">    AMessage(<span class="keyword">uint32_t</span> what, <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler); <span class="comment">// 代码中常用的构造函数</span></span><br><span class="line">    <span class="keyword">static</span> sp&lt;AMessage&gt; FromParcel(<span class="keyword">const</span> Parcel &amp;parcel, <span class="keyword">size_t</span> maxNestingLevel = <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write this AMessage to a parcel.</span></span><br><span class="line">    <span class="comment">// All items in the AMessage must have types that are recognized by</span></span><br><span class="line">    <span class="comment">// FromParcel(); otherwise, TRESPASS error will occur.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel *parcel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWhat</span><span class="params">(<span class="keyword">uint32_t</span> what)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> what() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这是一个AHandler，通过这个可以获得ALooper对象引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有设置的消息属性参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一系列设置/获取 Message 属性的函数。。。</span></span><br><span class="line">    <span class="keyword">void</span> setInt32/setInt64/setSize/setFloat/setDouble/setPointer/setPointer/setString/setRect/setObject/setBuffer/setMessage(...);</span><br><span class="line">    <span class="keyword">bool</span> findInt32/findInt64/findSize/findFloat/findDouble/findPointer/findString/findObject/findBuffer/findMessage/findRect(...) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过这个函数检索下指定名称的消息属性是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息的接口，顾名思义直接投递给构造函数的ALooper，注意支持延时消息，但不支持提前消息，delayUS &gt; 0</span></span><br><span class="line">    <span class="keyword">status_t</span> post(<span class="keyword">int64_t</span> delayUs = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息并等待执行结束后发送response消息</span></span><br><span class="line">    <span class="keyword">status_t</span> postAndAwaitResponse(sp&lt;AMessage&gt; *response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this returns true, the sender of this message is synchronously</span></span><br><span class="line">    <span class="comment">// awaiting a response and the reply token is consumed from the message</span></span><br><span class="line">    <span class="comment">// and stored into replyID. The reply token must be used to send the response</span></span><br><span class="line">    <span class="comment">// using "postReply" below.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">senderAwaitsResponse</span><span class="params">(sp&lt;AReplyToken&gt; *replyID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Posts the message as a response to a reply token.  A reply token can</span></span><br><span class="line">    <span class="comment">// only be used once. Returns OK if the response could be posted; otherwise,</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    sp&lt;AMessage&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个消息，并返回差异</span></span><br><span class="line">    sp&lt;AMessage&gt; changesFrom(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AMessage&gt; &amp;other, <span class="keyword">bool</span> deep = <span class="literal">false</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息属性存储的个数及特定索引上的消息属性参数</span></span><br><span class="line">    <span class="keyword">size_t</span> countEntries() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getEntryNameAt</span><span class="params">(<span class="keyword">size_t</span> index, Type *type)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AMessage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span>;</span> <span class="comment">// deliver()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mWhat;</span><br><span class="line"></span><br><span class="line">    wp&lt;AHandler&gt; mHandler;</span><br><span class="line">    wp&lt;ALooper&gt; mLooper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于ALooper调用的，发送消息的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的接口可以看出在使用AMessage是只需要指定消息的id和要处理该消息的AHandler即可，可以通过构造函数，也可以单独调用setWhat和setTarget接口。AMessage构造完成之后，可以调用setXXX设置对应的参数，通过findXXX获取传递的参数。最后通过post即可将消息投递到AHandler的消息队列中。</p><h5 id="3-3、ALooper接口分析（消息处理循环及后台线程）"><a href="#3-3、ALooper接口分析（消息处理循环及后台线程）" class="headerlink" title="3.3、ALooper接口分析（消息处理循环及后台线程）"></a>3.3、ALooper接口分析（消息处理循环及后台线程）</h5><p>其简化的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/ALooper.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    ALooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Takes effect in a subsequent call to start().</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">handler_id <span class="title">registerHandler</span><span class="params">(<span class="keyword">const</span> sp&lt;AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterHandler</span><span class="params">(handler_id handlerID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> start(<span class="keyword">bool</span> runOnCallingThread = <span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">bool</span> canCallJava = <span class="literal">false</span>, <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> stop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> int64_t <span class="title">GetNowUs</span><span class="params">()</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~ALooper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>       <span class="comment">// post()</span></span><br><span class="line"></span><br><span class="line">    AString mName;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> mWhenUs;</span><br><span class="line">        sp&lt;AMessage&gt; mMessage;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Event&gt; mEventQueue;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LooperThread</span>;</span></span><br><span class="line">    sp&lt;LooperThread&gt; mThread;</span><br><span class="line">    <span class="keyword">bool</span> mRunningLocally;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// START --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// posts a message on this looper with the given timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg, <span class="keyword">int64_t</span> delayUs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creates a reply token to be used with this looper</span></span><br><span class="line">    sp&lt;AReplyToken&gt; createReplyToken();</span><br><span class="line">    <span class="comment">// waits for a response for the reply token.  If status is OK, the response</span></span><br><span class="line">    <span class="comment">// is stored into the supplied variable.  Otherwise, it is unchanged.</span></span><br><span class="line">    <span class="keyword">status_t</span> awaitResponse(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, sp&lt;AMessage&gt; *response);</span><br><span class="line">    <span class="comment">// posts a reply for a reply token.  If the reply could be successfully posted,</span></span><br><span class="line">    <span class="comment">// it returns OK. Otherwise, it returns an error value.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// END --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ALooper对外接口比较简单，通常就是NuPlayerDriver构造函数中的调用逻辑。先创建一个ALooper对象，然后调用setName和start接口，之后调用registerHandler设置一个AHandler，这样就完成了初始化。在析构之前需要调用stop接口。<br>这里需要说明下，ALooper::start接口会启动一个线程，并调用ALooper::loop函数，该函数主要实现消息的实际执行。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ALooper::loop() &#123;</span><br><span class="line">    Event event;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mThread == <span class="literal">NULL</span> &amp;&amp; !mRunningLocally) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从mEventQueue取出消息，判断是否需要执行，不需要的话就等待</span></span><br><span class="line">        <span class="comment">// 需要的话就调用handler执行，并删除对应消息</span></span><br><span class="line">        <span class="keyword">if</span> (mEventQueue.empty()) &#123;</span><br><span class="line">            mQueueChangedCondition.wait(mLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int64_t</span> whenUs = (*mEventQueue.begin()).mWhenUs;</span><br><span class="line">        <span class="keyword">int64_t</span> nowUs = GetNowUs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (whenUs &gt; nowUs) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> delayUs = whenUs - nowUs;</span><br><span class="line">            mQueueChangedCondition.waitRelative(mLock, delayUs * <span class="number">1000l</span>l);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        event = *mEventQueue.begin();</span><br><span class="line">        mEventQueue.erase(mEventQueue.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.mMessage-&gt;deliver();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么消息是通过那个函数添加进来的呢？ 这就是友元类AMessage的作用，通过调用ALooper::post接口，将AMessage添加到mEventQueue中。</p><h5 id="3-4、一个调用实例"><a href="#3-4、一个调用实例" class="headerlink" title="3.4、一个调用实例"></a>3.4、一个调用实例</h5><p>以NuPlayer::setVideoSurfaceTextureAsync为示例分析下ALooper/AHandler机制。<br>这里不解释ALooper的初始化过程，有兴趣的可以参考资料Android Native层异步消息处理框架的内容。<br>下面是setVideoSurfaceTextureAsync的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码功能很简单，创建一个AMessage对象，并设置下参数，参数类型为Object，名称是”surface”，然后通过AMessage::post接口，间接调用ALooper::post接口，将消息发送给ALooper-NuPlayerDriver::mLooper；ALooper的消息循环线程检测到这个消息，在ALooper::loop函数中通过AMessage的deliver接口，调用AHandler::deliverMessage接口，这个函数会调动NuPlayer::onMessageReceived（通过继承机制实现）接口。这样绕了一圈。我们就可以通过ALooper/AHandler机制处理消息了。<br>具体处理代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">        <span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            ALOGD(<span class="string">"onSetVideoSurface(%p video decoder)"</span>, surface.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">            <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">            <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 省略其他部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-、NuPlayer源码分析"><a href="#四-、NuPlayer源码分析" class="headerlink" title="(四)、NuPlayer源码分析"></a>(四)、NuPlayer源码分析</h4><p>这次我们需要深入分析的是NuPlayer类，相比于NuPlayerDriver的接口功能，NuPlayer继承自AHandler类，是AOSP播放框架中连接Source、Decoder、Render的纽带。</p><h5 id="4-1、主要接口和核心的类成员"><a href="#4-1、主要接口和核心的类成员" class="headerlink" title="4.1、主要接口和核心的类成员"></a>4.1、主要接口和核心的类成员</h5><p>NuPlayer类被NuPlayerDriver直接调用，其主要接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code from NuPlayer.h (~/frameworks/av/media/libmediaplayerservice/nuplayer/)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NuPlayer</span> :</span> <span class="keyword">public</span> AHandler &#123;</span><br><span class="line">    NuPlayer(<span class="keyword">pid_t</span> pid);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUID</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(<span class="keyword">const</span> wp&lt;NuPlayerDriver&gt; &amp;driver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVideoSurfaceTextureAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifyResetComplete" once finished.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetAsync</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifySeekComplete" once finished</span></span><br><span class="line">    <span class="comment">// and needNotify is true.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seekToAsync</span><span class="params">(<span class="keyword">int64_t</span> seekTimeUs, <span class="keyword">bool</span> needNotify = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> setVideoScalingMode(<span class="keyword">int32_t</span> mode);</span><br><span class="line">    <span class="keyword">status_t</span> getTrackInfo(Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> getSelectedTrack(<span class="keyword">int32_t</span> type, Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> selectTrack(<span class="keyword">size_t</span> trackIndex, <span class="keyword">bool</span> select, <span class="keyword">int64_t</span> timeUs);</span><br><span class="line">    <span class="keyword">status_t</span> getCurrentPosition(<span class="keyword">int64_t</span> *mediaUs);</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; getFileMeta();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFrameRate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NuPlayer();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口分类下，无外乎几个分类：</p><p>☯ 用于初始化的（比如构造函数、setDriver/setDataSourceAsync/prepareAsync/setVideoSurfaceTextureAsync）<br>☯ 用于销毁的（比如析构函数、resetAsync）<br>☯ 用于播放控制的（比如start/pause/seekToAsync）<br>☯ 用于状态获取的（比如getCurrentPosition/getFileMeta）<br>下面是主要的类成员部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line">wp&lt;NuPlayerDriver&gt; mDriver; <span class="comment">// 接口调用方</span></span><br><span class="line">sp&lt;Source&gt; mSource; <span class="comment">// 相当于FFmpeg中的demuxer</span></span><br><span class="line">sp&lt;Surface&gt; mSurface; <span class="comment">// 显示用的Surface</span></span><br><span class="line">sp&lt;DecoderBase&gt; mVideoDecoder; <span class="comment">// 视频解码器</span></span><br><span class="line">sp&lt;DecoderBase&gt; mAudioDecoder; <span class="comment">// 音频解码器</span></span><br><span class="line">sp&lt;CCDecoder&gt; mCCDecoder; </span><br><span class="line">sp&lt;Renderer&gt; mRenderer; <span class="comment">// 渲染器</span></span><br><span class="line">sp&lt;ALooper&gt; mRendererLooper;</span><br></pre></td></tr></table></figure><h5 id="4-2、setDataSourceAsync-现分析"><a href="#4-2、setDataSourceAsync-现分析" class="headerlink" title="4.2、setDataSourceAsync()现分析"></a>4.2、setDataSourceAsync()现分析</h5><p>这个函数有多重不同的重载形式，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IStreamSource&gt; &amp;source)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source)</span></span>;</span><br></pre></td></tr></table></figure><p>需要根据实际情况选择，这里以第三个接口为例，说明下多本地媒体文件是如何处理的。<br>下面是这个函数的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setDataSourceAsync(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetDataSource, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatSourceNotify, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建对象用于读取本地文件</span></span><br><span class="line">    sp&lt;GenericSource&gt; source =</span><br><span class="line">            <span class="keyword">new</span> GenericSource(notify, mUIDValid, mUID);</span><br><span class="line">    <span class="comment">// 实际干活的的代码</span></span><br><span class="line">    <span class="keyword">status_t</span> err = source-&gt;setDataSource(fd, offset, length);</span><br><span class="line">    </span><br><span class="line">    msg-&gt;setObject(<span class="string">"source"</span>, source);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现很简单，创建GenericSource对象，并调用其setDataSource接口，然后发送kWhatSetDataSource消息。<br>我们看看如何处理然后发送kWhatSetDataSource消息呢？代码如下：<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetDataSource:</span><br><span class="line">&#123;</span><br><span class="line">    CHECK(mSource == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"source"</span>, &amp;obj));</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mSourceLock)</span></span>;</span><br><span class="line">        mSource = <span class="keyword">static_cast</span>&lt;Source *&gt;(obj.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知Driver函数调用完成</span></span><br><span class="line">    CHECK(mDriver != <span class="literal">NULL</span>);</span><br><span class="line">    sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        driver-&gt;notifySetDataSourceCompleted(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>看到这里发现，其实没做什么就是直接通知NuPlayerDriver。我们还注意到这里构建了一个特殊消息（AMessage）notify，这个消息用于在Source和NuPlayer直接传递。下面这是消息循环中的处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSourceNotify:</span><br><span class="line">&#123;</span><br><span class="line">    onSourceNotify(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续讨论Source的时候详细说明这个消息通知的意义。</p><h5 id="4-3、prepareAsync"><a href="#4-3、prepareAsync" class="headerlink" title="4.3、prepareAsync()"></a>4.3、prepareAsync()</h5><p>这个函数实现的功能对应于MediaPlayerBase::prepare/prepareAsync接口，实现异步的prepare功能，一般就是做一些额外的初始化工作。那么直接看一下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是发了一个kWhatPrepare的消息。接下来是如何处理这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终还是调用了Source::prepareAsync接口。后面会解释其功能。（这里面可能会解析下码流，读取音频、视频、字幕流信息，读取时长、元数据等）。</p><h5 id="4-4、setVideoSurfaceTextureAsync"><a href="#4-4、setVideoSurfaceTextureAsync" class="headerlink" title="4.4、setVideoSurfaceTextureAsync()"></a>4.4、setVideoSurfaceTextureAsync()</h5><p>调用这个接口主要为了设置视频渲染窗口。其实现相对简单，创建一个Surface，然后发送异步的kWhatSetVideoSurface消息。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync( <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么看看如何处理kWhatSetVideoSurface消息呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface: &#123;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">    sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">    <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">    <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">    <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">            || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">        performSetSurface(surface); <span class="comment">// 通知NuPlayerDriver设置完成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空音频、视频缓冲</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line">    <span class="comment">// 最终调用NuPlayer::performSetSurface接口</span></span><br><span class="line">    mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">            <span class="comment">// Issue a seek to refresh the video screen only if started otherwise</span></span><br><span class="line">            <span class="comment">// the extractor may not yet be started and will assert.</span></span><br><span class="line">            <span class="comment">// If the video decoder is not set (perhaps audio only in this case)</span></span><br><span class="line">            <span class="comment">// do not perform a seek as it is not needed.</span></span><br><span class="line">            <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于新的surface设置，重置下解码器</span></span><br><span class="line">        mDeferredActions.push_back(<span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After a flush without shutdown, decoder is paused.</span></span><br><span class="line">    <span class="comment">// Don't resume it until source seek is done, otherwise it could</span></span><br><span class="line">    <span class="comment">// start pulling stale data too soon.</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line">    <span class="comment">// 把上面mDeferredActions中缓存的所有Action处理下，并清空</span></span><br><span class="line">    processDeferredActions();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码相对复杂点，涉及到很多，其实主要是为了设置Surface之后，可以正常解码显示，因为某些情况下解码器初始化需要依赖于具体的Surface。当然，里边还涉及到NuPlayer状态及初始化判断。</p><h5 id="4-5、start-pause"><a href="#4-5、start-pause" class="headerlink" title="4.5、start()/pause()"></a>4.5、start()/pause()</h5><p>start函数实现很简单，实际就发送了kWhatStart消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息处理函数中的处理如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">        <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">        <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">            onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了OnStart/OnResume函数。<br>pause函数实现类似，只是发送的是kWhatPause消息。在消息处理函数中的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPause:</span><br><span class="line">&#123;</span><br><span class="line">    onPause();</span><br><span class="line">    mPausedByClient = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用的onPause函数。下面单独分析下这三个函数。先从简单的函数开始OnPause/onResume</p><p>NuPlayer::onPause<br>这个函数实现暂停功能，总体来说就是把Source和Render暂停就可以了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onPause() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onResume<br>这个函数实现恢复功能，代码逻辑跟onPause差不多，把Source和Render恢复，还可能涉及其它操作。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onResume() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPaused || mResetting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// |mAudioDecoder| may have been released due to the pause timeout, so re-create it if</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    <span class="keyword">if</span> (audioDecoderStillNeeded() &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        instantiateDecoder(<span class="literal">true</span> <span class="comment">/* audio */</span>, &amp;mAudioDecoder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onStart<br>这个接口实现启动的操作，相对复杂点，需要初始化解码器、初始化Render、设置Source状态，并将三者关联起来。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start(); <span class="comment">// 设置Source状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (省略部分代码)</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration; <span class="comment">// 创建Render和RenderLooper，属性设置、与解码器关联</span></span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中没有解码器的初始化，那只能继续看看postScanSources代码了。看实现发现就是发送了kWhatScanSources消息。那么消息循环里边是怎么处理的呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> generation;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"generation"</span>, &amp;generation));</span><br><span class="line">    <span class="keyword">if</span> (generation != mScanSourcesGeneration) &#123;</span><br><span class="line">        <span class="comment">// Drop obsolete msg.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> mHadAnySourcesBefore = (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">    <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化视频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化音频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHadAnySourcesBefore &amp;&amp; (mAudioDecoder != <span class="literal">NULL</span> || mVideoDecoder != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// This is the first time we've found anything playable.</span></span><br><span class="line">        <span class="comment">// 设置定期查询时长</span></span><br><span class="line">        <span class="keyword">if</span> (mSourceFlags &amp; Source::FLAG_DYNAMIC_DURATION) &#123;</span><br><span class="line">            schedulePollDuration();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err; <span class="comment">// 一些异常处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;feedMoreTSData()) != OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioDecoder == <span class="literal">NULL</span> &amp;&amp; mVideoDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// We're not currently decoding anything (no audio or</span></span><br><span class="line">            <span class="comment">// video tracks found) and we just ran out of input data.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err == ERROR_END_OF_STREAM) &#123;</span><br><span class="line">                notifyListener(MEDIA_PLAYBACK_COMPLETE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyListener(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要的话，重新扫描Source</span></span><br><span class="line">    <span class="keyword">if</span> (rescan) &#123;</span><br><span class="line">        msg-&gt;post(<span class="number">100000l</span>l);</span><br><span class="line">        mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有seekToAsync()、resetAsync()、getCurrentPosition()、getFileMeta()。由于实现类似，就不一一介绍了。</p><h5 id="4-6、小结结和疑问"><a href="#4-6、小结结和疑问" class="headerlink" title="4.6、小结结和疑问"></a>4.6、小结结和疑问</h5><p>到这里，我们已经把NuPlayer主要的函数分析完了，但是问题依旧在。比如下面几个：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong></p></blockquote><p>我想接下来的分析就是解决这些疑问的。</p><h5 id="4-7、Codec-Encoder-、Decoder列表附录"><a href="#4-7、Codec-Encoder-、Decoder列表附录" class="headerlink" title="4.7、Codec Encoder 、Decoder列表附录"></a>4.7、Codec Encoder 、Decoder列表附录</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line">&lt;!--</span><br><span class="line"> <span class="number">8996</span> Decoder capabilities</span><br><span class="line"> __________________________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    | Secure-dec |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  N         |</span><br><span class="line"> | vc1      | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  Y         |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  N         |</span><br><span class="line"> | vp9      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  Y         |</span><br><span class="line"> | divx3    | <span class="number">720</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">40500</span>   |  N         |</span><br><span class="line"> | div4/<span class="number">5</span>/<span class="number">6</span> | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">10</span>      <span class="number">244800</span>  |  N         |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |  N         |</span><br><span class="line"> | mpeg2    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">40</span>      <span class="number">244800</span>  |  Y         |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">8996</span> Encoder capabilities</span><br><span class="line"> ______________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;MediaCodecs&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_audio.xml"</span> /&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_telephony.xml"</span> /&gt;</span><br><span class="line">    &lt;Settings&gt;</span><br><span class="line">        &lt;Setting name=<span class="string">"max-video-encoder-input-buffers"</span> value=<span class="string">"11"</span> /&gt;</span><br><span class="line">    &lt;/Settings&gt;</span><br><span class="line">    &lt;Encoders&gt;</span><br><span class="line">        &lt;!-- Audio Hardware  --&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-loaded-to-idle-after-allocation"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"96x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"979200"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">          ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">    &lt;/Encoders&gt;</span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2.secure"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br><span class="line">&lt;/MediaCodecs&gt;</span><br></pre></td></tr></table></figure><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p></div><div class="post-announce">Thank you for reading, this article belongs to <a href="http://zhoujinjian.cc">๑Charles✦ˑ̫✦Vincent๑</a> copyright, if reproduced, please indicate the source：๑Charles✦ˑ̫✦Vincent๑（<a href="http://zhoujinjian.cc/2018/06/01/Android Video System（1）：Video System(视频系统)框架分析/">http://zhoujinjian.cc/2018/06/01/Android Video System（1）：Video System(视频系统)框架分析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/05/25/Audio System（3）：Android audio system(音频系统)分析/" title="Audio System（3）：Android audio system(音频系统)分析"><i class="iconfont icon-prev"></i>Audio System（3）：Android audio system(音频系统)分析</a></div><div class="post__prev post__prev--right"><a href="/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/" title="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。</p></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/Hexo/">Hexo</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">24</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2088/08/08/android/" title="zhoujinjian.cc-Android系列分析文档【➺置顶➺】"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2088.08.88.jpg" alt="zhoujinjian.cc-Android系列分析文档【➺置顶➺】"></div><div class="item__info"><h3 class="item__title">zhoujinjian.cc-Android系列分析文档【➺置顶➺】</h3><span class="item__text">2088-08-08</span></div></a></li><li class="latest-post-item"><a href="/2018/09/06/Android Video System（4）：Android Multimedia - OpenMax实现分析/" title="Android Video System（4）：Android Multimedia - OpenMax实现分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.25.jpg" alt="Android Video System（4）：Android Multimedia - OpenMax实现分析"></div><div class="item__info"><h3 class="item__title">Android Video System（4）：Android Multimedia - OpenMax实现分析</h3><span class="item__text">2018-09-06</span></div></a></li><li class="latest-post-item"><a href="/2018/08/30/Android Display System（5）：Android Display System 系统分析之Display Driver Architecture/" title="Android Display System（5）：Android Display System 系统分析之Display Driver Architecture"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.23.jpg" alt="Android Display System（5）：Android Display System 系统分析之Display Driver Architecture"></div><div class="item__info"><h3 class="item__title">Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</h3><span class="item__text">2018-08-30</span></div></a></li><li class="latest-post-item"><a href="/2018/08/16/Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析/" title="Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.22.jpg" alt="Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"></div><div class="item__info"><h3 class="item__title">Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析</h3><span class="item__text">2018-08-16</span></div></a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">开始的开始亦是结束•结束的结束亦是开始</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Room 103, Building 5, No. 5 Jiangtai Road, Shouxin Building, Chaoyang District, Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>zhou.jinjian@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/DreamWorks_2016_Stacked-MI-512x512.png" alt="logo" title="๑Charles✦ˑ̫✦Vincent๑"></div><div class="footer-top__item"><h3 class="item__title">Friend Links</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://keyin.me/" title="World of Forks" target="_blank">World of Forks</a></li><li class="list-item"><a href="https://molunerfinn.com/" title="MARKSZのBlog" target="_blank">MARKSZのBlog</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Hexo-theme-skapp" target="_blank">Hexo-theme-skapp</a></li><li class="list-item"><a href="http://zhoujinjian.cc/" title="๑Charles✦ˑ̫✦Vincent๑" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">Build Tools</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://dribbble.com/" title="Dribbble" target="_blank">Dribbble</a></li><li class="list-item"><a href="https://pages.github.com/" title="Blog Framework" target="_blank">Github-Pages</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Made by <a href="https://github.com/izhoujinjian" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/izhoujinjian" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:zhou.jinjian@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>🍀<span class="post-count">350.8k</span> </span><span>| </span><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>