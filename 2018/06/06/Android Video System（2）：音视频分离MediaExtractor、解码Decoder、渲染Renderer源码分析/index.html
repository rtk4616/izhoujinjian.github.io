<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析 | ๑Charles✦ˑ̫✦Vincent๑</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="๑Charles✦ˑ̫✦Vincent๑"><meta name="designer" content="minfive"><meta name="keywords" content="zhoujinjian, zhoujinjian blog, Android, 源代码, ActivityManagerService, AMS, WindowManagerService, WMS , zygote ，InputManagerService , SurfaceFlinger, SystemServer , Binder , Graphics , Kernel , Linux"><meta name="description" content="嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><meta name="baidu-site-verification" content="7AVr5WpX72"><link rel="canonical" href="http://zhoujinjian.cc/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/index.html"><link rel="icon" type="image/png" href="null" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="๑Charles✦ˑ̫✦Vincent๑"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?c54bda95ff8b34e8be2edd1d138812c1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-117331438-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-117331438-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(/img/loading-small.gif)"></div><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="๑Charles✦ˑ̫✦Vincent๑" alt="๑Charles✦ˑ̫✦Vincent๑"><img src="/img/Logo.png" alt="๑Charles✦ˑ̫✦Vincent๑"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="Home" title="Home">Home</a></li><li class="nav__item"><a href="/archives" alt="Archive" title="Archive">Archive</a></li><li class="nav__item"><a href="/about" alt="About" title="About">About</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><div id="page" class="page js-hidden"><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.17.jpg" alt="Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析"></div><header class="post__info"><h1 class="post__title">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="https://www.github.com/izhoujinjian">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-06-06</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Android/">Android</a></li></ul></div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></header><div class="post__content"><div><div id="toc" class="toc-article"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）、多媒体文件解析-MediaExtractor分离音视频"><span class="toc-text">（一）、多媒体文件解析 - MediaExtractor分离音视频</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1、mMediaPlayer-prepareAsync"><span class="toc-text">1.1、mMediaPlayer.prepareAsync()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-1、MediaPlayer-setVideoSurfaceTexture"><span class="toc-text">1.1.1、MediaPlayer.setVideoSurfaceTexture()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-2、MediaPlayer-prepareAsync"><span class="toc-text">1.1.2、MediaPlayer.prepareAsync()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-3、GenericSource-initFromDataSource"><span class="toc-text">1.1.3、GenericSource.initFromDataSource()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-4、MediaExtractor-Create"><span class="toc-text">1.1.4、MediaExtractor::Create()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-5、IMediaExtractor-gt-getTrack"><span class="toc-text">1.1.5、IMediaExtractor-&gt;getTrack()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）、多媒体文件-音视频解码（Decoder）"><span class="toc-text">（二）、多媒体文件 - 音视频解码（Decoder）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1、NuPlayer-start"><span class="toc-text">2.1、NuPlayer::start()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2、postScanSources"><span class="toc-text">2.2、postScanSources()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3、instantiateDecoder"><span class="toc-text">2.3、instantiateDecoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1、创建音视频解码器new-Decoder"><span class="toc-text">2.3.1、创建音视频解码器new Decoder()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2、初始化Decoder-gt-init"><span class="toc-text">2.3.2、初始化Decoder-&gt;init()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3、配置Decoder-gt-configure"><span class="toc-text">2.3.3、配置Decoder-&gt;configure()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4、MediaCodec-init-…"><span class="toc-text">2.3.4、MediaCodec::init(…)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-1、GetCodecBase"><span class="toc-text">2.3.4.1、GetCodecBase</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-4-2、MediaCodecList-getInstance"><span class="toc-text">2.3.4.2、MediaCodecList::getInstance()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-5、MediaCodec-gt-configure"><span class="toc-text">2.3.5、MediaCodec-&gt;configure()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-6、MediaCodec-gt-start"><span class="toc-text">2.3.6、MediaCodec-&gt;start()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）、音视频解码数据处理"><span class="toc-text">（三）、音视频解码数据处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1、音视频解码数据处理-emptyBuffer"><span class="toc-text">3.1、音视频解码数据处理-emptyBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1、ACodec-ExecutingState-resume"><span class="toc-text">3.1.1、ACodec::ExecutingState::resume()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-1、kWhatFillThisBuffer消息处理"><span class="toc-text">3.1.1.1、kWhatFillThisBuffer消息处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-2、kWhatInputBufferFilled消息处理"><span class="toc-text">3.1.1.2、kWhatInputBufferFilled消息处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2、音视频解码数据处理-fillBuffer"><span class="toc-text">3.2、音视频解码数据处理-fillBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-1、ACodec-ExecutingState-resume"><span class="toc-text">3.2.1、ACodec::ExecutingState::resume()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（四）、多媒体文件-音视频渲染（Renderer）"><span class="toc-text">（四）、多媒体文件 - 音视频渲染（Renderer）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（五）、视频解码输出到SurfaceFlinger"><span class="toc-text">（五）、视频解码输出到SurfaceFlinger</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1、Surfaceflinger-视频解码缓存申请"><span class="toc-text">5.1、Surfaceflinger 视频解码缓存申请</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1、allocateOutputBuffersFromNativeWindow-的实现"><span class="toc-text">5.1.1、allocateOutputBuffersFromNativeWindow()的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-1、首先为视频编码输出准备Surface"><span class="toc-text">5.1.1.1、首先为视频编码输出准备Surface</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-2、Surface-gt-dequeueBuffer"><span class="toc-text">5.1.1.2、Surface-&gt;dequeueBuffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2、Surface-gt-queueBuffer"><span class="toc-text">5.2、Surface-&gt;queueBuffer()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（六）、参考资料-特别感谢各位前辈的分析和图示-："><span class="toc-text">（六）、参考资料(特别感谢各位前辈的分析和图示)：</span></a></li></ol></div><hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 - Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 - android ACodec MediaCodec NuPlayer flow】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br><a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br><a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener">Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>前面第一章节已经分析过mMediaPlayer.setDataSource()、mMediaPlayer.setDisplay()下来的分析尝试分析解答如下疑问：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong></p></blockquote><h4 id="（一）、多媒体文件解析-MediaExtractor分离音视频"><a href="#（一）、多媒体文件解析-MediaExtractor分离音视频" class="headerlink" title="（一）、多媒体文件解析 - MediaExtractor分离音视频"></a>（一）、多媒体文件解析 - MediaExtractor分离音视频</h4><p>接下来继续分析mMediaPlayer.prepareAsync()</p><h5 id="1-1、mMediaPlayer-prepareAsync"><a href="#1-1、mMediaPlayer-prepareAsync" class="headerlink" title="1.1、mMediaPlayer.prepareAsync()"></a>1.1、mMediaPlayer.prepareAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p>通过JNI调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">android_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(st);</span><br><span class="line"></span><br><span class="line">    process_media_player_call( env, thiz, mp-&gt;prepareAsync(), <span class="string">"java/io/IOException"</span>, <span class="string">"Prepare Async failed."</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置视频的 display surface（关于IGraphicBufferProducer相关知识请参考：Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]），</p><h5 id="1-1-1、MediaPlayer-setVideoSurfaceTexture"><a href="#1-1-1、MediaPlayer-setVideoSurfaceTexture" class="headerlink" title="1.1.1、MediaPlayer.setVideoSurfaceTexture()"></a>1.1.1、MediaPlayer.setVideoSurfaceTexture()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::setVideoSurfaceTexture(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setVideoSurfaceTexture"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mPlayer == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面setDataSource()分析过，此处会调用NuPlayer的setVideoSurfaceTexture()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处首先构造了一个AMessage消息，然后new Surface()，接下来看看消息处理过程。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,</span><br><span class="line">                                           FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                    <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                        mDeferredActions.push_back(</span><br><span class="line">                                <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line"></span><br><span class="line">            processDeferredActions();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::performSetSurface(<span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface) &#123;</span><br><span class="line">    ALOGV(<span class="string">"performSetSurface"</span>);</span><br><span class="line"></span><br><span class="line">    mSurface = surface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX - ignore error from setVideoScalingMode for now</span></span><br><span class="line">    setVideoScalingMode(mVideoScalingMode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            driver-&gt;notifySetSurfaceComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到将surface 赋值给NuPlayer的mSurface ，待视频解码后就可以在此surface 上渲染画面了，<br>这个稍后再作分析。</p><h5 id="1-1-2、MediaPlayer-prepareAsync"><a href="#1-1-2、MediaPlayer-prepareAsync" class="headerlink" title="1.1.2、MediaPlayer.prepareAsync()"></a>1.1.2、MediaPlayer.prepareAsync()</h5><p>然后接着调用MediaPlayer prepareAsync()函数。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"prepareAsync"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(<span class="string">"prepareAsync called in state %d, mPlayer(%p)"</span>, mCurrentState, mPlayer.get());</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此处会调用NuPlayer的prepareAsync()函数，prepareAsync()发送了一个kWhatPrepare的AMessage，我们直接看看消息处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处又调用了GenericSource的prepareAsync()函数，发送了一个kWhatPrepareAsync消息。直接看看GenericSource如何处理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::prepareAsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLooper-&gt;setName(<span class="string">"generic"</span>);</span><br><span class="line">        mLooper-&gt;start();</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatPrepareAsync, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">      <span class="keyword">case</span> kWhatPrepareAsync:</span><br><span class="line">      &#123;</span><br><span class="line">          onPrepareAsync();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::onPrepareAsync() &#123;</span><br><span class="line">    <span class="comment">// delayed data source creation</span></span><br><span class="line">    <span class="keyword">if</span> (mDataSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// set to false first, if the extractor</span></span><br><span class="line">        <span class="comment">// comes back as secure, set it to true then.</span></span><br><span class="line">        mIsSecure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mUri.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* uri = mUri.c_str();</span><br><span class="line">            String8 contentType;</span><br><span class="line">            mIsWidevine = !strncasecmp(uri, <span class="string">"widevine://"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!strncasecmp(<span class="string">"http://"</span>, uri, <span class="number">7</span>)</span><br><span class="line">                    || !strncasecmp(<span class="string">"https://"</span>, uri, <span class="number">8</span>)</span><br><span class="line">                    || mIsWidevine) &#123;</span><br><span class="line">                mHttpSource = DataSource::CreateMediaHTTP(mHTTPService);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDataSource = DataSource::CreateFromURI(</span><br><span class="line">                   mHTTPService, uri, &amp;mUriHeaders, &amp;contentType,</span><br><span class="line">                   <span class="keyword">static_cast</span>&lt;HTTPBase *&gt;(mHttpSource.get()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mIsWidevine = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            mDataSource = <span class="keyword">new</span> FileSource(mFd, mOffset, mLength);</span><br><span class="line">            mFd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;flags() &amp; DataSource::kIsCachingDataSource) &#123;</span><br><span class="line">        mCachedSource = <span class="keyword">static_cast</span>&lt;NuCachedSource2 *&gt;(mDataSource.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsStreaming = (mIsWidevine || mCachedSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init extractor from data source</span></span><br><span class="line">    <span class="keyword">status_t</span> err = initFromDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack.mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = doGetFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage;</span><br><span class="line">        err = convertMetaDataToMessage(meta, &amp;msg);</span><br><span class="line">        ......</span><br><span class="line">        notifyVideoSizeChanged(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mIsSecure) &#123;</span><br><span class="line">        <span class="comment">// secure decoders must be instantiated before starting widevine source</span></span><br><span class="line">        sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatSecureDecodersInstantiated, <span class="keyword">this</span>);</span><br><span class="line">        notifyInstantiateSecureDecoders(reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishPrepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造了 mDataSource = new FileSource，然后调用了initFromDataSource()，这里面包含多媒体文件格式探测，。</p><h5 id="1-1-3、GenericSource-initFromDataSource"><a href="#1-1-3、GenericSource-initFromDataSource" class="headerlink" title="1.1.3、GenericSource.initFromDataSource()"></a>1.1.3、GenericSource.initFromDataSource()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::GenericSource::initFromDataSource() &#123;</span><br><span class="line">    sp&lt;IMediaExtractor&gt; extractor;</span><br><span class="line">    String8 mimeType;</span><br><span class="line">    <span class="keyword">float</span> confidence;</span><br><span class="line">    sp&lt;AMessage&gt; dummy;</span><br><span class="line">    <span class="keyword">bool</span> isWidevineStreaming = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CHECK(mDataSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWidevine) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsStreaming) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDataSource-&gt;sniff(&amp;mimeType, &amp;confidence, &amp;dummy)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        isWidevineStreaming = !strcasecmp(</span><br><span class="line">                mimeType.<span class="built_in">string</span>(), MEDIA_MIMETYPE_CONTAINER_WVM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWidevineStreaming) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extractor = MediaExtractor::Create(mDataSource,</span><br><span class="line">                mimeType.isEmpty() ? <span class="literal">NULL</span> : mimeType.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(mDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFileMeta = extractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (mFileMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> duration;</span><br><span class="line">        <span class="keyword">if</span> (mFileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> totalBitrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> numtracks = extractor-&gt;countTracks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numtracks; ++i) &#123;</span><br><span class="line">        sp&lt;IMediaSource&gt; track = extractor-&gt;getTrack(i);</span><br><span class="line">        </span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do the string compare immediately with "mime",</span></span><br><span class="line">        <span class="comment">// we can't assume "mime" would stay valid after another</span></span><br><span class="line">        <span class="comment">// extractor operation, some extractors might modify meta</span></span><br><span class="line">        <span class="comment">// during getTrack() and make it invalid.</span></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"audio/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAudioTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mAudioTrack.mIndex = i;</span><br><span class="line">                mAudioTrack.mSource = track;</span><br><span class="line">                mAudioTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mAudioTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mVideoTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mVideoTrack.mIndex = i;</span><br><span class="line">                mVideoTrack.mSource = track;</span><br><span class="line">                mVideoTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mVideoTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if the source requires secure buffers</span></span><br><span class="line">                <span class="keyword">int32_t</span> secure;</span><br><span class="line">                <span class="keyword">if</span> (meta-&gt;findInt32(kKeyRequiresSecureBuffers, &amp;secure)</span><br><span class="line">                        &amp;&amp; secure) &#123;</span><br><span class="line">                    mIsSecure = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">                        extractor-&gt;setUID(mUID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSources.push(track);</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="keyword">if</span> (meta-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> bitrate;</span><br><span class="line">        <span class="keyword">if</span> (totalBitrate &gt;= <span class="number">0</span> &amp;&amp; meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            totalBitrate += bitrate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalBitrate = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    mBitrate = totalBitrate;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过MediaExtractor::Create()得到MediaExtractor，然后将数据解析成track 赋值给mAudioTrack.mSource、mVideoTrack.mSource。</p><h5 id="1-1-4、MediaExtractor-Create"><a href="#1-1-4、MediaExtractor-Create" class="headerlink" title="1.1.4、MediaExtractor::Create()"></a>1.1.4、MediaExtractor::Create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaExtractor.cpp]</span><br><span class="line">sp&lt;IMediaExtractor&gt; MediaExtractor::Create(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> <span class="keyword">char</span> *mime) &#123;</span><br><span class="line">    ALOGV(<span class="string">"MediaExtractor::Create %s"</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"media.stagefright.extractremote"</span>, value, <span class="literal">NULL</span>)</span><br><span class="line">            &amp;&amp; (!<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) || !strcasecmp(<span class="string">"false"</span>, value))) &#123;</span><br><span class="line">        <span class="comment">// local extractor</span></span><br><span class="line">        ALOGW(<span class="string">"creating media extractor in calling process"</span>);</span><br><span class="line">        <span class="keyword">return</span> CreateFromService(source, mime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check if it's WVM, since WVMExtractor needs to be created in the media server process,</span></span><br><span class="line">        <span class="comment">// not the extractor process.</span></span><br><span class="line">        String8 mime8;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        sp&lt;AMessage&gt; meta;</span><br><span class="line">        <span class="keyword">if</span> (SniffWVM(source, &amp;mime8, &amp;confidence, &amp;meta) &amp;&amp;</span><br><span class="line">                !strcasecmp(mime8, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WVMExtractor(source);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SniffDRM(source, &amp;mime8, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *drmMime = mime8.<span class="built_in">string</span>();</span><br><span class="line">            ALOGV(<span class="string">"Detected media content as '%s' with confidence %.2f"</span>, drmMime, confidence);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drmMime, <span class="string">"drm+es_based+"</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">                <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DRMExtractor(source, drmMime + <span class="number">14</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remote extractor</span></span><br><span class="line">        ALOGV(<span class="string">"get service manager"</span>);</span><br><span class="line">        sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(<span class="string">"media.extractor"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;IMediaExtractorService&gt; mediaExService(interface_cast&lt;IMediaExtractorService&gt;(binder));</span><br><span class="line">            sp&lt;IMediaExtractor&gt; ex = mediaExService-&gt;makeExtractor(RemoteDataSource::wrap(source), mime);</span><br><span class="line">            <span class="keyword">return</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过Binder通信获取”media.extractor”服务得到一个Extractor。</p><h5 id="1-1-5、IMediaExtractor-gt-getTrack"><a href="#1-1-5、IMediaExtractor-gt-getTrack" class="headerlink" title="1.1.5、IMediaExtractor-&gt;getTrack()"></a>1.1.5、IMediaExtractor-&gt;getTrack()</h5><p>根据不同类别解析出不同的Track</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\]</span><br><span class="line"></span><br><span class="line">AACExtractor.cpp sp&lt;IMediaSource&gt; AACExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">AMRExtractor.cpp sp&lt;IMediaSource&gt; AMRExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MP3Extractor.cpp sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">NuMediaExtractor.cpp sp&lt;IMediaSource&gt; source = mImpl-&gt;getTrack(index)</span><br><span class="line">WAVExtractor.cpp sp&lt;IMediaSource&gt; WAVExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">FLACExtractor.cpp sp&lt;IMediaSource&gt; FLACExtractor::getTrack(<span class="keyword">size_t</span> index) </span><br><span class="line">StagefrightMetadataRetriever.cpp sp&lt;IMediaSource&gt; source = mExtractor-&gt;getTrack(i)</span><br><span class="line">AVIExtractor.cpp sp&lt;MediaSource&gt; AVIExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">OggExtractor.cpp sp&lt;IMediaSource&gt; OggExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MPEG4Extractor.cpp sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3</span></span><br><span class="line">sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MP3Source(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MPEG4</span></span><br><span class="line">sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    ......</span><br><span class="line">    Track *track = mFirstTrack;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track = track-&gt;next;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trex *trex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> trackId;</span><br><span class="line">    <span class="keyword">if</span> (track-&gt;meta-&gt;findInt32(kKeyTrackID, &amp;trackId)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mTrex.size(); i++) &#123;</span><br><span class="line">            Trex *t = &amp;mTrex.editItemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;track_ID == (<span class="keyword">uint32_t</span>) trackId) &#123;</span><br><span class="line">                trex = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyAVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyHVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPEG4Source(<span class="keyword">this</span>,</span><br><span class="line">            track-&gt;meta, mDataSource, track-&gt;timescale, track-&gt;sampleTable,</span><br><span class="line">            mSidxEntries, trex, mMoofOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到不同格式的 MP3Extractor、MPEG4Source ……</p><p>还记的前面提出的第一点疑问吗，现在我们知道了如何分离音视频了并且得到了相应的文件Source了。<br>图示（红线部分）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-01-source-demux-decoder-output-MediaExtractor.jpg" alt="Alt text"></p><h4 id="（二）、多媒体文件-音视频解码（Decoder）"><a href="#（二）、多媒体文件-音视频解码（Decoder）" class="headerlink" title="（二）、多媒体文件 - 音视频解码（Decoder）"></a>（二）、多媒体文件 - 音视频解码（Decoder）</h4><p>音频解码、视频解码在何处，答案就在mMediaPlayer.start()流程当中，先看看start()总体时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-02-NuPlayer-Start-instantiateDecoder.png" alt="Alt text"></p><p>由于从Java层到JNI前面已多次分析，这里直接从NuPlayer::start()开始分析</p><h5 id="2-1、NuPlayer-start"><a href="#2-1、NuPlayer-start" class="headerlink" title="2.1、NuPlayer::start()"></a>2.1、NuPlayer::start()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            ALOGV(<span class="string">"kWhatStart"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">                <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startPositionUs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        performSeek(startPositionUs);</span><br><span class="line">        <span class="keyword">if</span> (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = <span class="literal">false</span>;</span><br><span class="line">    mAudioEOS = <span class="literal">false</span>;</span><br><span class="line">    mVideoEOS = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSource-&gt;isRealTime()) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_REAL_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; audioMeta = mSource-&gt;getFormatMeta(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    sp&lt;MetaData&gt; videoMeta = mSource-&gt;getFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    ......</span><br><span class="line">    ALOGV_IF(audioMeta == <span class="literal">NULL</span>, <span class="string">"no metadata for audio source"</span>);  <span class="comment">// video only stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">audio_stream_type_t</span> streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; videoFormat = mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line"></span><br><span class="line">    mOffloadAudio =</span><br><span class="line">        canOffloadStream(audioMeta, (videoFormat != <span class="literal">NULL</span>), mSource-&gt;isStreaming(), streamType)</span><br><span class="line">                &amp;&amp; (mPlaybackSettings.mSpeed == <span class="number">1.f</span> &amp;&amp; mPlaybackSettings.mPitch == <span class="number">1.f</span>);</span><br><span class="line">    <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_OFFLOAD_AUDIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration;</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了名为NuPlayerRenderer的Renderer对象，然后启动循环，看看初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">NuPlayer::Renderer::Renderer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    : mAudioSink(sink),</span><br><span class="line">      mUseVirtualAudioSink(<span class="literal">false</span>),</span><br><span class="line">      mNotify(notify),</span><br><span class="line">      mFlags(flags),</span><br><span class="line">      mNumFramesWritten(<span class="number">0</span>),</span><br><span class="line">      mDrainAudioQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mDrainVideoQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mAudioQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioEOSGeneration(<span class="number">0</span>),</span><br><span class="line">      mPlaybackSettings(AUDIO_PLAYBACK_RATE_DEFAULT),</span><br><span class="line">      ......</span><br><span class="line">      mWakeLock(<span class="keyword">new</span> AWakeLock()) &#123;</span><br><span class="line">    mMediaClock = <span class="keyword">new</span> MediaClock;</span><br><span class="line">    mPlaybackRate = mPlaybackSettings.mSpeed;</span><br><span class="line">    mMediaClock-&gt;setPlaybackRate(mPlaybackRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、postScanSources"><a href="#2-2、postScanSources" class="headerlink" title="2.2、postScanSources()"></a>2.2、postScanSources()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::postScanSources() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatScanSources, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"generation"</span>, mScanSourcesGeneration);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> generation;</span><br><span class="line">            mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> mHadAnySourcesBefore =</span><br><span class="line">                (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">            <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">            <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此处调用了instantiateDecoder()来初始化音视频解码器Decoder</p><h5 id="2-3、instantiateDecoder"><a href="#2-3、instantiateDecoder" class="headerlink" title="2.3、instantiateDecoder()"></a>2.3、instantiateDecoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::instantiateDecoder(</span><br><span class="line">        <span class="keyword">bool</span> audio, sp&lt;DecoderBase&gt; *decoder, <span class="keyword">bool</span> checkAudioModeChange) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;getFormat(audio);</span><br><span class="line"></span><br><span class="line">    format-&gt;setInt32(<span class="string">"priority"</span>, <span class="number">0</span> <span class="comment">/* realtime */</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatAudioNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mAudioDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkAudioModeChange) &#123;</span><br><span class="line">            determineAudioModeChange(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">true</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> hasVideo = (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/*audio */</span>) != <span class="literal">NULL</span>);</span><br><span class="line">            format-&gt;setInt32(<span class="string">"has-video"</span>, hasVideo);</span><br><span class="line">            *decoder = <span class="keyword">new</span> DecoderPassThrough(notify, mSource, mRenderer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">false</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            *decoder = <span class="keyword">new</span> Decoder(notify, mSource, mPID, mRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatVideoNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mVideoDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        *decoder = <span class="keyword">new</span> Decoder(</span><br><span class="line">                notify, mSource, mPID, mRenderer, mSurface, mCCDecoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enable FRC if high-quality AV sync is requested, even if not</span></span><br><span class="line">        <span class="comment">// directly queuing to display, as this will even improve textureview</span></span><br><span class="line">        <span class="comment">// playback.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">            <span class="keyword">if</span> (property_get(<span class="string">"persist.sys.media.avsync"</span>, value, <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (!<span class="built_in">strcmp</span>(<span class="string">"1"</span>, value) || !strcasecmp(<span class="string">"true"</span>, value))) &#123;</span><br><span class="line">                format-&gt;setInt32(<span class="string">"auto-frc"</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*decoder)-&gt;init();</span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-1、创建音视频解码器new-Decoder"><a href="#2-3-1、创建音视频解码器new-Decoder" class="headerlink" title="2.3.1、创建音视频解码器new Decoder()"></a>2.3.1、创建音视频解码器new Decoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line">NuPlayer::Decoder::Decoder(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Source&gt; &amp;source,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Renderer&gt; &amp;renderer,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CCDecoder&gt; &amp;ccDecoder)</span><br><span class="line">    : DecoderBase(notify),</span><br><span class="line">      mSurface(surface),</span><br><span class="line">      mSource(source),</span><br><span class="line">      mRenderer(renderer),</span><br><span class="line">      mCCDecoder(ccDecoder),</span><br><span class="line">      ......</span><br><span class="line">      mVideoWidth(<span class="number">0</span>),</span><br><span class="line">      mVideoHeight(<span class="number">0</span>),</span><br><span class="line">      mIsAudio(<span class="literal">true</span>),</span><br><span class="line">      ......</span><br><span class="line">      mComponentName(<span class="string">"decoder"</span>) &#123;</span><br><span class="line">    mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mCodecLooper-&gt;setName(<span class="string">"NPDecoder-CL"</span>);</span><br><span class="line">    mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mVideoTemporalLayerAggregateFps[<span class="number">0</span>] = mFrameRateTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建音视频解码器（NuPlayer::Decoder），为其创建名为NPDecoder-CL的mCodecLooper 【其父类NuPlayer::DecoderBase的构造中则会创建NPDecoder】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line">NuPlayer::DecoderBase::DecoderBase(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify)</span><br><span class="line">    :  mNotify(notify),</span><br><span class="line">       mBufferGeneration(<span class="number">0</span>),</span><br><span class="line">       mPaused(<span class="literal">false</span>),</span><br><span class="line">       mStats(<span class="keyword">new</span> AMessage),</span><br><span class="line">       mRequestInputBuffersPending(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Every decoder has its own looper because MediaCodec operations</span></span><br><span class="line">    <span class="comment">// are blocking, but NuPlayer needs asynchronous operations.</span></span><br><span class="line">    mDecoderLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mDecoderLooper-&gt;setName(<span class="string">"NPDecoder"</span>);</span><br><span class="line">    mDecoderLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2、初始化Decoder-gt-init"><a href="#2-3-2、初始化Decoder-gt-init" class="headerlink" title="2.3.2、初始化Decoder-&gt;init()"></a>2.3.2、初始化Decoder-&gt;init()</h5><p>对该解码器进行init()操作，调用NuPlayer::DecoderBase::init()为mDecoderLooper注册handler【init()和configure()都是NuPlayerDecoder继承自NuPlayer::DecoderBase的方法】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::configure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"format"</span>, format);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::init() &#123;</span><br><span class="line">    mDecoderLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            CHECK(msg-&gt;findMessage(<span class="string">"format"</span>, &amp;format));</span><br><span class="line">            onConfigure(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对该解码器进行configure(format)操作，调用NuPlayer::DecoderBase::configure(…)产生一个kWhatConfigure消息，然后消息处理中调用NuPlayer::Decoder::onConfigure(…)</p><h5 id="2-3-3、配置Decoder-gt-configure"><a href="#2-3-3、配置Decoder-gt-configure" class="headerlink" title="2.3.3、配置Decoder-&gt;configure()"></a>2.3.3、配置Decoder-&gt;configure()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onConfigure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">  </span><br><span class="line">    mFormatChangePending = <span class="literal">false</span>;</span><br><span class="line">    mTimeChangePending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++mBufferGeneration;</span><br><span class="line"></span><br><span class="line">    AString mime;</span><br><span class="line"></span><br><span class="line">    mIsAudio = !strncasecmp(<span class="string">"audio/"</span>, mime.c_str(), <span class="number">6</span>);</span><br><span class="line">    mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());</span><br><span class="line"></span><br><span class="line">    mComponentName = mime;</span><br><span class="line">    mComponentName.append(<span class="string">" decoder"</span>);</span><br><span class="line">    ALOGV(<span class="string">"[%s] onConfigure (surface=%p)"</span>, mComponentName.c_str(), mSurface.get());</span><br><span class="line"></span><br><span class="line">    mCodec = MediaCodec::CreateByType(</span><br><span class="line">            mCodecLooper, mime.c_str(), <span class="literal">false</span> <span class="comment">/* encoder */</span>, <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="keyword">int32_t</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (format-&gt;findInt32(<span class="string">"secure"</span>, &amp;secure) &amp;&amp; secure != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line">            mComponentName.append(<span class="string">".secure"</span>);</span><br><span class="line">            mCodec-&gt;release();</span><br><span class="line">            ALOGI(<span class="string">"[%s] creating"</span>, mComponentName.c_str());</span><br><span class="line">            mCodec = MediaCodec::CreateByComponentName(</span><br><span class="line">                    mCodecLooper, mComponentName.c_str(), <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mIsSecure = secure;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// disconnect from surface as MediaCodec will reconnect</span></span><br><span class="line">        err = native_window_api_disconnect(</span><br><span class="line">                mSurface.get(), NATIVE_WINDOW_API_MEDIA);</span><br><span class="line">        <span class="comment">// We treat this as a warning, as this is a preparatory step.</span></span><br><span class="line">        <span class="comment">// Codec will try to connect to the surface, which is where</span></span><br><span class="line">        <span class="comment">// any error signaling will occur.</span></span><br><span class="line">        ALOGW_IF(err != OK, <span class="string">"failed to disconnect from surface: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    err = mCodec-&gt;configure(</span><br><span class="line">            format, mSurface, <span class="literal">NULL</span> <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    ......</span><br><span class="line">    rememberCodecSpecificData(format);</span><br><span class="line">    mStats-&gt;setString(<span class="string">"mime"</span>, mime.c_str());</span><br><span class="line">    mStats-&gt;setString(<span class="string">"component-name"</span>, mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;findInt32(<span class="string">"width"</span>, &amp;width)</span><br><span class="line">                &amp;&amp; mOutputFormat-&gt;findInt32(<span class="string">"height"</span>, &amp;height)) &#123;</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"width"</span>, width);</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"height"</span>, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>);</span><br><span class="line">    mCodec-&gt;setCallback(reply);</span><br><span class="line"></span><br><span class="line">    err = mCodec-&gt;start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    releaseAndResetMediaBuffers();</span><br><span class="line"></span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    mResumePending = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onConfigure中，首先会调用MediaCodec::CreateByType(…)或者MediaCodec::CreateByComponentName(…)根据情况创建MediaCodec，接着调用MediaCodec::init(…)，随后调用MediaCodec::configure(…)对MediaCodec进行配置使其转入Configured状态;然后又调用MediaCodec::start()使MediaCodec转入Executing状态。</p><h5 id="2-3-4、MediaCodec-init-…"><a href="#2-3-4、MediaCodec-init-…" class="headerlink" title="2.3.4、MediaCodec::init(…)"></a>2.3.4、MediaCodec::init(…)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByComponentName(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;name, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(name, <span class="literal">false</span> <span class="comment">/* nameIsType */</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *err = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::init(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType, <span class="keyword">bool</span> encoder) &#123;</span><br><span class="line">    mResourceManagerService-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save init parameters for reset</span></span><br><span class="line">    mInitName = name;</span><br><span class="line">    mInitNameIsType = nameIsType;</span><br><span class="line">    mInitIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current video decoders do not return from OMX_FillThisBuffer</span></span><br><span class="line">    <span class="comment">// quickly, violating the OpenMAX specs, until that is remedied</span></span><br><span class="line">    <span class="comment">// we need to invest in an extra looper to free the main event</span></span><br><span class="line">    <span class="comment">// queue.</span></span><br><span class="line"></span><br><span class="line">    mCodec = GetCodecBase(name, nameIsType);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> secureCodec = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType &amp;&amp; !strncasecmp(name.c_str(), <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        mIsVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AString tmp = name;</span><br><span class="line">        <span class="keyword">if</span> (tmp.endsWith(<span class="string">".secure"</span>)) &#123;</span><br><span class="line">            secureCodec = <span class="literal">true</span>;</span><br><span class="line">            tmp.erase(tmp.size() - <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">ssize_t</span> codecIdx = mcl-&gt;findCodecByName(tmp.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codecIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = mcl-&gt;getCodecInfo(codecIdx);</span><br><span class="line">            Vector&lt;AString&gt; mimes;</span><br><span class="line">            info-&gt;getSupportedMimes(&amp;mimes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mimes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mimes[i].startsWith(<span class="string">"video/"</span>)) &#123;</span><br><span class="line">                    mIsVideo = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        <span class="comment">// video codec needs dedicated looper</span></span><br><span class="line">        <span class="keyword">if</span> (mCodecLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">            mCodecLooper-&gt;setName(<span class="string">"CodecLooper"</span>);</span><br><span class="line">            mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;setNotificationMessage(<span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatInit, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">"name"</span>, name);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"nameIsType"</span>, nameIsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"encoder"</span>, encoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    MediaResource::Type type =</span><br><span class="line">            secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec;</span><br><span class="line">    MediaResource::SubType subtype =</span><br><span class="line">            mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec;</span><br><span class="line">    resources.push_back(MediaResource(type, subtype, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-1、GetCodecBase"><a href="#2-3-4-1、GetCodecBase" class="headerlink" title="2.3.4.1、GetCodecBase"></a>2.3.4.1、GetCodecBase</h5><p>当编解码以”omx.”开头则创建ACodec对象。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;CodecBase&gt; MediaCodec::GetCodecBase(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType) &#123;</span><br><span class="line">    <span class="comment">// at this time only ACodec specifies a mime type.</span></span><br><span class="line">    <span class="keyword">if</span> (nameIsType || name.startsWithIgnoreCase(<span class="string">"omx."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWithIgnoreCase(<span class="string">"android.filter."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MediaFilter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="2-3-4-2、MediaCodecList-getInstance"><a href="#2-3-4-2、MediaCodecList-getInstance" class="headerlink" title="2.3.4.2、MediaCodecList::getInstance()"></a>2.3.4.2、MediaCodecList::getInstance()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getInstance() &#123;</span><br><span class="line">    Mutex::Autolock _l(sRemoteInitMutex);</span><br><span class="line">    <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; binder =</span><br><span class="line">            defaultServiceManager()-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">        sp&lt;IMediaPlayerService&gt; service =</span><br><span class="line">            interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">        <span class="keyword">if</span> (service.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sRemoteList = service-&gt;getCodecList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sRemoteList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Binder通信获取MediaCodec列表。getCodecList()函数实现在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::getCodecList() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MediaCodecList::getLocalInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getLocalInstance() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br><span class="line">MediaCodecList::MediaCodecList()</span><br><span class="line">    : mInitCheck(NO_INIT),</span><br><span class="line">      mUpdate(<span class="literal">false</span>),</span><br><span class="line">      mGlobalSettings(<span class="keyword">new</span> AMessage()) &#123;</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs.xml"</span>);</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs_performance.xml"</span>, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">    parseTopLevelXMLFile(kProfilingResults, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(∩_∩)O哈哈~，终于分析到Codecs加载的地方了。还记得第一章节分析的附录吗，高通的音视频硬解码，这里再贴一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line"></span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br></pre></td></tr></table></figure><h5 id="2-3-5、MediaCodec-gt-configure"><a href="#2-3-5、MediaCodec-gt-configure" class="headerlink" title="2.3.5、MediaCodec-&gt;configure()"></a>2.3.5、MediaCodec-&gt;configure()</h5><p>产生kWhatConfigure消息，在消息处理中调用ACodec::initiateConfigureComponent(…)又产生消息kWhatConfigureComponent，然后该消息处理中又调用了ACodec::LoadedState::onConfigureComponent(…)。然后在其中又会先调用ACodec::configureCodec(…)，在configureCodec中会对IOMX进行一系列的设置以及配置操作，通过Binder通信就对OMXNodeInstance进行相应的设置和配置操作，最终就对OMX组件进行了相应的设置和配置。然后向MediaCodec发送kWhatComponentConfigured消息，在消息处理中将MediaCodec状态设为CONFIGURED；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::configure(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ICrypto&gt; &amp;crypto,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format-&gt;setObject(<span class="string">"native-window"</span>, obj);</span><br><span class="line">                <span class="keyword">status_t</span> err = handleSetSurface(<span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleSetSurface(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mReplyID = replyID;</span><br><span class="line">            setState(CONFIGURING);</span><br><span class="line">            ......</span><br><span class="line">            extractCSD(format);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateConfigureComponent(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateConfigureComponent(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    msg-&gt;setWhat(kWhatConfigureComponent);</span><br><span class="line">    msg-&gt;setTarget(<span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">        &#123;</span><br><span class="line">            onConfigureComponent(msg);</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">bool</span> ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;findString(<span class="string">"mime"</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = mCodec-&gt;configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"input-format"</span>, mCodec-&gt;mInputFormat);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"output-format"</span>, mCodec-&gt;mOutputFormat);</span><br><span class="line">        notify-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-6、MediaCodec-gt-start"><a href="#2-3-6、MediaCodec-gt-start" class="headerlink" title="2.3.6、MediaCodec-&gt;start()"></a>2.3.6、MediaCodec-&gt;start()</h5><p>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt; ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::start() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            setState(STARTING);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateStart();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateStart() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;sendCommand(mCodec-&gt;mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCodec-&gt;changeState(mCodec-&gt;mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦缓冲区成功分配到输入和输出端口，OMX组件（编解码）会为Loaded-to-Idle状态生成OMX_EventCmdComplete事件转换并使用EventHandlerCallback将其发送给客户端。</p><h4 id="（三）、音视频解码数据处理"><a href="#（三）、音视频解码数据处理" class="headerlink" title="（三）、音视频解码数据处理"></a>（三）、音视频解码数据处理</h4><h5 id="3-1、音视频解码数据处理-emptyBuffer"><a href="#3-1、音视频解码数据处理-emptyBuffer" class="headerlink" title="3.1、音视频解码数据处理-emptyBuffer"></a>3.1、音视频解码数据处理-emptyBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-03-acodec-emptyBuffer.png" alt="Alt text"></p><p>1、 MediaCodec::start()之后ACodec是在LoadedToIdleState状态，此时若ACodec::LoadedToIdleState::onOMXEvent(…)接收到组件转换至Idle状态后的OMX_EventCmdComplete事件，会向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Executing状态（这里OMX会发送OMX_EventCmdComplete事件），然后ACodec进行changeState至IdleToExecutingState。<br>2、 此时ACodec::IdleToExecutingState::onOMXEvent(…)检测到上面的OMX_EventCmdComplete事件后，会首先调用函数ACodec::ExecutingState::resume()，然后对ACodec进行changeState至ExecutingState。</p><h5 id="3-1-1、ACodec-ExecutingState-resume"><a href="#3-1-1、ACodec-ExecutingState-resume" class="headerlink" title="3.1.1、ACodec::ExecutingState::resume()"></a>3.1.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)BufferInfo::OWNED_BY_US);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    info-&gt;mData-&gt;meta()-&gt;clear();</span><br><span class="line">    notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">    notify-&gt;post();</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数ACodec::ExecutingState::resume()中会调用ACodec::BaseState::postFillThisBuffer(…)，然后其中会先向MediaCodec发送kWhatFillThisBuffer消息，消息处理中在满足相应的条件下就会去调用函数MediaCodec::onInputBufferAvailable()来通知NuPlayer::Decoder有可用的inputbuffer；然后再生成kWhatInputBufferFilled消息，消息处理中调用ACodec::BaseState::onInputBufferFilled(…)。<br>【产生两个消息，一个向上(MediaCodec)处理，一个向下(OMX)处理】</p><h5 id="3-1-1-1、kWhatFillThisBuffer消息处理"><a href="#3-1-1-1、kWhatFillThisBuffer消息处理" class="headerlink" title="3.1.1.1、kWhatFillThisBuffer消息处理"></a>3.1.1.1、kWhatFillThisBuffer消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">                <span class="keyword">case</span> CodecBase::kWhatFillThisBuffer:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* size_t index = */</span>updateBuffers(kPortIndexInput, msg);</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mState == FLUSHED) &#123;</span><br><span class="line">                                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                onInputBufferAvailable();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">                        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">                        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">                        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        postActivityNotificationIfPossible();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 1：MediaCodec::onInputBufferAvailable()的调用：<br>其中会先调用函数MediaCodec::dequeuePortBuffer(…)获取buffer的索引，然后将一个新消息发送给NuPlayer::Decoder，并设置消息的callbackID为CB_INPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_INPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnInputBuffer(…)，其会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">case</span> MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"index"</span>, &amp;index));</span><br><span class="line"></span><br><span class="line">    handleAnInputBuffer(index);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnInputBuffer(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getInputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mInputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add();</span><br><span class="line">            mMediaBuffers.add();</span><br><span class="line">            mInputBufferIsDequeued.add();</span><br><span class="line">            mMediaBuffers.editItemAt(i) = <span class="literal">NULL</span>;</span><br><span class="line">            mInputBufferIsDequeued.editItemAt(i) = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaBuffers[index]-&gt;release();</span><br><span class="line">        mMediaBuffers.editItemAt(index) = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.editItemAt(index) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.isEmpty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(<span class="number">0</span>);</span><br><span class="line">        msg-&gt;setBuffer(<span class="string">"buffer"</span>, buffer);</span><br><span class="line">        mCSDsToSubmit.removeAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin();</span><br><span class="line">        <span class="keyword">if</span> (!onInputBufferFetched(msg)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.editItemAt(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push_back(index);</span><br><span class="line"></span><br><span class="line">    onRequestInputBuffers();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○1、先通过MediaCodec::getInputBuffer(…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer</p><p>○2、然后调用NuPlayer::Decoder::onInputBufferFetched(…)执行内存拷贝将buffer拷贝到编解码器，然后又调用了MediaCodec::queueInputBuffer(…)将buffer提交给解码器，其会产生消息kWhatQueueInputBuffer，消息处理中调用MediaCodec::onQueueInputBuffer(…)</p><p>○3、之后调用函数NuPlayer::DecoderBase::onRequestInputBuffers()，处理是否需要更多的数据。其中会调用NuPlayer::Decoder::doRequestBuffers，若返回true则需要更多的数据，则会产生新消息kWhatRequestInputBuffers，消息处理中又将调用onRequestInputBuffers。（实际获取更多缓冲的操作在下面ACodec部分完成）</p><h5 id="3-1-1-2、kWhatInputBufferFilled消息处理"><a href="#3-1-1-2、kWhatInputBufferFilled消息处理" class="headerlink" title="3.1.1.2、kWhatInputBufferFilled消息处理"></a>3.1.1.2、kWhatInputBufferFilled消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line">        <span class="keyword">case</span> kWhatInputBufferFilled:</span><br><span class="line">        &#123;</span><br><span class="line">            onInputBufferFilled(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onInputBufferFilled(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    <span class="keyword">int32_t</span> err = OK;</span><br><span class="line">    <span class="keyword">bool</span> eos = <span class="literal">false</span>;</span><br><span class="line">    PortMode mode = getPortMode(kPortIndexInput);</span><br><span class="line">    <span class="keyword">int32_t</span> tmp;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexInput, bufferID);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; !mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">                CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">                OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;</span><br><span class="line"></span><br><span class="line">                MetadataBufferType metaType = mCodec-&gt;mInputMetadataType;</span><br><span class="line">                <span class="keyword">int32_t</span> isCSD = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">"csd"</span>, &amp;isCSD) &amp;&amp; isCSD != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCodec-&gt;mIsLegacyVP9Decoder) &#123;</span><br><span class="line">                        postFillThisBuffer(info);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flags |= OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">                    metaType = kMetadataBufferTypeInvalid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">if</span> (buffer != info-&gt;mCodecData) &#123;</span><br><span class="line">                    sp&lt;DataConverter&gt; converter = mCodec-&gt;mConverter[kPortIndexInput];</span><br><span class="line">                    <span class="keyword">status_t</span> err = converter-&gt;convert(buffer, info-&gt;mCodecData);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">status_t</span> err2 = OK;</span><br><span class="line">                <span class="keyword">switch</span> (metaType) &#123;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeInvalid:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeNativeHandleSource:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeHandleMetadata)) &#123;</span><br><span class="line">                        VideoNativeHandleMetadata *vnhmd =</span><br><span class="line">                            (VideoNativeHandleMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateNativeHandleInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                NativeHandle::create(vnhmd-&gt;pHandle, <span class="literal">false</span> <span class="comment">/* ownsHandle */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeANWBuffer:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeMetadata)) &#123;</span><br><span class="line">                        VideoNativeMetadata *vnmd = (VideoNativeMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateGraphicBufferInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                <span class="keyword">new</span> GraphicBuffer(vnmd-&gt;pBuffer, <span class="literal">false</span> <span class="comment">/* keepOwnership */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    err2 = ERROR_UNSUPPORTED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err2 == OK) &#123;</span><br><span class="line">                    err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mCodecData-&gt;size(),</span><br><span class="line">                        flags,</span><br><span class="line">                        timeUs,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eos &amp;&amp; err == OK) &#123;</span><br><span class="line">                    getMoreInputDataIfPossible();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGV(<span class="string">"[%s] Signalled EOS (%d) on the input port"</span>,</span><br><span class="line">                         mCodec-&gt;mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line">                <span class="keyword">status_t</span> err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        OMX_BUFFERFLAG_EOS,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 2：ACodec::BaseState::onInputBufferFilled(…)的调用：<br>因为当前ACodec在ExecutingState，所以PortMode为RESUBMIT_BUFFERS，故会调用IOMX的emptyBuffer(…)方法，经过进程间通信调用到OMX::emptyBuffer(…)，并最终调用OMXNodeInstance::emptyBuffer(…)，其中又会调用到函数OMXNodeInstance::emptyBuffer_l(…)，其则会调用OMX_EmptyThisBuffer宏对OMX组件进行相关的操作（根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent</p><p>○1、其的构造函数的初始化列表中有mComponent-&gt;EmptyThisBuffer = EmptyThisBufferWrapper;故实际会调用其EmptyThisBufferWrapper(…)函数，而其中调用SoftOMXComponent的虚函数emptyThisBuffer。</p><p>○2、所以调用子类的emptyThisBuffer即SimpleSoftOMXComponent::emptyThisBuffer(…)产生kWhatEmptyThisBuffer消息，消息处理中实际的解码器就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyEmptyBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。</p><p>○4、调用到OMXNodeInstance::OnEmptyBufferDone(…)，其又会调用OMX::OnEmptyBufferDone(…)，然后在其中会发送omx_message::EMPTY_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState::onOMXEmptyBufferDone(…)</p><p>○5、在onOMXEmptyBufferDone中获取PortMode，为RESUBMIT_BUFFERS则ACodec::BaseState::postFillThisBuffer(…)被调用，从而又从3中的postFillThisBuffer开始循环执行相关操作以处理更多的输入缓冲。</p><h5 id="3-2、音视频解码数据处理-fillBuffer"><a href="#3-2、音视频解码数据处理-fillBuffer" class="headerlink" title="3.2、音视频解码数据处理-fillBuffer"></a>3.2、音视频解码数据处理-fillBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-04-acodec-fillBuffer.png" alt="Alt text"></p><h5 id="3-2-1、ACodec-ExecutingState-resume"><a href="#3-2-1、ACodec-ExecutingState-resume" class="headerlink" title="3.2.1、ACodec::ExecutingState::resume()"></a>3.2.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitOutputBuffers() &#123;</span><br><span class="line">    submitRegularOutputBuffers();</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        submitOutputMetaBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitRegularOutputBuffers() &#123;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexOutput].size(); ++i) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexOutput].editItemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;checkWriteFence(<span class="string">"submitRegularOutputBuffers"</span>);</span><br><span class="line">        <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、ACodec::ExecutingState::resume()函数，在resume()中调用ACodec::BaseState::postFillThisBuffer(…)前会先调用函数ACodec::ExecutingState::submitOutputBuffers()，即在获取输入数据前会先把输出端的数据提交出去。</p><p>2、在submitOutputBuffers()中调用ACodec::ExecutingState::submitRegularOutputBuffers()，其中又会调用到IOMX的fillBuffer (…)方法，经过进程间通信调用到OMX:: fillBuffer (…)，并最终调用OMXNodeInstance:: fillBuffer (…)，其中又会调用到OMX_FillThisBuffer宏对OMX组件进行相关的操作（同样根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent：（下面的操作与emptyBuffer时类似）</p><p>○1、在其构造函数的初始化列表中有mComponent-&gt;FillThisBuffer = FillThisBufferWrapper;所以实际会调用到其FillThisBufferWrapper (…)函数<br>○2、然后调用SimpleSoftOMXComponent::fillThisBuffer(…)产生kWhatFillThisBuffer消息，消息处理中实际的组件就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyFillBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。<br>○4之后调用到OMXNodeInstance:: OnFillBufferDone (…)函数，其又会调用OMX:: OnFillBufferDone (…)，然后在其中会发送omx_message:: FILL_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState:: onOMXFillBufferDone (…)<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">bool</span> ACodec::BaseState::onOMXFillBufferDone(</span><br><span class="line">        IOMX::buffer_id bufferID,</span><br><span class="line">        <span class="keyword">size_t</span> rangeOffset, <span class="keyword">size_t</span> rangeLength,</span><br><span class="line">        OMX_U32 flags,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">    ALOGV(<span class="string">"[%s] onOMXFillBufferDone %u time %"</span> PRId64 <span class="string">" us, flags = 0x%08x"</span>,</span><br><span class="line">         mCodec-&gt;mComponentName.c_str(), bufferID, timeUs, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    <span class="keyword">status_t</span> err= OK;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACK_BUFFER_TIMING</span></span><br><span class="line">    index = mCodec-&gt;mBufferStats.indexOfKey(timeUs);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ACodec::BufferStats *stats = &amp;mCodec-&gt;mBufferStats.editValueAt(index);</span><br><span class="line">        stats-&gt;mFillBufferDoneTimeUs = ALooper::GetNowUs();</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"frame PTS %lld: %lld"</span>,</span><br><span class="line">                timeUs,</span><br><span class="line">                stats-&gt;mFillBufferDoneTimeUs - stats-&gt;mEmptyBufferTimeUs);</span><br><span class="line"></span><br><span class="line">        mCodec-&gt;mBufferStats.removeItemsAt(index);</span><br><span class="line">        stats = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    BufferInfo *info =</span><br><span class="line">        mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_COMPONENT) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in FBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ::close(fenceFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mDequeuedAt = ++mCodec-&gt;mDequeueCounter;</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;mRenderInfo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// The fence for an emptied buffer must have signaled, but there still could be queued</span></span><br><span class="line">        <span class="comment">// or out-of-order dequeued buffers in the render queue prior to this buffer. Drop these,</span></span><br><span class="line">        <span class="comment">// as we will soon requeue this buffer to the surface. While in theory we could still keep</span></span><br><span class="line">        <span class="comment">// track of buffers that are requeued to the surface, it is better to add support to the</span></span><br><span class="line">        <span class="comment">// buffer-queue to notify us of released buffers and their fences (in the future).</span></span><br><span class="line">        mCodec-&gt;notifyOfRenderedFrames(<span class="literal">true</span> <span class="comment">/* dropIncomplete */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte buffers cannot take fences, so wait for any fence now</span></span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mCodec-&gt;waitForFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line">        fenceFd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;setReadFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line"></span><br><span class="line">    PortMode mode = getPortMode(kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rangeLength == <span class="number">0</span> &amp;&amp; (!(flags &amp; OMX_BUFFERFLAG_EOS)</span><br><span class="line">                    || mCodec-&gt;mPortEOS[kPortIndexOutput])) &#123;</span><br><span class="line">                ......</span><br><span class="line">                err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; reply =</span><br><span class="line">                <span class="keyword">new</span> AMessage(kWhatOutputBufferDrained, mCodec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mOutputFormat != mCodec-&gt;mLastOutputFormat &amp;&amp; rangeLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// pretend that output format has changed on the first frame (we used to do this)</span></span><br><span class="line">                <span class="keyword">if</span> (mCodec-&gt;mBaseOutputFormat == mCodec-&gt;mOutputFormat) &#123;</span><br><span class="line">                    mCodec-&gt;onOutputFormatChanged(mCodec-&gt;mOutputFormat);</span><br><span class="line">                &#125;</span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">                mCodec-&gt;sendFormatChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeLength &gt; <span class="number">0</span> &amp;&amp; mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// If potentially rendering onto a surface, always save key format data (crop &amp;</span></span><br><span class="line">                <span class="comment">// data space) so that we can set it if and once the buffer is rendered.</span></span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;usingMetadataOnEncoderOutput()) &#123;</span><br><span class="line">                <span class="keyword">native_handle_t</span> *handle = <span class="literal">NULL</span>;</span><br><span class="line">                VideoNativeHandleMetadata &amp;nativeMeta =</span><br><span class="line">                    *(VideoNativeHandleMetadata *)info-&gt;mData-&gt;data();</span><br><span class="line">                <span class="keyword">if</span> (info-&gt;mData-&gt;size() &gt;= <span class="keyword">sizeof</span>(nativeMeta)</span><br><span class="line">                        &amp;&amp; nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                    <span class="comment">// handle is only valid on 32-bit/mediaserver process</span></span><br><span class="line">                    handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    handle = (<span class="keyword">native_handle_t</span> *)nativeMeta.pHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setPointer(<span class="string">"handle"</span>, handle);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeOffset"</span>, rangeOffset);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeLength"</span>, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mData == info-&gt;mCodecData) &#123;</span><br><span class="line">                info-&gt;mData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;mCodecData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">                <span class="comment">// in this case we know that mConverter is not null</span></span><br><span class="line">                <span class="keyword">status_t</span> err = mCodec-&gt;mConverter[kPortIndexOutput]-&gt;convert(</span><br><span class="line">                        info-&gt;mCodecData, info-&gt;mData);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mCodec-&gt;mSkipCutBuffer-&gt;submit(info-&gt;mData);</span><br><span class="line">            &#125;</span><br><span class="line">            info-&gt;mData-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatDrainThisBuffer);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line">            notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">            reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">            notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">            notify-&gt;post();</span><br><span class="line"></span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">                ALOGV(<span class="string">"[%s] saw output EOS"</span>, mCodec-&gt;mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">                sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatEOS);</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"err"</span>, mCodec-&gt;mInputEOSResult);</span><br><span class="line">                notify-&gt;post();</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexOutput] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FREE_BUFFERS:</span><br><span class="line">            err = mCodec-&gt;freeBuffer(kPortIndexOutput, index);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Invalid port mode: %d"</span>, mode);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>○5、在onOMXFillBufferDone中获取PortMode，为RESUBMIT_BUFFERS则首先如果需要继续调用到IOMX的fillBuffer (…)填充输出缓冲重复做相关操作，接着ACodec又会生成一个kWhatOutputBufferDrained消息存在reply中，作为kWhatDrainThisBuffer消息的返回消息【notify-&gt;setMessage(“reply”, reply);】，然后向MediaCodec发送消息kWhatDrainThisBuffer，消息处理中调用函数MediaCodec::onOutputBufferAvailable()通知NuPlayer::Decoder有可用的output buffer，其中会设置消息的callbackID为CB_OUTPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_OUTPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnOutputBuffer(…)，在其中会进行如下处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onOutputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer =</span><br><span class="line">            mPortBuffers[kPortIndexOutput].itemAt(index).mData;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_OUTPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;setSize(<span class="string">"offset"</span>, buffer-&gt;offset());</span><br><span class="line">        msg-&gt;setSize(<span class="string">"size"</span>, buffer-&gt;size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> omxFlags;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt32(<span class="string">"omxFlags"</span>, &amp;omxFlags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_CODECCONFIG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、多媒体文件-音视频渲染（Renderer）"><a href="#（四）、多媒体文件-音视频渲染（Renderer）" class="headerlink" title="（四）、多媒体文件 - 音视频渲染（Renderer）"></a>（四）、多媒体文件 - 音视频渲染（Renderer）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnOutputBuffer(</span><br><span class="line">        <span class="keyword">size_t</span> index,</span><br><span class="line">        <span class="keyword">size_t</span> offset,</span><br><span class="line">        <span class="keyword">size_t</span> size,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getOutputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mOutputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mOutputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mOutputBuffers.add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOutputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setRange(offset, size);</span><br><span class="line">    buffer-&gt;meta()-&gt;clear();</span><br><span class="line">    buffer-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> eos = flags &amp; MediaCodec::BUFFER_FLAG_EOS;</span><br><span class="line">    <span class="comment">// we do not expect CODECCONFIG or SYNCFRAME for decoder</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatRenderBuffer, <span class="keyword">this</span>);</span><br><span class="line">    reply-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"generation"</span>, mBufferGeneration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">        reply-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSkipRenderingUntilMediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeUs &lt; mSkipRenderingUntilMediaTimeUs) &#123;</span><br><span class="line">            reply-&gt;post();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSkipRenderingUntilMediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumFramesTotal += !mIsAudio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until 1st frame comes out to signal resume complete</span></span><br><span class="line">    notifyResumeCompleteIfNecessary();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// send the buffer to renderer.</span></span><br><span class="line">        mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply);</span><br><span class="line">        <span class="keyword">if</span> (eos &amp;&amp; !isDiscontinuityPending()) &#123;</span><br><span class="line">            mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a. 在kWhatRenderBuffer消息处理中会调用NuPlayer::Decoder::onRenderBuffer(…)，在其中根据情况调用函数MediaCodec::renderOutputBufferAndRelease(..)渲染并释放，或者调用MediaCodec::releaseOutputBuffer(…)不渲染直接释放，两中情况都会产生kWhatReleaseOutputBuffer消息，该消息处理中调用函数MediaCodec::onReleaseOutputBuffer(…)，其中判断若SoftRenderer非空则进行软件渲染，不然就会通过○5中的reply让ACodec去硬件渲染，在kWhatOutputBufferDrained消息处理就会中调用到函数ACodec::BaseState::onOutputBufferDrained(…)进行真正的硬件渲染。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onRenderBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">size_t</span> bufferIx;</span><br><span class="line">    <span class="keyword">int32_t</span> eos;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"buffer-ix"</span>, &amp;bufferIx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mOutputBuffers[bufferIx];</span><br><span class="line">        buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCCDecoder != <span class="literal">NULL</span> &amp;&amp; mCCDecoder-&gt;isSelected()) &#123;</span><br><span class="line">            mCCDecoder-&gt;display(timeUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs;</span><br><span class="line">        CHECK(msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs));</span><br><span class="line">        err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNumOutputFramesDropped += !mIsAudio;</span><br><span class="line">        err = mCodec-&gt;releaseOutputBuffer(bufferIx);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b. MediaCodec:: getOutputBuffer (…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer的信息<br>c. 若Renderer非空则会调用NuPlayer::Renderer::queueBuffer(…)进行Renderer的相关处理同时消耗产生的kWhatRenderBuffer消息。queueBuffer()会产生kWhatQueueBuffer消息，消息处理中会调用函数NuPlayer::Renderer::onQueueBuffer(…) –&gt; NuPlayer::Renderer::postDrainVideoQueue() 【另外有audio的相关处理】，其中产生kWhatDrainVideoQueue消息，消息处理中调用先NuPlayer::Renderer::onDrainVideoQueue()在VideoQueue中取相关数据，再调用NuPlayer::Renderer::postDrainVideoQueue()循环取video数据，接着还会发送kWhatRenderBuffer消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onQueueBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> audio;</span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        mHasAudio = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHasVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoScheduler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mVideoScheduler = <span class="keyword">new</span> VideoFrameScheduler();</span><br><span class="line">            mVideoScheduler-&gt;init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">"buffer"</span>, &amp;buffer));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notifyConsumed;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"notifyConsumed"</span>, &amp;notifyConsumed));</span><br><span class="line"></span><br><span class="line">    QueueEntry entry;</span><br><span class="line">    entry.mBuffer = buffer;</span><br><span class="line">    entry.mNotifyConsumed = notifyConsumed;</span><br><span class="line">    entry.mOffset = <span class="number">0</span>;</span><br><span class="line">    entry.mFinalResult = OK;</span><br><span class="line">    entry.mBufferOrdinal = ++mTotalBuffersQueued;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mAudioQueue.push_back(entry);</span><br><span class="line">        postDrainAudioQueue_l();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVideoQueue.push_back(entry);</span><br><span class="line">        postDrainVideoQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mSyncQueues || mAudioQueue.empty() || mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer;</span><br><span class="line">    sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstAudioBuffer == <span class="literal">NULL</span> || firstVideoBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        syncQueuesDone_l();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> firstVideoTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> diff = firstVideoTimeUs - firstAudioTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000l</span>l) &#123;</span><br><span class="line">        (*mAudioQueue.begin()).mNotifyConsumed-&gt;post();</span><br><span class="line">        mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syncQueuesDone_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-05-source-demux-decoder-output-render.jpg" alt="Alt text"></p><h4 id="（五）、视频解码输出到SurfaceFlinger"><a href="#（五）、视频解码输出到SurfaceFlinger" class="headerlink" title="（五）、视频解码输出到SurfaceFlinger"></a>（五）、视频解码输出到SurfaceFlinger</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_DOWNSTREAM) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in OBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">android_native_rect_t</span> crop;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findRect(<span class="string">"crop"</span>, &amp;crop.left, &amp;crop.top, &amp;crop.right, &amp;crop.bottom)</span><br><span class="line">            &amp;&amp; <span class="built_in">memcmp</span>(&amp;crop, &amp;mCodec-&gt;mLastNativeWindowCrop, <span class="keyword">sizeof</span>(crop)) != <span class="number">0</span>) &#123;</span><br><span class="line">        mCodec-&gt;mLastNativeWindowCrop = crop;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_crop(mCodec-&gt;mNativeWindow.get(), &amp;crop);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set crop: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> dataSpace;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"dataspace"</span>, &amp;dataSpace)</span><br><span class="line">            &amp;&amp; dataSpace != mCodec-&gt;mLastNativeWindowDataSpace) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_buffers_data_space(</span><br><span class="line">                mCodec-&gt;mNativeWindow.get(), (android_dataspace)dataSpace);</span><br><span class="line">        mCodec-&gt;mLastNativeWindowDataSpace = dataSpace;</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set dataspace: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render != <span class="number">0</span></span><br><span class="line">            &amp;&amp; info-&gt;mData != <span class="literal">NULL</span> &amp;&amp; info-&gt;mData-&gt;size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">"render"</span>);</span><br><span class="line">        <span class="comment">// The client wants this buffer to be rendered.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// save buffers sent to the surface so we can get render time when they return</span></span><br><span class="line">        <span class="keyword">int64_t</span> mediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">        info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs);</span><br><span class="line">        <span class="keyword">if</span> (mediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mCodec-&gt;mRenderTracker.onFrameQueued(</span><br><span class="line">                    mediaTimeUs, info-&gt;mGraphicBuffer, <span class="keyword">new</span> Fence(::dup(info-&gt;mFenceFd)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">            <span class="comment">// use media timestamp if client did not request a specific render timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">                ALOGV(<span class="string">"using buffer PTS of %lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)timestampNs);</span><br><span class="line">                timestampNs *= <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err;</span><br><span class="line">        err = native_window_set_buffers_timestamp(mCodec-&gt;mNativeWindow.get(), timestampNs);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set buffer timestamp: %d"</span>, err);</span><br><span class="line"></span><br><span class="line">        info-&gt;checkReadFence(<span class="string">"onOutputBufferDrained before queueBuffer"</span>);</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"queueBuffer failed in onOutputBufferDrained: %d"</span>, err);</span><br><span class="line">            mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">            <span class="comment">// keeping read fence as write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (info-&gt;mData == <span class="literal">NULL</span> || info-&gt;mData-&gt;size() != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// move read fence into write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">            ATRACE_NAME(<span class="string">"frame-drop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1、Surfaceflinger-视频解码缓存申请"><a href="#5-1、Surfaceflinger-视频解码缓存申请" class="headerlink" title="5.1、Surfaceflinger 视频解码缓存申请"></a>5.1、Surfaceflinger 视频解码缓存申请</h5><p>前面2.3.6、MediaCodec-&gt;start()分析过：<br>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt; ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="comment">//使用surface渲染，为输出分配图形缓存GraphicBuffer  </span></span><br><span class="line"><span class="keyword">status_t</span> ACodec::LoadedToIdleState::allocateBuffers() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;allocateBuffersOnPort(kPortIndexInput);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCodec-&gt;allocateBuffersOnPort(kPortIndexOutput);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateBuffersOnPort(OMX_U32 portIndex) &#123;</span><br><span class="line">    CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    CHECK(mDealer[portIndex] == <span class="literal">NULL</span>);</span><br><span class="line">    CHECK(mBuffers[portIndex].isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">            err = allocateOutputMetadataBuffers();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = allocateOutputBuffersFromNativeWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="5-1-1、allocateOutputBuffersFromNativeWindow-的实现"><a href="#5-1-1、allocateOutputBuffersFromNativeWindow-的实现" class="headerlink" title="5.1.1、allocateOutputBuffersFromNativeWindow()的实现"></a>5.1.1、allocateOutputBuffersFromNativeWindow()的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;</span><br><span class="line">    <span class="keyword">status_t</span> err = configureOutputBuffersFromNativeWindow(</span><br><span class="line">            &amp;bufferCount, &amp;bufferSize, &amp;minUndequeuedBuffers, <span class="literal">true</span> <span class="comment">/* preregister */</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    mNumUndequeuedBuffers = minUndequeuedBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">                -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Dequeue buffers and send them to OMX</span></span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(buf, <span class="literal">false</span>));</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">        info.mFenceFd = fenceFd;</span><br><span class="line">        info.mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        info.mRenderInfo = <span class="literal">NULL</span>;</span><br><span class="line">        info.mData = <span class="keyword">new</span> ABuffer(<span class="literal">NULL</span> <span class="comment">/* data */</span>, bufferSize <span class="comment">/* capacity */</span>);</span><br><span class="line">        info.mCodecData = info.mData;</span><br><span class="line">        info.mGraphicBuffer = graphicBuffer;</span><br><span class="line">        mBuffers[kPortIndexOutput].push(info);</span><br><span class="line"></span><br><span class="line">        IOMX::buffer_id bufferId;</span><br><span class="line">        err = mOMX-&gt;useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,</span><br><span class="line">                &amp;bufferId);</span><br><span class="line">        ......</span><br><span class="line">        mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-1-1、首先为视频编码输出准备Surface"><a href="#5-1-1-1、首先为视频编码输出准备Surface" class="headerlink" title="5.1.1.1、首先为视频编码输出准备Surface"></a>5.1.1.1、首先为视频编码输出准备Surface</h5><p>此处通过Binder通信使用IGraphicBufferProducer请求分配一个Native Surface<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">        -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-06-Surface-ANativeWindow.png" alt="Alt text"></p><h5 id="5-1-1-2、Surface-gt-dequeueBuffer"><a href="#5-1-1-2、Surface-gt-dequeueBuffer" class="headerlink" title="5.1.1.2、Surface-&gt;dequeueBuffer"></a>5.1.1.2、Surface-&gt;dequeueBuffer</h5><p>为Surface分配Buffer，提供给视频解码后数据使用<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="5-2、Surface-gt-queueBuffer"><a href="#5-2、Surface-gt-queueBuffer" class="headerlink" title="5.2、Surface-&gt;queueBuffer()"></a>5.2、Surface-&gt;queueBuffer()</h5><p>待视频解码后，使用queueBuffer()交给SurfaceFlinger渲染，就可以在屏幕上看到视频画面了。<br></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-07-OpenMax-Based video decode-surfaceflinger.png" alt="Alt text"></p><p>关于SurfaceFlinger的知识请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】</p><p><strong>（ ͡° ͜ʖ ͡°）、（ಡωಡ）累~~~，有时间再继续Todo的分析吧，(๑乛◡乛๑) ！！！</strong><br><strong>Todo：Android OpenMax机制 实现分析</strong><br><strong>Todo：Android 音视频同步机制 源码分析</strong><br><strong>Todo：Android 音视频录制（Recoder）、编码（Encode）、混合（MediaMuxer）源码分析</strong></p><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/16222.html" target="_blank" rel="noopener">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a href="https://blog.csdn.net/nonmarking/article/category/6746500" target="_blank" rel="noopener">深入理解Android音视频同步机制（总共五篇）</a><br><a href="https://blog.csdn.net/junzia/article/details/54018671" target="_blank" rel="noopener">Android硬编码——音频编码、视频编码及音视频混合</a></p></div><div class="post-announce">Thank you for reading, this article belongs to <a href="http://zhoujinjian.cc">๑Charles✦ˑ̫✦Vincent๑</a> copyright, if reproduced, please indicate the source：๑Charles✦ˑ̫✦Vincent๑（<a href="http://zhoujinjian.cc/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/">http://zhoujinjian.cc/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/06/01/Android Video System（1）：Video System(视频系统)框架分析/" title="Android Video System（1）：Video System(视频系统)框架分析"><i class="iconfont icon-prev"></i>Android Video System（1）：Video System(视频系统)框架分析</a></div><div class="post__prev post__prev--right"><a href="/2018/06/18/Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析/" title="Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析<i class="iconfont icon-next"></i></a></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">Introduction</h3><p class="block__text">嘿嘿(๑乛◡乛๑),但这也是无可奈何的事情，毕竟世上不可能有那么多十全十美的好事，做人在某些时候总是要有些取舍的。</p></div><div class="sidebar__block"><h3 class="block__title">Tags</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/Android/">Android</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hexo/">Hexo</a></li></ul></div><div class="sidebar__block"><h3 class="block__title">Categories</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/Hexo/">Hexo</a><span class="block-list-count">2</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Android/">Android</a><span class="block-list-count">22</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">Latest Post</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/08/30/Android Display System（5）：Android Display System 系统分析之Display Driver Architecture/" title="Android Display System（5）：Android Display System 系统分析之Display Driver Architecture"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.23.jpg" alt="Android Display System（5）：Android Display System 系统分析之Display Driver Architecture"></div><div class="item__info"><h3 class="item__title">Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</h3><span class="item__text">2018-08-30</span></div></a></li><li class="latest-post-item"><a href="/2018/08/16/Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析/" title="Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.22.jpg" alt="Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析"></div><div class="item__info"><h3 class="item__title">Android Display System（4）：Android Display System 系统分析之Gralloc && HWComposer模块分析</h3><span class="item__text">2018-08-16</span></div></a></li><li class="latest-post-item"><a href="/2018/08/01/Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析/" title="Android Display System（3）：Android Display System 系统分析 之  HardwareRenderer.draw()绘制流程分析"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.21.jpg" alt="Android Display System（3）：Android Display System 系统分析 之  HardwareRenderer.draw()绘制流程分析"></div><div class="item__info"><h3 class="item__title">Android Display System（3）：Android Display System 系统分析 之 HardwareRenderer.draw()绘制流程分析</h3><span class="item__text">2018-08-01</span></div></a></li><li class="latest-post-item"><a href="/2018/07/20/Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL/" title="Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL"><div class="item__cover"><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/hexo.themes/bing-wallpaper-2018.04.20.jpg" alt="Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL"></div><div class="item__info"><h3 class="item__title">Android Display System（2）：Android Display System 系统分析之Android EGL && OpenGL</h3><span class="item__text">2018-07-20</span></div></a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">About</h3><div class="item__content"><p class="item__text">开始的开始亦是结束•结束的结束亦是开始</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Room 103, Building 5, No. 5 Jiangtai Road, Shouxin Building, Chaoyang District, Beijing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>zhou.jinjian@qq.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="/img/DreamWorks_2016_Stacked-MI-512x512.png" alt="logo" title="๑Charles✦ˑ̫✦Vincent๑"></div><div class="footer-top__item"><h3 class="item__title">Friend Links</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://keyin.me/" title="World of Forks" target="_blank">World of Forks</a></li><li class="list-item"><a href="https://molunerfinn.com/" title="MARKSZのBlog" target="_blank">MARKSZのBlog</a></li><li class="list-item"><a href="https://github.com/Mrminfive/hexo-theme-skapp" title="Hexo-theme-skapp" target="_blank">Hexo-theme-skapp</a></li><li class="list-item"><a href="http://zhoujinjian.cc/" title="๑Charles✦ˑ̫✦Vincent๑" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a></li></ul></div></div><div class="footer-top__item"><h3 class="item__title">Build Tools</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://hexo.io/" title="Blog Framework" target="_blank">Hexo</a></li><li class="list-item"><a href="https://dribbble.com/" title="Dribbble" target="_blank">Dribbble</a></li><li class="list-item"><a href="https://pages.github.com/" title="Blog Framework" target="_blank">Github-Pages</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Made by <a href="https://github.com/izhoujinjian" target="_blank">๑Charles✦ˑ̫✦Vincent๑</a>.</p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/izhoujinjian" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="mailto:zhou.jinjian@qq.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span>🍀<span class="post-count">335.4k</span> </span><span>| </span><span id="busuanzi_container_site_uv" style="display:inline">👽<span id="busuanzi_value_site_uv">1000000</span><span></span></span><span class="footer-separator"> | </span><span id="busuanzi_container_site_pv" style="display:inline">🌀<span id="busuanzi_value_site_pv">1000000</span><span></span></span></div></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>