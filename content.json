{"meta":{"title":"à¹‘Charlesâœ¦Ë‘Ì«âœ¦Vincentà¹‘","subtitle":"à¹‘Charlesâœ¦Ë‘Ì«âœ¦Vincentà¹‘","description":"å˜¿å˜¿(à¹‘ä¹›â—¡ä¹›à¹‘),ä½†è¿™ä¹Ÿæ˜¯æ— å¯å¥ˆä½•çš„äº‹æƒ…ï¼Œæ¯•ç«Ÿä¸–ä¸Šä¸å¯èƒ½æœ‰é‚£ä¹ˆå¤šåå…¨åç¾çš„å¥½äº‹ï¼Œåšäººåœ¨æŸäº›æ—¶å€™æ€»æ˜¯è¦æœ‰äº›å–èˆçš„ã€‚","author":"à¹‘Charlesâœ¦Ë‘Ì«âœ¦Vincentà¹‘","url":"http://zhoujinjian.cc"},"pages":[{"title":"404 Page Not Found","date":"2017-08-04T15:36:59.000Z","updated":"2018-03-31T10:12:07.268Z","comments":true,"path":"404.html","permalink":"http://zhoujinjian.cc/404.html","excerpt":"","text":""},{"title":"about","date":"2017-07-28T16:50:51.000Z","updated":"2018-03-31T10:03:00.022Z","comments":true,"path":"about/index.html","permalink":"http://zhoujinjian.cc/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-01-04T16:00:00.000Z","updated":"2018-03-27T10:19:32.000Z","comments":true,"path":"categories/index.html","permalink":"http://zhoujinjian.cc/categories/index.html","excerpt":"","text":"title: Androiddate: 2018-01-05 00:00:00 type: â€œcategoriesâ€ title: Hexodate: 2018-01-05 00:00:00 type: â€œcategoriesâ€"},{"title":"search","date":"2018-04-01T09:52:02.000Z","updated":"2018-04-01T09:56:05.356Z","comments":true,"path":"search/index.html","permalink":"http://zhoujinjian.cc/search/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-03-31T16:00:00.000Z","updated":"2018-04-01T09:51:23.239Z","comments":true,"path":"tags/index.html","permalink":"http://zhoujinjian.cc/tags/index.html","excerpt":"","text":""},{"title":"Android","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-12T11:33:56.000Z","comments":true,"path":"categories/Android/index.html","permalink":"http://zhoujinjian.cc/categories/Android/index.html","excerpt":"","text":""},{"title":"Hexo","date":"2018-01-04T16:00:00.000Z","updated":"2018-01-19T09:55:08.000Z","comments":true,"path":"categories/Hexo/index.html","permalink":"http://zhoujinjian.cc/categories/Hexo/index.html","excerpt":"","text":""}],"posts":[{"title":"zhoujinjian.cc-Androidç³»åˆ—åˆ†ææ–‡æ¡£ã€ğŸŒ€ç½®é¡¶ğŸŒ€ã€‘","slug":"zhoujinjian.cc-Androidç³»åˆ—åˆ†ææ–‡æ¡£ã€ğŸŒ€ç½®é¡¶ğŸŒ€ã€‘","date":"2088-08-08T00:08:08.080Z","updated":"2018-07-09T12:47:10.886Z","comments":true,"path":"2088/08/08/zhoujinjian.cc-Androidç³»åˆ—åˆ†ææ–‡æ¡£ã€ğŸŒ€ç½®é¡¶ğŸŒ€ã€‘/","link":"","permalink":"http://zhoujinjian.cc/2088/08/08/zhoujinjian.cc-Androidç³»åˆ—åˆ†ææ–‡æ¡£ã€ğŸŒ€ç½®é¡¶ğŸŒ€ã€‘/","excerpt":"","text":"Android Multimedia Systemï¼šAndroid Video Systemï¼ˆ5ï¼‰ï¼šAndroid Multimedia - NuPlayeréŸ³è§†é¢‘åŒæ­¥å®ç°åˆ†æAndroid Video Systemï¼ˆ4ï¼‰ï¼šAndroid Multimedia - OpenMaxå®ç°åˆ†æAndroid Video Systemï¼ˆ3ï¼‰ï¼šéŸ³è§†é¢‘å½•åˆ¶Recorderã€ç¼–ç Encoderã€æ··åˆMediaMuxeræºç åˆ†æAndroid Video Systemï¼ˆ2ï¼‰ï¼šéŸ³è§†é¢‘åˆ†ç¦»MediaExtractorã€è§£ç Decoderã€æ¸²æŸ“Rendereræºç åˆ†æAndroid Video Systemï¼ˆ1ï¼‰ï¼šVideo System(è§†é¢‘ç³»ç»Ÿ)æ¡†æ¶åˆ†æ Android Camera Systemï¼šAndroid Camera Systemï¼ˆ2ï¼‰ï¼šCamera System(Camera ç³»ç»Ÿ)startPreviewã€takePictureã€Recorderæµç¨‹åˆ†æAndroid Camera Systemï¼ˆ1ï¼‰ï¼šCamera System(Camera ç³»ç»Ÿ)æ¡†æ¶ã€Open()è¿‡ç¨‹åˆ†æ Android Display Systemï¼šAndroid Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver ArchitectureAndroid Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc &amp;&amp; HWComposeræ¨¡å—åˆ†æAndroid Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.draw()ç»˜åˆ¶æµç¨‹åˆ†æAndroid Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL &amp;&amp; OpenGLAndroid Display Systemï¼ˆ1ï¼‰ï¼šAndroid 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æ Android Audio Systemï¼šAndroid Audio Systemï¼ˆ3ï¼‰ï¼šAndroid audio system(éŸ³é¢‘ç³»ç»Ÿ)åˆ†æAndroid Audio Systemï¼ˆ2ï¼‰ï¼šLinux ALSAéŸ³é¢‘ç³»ç»Ÿåˆ†æAndroid Audio Systemï¼ˆ1ï¼‰ï¼šLinux &amp;&amp; Android Audio ç³»ç»Ÿæ¡†æ¶åˆ†æ Android Input Systemï¼šAndroid Input Systemï¼ˆ2ï¼‰ï¼šAndroid 7.1.2 (Android N) Android è¾“å…¥å­ç³»ç»Ÿ - Input System åˆ†æAndroid Input Systemï¼ˆ1ï¼‰ï¼šLinuxå†…æ ¸ï¼ˆKernel-3.18ï¼‰ - Linux Input å­ç³»ç»Ÿ åˆ†æ Android åŸºç¡€ï¼ˆAMS &amp; WMSï¼‰AndroidåŸºç¡€ ï¼ˆ6ï¼‰ï¼šAndroid 7.1.2 (Android N) Android WindowManagerService çª—å£ç®¡ç†æœåŠ¡ åˆ†æAndroidåŸºç¡€ ï¼ˆ5ï¼‰ï¼šAndroid 7.1.2 (Android N) Activity - Window åŠ è½½æ˜¾ç¤ºæµç¨‹ åˆ†æAndroidåŸºç¡€ ï¼ˆ4ï¼‰ï¼šAndroid 7.1.2 (Android N) Activity å¯åŠ¨æµç¨‹ ï¼ˆAMSï¼‰åˆ†æAndroidåŸºç¡€ ï¼ˆ3ï¼‰ï¼šAndroid 7.1.2 (Android N) Android ç³»ç»Ÿå¯åŠ¨æµç¨‹ åˆ†æAndroidåŸºç¡€ ï¼ˆ2ï¼‰ï¼šAndroid 7.1.2 (Android N) Android Binder ç³»ç»Ÿåˆ†æAndroidåŸºç¡€ ï¼ˆ1ï¼‰ï¼šAndroid 7.1.2 (Android N) Androidæ¶ˆæ¯æœºåˆ¶â€“Handlerã€Looperã€Message åˆ†æ","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Video Systemï¼ˆ5ï¼‰ï¼šAndroid Multimedia - NuPlayeréŸ³è§†é¢‘åŒæ­¥å®ç°åˆ†æ","slug":"Android Video Systemï¼ˆ5ï¼‰ï¼šAndroid Multimedia - NuPlayeréŸ³è§†é¢‘åŒæ­¥å®ç°åˆ†æ","date":"2018-09-11T16:00:00.000Z","updated":"2018-07-09T12:33:48.621Z","comments":true,"path":"2018/09/12/Android Video Systemï¼ˆ5ï¼‰ï¼šAndroid Multimedia - NuPlayeréŸ³è§†é¢‘åŒæ­¥å®ç°åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/09/12/Android Video Systemï¼ˆ5ï¼‰ï¼šAndroid Multimedia - NuPlayeréŸ³è§†é¢‘åŒæ­¥å®ç°åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android MediaCodec ACodecã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - android ACodec MediaCodec NuPlayer flowã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ï¼ˆä¸€ï¼‰ã€éŸ³è§†é¢‘åŒæ­¥æ—¶å¦‚ä½•å®ç°çš„ï¼Ÿä»Rendereræ¥å£å±‚æ¥çœ‹ï¼Œæ²¡æœ‰ä»»ä½•å…³äºåŒæ­¥å¤„ç†çš„æ¥å£ï¼Œä»…æœ‰æœ‰é™çš„å‡ ä¸ªæ§åˆ¶æ¥å£flush/pause/resumeï¼Œä»¥åŠqueueBuffer/queueEOSæ¥å£ã€‚åŒæ­¥é—®é¢˜çš„æ ¸å¿ƒå°±åœ¨äºALooper-AHandleræœºåˆ¶ã€‚å…¶å®çœŸæ­£çš„åŒæ­¥éƒ½æ˜¯åœ¨æ¶ˆæ¯å¾ªç¯çš„å“åº”å‡½æ•°é‡Œå®ç°çš„ã€‚å…ˆçœ‹éŸ³é¢‘ã€‚ 1.1ã€Rendererä¸­çš„éŸ³é¢‘åŒæ­¥æœºåˆ¶èµ·å§‹ä½ç½®ä»éŸ³é¢‘PCMæ•°æ®è¿›å…¥å¼€å§‹ï¼Œå¤„ç†åœ¨Renderer::queueBuffer()ä¸­ï¼Œæœ€ç»ˆå‘é€äº†kWhatQueueBufferæ¶ˆæ¯ã€‚è¿™ä¸ªæ¶ˆæ¯çš„å®é™…å¤„ç†å‡½æ•°æ˜¯Renderer::onQueueBuffer()ã€‚å®é™…ä»£ç åœ¨â€œéŸ³è§†é¢‘åŸå§‹æ•°æ®è¾“å…¥â€”â€”queueBufferâ€ä¸­æœ‰ï¼Œè¿™é‡Œä»…é’ˆå¯¹éŸ³é¢‘æµç¨‹è§£é‡Šä¸‹ã€‚ åŸºæœ¬é€»è¾‘å¾ˆç®€å•ï¼Œä¿å­˜ä¼ å…¥çš„bufferå‚æ•°ï¼Œå¹¶é€šçŸ¥è¾“å‡ºä¸‹AudioQueueã€‚ 1234567891011121314151617181920[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]void NuPlayer::Renderer::onQueueBuffer(const sp&lt;AMessage&gt; &amp;msg) &#123;...... QueueEntry entry; entry.mBuffer = buffer; entry.mNotifyConsumed = notifyConsumed; entry.mOffset = 0; entry.mFinalResult = OK; entry.mBufferOrdinal = ++mTotalBuffersQueued; if (audio) &#123; Mutex::Autolock autoLock(mLock); mAudioQueue.push_back(entry); postDrainAudioQueue_l(); &#125; else &#123; mVideoQueue.push_back(entry); postDrainVideoQueue(); &#125;......&#125; ä¸‹é¢çœ‹çœ‹postDrainAudioQueue_lçš„å®ç°ï¼Œå†…éƒ¨å®ç°é€»è¾‘åŸºæœ¬ä¸Šå°±æ˜¯è¾¹ç•Œåˆ¤æ–­åŠ ä¸Šå‘é€kWhatDrainAudioQueueæ¶ˆæ¯ã€‚ 123456789[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]void NuPlayer::Renderer::postDrainAudioQueue_l(int64_t delayUs) &#123; if (mAudioQueue.empty()) return; mDrainAudioQueuePending = true; sp&lt;AMessage&gt; msg = new AMessage(kWhatDrainAudioQueue, this); msg-&gt;setInt32(\"drainGeneration\", mAudioDrainGeneration); msg-&gt;post(delayUs);&#125; é‚£å°±ç»§ç»­æŸ¥çœ‹ä¸‹è¿™ä¸ªæ¶ˆæ¯å¦‚ä½•å¤„ç†çš„ã€‚ 1234567891011121314151617181920212223242526[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp] case kWhatDrainAudioQueue: &#123; mDrainAudioQueuePending = false; if (onDrainAudioQueue()) &#123; uint32_t numFramesPlayed; uint32_t numFramesPendingPlayout = mNumFramesWritten - numFramesPlayed; // è¿™é‡Œæ˜¯audio sinkä¸­ç¼“å­˜äº†å¤šé•¿çš„å¯ç”¨äºæ’­æ”¾çš„æ•°æ® int64_t delayUs = mAudioSink-&gt;msecsPerFrame() * numFramesPendingPlayout * 1000ll; if (mPlaybackRate &gt; 1.0f) &#123; delayUs /= mPlaybackRate; &#125; // åˆ©ç”¨ä¸€åŠçš„å»¶æ—¶æ¥ä¿è¯ä¸‹æ¬¡åˆ·æ–°æ—¶é—´ï¼ˆæ³¨æ„æ—¶é—´ä¸Šæœ‰é‡å ï¼‰ delayUs /= 2; // å‚è€ƒbufferå¤§å°æ¥ä¼°è®¡æœ€å¤§çš„å»¶æ—¶æ—¶é—´ const int64_t maxDrainDelayUs = std::max( mAudioSink-&gt;getBufferDurationInUs(), (int64_t)500000 /* half second */); ALOGD_IF(delayUs &gt; maxDrainDelayUs, \"postDrainAudioQueue long delay: %lld &gt; %lld\", (long long)delayUs, (long long)maxDrainDelayUs); Mutex::Autolock autoLock(mLock); postDrainAudioQueue_l(delayUs); // è¿™é‡ŒåŒä¸€ä¸ªæ¶ˆæ¯é‡å‘äº† &#125; break; &#125; åˆ°è¿™é‡Œï¼Œè²Œä¼¼è¿˜æ˜¯æ²¡æœ‰åŒæ­¥çš„æœºåˆ¶ï¼Œä¸è¿‡æˆ‘ä»¬å·²ç»çŸ¥é“è¿™ä¸ªéŸ³é¢‘æ’­æ”¾æ¶ˆæ¯çš„è§¦å‘æœºåˆ¶äº†ï¼Œåœ¨queueBufferå’Œæ¶ˆæ¯å¤„ç†å‡½æ•°ä¸­éƒ½ä¼šè§¦å‘ï¼ŒåŸºæœ¬ä¸Šå°±æ˜¯å®šæ—¶å™¨ã€‚è¿˜æœ‰æœ€åä¸€ä¸ªå‡½æ•°onDrainAudioQueue()ã€‚ä¸‹é¢æ˜¯ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]bool NuPlayer::Renderer::onDrainAudioQueue() &#123; uint32_t numFramesPlayed; if (mAudioSink-&gt;getPosition(&amp;numFramesPlayed) != OK) &#123; drainAudioQueueUntilLastEOS(); ALOGW(\"onDrainAudioQueue(): audio sink is not ready\"); return false; &#125; uint32_t prevFramesWritten = mNumFramesWritten; while (!mAudioQueue.empty()) &#123; QueueEntry *entry = &amp;*mAudioQueue.begin(); mLastAudioBufferDrained = entry-&gt;mBufferOrdinal; if (entry-&gt;mBuffer == NULL) &#123; // åˆ é™¤é’ˆå¯¹EOSçš„å¤„ç†ä»£ç  &#125; // ignore 0-sized buffer which could be EOS marker with no data if (entry-&gt;mOffset == 0 &amp;&amp; entry-&gt;mBuffer-&gt;size() &gt; 0) &#123; int64_t mediaTimeUs; CHECK(entry-&gt;mBuffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;mediaTimeUs)); ALOGV(\"onDrainAudioQueue: rendering audio at media time %.2f secs\", mediaTimeUs / 1E6); onNewAudioMediaTime(mediaTimeUs); &#125; size_t copy = entry-&gt;mBuffer-&gt;size() - entry-&gt;mOffset; ssize_t written = mAudioSink-&gt;write(entry-&gt;mBuffer-&gt;data() + entry-&gt;mOffset, copy, false /* blocking */); if (written &lt; 0) &#123;/* ...å¿½ç•¥å¼‚å¸¸å¤„ç†éƒ¨åˆ†ä»£ç  */&#125; entry-&gt;mOffset += written; size_t remainder = entry-&gt;mBuffer-&gt;size() - entry-&gt;mOffset; if ((ssize_t)remainder &lt; mAudioSink-&gt;frameSize()) &#123; if (remainder &gt; 0) &#123;// è¿™æ˜¯ç›´æ¥å‡‘æˆå®Œæ•´çš„ä¸€å¸§éŸ³é¢‘ ALOGW(\"Corrupted audio buffer has fractional frames, discarding %zu bytes.\", remainder); entry-&gt;mOffset += remainder; copy -= remainder; &#125; entry-&gt;mNotifyConsumed-&gt;post(); mAudioQueue.erase(mAudioQueue.begin()); entry = NULL; &#125; size_t copiedFrames = written / mAudioSink-&gt;frameSize(); mNumFramesWritten += copiedFrames; &#123; Mutex::Autolock autoLock(mLock); int64_t maxTimeMedia; maxTimeMedia = mAnchorTimeMediaUs + (int64_t)(max((long long)mNumFramesWritten - mAnchorNumFramesWritten, 0LL) * 1000LL * mAudioSink-&gt;msecsPerFrame()); mMediaClock-&gt;updateMaxTimeMedia(maxTimeMedia); notifyIfMediaRenderingStarted_l(); &#125; if (written != (ssize_t)copy) &#123; // A short count was received from AudioSink::write() // // AudioSink write is called in non-blocking mode. // It may return with a short count when: // // 1) Size to be copied is not a multiple of the frame size. Fractional frames are // discarded. // 2) The data to be copied exceeds the available buffer in AudioSink. // 3) An error occurs and data has been partially copied to the buffer in AudioSink. // 4) AudioSink is an AudioCache for data retrieval, and the AudioCache is exceeded. // (Case 1) // Must be a multiple of the frame size. If it is not a multiple of a frame size, it // needs to fail, as we should not carry over fractional frames between calls. CHECK_EQ(copy % mAudioSink-&gt;frameSize(), 0); // (Case 2, 3, 4) // Return early to the caller. // Beware of calling immediately again as this may busy-loop if you are not careful. ALOGV(\"AudioSink write short frame count %zd &lt; %zu\", written, copy); break; &#125; &#125; // calculate whether we need to reschedule another write. bool reschedule = !mAudioQueue.empty() &amp;&amp; (!mPaused || prevFramesWritten != mNumFramesWritten); // permit pause to fill buffers //ALOGD(\"reschedule:%d empty:%d mPaused:%d prevFramesWritten:%u mNumFramesWritten:%u\", // reschedule, mAudioQueue.empty(), mPaused, prevFramesWritten, mNumFramesWritten); return reschedule;&#125; è¿™é‡Œé¢æ¯”è¾ƒä¸»è¦çš„æ›´æ–°æ˜¯onNewAudioMediaTimeå’ŒmNumFramesWrittenå­—æ®µã€‚å‰©ä¸‹çš„ä¸€éƒ¨åˆ†ä»£ç æ˜¯å…³äºå¼‚å¸¸è¾¹ç•Œæƒ…å†µä¸‹çš„éŸ³è§†é¢‘å¤„ç†é€»è¾‘ï¼š 123456789101112131415161718192021222324252627[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer; sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer; if (firstAudioBuffer == NULL || firstVideoBuffer == NULL) &#123; // å¯¹äºä¸€ä¸ªé˜Ÿåˆ—ä¸ºç©ºçš„æƒ…å†µï¼Œé€šçŸ¥å¦ä¸ªä¸€é˜Ÿåˆ—EOS syncQueuesDone_l(); return; &#125; int64_t firstAudioTimeUs; int64_t firstVideoTimeUs; CHECK(firstAudioBuffer-&gt;meta() -&gt;findInt64(\"timeUs\", &amp;firstAudioTimeUs)); CHECK(firstVideoBuffer-&gt;meta() -&gt;findInt64(\"timeUs\", &amp;firstVideoTimeUs)); int64_t diff = firstVideoTimeUs - firstAudioTimeUs; if (diff &gt; 100000ll) &#123; // éŸ³é¢‘æ•°æ®æ—¶é—´æˆ³æ¯”è§†é¢‘æ•°æ®æ—©0.1sï¼Œ (*mAudioQueue.begin()).mNotifyConsumed-&gt;post(); mAudioQueue.erase(mAudioQueue.begin()); return; &#125; syncQueuesDone_l(); 1.2ã€Rendererä¸­çš„è§†é¢‘åŒæ­¥éƒ¨åˆ†å’ŒéŸ³é¢‘åŒæ­¥ç±»ä¼¼ï¼Œå…¥å£åœ¨åœ¨Renderer::queueBuffer()ï¼Œä¸»è¦åŒºåˆ†åœ¨Renderer::onQueueBuffer()ä¸­ï¼Œä»£ç å¦‚ä¸‹ï¼š 123// å¦‚æœæ˜¯è§†é¢‘ï¼Œåˆ™å°†æ•°æ®å­˜æ”¾åˆ°è§†é¢‘é˜Ÿåˆ—ï¼Œç„¶åå®‰æ’åˆ·æ–°mVideoQueue.push_back(entry);postDrainVideoQueue(); ä¸‹é¢æŒ‰ç…§ä¹‹å‰çš„æ€è·¯ç»§ç»­åˆ†æï¼Œæ¥ä¸‹æ¥æ˜¯postDrainVideoQueueå®ç°ï¼Œä¸»è¦éŸ³è§†é¢‘åŒæ­¥é€»è¾‘ä½äºè¿™é‡Œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]void NuPlayer::Renderer::postDrainVideoQueue() &#123; if (mVideoQueue.empty()) &#123; return; &#125; QueueEntry &amp;entry = *mVideoQueue.begin(); sp&lt;AMessage&gt; msg = new AMessage(kWhatDrainVideoQueue, this); //è¿™æ˜¯å®é™…å¤„ç†è§†é¢‘ç¼“å†²åŒºå’Œæ˜¾ç¤ºçš„æ¶ˆæ¯ msg-&gt;setInt32(\"drainGeneration\", getDrainGeneration(false /* audio */)); if (entry.mBuffer == NULL) &#123; // EOS doesn't carry a timestamp. msg-&gt;post(); mDrainVideoQueuePending = true; return; &#125; bool needRepostDrainVideoQueue = false; int64_t delayUs; int64_t nowUs = ALooper::GetNowUs(); int64_t realTimeUs; int64_t mediaTimeUs; CHECK(entry.mBuffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;mediaTimeUs)); if (mFlags &amp; FLAG_REAL_TIME) &#123; realTimeUs = mediaTimeUs; &#125; else &#123; &#123; Mutex::Autolock autoLock(mLock); if (mAnchorTimeMediaUs &lt; 0) &#123; // åŒæ­¥åŸºå‡†æœªè®¾ç½®çš„æƒ…å†µä¸‹ï¼Œç›´æ¥æ˜¾ç¤º mMediaClock-&gt;updateAnchor(mediaTimeUs, nowUs, mediaTimeUs); mAnchorTimeMediaUs = mediaTimeUs; realTimeUs = nowUs; &#125; else if (!mVideoSampleReceived) &#123; // ç¬¬ä¸€å¸§æœªæ˜¾ç¤ºå‰ï¼Œç›´æ¥æ˜¾ç¤º // Always render the first video frame. realTimeUs = nowUs; &#125; else if (mAudioFirstAnchorTimeMediaUs &lt; 0 // éŸ³é¢‘æœªæ’­æ”¾ä¹‹å‰ï¼Œä»¥è§†é¢‘ä¸ºå‡† || mMediaClock-&gt;getRealTimeFor(mediaTimeUs, &amp;realTimeUs) == OK) &#123; realTimeUs = getRealTimeUs(mediaTimeUs, nowUs); &#125; else if (mediaTimeUs - mAudioFirstAnchorTimeMediaUs &gt;= 0) &#123; // è§†é¢‘è¶…å‰çš„æƒ…å†µä¸‹ï¼Œç­‰å¾… needRepostDrainVideoQueue = true; realTimeUs = nowUs; &#125; else &#123; realTimeUs = nowUs; &#125; &#125; // Heuristics to handle situation when media time changed without a // discontinuity. If we have not drained an audio buffer that was // received after this buffer, repost in 10 msec. Otherwise repost // in 500 msec. delayUs = realTimeUs - nowUs; int64_t postDelayUs = -1; if (delayUs &gt; 500000) &#123; postDelayUs = 500000; if (mHasAudio &amp;&amp; (mLastAudioBufferDrained - entry.mBufferOrdinal) &lt;= 0) &#123; postDelayUs = 10000; &#125; &#125; else if (needRepostDrainVideoQueue) &#123; // CHECK(mPlaybackRate &gt; 0); // CHECK(mAudioFirstAnchorTimeMediaUs &gt;= 0); // CHECK(mediaTimeUs - mAudioFirstAnchorTimeMediaUs &gt;= 0); postDelayUs = mediaTimeUs - mAudioFirstAnchorTimeMediaUs; postDelayUs /= mPlaybackRate; &#125; if (postDelayUs &gt;= 0) &#123; msg-&gt;setWhat(kWhatPostDrainVideoQueue); msg-&gt;post(postDelayUs); mVideoScheduler-&gt;restart(); ALOGI(\"possible video time jump of %dms or uninitialized media clock, retrying in %dms\", (int)(delayUs / 1000), (int)(postDelayUs / 1000)); mDrainVideoQueuePending = true; return; &#125; &#125; realTimeUs = mVideoScheduler-&gt;schedule(realTimeUs * 1000) / 1000; int64_t twoVsyncsUs = 2 * (mVideoScheduler-&gt;getVsyncPeriod() / 1000); delayUs = realTimeUs - nowUs; // ä¸Šé¢ä»£ç çš„ä¸»è¦ç›®çš„æ˜¯è®¡ç®—è¿™ä¸ªå»¶æ—¶ ALOGW_IF(delayUs &gt; 500000, \"unusually high delayUs: %\" PRId64, delayUs); // post 2 display refreshes before rendering is due msg-&gt;post(delayUs &gt; twoVsyncsUs ? delayUs - twoVsyncsUs : 0); mDrainVideoQueuePending = true;&#125; è¿™é‡Œä¸»è¦çš„æ˜¯å‘é€äº†ä¸€ä¸ªå»¶æ—¶æ¶ˆæ¯kWhatDrainVideoQueueï¼Œä¸‹é¢æ˜¯å¦‚ä½•å¤„ç†çš„ä»£ç ï¼š 1234567891011121314[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]case kWhatDrainVideoQueue:&#123; int32_t generation; CHECK(msg-&gt;findInt32(\"drainGeneration\", &amp;generation)); if (generation != getDrainGeneration(false /* audio */)) &#123; break; &#125; mDrainVideoQueuePending = false; onDrainVideoQueue(); postDrainVideoQueue(); // æ³¨æ„è¿™é‡Œç›¸å½“äºå®šæ—¶å™¨çš„å®ç°äº† break;&#125; ç›´æ¥è°ƒç”¨onDrainVideoQueueå‡½æ•°ï¼Œçœ‹çœ‹å¦‚ä½•å®ç°çš„ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]void NuPlayer::Renderer::onDrainVideoQueue() &#123; if (mVideoQueue.empty()) &#123; return; &#125; QueueEntry *entry = &amp;*mVideoQueue.begin(); if (entry-&gt;mBuffer == NULL) &#123; // ...çœç•¥é’ˆå¯¹EOS å¤„ç† &#125; int64_t nowUs = ALooper::GetNowUs(); int64_t realTimeUs; int64_t mediaTimeUs = -1; if (mFlags &amp; FLAG_REAL_TIME) &#123; CHECK(entry-&gt;mBuffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;realTimeUs)); &#125; else &#123; CHECK(entry-&gt;mBuffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;mediaTimeUs)); realTimeUs = getRealTimeUs(mediaTimeUs, nowUs); &#125; bool tooLate = false; if (!mPaused) &#123; setVideoLateByUs(nowUs - realTimeUs); tooLate = (mVideoLateByUs &gt; 40000); if (tooLate) &#123; ALOGV(\"video late by %lld us (%.2f secs)\", (long long)mVideoLateByUs, mVideoLateByUs / 1E6); &#125; else &#123; int64_t mediaUs = 0; mMediaClock-&gt;getMediaTime(realTimeUs, &amp;mediaUs); ALOGV(\"rendering video at media time %.2f secs\", (mFlags &amp; FLAG_REAL_TIME ? realTimeUs : mediaUs) / 1E6); if (!(mFlags &amp; FLAG_REAL_TIME) &amp;&amp; mLastAudioMediaTimeUs != -1 &amp;&amp; mediaTimeUs &gt; mLastAudioMediaTimeUs) &#123; // If audio ends before video, video continues to drive media clock. // Also smooth out videos &gt;= 10fps. mMediaClock-&gt;updateMaxTimeMedia(mediaTimeUs + 100000); &#125; &#125; &#125; else &#123; setVideoLateByUs(0); if (!mVideoSampleReceived &amp;&amp; !mHasAudio) &#123; // This will ensure that the first frame after a flush won't be used as anchor // when renderer is in paused state, because resume can happen any time after seek. Mutex::Autolock autoLock(mLock); clearAnchorTime_l(); &#125; &#125; // Always render the first video frame while keeping stats on A/V sync. if (!mVideoSampleReceived) &#123; realTimeUs = nowUs; tooLate = false; &#125; entry-&gt;mNotifyConsumed-&gt;setInt64(\"timestampNs\", realTimeUs * 1000ll); // ä¸Šé¢æ‰€æœ‰è®¡ç®—çš„å‚æ•°åœ¨è¿™é‡Œä½¿ç”¨äº† entry-&gt;mNotifyConsumed-&gt;setInt32(\"render\", !tooLate); entry-&gt;mNotifyConsumed-&gt;post(); // æ³¨æ„è¿™é‡Œï¼Œå®é™…æ˜¯å‘è§£ç å™¨å‘é€æ¶ˆæ¯ï¼Œç”¨äºæ˜¾ç¤º mVideoQueue.erase(mVideoQueue.begin()); entry = NULL; mVideoSampleReceived = true; if (!mPaused) &#123; // è¿™é‡Œæ˜¯é€šçŸ¥NuPlayerå±‚æ¸²æŸ“å¼€å§‹ if (!mVideoRenderingStarted) &#123; mVideoRenderingStarted = true; notifyVideoRenderingStart(); &#125; Mutex::Autolock autoLock(mLock); notifyIfMediaRenderingStarted_l(); &#125;&#125; åˆ°è¿™é‡Œï¼Œå°ç»“ä¸‹ï¼Œè¯»å®Œè¿™éƒ¨åˆ†ä»£ç å‘ç°ï¼ŒNuPlayer::Rendererä½¿ç”¨çš„ä»¥è§†é¢‘ä¸ºåŸºå‡†çš„åŒæ­¥æœºåˆ¶ï¼ŒéŸ³é¢‘æ™šäº†ç›´æ¥ä¸¢åŒ…ï¼Œè§†é¢‘éœ€è¦æ˜¾ç¤ºã€‚åŒæ­¥ä¸»è¦ä½äºè§†é¢‘ç¼“å†²åŒºå¤„ç†éƒ¨åˆ†onDrainVideoQueueå’ŒéŸ³é¢‘ç¼“å†²åŒºå¤„ç†éƒ¨åˆ†onDrainVideoQueueä¸­ã€‚ ï¼ˆäºŒï¼‰ã€éŸ³è§†é¢‘åŒæ­¥æ—¶åºå›¾ 1ï¼šOMX component é›†æˆåœ¨ACodecä¸­ï¼ŒACodecï¼ˆA/Vï¼‰è§£å®Œæ•°æ®åï¼Œé€šçŸ¥Nulayerï¼›2ï¼šNuPlayeré€šçŸ¥Renderï¼ŒRenderéœ€è¦A/Vçš„æ—¶é—´åŒæ­¥ï¼ˆå¦ï¼Œå¦‚æœæ˜¯JPEGçš„è¯å°±ä¸éœ€è¦è¿™ä¸ªåŒæ­¥ï¼Œç›´æ¥renderå³å¯ï¼‰ï¼›3ï¼šå¯¹äºAudioï¼Œç›´æ¥é€šè¿‡AudioSinkæ’­æ”¾ï¼›4ï¼šå¯¹äºVideoï¼Œé€šè¿‡é€šçŸ¥ACodecï¼Œè®©ACodecé€šè¿‡(NativeWindow/Render)å‘é€åˆ°ç•Œé¢ Step1:1.1 omx_message::FILL_BUFFER_DONE ===&gt;&gt;&gt;ACodec::onOMXFillBufferDone() OMX component send msg FILL_BUFFER_DONE ACodec call onOMXFillBufferDone to handle1.2 ACodec::onOMXFillBufferDone()::ACodec::kWhatDrainThisBuffer setMessage ===&gt;&gt;&gt; NuPlayer::onMessageReceived()Step2:2.1 NuPlayer::renderBuffer()2.2 NuPlayer::Renderer::queueBuffer() ===&gt;&gt;&gt; send msg kWhatQueueBuffer2.3 NuPlayer::Renderer::onMessageReceived() ===&gt;&gt;&gt; onQueueBuffer()2.4 postDrainAudioQueue() or postDrainVideoQueue() ===&gt;&gt;&gt; send msg kWhatDrainVideoQueue2.5 onMessageReceived() ===&gt;&gt;&gt; onDrainVideoQueue(); postDrainVideoQueue();onDrainVideoQueue():A/Vçš„æ—¶é—´åŒæ­¥,å¦‚æœæ…¢0.4s,æ ‡è®°too_latepostDrainVideoQueue():A/Vçš„æ—¶é—´åŒæ­¥,å¦‚æœè§£ç æ—¶é—´å¿«ï¼Œå†³å®šç­‰å¾…çš„æ—¶é—´ï¼Œå¹¶æŠŠæ¶ˆæ¯ç»™renderStep3ï¼š3.1 postDrainAudioQueue()===&gt;&gt;&gt;onDrainAudioQueue()===&gt;&gt;&gt;mAudioSink-&gt;write()Step4:4.1 Renderer::onDrainVideoQueue(): entry-&gt;mNotifyConsumed-&gt;setInt32(â€œrenderâ€, !tooLate);4.2 Renderer::postDrainVideoQueue()===&gt;&gt;&gt; send msg kWhatDrainVideoQueue4.2 ACodec::BaseState::onMessageReceived() ===&gt;&gt;&gt; onOutputBufferDrained(msg); 1234567891011121314151617181920Log:...07-03 11:32:58.675 741 5075 V NuPlayerRenderer: rendering video at media time 0.36 secs07-03 11:32:58.676 725 1139 V AudioFlinger: releaseWakeLock_l() AudioOut_2507-03 11:32:58.676 725 1139 V AudioFlinger: thread 0xef883380 type 0 TID 1139 going to sleep07-03 11:32:58.679 725 1131 V AudioFlinger: releaseWakeLock_l() AudioOut_D07-03 11:32:58.682 741 5075 V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time 0.70 secs07-03 11:32:58.683 741 5075 V AudioTrack: frame adjustment:2400 timestamp:BOOTTIME offset 007-03 11:32:58.683 741 5075 V AudioTrack: ExtendedTimestamp[0] position: 0 time: -107-03 11:32:58.683 741 5075 V AudioTrack: ExtendedTimestamp[1] position: 17280 time: 9647618595007-03 11:32:58.683 741 5075 V AudioTrack: ExtendedTimestamp[2] position: 0 time: -107-03 11:32:58.683 741 5075 V AudioTrack: ExtendedTimestamp[3] position: 0 time: -107-03 11:32:58.683 741 5075 V AudioTrack: ExtendedTimestamp[4] position: 0 time: -107-03 11:32:58.683 741 5075 V AudioSink: getPlayedOutDurationUs(370130) nowUs(96536315) frames(14880) framesAt(96476185)07-03 11:32:58.684 741 5075 V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time 0.73 secs07-03 11:32:58.694 725 1131 V AudioFlinger: thread 0xf0208880 type 0 TID 1131 going to sleep07-03 11:32:58.701 741 5075 V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time 0.75 secs07-03 11:32:58.717 741 5075 V NuPlayerRenderer: rendering video at media time 0.41 secs07-03 11:32:58.733 741 5075 V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time 0.77 secs... ï¼ˆä¸‰ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šâ‘£NuPlayeræ’­æ”¾æ¡†æ¶ä¹‹Rendereræºç åˆ†æï¼šéŸ³è§†é¢‘åŒæ­¥æ—¶å¦‚ä½•å®ç°çš„ï¼Ÿandroid ACodec MediaCodec NuPlayer flow - CSDNåšå®¢android MediaCodec ACodec - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Video Systemï¼ˆ4ï¼‰ï¼šAndroid Multimedia - OpenMaxå®ç°åˆ†æ","slug":"Android Video Systemï¼ˆ4ï¼‰ï¼šAndroid Multimedia - OpenMaxå®ç°åˆ†æ","date":"2018-09-05T16:00:00.000Z","updated":"2018-07-06T12:27:52.098Z","comments":true,"path":"2018/09/06/Android Video Systemï¼ˆ4ï¼‰ï¼šAndroid Multimedia - OpenMaxå®ç°åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/09/06/Android Video Systemï¼ˆ4ï¼‰ï¼šAndroid Multimedia - OpenMaxå®ç°åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Copy Windrunnerlihuanï¼ˆOpenMaxåˆ†æï¼‰ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android MediaCodec ACodecã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - android ACodec MediaCodec NuPlayer flowã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) â˜¯ \\hardware\\qcom\\media\\msm8996\\libstagefrighthw QComOMXPlugin.cpp QComOMXMetadata.h QComOMXPlugin.h â˜¯ \\hardware\\qcom\\media\\msm8996\\mm-video-v4l2\\vidc â˜¯ \\hardware\\qcom\\media\\msm8996\\mm-core ï¼ˆä¸€ï¼‰ã€OpenMaxç®€ä»‹ androidä¸­çš„ NuPlayerå°±æ˜¯ç”¨OpenMaxæ¥åš(codec)ç¼–è§£ç çš„ï¼Œæœ¬èŠ‚å°±ä¸»è¦ç§‘æ™®ä¸€ä¸‹OpenMaxå’Œå®ƒåœ¨Androidç³»ç»Ÿä¸­æ‰®æ¼”çš„è§’è‰²ã€‚ 1.1ã€ OpenMaxç³»ç»Ÿçš„ç»“æ„1.1.1ã€OpenMaxæ€»ä½“å±‚æ¬¡ç»“æ„ OpenMaxæ˜¯ä¸€ä¸ªå¤šåª’ä½“åº”ç”¨ç¨‹åºçš„æ¡†æ¶æ ‡å‡†ï¼Œç”±NVIDIAå…¬å¸å’ŒKhronosåœ¨2006å¹´æ¨å‡ºã€‚ OpenMaxæ˜¯æ— æˆæƒè´¹çš„ï¼Œè·¨å¹³å°çš„åº”ç”¨ç¨‹åºæ¥å£APIï¼Œé€šè¿‡ä½¿åª’ä½“åŠ é€Ÿç»„ä»¶èƒ½å¤Ÿåœ¨å¼€å‘ã€é›†æˆå’Œç¼–ç¨‹ç¯èŠ‚ä¸­å®ç°è·¨å¤šæ“ä½œç³»ç»Ÿå’Œå¤„ç†å™¨ç¡¬ä»¶å¹³å°ï¼Œæä¾›å…¨é¢çš„æµåª’ä½“ç¼–è§£ç å™¨å’Œåº”ç”¨ç¨‹åºä¾¿æºåŒ–ã€‚ OpenMaxçš„å®˜æ–¹ç½‘ç«™å¦‚ä¸‹æ‰€ç¤ºï¼š http://www.khronos.org/openmax/OpenMaxå®é™…ä¸Šåˆ†æˆä¸‰ä¸ªå±‚æ¬¡ï¼Œè‡ªä¸Šè€Œä¸‹åˆ†åˆ«æ˜¯ï¼ŒOpenMax DLï¼ˆå¼€å‘å±‚ï¼‰ï¼ŒOpenMax ILï¼ˆé›†æˆå±‚ï¼‰å’ŒOpenMax ALï¼ˆåº”ç”¨å±‚ï¼‰ã€‚ä¸‰ä¸ªå±‚æ¬¡çš„å†…å®¹åˆ†åˆ«å¦‚ä¸‹æ‰€ç¤ºï¼š ç¬¬ä¸€å±‚ï¼šOpenMax DLï¼ˆDevelopment Layerï¼Œå¼€å‘å±‚ï¼‰ OpenMax DLå®šä¹‰äº†ä¸€ä¸ªAPIï¼Œå®ƒæ˜¯éŸ³é¢‘ã€è§†é¢‘å’Œå›¾åƒåŠŸèƒ½çš„é›†åˆã€‚ä¾›åº”å•†èƒ½å¤Ÿåœ¨ä¸€ä¸ªæ–°çš„å¤„ç†å™¨ä¸Šå®ç°å¹¶ä¼˜åŒ–ï¼Œç„¶åç¼–è§£ç ä¾›åº”å•†ä½¿ç”¨å®ƒæ¥ç¼–å†™æ›´å¹¿æ³›çš„ç¼–è§£ç å™¨åŠŸèƒ½ã€‚å®ƒåŒ…æ‹¬éŸ³é¢‘ä¿¡å·çš„å¤„ç†åŠŸèƒ½ï¼Œå¦‚FFTå’Œfilterï¼Œå›¾åƒåŸå§‹å¤„ç†ï¼Œå¦‚é¢œè‰²ç©ºé—´è½¬æ¢ã€è§†é¢‘åŸå§‹å¤„ç†ï¼Œä»¥å®ç°ä¾‹å¦‚MPEG-4ã€H.264ã€MP3ã€AACå’ŒJPEGç­‰ç¼–è§£ç å™¨çš„ä¼˜åŒ–ã€‚ ç¬¬äºŒå±‚ï¼šOpenMax ILï¼ˆIntegration Layerï¼Œé›†æˆå±‚ï¼‰ OpenMax ILä½œä¸ºéŸ³é¢‘ã€è§†é¢‘å’Œå›¾åƒç¼–è§£ç å™¨èƒ½ä¸å¤šåª’ä½“ç¼–è§£ç å™¨äº¤äº’ï¼Œå¹¶ä»¥ç»Ÿä¸€çš„è¡Œä¸ºæ”¯æŒç»„ä»¶ï¼ˆä¾‹å¦‚ï¼Œèµ„æºå’Œçš®è‚¤ï¼‰ã€‚è¿™äº›ç¼–è§£ç å™¨æˆ–è®¸æ˜¯è½¯ç¡¬ä»¶çš„æ··åˆä½“ï¼Œå¯¹ç”¨æˆ·æ˜¯é€æ˜çš„åº•å±‚æ¥å£åº”ç”¨äºåµŒå…¥å¼ã€ç§»åŠ¨è®¾å¤‡ã€‚å®ƒæä¾›äº†åº”ç”¨ç¨‹åºå’Œåª’ä½“æ¡†æ¶ï¼Œé€æ˜çš„ã€‚ç¼–è§£ç å™¨ä¾›åº”å•†å¿…é¡»å†™ç§æœ‰çš„æˆ–è€…å°é—­çš„æ¥å£ï¼Œé›†æˆè¿›ç§»åŠ¨è®¾å¤‡ã€‚ILçš„ä¸»è¦ç›®çš„æ˜¯ä½¿ç”¨ç‰¹å¾é›†åˆä¸ºç¼–è§£ç å™¨æä¾›ä¸€ä¸ªç³»ç»ŸæŠ½è±¡ï¼Œä¸ºè§£å†³å¤šä¸ªä¸åŒåª’ä½“ç³»ç»Ÿä¹‹é—´è½»ä¾¿æ€§çš„é—®é¢˜ã€‚ ç¬¬ä¸‰å±‚ï¼šOpenMax ALï¼ˆAppliction Layerï¼Œåº”ç”¨å±‚ï¼‰ OpenMax AL APIåœ¨åº”ç”¨ç¨‹åºå’Œå¤šåª’ä½“ä¸­é—´ä»¶ä¹‹é—´æä¾›äº†ä¸€ä¸ªæ ‡å‡†åŒ–æ¥å£ï¼Œå¤šåª’ä½“ä¸­é—´ä»¶æä¾›æœåŠ¡ä»¥å®ç°è¢«æœŸå¾…çš„APIåŠŸèƒ½ã€‚ OpenMax APIå°†ä¼šä¸å¤„ç†å™¨ä¸€åŒæä¾›ï¼Œä»¥ä½¿åº“å’Œç¼–è§£ç å™¨å¼€å‘è€…èƒ½å¤Ÿé«˜é€Ÿæœ‰æ•ˆåœ°åˆ©ç”¨æ–°å™¨ä»¶çš„å®Œæ•´åŠ é€Ÿæ½œèƒ½ï¼Œæ— é¡»æ‹…å¿ƒå…¶åº•å±‚çš„ç¡¬ä»¶ç»“æ„ã€‚è¯¥æ ‡å‡†æ˜¯é’ˆå¯¹åµŒå…¥å¼è®¾å¤‡å’Œç§»åŠ¨è®¾å¤‡çš„å¤šåª’ä½“è½¯ä»¶æ¶æ„ã€‚åœ¨æ¶æ„åº•å±‚ä¸Šä¸ºå¤šåª’ä½“çš„ç¼–è§£ç å’Œæ•°æ®å¤„ç†å®šä¹‰äº†ä¸€å¥—ç»Ÿä¸€çš„ç¼–ç¨‹æ¥å£ï¼Œå¯¹å¤šåª’ä½“æ•°æ®çš„å¤„ç†åŠŸèƒ½è¿›è¡Œç³»ç»Ÿçº§æŠ½è±¡ï¼Œä¸ºç”¨æˆ·å±è”½äº†åº•å±‚çš„ç»†èŠ‚ã€‚å› æ­¤ï¼Œå¤šåª’ä½“åº”ç”¨ç¨‹åºå’Œå¤šåª’ä½“æ¡†æ¶é€šè¿‡OpenMax ILå¯ä»¥ä»¥ä¸€ç§ç»Ÿä¸€çš„æ–¹å¼æ¥ä½¿ç”¨ç¼–è§£ç å’Œå…¶ä»–å¤šåª’ä½“æ•°æ®å¤„ç†åŠŸèƒ½ï¼Œå…·æœ‰äº†è·¨è¶Šè½¯ç¡¬ä»¶å¹³å°çš„ç§»æ¤æ€§ã€‚ æ³¨ï¼šåœ¨å®é™…çš„åº”ç”¨ä¸­ï¼ŒOpenMaxçš„ä¸‰ä¸ªå±‚æ¬¡ä¸­ä½¿ç”¨è¾ƒå¤šçš„æ˜¯OpenMax ILé›†æˆå±‚ï¼Œç”±äºæ“ä½œç³»ç»Ÿåˆ°ç¡¬ä»¶çš„å·®å¼‚å’Œå¤šåª’ä½“åº”ç”¨çš„å·®å¼‚ï¼ŒOpenMaxçš„DLå’ŒALå±‚ä½¿ç”¨ç›¸å¯¹è¾ƒå°‘ã€‚ 1.1.2ã€OpenMax ILç®€ä»‹OpenMax IL å¤„åœ¨ä¸­é—´å±‚çš„ä½ç½®ï¼ŒOpenMAX IL ä½œä¸ºéŸ³é¢‘ï¼Œè§†é¢‘å’Œå›¾åƒç¼–è§£ç å™¨ èƒ½ä¸å¤šåª’ä½“ç¼–è§£ç å™¨äº¤äº’ï¼Œå¹¶ä»¥ç»Ÿä¸€çš„è¡Œä¸ºæ”¯æŒç»„ä»¶ï¼ˆä¾‹å¦‚èµ„æºå’Œçš®è‚¤ï¼‰ã€‚è¿™äº›ç¼–è§£ç å™¨æˆ–è®¸æ˜¯è½¯ç¡¬ä»¶çš„æ··åˆä½“ï¼Œå¯¹ç”¨æˆ·æ˜¯ çš„åº•å±‚æ¥å£åº”ç”¨äºåµŒå…¥å¼æˆ– / å’Œç§»åŠ¨è®¾å¤‡ã€‚å®ƒæä¾›äº†åº”ç”¨ç¨‹åºå’Œåª’ä½“æ¡†æ¶ï¼Œ é€æ˜çš„ã€‚æœ¬è´¨ä¸Šä¸å­˜åœ¨è¿™ç§æ ‡å‡†åŒ–çš„æ¥å£ï¼Œç¼–è§£ç å™¨ä¾› åº”å•†å¿…é¡»å†™ç§æœ‰çš„æˆ–è€…å°é—­çš„æ¥å£ï¼Œé›†æˆè¿›ç§»åŠ¨è®¾å¤‡ã€‚ IL çš„ä¸»è¦ç›®çš„ æ˜¯ä½¿ç”¨ç‰¹å¾é›†åˆä¸ºç¼–è§£ç å™¨æä¾›ä¸€ä¸ªç³»ç»ŸæŠ½è±¡ï¼Œä¸ºè§£å†³å¤šä¸ªä¸åŒåª’ä½“ç³»ç»Ÿä¹‹é—´è½»ä¾¿æ€§çš„é—®é¢˜ã€‚ OpenMax IL çš„ç›®çš„å°±æ˜¯ä¸ºç¡¬ä»¶å¹³å°çš„å›¾å½¢åŠéŸ³è§†é¢‘æä¾›ä¸€ä¸ªæŠ½è±¡å±‚ï¼Œå¯ä»¥ä¸ºä¸Šå±‚çš„åº”ç”¨æä¾›ä¸€ä¸ªå¯è·¨å¹³å°çš„æ”¯æ’‘ã€‚è¿™ä¸€ç‚¹å¯¹äºè·¨å¹³å°çš„åª’ä½“åº”ç”¨æ¥è¯´ååˆ†é‡è¦ã€‚æœ¬äººä¹Ÿæ¥è§¦è¿‡å‡ å®¶é«˜æ¸…è§£ç èŠ¯ç‰‡ï¼Œè¿™äº›èŠ¯ç‰‡åº•å±‚çš„éŸ³è§†é¢‘æ¥å£è™½ç„¶åŠŸèƒ½ä¸Šå¤§è‡´ç›¸åŒï¼Œä½†æ˜¯æ¥å£è®¾è®¡åŠç”¨æ³•ä¸Šå„æœ‰ä¸åŒï¼Œè€Œä¸”ç›¸å·®å¾ˆå¤šã€‚ä½ è¦æƒ³è®©è‡ªå·±å¼€å‘çš„åª’ä½“åº”ç”¨å®Œç¾çš„è¿è¡Œåœ¨ä¸åŒçš„ç¡¬ä»¶å‚å•†å¹³å°ä¸Šï¼Œå°±å¾—é€‚åº”ä¸åŒèŠ¯ç‰‡çš„åº•å±‚è§£ç æ¥å£ã€‚è¿™ä¸ªå¯¹äºåº”ç”¨å¼€å‘æ¥è¯´ååˆ†ç¹çã€‚æ‰€ä»¥å°±éœ€è¦ç±»ä¼¼äºOpenMax IL è¿™ç§æ¥å£è§„èŒƒã€‚åº”ç”¨å‡å¦‚æ¶‰åŠåˆ°éŸ³è§†é¢‘ç›¸å…³åŠŸèƒ½æ—¶ï¼Œåªéœ€è°ƒç”¨è¿™äº›æ ‡å‡†çš„æ¥å£ï¼Œè€Œä¸éœ€è¦å…³å¿ƒæ¥å£ä¸‹æ–¹ç¡¬ä»¶ç›¸å…³çš„å®ç°ã€‚å‡å¦‚æ¢äº†ç¡¬ä»¶å¹³å°æ—¶ï¼Œåªéœ€è¦æŠŠæ¥å£å±‚ä¸ç¡¬ä»¶é€‚é…å¥½äº†å°±è¡Œäº†ã€‚ä¸Šå±‚åº”ç”¨ä¸éœ€è¦é¢‘ç¹æ”¹åŠ¨ã€‚ ä½ å¯ä»¥æŠŠOpenMax IL çœ‹ä½œæ˜¯ä¸­é—´ä»¶ä¸­çš„portingå±‚æ¥å£ï¼Œä½†æ˜¯ç°åœ¨ä¸­é—´ä»¶å¤§éƒ¨åˆ†éƒ½æ˜¯è‡ªå®¶å®šä¹‰è‡ªå·±çš„ã€‚ OpenMax æƒ³åšçš„å°±æ˜¯å®šä¹‰ä¸€ä¸ªè¿™æ ·çš„è¡Œä¸šæ ‡å‡†ï¼Œè¿™æ ·åª’ä½“åº”ç”¨ã€ç¡¬ä»¶å‚å•†éƒ½éµå¾ªè¿™ç§æ ‡å‡†ã€‚ç¡¬ä»¶å‚å•†å°†OpenMax ä¸å¤„ç†å™¨ä¸€å¹¶æä¾›ï¼Œä¸Šå±‚çš„å¤šåª’ä½“æ¡†æ¶æƒ³è¦ç”¨åˆ°ç¡¬ä»¶éŸ³è§†é¢‘åŠ é€ŸåŠŸèƒ½æ—¶ï¼Œåªéœ€éµå¾ªopenmaxçš„æ¥å£å°±å¯ä»¥æ‰©å¹³å°è¿è¡Œã€‚ å¯å–œçš„ï¼Œç°åœ¨è¶Šæ¥è¶Šå¤šçš„å¤šåª’ä½“æ¡†æ¶åŠå¤šåª’ä½“åº”ç”¨æ­£åœ¨éµå¾ªopenmaxæ ‡å‡†ï¼ŒåŒ…æ‹¬å„ç§çŸ¥åçš„åª’ä½“å¼€æºè½¯ä»¶ã€‚è¶Šæ¥è¶Šå¤šçš„èŠ¯ç‰‡å‚å•†ä¹Ÿåœ¨éµå¾ªopenmaxçš„æ ‡å‡†ã€‚å¯¹äºç°åœ¨çš„éŸ³è§†é¢‘ç¼–è§£ç æ¥è¯´ï¼Œåˆ†è¾¨ç‡è¶Šæ¥è¶Šé«˜ï¼Œéœ€è¦èŠ¯ç‰‡æä¾›ç¡¬ä»¶åŠ é€ŸåŠŸèƒ½æ˜¯ä¸ªå¤§çš„è¶‹åŠ¿ã€‚æˆ‘ç›¸ä¿¡ æ¥å£çš„æ ‡å‡†åŒ–æ˜¯ä¸€å®šè¦èµ°çš„ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œ openmax ILåœ¨å¤šåª’ä½“æ¡†æ¶ä¸­çš„åº”ç”¨ï¼š OpenMax ILç›®å‰å·²ç»æˆä¸ºäº†äº‹å®ä¸Šçš„å¤šåª’ä½“æ¡†æ¶æ ‡å‡†ã€‚åµŒå…¥å¼å¤„ç†å™¨æˆ–è€…å¤šåª’ä½“ç¼–è§£ç æ¨¡å—çš„ç¡¬ä»¶ç”Ÿäº§è€…ï¼Œé€šå¸¸æä¾›æ ‡å‡†çš„OpenMax ILå±‚çš„è½¯ä»¶æ¥å£ï¼Œè¿™æ ·è½¯ä»¶çš„å¼€å‘è€…å°±å¯ä»¥åŸºäºè¿™ä¸ªå±‚æ¬¡çš„æ ‡å‡†åŒ–æ¥å£è¿›è¡Œå¤šåª’ä½“ç¨‹åºçš„å¼€å‘ã€‚ OpenMax ILçš„æ¥å£å±‚æ¬¡ç»“æ„é€‚ä¸­ï¼Œæ—¢ä¸æ˜¯ç¡¬ä»¶ç¼–è§£ç çš„æ¥å£ï¼Œä¹Ÿä¸æ˜¯åº”ç”¨ç¨‹åºå±‚çš„æ¥å£ï¼Œå› æ­¤æ¯”è¾ƒå®¹æ˜“å®ç°æ ‡å‡†åŒ–ã€‚OpenMax ILçš„å±‚æ¬¡ç»“æ„å¦‚ä¸‹ï¼š å›¾ä¸­çš„è™šçº¿ä¸­çš„å†…å®¹æ˜¯OpenMax ILå±‚çš„å†…å®¹ï¼Œå…¶ä¸»è¦å®ç°äº†OpenMax ILä¸­çš„å„ä¸ªç»„ä»¶ï¼ˆComponentï¼‰ã€‚å¯¹ä¸‹å±‚ï¼ŒOpenMax ILå¯ä»¥è°ƒç”¨OpenMax DLå±‚çš„æ¥å£ï¼Œä¹Ÿå¯ä»¥ç›´æ¥è°ƒç”¨å„ç§Codecå®ç°ã€‚å¯¹ä¸Šå±‚ï¼ŒOpenMax ILå¯ä»¥ç»™OpenMax AL å±‚ç­‰æ¡†æ¶å±‚ï¼ˆMiddlewareï¼‰è°ƒç”¨ï¼Œä¹Ÿå¯ä»¥ç»™åº”ç”¨ç¨‹åºç›´æ¥è°ƒç”¨ã€‚ 1.1.3ã€OpenMax ILç»“æ„OpenMax ILä¸»è¦å†…å®¹å¦‚ä¸‹æ‰€ç¤ºã€‚ â˜¯ å®¢æˆ·ç«¯ï¼ˆClientï¼‰ï¼šOpenMax ILçš„è°ƒç”¨è€…â˜¯ ç»„ä»¶ï¼ˆComponentï¼‰ï¼šOpenMax ILçš„å•å…ƒï¼Œæ¯ä¸€ä¸ªç»„ä»¶å®ç°ä¸€ç§åŠŸèƒ½â˜¯ ç«¯å£ï¼ˆPortï¼‰ï¼šç»„ä»¶çš„è¾“å…¥è¾“å‡ºæ¥å£â˜¯ éš§é“åŒ–ï¼ˆTunneledï¼‰ï¼šè®©ä¸¤ä¸ªç»„ä»¶ç›´æ¥è¿æ¥çš„æ–¹å¼ OpenMax ILçš„åŸºæœ¬è¿ä½œè¿‡ç¨‹å¦‚å›¾æ‰€ç¤ºï¼š OpenMAL ILçš„å®¢æˆ·ç«¯ï¼Œé€šè¿‡è°ƒç”¨å››ä¸ªOpenMAL ILç»„ä»¶ï¼Œå®ç°äº†ä¸€ä¸ªåŠŸèƒ½ã€‚å››ä¸ªç»„ä»¶åˆ†åˆ«æ˜¯Sourceç»„ä»¶ã€Hostç»„ä»¶ã€Acceleratorç»„ä»¶å’ŒSinkç»„ä»¶ã€‚Sourceç»„ä»¶åªæœ‰ä¸€ä¸ªè¾“å‡ºç«¯å£ï¼›è€ŒHostç»„ä»¶æœ‰ä¸€ä¸ªè¾“å…¥ç«¯å£å’Œä¸€ä¸ªè¾“å‡ºç«¯å£ï¼›Acceleratorç»„ä»¶å…·æœ‰ä¸€ä¸ªè¾“å…¥ç«¯å£ï¼Œè°ƒç”¨äº†ç¡¬ä»¶çš„ç¼–è§£ç å™¨ï¼ŒåŠ é€Ÿä¸»è¦ä½“ç°åœ¨è¿™ä¸ªç¯èŠ‚ä¸Šã€‚Acceleratorç»„ä»¶å’ŒSinkç»„ä»¶é€šè¿‡ç§æœ‰é€šè®¯æ–¹å¼åœ¨å†…éƒ¨è¿›è¡Œè¿æ¥ï¼Œæ²¡æœ‰ç»è¿‡æ˜ç¡®çš„ç»„ä»¶ç«¯å£ã€‚ OpenMAL ILåœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œå…¶æ•°æ®æµä¹Ÿæœ‰ä¸åŒçš„å¤„ç†æ–¹å¼ï¼šæ—¢å¯ä»¥ç»ç”±å®¢æˆ·ç«¯ï¼Œä¹Ÿå¯ä»¥ä¸ç»ç”±å®¢æˆ·ç«¯ã€‚å›¾ä¸­Sourceç»„ä»¶åˆ°Hostç»„ä»¶çš„æ•°æ®æµå°±æ˜¯ç»è¿‡å®¢æˆ·ç«¯çš„ï¼›è€ŒHostç»„ä»¶åˆ°Acceleratorç»„ä»¶çš„æ•°æ®æµå°±æ²¡æœ‰ç»è¿‡å®¢æˆ·ç«¯ï¼Œä½¿ç”¨äº†éš§é“åŒ–çš„æ–¹å¼ï¼›Acceleratorç»„ä»¶å’ŒSinkç»„ä»¶ç”šè‡³å¯ä»¥ä½¿ç”¨ç§æœ‰çš„é€šè®¯æ–¹å¼ã€‚ OpenMax Coreæ˜¯è¾…åŠ©å„ä¸ªç»„ä»¶è¿è¡Œçš„éƒ¨åˆ†ï¼Œå®ƒé€šå¸¸éœ€è¦å®Œæˆå„ä¸ªç»„ä»¶çš„åˆå§‹åŒ–ç­‰å·¥ä½œï¼Œåœ¨çœŸæ­£è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œé‡ç‚¹æ˜¯å„ä¸ªOpenMax ILçš„ç»„ä»¶ï¼ŒOpenMax Coreä¸æ˜¯é‡ç‚¹ï¼Œä¹Ÿä¸æ˜¯æ ‡å‡†ã€‚ OpenMAL ILçš„ç»„ä»¶æ˜¯OpenMax ILå®ç°çš„æ ¸å¿ƒå†…å®¹ï¼Œä¸€ä¸ªç»„ä»¶ä»¥è¾“å…¥ã€è¾“å‡ºç«¯å£ä¸ºæ¥å£ï¼Œç«¯å£å¯ä»¥è¢«è¿æ¥åˆ°å¦ä¸€ä¸ªç»„ä»¶ä¸Šã€‚å¤–éƒ¨å¯¹ç»„ä»¶å¯ä»¥å‘é€å‘½ä»¤ï¼Œè¿˜è¿›è¡Œè®¾ç½®/è·å–å‚æ•°ã€é…ç½®ç­‰å†…å®¹ã€‚ç»„ä»¶çš„ç«¯å£å¯ä»¥åŒ…å«ç¼“å†²åŒºï¼ˆBufferï¼‰çš„é˜Ÿåˆ—ã€‚ ç»„ä»¶çš„å¤„ç†çš„æ ¸å¿ƒå†…å®¹æ˜¯ï¼šé€šè¿‡è¾“å…¥ç«¯å£æ¶ˆè€—Bufferï¼Œé€šè¿‡è¾“å‡ºç«¯å£å¡«å……Bufferï¼Œç”±æ­¤å¤šç»„ä»¶ç›¸è”æ¥å¯ä»¥æ„æˆæµå¼çš„å¤„ç†ã€‚OpenMAL ILä¸­ä¸€ä¸ªç»„ä»¶çš„ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ç»„ä»¶çš„åŠŸèƒ½å’Œå…¶å®šä¹‰çš„ç«¯å£ç±»å‹å¯†åˆ‡ç›¸å…³ï¼Œé€šå¸¸æƒ…å†µä¸‹ï¼šåªæœ‰ä¸€ä¸ªè¾“å‡ºç«¯å£çš„ï¼Œä¸ºSourceç»„ä»¶ï¼›åªæœ‰ä¸€ä¸ªè¾“å…¥ç«¯å£çš„ï¼Œä¸ºSinkç»„ä»¶ï¼›æœ‰å¤šä¸ªè¾“å…¥ç«¯å£ï¼Œä¸€ä¸ªè¾“å‡ºç«¯å£çš„ä¸ºMuxç»„ä»¶ï¼›æœ‰ä¸€ä¸ªè¾“å…¥ç«¯å£ï¼Œå¤šä¸ªè¾“å‡ºç«¯å£çš„ä¸ºDeMuxç»„ä»¶ï¼›è¾“å…¥è¾“å‡ºç«¯å£å„ä¸€ä¸ªç»„ä»¶çš„ä¸ºä¸­é—´å¤„ç†ç¯èŠ‚ï¼Œè¿™æ˜¯æœ€å¸¸è§çš„ç»„ä»¶ã€‚ ç«¯å£å…·ä½“æ”¯æŒçš„æ•°æ®ä¹Ÿæœ‰ä¸åŒçš„ç±»å‹ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªè¾“å…¥ã€è¾“å‡ºç«¯å£å„ä¸€ä¸ªç»„ä»¶ï¼Œå…¶è¾“å…¥ç«¯å£ä½¿ç”¨MP3æ ¼å¼çš„æ•°æ®ï¼Œè¾“å‡ºç«¯å£ä½¿ç”¨PCMæ ¼å¼çš„æ•°æ®ï¼Œé‚£ä¹ˆè¿™ä¸ªç»„ä»¶å°±æ˜¯ä¸€ä¸ªMP3è§£ç ç»„ä»¶ã€‚ éš§é“åŒ–ï¼ˆTunneledï¼‰æ˜¯ä¸€ä¸ªå…³äºç»„ä»¶è¿æ¥æ–¹å¼çš„æ¦‚å¿µã€‚é€šè¿‡éš§é“åŒ–å¯ä»¥å°†ä¸åŒçš„ç»„ä»¶çš„ä¸€ä¸ªè¾“å…¥ç«¯å£å’Œä¸€ä¸ªè¾“å‡ºç«¯å£è¿æ¥åˆ°ä¸€èµ·ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªç»„ä»¶çš„å¤„ç†è¿‡ç¨‹åˆå¹¶ï¼Œå…±åŒå¤„ç†ã€‚å°¤å…¶å¯¹äºå•è¾“å…¥å’Œå•è¾“å‡ºçš„ç»„ä»¶ï¼Œä¸¤ä¸ªç»„ä»¶å°†ä½œä¸ºç±»ä¼¼ä¸€ä¸ªä½¿ç”¨ã€‚ 1.2ã€Androidä¸­çš„OpenMax1.2.1ã€OpenMaxåœ¨Androidä¸­çš„ä½¿ç”¨æƒ…å†µ åœ¨Androidä¸­ï¼ŒOpenMax ILå±‚ï¼Œé€šå¸¸å¯ä»¥ç”¨äºå¤šåª’ä½“å¼•æ“çš„æ’ä»¶ï¼ŒAndroidçš„å¤šåª’ä½“å¼•æ“OpenCoreå’ŒStageFrightéƒ½å¯ä»¥ä½¿ç”¨OpenMaxä½œä¸ºæ’ä»¶ï¼Œä¸»è¦ç”¨äºç¼–è§£ç ï¼ˆCodecï¼‰å¤„ç†ã€‚ åœ¨Androidçš„æ¡†æ¶å±‚ï¼Œä¹Ÿå®šä¹‰äº†ç”±Androidå°è£…çš„OpenMaxæ¥å£ï¼Œå’Œæ ‡å‡†çš„æ¥å£æ¦‚å¿µåŸºæœ¬ç›¸åŒï¼Œä½†æ˜¯ä½¿ç”¨C++ç±»å‹çš„æ¥å£ï¼Œå¹¶ä¸”ä½¿ç”¨äº†Androidçš„Binder IPCæœºåˆ¶ã€‚Androidå°è£…OpenMaxçš„æ¥å£è¢«StageFrightä½¿ç”¨ï¼ŒOpenCoreæ²¡æœ‰ä½¿ç”¨è¿™ä¸ªæ¥å£ï¼Œè€Œæ˜¯ä½¿ç”¨å…¶ä»–å½¢å¼å¯¹OpenMax ILå±‚æ¥å£è¿›è¡Œå°è£…ã€‚Android OpenMaxçš„åŸºæœ¬å±‚æ¬¡ç»“æ„å¦‚å›¾ï¼š Androidç³»ç»Ÿçš„ä¸€äº›éƒ¨åˆ†å¯¹OpenMax ILå±‚è¿›è¡Œä½¿ç”¨ï¼ŒåŸºæœ¬ä½¿ç”¨çš„æ˜¯æ ‡å‡†OpenMax ILå±‚çš„æ¥å£ï¼Œåªæ˜¯è¿›è¡Œäº†ç®€å•çš„å°è£…ã€‚æ ‡å‡†çš„OpenMax ILå®ç°å¾ˆå®¹æ˜“ä»¥æ’ä»¶çš„å½¢å¼åŠ å…¥åˆ°Androidç³»ç»Ÿä¸­ã€‚ Androidçš„å¤šåª’ä½“å¼•æ“OpenCoreå’ŒStageFrightéƒ½å¯ä»¥ä½¿ç”¨OpenMaxä½œä¸ºå¤šåª’ä½“ç¼–è§£ç çš„æ’ä»¶ï¼Œåªæ˜¯æ²¡æœ‰ç›´æ¥ä½¿ç”¨OpenMax ILå±‚æä¾›çš„çº¯Cæ¥å£ï¼Œè€Œæ˜¯å¯¹å…¶è¿›è¡Œäº†ä¸€å®šçš„å°è£…(C++å°è£…)ã€‚ åœ¨Android2.xç‰ˆæœ¬ä¹‹åï¼ŒAndroidçš„æ¡†æ¶å±‚ä¹Ÿå¯¹OpenMax ILå±‚çš„æ¥å£è¿›è¡Œäº†å°è£…å®šä¹‰ï¼Œç”šè‡³ä½¿ç”¨Androidä¸­çš„Binder IPCæœºåˆ¶ã€‚Stagefrightä½¿ç”¨äº†è¿™ä¸ªå±‚æ¬¡çš„æ¥å£ï¼ŒOpenCoreæ²¡æœ‰ä½¿ç”¨ã€‚ æ³¨ï¼šOpenCoreä½¿ç”¨OpenMax ILå±‚ä½œä¸ºç¼–è§£ç æ’ä»¶åœ¨å‰ï¼ŒAndroidæ¡†æ¶å±‚å°è£…OpenMaxæ¥å£åœ¨åé¢çš„ç‰ˆæœ¬ä¸­æ‰å¼•å…¥ã€‚ 1.2.2ã€Android OpenMaxå®ç°çš„å†…å®¹ androidä¸­çš„ AwesomePlayerå°±æ˜¯ç”¨openmaxæ¥åš(Codec)ç¼–è§£ç ,å…¶å®åœ¨openmaxæ¥å£è®¾è®¡ä¸­ï¼Œä»–ä¸å…‰èƒ½ç”¨æ¥å½“ç¼–è§£ç ã€‚é€šè¿‡ä»–çš„ç»„ä»¶å¯ä»¥ç»„æˆä¸€ä¸ªå®Œæ•´çš„æ’­æ”¾å™¨ï¼ŒåŒ…æ‹¬sourcã€demuxã€decodeã€outputã€‚ä½†æ˜¯ä¸ºä»€ä¹ˆandroidåªç”¨ä»–æ¥åšcodeå‘¢ï¼Ÿåº”è¯¥æœ‰å¦‚ä¸‹æ–¹é¢ï¼š â˜¯ 1.åœ¨æ•´ä¸ªæ’­æ”¾å™¨ä¸­ï¼Œè§£ç å™¨ä¸å¾—ä¸è¯´æ˜¯æœ€é‡è¦çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸”ä¹Ÿæ˜¯æœ€è€—èµ„æºçš„ä¸€å—ã€‚å¦‚æœå…¨é è½¯è§£ï¼Œç›´æ¥é€šè¿‡cpuæ¥è¿ç®—ï¼Œç‰¹åˆ«æ˜¯é«˜æ¸…è§†é¢‘ã€‚åˆ«çš„äº‹ä½ å°±å¯ä»¥å•¥éƒ½ä¸å¹²äº†ã€‚æ‰€ä»¥è§£ç å™¨æ˜¯æœ€éœ€è¦ç¡¬ä»¶æä¾›åŠ é€Ÿçš„éƒ¨åˆ†ã€‚ç°åœ¨çš„é«˜æ¸…è§£ç èŠ¯ç‰‡éƒ½æ˜¯ä¸»èŠ¯ç‰‡+DSPç»“æ„ï¼Œè§£ç çš„å·¥ä½œéƒ½æ˜¯é€šè¿‡DSPæ¥åšï¼Œä¸ä¼šåœ¨è¿‡å¤šçš„å ç”¨ä¸»èŠ¯ç‰‡ã€‚æ‰€æœ‰å°†èŠ¯ç‰‡ä¸­DSPç¡¬ä»¶ç¼–è§£ç çš„èƒ½åŠ›é€šè¿‡openmaxæ ‡å‡†æ¥å£å‘ˆç°å‡ºæ¥ï¼Œæä¾›ä¸Šå±‚æ’­æ”¾å™¨æ¥ç”¨ã€‚æˆ‘è®¤ä¸ºè¿™å—æ˜¯openmaxæœ€é‡è¦çš„æ„ä¹‰ã€‚â˜¯ 2.source ä¸»è¦æ˜¯å’Œåè®®æ‰“äº¤é“ï¼Œdemux åˆ†è§£å®¹å™¨éƒ¨åˆ†ï¼Œå¤§å¤šæ•°çš„å®¹å™¨æ ¼å¼çš„åˆ†è§£æ˜¯ä¸éœ€è¦é€šè¿‡ç¡¬ä»¶æ¥æ”¯æŒã€‚åªæ˜¯tsæµè¿™ç§æ ¼å¼æœ€å¯èƒ½ç”¨åˆ°ç¡¬ä»¶çš„æ”¯æŒã€‚å› ä¸ºtsæ ¼å¼æ¯”è¾ƒç‰¹æ®Šï¼Œå•åŒ…çš„å¤§å°å¤ªå°äº†ï¼Œåªæœ‰188å­—èŠ‚ã€‚æ‰€ä»¥ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆç°åœ¨å¸¸è§çš„è§£ç èŠ¯ç‰‡éƒ½ä¼šæä¾›ç¡¬ä»¶ts demux çš„æ”¯æŒã€‚â˜¯ 3.éŸ³è§†é¢‘è¾“å‡ºéƒ¨åˆ†video\\audio output è¿™å—å’Œæ“ä½œç³»ç»Ÿå…³ç³»ååˆ†ç´§å¯†ã€‚å¯ä»¥çœ‹çœ‹è‘—åå¼€æºæ’­æ”¾å™¨vlcã€‚vlc åœ¨macã€linuxã€Windowséƒ½æœ‰ï¼ŒåŠŸèƒ½ä¸Šå·®åˆ«ä¹Ÿä¸å¤§ã€‚æ‰€ä»¥è¯´ä»–æ˜¯è·¨å¹³å°çš„ï¼Œä»–è·¨å¹³å°è·¨åœ¨å“ªï¼Ÿä¸»è¦çš„å·¥ä½œé‡è¿˜æ˜¯åœ¨éŸ³è§†é¢‘è§£ç å®Œä¹‹åçš„è¾“å‡ºæ¨¡å—ã€‚å› ä¸ºå„ä¸ªç³»ç»Ÿçš„å›¾åƒæ¸²æŸ“å’ŒéŸ³é¢‘è¾“å‡ºå®ç°æ–¹æ³•ä¸åŒï¼Œæ‰€ä»¥vlcéœ€è¦é’ˆå¯¹æ¯ä¸ªå¹³å°å®ç°ä¸åŒçš„outputã€‚è¿™éƒ¨åˆ†å†…å®¹æ”¾åœ¨openmaxæ¥æ˜¾ç„¶ä¸åˆé€‚ã€‚ Androidä¸­ä½¿ç”¨çš„ä¸»è¦æ˜¯OpenMaxçš„ç¼–è§£ç åŠŸèƒ½ã€‚è™½ç„¶OpenMaxä¹Ÿå¯ä»¥ç”Ÿæˆè¾“å…¥ã€è¾“å‡ºã€æ–‡ä»¶è§£æ-æ„å»ºç­‰ç»„ä»¶ï¼Œä½†æ˜¯åœ¨å„ä¸ªç³»ç»Ÿï¼ˆä¸ä»…æ˜¯Androidï¼‰ä¸­ä½¿ç”¨çš„æœ€å¤šçš„è¿˜æ˜¯ç¼–è§£ç ç»„ä»¶ã€‚åª’ä½“çš„è¾“å…¥ã€è¾“å‡ºç¯èŠ‚å’Œç³»ç»Ÿçš„å…³ç³»å¾ˆå¤§ï¼Œå¼•å…¥OpenMaxæ ‡å‡†æ¯”è¾ƒéº»çƒ¦ï¼›æ–‡ä»¶è§£æ-æ„å»ºç¯èŠ‚ä¸€èˆ¬ä¸éœ€è¦ä½¿ç”¨ç¡¬ä»¶åŠ é€Ÿã€‚ç¼–è§£ç ç»„ä»¶ä¹Ÿæ˜¯æœ€èƒ½ä½“ç°ç¡¬ä»¶åŠ é€Ÿçš„ç¯èŠ‚ï¼Œå› æ­¤æœ€å¸¸ä½¿ç”¨ã€‚ 1.3ã€åˆçª¥é€‚é…å±‚æ¥å£åœ¨Androidä¸­å®ç°OpenMax ILå±‚å’Œæ ‡å‡†çš„OpenMax ILå±‚çš„æ–¹å¼åŸºæœ¬ï¼Œä¸€èˆ¬éœ€è¦å®ç°ä»¥ä¸‹ä¸¤ä¸ªç¯èŠ‚ï¼š â˜¯ ç¼–è§£ç é©±åŠ¨ç¨‹åºï¼šä½äºLinuxå†…æ ¸ç©ºé—´ï¼Œéœ€è¦é€šè¿‡Linuxå†…æ ¸è°ƒç”¨é©±åŠ¨ç¨‹åºï¼Œé€šå¸¸ä½¿ç”¨éæ ‡å‡†çš„é©±åŠ¨ç¨‹åºã€‚â˜¯ OpenMax ILå±‚ï¼šæ ¹æ®OpenMax ILå±‚çš„æ ‡å‡†å¤´æ–‡ä»¶å®ç°ä¸åŒåŠŸèƒ½çš„ç»„ä»¶ã€‚ Androidä¸­è¿˜æä¾›äº†OpenMaxçš„é€‚é…å±‚æ¥å£ï¼ˆå¯¹OpenMax ILçš„æ ‡å‡†ç»„ä»¶è¿›è¡Œå°è£…é€‚é…ï¼‰ï¼Œå®ƒä½œä¸ºAndroidæœ¬åœ°å±‚çš„æ¥å£ï¼Œå¯ä»¥è¢«Androidçš„å¤šåª’ä½“å¼•æ“è°ƒç”¨ã€‚ä¸Šä¸€ç¯‡æ–‡ç« æœ«å°¾ï¼Œåˆå§‹åŒ–è§£ç å™¨æ ¸å¿ƒè°ƒç”¨çš„ä¸¤ä¸ªæ–¹æ³•å°±æ˜¯é€‚é…å±‚çš„æ¥å£ã€‚ â˜¯ 1.ä¸Šé¢å·²ç»è¯´è¿‡äº†ï¼Œandroidç³»ç»Ÿä¸­åªç”¨openmaxæ¥åšCodecï¼Œæ‰€ä»¥androidå‘ä¸ŠæŠ½è±¡äº†ä¸€å±‚OMXCodecï¼Œæä¾›ç»™ä¸Šå±‚æ’­æ”¾å™¨ç”¨ã€‚æ’­æ”¾å™¨ä¸­éŸ³è§†é¢‘è§£ç å™¨mVideosourceã€mAudiosourceéƒ½æ˜¯OMXCodecçš„å®ä¾‹ã€‚â˜¯ 2.OMXCodecé€šè¿‡IOMX ä¾èµ–binderæœºåˆ¶ è·å¾— OMXæœåŠ¡ï¼ŒOMXæœåŠ¡ æ‰æ˜¯openmax åœ¨androidä¸­ å®ç°ã€‚â˜¯ 3.OMXæŠŠè½¯ç¼–è§£ç å’Œç¡¬ä»¶ç¼–è§£ç ç»Ÿä¸€çœ‹ä½œæ’ä»¶çš„å½¢å¼ç®¡ç†èµ·æ¥ã€‚ ï¼ˆäºŒï¼‰ã€Androidä¸­OpenMaxçš„å®ç°(preview)2.1ã€OpenMaxçš„æ¥å£ä¸å®ç°åœ¨Androidä¸­å®ç°OpenMax ILå±‚å’Œæ ‡å‡†çš„OpenMax ILå±‚çš„æ–¹å¼åŸºæœ¬ï¼Œä¸€èˆ¬éœ€è¦å®ç°ä»¥ä¸‹ä¸¤ä¸ªç¯èŠ‚ã€‚ ç¼–è§£ç é©±åŠ¨ç¨‹åºï¼šä½äºLinuxå†…æ ¸ç©ºé—´ï¼Œéœ€è¦é€šè¿‡Linuxå†…æ ¸è°ƒç”¨é©±åŠ¨ç¨‹åºï¼Œé€šå¸¸ä½¿ç”¨éæ ‡å‡†çš„é©±åŠ¨ç¨‹åºã€‚OpenMax ILå±‚ï¼šæ ¹æ®OpenMax ILå±‚çš„æ ‡å‡†å¤´æ–‡ä»¶å®ç°ä¸åŒåŠŸèƒ½çš„ç»„ä»¶ã€‚ Androidä¸­è¿˜æä¾›äº†OpenMaxçš„é€‚é…å±‚æ¥å£ï¼ˆå¯¹OpenMax ILçš„æ ‡å‡†ç»„ä»¶è¿›è¡Œå°è£…é€‚é…ï¼‰ï¼Œå®ƒä½œä¸ºAndroidæœ¬åœ°å±‚çš„æ¥å£ï¼Œå¯ä»¥è¢«Androidçš„å¤šåª’ä½“å¼•æ“è°ƒç”¨ã€‚ OpenMax ILå±‚æ¥å£ OpenMax ILå±‚çš„æ¥å£å®šä¹‰ç”±è‹¥å¹²ä¸ªå¤´æ–‡ä»¶ç»„æˆï¼Œè¿™ä¹Ÿæ˜¯å®ç°å®ƒéœ€è¦å®ç°çš„å†…å®¹ï¼Œä½äºframeworks/native/include/media/openmaxä¸‹ï¼Œå®ƒä»¬çš„åŸºæœ¬æè¿°å¦‚ä¸‹æ‰€ç¤ºï¼š OMX_Types.hï¼šOpenMax Ilçš„æ•°æ®ç±»å‹å®šä¹‰OMX_Core.hï¼šOpenMax ILæ ¸å¿ƒçš„APIOMX_Component.hï¼šOpenMax IL ç»„ä»¶ç›¸å…³çš„ APIOMX_Audio.hï¼šéŸ³é¢‘ç›¸å…³çš„å¸¸é‡å’Œæ•°æ®ç»“æ„OMX_IVCommon.hï¼šå›¾åƒå’Œè§†é¢‘å…¬å…±çš„å¸¸é‡å’Œæ•°æ®ç»“æ„OMX_Image.hï¼šå›¾åƒç›¸å…³çš„å¸¸é‡å’Œæ•°æ®ç»“æ„OMX_Video.hï¼šè§†é¢‘ç›¸å…³çš„å¸¸é‡å’Œæ•°æ®ç»“æ„OMX_Other.hï¼šå…¶ä»–æ•°æ®ç»“æ„ï¼ˆåŒ…æ‹¬A/V åŒæ­¥ï¼‰OMX_Index.hï¼šOpenMax ILå®šä¹‰çš„æ•°æ®ç»“æ„ç´¢å¼•OMX_ContentPipe.hï¼šå†…å®¹çš„ç®¡é“å®šä¹‰ æç¤ºï¼šOpenMaxæ ‡å‡†åªæœ‰å¤´æ–‡ä»¶ï¼Œæ²¡æœ‰æ ‡å‡†çš„åº“ï¼Œè®¾ç½®æ²¡æœ‰å®šä¹‰å‡½æ•°æ¥å£ã€‚å¯¹äºå®ç°è€…ï¼Œéœ€è¦å®ç°çš„ä¸»è¦æ˜¯åŒ…å«å‡½æ•°æŒ‡é’ˆçš„ç»“æ„ä½“ã€‚ å…¶ä¸­ï¼ŒOMX_Component.hä¸­å®šä¹‰çš„OMX_COMPONENTTYPEç»“æ„ä½“æ˜¯OpenMax ILå±‚çš„æ ¸å¿ƒå†…å®¹ï¼Œè¡¨ç¤ºä¸€ä¸ªç»„ä»¶ï¼Œå…¶å†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990[-&gt;frameworks/native/include/media/openmax/OMX_Component.h]typedef struct OMX_COMPONENTTYPE &#123; OMX_U32 nSize; /* è¿™ä¸ªç»“æ„ä½“çš„å¤§å° */ OMX_VERSIONTYPE nVersion; /* ç‰ˆæœ¬å· */ OMX_PTR pComponentPrivate; /* è¿™ä¸ªç»„ä»¶çš„ç§æœ‰æ•°æ®æŒ‡é’ˆ. */ /* è°ƒç”¨è€…ï¼ˆIL clientï¼‰è®¾ç½®çš„æŒ‡é’ˆï¼Œç”¨äºä¿å­˜å®ƒçš„ç§æœ‰æ•°æ®ï¼Œä¼ å›ç»™æ‰€æœ‰çš„å›è°ƒå‡½æ•° */ OMX_PTR pApplicationPrivate; /* ä»¥ä¸‹çš„å‡½æ•°æŒ‡é’ˆè¿”å›OMX_core.hä¸­çš„å¯¹åº”å†…å®¹ */ OMX_ERRORTYPE (*GetComponentVersion)(/* è·å¾—ç»„ä»¶çš„ç‰ˆæœ¬*/ OMX_IN OMX_HANDLETYPE hComponent, OMX_OUT OMX_STRING pComponentName, OMX_OUT OMX_VERSIONTYPE* pComponentVersion, OMX_OUT OMX_VERSIONTYPE* pSpecVersion, OMX_OUT OMX_UUIDTYPE* pComponentUUID); OMX_ERRORTYPE (*SendCommand)(/* å‘é€å‘½ä»¤ */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_COMMANDTYPE Cmd, OMX_IN OMX_U32 nParam1, OMX_IN OMX_PTR pCmdData); OMX_ERRORTYPE (*GetParameter)(/* è·å¾—å‚æ•° */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_INDEXTYPE nParamIndex, OMX_INOUT OMX_PTR pComponentParameterStructure); OMX_ERRORTYPE (*SetParameter)(/* è®¾ç½®å‚æ•° */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_INDEXTYPE nIndex, OMX_IN OMX_PTR pComponentParameterStructure); OMX_ERRORTYPE (*GetConfig)(/* è·å¾—é…ç½® */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_INDEXTYPE nIndex, OMX_INOUT OMX_PTR pComponentConfigStructure); OMX_ERRORTYPE (*SetConfig)(/* è®¾ç½®é…ç½® */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_INDEXTYPE nIndex, OMX_IN OMX_PTR pComponentConfigStructure); OMX_ERRORTYPE (*GetExtensionIndex)(/* è½¬æ¢æˆOMXç»“æ„çš„ç´¢å¼• */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_STRING cParameterName, OMX_OUT OMX_INDEXTYPE* pIndexType); OMX_ERRORTYPE (*GetState)(/* è·å¾—ç»„ä»¶å½“å‰çš„çŠ¶æ€ */ OMX_IN OMX_HANDLETYPE hComponent, OMX_OUT OMX_STATETYPE* pState); OMX_ERRORTYPE (*ComponentTunnelRequest)(/* ç”¨äºè¿æ¥åˆ°å¦ä¸€ä¸ªç»„ä»¶*/ OMX_IN OMX_HANDLETYPE hComp, OMX_IN OMX_U32 nPort, OMX_IN OMX_HANDLETYPE hTunneledComp, OMX_IN OMX_U32 nTunneledPort, OMX_INOUT OMX_TUNNELSETUPTYPE* pTunnelSetup); OMX_ERRORTYPE (*UseBuffer)(/* ä¸ºæŸä¸ªç«¯å£ä½¿ç”¨Buffer */ OMX_IN OMX_HANDLETYPE hComponent, OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_IN OMX_U32 nPortIndex, OMX_IN OMX_PTR pAppPrivate, OMX_IN OMX_U32 nSizeBytes, OMX_IN OMX_U8* pBuffer); OMX_ERRORTYPE (*AllocateBuffer)(/* åœ¨æŸä¸ªç«¯å£åˆ†é…Buffer */ OMX_IN OMX_HANDLETYPE hComponent, OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer, OMX_IN OMX_U32 nPortIndex, OMX_IN OMX_PTR pAppPrivate, OMX_IN OMX_U32 nSizeBytes); OMX_ERRORTYPE (*FreeBuffer)(/*å°†æŸä¸ªç«¯å£Bufferé‡Šæ”¾*/ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_U32 nPortIndex, OMX_IN OMX_BUFFERHEADERTYPE* pBuffer); OMX_ERRORTYPE (*EmptyThisBuffer)(/* è®©ç»„ä»¶æ¶ˆè€—è¿™ä¸ªBuffer */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_BUFFERHEADERTYPE* pBuffer); OMX_ERRORTYPE (*FillThisBuffer)(/* è®©ç»„ä»¶å¡«å……è¿™ä¸ªBuffer */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_BUFFERHEADERTYPE* pBuffer); OMX_ERRORTYPE (*SetCallbacks)(/* è®¾ç½®å›è°ƒå‡½æ•° */ OMX_IN OMX_HANDLETYPE hComponent, OMX_IN OMX_CALLBACKTYPE* pCallbacks, OMX_IN OMX_PTR pAppData); OMX_ERRORTYPE (*ComponentDeInit)(/* ååˆå§‹åŒ–ç»„ä»¶ */ OMX_IN OMX_HANDLETYPE hComponent); OMX_ERRORTYPE (*UseEGLImage)( OMX_IN OMX_HANDLETYPE hComponent, OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr, OMX_IN OMX_U32 nPortIndex, OMX_IN OMX_PTR pAppPrivate, OMX_IN void* eglImage); OMX_ERRORTYPE (*ComponentRoleEnum)( OMX_IN OMX_HANDLETYPE hComponent, OMX_OUT OMX_U8 *cRole, OMX_IN OMX_U32 nIndex); &#125; OMX_COMPONENTTYPE; â˜¯ 1ï¼‰EmptyThisBufferå’ŒFillThisBufferæ˜¯é©±åŠ¨ç»„ä»¶è¿è¡Œçš„åŸºæœ¬çš„æœºåˆ¶ï¼Œå‰è€…è¡¨ç¤ºè®©ç»„ä»¶æ¶ˆè€—ç¼“å†²åŒºï¼Œè¡¨ç¤ºå¯¹åº”ç»„ä»¶è¾“å…¥çš„å†…å®¹ï¼›åè€…è¡¨ç¤ºè®©ç»„ä»¶å¡«å……ç¼“å†²åŒºï¼Œè¡¨ç¤ºå¯¹åº”ç»„ä»¶è¾“å‡ºçš„å†…å®¹ã€‚â˜¯ 2ï¼‰UseBufferï¼ŒAllocateBufferï¼ŒFreeBufferä¸ºå’Œç«¯å£ç›¸å…³çš„ç¼“å†²åŒºç®¡ç†å‡½æ•°ï¼Œå¯¹äºç»„ä»¶çš„ç«¯å£æœ‰äº›å¯ä»¥è‡ªå·±åˆ†é…ç¼“å†²åŒºï¼Œæœ‰äº›å¯ä»¥ä½¿ç”¨å¤–éƒ¨çš„ç¼“å†²åŒºï¼Œå› æ­¤æœ‰ä¸åŒçš„æ¥å£å¯¹å…¶è¿›è¡Œæ“ä½œã€‚â˜¯ 3ï¼‰SendCommandè¡¨ç¤ºå‘ç»„ä»¶å‘é€æ§åˆ¶ç±»çš„å‘½ä»¤ã€‚GetParameterï¼ŒSetParameterï¼ŒGetConfigï¼ŒSetConfigå‡ ä¸ªæ¥å£ç”¨äºè¾…åŠ©çš„å‚æ•°å’Œé…ç½®çš„è®¾ç½®å’Œè·å–ã€‚â˜¯ 4ï¼‰ComponentTunnelRequestç”¨äºç»„ä»¶ä¹‹é—´çš„éš§é“åŒ–è¿æ¥ï¼Œå…¶ä¸­éœ€è¦åˆ¶å®šä¸¤ä¸ªç»„ä»¶åŠå…¶ç›¸è¿çš„ç«¯å£ã€‚â˜¯ 5ï¼‰ComponentDeInitç”¨äºç»„ä»¶çš„ååˆå§‹åŒ–ã€‚ OMX_COMPONENTTYPEç»“æ„ä½“å®ç°åï¼Œå…¶ä¸­çš„å„ä¸ªå‡½æ•°æŒ‡é’ˆå°±æ˜¯è°ƒç”¨è€…å¯ä»¥ä½¿ç”¨çš„å†…å®¹ã€‚å„ä¸ªå‡½æ•°æŒ‡é’ˆå’ŒOMX_core.hä¸­å®šä¹‰çš„å†…å®¹ç›¸å¯¹åº”ã€‚ æç¤ºï¼šOpenMaxå‡½æ•°çš„å‚æ•°ä¸­ï¼Œç»å¸¸åŒ…å«OMX_INå’ŒOMX_OUTç­‰å®ï¼Œå®ƒä»¬çš„å®é™…å†…å®¹ä¸ºç©ºï¼Œåªæ˜¯ä¸ºäº†æ ‡è®°å‚æ•°çš„æ–¹å‘æ˜¯è¾“å…¥è¿˜æ˜¯è¾“å‡ºã€‚ OMX_Component.hä¸­ç«¯å£ç±»å‹çš„å®šä¹‰ä¸ºOMX_PORTDOMAINTYPEæšä¸¾ç±»å‹ï¼Œå†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789typedef enum OMX_PORTDOMAINTYPE &#123; OMX_PortDomainAudio, /* éŸ³é¢‘ç±»å‹ç«¯å£ */ OMX_PortDomainVideo, /* è§†é¢‘ç±»å‹ç«¯å£ */ OMX_PortDomainImage, /* å›¾åƒç±»å‹ç«¯å£ */ OMX_PortDomainOther, /* å…¶ä»–ç±»å‹ç«¯å£ */ OMX_PortDomainKhronosExtensions = 0x6F000000, //ä¸ºKhronosæ ‡å‡†é¢„ç•™å®½å±• OMX_PortDomainVendorStartUnused = 0x7F000000 //ä¸ºå‚å•†é¢„ç•™æ‰©å±• OMX_PortDomainMax = 0x7ffffff &#125; OMX_PORTDOMAINTY éŸ³é¢‘ç±»å‹ï¼Œè§†é¢‘ç±»å‹ï¼Œå›¾åƒç±»å‹ï¼Œå…¶ä»–ç±»å‹æ˜¯OpenMax ILå±‚æ­¤æ‰€å®šä¹‰çš„å››ç§ç«¯å£çš„ç±»å‹ã€‚ ç«¯å£å…·ä½“å†…å®¹çš„å®šä¹‰ä½¿ç”¨OMX_PARAM_PORTDEFINITIONTYPEç±»ï¼ˆä¹Ÿåœ¨OMX_Component.hä¸­å®šä¹‰ï¼‰æ¥è¡¨ç¤ºï¼Œå…¶å†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920typedef struct OMX_PARAM_PORTDEFINITIONTYPE &#123; OMX_U32 nSize; /* ç»“æ„ä½“å¤§å° */ OMX_VERSIONTYPE nVersion; /* ç‰ˆæœ¬*/ OMX_U32 nPortIndex; /* ç«¯å£å· */ OMX_DIRTYPE eDir; /* ç«¯å£çš„æ–¹å‘ */ OMX_U32 nBufferCountActual; /* ä¸ºè¿™ä¸ªç«¯å£å®é™…åˆ†é…çš„Bufferçš„æ•°ç›® */ OMX_U32 nBufferCountMin; /* è¿™ä¸ªç«¯å£æœ€å°Bufferçš„æ•°ç›®*/ OMX_U32 nBufferSize; /* ç¼“å†²åŒºçš„å­—èŠ‚æ•° */ OMX_BOOL bEnabled; /* æ˜¯å¦ä½¿èƒ½ */ OMX_BOOL bPopulated; /* æ˜¯å¦åœ¨å¡«å…… */ OMX_PORTDOMAINTYPE eDomain; /* ç«¯å£çš„ç±»å‹ */ union &#123; /* ç«¯å£å®é™…çš„å†…å®¹ï¼Œç”±ç±»å‹ç¡®å®šå…·ä½“ç»“æ„ */ OMX_AUDIO_PORTDEFINITIONTYPE audio; OMX_VIDEO_PORTDEFINITIONTYPE video; OMX_IMAGE_PORTDEFINITIONTYPE image; OMX_OTHER_PORTDEFINITIONTYPE other; &#125; format; OMX_BOOL bBuffersContiguous; OMX_U32 nBufferAlignment; &#125; OMX_PARAM_PORTDEFINITIONTYPE; å¯¹äºä¸€ä¸ªç«¯å£ï¼Œå…¶é‡ç‚¹çš„å†…å®¹å¦‚ä¸‹: â˜¯ ç«¯å£çš„æ–¹å‘ï¼ˆOMX_DIRTYPEï¼‰ï¼šåŒ…å«OMX_DirInputï¼ˆè¾“å…¥ï¼‰å’ŒOMX_DirOutputï¼ˆè¾“å‡ºï¼‰ä¸¤ç§â˜¯ ç«¯å£åˆ†é…çš„ç¼“å†²åŒºæ•°ç›®å’Œæœ€å°ç¼“å†²åŒºæ•°ç›®â˜¯ ç«¯å£çš„ç±»å‹ï¼ˆOMX_PORTDOMAINTYPEï¼‰ï¼šå¯ä»¥æ˜¯å››ç§ç±»å‹â˜¯ ç«¯å£æ ¼å¼çš„æ•°æ®ç»“æ„ï¼šä½¿ç”¨formatè”åˆä½“æ¥è¡¨ç¤ºï¼Œå…·ä½“ç”±å››ç§ä¸åŒç±»å‹æ¥è¡¨ç¤ºï¼Œä¸ç«¯å£çš„ç±»å‹ç›¸å¯¹åº”â˜¯ OMX_AUDIO_PORTDEFINITIONTYPEï¼ŒOMX_VIDEO_PORTDEFINITIONTYPEï¼ŒOMX_IMAGE_PORTDEFINITIONTYPEå’ŒOMX_OTHER_PORTDEFINITIONTYPEç­‰å‡ ä¸ªå…·ä½“çš„æ ¼å¼ç±»å‹ï¼Œåˆ†åˆ«åœ¨OMX_Audio.hï¼ŒOMX_Video.hï¼ŒOMX_Image.hå’ŒOMX_Other.hè¿™å››ä¸ªå¤´æ–‡ä»¶ä¸­å®šä¹‰ã€‚ OMX_Core.hä¸­å®šä¹‰çš„æšä¸¾ç±»å‹OMX_STATETYPEå‘½ä»¤è¡¨ç¤ºOpenMaxçš„çŠ¶æ€æœºï¼Œå†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112typedef enum OMX_STATETYPE &#123; OMX_StateInvalid, /* ç»„ä»¶ç›‘æµ‹åˆ°å†…éƒ¨çš„æ•°æ®ç»“æ„è¢«ç ´å */ OMX_StateLoaded, /* ç»„ä»¶è¢«åŠ è½½ä½†æ˜¯æ²¡æœ‰å®Œæˆåˆå§‹åŒ– */ OMX_StateIdle, /* ç»„ä»¶åˆå§‹åŒ–å®Œæˆï¼Œå‡†å¤‡å¼€å§‹ */ OMX_StateExecuting, /* ç»„ä»¶æ¥å—äº†å¼€å§‹å‘½ä»¤ï¼Œæ­£åœ¨æ ‘ç«‹æ•°æ® */ OMX_StatePause, /* ç»„ä»¶æ¥å—æš‚åœå‘½ä»¤*/ OMX_StateWaitForResources, /* ç»„ä»¶æ­£åœ¨ç­‰å¾…èµ„æº */ OMX_StateKhronosExtensions = 0x6F000000, /* ä¿ç•™for Khronos */ OMX_StateVendorStartUnused = 0x7F000000, /* ä¿ç•™forå‚å•† */ OMX_StateMax = 0X7FFFFFFF &#125; OMX_STATETYPE; OpenMaxç»„ä»¶çš„çŠ¶æ€æœºå¯ä»¥ç”±å¤–éƒ¨çš„å‘½ä»¤æ”¹å˜ï¼Œä¹Ÿå¯ä»¥ç”±å†…éƒ¨å‘ç”Ÿçš„æƒ…å†µæ”¹å˜ã€‚OpenMax ILç»„ä»¶çš„çŠ¶æ€æœºçš„è¿ç§»å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼š OMX_Core.hä¸­å®šä¹‰çš„æšä¸¾ç±»å‹OMX_COMMANDTYPEè¡¨ç¤ºå¯¹ç»„ä»¶çš„å‘½ä»¤ç±»å‹ï¼Œå†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011typedef enum OMX_COMMANDTYPE &#123; OMX_CommandStateSet, /* æ”¹å˜çŠ¶æ€æœºå™¨ */ OMX_CommandFlush, /* åˆ·æ–°æ•°æ®é˜Ÿåˆ— */ OMX_CommandPortDisable, /* ç¦æ­¢ç«¯å£ */ OMX_CommandPortEnable, /* ä½¿èƒ½ç«¯å£ */ OMX_CommandMarkBuffer, /* æ ‡è®°ç»„ä»¶æˆ–Bufferç”¨äºè§‚å¯Ÿ */ OMX_CommandKhronosExtensions = 0x6F000000, /* ä¿ç•™for Khronos */ OMX_CommandVendorStartUnused = 0x7F000000, /* ä¿ç•™forå‚å•† */ OMX_CommandMax = 0X7FFFFFFF &#125; OMX_COMMANDTYPE; OMX_COMMANDTYPEç±»å‹åœ¨SendCommandè°ƒç”¨ä¸­ä½œä¸ºå‚æ•°è¢«ä½¿ç”¨ï¼Œå…¶ä¸­OMX_CommandStateSetå°±æ˜¯æ”¹å˜çŠ¶æ€æœºçš„å‘½ä»¤ã€‚ 2.1.2ã€OpenMax ILå®ç°çš„å†…å®¹ å¯¹äºOpenMax ILå±‚çš„å®ç°ï¼Œä¸€èˆ¬çš„æ–¹å¼å¹¶ä¸è°ƒç”¨OpenMax DLå±‚ã€‚å…·ä½“å®ç°çš„å†…å®¹å°±æ˜¯å„ä¸ªä¸åŒçš„ç»„ä»¶ã€‚ OpenMax ILç»„ä»¶çš„å®ç°åŒ…å«ä»¥ä¸‹ä¸¤ä¸ªæ­¥éª¤ï¼š â˜¯ ç»„ä»¶çš„åˆå§‹åŒ–å‡½æ•°ï¼šç¡¬ä»¶å’ŒOpenMaxæ•°æ®ç»“æ„çš„åˆå§‹åŒ–ï¼Œä¸€èˆ¬åˆ†æˆå‡½æ•°æŒ‡é’ˆåˆå§‹åŒ–ã€ç§æœ‰æ•°æ®ç»“æ„çš„åˆå§‹åŒ–ã€ç«¯å£çš„åˆå§‹åŒ–ç­‰å‡ ä¸ªæ­¥éª¤ï¼Œä½¿ç”¨OMX_Component.hå…¶ä¸­çš„pComponentPrivateæˆå‘˜ä¿ç•™æœ¬ç»„ä»¶çš„ç§æœ‰æ•°æ®ä¸ºä¸Šä¸‹æ–‡ï¼Œæœ€åè·å¾—å¡«å……å®ŒæˆOMX_COMPONENTTYPEç±»å‹çš„ç»“æ„ä½“ã€‚â˜¯ OMX_COMPONENTTYPEç±»å‹ç»“æ„ä½“çš„å„ä¸ªæŒ‡é’ˆï¼šå®ç°å…¶ä¸­çš„å„ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œéœ€è¦ä½¿ç”¨ç§æœ‰æ•°æ®çš„æ—¶å€™ï¼Œä»å…¶ä¸­çš„pComponentPrivateå¾—åˆ°æŒ‡é’ˆï¼Œè½¬åŒ–æˆå®é™…çš„æ•°æ®ç»“æ„ä½¿ç”¨ã€‚ ç«¯å£çš„å®šä¹‰æ˜¯OpenMax ILç»„ä»¶å¯¹å¤–éƒ¨çš„æ¥å£ã€‚OpenMax ILå¸¸ç”¨çš„ç»„ä»¶å¤§éƒ½æ˜¯è¾“å…¥å’Œè¾“å‡ºç«¯å£å„ä¸€ä¸ªã€‚å¯¹äºæœ€å¸¸ç”¨çš„ç¼–è§£ç ï¼ˆCodecï¼‰ç»„ä»¶ï¼Œé€šå¸¸éœ€è¦åœ¨æ¯ä¸ªç»„ä»¶çš„å®ç°è¿‡ç¨‹ä¸­ï¼Œè°ƒç”¨ç¡¬ä»¶çš„ç¼–è§£ç æ¥å£æ¥å®ç°ã€‚åœ¨ç»„ä»¶çš„å†…éƒ¨å¤„ç†ä¸­ï¼Œå¯ä»¥å»ºç«‹çº¿ç¨‹æ¥å¤„ç†ã€‚OpenMaxçš„ç»„ä»¶çš„ç«¯å£æœ‰é»˜è®¤å‚æ•°ï¼Œä½†ä¹Ÿå¯ä»¥åœ¨è¿è¡Œæ—¶è®¾ç½®ï¼Œå› æ­¤ä¸€ä¸ªç«¯å£ä¹Ÿå¯ä»¥æ”¯æŒä¸åŒçš„ç¼–ç æ ¼å¼ã€‚éŸ³é¢‘ç¼–ç ç»„ä»¶çš„è¾“å‡ºå’ŒéŸ³é¢‘ç¼–ç ç»„ä»¶çš„è¾“å…¥é€šå¸¸æ˜¯åŸå§‹æ•°æ®æ ¼å¼ï¼ˆPCMæ ¼å¼ï¼‰ï¼Œè§†é¢‘ç¼–ç ç»„ä»¶çš„è¾“å‡ºå’Œè§†é¢‘ç¼–ç ç»„ä»¶çš„è¾“å…¥é€šå¸¸æ˜¯åŸå§‹æ•°æ®æ ¼å¼ï¼ˆYUVæ ¼å¼ï¼‰ã€‚ æç¤ºï¼šåœ¨ä¸€ç§ç‰¹å®šçš„ç¡¬ä»¶å®ç°ä¸­ï¼Œç¼–è§£ç éƒ¨åˆ†å…·æœ‰ç›¸ä¼¼æ€§ï¼Œå› æ­¤é€šå¸¸å¯ä»¥æ„å»ºä¸€ä¸ªOpenMaxç»„ä»¶çš„â€åŸºç±»â€æˆ–è€…å…¬å…±å‡½æ•°ï¼Œæ¥å®Œæˆå…¬å…±æ€§çš„æ“ä½œã€‚ 2.2ã€Androidä¸­OpenMaxçš„é€‚é…å±‚ Androidä¸­çš„OpenMaxé€‚é…å±‚çš„æ¥å£åœ¨frameworks/av/include/media/IOMX.hæ–‡ä»¶å®šä¹‰ï¼Œå…¶å†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class IOMX : public IInterface &#123; public: DECLARE_META_INTERFACE(OMX); typedef void *buffer_id; typedef void *node_id; virtual bool livesLocally(pid_t pid) = 0; struct ComponentInfo &#123;// ç»„ä»¶çš„ä¿¡æ¯ String8 mName; List&lt;String8&gt; mRoles; &#125;; virtual status_t listNodes(List&lt;ComponentInfo&gt; *list) = 0; // èŠ‚ç‚¹åˆ—è¡¨ virtual status_t allocateNode( const char *name, const sp&lt;IOMXObserver&gt; &amp;observer, // åˆ†é…èŠ‚ç‚¹ node_id *node) = 0; virtual status_t freeNode(node_id node) = 0; // æ‰¾åˆ°èŠ‚ç‚¹ virtual status_t sendCommand(// å‘é€å‘½ä»¤ node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param) = 0; virtual status_t getParameter(// è·å¾—å‚æ•° node_id node, OMX_INDEXTYPE index, void *params, size_t size) = 0; virtual status_t setParameter(// è®¾ç½®å‚æ•° node_id node, OMX_INDEXTYPE index, const void *params, size_t size) = 0; virtual status_t getConfig(// è·å¾—é…ç½® node_id node, OMX_INDEXTYPE index, void *params, size_t size) = 0; virtual status_t setConfig(// è®¾ç½®é…ç½® node_id node, OMX_INDEXTYPE index, const void *params, size_t size) = 0; virtual status_t useBuffer(// ä½¿ç”¨ç¼“å†²åŒº node_id node, OMX_U32 port_index, const sp&lt;IMemory&gt; Â¶ms, buffer_id *buffer) = 0; virtual status_t allocateBuffer(// åˆ†é…ç¼“å†²åŒº node_id node, OMX_U32 port_index, size_t size, buffer_id *buffer, void **buffer_data) = 0; virtual status_t allocateBufferWithBackup(// åˆ†é…å¸¦åå¤‡ç¼“å†²åŒº node_id node, OMX_U32 port_index, const sp&lt;IMemory&gt; Â¶ms, buffer_id *buffer) = 0; virtual status_t freeBuffer(// é‡Šæ”¾ç¼“å†²åŒº node_id node, OMX_U32 port_index, buffer_id buffer) = 0; virtual status_t fillBuffer(node_id node, buffer_id buffer) = 0; // å¡«å……ç¼“å†²åŒº virtual status_t emptyBuffer(// æ¶ˆè€—ç¼“å†²åŒº node_id node, buffer_id buffer, OMX_U32 range_offset, OMX_U32 range_length, OMX_U32 flags, OMX_TICKS timestamp) = 0; virtual status_t getExtensionIndex( node_id node, const char *parameter_name, OMX_INDEXTYPE *index) = 0; virtual sp&lt;IOMXRenderer&gt; createRenderer(// åˆ›å»ºæ¸²æŸ“å™¨ï¼ˆä»ISurfaceï¼‰ const sp&lt;ISurface&gt; &amp;surface, const char *componentName, OMX_COLOR_FORMATTYPE colorFormat, size_t encodedWidth, size_t encodedHeight, size_t displayWidth, size_t displayHeight) = 0; ...... &#125;; IOMXè¡¨ç¤ºçš„æ˜¯OpenMaxçš„ä¸€ä¸ªç»„ä»¶ï¼Œæ ¹æ®Androidçš„Binder IPCæœºåˆ¶ï¼ŒBnOMXç»§æ‰¿IOMXï¼Œå®ç°è€…éœ€è¦ç»§æ‰¿å®ç°BnOMXã€‚IOMXç±»ä¸­ï¼Œæœ‰æ ‡å‡†çš„OpenMaxçš„GetParameterï¼ŒSetParameterï¼ŒGetConfigï¼ŒSetConfigï¼ŒSendCommandï¼ŒUseBufferï¼ŒAllocateBufferï¼ŒFreeBufferï¼ŒFillThisBufferå’ŒEmptyThisBufferç­‰æ¥å£ã€‚ åœ¨IOMX.hæ–‡ä»¶ä¸­ï¼Œå¦æœ‰è¡¨ç¤ºè§‚å¯Ÿå™¨ç±»çš„IOMXObserverï¼Œè¿™ä¸ªç±»è¡¨ç¤ºOpenMaxçš„è§‚å¯Ÿè€…ï¼Œå…¶ä¸­åªåŒ…å«ä¸€ä¸ªonMessage()å‡½æ•°ï¼Œå…¶å‚æ•°ä¸ºomx_messageæ¥å£ä½“ï¼Œå…¶ä¸­åŒ…å«Eventäº‹ä»¶ç±»å‹ã€FillThisBufferå®Œæˆå’ŒEmptyThisBufferå®Œæˆå‡ ç§ç±»å‹ã€‚ æç¤ºï¼šAndroidä¸­OpenMaxçš„é€‚é…å±‚æ˜¯OpenMAX ILå±‚è‡³ä¸Šçš„å°è£…å±‚ï¼Œåœ¨Androidç³»ç»Ÿä¸­è¢«StageFrightè°ƒç”¨ï¼Œä¹Ÿå¯ä»¥è¢«å…¶ä»–éƒ¨åˆ†è°ƒç”¨ã€‚ 2.3ã€TI(Texas Instruments å¾·å·ä»ªå™¨) OpenMax ILçš„ç¡¬ä»¶å®ç°2.3.1ã€TI OpenMax ILå®ç°çš„ç»“æ„å’Œæœºåˆ¶ Androidçš„å¼€æºä»£ç ä¸­ï¼Œå·²ç»åŒ…å«äº†TIçš„OpenMax ILå±‚çš„å®ç°ä»£ç ï¼Œå…¶è·¯å¾„å¦‚hardware/ti/omap3/omxä¸‹ã€‚å…¶ä¸­åŒ…å«çš„ä¸»è¦ç›®å½•å¦‚ä¸‹æ‰€ç¤ºï¼š â˜¯ systemï¼šOpenMaxæ ¸å¿ƒå’Œå…¬å…±éƒ¨åˆ†â˜¯ audioï¼šéŸ³é¢‘å¤„ç†éƒ¨åˆ†çš„OpenMax ILç»„ä»¶â˜¯ videoï¼šè§†é¢‘å¤„ç†éƒ¨åˆ†OpenMax ILç»„ä»¶â˜¯ imageï¼šå›¾åƒå¤„ç†éƒ¨åˆ†OpenMax ILç»„ä»¶ TI OpenMax ILå®ç°çš„ç»“æ„å¦‚å›¾æ‰€ç¤º: åœ¨TI OpenMax ILå®ç°ä¸­ï¼Œæœ€ä¸Šé¢çš„å†…å®¹æ˜¯OpenMaxçš„ç®¡ç†è€…ç”¨äºç®¡ç†å’Œåˆå§‹åŒ–ï¼Œä¸­é—´å±‚æ˜¯å„ä¸ªç¼–è§£ç å•å…ƒçš„OpenMax ILæ ‡å‡†ç»„ä»¶ï¼Œä¸‹å±‚æ˜¯LCMLå±‚ï¼Œä¾›å„ä¸ªOpenMax ILæ ‡å‡†ç»„ä»¶æ‰€è°ƒç”¨ã€‚ ï¼ˆ1ï¼‰TI OpenMax ILå®ç°çš„å…¬å…±éƒ¨åˆ†åœ¨system/src/openmax_il/ç›®å½•ä¸­ï¼Œä¸»è¦çš„å†…å®¹å¦‚ä¸‹æ‰€ç¤ºã€‚ â˜¯ omx_core/srcï¼šOpenMax ILçš„æ ¸å¿ƒï¼Œç”ŸæˆåŠ¨æ€åº“libOMX_Core.soâ˜¯ lcml/ï¼šLCMLçš„å·¥å…·åº“ï¼Œç”ŸæˆåŠ¨æ€åº“libLCML.so ï¼ˆ2ï¼‰I OpenMax ILçš„è§†é¢‘ï¼ˆVideoï¼‰ç›¸å…³çš„ç»„ä»¶åœ¨video/src/openmax_il/ç›®å½•ä¸­ï¼Œä¸»è¦çš„å†…å®¹å¦‚ä¸‹æ‰€ç¤ºã€‚ â˜¯ prepost_processorï¼šVideoæ•°æ®çš„å‰å¤„ç†å’Œåå¤„ç†ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.VPP.soâ˜¯ video_decodeï¼šVideoè§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.Video.Decoder.soâ˜¯ video_encodeï¼šVideoç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.Video.encoder.so ï¼ˆ3ï¼‰TI OpenMax ILçš„éŸ³é¢‘ï¼ˆAudioï¼‰ç›¸å…³çš„ç»„ä»¶åœ¨audio/src/openmax_il/ç›®å½•ä¸­ï¼Œä¸»è¦çš„å†…å®¹å¦‚ä¸‹æ‰€ç¤ºã€‚ â˜¯ g711_decï¼šG711è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G711.decode.soâ˜¯ g711_encï¼šG711ç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G711.encode.soâ˜¯ g722_decï¼šG722è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G722.decode.soâ˜¯ g722_encï¼šG722ç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G722.encode.soâ˜¯ g726_decï¼šG726è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G726.decode.soâ˜¯ g726_encï¼šG726ç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G726.encode.soâ˜¯ g729_decï¼šG729è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G729.decode.soâ˜¯ g729_encï¼šG720ç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.G729.encode.soâ˜¯ nbamr_decï¼šAMRçª„å¸¦è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.AMR.decode.soâ˜¯ nbamr_encï¼šAMRçª„å¸¦ç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.AMR.encode.soâ˜¯ wbamr_decï¼šAMRå®½å¸¦è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.WBAMR.decode.soâ˜¯ wbamr_encï¼šAMRå®½å¸¦ç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.WBAMR.encode.soâ˜¯ mp3_decï¼šMP3è§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.MP3.decode.soâ˜¯ aac_decï¼šAACè§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.AAC.decode.soâ˜¯ aac_encï¼šAACç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.AAC.encode.soâ˜¯ wma_decï¼šWMAè§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.WMA.decode.so ï¼ˆ4ï¼‰TI OpenMax ILçš„å›¾åƒï¼ˆImageï¼‰ç›¸å…³çš„ç»„ä»¶åœ¨image/src/openmax_il/ç›®å½•ä¸­ï¼Œä¸»è¦çš„å†…å®¹å¦‚ä¸‹æ‰€ç¤ºã€‚ â˜¯ jpeg_encï¼šJPEGç¼–ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.JPEG.Encoder.soâ˜¯ jpeg_decï¼šJPEGè§£ç å™¨ï¼Œç”ŸæˆåŠ¨æ€åº“libOMX.TI.JPEG.decoder.so 2.3.2ã€TI OpenMax ILçš„æ ¸å¿ƒå’Œå…¬å…±å†…å®¹ LCMLçš„å…¨ç§°æ˜¯â€Linux Common Multimedia Layerâ€œï¼Œæ˜¯TIçš„Linuxå…¬å…±å¤šåª’ä½“å±‚ã€‚åœ¨OpenMax ILçš„å®ç°ä¸­ï¼Œè¿™ä¸ªå†…å®¹åœ¨system/src/openmax_il/lcml/ç›®å½•ä¸­ï¼Œä¸»è¦æ–‡ä»¶æ˜¯å­ç›®å½•srcä¸­çš„LCML_DspCodec.cæ–‡ä»¶ã€‚é€šè¿‡è°ƒç”¨DSPBridgeçš„å†…å®¹ï¼Œ è®©ARMå’ŒDSPè¿›è¡Œé€šä¿¡ï¼Œç„¶DSPè¿›è¡Œç¼–è§£ç æ–¹é¢çš„å¤„ç†ã€‚DSPçš„è¿è¡Œè¿˜éœ€è¦å›ºä»¶çš„æ”¯æŒã€‚ TI OpenMax ILçš„æ ¸å¿ƒå®ç°åœ¨system/src/openmax_il/omx_core/ç›®å½•ä¸­ï¼Œç”ŸæˆTI OpenMax ILçš„æ ¸å¿ƒåº“libOMX_Core.soã€‚ å…¶ä¸­å­ç›®å½•srcä¸­çš„OMX_Core.cä¸ºä¸»è¦æ–‡ä»¶ï¼Œå…¶ä¸­å®šä¹‰äº†ç¼–è§£ç å™¨çš„åç§°ç­‰ï¼Œå…¶ç‰‡æ–­å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122char *tComponentName[MAXCOMP][2] = &#123; &#123;\"OMX.TI.JPEG.decoder\", \"image_decoder.jpeg\"&#125;,/* å›¾åƒå’Œè§†é¢‘ç¼–è§£ç å™¨ */ &#123;\"OMX.TI.JPEG.Encoder\", \"image_encoder.jpeg\"&#125;, &#123;\"OMX.TI.Video.Decoder\", \"video_decoder.avc\"&#125;, &#123;\"OMX.TI.Video.Decoder\", \"video_decoder.mpeg4\"&#125;, &#123;\"OMX.TI.Video.Decoder\", \"video_decoder.wmv\"&#125;, &#123;\"OMX.TI.Video.encoder\", \"video_encoder.mpeg4\"&#125;, &#123;\"OMX.TI.Video.encoder\", \"video_encoder.h263\"&#125;, &#123;\"OMX.TI.Video.encoder\", \"video_encoder.avc\"&#125;, /* ......çœç•¥ ï¼Œè¯­éŸ³ç›¸å…³ç»„ä»¶*/ #ifdef BUILD_WITH_TI_AUDIO /* éŸ³é¢‘ç¼–è§£ç å™¨ */ &#123;\"OMX.TI.MP3.decode\", \"audio_decoder.mp3\"&#125;, &#123;\"OMX.TI.AAC.encode\", \"audio_encoder.aac\"&#125;, &#123;\"OMX.TI.AAC.decode\", \"audio_decoder.aac\"&#125;, &#123;\"OMX.TI.WMA.decode\", \"audio_decoder.wma\"&#125;, &#123;\"OMX.TI.WBAMR.decode\", \"audio_decoder.amrwb\"&#125;, &#123;\"OMX.TI.AMR.decode\", \"audio_decoder.amrnb\"&#125;, &#123;\"OMX.TI.AMR.encode\", \"audio_encoder.amrnb\"&#125;, &#123;\"OMX.TI.WBAMR.encode\", \"audio_encoder.amrwb\"&#125;, #endif &#123;NULL, NULL&#125;, &#125;; tComponentNameæ•°ç»„çš„å„ä¸ªé¡¹ä¸­ï¼Œç¬¬ä¸€ä¸ªè¡¨ç¤ºç¼–è§£ç åº“å†…å®¹ï¼Œç¬¬äºŒä¸ªè¡¨ç¤ºåº“æ‰€å®ç°çš„åŠŸèƒ½ã€‚ å…¶ä¸­ï¼ŒTIOMX_GetHandle()å‡½æ•°ç”¨äºè·å¾—å„ä¸ªç»„ä»¶çš„å¥æŸ„ï¼Œå…¶å®ç°çš„ä¸»è¦ç‰‡æ–­å¦‚ä¸‹æ‰€ç¤ºï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647OMX_ERRORTYPE TIOMX_GetHandle( OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName, OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks) &#123; static const char prefix[] = \"lib\"; static const char postfix[] = \".so\"; OMX_ERRORTYPE (*pComponentInit)(OMX_HANDLETYPE*); OMX_ERRORTYPE err = OMX_ErrorNone; OMX_COMPONENTTYPE *componentType; const char* pErr = dlerror(); // ...... çœç•¥é”™è¯¯å¤„ç†å†…å®¹ int i = 0; for(i=0; i&lt; COUNTOF(pModules); i++) &#123; // å¾ªç¯æŸ¥æ‰¾ if(pModules[i] == NULL) break; &#125; // ...... çœç•¥é”™è¯¯å¤„ç†å†…å®¹ int refIndex = 0; for (refIndex=0; refIndex &lt; MAX_TABLE_SIZE; refIndex++) &#123; // å¾ªç¯æŸ¥æ‰¾ç»„ä»¶åˆ—è¡¨ if (strcmp(componentTable[refIndex].name, cComponentName) == 0) &#123; if (componentTable[refIndex].refCount&gt;= MAX_CONCURRENT_INSTANCES) &#123; // ...... çœç•¥é”™è¯¯å¤„ç†å†…å®¹ &#125; else &#123; char buf[sizeof(prefix) + MAXNAMESIZE+ sizeof(postfix)]; strcpy(buf, prefix); strcat(buf, cComponentName); strcat(buf, postfix); pModules[i] = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL); // ...... çœç•¥é”™è¯¯å¤„ç†å†…å®¹ // åŠ¨æ€å–å‡ºåˆå§‹åŒ–çš„ç¬¦å· pComponentInit = dlsym(pModules[i], \"OMX_ComponentInit\"); pErr = dlerror(); // ...... çœç•¥é”™è¯¯å¤„ç†å†…å®¹ *pHandle = malloc(sizeof(OMX_COMPONENTTYPE)); // ...... çœç•¥é”™è¯¯å¤„ç†å†…å®¹ pComponents[i] = *pHandle; componentType = (OMX_COMPONENTTYPE*) *pHandle; componentType-&gt;nSize = sizeof(OMX_COMPONENTTYPE); err = (*pComponentInit)(*pHandle); // æ‰§è¡Œåˆå§‹åŒ–å·¥ä½œ // ...... çœç•¥éƒ¨åˆ†å†…å®¹ &#125; &#125; &#125; err = OMX_ErrorComponentNotFound; goto UNLOCK_MUTEX; // ...... çœç•¥éƒ¨åˆ†å†…å®¹ return (err); &#125; åœ¨TIOMX_GetHandle()å‡½æ•°ä¸­ï¼Œæ ¹æ®tComponentNameæ•°ç»„ä¸­åŠ¨æ€åº“çš„åç§°ï¼ŒåŠ¨æ€æ‰“å¼€å„ä¸ªç¼–è§£ç å®ç°çš„åŠ¨æ€åº“ï¼Œå–å‡ºå…¶ä¸­çš„OMX_ComponentInitç¬¦å·æ¥æ‰§è¡Œå„ä¸ªç»„ä»¶çš„åˆå§‹åŒ–ã€‚ 2.3.3ã€ä¸€ä¸ªTI OpenMax ILç»„ä»¶çš„å®ç° TI OpenMax ILä¸­å„ä¸ªç»„ä»¶éƒ½æ˜¯é€šè¿‡è°ƒç”¨LCMLæ¥å®ç°çš„ï¼Œå®ç°çš„æ–¹å¼åŸºæœ¬ç±»ä¼¼ã€‚ä¸»è¦éƒ½æ˜¯å®ç°äº†åç§°ä¸ºOMX_ComponentInitçš„åˆå§‹åŒ–å‡½æ•°ï¼Œå®ç°OMX_COMPONENTTYPEç±»å‹çš„ç»“æ„ä½“ä¸­çš„å„ä¸ªæˆå‘˜ã€‚å„ä¸ªç»„ä»¶å…¶ç›®å½•ç»“æ„å’Œæ–‡ä»¶ç»“æ„ä¹Ÿç±»ä¼¼ã€‚ ä»¥MP3è§£ç å™¨çš„å®ç°ä¸ºä¾‹ï¼Œåœ¨audio/src/openmax_il/mp3_dec/srcç›®å½•ä¸­ï¼Œä¸»è¦åŒ…å«ä»¥ä¸‹æ–‡ä»¶ï¼š â˜¯ OMX_Mp3Decoder.cï¼šMP3è§£ç å™¨ç»„ä»¶å®ç°â˜¯ OMX_Mp3Dec_CompThread.cï¼šMP3è§£ç å™¨ç»„ä»¶çš„çº¿ç¨‹å¾ªç¯â˜¯ OMX_Mp3Dec_Utils.cï¼šMP3è§£ç å™¨çš„ç›¸å…³å·¥å…·ï¼Œè°ƒç”¨LCMLå®ç°çœŸæ­£çš„MP3è§£ç çš„åŠŸèƒ½ OMX_Mp3Decoder.cä¸­çš„OMX_ComponentInit()å‡½æ•°è´Ÿè´£ç»„ä»¶çš„åˆå§‹åŒ–ï¼Œè¿”å›çš„å†…å®¹å†ä»å‚æ•°ä¸­å¾—åˆ°ï¼Œè¿™ä¸ªå‡½æ•°çš„ä¸»è¦ç‰‡æ–­å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667OMX_ERRORTYPE OMX_ComponentInit (OMX_HANDLETYPE hComp) &#123; OMX_ERRORTYPE eError = OMX_ErrorNone; OMX_COMPONENTTYPE *pHandle = (OMX_COMPONENTTYPE*) hComp; OMX_PARAM_PORTDEFINITIONTYPE *pPortDef_ip = NULL, *pPortDef_op = NULL; OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat = NULL; OMX_AUDIO_PARAM_MP3TYPE *mp3_ip = NULL; OMX_AUDIO_PARAM_PCMMODETYPE *mp3_op = NULL; MP3DEC_COMPONENT_PRIVATE *pComponentPrivate = NULL; MP3D_AUDIODEC_PORT_TYPE *pCompPort = NULL; MP3D_BUFFERLIST *pTemp = NULL; int i=0; MP3D_OMX_CONF_CHECK_CMD(pHandle,1,1); /* ......çœç•¥ï¼Œåˆå§‹åŒ–OMX_COMPONENTTYPEç±»å‹çš„æŒ‡é’ˆpHandle */ OMX_MALLOC_GENERIC(pHandle-&gt;pComponentPrivate, MP3DEC_COMPONENT_PRIVATE); pComponentPrivate = pHandle-&gt;pComponentPrivate; /* ç§æœ‰æŒ‡é’ˆäº’ç›¸æŒ‡å‘ */ pComponentPrivate-&gt;pHandlepHandle = pHandle; /* ......ç•¥ï¼Œåˆå§‹åŒ–ä¼¼æœ‰æ•°æ®æŒ‡é’ˆpComponentPrivate */ /* è®¾ç½®è¾“å…¥ç«¯å£ï¼ˆOMX_PARAM_PORTDEFINITIONTYPEç±»å‹ï¼‰çš„é»˜è®¤å€¼ */ pPortDef_ip-&gt;nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE); pPortDef_ip-&gt;nPortIndex = MP3D_INPUT_PORT; pPortDef_ip-&gt;eDir = OMX_DirInput; pPortDef_ip-&gt;nBufferCountActual = MP3D_NUM_INPUT_BUFFERS; pPortDef_ip-&gt;nBufferCountMin = MP3D_NUM_INPUT_BUFFERS; pPortDef_ip-&gt;nBufferSize = MP3D_INPUT_BUFFER_SIZE; pPortDef_ip-&gt;nBufferAlignment = DSP_CACHE_ALIGNMENT; pPortDef_ip-&gt;bEnabled = OMX_TRUE; pPortDef_ip-&gt;bPopulated = OMX_FALSE; pPortDef_ip-&gt;eDomain = OMX_PortDomainAudio; pPortDef_ip-&gt;format.audio.eEncoding = OMX_AUDIO_CodingMP3; pPortDef_ip-&gt;format.audio.cMIMEType = NULL; pPortDef_ip-&gt;format.audio.pNativeRender = NULL; pPortDef_ip-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE; /* è®¾ç½®è¾“å‡ºç«¯å£ï¼ˆOMX_PARAM_PORTDEFINITIONTYPEç±»å‹ï¼‰çš„é»˜è®¤å€¼ */ pPortDef_op-&gt;nSize = sizeof(OMX_PARAM_PORTDEFINITIONTYPE); pPortDef_op-&gt;nPortIndex = MP3D_OUTPUT_PORT; pPortDef_op-&gt;eDir = OMX_DirOutput; pPortDef_op-&gt;nBufferCountMin = MP3D_NUM_OUTPUT_BUFFERS; pPortDef_op-&gt;nBufferCountActual = MP3D_NUM_OUTPUT_BUFFERS; pPortDef_op-&gt;nBufferSize = MP3D_OUTPUT_BUFFER_SIZE; pPortDef_op-&gt;nBufferAlignment = DSP_CACHE_ALIGNMENT; pPortDef_op-&gt;bEnabled = OMX_TRUE; pPortDef_op-&gt;bPopulated = OMX_FALSE; pPortDef_op-&gt;eDomain = OMX_PortDomainAudio; pPortDef_op-&gt;format.audio.eEncoding = OMX_AUDIO_CodingPCM; pPortDef_op-&gt;format.audio.cMIMEType = NULL; pPortDef_op-&gt;format.audio.pNativeRender = NULL; pPortDef_op-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE; /* ......çœç•¥ï¼Œåˆ†é…ç«¯å£ */ /* è®¾ç½®è¾“å…¥ç«¯å£çš„é»˜è®¤æ ¼å¼ */ pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_INPUT_PORT]-&gt;pPortFormat; OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE); pPortFormat-&gt;nPortIndex = MP3D_INPUT_PORT; pPortFormat-&gt;nIndex = OMX_IndexParamAudioMp3; pPortFormat-&gt;eEncoding = OMX_AUDIO_CodingMP3; /* è®¾ç½®è¾“å‡ºç«¯å£çš„é»˜è®¤æ ¼å¼ */ pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_OUTPUT_PORT]-&gt;pPortFormat; OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE); pPortFormat-&gt;nPortIndex = MP3D_OUTPUT_PORT; pPortFormat-&gt;nIndex = OMX_IndexParamAudioPcm; pPortFormat-&gt;eEncoding = OMX_AUDIO_CodingPCM; /* ......çœç•¥éƒ¨åˆ†å†…å®¹ */ eError = Mp3Dec_StartCompThread(pHandle); // å¯åŠ¨MP3è§£ç çº¿ç¨‹ /* ......çœç•¥éƒ¨åˆ†å†…å®¹ */ return eError; &#125; è¿™ä¸ªç»„ä»¶æ˜¯OpenMaxçš„æ ‡å‡†å®ç°æ–¹å¼ï¼Œå¯¹å¤–çš„æ¥å£çš„å†…å®¹åªæœ‰ä¸€ä¸ªåˆå§‹åŒ–å‡½æ•°ã€‚å®ŒæˆOMX_COMPONENTTYPEç±»å‹çš„åˆå§‹åŒ–ã€‚è¾“å…¥ç«¯å£çš„ç¼–å·ä¸ºMP3D_INPUT_PORTï¼ˆ==0ï¼‰ï¼Œç±»å‹ä¸ºOMX_PortDomainAudioï¼Œæ ¼å¼ä¸ºOMX_AUDIO_CodingMP3ã€‚è¾“å‡ºç«¯å£çš„ç¼–å·æ˜¯MP3D_OUTPUT_PORTï¼ˆ==1ï¼‰ï¼Œç±»å‹ä¸ºOMX_PortDomainAudioï¼Œæ ¼å¼ä¸ºOMXAUDIO CodingPCMã€‚ OMX_Mp3Dec_CompThread.cä¸­å®šä¹‰äº†MP3DEC_ComponentThread()å‡½æ•°ï¼Œç”¨äºåˆ›å»ºMP3è§£ç çš„çº¿ç¨‹çš„æ‰§è¡Œå‡½æ•°ã€‚ OMX_Mp3Dec_Utils.cä¸­çš„Mp3Dec_StartCompThread()å‡½æ•°ï¼Œè°ƒç”¨äº†POSIXçš„çº¿ç¨‹åº“å»ºç«‹MP3è§£ç çš„çº¿ç¨‹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 12nRet = pthread_create (&amp;(pComponentPrivate-&gt;ComponentThread), NULL, MP3DEC_ComponentThread, pComponentPrivate); Mp3Dec_StartCompThread()å‡½æ•°å°±æ˜¯åœ¨ç»„ä»¶åˆå§‹åŒ–å‡½æ•°OMX_ComponentInit()æœ€åè°ƒç”¨çš„å†…å®¹ã€‚MP3çº¿ç¨‹çš„å¼€å§‹å¹¶ä¸è¡¨ç¤ºè§£ç è¿‡ç¨‹å¼€å§‹ï¼Œçº¿ç¨‹éœ€è¦ç­‰å¾…é€šè¿‡pipeæœºåˆ¶è·å¾—å‘½ä»¤å’Œæ•°æ®ï¼ˆcmdPipeå’ŒdataPipeï¼‰ï¼Œåœ¨é€‚å½“çš„æ—¶å€™å¼€å§‹å·¥ä½œã€‚è¿™ä¸ªpipeåœ¨MP3è§£ç ç»„ä»¶çš„SendCommandç­‰å®ç°å†™æ“ä½œï¼Œåœ¨çº¿ç¨‹ä¸­è¯»å–å…¶å†…å®¹ã€‚ 2.4ã€Qualcomm(é«˜é€š) OpenMax ILçš„ç¡¬ä»¶å®ç°2.4.1ã€qcom OpenMax ILå®ç°çš„ç»“æ„å’Œæœºåˆ¶ï¼ˆ1ï¼‰åœ¨AOSPä¸­ä¾ç„¶æœ‰å¯¹é«˜é€šå¹³å°çš„OpenMax ILå±‚å®ç°ä»£ç ï¼Œä½äºhardware/qcom/media/mm-coreä¸‹ã€‚è¿™ä¸€éƒ¨åˆ†æ˜¯OpenMaxæ ¸å¿ƒå’Œå…¬å…±éƒ¨åˆ†ï¼Œä¸»è¦ç¼–è¯‘ä¸ºlibOmxCore.soã€‚ ï¼ˆ2ï¼‰e.g. ç»§ç»­åœ¨hardware/qcom/mediaä¸‹ï¼Œé€‰å–mm-video-v4l2ç›®å½•ã€‚å³Video4linux2ï¼ˆç®€ç§°V4L2),æ˜¯linuxä¸­å…³äºè§†é¢‘è®¾å¤‡çš„å†…æ ¸é©±åŠ¨ã€‚å†æ¬¡è¿›å…¥vidcï¼Œï¼ˆDivxDrmDecryptä¸ºDRMæ•°å­—ç‰ˆæƒç›¸å…³ï¼‰ä¸»è¦ç›®å½•å¦‚ä¸‹ï¼š â˜¯ vdecï¼šè§†é¢‘è§£ç å¤„ç†ï¼Œç¼–è¯‘æˆlibOmxVdec.so/libOmxVdecHevc.soâ˜¯ vencï¼šè§†é¢‘ç¼–ç å¤„ç†ï¼Œç¼–è¯‘æˆlibOmxVenc.soqcom OpenMax ILçš„æ ¸å¿ƒå’Œå…¬å…±å†…å®¹ ç±»ä¼¼äºå‰é¢ä»‹ç»çš„TIï¼Œé«˜é€šå¹³å°åœ¨OpenMax ILå®ç°ä¹Ÿæ˜¯å¤§åŒå°å¼‚ï¼Œä½äºhardware/qcom/media/mm-coreï¼Œç”ŸæˆlibOmxCore.soåº“ã€‚ å…¶ä¸­qc_omx_coreä¸ºä¸»è¦æ–‡ä»¶ï¼Œä½äºhardware/qcom/media/mm-core/omxcore/src/common/ä¸‹é¢ã€‚å’ŒTIçš„å·®ä¸å¤šï¼ŒOMX_GetHandle()å‡½æ•°ç”¨æˆ·è·å–å„ä¸ªç»„ä»¶çš„å¥æŸ„ï¼Œå…¶å®ç°çš„ä¸»è¦ç‰‡æ–­å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//ç¼–è§£ç å™¨ç»„ä»¶é›†åˆæ•°ç»„extern omx_core_cb_type core[]; OMX_API OMX_ERRORTYPE OMX_APIENTRYOMX_GetHandle(OMX_OUT OMX_HANDLETYPE* handle, OMX_IN OMX_STRING componentName, OMX_IN OMX_PTR appData, OMX_IN OMX_CALLBACKTYPE* callBacks)&#123; OMX_ERRORTYPE eRet = OMX_ErrorNone; int cmp_index = -1; int hnd_index = -1; DEBUG_PRINT(\"OMXCORE API : Get Handle %p %s %p\\n\", handle, componentName, appData); pthread_mutex_lock(&amp;lock_core); if(handle) &#123; struct stat sd; //ç»„ä»¶å¥æŸ„ *handle = NULL; //è·å–æ ¹æ®ç»„ä»¶åè·å–ç›¸åº”index cmp_index = get_cmp_index(componentName); if(cmp_index &gt;= 0) &#123; DEBUG_PRINT(\"getting fn pointer\\n\"); // dynamically load the so åŠ¨æ€åŠ è½½ç»„ä»¶çš„soåº“ core[cmp_index].fn_ptr = omx_core_load_cmp_library(core[cmp_index].so_lib_name, &amp;core[cmp_index].so_lib_handle); if(core[cmp_index].fn_ptr) &#123; // Construct the component requested // Function returns the opaque handle //æ ¹æ®è·å–çš„ç»„ä»¶å¥æŸ„åˆå§‹åŒ–å®ƒ void* pThis = (*(core[cmp_index].fn_ptr))(); if(pThis) &#123; //åŒ…è£…ä¸€å±‚ï¼Œå¿½ç•¥ void *hComp = NULL; hComp = qc_omx_create_component_wrapper((OMX_PTR)pThis); if((eRet = qc_omx_component_init(hComp, core[cmp_index].name)) != OMX_ErrorNone) &#123; DEBUG_PRINT(\"Component not created succesfully\\n\"); pthread_mutex_unlock(&amp;lock_core); return eRet; &#125; //è®¾ç½®å›è°ƒ qc_omx_component_set_callbacks(hComp,callBacks,appData); hnd_index = get_comp_handle_index(componentName); if(hnd_index &gt;= 0) &#123; //ä¿å­˜è¿™ä¸ªç»„ä»¶å¥æŸ„ core[cmp_index].inst[hnd_index]= *handle = (OMX_HANDLETYPE) hComp; &#125; else &#123; /*-------ä¸‹é¢å…¨æ˜¯é”™è¯¯å¤„ç†ï¼Œå¿½ç•¥------*/ DEBUG_PRINT(\"OMX_GetHandle:NO free slot available to store Component Handle\\n\"); pthread_mutex_unlock(&amp;lock_core); return OMX_ErrorInsufficientResources; &#125; DEBUG_PRINT(\"Component %p Successfully created\\n\",*handle); &#125; else &#123; eRet = OMX_ErrorInsufficientResources; DEBUG_PRINT(\"Component Creation failed\\n\"); &#125; &#125; else &#123; eRet = OMX_ErrorNotImplemented; DEBUG_PRINT(\"library couldnt return create instance fn\\n\"); &#125; &#125; else &#123; eRet = OMX_ErrorNotImplemented; DEBUG_PRINT(\"ERROR: Already another instance active ;rejecting \\n\"); &#125; &#125; else &#123; eRet = OMX_ErrorBadParameter; DEBUG_PRINT(\"\\n OMX_GetHandle: NULL handle \\n\"); &#125; pthread_mutex_unlock(&amp;lock_core); return eRet;&#125; è¿™é‡Œçš„æœ‰ä¸ªæ•°ç»„ï¼šextern omx_core_cb_type core[]ï¼Œæ˜¯ä»åˆ«çš„æ–‡ä»¶ä¸­å£°æ˜è¿‡æ¥çš„å…¨å±€å˜é‡ï¼Œå…¶ä¸­åŒ…å«äº†å„ç§ç¼–è§£ç å™¨çš„åç§°å’Œä¸€äº›å±æ€§çš„ç»“æ„ä½“ã€‚ç»“æ„ä½“å®šä¹‰ä½äºhardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.hï¼š 123456789typedef struct _omx_core_cb_type&#123; char* name;// Component name ç»„ä»¶å create_qc_omx_component fn_ptr;// create instance fn ptr åˆ›å»ºå®ä¾‹å‡½æ•°æŒ‡é’ˆ void* inst[OMX_COMP_MAX_INST];// Instance handle å®ä¾‹å¥æŸ„ void* so_lib_handle;// So Library handle soåº“å¥æŸ„ char* so_lib_name;// so directory soå char* roles[OMX_CORE_MAX_CMP_ROLES];// roles played ç»„ä»¶æ‰®æ¼”çš„è§’è‰²&#125;omx_core_cb_type; ä½†æ˜¯ç»™omx_core_cb_type core[]è¿™ä¸ªç»“æ„ä½“æ•°ç»„å¤åˆ¶çš„åœ°æ–¹è¦æ ¹æ®ä¸åŒå‹å·è¿›è¡Œé€‰å–ï¼Œæˆ‘ä»¬è¿›å…¥hardware/qcom/media/mm-core/srcä¸‹é¢ï¼Œä¼šçœ‹åˆ°æœ‰è®¸å¤šå‹å·ï¼Œ7627Aã€7630ã€8084ã€8226ã€8610ã€8660ç­‰ç­‰ã€‚æ¯”å¦‚è¿™ä¸ª8974çš„ï¼Œä½äºhardware/qcom/media/mm-core/src/8974/qc_registry_table_android.cä¸­ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162omx_core_cb_type core[] =&#123; //avc/h264è§£ç å™¨ &#123; \"OMX.qcom.video.decoder.avc\", NULL, // Create instance function // Unique instance handle &#123; NULL &#125;, NULL, // Shared object library handle \"libOmxVdec.so\", &#123; \"video_decoder.avc\" &#125; &#125;, //mpeg4è§£ç å™¨&#123; \"OMX.qcom.video.decoder.mpeg4\", NULL, // Create instance function // Unique instance handle &#123; NULL &#125;, NULL, // Shared object library handle \"libOmxVdec.so\", &#123; \"video_decoder.mpeg4\" &#125; &#125;, //wmvè§£ç å™¨ &#123; \"OMX.qcom.video.decoder.wmv\", NULL, // Create instance function // Unique instance handle &#123; NULL &#125;, NULL, // Shared object library handle \"libOmxVdec.so\", &#123; \"video_decoder.vc1\" &#125; &#125;, //hevc/h265ç¼–ç å™¨ &#123; \"OMX.qcom.video.encoder.hevc\", NULL, // Create instance function // Unique instance handle &#123; NULL &#125;, NULL, // Shared object library handle \"libOmxVencHevc.so\", &#123; \"video_encoder.hevc\" &#125; &#125;, ...å¤ªå¤šäº†ï¼Œçœç•¥... &#125; ä¸Šé¢å°±æ˜¯å¯¹ç¼–è§£ç å™¨ç›¸å…³ä¿¡æ¯çš„æ³¨å†Œã€‚ åœ¨OMX_GetHandle()å‡½æ•°ä¸­ï¼Œæ ¹æ®omx_core_cb_type core[]æ•°ç»„ä¸­åŠ¨æ€åº“çš„åç§°ï¼ŒåŠ¨æ€æ‰“å¼€å„ä¸ªç¼–è§£ç å®ç°çš„åŠ¨æ€åº“,ç„¶åè¿›è¡Œåˆå§‹åŒ–ã€‚ 2.4.1ã€ä¸€ä¸ªqcom OpenMax ILç»„ä»¶çš„å®ç° é«˜é€šå¹³å°å¯¹äºç¼–è§£ç ç»„ä»¶çš„å¤„ç†éƒ½æ¯”è¾ƒé›†ä¸­ï¼Œä¸åƒTIé‚£ä¹ˆåˆ†æ•£å’Œç»†è‡´ã€‚ä¸€ä¸ªç»„ä»¶å®ç°éƒ½è¦åŒ…å«Qc_omx_component.hå¤´æ–‡ä»¶ï¼Œä½äºå¾ˆå¤šåœ°æ–¹ï¼Œå¦‚hardware/qcom/media/mm-core/incï¼Œè¦å®ç°é‡Œé¢ç›¸å…³çº¯è™šå‡½æ•°ã€‚å½“ä¸€ä¸ªç»„ä»¶è¢«åˆ›å»ºåè¦åˆå§‹åŒ–ï¼Œå°±è¦å®ç°component_init(OMX_IN OMX_STRING componentName)æ–¹æ³•ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œä¾ç„¶ä»¥Video4linux2å¹³å°ï¼Œè¿›å…¥hardware/qcom/media/mm-video-v4l2/vidc/vdec/srcæŸ¥çœ‹è§†é¢‘è§£ç ç›¸å…³ç»„ä»¶ã€‚æ¯”å¦‚æˆ‘ä»¬çœ‹çœ‹è§£ç ç»„ä»¶omx_vdec_hevc.cppï¼ŒæŸ¥çœ‹component_initæ–¹æ³•ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413#ifdef VENUS_HEVC#define DEVICE_NAME \"/dev/video/venus_dec\"#else#define DEVICE_NAME \"/dev/video/q6_dec\"#endif/* ====================================================================== FUNCTION omx_vdec::ComponentInit DESCRIPTION Initialize the component. PARAMETERS ctxt -- Context information related to the self. id -- Event identifier. This could be any of the following: 1. Command completion event 2. Buffer done callback event 3. Frame done callback event RETURN VALUE None. ========================================================================== */OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)&#123; OMX_ERRORTYPE eRet = OMX_ErrorNone; struct v4l2_fmtdesc fdesc; struct v4l2_format fmt; struct v4l2_requestbuffers bufreq; struct v4l2_control control; unsigned int alignment = 0,buffer_size = 0; int fds[2]; int r,ret=0; bool codec_ambiguous = false; //æ‰“å¼€è®¾å¤‡æ–‡ä»¶\"/dev/video/venus_dec\"æˆ–\"/dev/video/q6_dec\" OMX_STRING device_name = (OMX_STRING)DEVICE_NAME; ...... drv_ctx.video_driver_fd = open(device_name, O_RDWR); ...... //å¦‚æœæ˜¯ä¸€ä¸ªæ‰“å¼€æˆåŠŸåï¼Œä¸ºä»€ä¹ˆè¦å†æ¬¡æ‰“å¼€ï¼Ÿï¼Ÿexcuse me ï¼Ÿ if (drv_ctx.video_driver_fd == 0) &#123; drv_ctx.video_driver_fd = open(device_name, O_RDWR); &#125; //æ‰“å¼€è®¾å¤‡æ–‡ä»¶å¤±è´¥ if (drv_ctx.video_driver_fd &lt; 0) &#123; DEBUG_PRINT_ERROR(\"Omx_vdec::Comp Init Returning failure, errno %d\", errno); return OMX_ErrorInsufficientResources; &#125; drv_ctx.frame_rate.fps_numerator = DEFAULT_FPS;//å¸§ç‡åˆ†å­ drv_ctx.frame_rate.fps_denominator = 1;//å¸§ç‡åˆ†æ¯ //åˆ›å»ºä¸€ä¸ªå¼‚æ­¥çº¿ç¨‹ï¼Œæ‰§è¡Œasync_message_threadå‡½æ•°ï¼Œå¯¹è¾“å…¥ç«¯è¿›è¡Œè®¾ç½® ret = pthread_create(&amp;async_thread_id,0,async_message_thread,this); //åˆ›å»ºçº¿ç¨‹å¤±è´¥ï¼Œåˆ™å…³é—­è®¾å¤‡æ–‡ä»¶ if (ret &lt; 0) &#123; close(drv_ctx.video_driver_fd); DEBUG_PRINT_ERROR(\"Failed to create async_message_thread\"); return OMX_ErrorInsufficientResources; &#125; ...... // Copy the role information which provides the decoder kind //å°†ç»„å»ºè§’è‰²åå­—copyè¿›è®¾å¤‡é©±åŠ¨ä¸Šä¸‹æ–‡ç»“æ„ä½“çš„kindå±æ€§ strlcpy(drv_ctx.kind,role,128); //å¦‚æœæ˜¯mpeg4è§£ç ç»„ä»¶ if (!strncmp(drv_ctx.kind,\"OMX.qcom.video.decoder.mpeg4\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.mpeg4\",\\ OMX_MAX_STRINGNAME_SIZE); drv_ctx.timestamp_adjust = true; drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG4; eCompressionFormat = OMX_VIDEO_CodingMPEG4; output_capability=V4L2_PIX_FMT_MPEG4; /*Initialize Start Code for MPEG4*/ codec_type_parse = CODEC_TYPE_MPEG4; m_frame_parser.init_start_codes (codec_type_parse); ...... //å¦‚æœæ˜¯mpeg2è§£ç ç»„ä»¶ &#125; else if (!strncmp(drv_ctx.kind,\"OMX.qcom.video.decoder.mpeg2\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.mpeg2\",\\ OMX_MAX_STRINGNAME_SIZE); drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG2; output_capability = V4L2_PIX_FMT_MPEG2; eCompressionFormat = OMX_VIDEO_CodingMPEG2; /*Initialize Start Code for MPEG2*/ codec_type_parse = CODEC_TYPE_MPEG2; m_frame_parser.init_start_codes (codec_type_parse); ...... //å¦‚æœæ˜¯h263è§£ç ç»„ä»¶ &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.h263\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.h263\",OMX_MAX_STRINGNAME_SIZE); DEBUG_PRINT_LOW(\"H263 Decoder selected\"); drv_ctx.decoder_format = VDEC_CODECTYPE_H263; eCompressionFormat = OMX_VIDEO_CodingH263; output_capability = V4L2_PIX_FMT_H263; codec_type_parse = CODEC_TYPE_H263; m_frame_parser.init_start_codes (codec_type_parse); ...... //å¦‚æœæ˜¯divx311... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.divx311\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.divx\",OMX_MAX_STRINGNAME_SIZE); DEBUG_PRINT_LOW (\"DIVX 311 Decoder selected\"); drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_3; output_capability = V4L2_PIX_FMT_DIVX_311; eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx; codec_type_parse = CODEC_TYPE_DIVX; m_frame_parser.init_start_codes (codec_type_parse); eRet = createDivxDrmContext(); if (eRet != OMX_ErrorNone) &#123; DEBUG_PRINT_ERROR(\"createDivxDrmContext Failed\"); return eRet; &#125; //å¦‚æœæ˜¯divx4... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.divx4\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.divx\",OMX_MAX_STRINGNAME_SIZE); DEBUG_PRINT_ERROR (\"DIVX 4 Decoder selected\"); drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_4; output_capability = V4L2_PIX_FMT_DIVX; eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx; codec_type_parse = CODEC_TYPE_DIVX; codec_ambiguous = true; m_frame_parser.init_start_codes (codec_type_parse); eRet = createDivxDrmContext(); if (eRet != OMX_ErrorNone) &#123; DEBUG_PRINT_ERROR(\"createDivxDrmContext Failed\"); return eRet; &#125; //å¦‚æœæ˜¯divx... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.divx\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.divx\",OMX_MAX_STRINGNAME_SIZE); DEBUG_PRINT_ERROR (\"DIVX 5/6 Decoder selected\"); drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_6; output_capability = V4L2_PIX_FMT_DIVX; eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx; codec_type_parse = CODEC_TYPE_DIVX; codec_ambiguous = true; m_frame_parser.init_start_codes (codec_type_parse); eRet = createDivxDrmContext(); if (eRet != OMX_ErrorNone) &#123; DEBUG_PRINT_ERROR(\"createDivxDrmContext Failed\"); return eRet; &#125; //å¦‚æœæ˜¯avc/h264... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.avc\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.avc\",OMX_MAX_STRINGNAME_SIZE); drv_ctx.decoder_format = VDEC_CODECTYPE_H264; output_capability=V4L2_PIX_FMT_H264; eCompressionFormat = OMX_VIDEO_CodingAVC; codec_type_parse = CODEC_TYPE_H264; m_frame_parser.init_start_codes (codec_type_parse); m_frame_parser.init_nal_length(nal_length); ...... //å¦‚æœæ˜¯hevc/h265... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.hevc\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.hevc\",OMX_MAX_STRINGNAME_SIZE); drv_ctx.decoder_format = VDEC_CODECTYPE_HEVC; output_capability=V4L2_PIX_FMT_HEVC; eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingHevc; codec_type_parse = CODEC_TYPE_HEVC; m_frame_parser.init_start_codes (codec_type_parse); m_frame_parser.init_nal_length(nal_length); ... //å¦‚æœæ˜¯vc1... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.vc1\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.vc1\",OMX_MAX_STRINGNAME_SIZE); drv_ctx.decoder_format = VDEC_CODECTYPE_VC1; eCompressionFormat = OMX_VIDEO_CodingWMV; codec_type_parse = CODEC_TYPE_VC1; output_capability = V4L2_PIX_FMT_VC1_ANNEX_G; m_frame_parser.init_start_codes (codec_type_parse); //å¦‚æœæ˜¯wmv... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.wmv\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.vc1\",OMX_MAX_STRINGNAME_SIZE); drv_ctx.decoder_format = VDEC_CODECTYPE_VC1_RCV; eCompressionFormat = OMX_VIDEO_CodingWMV; codec_type_parse = CODEC_TYPE_VC1; output_capability = V4L2_PIX_FMT_VC1_ANNEX_L; m_frame_parser.init_start_codes (codec_type_parse); //å¦‚æœæ˜¯vp8... &#125; else if (!strncmp(drv_ctx.kind, \"OMX.qcom.video.decoder.vp8\",\\ OMX_MAX_STRINGNAME_SIZE)) &#123; strlcpy((char *)m_cRole, \"video_decoder.vp8\",OMX_MAX_STRINGNAME_SIZE); output_capability=V4L2_PIX_FMT_VP8; eCompressionFormat = OMX_VIDEO_CodingVPX; codec_type_parse = CODEC_TYPE_VP8; arbitrary_bytes = false; // å¦‚æœæ˜¯ä¸è®¤è¯†çš„è§£ç ç»„ä»¶ï¼Œåˆ™æŠ¥é”™ &#125; else &#123; DEBUG_PRINT_ERROR(\"ERROR:Unknown Component\"); eRet = OMX_ErrorInvalidComponentName; &#125; //å¦‚æœé”™è¯¯ if (eRet == OMX_ErrorNone) &#123; //è®¾ç½®è§†é¢‘è¾“å‡ºç¼–ç æ ¼å¼ä¸ºYUVçš„ä¸€ç§ drv_ctx.output_format = VDEC_YUV_FORMAT_NV12; //è®¾ç½®é¢œè‰²ç¼–ç  OMX_COLOR_FORMATTYPE dest_color_format = (OMX_COLOR_FORMATTYPE) QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m; if (!client_buffers.set_color_format(dest_color_format)) &#123; DEBUG_PRINT_ERROR(\"Setting color format failed\"); eRet = OMX_ErrorInsufficientResources; &#125; //è®¢é˜…äº‹ä»¶ capture_capability= V4L2_PIX_FMT_NV12; ret = subscribe_to_events(drv_ctx.video_driver_fd); if (ret) &#123; DEBUG_PRINT_ERROR(\"Subscribe Event Failed\"); return OMX_ErrorInsufficientResources; &#125; struct v4l2_capability cap; //è®¾ç½®æŸ¥è¯¢èƒ½åŠ›æ ‡å¿—ä½ ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_QUERYCAP, &amp;cap); if (ret) &#123; DEBUG_PRINT_ERROR(\"Failed to query capabilities\"); /*TODO: How to handle this case */ &#125; else &#123; DEBUG_PRINT_HIGH(\"Capabilities: driver_name = %s, card = %s, bus_info = %s,\" \" version = %d, capabilities = %x\", cap.driver, cap.card, cap.bus_info, cap.version, cap.capabilities); &#125; ret=0; fdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE; fdesc.index=0; while (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == 0) &#123; DEBUG_PRINT_HIGH(\"fmt: description: %s, fmt: %x, flags = %x\", fdesc.description, fdesc.pixelformat, fdesc.flags); fdesc.index++; &#125; fdesc.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE; fdesc.index=0; while (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == 0) &#123; DEBUG_PRINT_HIGH(\"fmt: description: %s, fmt: %x, flags = %x\", fdesc.description, fdesc.pixelformat, fdesc.flags); fdesc.index++; &#125; update_resolution(320, 240); fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE; fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height; fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width; fmt.fmt.pix_mp.pixelformat = output_capability; ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt); if (ret) &#123; /*TODO: How to handle this case */ DEBUG_PRINT_ERROR(\"Failed to set format on output port\"); &#125; DEBUG_PRINT_HIGH(\"Set Format was successful\"); //å¦‚æœæœ‰æ­§ä¹‰çš„è§£ç ç»„ä»¶ if (codec_ambiguous) &#123; if (output_capability == V4L2_PIX_FMT_DIVX) &#123; struct v4l2_control divx_ctrl; if (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_4) &#123; divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_4; &#125; else if (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_5) &#123; divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_5; &#125; else &#123; divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_6; &#125; divx_ctrl.id = V4L2_CID_MPEG_VIDC_VIDEO_DIVX_FORMAT; ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;divx_ctrl); if (ret) &#123; DEBUG_PRINT_ERROR(\"Failed to set divx version\"); &#125; &#125; else &#123; DEBUG_PRINT_ERROR(\"Codec should not be ambiguous\"); &#125; &#125; //è§£ç ç›¸å…³å‚æ•°è®¾ç½® fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE; fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height; fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width; fmt.fmt.pix_mp.pixelformat = capture_capability; ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt); if (ret) &#123; /*TODO: How to handle this case */ DEBUG_PRINT_ERROR(\"Failed to set format on capture port\"); &#125; DEBUG_PRINT_HIGH(\"Set Format was successful\"); if (secure_mode) &#123; control.id = V4L2_CID_MPEG_VIDC_VIDEO_SECURE; control.value = 1; DEBUG_PRINT_LOW(\"Omx_vdec:: calling to open secure device %d\", ret); ret=ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&amp;control); if (ret) &#123; DEBUG_PRINT_ERROR(\"Omx_vdec:: Unable to open secure device %d\", ret); close(drv_ctx.video_driver_fd); return OMX_ErrorInsufficientResources; &#125; &#125; /*Get the Buffer requirements for input and output ports*/ //è·å¾—è¾“å…¥å’Œè¾“å‡ºçš„ç¼“å†²æ¡ä»¶ drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT; drv_ctx.op_buf.buffer_type = VDEC_BUFFER_TYPE_OUTPUT; if (secure_mode) &#123; drv_ctx.op_buf.alignment=SZ_1M; drv_ctx.ip_buf.alignment=SZ_1M; &#125; else &#123; drv_ctx.op_buf.alignment=SZ_4K; drv_ctx.ip_buf.alignment=SZ_4K; &#125; drv_ctx.interlace = VDEC_InterlaceFrameProgressive; drv_ctx.extradata = 0; drv_ctx.picture_order = VDEC_ORDER_DISPLAY; control.id = V4L2_CID_MPEG_VIDC_VIDEO_OUTPUT_ORDER; control.value = V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DISPLAY; ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;control); drv_ctx.idr_only_decoding = 0; m_state = OMX_StateLoaded;#ifdef DEFAULT_EXTRADATA if (eRet == OMX_ErrorNone &amp;&amp; !secure_mode) enable_extradata(DEFAULT_EXTRADATA, true, true);#endif eRet=get_buffer_req(&amp;drv_ctx.ip_buf); DEBUG_PRINT_HIGH(\"Input Buffer Size =%d\",drv_ctx.ip_buf.buffer_size); get_buffer_req(&amp;drv_ctx.op_buf); //å¦‚æœè§£ç å™¨æ ¼å¼æ˜¯h264æˆ–è€…hevc/h265 if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 || drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) &#123; h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size; h264_scratch.pBuffer = (OMX_U8 *)malloc (drv_ctx.ip_buf.buffer_size); h264_scratch.nFilledLen = 0; h264_scratch.nOffset = 0; if (h264_scratch.pBuffer == NULL) &#123; DEBUG_PRINT_ERROR(\"h264_scratch.pBuffer Allocation failed \"); return OMX_ErrorInsufficientResources; &#125; &#125; //å¦‚æœè§£ç å™¨æ ¼å¼æ˜¯h264 if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) &#123; if (m_frame_parser.mutils == NULL) &#123; m_frame_parser.mutils = new H264_Utils(); if (m_frame_parser.mutils == NULL) &#123; DEBUG_PRINT_ERROR(\"parser utils Allocation failed \"); eRet = OMX_ErrorInsufficientResources; &#125; else &#123; m_frame_parser.mutils-&gt;initialize_frame_checking_environment(); m_frame_parser.mutils-&gt;allocate_rbsp_buffer (drv_ctx.ip_buf.buffer_size); &#125; &#125; //åˆ›å»ºä¸€ä¸ªh264æµçš„è§£æå™¨ h264_parser = new h264_stream_parser(); if (!h264_parser) &#123; DEBUG_PRINT_ERROR(\"ERROR: H264 parser allocation failed!\"); eRet = OMX_ErrorInsufficientResources; &#125; &#125; //æ‰“å¼€ä¸€ä¸ªç®¡é“ï¼Œè¯»å†™ç«¯ä¿å­˜è¿›fdsæ•°ç»„ if (pipe(fds)) &#123; DEBUG_PRINT_ERROR(\"pipe creation failed\"); eRet = OMX_ErrorInsufficientResources; &#125; else &#123; int temp1[2]; if (fds[0] == 0 || fds[1] == 0) &#123; if (pipe (temp1)) &#123; DEBUG_PRINT_ERROR(\"pipe creation failed\"); return OMX_ErrorInsufficientResources; &#125; //close (fds[0]); //close (fds[1]); fds[0] = temp1 [0]; fds[1] = temp1 [1]; &#125; //è¾“å…¥/è¯» m_pipe_in = fds[0]; //è¾“å‡º/å†™ m_pipe_out = fds[1]; //åˆ›å»ºä¸€ä¸ªå·¥ä½œçº¿ç¨‹ï¼Œè°ƒç”¨omxå¼€å§‹å¤„ç†è§£ç ï¼Œå¹¶è¿›è¡Œi/oæ“ä½œ r = pthread_create(&amp;msg_thread_id,0,message_thread,this); if (r &lt; 0) &#123; DEBUG_PRINT_ERROR(\"component_init(): message_thread creation failed\"); eRet = OMX_ErrorInsufficientResources; &#125; &#125; &#125; //æ²¡æœ‰é”™è¯¯ï¼Œç„¶åæ”¶å°¾ if (eRet != OMX_ErrorNone) &#123; DEBUG_PRINT_ERROR(\"Component Init Failed\"); DEBUG_PRINT_HIGH(\"Calling VDEC_IOCTL_STOP_NEXT_MSG\"); (void)ioctl(drv_ctx.video_driver_fd, VDEC_IOCTL_STOP_NEXT_MSG, NULL); DEBUG_PRINT_HIGH(\"Calling close() on Video Driver\"); close (drv_ctx.video_driver_fd); drv_ctx.video_driver_fd = -1; &#125; else &#123; DEBUG_PRINT_HIGH(\"omx_vdec::component_init() success\"); &#125; //memset(&amp;h264_mv_buff,0,sizeof(struct h264_mv_buffer)); return eRet;&#125; è¿™ä¸ªæ˜¯è§£ç ç»„ä»¶çš„åˆå§‹åŒ–å®ç°ã€‚æˆ‘ä»¬èƒ½å¤Ÿçœ‹å‡ºå’ŒTIçš„å·®è·æŒºå¤§çš„ã€‚æ­¥éª¤å¤§æ¦‚å¦‚ä¸‹ï¼ˆmaybe wrongï¼‰ï¼š â˜¯ æ‰“å¼€mediaç›¸å…³è®¾å¤‡æ–‡ä»¶â˜¯ åˆ›å»ºä¸€ä¸ªå¼‚æ­¥çº¿ç¨‹ï¼Œæ‰§è¡Œasync_message_threadå‡½æ•°ï¼Œå¯¹è¾“å…¥ç«¯è¿›è¡Œè®¾ç½®â˜¯ æ ¹æ®è§£ç å™¨roleåé…ç½®ç›¸å…³å±æ€§â˜¯ å¯¹è§†é¢‘è§£ç ç›¸å…³åŸºæœ¬é…ç½®è¿›è¡Œè®¾ç½®â˜¯ åˆ›å»ºä¸€ä¸ªç®¡é“ï¼Œç„¶åå†å¼€ä¸€ä¸ªä¸ªå·¥ä½œçº¿ç¨‹ï¼Œè°ƒç”¨omxå¼€å§‹å¤„ç†è§£ç ï¼Œå¹¶è¿›è¡Œi/oæ“ä½œ ï¼ˆä¸‰ï¼‰ã€Androidä¸­OpenMaxçš„å®ç°3.1ã€android MediaCodec ACodec3.1.1ã€MediaCodecMediaCodecç±»å¯ç”¨äºè®¿é—®Androidåº•å±‚çš„åª’ä½“ç¼–è§£ç å™¨ï¼Œä¾‹å¦‚ï¼Œç¼–ç /è§£ç ç»„ä»¶ã€‚å®ƒæ˜¯Androidä¸ºå¤šåª’ä½“æ”¯æŒæä¾›çš„åº•å±‚æ¥å£çš„ä¸€éƒ¨åˆ†ï¼ˆé€šå¸¸ä¸MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface, ä»¥åŠAudioTrackä¸€èµ·ä½¿ç”¨ï¼‰ã€‚ä»å¹¿ä¹‰ä¸Šè®²ï¼Œä¸€ä¸ªç¼–è§£ç å™¨é€šè¿‡å¤„ç†è¾“å…¥æ•°æ®æ¥äº§ç”Ÿè¾“å‡ºæ•°æ®ã€‚å®ƒé€šè¿‡å¼‚æ­¥æ–¹å¼å¤„ç†æ•°æ®ï¼Œå¹¶ä¸”ä½¿ç”¨äº†ä¸€ç»„è¾“å…¥è¾“å‡ºbuffersã€‚åœ¨ç®€å•å±‚é¢ï¼Œè¯·æ±‚ï¼ˆæˆ–æ¥æ”¶ï¼‰åˆ°ä¸€ä¸ªç©ºçš„è¾“å…¥bufferï¼Œå‘é‡Œé¢å¡«æ»¡æ•°æ®å¹¶å°†å®ƒä¼ é€’ç»™ç¼–è§£ç å™¨å¤„ç†ã€‚è¿™ä¸ªç¼–è§£ç å™¨å°†ä½¿ç”¨å®Œè¿™äº›æ•°æ®å¹¶å‘æ‰€æœ‰ç©ºçš„è¾“å‡ºbufferä¸­çš„ä¸€ä¸ªå¡«å……è¿™äº›æ•°æ®ã€‚æœ€ç»ˆï¼Œè¯·æ±‚ï¼ˆæˆ–æ¥å—ï¼‰åˆ°ä¸€ä¸ªå¡«å……äº†æ•°æ®çš„buffer,å¯ä»¥ä½¿ç”¨å…¶ä¸­çš„æ•°æ®å†…å®¹ï¼Œå¹¶ä¸”åœ¨ä½¿ç”¨å®Œåå°†å…¶é‡Šæ”¾å›ç¼–è§£ç å™¨ã€‚ 1ã€ Data Typesç¼–è§£ç å™¨å¤„ç†ä¸‰ç§ç±»å‹çš„æ•°æ®ï¼šå‹ç¼©æ•°æ®ï¼ŒåŸå§‹éŸ³é¢‘æ•°æ®ï¼ŒåŸå§‹è§†é¢‘æ•°æ®ã€‚ä¸Šè¿°ä¸‰ç§æ•°æ®éƒ½å¯ä»¥é€šè¿‡ByteBuffersè¿›è¡Œå¤„ç†ï¼Œä½†éœ€è¦ä¸ºåŸå§‹è§†é¢‘æ•°æ®æä¾›ä¸€ä¸ªSurfaceæ¥æé«˜ç¼–è§£ç æ€§èƒ½ã€‚ï¬ å‹ç¼©ç¼“å­˜ï¼ˆCompressed Buffersï¼‰ï¼šè¾“å…¥ç¼“å†²åŒº(è§£ç å™¨)å’Œè¾“å‡ºç¼“å†²åŒº(ç¼–ç å™¨)åŒ…å«å‹ç¼©æ•°æ®æ ¼å¼çš„ç±»å‹ã€‚ï¬ åŸå§‹éŸ³é¢‘ç¼“å­˜ï¼ˆRaw Audio Buffersï¼‰ï¼šåŸå§‹éŸ³é¢‘ç¼“å†²åŒºåŒ…å«æ•´ä¸ªPCMéŸ³é¢‘å¸§æ•°æ®ã€‚ï¬ åŸå§‹è§†é¢‘ç¼“å­˜ï¼ˆRaw Video Buffersï¼‰ï¼šByteBufferæ¨¡å¼è§†é¢‘ç¼“å†²åŒºæ ¹æ®ä»–ä»¬çš„é¢œè‰²æ ¼å¼å¸ƒå±€ã€‚è§†é¢‘ç¼–è§£ç å™¨å¯èƒ½æ”¯æŒä¸‰ç§ç±»å‹çš„è‰²å½©æ ¼å¼ï¼š1)ã€native raw video formatï¼šè¢«COLOR_FormatSurfaceæ ‡è®°ï¼Œå…¶å¯ä¸è¾“å…¥æˆ–è¾“å‡ºSurfaceä¸€èµ·ä½¿ç”¨ï¼›2)ã€flexible YUV buffersï¼ˆå¦‚COLOR_FormatYUV420Flexibleï¼‰ï¼Œå¯ä»¥ä¸è¾“å…¥/è¾“å‡ºSurfaceä¸€èµ·ä½¿ç”¨, ByteBufferæ¨¡å¼ä¸‹å¯ä»¥é€šè¿‡è°ƒç”¨getInput/OutputImage(int)æ–¹æ³•è¿›è¡Œä½¿ç”¨ï¼›3)ã€é€šå¸¸åªåœ¨ByteBufferæ¨¡å¼ä¸‹è¢«æ”¯æŒã€‚ç”±ä¾›åº”å•†æŒ‡å®šï¼Œå¯ä»¥ä½¿ç”¨ getInput/OutputImage(int)æ–¹æ³•ã€‚ 2ã€Statesåœ¨ç¼–è§£ç å™¨çš„ç”Ÿå‘½å‘¨æœŸå†…æœ‰ä¸‰ç§ç†è®ºçŠ¶æ€ï¼šåœæ­¢æ€-Stoppedã€æ‰§è¡Œæ€-Executingã€é‡Šæ”¾æ€-Releasedã€‚åœæ­¢çŠ¶æ€ï¼ˆStoppedï¼‰åŒ…æ‹¬äº†ä¸‰ç§å­çŠ¶æ€ï¼šæœªåˆå§‹åŒ–ï¼ˆUninitializedï¼‰ã€é…ç½®ï¼ˆConfiguredï¼‰ã€é”™è¯¯ï¼ˆErrorï¼‰ã€‚æ‰§è¡ŒçŠ¶æ€ï¼ˆExecutingï¼‰åœ¨æ¦‚å¿µä¸Šä¼šç»å†ä¸‰ç§å­çŠ¶æ€ï¼šåˆ·æ–°ï¼ˆFlushedï¼‰ã€è¿è¡Œï¼ˆRunningï¼‰ã€æµç»“æŸï¼ˆEnd-of-Streamï¼‰ã€‚ ä½¿ç”¨å·¥å‚æ–¹æ³•ä¹‹ä¸€åˆ›å»ºä¸€ä¸ªç¼–è§£ç å™¨çš„æ—¶å€™ï¼Œæ˜¯å¤„äºUninitializedçŠ¶æ€ã€‚é¦–å…ˆï¼Œéœ€è¦é€šè¿‡configure(â€¦)æ–¹æ³•é…ç½®å®ƒï¼Œä»¥æ­¤è¿›å…¥Configured çŠ¶æ€ã€‚ç„¶åï¼Œé€šè¿‡è°ƒç”¨start()æ–¹æ³•è½¬å…¥Executing çŠ¶æ€ã€‚åœ¨è¿™ä¸ªçŠ¶æ€ä¸‹å¯ä»¥é€šè¿‡ä¸Šè¿°bufferé˜Ÿåˆ—æ“ä½œè¿‡ç¨‹æ•°æ®ã€‚è°ƒç”¨start()æ–¹æ³•åç«‹å³è¿›å…¥FlushedçŠ¶æ€ï¼Œæ­¤æ—¶ç¼–è§£ç å™¨æ‹¥æœ‰æ‰€æœ‰çš„ç¼“å­˜ã€‚ä¸€æ—¦ç¬¬ä¸€ä¸ªè¾“å…¥ç¼“å­˜è¢«ç§»å‡ºé˜Ÿåˆ—ï¼Œç¼–è§£ç å™¨å°±è½¬å…¥è¿è¡Œå­çŠ¶æ€ï¼Œè¿™ç§çŠ¶æ€å æ®äº†ç¼–è§£ç å™¨çš„å¤§éƒ¨åˆ†ç”Ÿå‘½å‘¨æœŸã€‚å½“å°†ä¸€ä¸ªå¸¦æœ‰end-of-stream markeræ ‡è®°çš„è¾“å…¥ç¼“å­˜å…¥é˜Ÿåˆ—æ—¶ï¼Œç¼–è§£ç å™¨å°†è½¬å…¥æµç»“æŸå­çŠ¶æ€ã€‚å¯åœ¨ExecutingçŠ¶æ€çš„ä»»ä½•æ—¶å€™é€šè¿‡è°ƒç”¨flush()ã€‚è°ƒç”¨stop()æ–¹æ³•è¿”å›ç¼–è§£ç å™¨çš„Uninitialized çŠ¶æ€ï¼Œå› æ­¤è¿™ä¸ªç¼–è§£ç å™¨éœ€è¦å†æ¬¡configured ã€‚å½“ä½¿ç”¨å®Œç¼–è§£ç å™¨åï¼Œå¿…é¡»è°ƒç”¨release()æ–¹æ³•é‡Šæ”¾å…¶èµ„æºã€‚ 3ã€Data Processingæ¯ä¸€ä¸ªç¼–è§£ç å™¨åŒ…å«ä¸€ç»„è¾“å…¥å’Œè¾“å‡ºç¼“å­˜ï¼Œè¿™äº›ç¼“å­˜åœ¨APIè°ƒç”¨ä¸­é€šè¿‡buffer-IDè¿›è¡Œå¼•ç”¨ã€‚å½“æˆåŠŸè°ƒç”¨start()æ–¹æ³•åå®¢æˆ·ç«¯å°†ä¸ä¼šæ‹¥æœ‰è¾“å…¥æˆ–è¾“å‡ºbuffersã€‚åœ¨åŒæ­¥æ¨¡å¼ä¸‹ï¼Œé€šè¿‡è°ƒç”¨dequeueInput/OutputBuffer(â€¦) æ–¹æ³•ä»ç¼–è§£ç å™¨è·å¾—ä¸€ä¸ªè¾“å…¥æˆ–è¾“å‡ºbufferï¼›åœ¨å¼‚æ­¥æ¨¡å¼ä¸‹ï¼Œå¯ä»¥é€šè¿‡MediaCodec.Callback.onInput/OutputBufferAvailable(â€¦)çš„å›è°ƒæ–¹æ³•è‡ªåŠ¨åœ°è·å¾—å¯ç”¨çš„buffersã€‚åœ¨è·å¾—ä¸€ä¸ªè¾“å…¥buffeåï¼Œå¡«å……æ•°æ®ï¼Œåˆ©ç”¨queueInputBuffer/queueSecureInputBufferæ–¹æ³•å°†å…¶æäº¤ç»™ç¼–è§£ç å™¨ï¼Œä¸è¦æäº¤å¤šä¸ªå…·æœ‰ç›¸åŒæ—¶é—´æˆ³çš„è¾“å…¥bufersï¼ˆé™¤éå®ƒæ˜¯ä¹Ÿè¢«åŒæ ·æ ‡è®°çš„codec-specific dataï¼Œå› ä¸ºcodec-specific dataç¼“å†²çš„æ—¶é—´æˆ³æ— æ„ä¹‰ï¼‰ã€‚a. Asynchronous Processing using Buffers ä»Android 5.0å¼€å§‹ï¼Œé¦–é€‰çš„æ–¹æ³•æ˜¯è°ƒç”¨configureä¹‹å‰é€šè¿‡è®¾ç½®å›è°ƒå¼‚æ­¥åœ°å¤„ç†æ•°æ®ã€‚å¼‚æ­¥æ¨¡å¼ç¨å¾®æ”¹å˜äº†çŠ¶æ€è½¬æ¢æ–¹å¼ï¼Œå› ä¸ºå¿…é¡»åœ¨è°ƒç”¨flush()æ–¹æ³•åå†è°ƒç”¨start()æ–¹æ³•æ‰èƒ½ä½¿ç¼–è§£ç å™¨çš„çŠ¶æ€è½¬æ¢ä¸ºRunningå­çŠ¶æ€å¹¶å¼€å§‹æ¥æ”¶è¾“å…¥buffersã€‚åŒæ ·ï¼Œåˆå§‹è°ƒç”¨startæ–¹æ³•å°†ç¼–è§£ç å™¨çš„çŠ¶æ€ç›´æ¥å˜åŒ–ä¸ºRunning å­çŠ¶æ€å¹¶é€šè¿‡å›è°ƒæ–¹æ³•å¼€å§‹ä¼ é€’å¯ç”¨çš„è¾“å…¥buufersã€‚b. Synchronous Processing using Buffersä»Android 5.0å¼€å§‹ï¼Œå³ä½¿åœ¨åŒæ­¥æ¨¡å¼ä¸‹ä½¿ç”¨ç¼–è§£ç å™¨ï¼Œä¹Ÿåº”è¯¥é€šè¿‡getInput/OutputBuffer(int) å’Œ/æˆ– getInput/OutputImage(int) æ–¹æ³•æ£€ç´¢è¾“å…¥å’Œè¾“å‡ºbuffersã€‚ 3.1.2ã€ACodec1ã€ACodecæ¶ˆæ¯æœºåˆ¶ï¼šï¬ ACodecæœ‰ä¸€ä¸ªBaseStateå’Œæ´¾ç”Ÿå‡ºæ¥çš„å…¶ä»–Stateï¼Œå¦‚ UninitializedState, LoadedToIdleState, ExecutingStateç­‰ã€‚å½“æœ‰æ¶ˆæ¯è¿‡æ¥æ—¶ï¼Œå¦‚æœæ´¾ç”Ÿç±»æœ‰é‡å†™çš„æ–¹æ³•ï¼Œåˆ™ä¼šè°ƒåˆ°é‡å†™çš„æ–¹æ³•ï¼Œå¦‚æœæ²¡æœ‰ï¼Œåˆ™ä¼šè°ƒåˆ°BaseStateçš„ï¬ ACodecç»§æ‰¿è‡ªAHierarchicalStateMachineç±»ï¼Œè¯¥ç±»ç”¨äºå°†æ”¶åˆ°çš„æ¶ˆæ¯ä¼ é€’ç»™å“ªä¸ªstateã€‚ï¬ ACodecæ”¶åˆ°çš„æ¶ˆæ¯åˆ†ä¸¤ç§ï¼Œä¸€ç§æ˜¯MediaCodecä¼ è¿‡æ¥çš„ï¼Œå¯¹åº”onMessageReceivedæ–¹æ³•ï¼›å¦ä¸€ç§æ˜¯OMX Componentä¼ è¿‡æ¥çš„ï¼Œå¯¹åº”onOMXMessageæ–¹æ³•ã€‚è€ŒonOMXMessageé‡Œé¢åˆåˆ†äº†4ç§æƒ…å†µæ¥è°ƒç”¨ä¸åŒçš„æ–¹æ³•ã€‚ï¼ˆEVENTã€EMPTY_BUFFER_DONEã€FILL_BUFFER_DONEå’ŒFRAME_RENDEREDï¼‰ 2ã€MediaCodecä¸ACodecçš„é€šçŸ¥ï¼šï¬ OMXçš„ç»„ä»¶è§£ç ä¹‹åï¼ŒACodec::BaseState:: onOMXFillBufferDone (â€¦)ä¼šè¢«å›è°ƒï¼Œå»å–å¾—è§£ç åçš„æ•°æ®ã€‚ç„¶åä¼šåœ¨onOMXFillBufferDoneä¸­è°ƒç”¨notifyé€šçŸ¥MediaCodecï¼Œå‘ç»™MediaCodecçš„æ¶ˆæ¯å½¢å¦‚notify-&gt;setInt32(â€œwhatâ€, CodecBase::kWhatDrainThisBuffer);ï¬ MediaCodecæ”¶åˆ°ACodecå‘çš„æ¶ˆæ¯ä¹‹åä¼šupdateBuffers(kPortIndexOutput, msg) è¿›è¡Œæ›´æ–°ï¼ŒåŒæ—¶è°ƒç”¨onOutputBufferAvailable()ä¸­é€šçŸ¥NuPlayer::Decoderæœ‰å¯ç”¨çš„output bufferã€‚ 3ã€ACodecæœ‰ä¸‰ç§ç«¯å£æ¨¡å¼çŠ¶æ€ï¼Œå…¶ä¼šæ ¹æ®å½“å‰å¤„äºå“ªä¸ªçŠ¶æ€æ¥å†³å®šbufferå¦‚ä½•å¤„ç†ï¼šï¬ KEEP_BUFFERSï¼šå½“ACodecå¤„äºBaseStateæˆ–è€…æ”¶åˆ°OnInputBufferFilledæ¶ˆæ¯ä½†æ˜¯bufferé‡Œé¢æ²¡æœ‰å¡«å……æœ‰æ•ˆçš„æ•°æ®æ—¶ï¼ŒACodecæ¡æœ‰çš„bufferä¸ä¼šé€åˆ°OMX ç»„ä»¶ï¼›ï¬ RESUBMIT_BUFFERSï¼šå½“ACodecå¤„äºExecutingStateæˆ–è€…å¤„äºOutputPortSettingChangedStateä½†æ˜¯å½“å‰æ˜¯inputå£çš„bufferæ—¶ï¼ŒACodecå°†æ¡æœ‰çš„bufferé€ç»™OMX ç»„ä»¶ï¼›ï¬ FREE_BUFFERSï¼šå½“ACodecå¤„äºOutputPortSettingChangedStateå¹¶ä¸”å½“å‰æ˜¯outputå£çš„bufferæ—¶ï¼ŒACodecå°†æ¡æœ‰çš„buffer freeã€‚ 4ã€stagefrightç±»çš„è°ƒç”¨å…³ç³»ï¼šï¬ OMXNodeInstanceè´Ÿè´£åˆ›å»ºå¹¶ç»´æŠ¤ä¸åŒçš„å®ä¾‹ï¼Œè¿™äº›å®ä¾‹ä»¥nodeä½œä¸ºå”¯ä¸€æ ‡è¯†ã€‚è¿™æ ·æ’­æ”¾å™¨ä¸­æ¯ä¸ªACodecåœ¨OMXæœåŠ¡ç«¯éƒ½å¯¹åº”æœ‰äº†è‡ªå·±çš„OMXNodeInstanceå®ä¾‹ã€‚ï¬ OMXMasterç”¨æ¥ç»´æŠ¤åº•å±‚è½¯ç¡¬ä»¶è§£ç åº“ï¼Œæ ¹æ®OMXNodeInstanceä¸­æƒ³è¦çš„è§£ç å™¨æ¥åˆ›å»ºè§£ç å®ä½“ç»„ä»¶ã€‚ï¬ OMXPluginBaseè´Ÿè´£åŠ è½½ç»„ä»¶åº“ï¼Œåˆ›å»ºç»„ä»¶å®ä¾‹ï¼Œç”±OMXMasterç®¡ç†ã€‚AndroidåŸç”Ÿæä¾›çš„ç»„ä»¶éƒ½æ˜¯ç”±SoftOMXPluginç±»æ¥ç®¡ç†ï¼Œè¿™ä¸ªç±»å°±æ˜¯ç»§æ‰¿è‡ªOMXPluginBaseã€‚ï¼ˆAndroidæºç æä¾›äº†ä¸€äº›è½¯ä»¶è§£ç å’Œç¼–ç çš„ç»„ä»¶ï¼Œå®ƒä»¬è¢«æŠ½è±¡ä¸ºSoftOMXComponentï¼‰ï¬ OMXClientæ˜¯å®¢æˆ·ç«¯ç”¨æ¥ä¸OMX ILè¿›è¡Œé€šä¿¡çš„ã€‚ï¬ å†…éƒ¨ç»“æ„CallbackDispatcherä½œç”¨æ˜¯ç”¨æ¥æ¥æ”¶å›è°ƒå‡½æ•°çš„æ¶ˆæ¯ï¬ OMXNodeInstance + CallbackDispatcher = åˆä½œå®Œæˆä¸åŒå®ä¾‹çš„æ¶ˆæ¯å¤„ç†ä»»åŠ¡ 5ã€ACodecåŒOMXNodeInstanceçš„æ¶ˆæ¯ä¼ é€’ï¼šï¬ ACodecå°†CodecObserver observerå¯¹è±¡é€šè¿‡omx-&gt;allocateNode()ä¼ é€’åˆ°OMXNodeInstanceã€‚ï¬ OMXNodeInstanceå°†kCallbacks(OnEvent,OnEmptyBufferDone,OnFillBufferDone)ä¼ é€’ç»™OMX Componentï¬ å½“OMX Componentæœ‰æ¶ˆæ¯notifyä¸Šæ¥æ—¶ï¼ŒOMXNodeInstanceæœ€å…ˆæ”¶åˆ°ï¼Œç„¶åè°ƒç”¨OMX.cppã€‚å°†æ¶ˆæ¯åœ¨OMX.cppé‡Œé¢å°†OMX Component threadè½¬æ¢åˆ°CallbackDispatcherçº¿ç¨‹ä¸­å¤„ç†ã€‚CallbackDispatcheråˆå°†æ¶ˆæ¯åè°ƒåˆ°OMXNodeInstance. æœ€åè°ƒç”¨CodecObserver çš„onMessage()å›åˆ°ACodecä¸­ 6ã€ ACodecä¸OMXç»„ä»¶çš„å…³ç³»ï¬ ACodec ï¼ŒCodecObserverå’ŒOMXNodeInstanceæ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œç®€å•çš„å¯ä»¥ç†è§£å®ƒä»¬3ä¸ªæ„æˆäº†OpenMAX ILçš„ä¸€ä¸ªComponentï¼Œæ¯ä¸€ä¸ªnodeå°±æ˜¯ä¸€ä¸ªcodecåœ¨OMXæœåŠ¡ç«¯çš„æ ‡è¯†ã€‚å½“ç„¶è¿˜æœ‰CallbackDispatcherï¼Œç”¨äºå¤„ç†codecè¿‡æ¥çš„æ¶ˆæ¯ï¼Œé€šè¿‡å®ƒçš„post/loop/dispatchæ¥å‘èµ·æ¥æ”¶ï¼Œä»OMX.cppå‘é€æ¶ˆæ¯ï¼Œæœ€ç»ˆé€šè¿‡OMXNodeInstance::onMessage -&gt; CodecObserver::onMessage -&gt; ACodec::onMessageä¸€è·¯å¾€ä¸Šï¼Œå½“ç„¶æ¶ˆæ¯çš„æ¥æºæ˜¯å› ä¸ºæˆ‘ä»¬æœ‰å‘codecæ³¨å†ŒOMXNodeInstance::kCallbacksã€‚ï¬ è€Œåœ¨OMXPluginBaseåˆ›å»ºç»„ä»¶å®ä¾‹çš„æ—¶å€™ï¼Œéœ€è¦ä¼ é€’ä¸€ä¸ªcallbackç»™ç»„ä»¶ï¼Œè¿™ä¸ªcallbackç”¨äºæ¥æ”¶ç»„ä»¶çš„æ¶ˆæ¯ï¼Œå®ƒçš„å®ç°æ˜¯åœ¨OMXNodeInstance.cppä¸­ã€‚è€Œkcallbacksæ˜¯OMXNodeInstanceçš„é™æ€æˆå‘˜å˜é‡ï¼Œå®ƒå†…éƒ¨çš„ä¸‰ä¸ªå‡½æ•°æŒ‡é’ˆåˆ†åˆ«æŒ‡å‘äº†OMXNodeInstanceçš„ä¸‰ä¸ªé™æ€æ–¹æ³•ï¼Œä¹Ÿå³æ˜¯è¿™ä¸‰ä¸ªæ–¹æ³•ä¸ç»„ä»¶è¿›è¡Œç€æ¶ˆæ¯ä¼ é€’ ï¬ å¯¹äºNuPlayeræ¥è¯´ï¼Œå®ƒå¹¶ä¸ç›´æ¥æ¥è§¦è§£ç ç»„ä»¶ï¼Œè€Œæ˜¯é€šè¿‡åˆ›å»ºACodecæ¥å’Œç»„ä»¶äº¤äº’ã€‚ACodeå†…éƒ¨æœ‰ä¸€ä¸ªidï¼Œè¿™ä¸ªidå¯¹åº”äºä¸€ä¸ªOMXNodeInstanceã€‚OMXå¯¹è±¡ä¸­ä¼šå¯¹äº§ç”Ÿçš„æ¯ä¸€ä¸ªOMXNodeInstanceåˆ†é…ä¸€ä¸ªå”¯ä¸€çš„node_idã€‚æ¯ä¸€ä¸ªOMXNodeInstanceå†…éƒ¨åˆä¿å­˜ç€ç»„ä»¶å®ä¾‹çš„æŒ‡é’ˆã€OMX_HANDLETYPE mHandle;ã€‘ï¼Œé€šè¿‡è¿™ä¸ªæŒ‡é’ˆå°±å¯ä»¥å’Œç»„ä»¶è¿›è¡Œäº¤äº’ã€‚äº¤äº’çš„æµç¨‹ä¸ºï¼šACodec â†’ OMX â†’ OMXNodeInstance â†’ COMPONENTã€‚ 8ã€ç»„ä»¶çš„ç®¡ç†ï¬ å¯¹ç»„ä»¶çš„ç®¡ç†å¯ä»¥æ€»ç»“ä¸ºï¼šé€šè¿‡OMXMasteråŠ è½½libstagefrighthw.soåº“æ–‡ä»¶ï¼Œåˆ›å»ºOMXPluginBaseã€å³åˆ›å»ºç»§æ‰¿æ­¤ç±»çš„ç»„ä»¶å¯¹è±¡ã€‘ï¼Œé€šè¿‡è¿™ä¸ªç±»æ¥ç®¡ç†ç»„ä»¶ã€‚ï¬ Androidæºç æä¾›äº†ä¸€äº›è½¯ä»¶è§£ç å’Œç¼–ç çš„ç»„ä»¶ï¼Œå®ƒä»¬è¢«æŠ½è±¡ä¸ºSoftOMXComponentã€‚OMXPluginBaseæ‰®æ¼”è€…ç»„ä»¶çš„ç®¡ç†è€…ã€‚å®ƒè´Ÿè´£åŠ è½½ç»„ä»¶åº“ï¼Œåˆ›å»ºç»„ä»¶å®ä¾‹ã€‚è€ŒOMXMasteråˆ™ç®¡ç†ç€OMXPluginBaseï¼ŒAndroidåŸç”Ÿæä¾›çš„ç»„ä»¶éƒ½æ˜¯ç”±SoftOMXPluginç±»æ¥ç®¡ç†ï¼Œè¿™ä¸ªç±»å°±æ˜¯ç»§æ‰¿è‡ªOMXPluginBaseã€‚ï¬ å¯¹äºå‚å•†æ¥è¯´ï¼Œå¦‚æœè¦å®ç°è‡ªå·±çš„ç»„ä»¶ç®¡ç†æ¨¡å—ï¼Œéœ€è¦é€šè¿‡ç»§æ‰¿å®ç°OMXPluginBaseï¼Œå¹¶å°†ä¹‹ç¼–è¯‘ä¸ºlibstagefrighthw.soã€‚åœ¨OMXMasterä¸­ä¼šåŠ è½½è¿™ä¸ªåº“æ–‡ä»¶ï¼Œç„¶åè°ƒç”¨å…¶createOMXPluginæ–¹æ³•è·å¾—ä¸€ä¸ªOMXPluginBaseæŒ‡é’ˆï¼Œç„¶åå°†å…¶åŠ å…¥OMXPluginBaseåˆ—è¡¨ä»¥åŠä¸ç»„ä»¶åç›¸å…³çš„map ã€mPluginByComponentNameã€‘ä¸­ï¼Œåç»­éƒ½ä¼šé€šè¿‡OMXPluginBaseæ¥ç®¡ç†ç»„ä»¶ã€‚ 3.2ã€éŸ³è§†é¢‘è§£ç æ•°æ®å¤„ç†æ•°æ®å¤„ç†è¯·å‚è€ƒï¼š éŸ³è§†é¢‘è§£ç æ•°æ®å¤„ç† 3.3ã€é«˜é€šå®ç°ï¼ˆå‚è€ƒé«˜é€šæ–‡æ¡£ï¼‰OpenMAX Integration Layer Video Encoder for Linux Androidï¼ˆé«˜é€šæ–‡æ¡£ï¼‰OpenMAX Integration Layer Video Decoder for Linux Androidï¼ˆé«˜é€šæ–‡æ¡£ï¼‰ ï¼ˆå››ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroidå¤šåª’ä½“å¼€å‘(äº”)â€”-OpenMaxç®€ä»‹Androidå¤šåª’ä½“å¼€å‘(å…­)â€”-Androidä¸­OpenMaxçš„å®ç°(preview)Androidå¤šåª’ä½“å¼€å‘(ä¸ƒ)â€”-Androidä¸­OpenMaxçš„å®ç°android ACodec MediaCodec NuPlayer flow - CSDNåšå®¢android MediaCodec ACodec - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architecture","slug":"Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architecture","date":"2018-08-29T16:00:00.000Z","updated":"2018-06-20T15:15:33.034Z","comments":true,"path":"2018/08/30/Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architecture/","link":"","permalink":"http://zhoujinjian.cc/2018/08/30/Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architecture/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ ã€ç‰¹åˆ«æ„Ÿè°¢ - é«˜é€šAndroidå¹³å°-åº”ç”¨ç©ºé—´æ“ä½œframebuffer dump LCDæ€»ç»“ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - linux qcom LCD framworkã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - msm8610 lcd driver code analysisã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ğŸŒ€ğŸŒ€ï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ ã€Android Display System ç³»ç»Ÿåˆ†æç³»åˆ—ã€‘ï¼šã€Android Display Systemï¼ˆ1ï¼‰ï¼šAndroid 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æã€‘ã€Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL &amp;&amp; OpenGLã€‘ã€Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.draw()ç»˜åˆ¶æµç¨‹åˆ†æã€‘ã€Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc &amp;&amp; HWComposeræ¨¡å—åˆ†æã€‘ã€Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architectureã€‘ è·¯å¾„ï¼škernel\\msm-3.18\\drivers\\video\\msm\\mdss MDSS driver software block diagram mdss_fb â†’ Top-level IOCTL/native framebufferinterface mdss_mdp.c â†’ MDP resources(clocks/irq/bus-bw/power) mdss_mdp_overlay â†’ Overlay/DMA top-levelAPI mdss_mdp_ctl â†’ Controls the hardware abstraction to club the (LM + DSPP + Ping-pong +interface) mdss_mdp_pipe â†’ SRC pipe related handling mdss_mdp_intf_cmd/mdss_mdp_intf_video/mdss_mdp_intf_writeback â†’ MDP panelinterface relatedhandling mdss_mdp_pp â†’ Postprocessing related implementation mdss_mdp_rotator â†’ Rotator APIs (overlay_set/overlay_playinterface) mdss_mdp_pp.c â†’ Postprocessing relatedmaterial æ³¨ï¼šé¦–å…ˆè¯´æ˜ï¼Œç”±äºåšä¸»ä¸æ˜¯kernelå¼€å‘æ–¹å‘çš„ï¼Œå¯èƒ½ç†è§£ä¸å¤Ÿé€å½»ï¼Œè¿˜è¯·çœ‹å®˜è§è°…ï¼Œä¸»è¦æ˜¯ä¸ºäº†ç†è§£Kernel DisplayåŸç†ã€‚ä¸ºäº†åŠ æ·±å¯¹æ˜¾ç¤ºå±å·¥ä½œåŸç†çš„ç†è§£ï¼Œé¦–å…ˆå…ˆçœ‹ä¸¤ä¸ªæ“ä½œLCDæ˜¾ç¤ºå±çš„ä¾‹å­ç»ªè®ºï¼ˆæ€»ä½“æ¶æ„å›¾ï¼‰ï¼š ï¼ˆä¸€ï¼‰ã€ç›´æ¥æ“ä½œframebufferæ˜¾ç¤ºå›¾åƒ1.1ã€ç›´æ¥æ“ä½œframebufferæ˜¾ç¤ºå›¾åƒ1.1.1ã€æºä»£ç panel_test.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; #include &lt;linux/fb.h&gt; #include &lt;sys/mman.h&gt; #include &lt;stdlib.h&gt;#include \"yellow_face.zif\"int main() &#123; int fbfd = 0; struct fb_var_screeninfo vinfo; struct fb_fix_screeninfo finfo; struct fb_cmap cmapinfo; long int screensize = 0; char *fbp = 0; int x = 0, y = 0; long int location = 0; int b,g,r; // Open the file for reading and writing fbfd = open(\"/dev/graphics/fb0\", O_RDWR,0); // æ‰“å¼€Frame Bufferè®¾å¤‡ if (fbfd &lt; 0) &#123; printf(\"Error: cannot open framebuffer device.%x\\n\",fbfd); exit(1); &#125; printf(\"The framebuffer device was opened successfully.\\n\"); // Get fixed screen information if (ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo)) &#123; // è·å–è®¾å¤‡å›ºæœ‰ä¿¡æ¯ printf(\"Error reading fixed information.\\n\"); exit(2); &#125; printf(\"\\ntype:0x%x\\n\", finfo.type ); // FrameBuffer ç±»å‹,å¦‚0ä¸ºè±¡ç´  printf(\"visual:%d\\n\", finfo.visual ); // è§†è§‰ç±»å‹ï¼šå¦‚çœŸå½©2ï¼Œä¼ªå½©3 printf(\"line_length:%d\\n\", finfo.line_length ); // æ¯è¡Œé•¿åº¦ printf(\"\\nsmem_start:0x%lx,smem_len:%u\\n\", finfo.smem_start, finfo.smem_len ); // æ˜ è±¡RAMçš„å‚æ•° printf(\"mmio_start:0x%lx ,mmio_len:%u\\n\", finfo.mmio_start, finfo.mmio_len ); // Get variable screen information if (ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123; // è·å–è®¾å¤‡å¯å˜ä¿¡æ¯ printf(\"Error reading variable information.\\n\"); exit(3); &#125; printf(\"%dx%d, %dbpp,xres_virtual=%d,yres_virtual=%dvinfo.xoffset=%d,vinfo.yoffset=%d\\n\", vinfo.xres, vinfo.yres, vinfo.bits_per_pixel,vinfo.xres_virtual,vinfo.yres_virtual,vinfo.xoffset,vinfo.yoffset); screensize = finfo.line_length * vinfo.yres_virtual; // Map the device to memory é€šè¿‡mmapç³»ç»Ÿè°ƒç”¨å°†framebufferå†…å­˜æ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´,å¹¶è¿”å›æ˜ å°„åçš„èµ·å§‹åœ°å€ fbp = (char *)mmap(0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED,fbfd, 0); if ((int)fbp == -1) &#123; printf(\"Error: failed to map framebuffer device to memory.\\n\"); exit(4); &#125; printf(\"The framebuffer device was mapped to memory successfully.\\n\"); /***************exampel 1**********************/ b = 10; g = 100; r = 100; for ( y = 0; y &lt; 340; y++ ) for ( x = 0; x &lt; 420; x++ ) &#123; location = (x+100) * (vinfo.bits_per_pixel/8) + (y+100) * finfo.line_length; if ( vinfo.bits_per_pixel == 32 ) &#123; // *(fbp + location) = b; // Some blue *(fbp + location + 1) = g; // A little green *(fbp + location + 2) = r; // A lot of red *(fbp + location + 3) = 0; // No transparency &#125; &#125;/*****************exampel 1********************//*****************exampel 2********************/ unsigned char *pTemp = (unsigned char *)fbp; int i, j; //èµ·å§‹åæ ‡(x,y),ç»ˆç‚¹åæ ‡(right,bottom) x = 400; y = 400; int right = 700;//vinfo.xres; int bottom = 1000;//vinfo.yres; for(i=y; i&lt; bottom; i++) &#123; for(j=x; j&lt;right; j++) &#123; unsigned short data = yellow_face_data[(((i-y) % 128) * 128) + ((j-x) %128)]; pTemp[i*finfo.line_length + (j*4) + 2] = (unsigned char)((data &amp; 0xF800) &gt;&gt; 11 &lt;&lt; 3); pTemp[i*finfo.line_length + (j*4) + 1] = (unsigned char)((data &amp; 0x7E0) &gt;&gt; 5 &lt;&lt; 2); pTemp[i*finfo.line_length + (j*4) + 0] = (unsigned char)((data &amp; 0x1F) &lt;&lt; 3); &#125; &#125; /*****************exampel 2********************/ //noteï¼švinfo.xoffset =0 vinfo.yoffset =0 å¦åˆ™FBIOPAN_DISPLAYä¸æˆåŠŸ if (ioctl(fbfd, FBIOPAN_DISPLAY, &amp;vinfo)) &#123; printf(\"Error FBIOPAN_DISPLAY information.\\n\"); exit(5); &#125; sleep(10); munmap(fbp,finfo.smem_len);//finfo.smem_len == screensize == finfo.line_length * vinfo.yres_virtual close(fbfd); return 0; &#125; Android.mk 12345678910111213141516171819# Copyright 2006-2014 The Android Open Source ProjectLOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES:= panel_test.cLOCAL_SHARED_LIBRARIES := $(common_libs) libqdutils libdl liblog libbase libcutilsLOCAL_C_INCLUDES := $(common_includes) $(kernel_includes)LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps) $(kernel_deps)LOCAL_MODULE := panel_testLOCAL_CFLAGS := -Werrorinclude $(BUILD_EXECUTABLE)include $(call first-makefiles-under,$(LOCAL_PATH)) yellow_face.zifyellow_face.zif 1.1.2ã€ç¼–è¯‘æµ‹è¯•ç¼–è¯‘ä¼šç”Ÿæˆpanel_testï¼Œç„¶åè¿›è¡Œæµ‹è¯•ã€‚ æ³¨æ„äº‹é¡¹ï¼š1ã€adb shell stop æ€æ‰surfaceflinger ä¹‹ååœ¨æµ‹è¯•ï¼›2ã€è®¾ç½®èƒŒå…‰ echo 255 &gt; /sys/class/leds/lcd-backlight/brightness 1ã€è¿æ¥adb2ã€adb push panel_test system/bin3ã€è¿›å…¥adb shell4ã€stop5ã€echo 255 &gt; /sys/class/leds/lcd-backlight/brightness6ã€system/bin/panel_test 1.1.3ã€æ˜¾ç¤ºæ•ˆæœ 1.1.4ã€è§†é¢‘ï¼ˆåŠ æ·±ç†è§£ã€è‡ªâ˜¯å¤‡â˜¯æ¢¯â˜¯å­ï¼‰Android Frame Buffer and Screen Shots TutorialMplayer on Android Through Chroot and Frame Buffer 1.1.5ã€é©±åŠ¨æ€»ä½“æ¦‚è§ˆå›¾ ï¼ˆäºŒï¼‰ã€FrameBufferé©±åŠ¨ç¨‹åºåˆ†æFrameBufferé€šå¸¸ä½œä¸ºLCDæ§åˆ¶å™¨æˆ–è€…å…¶ä»–æ˜¾ç¤ºè®¾å¤‡çš„é©±åŠ¨ï¼ŒFrameBufferé©±åŠ¨æ˜¯ä¸€ä¸ªå­—ç¬¦è®¾å¤‡ï¼Œè®¾å¤‡èŠ‚ç‚¹æ˜¯/dev/fbXï¼ˆAndroid è®¾å¤‡ä¸º/dev/graphics/fb0ï¼‰ï¼Œä¸»è®¾å¤‡å·ä¸º29ï¼Œæ¬¡è®¾å¤‡å·é€’å¢ï¼Œç”¨æˆ·å¯ä»¥å°†Framebufferçœ‹æˆæ˜¯æ˜¾ç¤ºå†…å­˜çš„ä¸€ä¸ªæ˜ åƒï¼Œå°†å…¶æ˜ å°„åˆ°è¿›ç¨‹åœ°å€ç©ºé—´ä¹‹åï¼Œå°±å¯ä»¥ç›´æ¥è¿›è¡Œè¯»å†™æ“ä½œï¼Œè€Œå†™æ“ä½œå¯ä»¥ç«‹å³ååº”åœ¨å±å¹•ä¸Šã€‚è¿™ç§æ“ä½œæ˜¯æŠ½è±¡çš„ï¼Œç»Ÿä¸€çš„ã€‚ç”¨æˆ·ä¸å¿…å…³å¿ƒç‰©ç†æ˜¾å­˜çš„ä½ç½®ã€æ¢é¡µæœºåˆ¶ç­‰ç­‰å…·ä½“ç»†èŠ‚ã€‚è¿™äº›éƒ½æ˜¯ç”±Framebufferè®¾å¤‡é©±åŠ¨æ¥å®Œæˆçš„ã€‚Framebufferè®¾å¤‡ä¸ºä¸Šå±‚åº”ç”¨ç¨‹åºæä¾›ç³»ç»Ÿè°ƒç”¨ï¼Œä¹Ÿä¸ºä¸‹ä¸€å±‚çš„ç‰¹å®šç¡¬ä»¶é©±åŠ¨æä¾›æ¥å£ï¼›é‚£äº›åº•å±‚ç¡¬ä»¶é©±åŠ¨éœ€è¦ç”¨åˆ°è¿™å„¿çš„æ¥å£æ¥å‘ç³»ç»Ÿå†…æ ¸æ³¨å†Œå®ƒä»¬è‡ªå·±ã€‚ Linuxä¸­çš„PCIè®¾å¤‡å¯ä»¥å°†å…¶æ§åˆ¶å¯„å­˜å™¨æ˜ å°„åˆ°ç‰©ç†å†…å­˜ç©ºé—´ï¼Œè€Œåï¼Œå¯¹è¿™äº›æ§åˆ¶å¯„å­˜å™¨çš„è®¿é—®å˜æˆäº†å¯¹ç†å†…å­˜çš„è®¿é—®ï¼Œå› æ­¤ï¼Œè¿™äº›å¯„å­˜å™¨åˆè¢«ç§°ä¸ºâ€memioâ€ã€‚ä¸€æ—¦è¢«æ˜ å°„åˆ°ç‰©ç†å†…å­˜ï¼ŒLinuxçš„æ™®é€šè¿›ç¨‹å°±å¯ä»¥é€šè¿‡mmapå°†è¿™äº›å†…å­˜I/Oæ˜ å°„åˆ°è¿›ç¨‹åœ°å€ç©ºé—´ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æ¥è®¿é—®è¿™äº›å¯„å­˜å™¨äº†ã€‚ FrameBufferè®¾å¤‡å±äºå­—ç¬¦è®¾å¤‡ï¼Œé‡‡ç”¨äº†æ–‡ä»¶å±‚â€”é©±åŠ¨å±‚çš„æ¥å£æ–¹å¼ï¼ŒLinuxä¸ºå¸§ç¼“å†²è®¾å¤‡å®šä¹‰äº†é©±åŠ¨å±‚çš„æ¥å£fb_infoç»“æ„ï¼Œåœ¨æ–‡ä»¶å±‚ä¸Šï¼Œç”¨æˆ·è°ƒç”¨file_operationsçš„å‡½æ•°æ“ä½œï¼Œé—´æ¥è°ƒç”¨fb_infoä¸­çš„fb_opså‡½æ•°é›†æ¥æ“ä½œç¡¬ä»¶ã€‚ 2.1ã€ Framebufferæ•°æ®ç»“æ„2.1.1ã€ fb_infofb_infoæ˜¯Linuxä¸ºå¸§ç¼“å†²è®¾å¤‡å®šä¹‰çš„é©±åŠ¨å±‚æ¥å£ã€‚å®ƒä¸ä»…åŒ…å«äº†åº•å±‚å‡½æ•°ï¼Œè€Œä¸”è¿˜æœ‰è®°å½•è®¾å¤‡çŠ¶æ€çš„æ•°æ®ã€‚æ¯ä¸ªå¸§ç¼“å†²è®¾å¤‡éƒ½ä¸ä¸€ä¸ªfb_infoç»“æ„ç›¸å¯¹åº”ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[-&gt;kernel\\include\\linux\\fb.h]struct fb_info &#123; atomic_t count; int node; int flags; struct mutex lock; /* Lock for open/release/ioctl funcs */ struct mutex mm_lock; /* Lock for fb_mmap and smem_* fields */ struct fb_var_screeninfo var; /* Current var */ struct fb_fix_screeninfo fix; /* Current fix */ struct fb_monspecs monspecs; /* Current Monitor specs */ struct work_struct queue; /* Framebuffer event queue */ struct fb_pixmap pixmap; /* Image hardware mapper */ struct fb_pixmap sprite; /* Cursor hardware mapper */ struct fb_cmap cmap; /* Current cmap */ struct list_head modelist; /* mode list */ struct fb_videomode *mode; /* current mode */ struct file *file; /* current file node */#ifdef CONFIG_FB_DEFERRED_IO struct delayed_work deferred_work; struct fb_deferred_io *fbdefio;#endif struct fb_ops *fbops; struct device *device; /* This is the parent */ struct device *dev; /* This is this fb device */ int class_flag; /* private sysfs flags */#ifdef CONFIG_FB_TILEBLITTING struct fb_tile_ops *tileops; /* Tile Blitting */#endif char __iomem *screen_base; /* Virtual address */ unsigned long screen_size; /* Amount of ioremapped VRAM or 0 */ void *pseudo_palette; /* Fake palette of 16 colors */ #define FBINFO_STATE_RUNNING 0#define FBINFO_STATE_SUSPENDED 1 u32 state; /* Hardware state i.e suspend */ void *fbcon_par; /* fbcon use-only private area */ /* From here on everything is device dependent */ void *par; /* we need the PCI or similar aperture base/size not smem_start/size as smem_start may just be an object allocated inside the aperture so may not actually overlap */ struct apertures_struct &#123; unsigned int count; struct aperture &#123; resource_size_t base; resource_size_t size; &#125; ranges[0]; &#125; *apertures; bool skip_vt_switch; /* no VT switch on suspend/resume required */&#125;; 2.1.2ã€fb_var_screeninfo fb_var_screeninfoï¼šç”¨äºè®°å½•ç”¨æˆ·å¯ä¿®æ”¹çš„æ˜¾ç¤ºæ§åˆ¶å™¨å‚æ•°ï¼ŒåŒ…æ‹¬å±å¹•åˆ†è¾¨ç‡ã€æ¯ä¸ªåƒç´ ç‚¹çš„æ¯”ç‰¹æ•°ç­‰ 12345678910111213141516171819202122232425262728293031[-&gt;\\include\\uapi\\linux\\fb.h]struct fb_var_screeninfo &#123; __u32 xres; /* è¡Œå¯è§åƒç´ */ __u32 yres; /* åˆ—å¯è§åƒç´ */ __u32 xres_virtual; /* è¡Œè™šæ‹Ÿåƒç´ */ __u32 yres_virtual; /* åˆ—è™šæ‹Ÿåƒç´ */ __u32 xoffset; /* æ°´å¹³åç§»é‡*/ __u32 yoffset; /* å‚ç›´åç§»é‡*/ __u32 bits_per_pixel;/*æ¯ä¸ªåƒç´ æ‰€å bitä½æ•°*/ __u32 grayscale; /* ç°è‰²åˆ»åº¦*/ struct fb_bitfield red; /* bitfield in fb mem if true color, */ struct fb_bitfield green; /* else only length is significant */ struct fb_bitfield blue; struct fb_bitfield transp; /* transparency */ __u32 nonstd; /* != 0 Non standard pixel format */ __u32 activate; /* see FB_ACTIVATE_* */ __u32 height; /* å›¾åƒé«˜åº¦*/ __u32 width; /* å›¾åƒå®½åº¦*/ __u32 accel_flags; /* (OBSOLETE) see fb_info.flags */ __u32 pixclock; /* pixel clock in ps (pico seconds) */ __u32 left_margin; /* time from sync to picture */ __u32 right_margin; /* time from picture to sync */ __u32 upper_margin; /* time from sync to picture */ __u32 lower_margin; __u32 hsync_len; /* length of horizontal sync */ __u32 vsync_len; /* length of vertical sync */ __u32 sync; /* see FB_SYNC_* */ __u32 vmode; /* see FB_VMODE_* */ __u32 rotate; /* angle we rotate counter clockwise */ __u32 reserved[5]; /* Reserved for future compatibility */ &#125;; 2.1.3ã€fb_fix_screeninfofb_fix_screeninfoï¼šè®°å½•äº†ç”¨æˆ·ä¸èƒ½ä¿®æ”¹çš„æ˜¾ç¤ºæ§åˆ¶å™¨çš„å‚æ•°ï¼Œè¿™äº›å‚æ•°æ˜¯åœ¨é©±åŠ¨åˆå§‹åŒ–æ—¶è®¾ç½®çš„ 123456789101112131415161718192021[-&gt;\\include\\uapi\\linux\\fb.h]struct fb_fix_screeninfo &#123; char id[16]; /* identification string eg \"TT Builtin\" */ unsigned long smem_start; /* Start of frame buffer mem */ /* (physical address) */ __u32 smem_len; /* Length of frame buffer mem */ __u32 type; /* see FB_TYPE_* */ __u32 type_aux; /* Interleave for interleaved Planes */ __u32 visual; /* see FB_VISUAL_* */ __u16 xpanstep; /* zero if no hardware panning */ __u16 ypanstep; /* zero if no hardware panning */ __u16 ywrapstep; /* zero if no hardware ywrap */ __u32 line_length; /* length of a line in bytes */ unsigned long mmio_start; /* Start of Memory Mapped I/O */ /* (physical address) */ __u32 mmio_len; /* Length of Memory Mapped I/O */ __u32 accel; /* Indicate to driver which */ /* specific chip/card we have */ __u16 capabilities; /* see FB_CAP_* */ __u16 reserved[2]; /* Reserved for future compatibility */&#125;; fb_opsæ˜¯æä¾›ç»™åº•å±‚è®¾å¤‡é©±åŠ¨çš„ä¸€ä¸ªæ¥å£ã€‚å½“æˆ‘ä»¬ç¼–å†™ä¸€ä¸ªFrameBufferçš„æ—¶å€™ï¼Œå°±è¦ä¾ç…§Linux FrameBufferç¼–ç¨‹çš„å¥—è·¯ï¼Œå¡«å†™fb_opsç»“æ„ä½“ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081[-&gt;\\include\\linux\\fb.h]struct fb_ops &#123; /* open/release and usage marking */ struct module *owner; int (*fb_open)(struct fb_info *info, int user); int (*fb_release)(struct fb_info *info, int user); /* For framebuffers with strange non linear layouts or that do not * work with normal memory mapped access */ ssize_t (*fb_read)(struct fb_info *info, char __user *buf, size_t count, loff_t *ppos); ssize_t (*fb_write)(struct fb_info *info, const char __user *buf, size_t count, loff_t *ppos); /* checks var and eventually tweaks it to something supported, * DO NOT MODIFY PAR */ int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info); /* set the video mode according to info-&gt;var */ int (*fb_set_par)(struct fb_info *info); /* set color register */ int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, struct fb_info *info); /* set color registers in batch */ int (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info); /* blank display */ int (*fb_blank)(int blank, struct fb_info *info); /* pan display */ int (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info); /* Draws a rectangle */ void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect); /* Copy data from area to another */ void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region); /* Draws a image to the display */ void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image); /* Draws cursor */ int (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor); /* Rotates the display */ void (*fb_rotate)(struct fb_info *info, int angle); /* wait for blit idle, optional */ int (*fb_sync)(struct fb_info *info); /* perform fb specific ioctl (optional) */ int (*fb_ioctl)(struct fb_info *info, unsigned int cmd, unsigned long arg); /* perform fb specific ioctl v2 (optional) - provides file param */ int (*fb_ioctl_v2)(struct fb_info *info, unsigned int cmd, unsigned long arg, struct file *file); /* Handle 32bit compat ioctl (optional) */ int (*fb_compat_ioctl)(struct fb_info *info, unsigned cmd, unsigned long arg); /* Handle 32bit compat ioctl (optional) */ int (*fb_compat_ioctl_v2)(struct fb_info *info, unsigned cmd, unsigned long arg, struct file *file); /* perform fb specific mmap */ int (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma); /* get capability given var */ void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps, struct fb_var_screeninfo *var); /* teardown any resources to do with this framebuffer */ void (*fb_destroy)(struct fb_info *info); /* called at KDB enter and leave time to prepare the console */ int (*fb_debug_enter)(struct fb_info *info); int (*fb_debug_leave)(struct fb_info *info);&#125;; 2.2ã€Framebufferé©±åŠ¨æ³¨å†Œè¿‡ç¨‹åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œå†…æ ¸è°ƒç”¨æ‰€æœ‰æ³¨å†Œé©±åŠ¨ç¨‹åºçš„é©±åŠ¨ç¨‹åºåˆå§‹åŒ–å‡½æ•°ã€‚ ä¸ºäº†å¸§ç¼“å†²åŒºé©±åŠ¨ç¨‹åºï¼Œè°ƒç”¨mdss_fb_initã€‚ mdss_fb_initæ³¨å†Œmdss_fb_driverã€‚é©±åŠ¨åœ¨mdss_fb.cæ–‡ä»¶ä¸­æ³¨å†Œã€‚ 12345678910111213[-\\drivers\\video\\msm\\mdss\\mdss_fb.c]static struct platform_driver mdss_fb_driver = &#123; .probe = mdss_fb_probe, .remove = mdss_fb_remove, .suspend = mdss_fb_suspend, .resume = mdss_fb_resume, .shutdown = mdss_fb_shutdown, .driver = &#123; .name = \"mdss_fb\", .of_match_table = mdss_fb_dt_match, .pm = &amp;mdss_fb_pm_ops, &#125;,&#125;; åœ¨è°ƒç”¨initä¹‹åï¼Œå†…æ ¸è°ƒç”¨æ¯ä¸ªå¹³å°é©±åŠ¨ç¨‹åºçš„æ¢æµ‹å‡½æ•°ã€‚ åœ¨è°ƒç”¨mdss_fb_probeæ—¶ï¼Œå‡½æ•°æ‰§è¡Œèµ„æºåˆ†é…å¹¶è°ƒç”¨mdss_fb_registerã€‚ å¯ä»¥æœ‰å¤šä¸ªå¸§ç¼“å†²åŒºï¼ˆfbï¼‰è®¾å¤‡ï¼ˆèŠ‚ç‚¹ï¼‰ã€‚ è¯¥é©±åŠ¨ç¨‹åºé€šè¿‡è°ƒç”¨mdss_fb_registeræ¥æ³¨å†Œå„ä¸ªfbè®¾å¤‡ï¼Œåè€…åˆè°ƒç”¨register_framebufferã€‚ HDMIå’Œä¸»æ˜¾ç¤ºå™¨æ˜¯å„ä¸ªfbè®¾å¤‡çš„ä¾‹å­ã€‚ ä»¥ä¸‹æ“ä½œå·²æ³¨å†Œï¼š é¦–å…ˆçœ‹ä¸€ä¸‹mdss_fb_probe()å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536[-&gt;\\drivers\\video\\msm\\mdss\\mdss_fb.c]static int mdss_fb_probe(struct platform_device *pdev)&#123; struct msm_fb_data_type *mfd = NULL; struct mdss_panel_data *pdata; struct fb_info *fbi; int rc; pdata = dev_get_platdata(&amp;pdev-&gt;dev); /* * alloc framebuffer info + par data */ fbi = framebuffer_alloc(sizeof(struct msm_fb_data_type), NULL); mfd = (struct msm_fb_data_type *)fbi-&gt;par; mfd-&gt;key = MFD_KEY; mfd-&gt;fbi = fbi; mfd-&gt;panel_info = &amp;pdata-&gt;panel_info; mfd-&gt;panel.type = pdata-&gt;panel_info.type; mfd-&gt;panel.id = mfd-&gt;index; mfd-&gt;fb_page = MDSS_FB_NUM; mfd-&gt;index = fbi_list_index; mfd-&gt;mdp_fb_page_protection = MDP_FB_PAGE_PROTECTION_WRITECOMBINE; mfd-&gt;ext_ad_ctrl = -1; ...... platform_set_drvdata(pdev, mfd); rc = mdss_fb_register(mfd); ...... return rc;&#125; é¦–å…ˆè°ƒç”¨framebuffer_alloc()å‡½æ•°è¿”å›ä¸€ä¸ªfb_info ç»“æ„ä½“ï¼Œç„¶åè°ƒç”¨mdss_fb_register(mfd)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132[-&gt;\\drivers\\video\\msm\\mdss\\mdss_fb.c]static int mdss_fb_register(struct msm_fb_data_type *mfd)&#123; int ret = -ENODEV; int bpp; char panel_name[20]; struct mdss_panel_info *panel_info = mfd-&gt;panel_info; struct fb_info *fbi = mfd-&gt;fbi; struct fb_fix_screeninfo *fix; struct fb_var_screeninfo *var; int *id; /* * fb info initialization */ fix = &amp;fbi-&gt;fix; var = &amp;fbi-&gt;var; fix-&gt;type_aux = 0; /* if type == FB_TYPE_INTERLEAVED_PLANES */ fix-&gt;visual = FB_VISUAL_TRUECOLOR; /* True Color */ fix-&gt;ywrapstep = 0; /* No support */ fix-&gt;mmio_start = 0; /* No MMIO Address */ fix-&gt;mmio_len = 0; /* No MMIO Address */ fix-&gt;accel = FB_ACCEL_NONE;/* FB_ACCEL_MSM needes to be added in fb.h */ var-&gt;xoffset = 0, /* Offset from virtual to visible */ var-&gt;yoffset = 0, /* resolution */ var-&gt;grayscale = 0, /* No graylevels */ var-&gt;nonstd = 0, /* standard pixel format */ var-&gt;activate = FB_ACTIVATE_VBL, /* activate it at vsync */ var-&gt;height = -1, /* height of picture in mm */ var-&gt;width = -1, /* width of picture in mm */ var-&gt;accel_flags = 0, /* acceleration flags */ var-&gt;sync = 0, /* see FB_SYNC_* */ var-&gt;rotate = 0, /* angle we rotate counter clockwise */ mfd-&gt;op_enable = false; switch (mfd-&gt;fb_imgType) &#123; case MDP_RGB_565: ...... var-&gt;transp.offset = 0; var-&gt;transp.length = 0; bpp = 2; break; case MDP_RGB_888: ...... var-&gt;transp.offset = 0; var-&gt;transp.length = 0; bpp = 3; break; case MDP_ARGB_8888: ...... var-&gt;transp.offset = 0; var-&gt;transp.length = 8; bpp = 4; break; case MDP_RGBA_8888: ...... var-&gt;transp.offset = 24; var-&gt;transp.length = 8; bpp = 4; break; case MDP_YCRYCB_H2V1: ...... var-&gt;transp.offset = 0; var-&gt;transp.length = 0; bpp = 2; break; default: return ret; &#125; mdss_panelinfo_to_fb_var(panel_info, var); fix-&gt;type = panel_info-&gt;is_3d_panel; if (mfd-&gt;mdp.fb_stride) fix-&gt;line_length = mfd-&gt;mdp.fb_stride(mfd-&gt;index, var-&gt;xres, bpp); else fix-&gt;line_length = var-&gt;xres * bpp; var-&gt;xres_virtual = var-&gt;xres; var-&gt;yres_virtual = panel_info-&gt;yres * mfd-&gt;fb_page; var-&gt;bits_per_pixel = bpp * 8; /* FrameBuffer color depth */ /* * Populate smem length here for uspace to get the * Framebuffer size when FBIO_FSCREENINFO ioctl is called. */ fix-&gt;smem_len = PAGE_ALIGN(fix-&gt;line_length * var-&gt;yres) * mfd-&gt;fb_page; /* id field for fb app */ id = (int *)&amp;mfd-&gt;panel; snprintf(fix-&gt;id, sizeof(fix-&gt;id), \"mdssfb_%x\", (u32) *id); fbi-&gt;fbops = &amp;mdss_fb_ops; fbi-&gt;flags = FBINFO_FLAG_DEFAULT; fbi-&gt;pseudo_palette = mdss_fb_pseudo_palette; mfd-&gt;ref_cnt = 0; mfd-&gt;panel_power_state = MDSS_PANEL_POWER_OFF; mfd-&gt;dcm_state = DCM_UNINIT; if (mdss_fb_alloc_fbmem(mfd)) pr_warn(\"unable to allocate fb memory in fb register\\n\"); ...... ret = fb_alloc_cmap(&amp;fbi-&gt;cmap, 256, 0); if (ret) pr_err(\"fb_alloc_cmap() failed!\\n\"); if (register_framebuffer(fbi) &lt; 0) &#123; fb_dealloc_cmap(&amp;fbi-&gt;cmap); mfd-&gt;op_enable = false; return -EPERM; &#125; snprintf(panel_name, ARRAY_SIZE(panel_name), \"mdss_panel_fb%d\", mfd-&gt;index); mdss_panel_debugfs_init(panel_info, panel_name); pr_info(\"FrameBuffer[%d] %dx%d registered successfully!\\n\", mfd-&gt;index, fbi-&gt;var.xres, fbi-&gt;var.yres); return 0;&#125; ä»»ä½•ä¸€ä¸ªç‰¹å®šç¡¬ä»¶Framebufferé©±åŠ¨åœ¨åˆå§‹åŒ–æ—¶éƒ½å¿…é¡»å‘fbmem.cæ³¨å†Œï¼ŒFrameBufferæ¨¡å—æä¾›äº†é©±åŠ¨æ³¨å†Œæ¥å£å‡½æ•°register_framebufferï¼š 123456789101112[-&gt;\\drivers\\video\\fbdev\\core\\fbmem.c]intregister_framebuffer(struct fb_info *fb_info)&#123; int ret; mutex_lock(&amp;registration_lock); ret = do_register_framebuffer(fb_info); mutex_unlock(&amp;registration_lock); return ret;&#125; å‚æ•°fb_infoæè¿°ç‰¹å®šç¡¬ä»¶çš„FrameBufferé©±åŠ¨ä¿¡æ¯ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[-&gt;\\drivers\\video\\fbdev\\core\\fbmem.c]static int do_register_framebuffer(struct fb_info *fb_info) &#123; int i; struct fb_event event; struct fb_videomode mode; if (fb_check_foreignness(fb_info)) return -ENOSYS; //æ ¹æ®å½“å‰æ³¨å†Œçš„fb_infoçš„apertureså±æ€§ä»FrameBufferé©±åŠ¨æ•°ç»„registered_fbä¸­æŸ¥è¯¢æ˜¯å¦å­˜åœ¨å†²çª do_remove_conflicting_framebuffers(fb_info-&gt;apertures, fb_info-&gt;fix.id, fb_is_primary_device(fb_info)); //åˆ¤æ–­å·²æ³¨å†Œçš„é©±åŠ¨æ˜¯å¦è¶…è¿‡32ä¸ªFrameBufferé©±åŠ¨ if (num_registered_fb == FB_MAX) return -ENXIO; //å¢åŠ å·²æ³¨å†Œçš„é©±åŠ¨ä¸ªæ•° num_registered_fb++; //ä»æ•°ç»„registered_fbä¸­æŸ¥æ‰¾ç©ºé—²å…ƒç´ ï¼Œç”¨äºå­˜å‚¨å½“å‰æ³¨å†Œçš„fb_info for (i = 0 ; i &lt; FB_MAX; i++) if (!registered_fb[i]) break; //å°†å½“å‰æ³¨å†Œçš„fb_infoåœ¨æ•°ç»„registered_fbä¸­çš„ç´¢å¼•ä½ç½®ä¿å­˜åˆ°fb_info-&gt;node fb_info-&gt;node = i; //åˆå§‹åŒ–å½“å‰æ³¨å†Œçš„fb_infoçš„æˆå‘˜ä¿¡æ¯ atomic_set(&amp;fb_info-&gt;count, 1); mutex_init(&amp;fb_info-&gt;lock); mutex_init(&amp;fb_info-&gt;mm_lock); //åœ¨/devç›®å½•ä¸‹åˆ›å»ºä¸€ä¸ªfbxçš„è®¾å¤‡æ–‡ä»¶ï¼Œæ¬¡è®¾å¤‡å·å°±æ˜¯è¯¥fb_infoåœ¨æ•°ç»„registered_fbä¸­çš„ç´¢å¼• fb_info-&gt;dev = device_create(fb_class, fb_info-&gt;device,MKDEV(FB_MAJOR, i), NULL, \"fb%d\", i); if (IS_ERR(fb_info-&gt;dev)) &#123; printk(KERN_WARNING \"Unable to create device for framebuffer %d; errno = %ld\\n\", i, PTR_ERR(fb_info-&gt;dev)); fb_info-&gt;dev = NULL; &#125; else //åˆå§‹åŒ–fb_info fb_init_device(fb_info); if (fb_info-&gt;pixmap.addr == NULL) &#123; fb_info-&gt;pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL); if (fb_info-&gt;pixmap.addr) &#123; fb_info-&gt;pixmap.size = FBPIXMAPSIZE; fb_info-&gt;pixmap.buf_align = 1; fb_info-&gt;pixmap.scan_align = 1; fb_info-&gt;pixmap.access_align = 32; fb_info-&gt;pixmap.flags = FB_PIXMAP_DEFAULT; &#125; &#125; fb_info-&gt;pixmap.offset = 0; if (!fb_info-&gt;pixmap.blit_x) fb_info-&gt;pixmap.blit_x = ~(u32)0; if (!fb_info-&gt;pixmap.blit_y) fb_info-&gt;pixmap.blit_y = ~(u32)0; if (!fb_info-&gt;modelist.prev || !fb_info-&gt;modelist.next) INIT_LIST_HEAD(&amp;fb_info-&gt;modelist); fb_var_to_videomode(&amp;mode, &amp;fb_info-&gt;var); fb_add_videomode(&amp;mode, &amp;fb_info-&gt;modelist); //å°†ç‰¹å®šç¡¬ä»¶å¯¹åº”çš„fb_infoæ³¨å†Œåˆ°registered_fbæ•°ç»„ä¸­ registered_fb[i] = fb_info; event.info = fb_info; if (!lock_fb_info(fb_info)) return -ENODEV; //ä½¿ç”¨Linuxäº‹ä»¶é€šçŸ¥æœºåˆ¶å‘é€ä¸€ä¸ªFrameBufferæ³¨å†Œäº‹ä»¶FB_EVENT_FB_REGISTERED fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &amp;event); unlock_fb_info(fb_info); return 0; &#125; æ³¨å†Œè¿‡ç¨‹å°±æ˜¯å°†æŒ‡å®šçš„è®¾å¤‡é©±åŠ¨ä¿¡æ¯fb_infoå­˜æ”¾åˆ°registered_fbæ•°ç»„ä¸­ã€‚å› æ­¤åœ¨æ³¨å†Œå…·ä½“çš„fb_infoæ—¶ï¼Œé¦–å…ˆè¦æ„é€ ä¸€ä¸ªfb_infoæ•°æ®ç»“æ„ï¼Œå¹¶åˆå§‹åŒ–è¯¥æ•°æ®ç»“æ„ï¼Œè¯¥ç»“æ„ç”¨äºæè¿°ä¸€ä¸ªç‰¹å®šçš„FrameBufferé©±åŠ¨ã€‚ ï¼ˆä¸‰ï¼‰ã€MDP driverMDPä¹Ÿè¢«æ³¨å†Œä¸ºå¹³å°é©±åŠ¨ç¨‹åºã€‚ mdp3_driver_initæ‰§è¡Œé©±åŠ¨ç¨‹åºinitã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149[-&gt;\\drivers\\video\\msm\\mdss\\mdp3.c]static struct platform_driver mdp3_driver = &#123; .probe = mdp3_probe, .remove = mdp3_remove, .suspend = mdp3_suspend, .resume = mdp3_resume, .shutdown = NULL, .driver = &#123; .name = \"mdp3\", .of_match_table = mdp3_dt_match, .pm = &amp;mdp3_pm_ops, &#125;,&#125;;static int __init mdp3_driver_init(void)&#123; int ret; ret = platform_driver_register(&amp;mdp3_driver); if (ret) &#123; pr_err(\"register mdp3 driver failed!\\n\"); return ret; &#125; return 0;&#125;static int mdp3_probe(struct platform_device *pdev)&#123; int rc; static struct msm_mdp_interface mdp3_interface = &#123; .init_fnc = mdp3_init, .fb_mem_get_iommu_domain = mdp3_fb_mem_get_iommu_domain, .panel_register_done = mdp3_panel_register_done, .fb_stride = mdp3_fb_stride, .check_dsi_status = mdp3_check_dsi_ctrl_status, &#125;; struct mdp3_intr_cb underrun_cb = &#123; .cb = mdp3_dma_underrun_intr_handler, .data = NULL, &#125;; pr_debug(\"%s: START\\n\", __func__); if (!pdev-&gt;dev.of_node) &#123; pr_err(\"MDP driver only supports device tree probe\\n\"); return -ENOTSUPP; &#125; if (mdp3_res) &#123; pr_err(\"MDP already initialized\\n\"); return -EINVAL; &#125; mdp3_res = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct mdp3_hw_resource), GFP_KERNEL); if (mdp3_res == NULL) return -ENOMEM; pdev-&gt;id = 0; mdp3_res-&gt;pdev = pdev; mutex_init(&amp;mdp3_res-&gt;res_mutex); spin_lock_init(&amp;mdp3_res-&gt;irq_lock); platform_set_drvdata(pdev, mdp3_res); atomic_set(&amp;mdp3_res-&gt;active_intf_cnt, 0); mutex_init(&amp;mdp3_res-&gt;reg_bus_lock); INIT_LIST_HEAD(&amp;mdp3_res-&gt;reg_bus_clist); mdp3_res-&gt;mdss_util = mdss_get_util_intf(); if (mdp3_res-&gt;mdss_util == NULL) &#123; pr_err(\"Failed to get mdss utility functions\\n\"); rc = -ENODEV; goto get_util_fail; &#125; mdp3_res-&gt;mdss_util-&gt;get_iommu_domain = mdp3_get_iommu_domain; mdp3_res-&gt;mdss_util-&gt;iommu_attached = is_mdss_iommu_attached; mdp3_res-&gt;mdss_util-&gt;iommu_ctrl = mdp3_iommu_ctrl; mdp3_res-&gt;mdss_util-&gt;bus_scale_set_quota = mdp3_bus_scale_set_quota; mdp3_res-&gt;mdss_util-&gt;panel_intf_type = mdp3_panel_intf_type; mdp3_res-&gt;mdss_util-&gt;dyn_clk_gating_ctrl = mdp3_dynamic_clock_gating_ctrl; mdp3_res-&gt;mdss_util-&gt;panel_intf_type = mdp3_panel_intf_type; mdp3_res-&gt;mdss_util-&gt;panel_intf_status = mdp3_panel_get_intf_status; rc = mdp3_parse_dt(pdev); if (rc) goto probe_done; rc = mdp3_res_init(); if (rc) &#123; pr_err(\"unable to initialize mdp3 resources\\n\"); goto probe_done; &#125; mdp3_res-&gt;fs_ena = false; mdp3_res-&gt;fs = devm_regulator_get(&amp;pdev-&gt;dev, \"vdd\"); if (IS_ERR_OR_NULL(mdp3_res-&gt;fs)) &#123; pr_err(\"unable to get mdss gdsc regulator\\n\"); return -EINVAL; &#125; rc = mdp3_debug_init(pdev); if (rc) &#123; pr_err(\"unable to initialize mdp debugging\\n\"); goto probe_done; &#125; pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, AUTOSUSPEND_TIMEOUT_MS); if (mdp3_res-&gt;idle_pc_enabled) &#123; pr_debug(\"%s: Enabling autosuspend\\n\", __func__); pm_runtime_use_autosuspend(&amp;pdev-&gt;dev); &#125; /* Enable PM runtime */ pm_runtime_set_suspended(&amp;pdev-&gt;dev); pm_runtime_enable(&amp;pdev-&gt;dev); if (!pm_runtime_enabled(&amp;pdev-&gt;dev)) &#123; rc = mdp3_footswitch_ctrl(1); if (rc) &#123; pr_err(\"unable to turn on FS\\n\"); goto probe_done; &#125; &#125; rc = mdp3_check_version(); if (rc) &#123; pr_err(\"mdp3 check version failed\\n\"); goto probe_done; &#125; rc = mdp3_register_sysfs(pdev); if (rc) pr_err(\"unable to register mdp sysfs nodes\\n\"); rc = mdss_fb_register_mdp_instance(&amp;mdp3_interface); if (rc) pr_err(\"unable to register mdp instance\\n\"); rc = mdp3_set_intr_callback(MDP3_INTR_LCDC_UNDERFLOW, &amp;underrun_cb); if (rc) pr_err(\"unable to configure interrupt callback\\n\"); rc = mdss_smmu_init(mdss_res, &amp;pdev-&gt;dev); if (rc) pr_err(\"mdss smmu init failed\\n\"); mdp3_res-&gt;mdss_util-&gt;mdp_probe_done = true; pr_debug(\"%s: END\\n\", __func__); return rc;&#125; å†…æ ¸è°ƒç”¨MDPæ¢æµ‹å‡½æ•°mdp3_probeã€‚ åœ¨æ¢æµ‹å™¨ä¸Šï¼Œé©±åŠ¨ç¨‹åºä»è®¾å¤‡æ ‘ä¸­è·å–é¢æ¿ä¿¡æ¯ï¼Œå¹¶é€šè¿‡è°ƒç”¨mdp3_parse_dtæ¥è§£æä¿¡æ¯ã€‚ åœ¨mdp3_ctrl_onæœŸé—´ï¼ŒMDPé©±åŠ¨ç¨‹åºè°ƒç”¨mdp3_ctrl_res_req_clkå¹¶è¯·æ±‚MDPå’ŒVsyncæ—¶é’Ÿã€‚ åœ¨mdp3_ctrl_offæœŸé—´ï¼Œé©±åŠ¨ç¨‹åºè¯·æ±‚å…³é—­MDPå’ŒVsyncæ—¶é’Ÿã€‚ ï¼ˆå››ï¼‰ã€DSI controller driver ï¼ˆlcdé©±åŠ¨ dsiï¼‰msm_dsi_v2_driver_initæ‰§è¡Œé©±åŠ¨ç¨‹åºåˆå§‹åŒ–ã€‚ msm_dsi_v2_driver_initè°ƒç”¨ msm_dsi_v2_register_driveræ³¨å†Œé©±åŠ¨ç¨‹åºã€‚æ€»ä½“æ—¶åºå›¾ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102[-&gt;\\drivers\\video\\msm\\mdss\\dsi_host_v2.c]static struct platform_driver msm_dsi_v2_driver = &#123; .probe = msm_dsi_probe, .remove = msm_dsi_remove, .shutdown = NULL, .driver = &#123; .name = \"msm_dsi_v2\", .of_match_table = msm_dsi_v2_dt_match, &#125;,&#125;;static int msm_dsi_v2_register_driver(void)&#123; return platform_driver_register(&amp;msm_dsi_v2_driver);&#125;static int msm_dsi_probe(struct platform_device *pdev)&#123; struct dsi_interface intf; char panel_cfg[MDSS_MAX_PANEL_LEN]; struct mdss_dsi_ctrl_pdata *ctrl_pdata = NULL; int rc = 0; struct device_node *dsi_pan_node = NULL; bool cmd_cfg_cont_splash = false; struct resource *mdss_dsi_mres; int i; pr_debug(\"%s\\n\", __func__); rc = msm_dsi_init(); pdev-&gt;id = 0; ctrl_pdata = platform_get_drvdata(pdev); if (!ctrl_pdata) &#123; ctrl_pdata = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct mdss_dsi_ctrl_pdata), GFP_KERNEL); platform_set_drvdata(pdev, ctrl_pdata); &#125; ctrl_pdata-&gt;mdss_util = mdss_get_util_intf(); if (mdp3_res-&gt;mdss_util == NULL) &#123; pr_err(\"Failed to get mdss utility functions\\n\"); return -ENODEV; &#125; mdss_dsi_mres = platform_get_resource(pdev, IORESOURCE_MEM, 0); if (!mdss_dsi_mres) &#123; &#125; else &#123; dsi_host_private-&gt;dsi_reg_size = resource_size(mdss_dsi_mres); dsi_host_private-&gt;dsi_base = ioremap(mdss_dsi_mres-&gt;start, dsi_host_private-&gt;dsi_reg_size); &#125; mdss_dsi_mres = platform_get_resource(pdev, IORESOURCE_IRQ, 0); rc = of_platform_populate(pdev-&gt;dev.of_node, NULL, NULL, &amp;pdev-&gt;dev); /* DSI panels can be different between controllers */ rc = dsi_get_panel_cfg(panel_cfg); /* find panel device node */ dsi_pan_node = dsi_find_panel_of_node(pdev, panel_cfg); cmd_cfg_cont_splash = mdp3_panel_get_boot_cfg() ? true : false; rc = mdss_dsi_panel_init(dsi_pan_node, ctrl_pdata, cmd_cfg_cont_splash); rc = dsi_ctrl_config_init(pdev, ctrl_pdata); msm_dsi_parse_lane_swap(pdev-&gt;dev.of_node, &amp;(ctrl_pdata-&gt;dlane_swap)); for (i = 0; i &lt; DSI_MAX_PM; i++) &#123; rc = msm_dsi_io_init(pdev, &amp;(ctrl_pdata-&gt;power_data[i])); &#125; pr_debug(\"%s: Dsi Ctrl-&gt;0 initialized\\n\", __func__); dsi_host_private-&gt;dis_dev = pdev-&gt;dev; intf.on = msm_dsi_on; intf.off = msm_dsi_off; intf.cont_on = msm_dsi_cont_on; intf.clk_ctrl = msm_dsi_clk_ctrl; intf.op_mode_config = msm_dsi_op_mode_config; intf.index = 0; intf.private = NULL; dsi_register_interface(&amp;intf); msm_dsi_debug_init(); msm_dsi_ctrl_init(ctrl_pdata); rc = msm_dsi_irq_init(&amp;pdev-&gt;dev, mdss_dsi_mres-&gt;start, ctrl_pdata); rc = dsi_panel_device_register_v2(pdev, ctrl_pdata); pr_debug(\"%s success\\n\", __func__); return 0;&#125; å†…æ ¸è°ƒç”¨msm_dsi_probeã€‚ é¢æ¿è¢«æ£€æµ‹åˆ°ã€‚ msm_dsi_probeè°ƒç”¨mdss_dsi_panel_initå‡½æ•°ã€‚ mdss_dsi_panel_initè°ƒç”¨mdss_panel_parse_dtæ¥è·å–é¢æ¿å‚æ•°ã€‚MDPé©±åŠ¨ç¨‹åºä½¿ç”¨è¯¥äº‹ä»¶ä¸DSIé©±åŠ¨ç¨‹åºè¿›è¡Œé€šä¿¡ã€‚ DSIé©±åŠ¨ç¨‹åºå…·æœ‰mdss_dsi_event_handlerï¼Œè¿™æ˜¯MDPæ ¸å¿ƒäº‹ä»¶çš„å›è°ƒå¤„ç†ç¨‹åºã€‚ mdss_panel.hå®šä¹‰äº†MDPæ ¸å¿ƒäº‹ä»¶ã€‚ 1234567891011121314151617181920212223242526272829303132[-&gt;\\drivers\\video\\msm\\mdss\\mdss_panel.h]enum mdss_intf_events &#123; MDSS_EVENT_RESET = 1, MDSS_EVENT_LINK_READY, MDSS_EVENT_UNBLANK, MDSS_EVENT_PANEL_ON, MDSS_EVENT_POST_PANEL_ON, MDSS_EVENT_BLANK, MDSS_EVENT_PANEL_OFF, MDSS_EVENT_CLOSE, MDSS_EVENT_SUSPEND, MDSS_EVENT_RESUME, MDSS_EVENT_CHECK_PARAMS, MDSS_EVENT_CONT_SPLASH_BEGIN, MDSS_EVENT_CONT_SPLASH_FINISH, MDSS_EVENT_PANEL_UPDATE_FPS, MDSS_EVENT_FB_REGISTERED, MDSS_EVENT_PANEL_CLK_CTRL, MDSS_EVENT_DSI_CMDLIST_KOFF, MDSS_EVENT_ENABLE_PARTIAL_ROI, MDSS_EVENT_DSC_PPS_SEND, MDSS_EVENT_DSI_STREAM_SIZE, MDSS_EVENT_DSI_UPDATE_PANEL_DATA, MDSS_EVENT_REGISTER_RECOVERY_HANDLER, MDSS_EVENT_REGISTER_MDP_CALLBACK, MDSS_EVENT_DSI_PANEL_STATUS, MDSS_EVENT_DSI_DYNAMIC_SWITCH, MDSS_EVENT_DSI_RECONFIG_CMD, MDSS_EVENT_DSI_RESET_WRITE_PTR, MDSS_EVENT_PANEL_TIMING_SWITCH, MDSS_EVENT_MAX,&#125;; åœ¨msm_dsi_onæœŸé—´ï¼Œé€šè¿‡è°ƒç”¨msm_dsi_clk_enableæ‰“å¼€DSIæ—¶é’Ÿã€‚ åœ¨msm_dsi_offæœŸé—´ï¼Œé€šè¿‡è°ƒç”¨msm_dsi_clk_disableå…³é—­clksã€‚ ï¼ˆäº”ï¼‰ã€ Panel driver ï¼ˆé¢æ¿ dsiï¼‰MDSS : Multimedia Display sub systemDSI: Display Serial Interface qcom,mdss-dsi-force-clock-lane-hs; // faulse ï¼šclockæ¯å¸§å›lp11ture: clockä¸å› qcom,mdss-dsi-hfp-power-mode; // data æ¯è¡Œå›lp11,å¯¹åº”çš„hfpè¦ä¿®æ”¹æˆ300ä»¥ä¸Š é¢æ¿ä¿¡æ¯ä½äºkernel\\arch\\arm\\boot\\dts\\ä¸­çš„.dtsiæ–‡ä»¶ä¸­ã€‚ è¿™åŒ…å«æ‰€æœ‰é¢æ¿ç‰¹å®šçš„å‘½ä»¤ï¼Œä¾‹å¦‚onï¼Œoffå’Œresetï¼ˆmdss-dsi-on-commandï¼Œmdss-dsi-off-commandï¼Œmdss-dsi-reset-sequenceï¼‰ï¼ŒBLæ§åˆ¶å’Œå…¶ä»–é¢æ¿ ç‹¬ç«‹å‚æ•°ã€‚ä¾‹å¦‚ï¼šmsm8610-mdss.dtsi ï¼ˆæ–‡ä»¶åé€šå¸¸ä¸º msmxxx-mdss.dtsi æŒ‡å®šäº†mdss çš„ mdp å’Œ dsiï¼‰ 5.1ã€.dtsiæ–‡ä»¶è§£æ1234567891011mdss_mdp: qcom,mdss_mdp@fd900000 &#123; compatible = \"qcom,mdss_mdp3\"; // å¯¹åº”mdssé©±åŠ¨ mdss_mdp.c---------- mdss_dsi0: qcom,mdss_dsi@fdd00000 &#123; compatible = \"qcom,msm-dsi-v2\"; // å¯¹åº”dsiè§£æé©±åŠ¨ dsi_host_v2.cæˆ–è€… mdss_dsi0: qcom,mdss_dsi_ctrl0@1a94000 &#123; compatible = \"qcom,mdss-dsi-ctrl\"; // å¯¹åº”dsiè§£æé©±åŠ¨ mdss_dsi.c é€šè¿‡ä¸‹é¢å‡½æ•°å‘ mdss_fb.c æ³¨å†Œäº†fb_infoç»“æ„ (åŒ…å«åœ¨mdss_dsi_ctrl_pdataç»“æ„ä¸­) 1234567891011drivers\\video\\msm\\mdss\\dsi_host_v2.c ï¼ˆlcdé©±åŠ¨ dsiï¼‰dsi_panel_device_register_v2(struct platform_device *dev,struct mdss_dsi_ctrl_pdata *ctrl_pdata)static const struct of_device_id msm_dsi_v2_dt_match[] = &#123; &#123;.compatible = &quot;qcom,msm-dsi-v2&quot;&#125;, &#123;&#125;&#125;;æˆ–è€… drivers\\video\\msm\\mdss\\mdss_dsi.c msm8610-asus.dts ï¼ˆæŒ‡å®šmdpä¸­çš„å“ªä¸€ä¸ªé…ç½®ï¼‰é€šå¸¸åœ¨dtsæ–‡ä»¶çš„ mdss_dsi0 labé‡Œé¢é€šè¿‡ qcom,dsi-pref-prim-pan å±æ€§ æŒ‡å®šä½¿ç”¨å“ªä¸€ä¸ªlcdé…ç½® 123&amp;mdss_dsi0 &#123; qcom,dsi-pref-prim-pan = &lt;&amp;dsi_fl10802_fwvga_vid&gt;;&#125;; dsi-panel-fl10802-fwvga-video.dtsi 123456789&amp;mdss_mdp &#123; dsi_fl10802_fwvga_vid: qcom,mdss_dsi_fl10802_fwvga_video &#123; qcom,mdss-dsi-panel-name = &quot;fl10802 fwvga video mode dsi panel&quot;; qcom,mdss-dsi-drive-ic = &quot;fl10802&quot;; qcom,mdss-dsi-panel-controller = &lt;&amp;mdss_dsi0&gt;; qcom,mdss-dsi-panel-type = &quot;dsi_video_mode&quot;; qcom,mdss-dsi-panel-destination = &quot;display_1&quot;; ... &#125; 5.2ã€mdss_mdp å’Œ mdss_dsi0 çš„å…³ç³»mdss_mdp ç›¸å½“äºä¸€ä¸ªæ•°ç»„ï¼Œé‡Œé¢å®šä¹‰äº†å¾ˆå¤šä¸åŒlcdæ˜¾ç¤ºå±çš„é…ç½®é¡¹åŒ…æ‹¬åˆ†è¾¨ç‡ç­‰ç­‰ é¢æ¿é©±åŠ¨ç¨‹åºå¯ä»¥æ ¹æ®è¿æ¥çš„å®é™…é¢æ¿æ•°é‡å…·æœ‰å¤šä¸ªèŠ‚ç‚¹ã€‚mdss_register_panelæ³¨å†Œé¢æ¿é©±åŠ¨ç¨‹åºï¼šmsm_dsi_probeâ†’dsi_panel_device_register_v2â†’mdss_register_panelâ†’of_platform_device_createä»¥ä¸‹é¢æ¿æ§åˆ¶åŠŸèƒ½å¯ç”¨å¹¶åœ¨mdss_dsi_panel_initä¸­åˆå§‹åŒ–ï¼šctrl_pdataâ†’on = mdss_dsi_panel_on;ctrl_pdataâ†’off = mdss_dsi_panel_off;ctrl_pdataâ†’panel_data.set_backlight = mdss_dsi_panel_bl_ctrl; ä¾‹å¦‚ï¼Œåœ¨mdp3_ctrl.cä¸­ï¼Œå‡½æ•°mdp3_ctrl_onï¼ˆï¼‰ä¼šè°ƒç”¨ä»¥ä¸‹DSIå¤„ç†ç¨‹åºMDSS_EVENT_UNBLANKå’ŒMDSS_EVENT_PANEL_ONäº‹ä»¶å¦‚ä¸‹æ‰€ç¤ºï¼šrc = panelâ†’event_handlerï¼ˆpanelï¼ŒMDSS_EVENT_UNBLANKï¼ŒNULLï¼‰;rc | =é¢æ¿â†’event_handlerï¼ˆé¢æ¿ï¼ŒMDSS_EVENT_PANEL_ONï¼ŒNULLï¼‰; 5.3ã€é€šè¿‡å†…æ ¸æ¥å£æ‰“å¼€å’Œå…³é—­æ˜¾ç¤ºå™¨5.3.1ã€å¯åŠ¨ æŒ‰ç…§ä¸Šé¢çš„éƒ¨åˆ†æ‰€è¿°æ³¨å†Œè®¾å¤‡åï¼šmdss_fb_openâ†’mdss_fb_blank_subâ†’pdataâ†’onï¼ˆé¢æ¿ONåŠŸèƒ½ï¼‰æ³¨æ„ï¼šå¯¹äºå‘½ä»¤æ¨¡å¼é¢æ¿ï¼Œå¦‚æœé¢æ¿åœ¨å¯åŠ¨æ—¶å·²æ‰“å¼€ï¼Œåˆ™ä¼šè·³è¿‡è¯¥å¯åŠ¨åºåˆ— ä»¥é¿å…å…³é—­/ -onçš„æ–‡ç‰©ã€‚ 5.3.2ã€æš‚åœ/æ¢å¤æŒ‚èµ·/æ¢å¤æ—¶ï¼Œè°ƒç”¨fbé©±åŠ¨ç¨‹åºæŒ‚èµ·/æ¢å¤å’ŒMDPé©±åŠ¨ç¨‹åºæŒ‚èµ·/æ¢å¤ã€‚ fbé©±åŠ¨ç¨‹åºä¾æ¬¡è°ƒç”¨é¢æ¿é©±åŠ¨ç¨‹åºçš„å¼€/å…³åŠŸèƒ½ã€‚ 5.3.2.1ã€æš‚åœåºåˆ— Kernelcallâ†’mdss_fb_release_allâ†’mdss_fb_blankâ†’mdss_fb_blank_subâ†’mdp3_ctrl_offâ†’mdp3_ctrl_offå‘é€ä¸¤ä¸ªäº‹ä»¶ï¼š MDSS_EVENT_PANEL_OFF - dsi_event_handleræ¥æ”¶äº‹ä»¶ã€‚ å½“äº‹ä»¶å‘ç”Ÿæ—¶æ¥æ”¶åˆ°æ—¶ï¼Œè°ƒç”¨å°ç»„å…³é—­åºåˆ—ã€‚ MDSS_EVENT_BLANK - è¯¥äº‹ä»¶ç”±è°ƒç”¨çš„dsi_event_handlerå¤„ç†mdss_dsi_offã€‚ Kernelcallâ†’mdp3_suspend - æœªä½¿ç”¨5.3.2.2ã€æ¢å¤åºåˆ— Kernelcallâ†’mdss_fb_blankâ†’mdss_fb_blank_subâ†’mdp3_ctrl_onâ†’mdp3_ctrl_onå‘é€ä¸¤ä¸ªäº‹ä»¶ï¼š MDSS_EVENT_UNBLANK - dsi_event_handleræ¥æ”¶äº‹ä»¶ã€‚ å½“äº‹ä»¶å‘ç”Ÿæ—¶æ”¶åˆ°ï¼ŒDSI-onè¢«è°ƒç”¨ã€‚ MDSS_EVENT_PANEL_ON - äº‹ä»¶ç”±dsi_event_handlerå¤„ç†ï¼Œdsi_event_handlerå‘é€é¢æ¿ä¸Šçš„åºåˆ—ã€‚Kernelcallâ†’mdp3_resume - æœªä½¿ç”¨ 5.4ã€å›¾åƒæ›´æ–°åˆ°é¢æ¿ ç”¨æˆ·å¿…é¡»ç¡®ä¿MSMFB_OVERLAY_SET IOCTLåœ¨å‘¼å«ä¹‹å‰è‡³å°‘è¢«è°ƒç”¨ä¸€æ¬¡ åˆ°MSMFB_OVERLAY_PLAY IOCLTï¼ˆä¾‹å¦‚ioctl(fd, MSMFB_OVERLAY_PLAY, &amp;od)ï¼‰ã€‚MSMFB_OVERLAY_PLAYé˜Ÿåˆ—ç¼“å†²åŒº æ˜¾ç¤ºåœ¨é¢æ¿ä¸Šã€‚ ç”¨æˆ·ä½¿ç”¨MSMFB_DISPLAY_COMMITè°ƒç”¨fb IOCLTã€‚è¿™ä¼šå¯åŠ¨ä¸€ä¸ªå‘¼å« mdss_fb_display_commit å¹¶å®‰æ’å·¥ä½œé˜Ÿåˆ—ã€‚æ­¤å·¥ä½œé˜Ÿåˆ—å¤„ç†ç¨‹åºè°ƒç”¨ msm_fb_pan_display_exï¼Œç„¶åè°ƒç”¨mdp3_ctrl_pan_displayã€‚ mdss_fb_ioctlâ†’ï¼ˆMSMFB_DISPLAY_COMMITï¼‰â†’mdss_fb_display_commitâ†’ mdss_fb_pan_display_exâ†’è®¡åˆ’å·¥ä½œmdss_fb_commit_wq_handler msm_fb_commit_wq_handlerâ†’mdp3_ctrl_display_commit_kickoffâ†’mdp3_dmap_updateä¸€æ¬¡å‘¼å«åï¼Œå¯ä»¥æœ‰å¤šä¸ªå¯¹PLAYå’ŒCOMMIT IOCLTçš„å‘¼å« MSMFB_OVERLAY_SET IOCTLã€‚é¢æ¿æ›´æ–°å®Œæˆå¹¶ä¸”è®¾å¤‡å®Œæˆåéœ€è¦è¿›å…¥æŒ‚èµ·æˆ–å…³é—­çŠ¶æ€ï¼Œç”¨æˆ·å¯ä»¥è°ƒç”¨MSMFB_OVERLAY_UNSETã€‚ æ³¨æ„ï¼šå·¥ä½œé˜Ÿåˆ—æ¶æ„æ­£åœ¨è¢«å³å°†å‘å¸ƒçš„çº¿ç¨‹å–ä»£ï¼Œè¿™äº›æ–‡ä»¶æœªè¢«æ•è·ã€‚è§†é¢‘å’Œå‘½ä»¤æ¨¡å¼é¢æ¿çš„é¢æ¿æ›´æ–°ç•¥æœ‰ä¸åŒã€‚ä¸ºäº†åœ¨å‘½ä»¤æ¨¡å¼é¢æ¿ä¸­ï¼Œmdp3_dmap_updateå‡½æ•°ä¼šç­‰å¾…ï¼Œç›´åˆ°å‰ä¸€ä¸ªå›¾åƒæ›´æ–°ä¸ºæ­¢å®Œæˆä½¿ç”¨MDP DMAå¼€å§‹æ–°å¸§æ›´æ–° ifï¼ˆdma-&gt; output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMDï¼‰{cb_type = MDP3_DMA_CALLBACK_TYPE_DMA_DONE;å¦‚æœï¼ˆintf-&gt; activeï¼‰wait_for_completion_killableï¼ˆDMA-&gt; dma_compï¼‰; å¯¹äºè§†é¢‘é¢æ¿ï¼Œåœ¨DMAè§¦å‘åï¼Œmdp3_dmap_updateç­‰å¾…vsyncã€‚ ï¼ˆå…­ï¼‰ã€Msm8610 lcd driver å†…æ ¸åˆå§‹åŒ–åˆ†æè¯·å‚è€ƒã€msm8610 lcd driver code analysisã€‘ ï¼ˆä¸ƒï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼š(à¹‘ä¹›â—¡ä¹›à¹‘) ã€ï¼ˆ Í¡Â° ÍœÊ– Í¡Â°ï¼‰ã€ï¼ˆà²¡Ï‰à²¡ï¼‰ï¼ï¼ï¼ç´¯~~~æ—¶è‡³ä»Šæ—¥ï¼Œç»ˆäºå®Œæ•´çš„åˆ†æäº†Android Display System æ€»ä½“æ¡†æ¶æµç¨‹ï¼Œä¸ç¦æ„Ÿå¹è®¡ç®—æœºä¸–ç•Œçš„åšå¤§ç²¾æ·±ï¼Œåœ¨è¿™ä¸ªç³»åˆ—çš„åˆ†æä¸­å†ç»ƒäº†å¦‚ä½•æ‹†è§£åˆ†æä¸€ä¸ªåºå¤§å¤æ‚çš„æ¨¡å—ã€å­¦ä¹ æ”¶è·è‰¯å¤šï¼ŒåŒæ—¶ä¹Ÿäº†è§£äº†è‡ªèº«çŸ¥è¯†çš„æ¬ ç¼ºï¼Œç”±äºæ¶‰åŠçŸ¥è¯†è¾ƒå¤šè¾ƒå¹¿ï¼Œåšä¸»ä¹Ÿæœªèƒ½å®Œå…¨åƒé€ï¼Œå…¶ä¸­åˆ†ææœ‰è¯¯çš„åœ°æ–¹è¿˜è¯·å„ä½è§è°…ã€‚æ‰€è°“è·¯æ¼«æ¼«å…¶ä¿®è¿œå…®ï¼Œå¾å°†ä¸Šä¸‹è€Œæ±‚ç´¢ã€‚Todoï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ï¼ŒMultimedia System ä»»è¿˜æœ‰è®¸å¤šæœªè§£ä¹‹æƒ‘ï¼Œéœ€æ¶è¡¥Linuxå†…æ ¸çŸ¥è¯†ï¼Œå°‘å¹´ï¼ŒåŠ æ²¹ï¼ˆâ½â½â½ï¼‰ ï¼ˆå…«ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šGraphics Stack Updateé«˜é€šAndroidå¹³å°-åº”ç”¨ç©ºé—´æ“ä½œframebuffer dump LCDæ€»ç»“msm8610 lcd driver code analysislinux qcom LCD framworkQualcommå¹³å° display bring up è¿‡ç¨‹è¯¦è§£é«˜é€š8x25å¹³å°displayæ¨¡å—æ€»ç»“Android ä¸­çš„ framebufferFrameBufferé©±åŠ¨ç¨‹åºåˆ†æAndroid Framebufferä»‹ç»åŠä½¿ç”¨Android å›¾å½¢ç³»ç»Ÿ","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc && HWComposeræ¨¡å—åˆ†æ","slug":"Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc && HWComposeræ¨¡å—åˆ†æ","date":"2018-08-15T16:00:00.000Z","updated":"2018-06-20T15:16:27.801Z","comments":true,"path":"2018/08/16/Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc && HWComposeræ¨¡å—åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/08/16/Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc && HWComposeræ¨¡å—åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ ã€ç‰¹åˆ«æ„Ÿè°¢ - Androidç ”ç©¶ Gralloc &amp;&amp; HWComposerç³»åˆ—åˆ†æã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android display ç³»åˆ—åˆ†æã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Androidå›¾å½¢æ˜¾ç¤ºä¹‹ç¡¬ä»¶æŠ½è±¡å±‚Grallocã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ğŸŒ€ğŸŒ€ï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ ã€Android Display System ç³»ç»Ÿåˆ†æç³»åˆ—ã€‘ï¼šã€Android Display Systemï¼ˆ1ï¼‰ï¼šAndroid 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æã€‘ã€Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL &amp;&amp; OpenGLã€‘ã€Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.draw()ç»˜åˆ¶æµç¨‹åˆ†æã€‘ã€Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc &amp;&amp; HWComposeræ¨¡å—åˆ†æã€‘ã€Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architectureã€‘ \\hardware\\libhardware\\include\\hardware fb.h \\hardware\\libhardware\\modules\\gralloc framebuffer.cpp gralloc.cpp gralloc_priv.h gr.h mapper.cpp \\hardware\\qcom\\display\\msm8996\\libgralloc alloc_controller.cpp framebuffer.cpp gpu.cpp gralloc.cpp ionalloc.cpp mapper.cpp \\hardware\\qcom\\display\\msm8996\\libgralloc1 gr_adreno_info.cpp gr_allocator.cpp gr_buf_mgr.cpp gr_device_impl.cpp gr_ion_alloc.cpp gr_utils.cpp \\frameworks\\native\\services\\surfaceflinger DisplayDevice.cpp SurfaceFlinger.cpp MonitoredProducer.cpp SurfaceFlingerConsumer.cpp SurfaceFlinger_hwc1.cpp Client.cpp DispSync.cpp EventControlThread.cpp EventThread.cpp Layer.cpp MessageQueue.cpp \\frameworks\\native\\services\\surfaceflinger\\DisplayHardware FramebufferSurface.cpp HWC2.cpp HWC2On1Adapter.cpp HWComposer.cpp HWComposer_hwc1.cpp Linuxç³»ç»Ÿä¸‹çš„æ˜¾ç¤ºé©±åŠ¨æ¡†æ¶ï¼Œæ¯ä¸ªæ˜¾ç¤ºå±è¢«æŠ½è±¡ä¸ºä¸€ä¸ªå¸§ç¼“å†²åŒºï¼Œæ³¨å†Œåˆ°FrameBufferæ¨¡å—ä¸­ï¼Œå¹¶åœ¨/dev/graphicsç›®å½•ä¸‹åˆ›å»ºå¯¹åº”çš„fbXè®¾å¤‡ã€‚Androidç³»ç»Ÿåœ¨ç¡¬ä»¶æŠ½è±¡å±‚ä¸­æä¾›äº†ä¸€ä¸ªGrallocæ¨¡å—ï¼Œå°è£…äº†å¯¹å¸§ç¼“å†²åŒºçš„æ‰€æœ‰è®¿é—®æ“ä½œã€‚ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºåœ¨ä½¿ç”¨å¸§ç¼“å†²åŒºä¹‹é—´ï¼Œé¦–å…ˆè¦åŠ è½½Grallocæ¨¡å—ï¼Œå¹¶ä¸”è·å¾—ä¸€ä¸ªgrallocè®¾å¤‡å’Œä¸€ä¸ªfbè®¾å¤‡ã€‚æœ‰äº†grallocè®¾å¤‡ä¹‹åï¼Œç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ç¨‹åºå°±å¯ä»¥ç”³è¯·åˆ†é…ä¸€å—å›¾å½¢ç¼“å†²åŒºï¼Œå¹¶ä¸”å°†è¿™å—å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°åº”ç”¨ç¨‹åºçš„åœ°å€ç©ºé—´æ¥ï¼Œä»¥ä¾¿å¯ä»¥å‘é‡Œé¢å†™å…¥è¦ç»˜åˆ¶çš„ç”»é¢çš„å†…å®¹ã€‚æœ€åï¼Œç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ç¨‹åºå°±é€šè¿‡fbè®¾å¤‡æ¥å°†å·²ç»å‡†å¤‡å¥½äº†çš„å›¾å½¢ç¼“å†²åŒºæ¸²æŸ“åˆ°å¸§ç¼“å†²åŒºä¸­å»ï¼Œå³å°†å›¾å½¢ç¼“å†²åŒºçš„å†…å®¹ç»˜åˆ¶åˆ°æ˜¾ç¤ºå±ä¸­å»ã€‚ç›¸åº”åœ°ï¼Œå½“ç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ç¨‹åºä¸å†éœ€è¦ä½¿ç”¨ä¸€å—å›¾å½¢ç¼“å†²åŒºçš„æ—¶å€™ï¼Œå°±å¯ä»¥é€šè¿‡grallocè®¾å¤‡æ¥é‡Šæ”¾å®ƒï¼Œå¹¶ä¸”å°†å®ƒä»åœ°å€ç©ºé—´ä¸­è§£é™¤æ˜ å°„ã€‚ é«˜é€šMSM8996 Grallocæ¨¡å— å®ç°æºç ä½äºï¼š\\hardware\\qcom\\display\\msm8996\\libgrallocæ¯ä¸ªç¡¬ä»¶æŠ½è±¡å±‚æ¨¡å—éƒ½å¿…é¡»å®šä¹‰HAL_MODULE_INFO_SYMç¬¦å·ï¼Œå¹¶ä¸”æœ‰è‡ªå·±å”¯ä¸€çš„IDï¼ŒGrallocä¹Ÿä¸ä¾‹å¤–ï¼ŒGrallocæ¨¡å—IDå®šä¹‰ä¸ºï¼š 12345[-&gt;/hardware/libhardware/include/hardware/gralloc.h]/** * The id of this module */#define GRALLOC_HARDWARE_MODULE_ID \"gralloc\" åŒæ—¶å®šä¹‰äº†ä»¥HAL_MODULE_INFO_SYMä¸ºç¬¦å·çš„ç±»å‹ä¸º private_module_tçš„ç»“æ„ä½“ï¼š 12345678910111213141516171819202122232425262728293031323334hardware\\libhardware\\modules\\gralloc\\gralloc.cpp// HAL module methodsstatic struct hw_module_methods_t gralloc_module_methods = &#123; .open = gralloc_device_open&#125;;// HAL module initializestruct private_module_t HAL_MODULE_INFO_SYM = &#123; .base = &#123; .common = &#123; .tag = HARDWARE_MODULE_TAG, .version_major = 1, .version_minor = 0, .id = GRALLOC_HARDWARE_MODULE_ID, .name = \"Graphics Memory Allocator Module\", .author = \"The Android Open Source Project\", .methods = &amp;gralloc_module_methods, .dso = 0, .reserved = &#123;0&#125;, &#125;, .registerBuffer = gralloc_register_buffer, .unregisterBuffer = gralloc_unregister_buffer, .lock = gralloc_lock, .unlock = gralloc_unlock, .perform = gralloc_perform, .lock_ycbcr = gralloc_lock_ycbcr, &#125;, .framebuffer = 0, .fbFormat = 0, .flags = 0, .numBuffers = 0, .bufferMask = 0, .lock = PTHREAD_MUTEX_INITIALIZER,&#125;; é€šè¿‡Grallocæ¨¡å—åŠ è½½ åˆ†æçš„æ–¹æ³•å°†Grallocæ¨¡å—åŠ è½½åˆ°å†…å­˜ä¸­æ¥ä¹‹åï¼Œå°±å¯ä»¥è°ƒç”¨å‡½æ•°dlsymæ¥è·å¾—å®ƒæ‰€å¯¼å‡ºçš„ç¬¦å·HMIï¼Œå¾—åˆ°private_module_tçš„é¦–åœ°å€åï¼Œç”±äºprivate_module_tçš„ç¬¬ä¸€ä¸ªæˆå‘˜å˜é‡çš„ç±»å‹ä¸ºgralloc_module_tï¼Œå› æ­¤ä¹Ÿæ˜¯gralloc_module_tçš„é¦–åœ°å€ï¼Œç”±äºgralloc_module_tçš„ç¬¬ä¸€ä¸ªæˆå‘˜å˜é‡ç±»å‹ä¸ºhw_module_tï¼Œå› æ­¤ä¹Ÿæ˜¯hw_module_tçš„é¦–åœ°å€ï¼Œå› æ­¤åªè¦å¾—åˆ°è¿™ä¸‰ç§ç±»å‹ä¸­å…¶ä¸­ä¸€ç§ç±»å‹å˜é‡çš„åœ°å€ï¼Œå°±å¯ä»¥ç›¸äº’è½¬æ¢ä¸ºå…¶ä»–ä¸¤ç§ç±»å‹çš„æŒ‡é’ˆã€‚ ï¼ˆä¸€ï¼‰ã€Grallocæ¨¡å— æ•°æ®ç»“æ„åœ¨åˆ†æGrallocæ¨¡å—ä¹‹å‰ï¼Œé¦–å…ˆä»‹ç»Grallocæ¨¡å—å®šä¹‰çš„ä¸€äº›æ•°æ®ç»“æ„ã€‚private_module_tç”¨äºæè¿°Grallocæ¨¡å—ä¸‹çš„ç³»ç»Ÿå¸§ç¼“å†²åŒºä¿¡æ¯12345678910111213141516[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\fb_priv.h]struct private_module_t &#123; gralloc_module_t base; struct private_handle_t* framebuffer;//æŒ‡å‘ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„å¥æŸ„ uint32_t fbFormat; uint32_t flags;//ç”¨æ¥æ ‡å¿—ç³»ç»Ÿå¸§ç¼“å†²åŒºæ˜¯å¦æ”¯æŒåŒç¼“å†² uint32_t numBuffers;//è¡¨ç¤ºç³»ç»Ÿå¸§ç¼“å†²åŒºåŒ…å«æœ‰å¤šå°‘ä¸ªå›¾å½¢ç¼“å†²åŒº uint32_t bufferMask;//è®°å½•ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­çš„å›¾å½¢ç¼“å†²åŒºçš„ä½¿ç”¨æƒ…å†µ pthread_mutex_t lock;//ä¸€ä¸ªäº’æ–¥é”ï¼Œç”¨æ¥ä¿æŠ¤ç»“æ„ä½“private_module_tçš„å¹¶è¡Œè®¿é—® struct fb_var_screeninfo info;//ä¿å­˜è®¾å¤‡æ˜¾ç¤ºå±çš„åŠ¨æ€å±æ€§ä¿¡æ¯ struct fb_fix_screeninfo finfo;//ä¿å­˜è®¾å¤‡æ˜¾ç¤ºå±çš„å›ºå®šå±æ€§ä¿¡æ¯ float xdpi;//æè¿°è®¾å¤‡æ˜¾ç¤ºå±åœ¨å®½åº¦ float ydpi;//æè¿°è®¾å¤‡æ˜¾ç¤ºå±åœ¨é«˜åº¦ float fps;//ç”¨æ¥æè¿°æ˜¾ç¤ºå±çš„åˆ·æ–°é¢‘ç‡ uint32_t swapInterval;&#125;; framebuffer_device_tç”¨æ¥æè¿°ç³»ç»Ÿå¸§ç¼“å†²åŒºè®¾å¤‡çš„ä¿¡æ¯ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[-&gt;/hardware/libhardware/include/hardware/fb.h]typedef struct framebuffer_device_t &#123; /** * Common methods of the framebuffer device. This *must* be the first member of * framebuffer_device_t as users of this structure will cast a hw_device_t to * framebuffer_device_t pointer in contexts where it's known the hw_device_t references a * framebuffer_device_t. */ struct hw_device_t common; //ç”¨æ¥è®°å½•ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„æ ‡å¿— const uint32_t flags; //ç”¨æ¥æè¿°è®¾å¤‡æ˜¾ç¤ºå±çš„å®½åº¦ã€é«˜åº¦ const uint32_t width; const uint32_t height; //ç”¨æ¥æè¿°è®¾å¤‡æ˜¾ç¤ºå±çš„ä¸€è¡Œæœ‰å¤šå°‘ä¸ªåƒç´ ç‚¹ const int stride; //ç”¨æ¥æè¿°ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„åƒç´ æ ¼å¼ const int format; //ç”¨æ¥æè¿°è®¾å¤‡æ˜¾ç¤ºå±åœ¨å®½åº¦ä¸Šçš„å¯†åº¦ã€å¯†åº¦ const float xdpi; const float ydpi; //ç”¨æ¥æè¿°è®¾å¤‡æ˜¾ç¤ºå±çš„åˆ·æ–°é¢‘ç‡ const float fps; //ç”¨æ¥è®¾ç½®å¸§ç¼“å†²åŒºäº¤æ¢å‰åä¸¤ä¸ªå›¾å½¢ç¼“å†²åŒºçš„æœ€å°å’Œæœ€å¤§æ—¶é—´é—´éš” const int minSwapInterval; const int maxSwapInterval; /* Number of framebuffers supported*/ const int numFramebuffers; int reserved[7]; //ç”¨æ¥è®¾ç½®å¸§ç¼“å†²åŒºäº¤æ¢å‰åä¸¤ä¸ªå›¾å½¢ç¼“å†²åŒºçš„æœ€å°å’Œæœ€å¤§æ—¶é—´é—´éš” int (*setSwapInterval)(struct framebuffer_device_t* window, int interval); //ç”¨æ¥è®¾ç½®å¸§ç¼“å†²åŒºçš„æ›´æ–°åŒºåŸŸ int (*setUpdateRect)(struct framebuffer_device_t* window, int left, int top, int width, int height); //ç”¨æ¥å°†å›¾å½¢ç¼“å†²åŒºbufferçš„å†…å®¹æ¸²æŸ“åˆ°å¸§ç¼“å†²åŒºä¸­å» int (*post)(struct framebuffer_device_t* dev, buffer_handle_t buffer); //ç”¨æ¥é€šçŸ¥fbè®¾å¤‡ï¼Œå›¾å½¢ç¼“å†²åŒºçš„ç»„åˆå·¥ä½œå·²ç»å®Œæˆ int (*compositionComplete)(struct framebuffer_device_t* dev); void (*dump)(struct framebuffer_device_t* dev, char *buff, int buff_len); int (*enableScreen)(struct framebuffer_device_t* dev, int enable); void* reserved_proc[6];&#125; framebuffer_device_t; gralloc_module_tç”¨äºæè¿°grallocæ¨¡å—ä¿¡æ¯ 12345678910111213141516171819202122[-&gt;\\hardware\\libhardware\\include\\hardware\\gralloc.h]typedef struct gralloc_module_t &#123; struct hw_module_t common; //æ˜ å°„ä¸€å—å›¾å½¢ç¼“å†²åŒºåˆ°ä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´å» int (*registerBuffer)(struct gralloc_module_t const* module, buffer_handle_t handle); //å–æ¶ˆæ˜ å°„ä¸€å—å›¾å½¢ç¼“å†²åŒºåˆ°ä¸€ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´å» int (*unregisterBuffer)(struct gralloc_module_t const* module, buffer_handle_t handle); int (*lock)(struct gralloc_module_t const* module, buffer_handle_t handle, int usage, int l, int t, int w, int h, void** vaddr); int (*unlock)(struct gralloc_module_t const* module, buffer_handle_t handle); ...... /* reserved for future use */ void* reserved_proc[3];&#125; gralloc_module_t; alloc_device_tç”¨äºæè¿°grallocè®¾å¤‡çš„ä¿¡æ¯ 123456789101112131415[-&gt;\\hardware\\libhardware\\include\\hardware\\gralloc.h]typedef struct alloc_device_t &#123; struct hw_device_t common; int (*alloc)(struct alloc_device_t* dev, int w, int h, int format, int usage, buffer_handle_t* handle, int* stride); int (*free)(struct alloc_device_t* dev, buffer_handle_t handle); void (*dump)(struct alloc_device_t *dev, char *buff, int buff_len); void* reserved_proc[7];&#125; alloc_device_t; 123456789101112[-&gt;/hardware/libhardware/include/hardware/hardware.h]typedef struct hw_module_t &#123; uint32_t tag;//æ ‡ç­¾ uint16_t version_major;//æ¨¡å—ä¸»è®¾å¤‡å· uint16_t version_minor;//æ¨¡å—æ¬¡è®¾å¤‡å· const char *id;//æ¨¡å—ID const char *name;//æ¨¡å—åç§° const char *author;//æ¨¡å—ä½œè€… struct hw_module_methods_t* methods;//æ¨¡å—æ“ä½œæ–¹æ³• void* dso;//ä¿å­˜æ¨¡å—é¦–åœ°å€ uint32_t reserved[32-7];//ä¿ç•™ä½ &#125; hw_module_t; æ¨¡å— è®¾å¤‡ ä½œç”¨ private_module_t framebuffer_device_t å°†å›¾å½¢ç¼“å†²å™¨æ˜ å°„åˆ°å¸§ç¼“å†²åŒº gralloc_module_t alloc_module_t åˆ†é…æˆ–é‡Šæ”¾å›¾å½¢ç¼“å†²åŒº hw_module_t hw_module_t å…³è”è®¾å¤‡å’Œæ¨¡å— ç¡¬ä»¶æŠ½è±¡å±‚Grallocæ¨¡å—å®šä¹‰äº†è®¾å¤‡fbå’Œè®¾å¤‡gpuï¼š 1234[-&gt;\\hardware\\libhardware\\include\\hardware\\fb.h]#define GRALLOC_HARDWARE_FB0 \"fb0\"[-&gt;/hardware/libhardware/include/hardware/gralloc.h]#define GRALLOC_HARDWARE_GPU0 \"gpu0\" è®¾å¤‡gpuç”¨äºåˆ†é…å›¾å½¢ç¼“å†²åŒºï¼Œè€Œè®¾å¤‡fbç”¨äºæ¸²æŸ“å›¾å½¢ç¼“å†²åŒºï¼›hw_module_tç”¨äºæè¿°ç¡¬ä»¶æŠ½è±¡å±‚Grallocæ¨¡å—ï¼Œè€Œhw_device_tåˆ™ç”¨äºæè¿°ç¡¬ä»¶æŠ½è±¡å±‚Grallocè®¾å¤‡ï¼Œé€šè¿‡ç¡¬ä»¶æŠ½è±¡å±‚è®¾å¤‡å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„ç¡¬ä»¶æŠ½è±¡å±‚æ¨¡å—ã€‚åœ¨Grallocæ¨¡å—ä¸­ï¼Œæ— è®ºæ˜¯å®šä¹‰fbè®¾å¤‡è¿˜æ˜¯gpuè®¾å¤‡ï¼Œéƒ½æ˜¯ç”¨æ¥å¤„ç†å›¾å½¢ç¼“å†²åŒºï¼Œä»¥ä¸‹æ˜¯å…³äºç¼“å†²åŒºçš„æ•°æ®ç»“æ„ å®šä¹‰ï¼šprivate_handle_tç”¨æ¥æè¿°ä¸€å—ç¼“å†²åŒºï¼ŒAndroidå¯¹ç¼“å†²åŒºçš„å®šä¹‰æä¾›äº†Cå’ŒC++ä¸¤ç§æ–¹å¼ï¼ŒC++ï¼š12345678910111213141516171819202122232425[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\gralloc_priv.h]struct private_handle_t : public native_handle &#123;#else struct private_handle_t &#123; native_handle_t nativeHandle;#endif enum &#123; PRIV_FLAGS_FRAMEBUFFER = 0x00000001, ...... &#125;; // file-descriptors int fd; int fd_metadata; // fd for the meta-data // ints int magic; int flags; unsigned int size; unsigned int offset; int bufferType; ...... int format; int width; int height; ...... ä¸¤ç§ç¼–è¯‘å™¨ä¸‹çš„private_handle_tå®šä¹‰éƒ½ç»§æ‰¿äºnative_handleï¼Œnative_handleçš„å®šä¹‰å¦‚ä¸‹ï¼š 123456789[-&gt;/system/core/include/cutils/native_handle.h]typedef struct native_handle &#123; int version; //è®¾ç½®ä¸ºç»“æ„ä½“native_handle_tçš„å¤§å°ï¼Œç”¨æ¥æ ‡è¯†ç»“æ„ä½“native_handle_tçš„ç‰ˆæœ¬ int numFds; //è¡¨ç¤ºç»“æ„ä½“native_handle_tæ‰€åŒ…å«çš„æ–‡ä»¶æè¿°ç¬¦çš„ä¸ªæ•°ï¼Œè¿™äº›æ–‡ä»¶æè¿°ç¬¦ä¿å­˜åœ¨æˆå‘˜å˜é‡dataæ‰€æŒ‡å‘çš„ä¸€å—ç¼“å†²åŒºä¸­ã€‚ int numInts; //è¡¨ç¤ºç»“æ„ä½“native_handle_tæ‰€åŒ…å«çš„æ•´æ•°å€¼çš„ä¸ªæ•°ï¼Œè¿™äº›æ•´æ•°ä¿å­˜åœ¨æˆå‘˜å˜é‡dataæ‰€æŒ‡å‘çš„ä¸€å—ç¼“å†²åŒºä¸­ã€‚ int data[0]; //æŒ‡å‘çš„ä¸€å—ç¼“å†²åŒºä¸­ &#125; native_handle_t; typedef const native_handle_t* buffer_handle_t; ä¸‹é¢å°±åˆ†æGrallocæ¨¡å—ä¸­å®šä¹‰äº†ä¸¤ç§è®¾å¤‡çš„æ‰“å¼€è¿‡ç¨‹ã€‚ ï¼ˆäºŒï¼‰ã€Fbè®¾å¤‡æ‰“å¼€è¿‡ç¨‹Fbè®¾å¤‡æ‰“å¼€è¿‡ç¨‹æ˜¯ä»SurfaceFlinger.init()å‡½æ•°é€šè¿‡HWComposerå¯¹è±¡åˆå§‹åŒ–è¿‡ç¨‹ä¸­æ‰“å¼€çš„ 1234567891011121314151617181920[-&gt;\\frameworks\\native\\services\\surfaceflinger\\SurfaceFlinger_hwc1.cpp]void SurfaceFlinger::init() &#123; // initialize EGL for the default display mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); eglInitialize(mEGLDisplay, NULL, NULL); // start the EventThread sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true, \"app\"); mEventThread = new EventThread(vsyncSrc, *this); sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, true, \"sf\"); mSFEventThread = new EventThread(sfVsyncSrc, *this); mEventQueue.setEventThread(mSFEventThread); ...... // Initialize the H/W composer object. There may or may not be an // actual hardware composer underneath. mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this)); ...... çœ‹çœ‹HWComposeræ„é€ å‡½æ•° 1234567891011121314151617181920212223HWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false)&#123; ...... // Note: some devices may insist that the FB HAL be opened before HWC. int fberr = loadFbHalModule(); loadHwcModule(); ......&#125;int HWComposer::loadFbHalModule()&#123; hw_module_t const* module; int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module); ...... return framebuffer_open(module, &amp;mFbDev);&#125; Androidç³»ç»Ÿåœ¨ç¡¬ä»¶æŠ½è±¡å±‚ä¸­æä¾›äº†ä¸€ä¸ªGrallocæ¨¡å—ï¼Œå°è£…äº†å¯¹framebufferçš„æ‰€æœ‰è®¿é—®æ“ä½œã€‚Grallocæ¨¡å—ç¬¦åˆAndroidæ ‡å‡†çš„HALæ¶æ„è®¾è®¡ã€‚Grallocå¯¹åº”çš„hardware idä¸ºï¼šGRALLOC_HARDWARE_MODULE_ID 123456[-&gt;\\hardware\\libhardware\\include\\hardware\\fb.h]static inline int framebuffer_open(const struct hw_module_t* module, struct framebuffer_device_t** device) &#123; return module-&gt;methods-&gt;open(module, GRALLOC_HARDWARE_FB0, (struct hw_device_t**)device);&#125; ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºåœ¨ä½¿ç”¨å¸§ç¼“å†²åŒºä¹‹å‰ï¼Œé¦–å…ˆè¦åŠ è½½Grallocæ¨¡å—ï¼Œå¹¶ä¸”è·å¾—ä¸€ä¸ªgpu0è®¾å¤‡(gralloc_device, modulename:GRALLOC_HARDWARE_GPU0)å’Œä¸€ä¸ªfb0è®¾å¤‡(modulename:GRALLOC_HARDWARE_FB0)ã€‚ æœ‰äº†allocè®¾å¤‡ä¹‹åï¼Œç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ç¨‹åºå°±å¯ä»¥ç”³è¯·åˆ†é…ä¸€å—å›¾å½¢ç¼“å†²åŒºï¼Œå¹¶ä¸”å°†è¿™å—å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°åº”ç”¨ç¨‹åºçš„åœ°å€ç©ºé—´æ¥ï¼Œä»¥ä¾¿å¯ä»¥å‘é‡Œé¢å†™å…¥è¦ç»˜åˆ¶çš„ç”»é¢çš„å†…å®¹ã€‚æœ€åï¼Œç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ç¨‹åºå°±é€šè¿‡fb0è®¾å¤‡æ¥å°†å·²ç»å‡†å¤‡å¥½äº†çš„å›¾å½¢ç¼“å†²åŒºæ¸²æŸ“åˆ°å¸§ç¼“å†²åŒºä¸­å»ï¼Œå³å°†å›¾å½¢ç¼“å†²åŒºçš„å†…å®¹ç»˜åˆ¶åˆ°æ˜¾ç¤ºå±ä¸­å»ã€‚ç›¸åº”åœ°ï¼Œå½“ç”¨æˆ·ç©ºé—´ä¸­çš„åº”ç”¨ç¨‹åºä¸å†éœ€è¦ä½¿ç”¨ä¸€å—å›¾å½¢ç¼“å†²åŒºçš„æ—¶å€™ï¼Œå°±å¯ä»¥é€šè¿‡allocè®¾å¤‡æ¥é‡Šæ”¾å®ƒï¼Œå¹¶ä¸”å°†å®ƒä»åœ°å€ç©ºé—´ä¸­è§£é™¤æ˜ å°„ã€‚ 1234567891011121314151617181920212223[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\gralloc.cpp]// Open Gralloc deviceint gralloc_device_open(const hw_module_t* module, const char* name, hw_device_t** device)&#123; int status = -EINVAL; if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) &#123; const private_module_t* m = reinterpret_cast&lt;const private_module_t*&gt;( module); gpu_context_t *dev; IAllocController* alloc_ctrl = IAllocController::getInstance(); dev = new gpu_context_t(m, alloc_ctrl); if(!dev) return status; *device = &amp;dev-&gt;common; status = 0; &#125; else &#123; //GRALLOC_HARDWARE_FB0, status = fb_device_open(module, name, device); &#125; return status;&#125; 2.1ã€Fbè®¾å¤‡æ‰“å¼€è¿‡ç¨‹fb_device_open()çœ‹ä¸‹fb_device_open()å‡½æ•°å®ç°è¿‡ç¨‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\framebuffer.cpp]int fb_device_open(hw_module_t const* module, const char* name, hw_device_t** device)&#123; int status = -EINVAL; if (!strcmp(name, GRALLOC_HARDWARE_FB0)) &#123; alloc_device_t* gralloc_device; // æ‰“å¼€gralloc_deviceè®¾å¤‡ã€‚GRALLOC_HARDWARE_GPU0 status = gralloc_open(module, &amp;gralloc_device); if (status &lt; 0) return status; //åˆ›å»ºä¸€ä¸ªfb_context_tå¯¹è±¡ï¼Œç”¨æ¥æè¿°fbè®¾å¤‡ä¸Šä¸‹æ–‡ fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev)); ...... memset(dev, 0, sizeof(*dev)); //åˆå§‹åŒ–fb_context_tå¯¹è±¡ /* initialize the procs */ dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; dev-&gt;device.common.version = 0; dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); //æ³¨å†Œfbè®¾å¤‡çš„æ“ä½œå‡½æ•° dev-&gt;device.common.close = fb_close; dev-&gt;device.setSwapInterval = fb_setSwapInterval; dev-&gt;device.post = fb_post; dev-&gt;device.setUpdateRect = 0; dev-&gt;device.compositionComplete = fb_compositionComplete; //å°†fbæ˜ å°„åˆ°å½“å‰è¿›ç¨‹åœ°å€ç©ºé—´ status = mapFrameBuffer((framebuffer_device_t*)dev); private_module_t* m = (private_module_t*)dev-&gt;device.common.module; if (status &gt;= 0) &#123; int stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; 3); const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.flags) = 0; const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres; const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres; const_cast&lt;int&amp;&gt;(dev-&gt;device.stride) = stride; const_cast&lt;int&amp;&gt;(dev-&gt;device.format) = m-&gt;fbFormat; const_cast&lt;float&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi; const_cast&lt;float&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi; const_cast&lt;float&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps; const_cast&lt;int&amp;&gt;(dev-&gt;device.minSwapInterval) = PRIV_MIN_SWAP_INTERVAL; const_cast&lt;int&amp;&gt;(dev-&gt;device.maxSwapInterval) = PRIV_MAX_SWAP_INTERVAL; const_cast&lt;int&amp;&gt;(dev-&gt;device.numFramebuffers) = m-&gt;numBuffers; dev-&gt;device.setUpdateRect = 0; *device = &amp;dev-&gt;device.common; &#125; // Close the gralloc module gralloc_close(gralloc_device); &#125; return status;&#125; è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯ç”¨æ¥åˆ›å»ºä¸€ä¸ªfb_context_tç»“æ„ä½“ï¼Œå¹¶ä¸”å¯¹å®ƒçš„æˆå‘˜å˜é‡deviceè¿›è¡Œåˆå§‹åŒ–ã€‚ç»“æ„ä½“fb_context_tçš„æˆå‘˜å˜é‡deviceçš„ç±»å‹ä¸ºframebuffer_device_tï¼Œå®ƒæ˜¯ç”¨æ¥æè¿°fbè®¾å¤‡çš„ã€‚fbè®¾å¤‡ä¸»è¦æ˜¯ç”¨æ¥æ¸²æŸ“å›¾å½¢ç¼“å†²åŒºçš„ï¼Œè¿™æ˜¯é€šè¿‡è°ƒç”¨å®ƒçš„æˆå‘˜å‡½æ•°postæ¥å®ç°çš„ã€‚å‡½æ•°fb_device_openæ‰€æ‰“å¼€çš„fbè®¾å¤‡çš„æˆå‘˜å‡½æ•°postè¢«è®¾ç½®ä¸ºGrallocæ¨¡å—ä¸­çš„å‡½æ•°fb_postã€‚å‡½æ•°mapFrameBufferé™¤äº†ç”¨æ¥è·å¾—ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„ä¿¡æ¯ä¹‹å¤–ï¼Œè¿˜ä¼šå°†ç³»ç»Ÿå¸§ç¼“å†²åŒºæ˜ å°„åˆ°å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´æ¥ã€‚line_lengthç”¨æ¥æè¿°æ˜¾ç¤ºå±ä¸€è¡Œåƒç´ æ€»å…±æ‰€å ç”¨çš„å­—èŠ‚æ•°ï¼Œbits_per_pixelç”¨æ¥æè¿°æ˜¾ç¤ºå±æ¯ä¸€ä¸ªåƒç´ æ‰€å ç”¨çš„ä½æ•°ï¼Œbits_per_pixelçš„å€¼å‘å³ç§»3ä½ï¼Œå°±å¯ä»¥å¾—åˆ°æ˜¾ç¤ºå±æ¯ä¸€ä¸ªåƒç´ æ‰€å ç”¨çš„å­—èŠ‚æ•°ã€‚ç”¨æ˜¾ç¤ºå±åƒç´ æ€»å…±æ‰€å ç”¨çš„å­—èŠ‚æ•°line_lengthé™¤ä»¥æ¯ä¸€ä¸ªåƒç´ æ‰€å ç”¨çš„å­—èŠ‚æ•°å°±å¯ä»¥å¾—åˆ°æ˜¾ç¤ºå±ä¸€è¡Œæœ‰å¤šå°‘ä¸ªåƒç´ ç‚¹ï¼Œå¹¶ä¿å­˜åœ¨strideä¸­ã€‚ 2.2ã€Fbè®¾å¤‡åœ°å€ç©ºé—´æ˜ å°„mapFrameBuffer()12345678910111213141516[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\framebuffer.cpp]static int mapFrameBuffer(framebuffer_device_t *dev)&#123; int err = -1; char property[PROPERTY_VALUE_MAX]; if((property_get(\"debug.gralloc.map_fb_memory\", property, NULL) &gt; 0) &amp;&amp; (!strncmp(property, \"1\", PROPERTY_VALUE_MAX ) || (!strncasecmp(property,\"true\", PROPERTY_VALUE_MAX )))) &#123; private_module_t* module = reinterpret_cast&lt;private_module_t*&gt;(dev-&gt;common.module); pthread_mutex_lock(&amp;module-&gt;lock); err = mapFrameBufferLocked(dev); pthread_mutex_unlock(&amp;module-&gt;lock); &#125; return err;&#125; è°ƒç”¨mapFrameBufferLockedå‡½æ•°æ‰§è¡Œæ˜ å°„è¿‡ç¨‹ï¼Œè¯¥å‡½æ•°åœ¨çº¿ç¨‹ä¿æŠ¤ä¸‹å®Œæˆã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\framebuffer.cpp]int mapFrameBufferLocked(framebuffer_device_t *dev)&#123; private_module_t* module = reinterpret_cast&lt;private_module_t*&gt;(dev-&gt;common.module); fb_context_t *ctx = reinterpret_cast&lt;fb_context_t*&gt;(dev); // already initialized... if (module-&gt;framebuffer) &#123; return 0; &#125; char const * const device_template[] = &#123; \"/dev/graphics/fb%u\", \"/dev/fb%u\", 0 &#125;; int fd = -1; int i=0; char name[64]; char property[PROPERTY_VALUE_MAX]; //æ£€æŸ¥æ˜¯å¦å­˜åœ¨è®¾å¤‡æ–‡ä»¶/dev/graphics/fb0æˆ–è€…/dev/fb0ã€‚å¦‚æœå­˜åœ¨çš„è¯ï¼Œé‚£ä¹ˆå°±è°ƒç”¨å‡½æ•°openæ¥æ‰“å¼€å®ƒï¼Œå¹¶ä¸”å°†å¾—åˆ°çš„æ–‡ä»¶æè¿°ç¬¦ä¿å­˜åœ¨å˜é‡fdä¸­ while ((fd==-1) &amp;&amp; device_template[i]) &#123; snprintf(name, 64, device_template[i], 0); fd = open(name, O_RDWR, 0); i++; &#125; ...... //é€šè¿‡IOæ§åˆ¶å‘½ä»¤FBIOGET_FSCREENINFOæ¥è·å¾—ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„å›ºå®šä¿¡æ¯ï¼Œä¿å­˜åœ¨fb_fix_screeninfoç»“æ„ä½“finfoä¸­ struct fb_fix_screeninfo finfo; if (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == -1) &#123; close(fd); return -errno; &#125; //é€šè¿‡IOæ§åˆ¶å‘½ä»¤FBIOGET_VSCREENINFOæ¥è·å¾—ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„å¯å˜ä¿¡æ¯ï¼Œä¿å­˜åœ¨fb_var_screeninfoç»“æ„ä½“infoä¸­ struct fb_var_screeninfo info; if (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == -1) &#123; close(fd); return -errno; &#125; //åˆå§‹åŒ–info info.reserved[0] = 0; info.reserved[1] = 0; info.reserved[2] = 0; info.xoffset = 0; info.yoffset = 0; info.activate = FB_ACTIVATE_NOW; /* Interpretation of offset for color fields: All offsets are from the * right, inside a \"pixel\" value, which is exactly 'bits_per_pixel' wide * (means: you can use the offset as right argument to &lt;&lt;). A pixel * afterwards is a bit stream and is written to video memory as that * unmodified. This implies big-endian byte order if bits_per_pixel is * greater than 8. */ if(info.bits_per_pixel == 32) &#123; /* * Explicitly request RGBA_8888 */ info.bits_per_pixel = 32; info.red.offset = 24; info.red.length = 8; info.green.offset = 16; info.green.length = 8; info.blue.offset = 8; info.blue.length = 8; info.transp.offset = 0; info.transp.length = 8; /* Note: the GL driver does not have a r=8 g=8 b=8 a=0 config, so if we * do not use the MDP for composition (i.e. hw composition == 0), ask * for RGBA instead of RGBX. */ if (property_get(\"debug.sf.hw\", property, NULL) &gt; 0 &amp;&amp; atoi(property) == 0) module-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBX_8888; else if(property_get(\"debug.composition.type\", property, NULL) &gt; 0 &amp;&amp; (strncmp(property, \"mdp\", 3) == 0)) module-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBX_8888; else module-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBA_8888; &#125; else &#123; /* * Explicitly request 5/6/5 */ info.bits_per_pixel = 16; info.red.offset = 11; info.red.length = 5; info.green.offset = 5; info.green.length = 6; info.blue.offset = 0; info.blue.length = 5; info.transp.offset = 0; info.transp.length = 0; module-&gt;fbFormat = HAL_PIXEL_FORMAT_RGB_565; &#125; //adreno needs 4k aligned offsets. Max hole size is 4096-1 unsigned int size = roundUpToPageSize(info.yres * info.xres * (info.bits_per_pixel/8)); /* * Request NUM_BUFFERS screens (at least 2 for page flipping) */ int numberOfBuffers = (int)(finfo.smem_len/size); ALOGV(\"num supported framebuffers in kernel = %d\", numberOfBuffers); if (property_get(\"debug.gr.numframebuffers\", property, NULL) &gt; 0) &#123; int num = atoi(property); if ((num &gt;= NUM_FRAMEBUFFERS_MIN) &amp;&amp; (num &lt;= NUM_FRAMEBUFFERS_MAX)) &#123; numberOfBuffers = num; &#125; &#125; if (numberOfBuffers &gt; NUM_FRAMEBUFFERS_MAX) numberOfBuffers = NUM_FRAMEBUFFERS_MAX; ALOGV(\"We support %d buffers\", numberOfBuffers); //consider the included hole by 4k alignment uint32_t line_length = (info.xres * info.bits_per_pixel / 8); info.yres_virtual = (uint32_t) ((size * numberOfBuffers) / line_length); uint32_t flags = PAGE_FLIP; if (info.yres_virtual &lt; ((size * 2) / line_length) ) &#123; // we need at least 2 for page-flipping info.yres_virtual = (int)(size / line_length); flags &amp;= ~PAGE_FLIP; ...... &#125; if (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == -1) &#123; close(fd); return -errno; &#125; if (int(info.width) &lt;= 0 || int(info.height) &lt;= 0) &#123; info.width = (uint32_t)(((float)(info.xres) * 25.4f)/160.0f + 0.5f); info.height = (uint32_t)(((float)(info.yres) * 25.4f)/160.0f + 0.5f); &#125; float xdpi = ((float)(info.xres) * 25.4f) / (float)info.width; float ydpi = ((float)(info.yres) * 25.4f) / (float)info.height; ...... //é€šè¿‡IOæ§åˆ¶å‘½ä»¤FBIOGET_VSCREENINFOæ¥é‡æ–°è·å¾—ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„å¯å˜ä¿¡æ¯ if (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == -1) &#123; close(fd); return -errno; &#125;...... module-&gt;flags = flags; module-&gt;info = info; module-&gt;finfo = finfo; module-&gt;xdpi = xdpi; module-&gt;ydpi = ydpi; module-&gt;fps = fps; module-&gt;swapInterval = 1; /* * map the framebuffer */ module-&gt;numBuffers = info.yres_virtual / info.yres; module-&gt;bufferMask = 0; //æ•´ä¸ªç³»ç»Ÿå¸§ç¼“å†²åŒºçš„å¤§å°=è™šæ‹Ÿåˆ†è¾¨ç‡çš„é«˜åº¦å€¼info.yres_virtual * æ¯ä¸€è¡Œæ‰€å ç”¨çš„å­—èŠ‚æ•°finfo.line_length,å¹¶å°†æ•´ä¸ªç³»ç»Ÿå¸§ç¼“å†²åŒºçš„å¤§å°å¯¹é½åˆ°é¡µé¢è¾¹ç•Œ unsigned int fbSize = roundUpToPageSize(finfo.line_length * info.yres)* module-&gt;numBuffers; //ç³»ç»Ÿå¸§ç¼“å†²åŒºåœ¨å½“å‰è¿›ç¨‹çš„åœ°å€ç©ºé—´ä¸­çš„èµ·å§‹åœ°å€ä¿å­˜åˆ°private_handle_tçš„åŸŸbaseä¸­ void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0); ...... //store the framebuffer fd in the ctx ctx-&gt;fbFd = fd; ...... //åˆ›å»ºä¸€ä¸ªprivate_handle_tï¼Œç”¨æ¥æè¿°æ•´ä¸ªç³»ç»Ÿå¸§ç¼“å†²åŒºçš„ä¿¡æ¯ // Create framebuffer handle using the ION fd module-&gt;framebuffer = new private_handle_t(fd, fbSize, private_handle_t::PRIV_FLAGS_USES_ION, BUFFER_TYPE_UI, module-&gt;fbFormat, info.xres, info.yres); //ä»¥è¯»å†™å…±äº«æ–¹å¼å°†å¸§ç¼“å†²åŒºæ˜ å°„åˆ°å½“å‰è¿›ç¨‹åœ°å€ç©ºé—´ä¸­ module-&gt;framebuffer-&gt;base = uint64_t(vaddr); memset(vaddr, 0, fbSize); //Enable vsync int enable = 1; ioctl(ctx-&gt;fbFd, MSMFB_OVERLAY_VSYNC_CTRL, &amp;enable); return 0;&#125; 2.3ã€GPUè®¾å¤‡æ‰“å¼€è¿‡ç¨‹gralloc_open()12345678[-&gt;\\hardware\\libhardware\\include\\hardware\\gralloc.h]/** convenience API for opening and closing a supported device */static inline int gralloc_open(const struct hw_module_t* module, struct alloc_device_t** device) &#123; return module-&gt;methods-&gt;open(module, GRALLOC_HARDWARE_GPU0, (struct hw_device_t**)device);&#125; æœ€ç»ˆä¼šèµ°åˆ°gralloc_device_open()å‡½æ•°12345678910111213141516171819202122232425[-&gt;\\hardware\\libhardware\\include\\hardware\\gralloc.cpp]// HAL module methodsstatic struct hw_module_methods_t gralloc_module_methods = &#123; .open = gralloc_device_open&#125;;// Open Gralloc deviceint gralloc_device_open(const hw_module_t* module, const char* name, hw_device_t** device)&#123; int status = -EINVAL; if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) &#123; const private_module_t* m = reinterpret_cast&lt;const private_module_t*&gt;( module); gpu_context_t *dev; IAllocController* alloc_ctrl = IAllocController::getInstance(); dev = new gpu_context_t(m, alloc_ctrl); ...... *device = &amp;dev-&gt;common; status = 0; &#125; else &#123; status = fb_device_open(module, name, device); &#125; return status;&#125; è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯ç”¨æ¥åˆ›å»ºä¸€ä¸ªgpu_context_t ç»“æ„ä½“ï¼Œå¹¶ä¸”å¯¹å®ƒçš„æˆå‘˜å˜é‡deviceè¿›è¡Œåˆå§‹åŒ–ã€‚gpu_context_tç±»ç»§æ‰¿äº†alloc_device_tï¼Œå¹¶å®ç°äº†alloc_device_tä¸­çš„allocï¼Œfreeç­‰æ–¹æ³•ã€‚ 1234567891011121314151617[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\gpu.cpp]gpu_context_t::gpu_context_t(const private_module_t* module, IAllocController* alloc_ctrl ) : mAllocCtrl(alloc_ctrl)&#123; // Zero out the alloc_device_t memset(static_cast&lt;alloc_device_t*&gt;(this), 0, sizeof(alloc_device_t)); // Initialize the procs common.tag = HARDWARE_DEVICE_TAG; common.version = 0; common.module = const_cast&lt;hw_module_t*&gt;(&amp;module-&gt;base.common); common.close = gralloc_close; alloc = gralloc_alloc; free = gralloc_free;&#125; ä¸»è¦æ˜¯å®Œæˆalloc_device_tå‚æ•°çš„åˆå§‹åŒ–ã€‚å…¶æˆå‘˜å‡½æ•°allocï¼Œfreeè¢«è®¾ç½®æˆgralloc_alloc &amp; gralloc_freeã€‚è‡ªæ­¤ï¼Œallocè®¾å¤‡çš„æ‰“å¼€è¿‡ç¨‹å°±åˆ†æå®Œæˆäº†ã€‚æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬é‡ç‚¹åˆ†æalloc_device_tä¸­æä¾›çš„å‡ ä¸ªå…³é”®å‡½æ•°ã€‚ ï¼ˆä¸‰ï¼‰ã€ Grallocåˆ†é…å’Œé‡Šæ”¾Buffer3.1ã€Grallocåˆ†é…bufferå…ˆæ¥å›å¿†ä¸€ä¸‹SurfacFlingerå›¾å½¢ç¼“å†²åŒºåˆ›å»ºè¿‡ç¨‹ 12345GraphicBuffer::GraphicBuffer -&gt; initSize -&gt; GraphicBufferAllocator::alloc -&gt; alloc_device_t::alloc -&gt; gralloc_alloc ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºç”¨åˆ°çš„å›¾å½¢ç¼“å†²åŒºæ˜¯ç”±Grallocæ¨¡å—ä¸­çš„å‡½æ•°gralloc_allocæ¥åˆ†é…çš„ï¼Œè¿™ä¸ªå‡½æ•°å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\gpu.cpp]int gpu_context_t::gralloc_alloc(alloc_device_t* dev, int w, int h, int format, int usage, buffer_handle_t* pHandle, int* pStride)&#123; gpu_context_t* gpu = reinterpret_cast&lt;gpu_context_t*&gt;(dev); return gpu-&gt;alloc_impl(w, h, format, usage, pHandle, pStride, 0);&#125;int gpu_context_t::alloc_impl(int w, int h, int format, int usage, buffer_handle_t* pHandle, int* pStride, unsigned int bufferSize) &#123; ...... // å‚æ•°formatç”¨æ¥æè¿°è¦åˆ†é…çš„å›¾å½¢ç¼“å†²åŒºçš„é¢œè‰²æ ¼å¼ã€‚è¿™äº›æ ¼å¼å®šä¹‰åœ¨system/core/include/system/graphic.hä¸­ if(format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED || format == HAL_PIXEL_FORMAT_YCbCr_420_888) &#123; if (usage &amp; GRALLOC_USAGE_PRIVATE_ALLOC_UBWC) grallocFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS_UBWC; else if(usage &amp; GRALLOC_USAGE_HW_VIDEO_ENCODER) grallocFormat = HAL_PIXEL_FORMAT_NV12_ENCODEABLE; //NV12 ...... &#125; // è®¾ç½®buffertypeï¼ŒBUFFER_TYPE_UI: RGB formats &amp; HAL_PIXEL_FORMAT_R_8 &amp;HAL_PIXEL_FORMAT_RG_88ã€‚å…¶ä»–çš„éƒ½ä¸ºBUFFER_TYPE_VIDEO getGrallocInformationFromFormat(grallocFormat, &amp;bufferType); // æ ¹æ®formate &amp; wï¼Œhç®—å‡ºbuffersize size = getBufferSizeAndDimensions(w, h, grallocFormat, usage, alignedw, alignedh); ...... size = (bufferSize &gt;= size)? bufferSize : size; int err = 0; if(useFbMem) &#123; err = gralloc_alloc_framebuffer(usage, pHandle); &#125; else &#123; err = gralloc_alloc_buffer(size, usage, pHandle, bufferType, grallocFormat, alignedw, alignedh); &#125; ...... *pStride = alignedw; return 0;&#125; æœ€åæ ¹æ®memory allocå‡ºå¤„ï¼ŒåŒºåˆ«è°ƒç”¨gralloc_alloc_framebuffer&amp; gralloc_alloc_bufferå‡½æ•°ã€‚ é¦–å…ˆæ¥çœ‹çœ‹ gralloc_alloc_framebufferçš„å®ç°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\gpu.cpp]int gpu_context_t::gralloc_alloc_framebuffer_locked(int usage, buffer_handle_t* pHandle)&#123; // å˜é‡bufferMaskç”¨æ¥æè¿°ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„ä½¿ç”¨æƒ…å†µ // å˜é‡numBuffersç”¨æ¥æè¿°ç³»ç»Ÿå¸§ç¼“å†²åŒºå¯ä»¥åˆ’åˆ†ä¸ºå¤šå°‘ä¸ªå›¾å½¢ç¼“å†²åŒºæ¥ä½¿ç”¨ // å˜é‡bufferSizeç”¨æ¥æè¿°è®¾å¤‡æ˜¾ç¤ºå±ä¸€å±å†…å®¹æ‰€å ç”¨çš„å†…å­˜çš„å¤§å°,åŒæ—¶é«˜é€šçš„ç¡¬ä»¶è¦æ±‚4Kå¯¹é½ã€‚ const unsigned int bufferMask = m-&gt;bufferMask; const uint32_t numBuffers = m-&gt;numBuffers; unsigned int bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres; //adreno needs FB size to be page aligned bufferSize = roundUpToPageSize(bufferSize); // å‡è®¾æ­¤æ—¶ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­å°šæœ‰ç©ºé—²çš„å›¾å½¢ç¼“å†²åŒºçš„ï¼Œæ¥ä¸‹æ¥å‡½æ•°å°±ä¼šåˆ›å»ºä¸€ä¸ªprivate_handle_tç»“æ„ä½“hndæ¥æè¿°è¿™ä¸ªå³å°†è¦åˆ†é…å‡ºå»çš„å›¾å½¢ç¼“å†²åŒºã€‚æ³¨æ„ï¼Œè¿™ä¸ªå›¾å½¢ç¼“å†²åŒºçš„æ ‡å¿—å€¼ç­‰äºPRIV_FLAGS_FRAMEBUFFERï¼Œå³è¡¨ç¤ºè¿™æ˜¯ä¸€å—åœ¨ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­åˆ†é…çš„å›¾å½¢ç¼“å†²åŒºã€‚ uint64_t vaddr = uint64_t(m-&gt;framebuffer-&gt;base); // As GPU needs ION FD, the private handle is created // using ION fd and ION flags are set private_handle_t* hnd = new private_handle_t( dup(m-&gt;framebuffer-&gt;fd), bufferSize, private_handle_t::PRIV_FLAGS_USES_ION | private_handle_t::PRIV_FLAGS_FRAMEBUFFER, BUFFER_TYPE_UI, m-&gt;fbFormat, m-&gt;info.xres, m-&gt;info.yres); // æ¥ä¸‹æ¥çš„forå¾ªç¯ä»ä½ä½åˆ°é«˜ä½æ£€æŸ¥å˜é‡bufferMaskçš„å€¼ï¼Œå¹¶ä¸”æ‰¾åˆ°ç¬¬ä¸€ä¸ªå€¼ç­‰äº0çš„ä½ï¼Œè¿™æ ·å°±å¯ä»¥çŸ¥é“åœ¨ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­ï¼Œç¬¬å‡ ä¸ªå›¾å½¢ç¼“å†²åŒºçš„æ˜¯ç©ºé—²çš„ã€‚æ³¨æ„ï¼Œå˜é‡vadrrçš„å€¼å¼€å§‹çš„æ—¶å€™æŒ‡å‘ç³»ç»Ÿå¸§ç¼“å†²åŒºçš„åŸºåœ°å€ï¼Œåœ¨ä¸‹é¢çš„forå¾ªç¯ä¸­ï¼Œæ¯å¾ªç¯ä¸€æ¬¡å®ƒçš„å€¼éƒ½ä¼šå¢åŠ bufferSizeã€‚ä»è¿™é‡Œå°±å¯ä»¥çœ‹å‡ºï¼Œæ¯æ¬¡ä»ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­åˆ†é…å‡ºå»çš„å›¾å½¢ç¼“å†²åŒºçš„å¤§å°éƒ½æ˜¯åˆšå¥½ç­‰äºæ˜¾ç¤ºå±ä¸€å±å†…å®¹å¤§å°çš„ã€‚ // find a free slot for (uint32_t i=0 ; i&lt;numBuffers ; i++) &#123; if ((bufferMask &amp; (1LU&lt;&lt;i)) == 0) &#123; m-&gt;bufferMask |= (uint32_t)(1LU&lt;&lt;i); break; &#125; vaddr += bufferSize; &#125; / å°†åˆ†é…çš„ç¼“å†²åŒºçš„å¼€å§‹åœ°å€ä¿å­˜åˆ°å˜é‡baseä¸­ï¼Œè¿™æ ·ç”¨æˆ·æ§ä»¶çš„åº”ç”¨ç¨‹åºå¯ä»¥ç›´æ¥å°†éœ€è¦æ¸²æŸ“çš„å›¾å½¢å†…å®¹æ‹·è´åˆ°è¿™ä¸ªåœ°å€ä¸Šã€‚è¿™æ ·ï¼Œå°±ç›¸å½“äºæ˜¯ç›´æ¥å°†å›¾å½¢æ¸²æŸ“åˆ°ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­å»ã€‚// offsetè¡¨ç¤ºåˆ†é…åˆ°çš„å›¾å½¢ç¼“å†²åŒºçš„èµ·å§‹åœ°å€æ­£å¯¹äºç³»ç»Ÿå¸§ç¼“å†²åŒºåŸºåœ°å€çš„åç§»é‡ã€‚ hnd-&gt;base = vaddr; hnd-&gt;offset = (unsigned int)(vaddr - m-&gt;framebuffer-&gt;base); *pHandle = hnd; return 0;&#125;int gpu_context_t::gralloc_alloc_framebuffer(int usage, buffer_handle_t* pHandle)&#123; private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;(common.module); pthread_mutex_lock(&amp;m-&gt;lock); int err = gralloc_alloc_framebuffer_locked(usage, pHandle); pthread_mutex_unlock(&amp;m-&gt;lock); return err;&#125; ä¸Šé¢åˆ†æäº†ä»framebufferä¸­åˆ†é…å›¾å½¢ç¼“å†²åŒºçš„è¿‡ç¨‹ã€‚æ€»ç»“ä¸‹è¿™å—bufferçš„æ¥å†ã€‚é¦–å…ˆåœ¨fbè®¾å¤‡opençš„æ—¶å€™ï¼Œé€šè¿‡mmapä»fb0ä¸­æ˜ å°„ä¸€å—å†…å­˜åˆ°ç”¨æˆ·ç©ºé—´ï¼Œå³ä¸€ä¸ªå†…å­˜æ± ï¼ˆmodule-&gt;framebuffer)ï¼Œé€šè¿‡bufferMaskæ¥è¡¨ç¤ºè¯¥æ± ä¸­å†…å­˜çš„ä½¿ç”¨æƒ…å†µã€‚è€Œallocåšçš„äº‹æƒ…ï¼Œå°±æ˜¯ä»è¿™ä¸ªå†…å­˜æ± ä¸­æ‰¾åˆ°ä¸€ä¸ªç©ºé—²çš„åŒºå—ï¼Œç„¶åè¿”å›è¯¥åŒºå—çš„hanlderæŒ‡é’ˆpHandleã€‚ æˆ‘ä»¬ç°åœ¨æ¥çœ‹çœ‹ä»å†…å­˜ä¸­åˆ†é…å›¾å½¢ç¼“å†²åŒºçš„æƒ…å†µã€‚ä»Android 4.0å¼€å§‹ï¼ŒAndroidå¯åŠ¨æ–°çš„å†…å­˜ç®¡ç†æ–¹å¼IONï¼Œä»¥å–ä»£PMEMã€‚PMEMéœ€è¦ä¸€ä¸ªè¿ç»­çš„ç‰©ç†å†…å­˜ï¼ŒåŒæ—¶éœ€è¦åœ¨ç³»ç»Ÿå¯åŠ¨çš„æ—¶å€™ï¼Œå°±å®Œæˆåˆ†é…ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\gpu.cpp]int gpu_context_t::gralloc_alloc_buffer(unsigned int size, int usage, buffer_handle_t* pHandle, int bufferType, int format, int width, int height)&#123; int err = 0; int flags = 0; size = roundUpToPageSize(size); // é¦–å…ˆåˆ†é…ä¸€ä¸ªdataåŒºåŸŸ alloc_data data; ...... // è¿½æŸ¥ä»£ç å¯ä»¥çŸ¥é“mallocCtrlæŒ‡å‘IonControllerå¯¹è±¡ï¼Œå…³é”®ä»£ç å¯ä»¥å‚è€ƒhardware/qrom/display/msm8974/libgralloc/alloc_controller.cppã€‚å…·ä½“æ€ä¹ˆä»ionä¸­åˆ†é…buffer data.size = size; data.pHandle = (uintptr_t) pHandle; err = mAllocCtrl-&gt;allocate(data, usage); if (!err) &#123; /* allocate memory for enhancement data */ alloc_data eData; ... int eDataErr = mAllocCtrl-&gt;allocate(eData, eDataUsage); ...... flags |= data.allocType; uint64_t eBaseAddr = (uint64_t)(eData.base) + eData.offset; private_handle_t *hnd = new private_handle_t(data.fd, size, flags, bufferType, format, width, height, eData.fd, eData.offset, eBaseAddr); hnd-&gt;offset = data.offset; hnd-&gt;base = (uint64_t)(data.base) + data.offset; hnd-&gt;gpuaddr = 0; ColorSpace_t colorSpace = ITU_R_601; setMetaData(hnd, UPDATE_COLOR_SPACE, (void*) &amp;colorSpace); *pHandle = hnd; &#125; ALOGE_IF(err, \"gralloc failed err=%s\", strerror(-err)); return err;&#125; 3.2ã€Grallocé‡Šæ”¾bufferé‡Šæ”¾bufferæœ¬è´¨æ˜¯è°ƒç”¨gralloc_freeå‡½æ•°ï¼Œè¯¥å‡½æ•°åˆè°ƒç”¨äº†free_implå‡½æ•°ã€‚åœ¨å¤„ç†free bufferçš„æ—¶å€™ï¼Œä¹Ÿæ˜¯æŒ‰ç…§ä¸¤ç§æƒ…å†µæ¥åˆ†åˆ«å¤„ç†çš„ã€‚å¦‚æœä¹‹å‰è¿™ä¸ªbufferæ˜¯ä»framebufferåˆ†é…çš„è¯ï¼Œå°±åªè¦æŠŠbufferMaskä¸­è®¾ç½®æˆ0å³å¯ã€‚è€Œå¯¹åº”ä»å†…å­˜ä¸­ç”³è¯·çš„ï¼Œåˆ™æ˜¯è°ƒç”¨allocCtrlï¼ˆionï¼‰ä¸­çš„free_bufferæ¥å®Œæˆé‡Šæ”¾ã€‚ 123456789101112131415161718192021222324252627[-&gt;\\hardware\\qcom\\display\\msm8996\\libgralloc\\framebuffer.cpp]int gpu_context_t::free_impl(private_handle_t const* hnd) &#123; private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;(common.module); if (hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER) &#123; const unsigned int bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres; unsigned int index = (unsigned int) ((hnd-&gt;base - m-&gt;framebuffer-&gt;base) / bufferSize); m-&gt;bufferMask &amp;= (uint32_t)~(1LU&lt;&lt;index); &#125; else &#123; terminateBuffer(&amp;m-&gt;base, const_cast&lt;private_handle_t*&gt;(hnd)); IMemAlloc* memalloc = mAllocCtrl-&gt;getAllocator(hnd-&gt;flags); int err = memalloc-&gt;free_buffer((void*)hnd-&gt;base, hnd-&gt;size, hnd-&gt;offset, hnd-&gt;fd); if(err) return err; // free the metadata space unsigned int size = ROUND_UP_PAGESIZE(sizeof(MetaData_t)); err = memalloc-&gt;free_buffer((void*)hnd-&gt;base_metadata, size, hnd-&gt;offset_metadata, hnd-&gt;fd_metadata); if (err) return err; &#125; delete hnd; return 0;&#125; ï¼ˆå››ï¼‰ã€å›¾å½¢ç¼“å†²åŒºæ˜ å°„è¿‡ç¨‹ å›¾å½¢ç¼“å†²åŒºå¯ä»¥ä»ç³»ç»Ÿå¸§ç¼“å†²åŒºåˆ†é…ä¹Ÿå¯ä»¥ä»å†…å­˜ä¸­åˆ†é…ï¼Œåˆ†é…ä¸€ä¸ªå›¾å½¢ç¼“å†²åŒºåè¿˜éœ€è¦å°†è¯¥å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°åˆ†é…è¯¥bufferçš„è¿›ç¨‹åœ°å€ç©ºé—´æ¥ï¼Œåœ¨Androidç³»ç»Ÿä¸­ï¼Œå›¾å½¢ç¼“å†²åŒºçš„ç®¡ç†ç”±SurfaceFlingeræœåŠ¡æ¥è´Ÿè´£ã€‚åœ¨ç³»ç»Ÿå¸§ç¼“å†²åŒºä¸­åˆ†é…çš„å›¾å½¢ç¼“å†²åŒºæ˜¯åœ¨SurfaceFlingeræœåŠ¡ä¸­ä½¿ç”¨ï¼Œè€Œåœ¨å†…å­˜ä¸­åˆ†é…çš„å›¾å½¢ç¼“å†²åŒºæ—¢å¯ä»¥åœ¨SurfaceFlingeræœåŠ¡ä¸­ä½¿ç”¨ï¼Œä¹Ÿå¯ä»¥åœ¨å…¶å®ƒçš„åº”ç”¨ç¨‹åºä¸­ä½¿ç”¨ã€‚å½“å…¶å®ƒçš„åº”ç”¨ç¨‹åºéœ€è¦ä½¿ç”¨å›¾å½¢ç¼“å†²åŒºçš„æ—¶å€™ï¼Œå®ƒä»¬å°±ä¼šè¯·æ±‚SurfaceFlingeræœåŠ¡ä¸ºå®ƒä»¬åˆ†é…å¹¶å°†SurfaceFlingeræœåŠ¡è¿”å›æ¥çš„å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹åœ°å€ç©ºé—´ã€‚åœ¨ä»å†…å­˜ä¸­åˆ†é…bufferæ—¶ï¼Œå·²ç»å°†åˆ†é…çš„bufferæ˜ å°„åˆ°äº†SurfaceFlingeræœåŠ¡è¿›ç¨‹åœ°å€ç©ºé—´ï¼Œå¦‚æœè¯¥bufferæ˜¯åº”ç”¨ç¨‹åºè¯·æ±‚SurfaceFlingeræœåŠ¡ä¸ºå®ƒä»¬åˆ†é…çš„ï¼Œé‚£ä¹ˆè¿˜éœ€è¦å°†SurfaceFlingeræœåŠ¡è¿”å›æ¥çš„å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹åœ°å€ç©ºé—´ã€‚ ä¸€ä¸ªå¯¹è±¡è¦åœ¨è¿›ç¨‹é—´ä¼ è¾“å¿…é¡»ç»§æ‰¿äºFlattenableç±»ï¼Œå¹¶ä¸”å®ç°flattenå’Œunflattenæ–¹æ³•ï¼Œflattenæ–¹æ³•ç”¨äºåºåˆ—åŒ–è¯¥å¯¹è±¡ï¼Œunflattenæ–¹æ³•ç”¨äºååºåˆ—åŒ–å¯¹è±¡ã€‚ GraphicBufferç±»ä»æ¨¡æ¿ç±»Flattenableæ´¾ç”Ÿï¼Œè¿™ä¸ªæ´¾ç”Ÿç±»å¯ä»¥é€šè¿‡Parcelä¼ é€’ï¼Œé€šå¸¸æ´¾ç”Ÿç±»éœ€è¦é‡è½½flattenå’Œunflattenæ–¹æ³•ï¼Œç”¨äºå¯¹è±¡çš„åºåˆ—åŒ–å’Œååºåˆ—åŒ–ã€‚ 1ï¼‰å°†ä¸€ä¸ªå¯¹è±¡å†™å…¥åˆ°Parcelä¸­ï¼Œéœ€è¦ä½¿ç”¨flattenå‡½æ•°åºåˆ—åŒ–è¯¥å¯¹è±¡ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹flattenå‡½æ•°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738[-&gt;\\frameworks\\native\\libs\\ui\\GraphicBuffer.cpp]status_t GraphicBuffer::flatten(void*&amp; buffer, size_t&amp; size, int*&amp; fds, size_t&amp; count) const &#123; size_t sizeNeeded = GraphicBuffer::getFlattenedSize(); if (size &lt; sizeNeeded) return NO_MEMORY; size_t fdCountNeeded = GraphicBuffer::getFdCount(); if (count &lt; fdCountNeeded) return NO_MEMORY; int32_t* buf = static_cast&lt;int32_t*&gt;(buffer); buf[0] = 'GBFR'; buf[1] = width; buf[2] = height; buf[3] = stride; buf[4] = format; buf[5] = usage; buf[6] = static_cast&lt;int32_t&gt;(mId &gt;&gt; 32); buf[7] = static_cast&lt;int32_t&gt;(mId &amp; 0xFFFFFFFFull); buf[8] = 0; buf[9] = 0; if (handle) &#123; buf[8] = handle-&gt;numFds; buf[9] = handle-&gt;numInts; native_handle_t const* const h = handle; //æŠŠhandleä¸­çš„dataå¤åˆ¶åˆ°fdsä¸­ memcpy(fds, h-&gt;data, h-&gt;numFds*sizeof(int)); memcpy(&amp;buf[10], h-&gt;data + h-&gt;numFds, h-&gt;numInts*sizeof(int)); &#125; buffer = reinterpret_cast&lt;void*&gt;(static_cast&lt;int*&gt;(buffer) + sizeNeeded); size -= sizeNeeded; if (handle) &#123; fds += handle-&gt;numFds; count -= handle-&gt;numFds; &#125; return NO_ERROR;&#125; è¿™ä¸ªhandleç±»å‹ä¸ºnative_handle_t ï¼Œä¸”typedefæˆäº†buffer_handle_tï¼Œæˆ‘ä»¬è´´ä¸€ä¸‹å®ƒçš„å®šä¹‰ï¼š 12345678[-&gt;/system/core/include/cutils/native_handle.h]typedef struct native_handle &#123; int version; //è®¾ç½®ä¸ºç»“æ„ä½“native_handle_tçš„å¤§å°ï¼Œç”¨æ¥æ ‡è¯†ç»“æ„ä½“native_handle_tçš„ç‰ˆæœ¬ int numFds; //è¡¨ç¤ºç»“æ„ä½“native_handle_tæ‰€åŒ…å«çš„æ–‡ä»¶æè¿°ç¬¦çš„ä¸ªæ•°ï¼Œè¿™äº›æ–‡ä»¶æè¿°ç¬¦ä¿å­˜åœ¨æˆå‘˜å˜é‡dataæ‰€æŒ‡å‘çš„ä¸€å—ç¼“å†²åŒºä¸­ã€‚ int numInts; //è¡¨ç¤ºç»“æ„ä½“native_handle_tæ‰€åŒ…å«çš„æ•´æ•°å€¼çš„ä¸ªæ•°ï¼Œè¿™äº›æ•´æ•°ä¿å­˜åœ¨æˆå‘˜å˜é‡dataæ‰€æŒ‡å‘çš„ä¸€å—ç¼“å†²åŒºä¸­ã€‚ int data[0]; //æŒ‡å‘çš„ä¸€å—ç¼“å†²åŒºä¸­ &#125; native_handle_t; æ‰€ä»¥æˆ‘ä»¬å›åˆ°flattenå‡½æ•°ä¸­ï¼Œfdså‚æ•°ç”¨æ¥ä¼ é€’æ–‡ä»¶å¥æŸ„ï¼Œå‡½æ•°æŠŠhandleä¸­çš„è¡¨ç¤ºæŒ‡å‘å›¾å½¢ç¼“å†²åŒºæ–‡ä»¶æè¿°ç¬¦å¥æŸ„å¤åˆ¶åˆ°fdsä¸­ï¼Œå› æ­¤è¿™äº›å¥æŸ„å°±èƒ½é€šè¿‡binderä¼ é€’åˆ°ç›®æ ‡è¿›ç¨‹ä¸­å»ã€‚ 2ï¼‰åœ¨åº”ç”¨ç¨‹åºè¯»å–æ¥è‡ªæœåŠ¡è¿›ç¨‹çš„GraphicBufferå¯¹è±¡æ—¶ï¼Œä¹Ÿå°±æ˜¯result = reply.read(*p)ï¼Œä¼šè°ƒç”¨GraphicBufferç±»çš„unflattenå‡½æ•°è¿›è¡Œååºåˆ—åŒ–è¿‡ç¨‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[-&gt;\\frameworks\\native\\libs\\ui\\GraphicBuffer.cpp]status_t GraphicBuffer::unflatten( void const*&amp; buffer, size_t&amp; size, int const*&amp; fds, size_t&amp; count) &#123; if (size &lt; 8*sizeof(int)) return NO_MEMORY; int const* buf = static_cast&lt;int const*&gt;(buffer); if (buf[0] != 'GBFR') return BAD_TYPE; const size_t numFds = buf[8]; const size_t numInts = buf[9]; const size_t sizeNeeded = (10 + numInts) * sizeof(int); if (size &lt; sizeNeeded) return NO_MEMORY; size_t fdCountNeeded = 0; if (count &lt; fdCountNeeded) return NO_MEMORY; if (handle) &#123; // free previous handle if any free_handle(); &#125; if (numFds || numInts) &#123; width = buf[1]; height = buf[2]; stride = buf[3]; format = buf[4]; usage = buf[5]; //åˆ›å»ºä¸€ä¸ªnative_handleå¯¹è±¡ native_handle* h = native_handle_create(numFds, numInts); //å°†fdså¤åˆ¶åˆ°native_handleå¯¹è±¡çš„dataä¸­ï¼Œå’Œflattenæ“ä½œç›¸å memcpy(h-&gt;data, fds, numFds*sizeof(int)); memcpy(h-&gt;data + numFds, &amp;buf[10], numInts*sizeof(int)); handle = h; &#125; else &#123; width = height = stride = format = usage = 0; handle = NULL; &#125; mId = static_cast&lt;uint64_t&gt;(buf[6]) &lt;&lt; 32; mId |= static_cast&lt;uint32_t&gt;(buf[7]); mOwner = ownHandle; if (handle != 0) &#123; //ä½¿ç”¨GraphicBufferMapperå°†æœåŠ¡ç«¯åˆ›å»ºçš„å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°å½“å‰è¿›ç¨‹åœ°å€ç©ºé—´ status_t err = mBufferMapper.registerBuffer(handle); if (err != NO_ERROR) &#123; width = height = stride = format = usage = 0; handle = NULL; ...... return err; &#125; &#125; buffer = reinterpret_cast&lt;void const*&gt;(static_cast&lt;int const*&gt;(buffer) + sizeNeeded); size -= sizeNeeded; fds += numFds; count -= numFds; return NO_ERROR;&#125; è°ƒç”¨unflattenå‡½æ•°æ—¶ï¼Œå…±äº«åŒºçš„æ–‡ä»¶å¥æŸ„å·²ç»å‡†å¤‡å¥½äº†ï¼Œä½†æ˜¯å†…å­˜è¿˜æ²¡æœ‰è¿›è¡Œæ˜ å°„ï¼Œè°ƒç”¨äº†mBufferMapper.registerBufferå‡½æ•°æ¥è¿›è¡Œå†…å­˜æ˜ å°„ã€‚ 4.1ã€å›¾å½¢ç¼“å†²åŒºçš„æ³¨å†Œè¿‡ç¨‹12345status_t GraphicBufferMapper::registerBuffer(const GraphicBuffer* buffer)&#123; gralloc1_error_t error = mDevice-&gt;retain(buffer); return error;&#125; ç”¨äº†mDevice-&gt;retain(buffer)å‡½æ•°ï¼Œ 123456789101112131415161718192021[-&gt;\\frameworks\\native\\libs\\ui\\Gralloc1On0Adapter.cpp]gralloc1_error_t Gralloc1On0Adapter::retain( const std::shared_ptr&lt;Buffer&gt;&amp; buffer)&#123; std::lock_guard&lt;std::mutex&gt; lock(mBufferMutex); buffer-&gt;retain(); return GRALLOC1_ERROR_NONE;&#125;gralloc1_error_t Gralloc1On0Adapter::retain( const android::GraphicBuffer* graphicBuffer)&#123; ...... buffer_handle_t handle = graphicBuffer-&gt;getNativeBuffer()-&gt;handle; std::lock_guard&lt;std::mutex&gt; lock(mBufferMutex); ALOGV(\"Calling registerBuffer(%p)\", handle); int result = mModule-&gt;registerBuffer(mModule, handle); ......&#125; ç»è¿‡ä¸€ç³»åˆ—æ­¥éª¤çš„è°ƒç”¨ 123456789101112131415161718192021222324252627282930313233343536373839[-&gt;/hardware/qcom/display/msm8996/libgralloc/mapper.cpp]int gralloc_register_buffer(gralloc_module_t const* module, buffer_handle_t handle)&#123; ...... int err = gralloc_map(module, handle); ...... return err;&#125;static int gralloc_map(gralloc_module_t const* module, buffer_handle_t handle)&#123; ...... private_handle_t* hnd = (private_handle_t*)handle; unsigned int size = 0; int err = 0; IMemAlloc* memalloc = getAllocator(hnd-&gt;flags) ; void *mappedAddress = MAP_FAILED; hnd-&gt;base = 0; // Dont map framebuffer and secure buffers if (!(hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER) &amp;&amp; !(hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_SECURE_BUFFER)) &#123; size = hnd-&gt;size; err = memalloc-&gt;map_buffer(&amp;mappedAddress, size, hnd-&gt;offset, hnd-&gt;fd); ...... hnd-&gt;base = uint64_t(mappedAddress) + hnd-&gt;offset; &#125; else &#123; err = -EACCES; &#125; //Allow mapping of metadata for all buffers including secure ones, but not //of framebuffer int metadata_err = gralloc_map_metadata(handle); return err;&#125; è¿›ä¸€æ­¥è°ƒç”¨ 1234567891011121314151617[-&gt;/hardware/qcom/display/msm8996/libgralloc/ionalloc.cpp]int IonAlloc::map_buffer(void **pBase, unsigned int size, unsigned int offset, int fd)&#123; ATRACE_CALL(); int err = 0; void *base = 0; // It is a (quirky) requirement of ION to have opened the // ion fd in the process that is doing the mapping err = open_device(); ...... base = mmap(0, size, PROT_READ| PROT_WRITE, MAP_SHARED, fd, 0); *pBase = base; ....... return err;&#125; è¿™ä¸ªå‡½æ•°å°±æ˜¯è°ƒç”¨äº†mmapæ¥è¿›è¡Œå…±äº«å†…å­˜çš„æ˜ å°„ã€‚ 4.2ã€å›¾å½¢ç¼“å†²åŒºçš„é‡Šæ”¾è¿‡ç¨‹é‡Šæ”¾è¿‡ç¨‹è°ƒç”¨æµç¨‹ç±»ä¼¼ï¼Œæœ€åä¼šè°ƒç”¨unmap_buffer()é‡Šæ”¾å›¾åƒç¼“å†²åŒºã€‚ 4.3ã€å°ç»“ ï¼ˆäº”ï¼‰HWComposeræ¨¡å—å‰é¢åˆ†æHWComposeræ„é€ å‡½æ•°æ²¡æœ‰åˆ†æloadHwcModule()å‡½æ•°ï¼ŒloadHwcModule()å‡½æ•°ç”¨æ¥åŠ è½½HWCæ¨¡å—ï¼Œæˆ‘ä»¬ç»§ç»­æŸ¥çœ‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[E-&gt;\\frameworks\\native\\services\\surfaceflinger\\DisplayHardware\\HWComposer_hwc1.cpp]HWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context),//è¿™é‡Œç›´æ¥newäº†ä¸€ä¸ªè®¾å¤‡ä¸Šä¸‹æ–‡å¯¹è±¡ mEventHandler(handler), mDebugForceFakeVSync(false)&#123; ...... //è£…è½½HWComposerçš„ç¡¬ä»¶æ¨¡å—,è¿™ä¸ªå‡½æ•°ä¸­ä¼šå°†mHwcç½®ä¸ºtrue loadHwcModule(); ...... //ç¡¬ä»¶vsyncä¿¡å· if (mHwc) &#123; ALOGI(\"Using %s version %u.%u\", HWC_HARDWARE_COMPOSER, (hwcApiVersion(mHwc) &gt;&gt; 24) &amp; 0xff, (hwcApiVersion(mHwc) &gt;&gt; 16) &amp; 0xff); if (mHwc-&gt;registerProcs) &#123; //HWComposerè®¾å¤‡ä¸Šä¸‹æ–‡å˜é‡mCBContextèµ‹å€¼ mCBContext-&gt;hwc = this; //å‡½æ•°æŒ‡é’ˆé’©å­å‡½æ•°hook_invalidateæ”¾å…¥ä¸Šä¸‹æ–‡ mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; //vsyncé’©å­å‡½æ•°æ”¾å…¥ä¸Šä¸‹æ–‡ mCBContext-&gt;procs.vsync = &amp;hook_vsync; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) //hotplugç‹—å­å‡½æ•°æ”¾å…¥ä¸Šä¸‹æ–‡ mCBContext-&gt;procs.hotplug = &amp;hook_hotplug; else mCBContext-&gt;procs.hotplug = NULL; memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero)); //å°†é’©å­å‡½æ•°æ³¨å†Œè¿›ç¡¬ä»¶è®¾å¤‡ï¼Œç¡¬ä»¶é©±åŠ¨å›è°ƒè¿™äº›é’©å­å‡½æ•° mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs); &#125; // don't need a vsync thread if we have a hardware composer //å¦‚æœæœ‰ç¡¬ä»¶vsyncä¿¡å·ï¼Œ åˆ™ä¸éœ€è¦è½¯ä»¶vsyncå®ç° needVSyncThread = false; ...... &#125;&#125;// Load and prepare the hardware composer module. Sets mHwc.void HWComposer::loadHwcModule()&#123; hw_module_t const* module; //åŒæ ·æ˜¯HALå±‚å°è£…çš„å‡½æ•°ï¼Œå‚æ•°æ˜¯HWC_HARDWARE_MODULE_IDï¼ŒåŠ è½½hwcæ¨¡å— if (hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;module) != 0) &#123; return; &#125; //æ‰“å¼€hwcè®¾å¤‡ int err = hwc_open_1(module, &amp;mHwc); ......&#125; å¦‚æœç¡¬ä»¶è®¾å¤‡æ‰“å¼€æˆåŠŸï¼Œåˆ™å°†é’©å­å‡½æ•°hook_invalidateã€hook_vsyncå’Œhook_hotplugæ³¨å†Œè¿›ç¡¬ä»¶è®¾å¤‡ï¼Œä½œä¸ºå›è°ƒå‡½æ•°ã€‚è¿™ä¸‰ä¸ªéƒ½æ˜¯ç¡¬ä»¶äº§ç”Ÿäº‹ä»¶ä¿¡å·ï¼Œé€šçŸ¥ä¸Šå±‚SurfaceFlingerçš„å›è°ƒå‡½æ•°ï¼Œç”¨äºå¤„ç†è¿™ä¸ªä¿¡å·ã€‚ å› ä¸ºæˆ‘ä»¬æœ¬èŠ‚æ˜¯Vsyncä¿¡å·ç›¸å…³ï¼Œæ‰€ä»¥æˆ‘ä»¬åªçœ‹çœ‹hook_vsyncé’©å­å‡½æ•°ã€‚è¿™é‡ŒæŒ‡å®šäº†vsyncçš„å›è°ƒå‡½æ•°æ˜¯hook_vsyncï¼Œå¦‚æœç¡¬ä»¶ä¸­äº§ç”Ÿäº†VSyncä¿¡å·ï¼Œå°†é€šè¿‡è¿™ä¸ªå‡½æ•°æ¥é€šçŸ¥ä¸Šå±‚ï¼Œçœ‹çœ‹å®ƒçš„ä»£ç ï¼š 1234567[E-&gt;\\frameworks\\native\\services\\surfaceflinger\\DisplayHardware\\HWComposer_hwc1.cpp]void HWComposer::hook_vsync(const struct hwc_procs* procs, int disp, int64_t timestamp) &#123; cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;( const_cast&lt;hwc_procs_t*&gt;(procs)); ctx-&gt;hwc-&gt;vsync(disp, timestamp);&#125; hook_vsyncé’©å­å‡½æ•°ä¼šè°ƒç”¨vsyncå‡½æ•°ï¼Œæˆ‘ä»¬ç»§ç»­çœ‹ï¼š 12345678910111213141516[E-&gt;\\frameworks\\native\\services\\surfaceflinger\\DisplayHardware\\HWComposer_hwc1.cpp]void HWComposer::vsync(int disp, int64_t timestamp) &#123; if (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123; &#123; Mutex::Autolock _l(mLock); mLastHwVSync[disp] = timestamp; &#125; char tag[16]; snprintf(tag, sizeof(tag), \"HW_VSYNC_%1u\", disp); ATRACE_INT(tag, ++mVSyncCounts[disp] &amp; 1); //è¿™é‡Œè°ƒç”¨EventHandlerç±»å‹å˜é‡mEventHandlerå°±æ˜¯SurfaceFlingerï¼Œ //æ‰€ä»¥è°ƒç”¨äº†SurfaceFlingerçš„onVSyncReceivedå‡½æ•° mEventHandler.onVSyncReceived(disp, timestamp); &#125;&#125; mEventHandlerå¯¹è±¡ç±»å‹ä¸ºEventHandlerï¼Œæˆ‘ä»¬åœ¨SurfaceFlingerçš„initå‡½æ•°åˆ›å»ºHWComposerç±»å®ä¾‹æ—¶å€™è®²SurfaceFlingerå¼ºè½¬ä¸ºEventHandlerä½œä¸ºæ„é€ å‡½æ•°çš„å‚æ•°ä¼ å…¥å…¶ä¸­ã€‚å†è€…SurfaceFlingerç»§æ‰¿HWComposer::EventHandlerï¼Œæ‰€ä»¥æœ€ç»ˆä¼šè°ƒç”¨SurfaceFlingerçš„onVSyncReceivedå‡½æ•°ï¼Œè¿™å°±æ˜¯ç¡¬ä»¶vsyncä¿¡å·çš„äº§ç”Ÿã€‚ 5.1ã€HWCè®¾å¤‡æ‰“å¼€è¿‡ç¨‹1234567[-&gt;/hardware/libhardware/include/hardware/hwcomposer.h]/** convenience API for opening and closing a device */static inline int hwc_open_1(const struct hw_module_t* module, hwc_composer_device_1_t** device) &#123; return module-&gt;methods-&gt;open(module, HWC_HARDWARE_COMPOSER, (struct hw_device_t**)device);&#125; å…·ä½“å®ç°/hardware/qcom/display/msm8996/sdm/libs/hwc/ or /hardware/qcom/display/msm8996/sdm/libs/hwc2/ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445[-&gt;/hardware/qcom/display/msm8996/sdm/libs/hwc/hwc_session.h] struct HWCModuleMethods : public hw_module_methods_t &#123; HWCModuleMethods() &#123; hw_module_methods_t::open = HWCSession::Open; &#125; &#125;;[-&gt;/hardware/qcom/display/msm8996/sdm/libs/hwc/hwc_session.cpp]int HWCSession::Open(const hw_module_t *module, const char *name, hw_device_t **device) &#123; ...... if (!strcmp(name, HWC_HARDWARE_COMPOSER)) &#123; HWCSession *hwc_session = new HWCSession(module); ...... int status = hwc_session-&gt;Init(); ...... hwc_composer_device_1_t *composer_device = hwc_session; *device = reinterpret_cast&lt;hw_device_t *&gt;(composer_device); &#125; return 0;&#125;HWCSession::HWCSession(const hw_module_t *module) &#123; // By default, drop any events. Calls will be routed to SurfaceFlinger after registerProcs. hwc_procs_default_.invalidate = Invalidate; hwc_procs_default_.vsync = VSync; hwc_procs_default_.hotplug = Hotplug; hwc_composer_device_1_t::common.tag = HARDWARE_DEVICE_TAG; hwc_composer_device_1_t::common.version = HWC_DEVICE_API_VERSION_1_5; hwc_composer_device_1_t::common.module = const_cast&lt;hw_module_t*&gt;(module); hwc_composer_device_1_t::common.close = Close; hwc_composer_device_1_t::prepare = Prepare; hwc_composer_device_1_t::set = Set; hwc_composer_device_1_t::eventControl = EventControl; hwc_composer_device_1_t::setPowerMode = SetPowerMode; hwc_composer_device_1_t::query = Query; hwc_composer_device_1_t::registerProcs = RegisterProcs; hwc_composer_device_1_t::dump = Dump; hwc_composer_device_1_t::getDisplayConfigs = GetDisplayConfigs; hwc_composer_device_1_t::getDisplayAttributes = GetDisplayAttributes; hwc_composer_device_1_t::getActiveConfig = GetActiveConfig; hwc_composer_device_1_t::setActiveConfig = SetActiveConfig; hwc_composer_device_1_t::setCursorPositionAsync = SetCursorPositionAsync;&#125; ï¼ˆå…­ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼š Androidç ”ç©¶ Gralloc &amp;&amp; HWComposerç³»åˆ—åˆ†æAndroid Display ç³»åˆ—åˆ†æAndroid display: framebuffer æ˜ å°„å…³ç³»Android displayæ¡†æ¶ä¸æ•°æ®æµAndroidå›¾å½¢æ˜¾ç¤ºä¹‹ç¡¬ä»¶æŠ½è±¡å±‚GrallocSurfaceFlingerä¸­Bufferçš„åˆ›å»ºä¸æ˜¾ç¤ºAndroid å›¾å½¢ç³»ç»Ÿä¹‹grallocæ·±å…¥å‰–æAndroidç³»ç»Ÿ æ˜¾ç¤ºæ¨¡å—Android SurfaceFlinger å­¦ä¹ ä¹‹è·¯","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æ ä¹‹  HardwareRenderer.draw()ç»˜åˆ¶æµç¨‹åˆ†æ","slug":"Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.drawç»˜åˆ¶æµç¨‹åˆ†æ","date":"2018-07-31T16:00:00.000Z","updated":"2018-06-20T15:11:18.995Z","comments":true,"path":"2018/08/01/Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.drawç»˜åˆ¶æµç¨‹åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/08/01/Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.drawç»˜åˆ¶æµç¨‹åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ ã€ç‰¹åˆ«æ„Ÿè°¢ - Androidåº”ç”¨ç¨‹åºUIç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“æŠ€æœ¯ç®€è¦ä»‹ç»å’Œå­¦ä¹ è®¡åˆ’ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Nä¸­UIç¡¬ä»¶æ¸²æŸ“ï¼ˆhwuiï¼‰çš„HWUI_NEW_OPS(åŸºäºAndroid 7.1)ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android DisplayList æ„å»ºè¿‡ç¨‹ã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ğŸŒ€ğŸŒ€ï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ ã€Android Display System ç³»ç»Ÿåˆ†æç³»åˆ—ã€‘ï¼šã€Android Display Systemï¼ˆ1ï¼‰ï¼šAndroid 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æã€‘ã€Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL &amp;&amp; OpenGLã€‘ã€Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.draw()ç»˜åˆ¶æµç¨‹åˆ†æã€‘ã€Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc &amp;&amp; HWComposeræ¨¡å—åˆ†æã€‘ã€Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architectureã€‘ \\frameworks\\base\\core\\java\\android\\view\\ ViewRootImpl.java RenderNode.java View.java DisplayListCanvas.java \\frameworks\\base\\core\\jni\\ android_view_DisplayListCanvas.cpp android_view_RenderNode.cpp android_view_ThreadedRenderer.cpp android_view_Surface.cpp android_server_AssetAtlasService.cpp \\frameworks\\base\\core\\jni\\android\\graphics\\ Graphics.cpp Bitmap.cpp \\frameworks\\base\\libs\\hwui\\ AssetAtlas.cpp BakedOpDispatcher.cpp BakedOpRenderer.cpp DeferredDisplayList.cpp DeferredLayerUpdater.cpp DisplayList.cpp DisplayListCanvas.cpp LayerBuilder.cpp LayerRenderer.cpp LayerUpdateQueue.cpp Patch.cpp RecordingCanvas.cpp RenderNode.cpp \\frameworks\\base\\libs\\hwui\\hwui\\ Canvas.cpp \\frameworks\\base\\libs\\hwui\\renderthread\\ EglManager.cpp CanvasContext.cpp DrawFrameTask.cpp RenderProxy.cpp RenderTask.cpp RenderThread.cpp UIä½œä¸ºç”¨æˆ·ä½“éªŒçš„æ ¸å¿ƒä¹‹ä¸€ï¼Œå§‹ç»ˆæ˜¯Androidæ¯æ¬¡å‡çº§ä¸­çš„é‡ç‚¹ã€‚ä»Androd 3.0(Honeycomb)å¼€å§‹ï¼ŒAndroidå¼€å§‹æ”¯æŒhwuiï¼ˆUIç¡¬ä»¶åŠ é€Ÿï¼‰ã€‚åˆ°Android 4.0ï¼ˆICSï¼‰æ—¶ï¼Œç¡¬ä»¶åŠ é€Ÿè¢«é»˜è®¤å¼€å¯ã€‚åŒæ—¶ICSè¿˜å¼•å…¥äº†DisplayListçš„æ¦‚å¿µï¼ˆä¸æ˜¯OpenGLé‡Œçš„é‚£ä¸ªï¼‰ï¼Œå®ƒç›¸å½“äºæ˜¯ä»Viewçš„ç»˜åˆ¶å‘½ä»¤åˆ°GLå‘½ä»¤ä¹‹é—´çš„â€œä¸­é—´è¯­è¨€â€ã€‚å®ƒè®°å½•äº†ç»˜åˆ¶è¯¥Viewæ‰€éœ€çš„å…¨éƒ¨ä¿¡æ¯ï¼Œä¹‹ååªè¦é‡æ”¾ï¼ˆreplayï¼‰å³å¯å®Œæˆå†…å®¹çš„ç»˜åˆ¶ã€‚è¿™æ ·å¦‚æœViewæ²¡æœ‰æ”¹åŠ¨æˆ–åªéƒ¨åˆ†æ”¹åŠ¨ï¼Œä¾¿å¯é‡ç”¨æˆ–ä¿®æ”¹DisplayListï¼Œä»è€Œé¿å…è°ƒç”¨äº†ä¸€äº›ä¸Šå±‚ä»£ç ï¼Œæé«˜äº†æ•ˆç‡ã€‚Android 4.3ï¼ˆJBï¼‰ä¸­å¼•å…¥äº†DisplayListçš„deferæ“ä½œï¼Œå®ƒä¸»è¦ç”¨äºå¯¹DisplayListä¸­å‘½ä»¤è¿›è¡ŒBatchï¼ˆæ‰¹æ¬¡ï¼‰å’ŒMergeï¼ˆåˆå¹¶ï¼‰ã€‚è¿™æ ·å¯ä»¥å‡å°‘GL draw callå’Œcontextåˆ‡æ¢ä»¥æé«˜æ•ˆç‡ã€‚ä¹‹åï¼Œåœ¨Android 5.0ï¼ˆLollipopï¼‰ä¸­åˆå¼•å…¥äº†RenderNodeï¼ˆæ¸²æŸ“èŠ‚ç‚¹ï¼‰çš„æ¦‚å¿µï¼Œå®ƒæ˜¯å¯¹DisplayListåŠä¸€äº›Viewæ˜¾ç¤ºå±æ€§çš„è¿›ä¸€æ­¥å°è£…ã€‚ä»£ç ä¸Šï¼Œä¸€ä¸ªViewå¯¹åº”ä¸€ä¸ªRenderNodeï¼ˆNativeå±‚å¯¹åº”åŒåç±»ï¼‰ï¼Œå…¶ä¸­ç®¡ç†ç€å¯¹åº”çš„DisplayListå’ŒOffscreenBufferï¼ˆå¦‚æœè¯¥Viewä¸ºç¡¬ä»¶ç»˜åˆ¶å±‚ï¼‰ã€‚æ¯ä¸ªå‘WindowManagerServiceæ³¨å†Œçš„çª—å£å¯¹åº”ä¸€ä¸ªRootRenderNodeï¼Œé€šè¿‡å®ƒå¯ä»¥æ‰¾åˆ°Viewå±‚æ¬¡ç»“æ„ä¸­æ‰€æœ‰Viewçš„DisplayListä¿¡æ¯ã€‚åœ¨Javaå±‚çš„DisplayListCanvasç”¨äºç”ŸæˆDisplayListï¼Œå…¶åœ¨nativeå±‚çš„å¯¹åº”ç±»ä¸ºRecordingCanvasï¼ˆåœ¨Android Nå‰ä¸ºDisplayListCanvasï¼‰ã€‚å¦å¤–Android Lä¸­è¿˜å¼•å…¥äº†RenderThreadï¼ˆæ¸²æŸ“çº¿ç¨‹ï¼‰ã€‚æ‰€æœ‰çš„GLå‘½ä»¤æ‰§è¡Œéƒ½æ”¾åˆ°è¿™ä¸ªçº¿ç¨‹ä¸Šã€‚æ¸²æŸ“çº¿ç¨‹åœ¨RenderNodeä¸­å­˜æœ‰æ¸²æŸ“å¸§çš„æ‰€æœ‰ä¿¡æ¯ï¼Œä¸”è¿˜ç›‘å¬VSyncä¿¡å·ï¼Œå› æ­¤å¯ä»¥ç‹¬ç«‹åšä¸€äº›å±æ€§åŠ¨ç”»ã€‚è¿™æ ·å³ä¾¿ä¸»çº¿ç¨‹blockä¹Ÿå¯ä»¥ä¿è¯åŠ¨ç”»æµç•…ã€‚å¼•å…¥æ¸²æŸ“çº¿ç¨‹åThreadedRendereræ›¿ä»£äº†Gl20Rendererï¼Œä½œä¸ºproxyç”¨äºä¸»çº¿ç¨‹ï¼ˆUIçº¿ç¨‹ï¼‰æŠŠæ¸²æŸ“ä»»åŠ¡äº¤ç»™æ¸²æŸ“çº¿ç¨‹ã€‚è¿‘æœŸï¼Œåœ¨Android 7.0ï¼ˆNougatï¼‰ä¸­åˆå¯¹hwuiè¿›è¡Œäº†å°è§„æ¨¡é‡æ„ï¼Œå¼•å…¥äº†BakedOpRenderer, FrameBuilder, LayerBuilder, RecordingCanvasç­‰ç±»ï¼Œç”¨å®HWUI_NEW_OPSç®¡ç†ã€‚ä¸‹é¢ç®€å•ä»‹ç»ä¸‹è¿™äº›æ–°æˆå‘˜ï¼š â˜¯ RecordingCanvas: ä¹‹å‰Javaå±‚çš„DisplayListCanvaså¯¹åº”nativeå±‚çš„DisplayListCanvasã€‚å¼•å…¥RecordingCanvasåï¼Œå…¶åœ¨nativeå±‚çš„å¯¹åº”ç‰©å°±å˜æˆäº†RecordingCanvasã€‚å’ŒDisplayListCanvasç±»ä¼¼ï¼Œç”»åœ¨RecordingCanvasä¸Šçš„å†…å®¹éƒ½ä¼šè¢«è®°å½•åœ¨RenderNodeçš„DisplayListä¸­ã€‚ â˜¯ BakedOpRenderer: é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯ç”¨äºç»˜åˆ¶batch/mergeå¥½çš„æ“ä½œã€‚ç”¨äºæ›¿ä»£ä¹‹å‰çš„OpenGLRendererã€‚å®ƒæ˜¯çœŸæ­£ç”¨GLç»˜åˆ¶åˆ°on-screen surfaceä¸Šçš„ã€‚ â˜¯ BakedOpDispatcher: æä¾›ä¸€ç³»åˆ—onXXXï¼ˆå¦‚onBitmapOpï¼‰å’ŒonMergedXXXï¼ˆå¦‚onMergedBitmapOpsï¼‰é™æ€å‡½æ•°ä¾›replayæ—¶è°ƒç”¨ã€‚è¿™äº›dispatchå‡½æ•°æœ€åä¸€èˆ¬éƒ½ä¼šé€šè¿‡GlopBuilderæ¥æ„é€ Glopç„¶åé€šè¿‡BakedOpRendererçš„renderGlop()å‡½æ•°æ¥ç”¨OpenGLç»˜åˆ¶ã€‚ â˜¯ LayerBuilder: ç”¨äºå­˜å‚¨ç»˜åˆ¶æŸä¸€å±‚çš„æ“ä½œå’ŒçŠ¶æ€ã€‚æ›¿ä»£äº†éƒ¨åˆ†åŸDeferredDisplayListçš„å·¥ä½œã€‚å¯¹äºæ‰€æœ‰Viewé€šç”¨ï¼Œå³å¦‚æœViewæœ‰render layerï¼Œå®ƒå¯¹åº”ä¸€ä¸ªFBOï¼›å¦‚æœå¯¹äºæ™®é€šViewï¼Œå®ƒå¯¹åº”çš„æ˜¯SurfaceFlingeræä¾›çš„surfaceã€‚ å…¶ä¸­çš„mBatcheså­˜å‚¨äº†å½“å‰å±‚deferåï¼ˆå³batch/mergeå¥½ï¼‰çš„ç»˜åˆ¶æ“ä½œã€‚ â˜¯ FrameBuilder: ç®¡ç†æŸä¸€å¸§çš„æ„å»ºï¼Œç”¨äºå¤„ç†ï¼Œä¼˜åŒ–å’Œå­˜å‚¨ä»RenderNodeå’ŒLayerUpdateQueueä¸­æ¥çš„æ¸²æŸ“å‘½ä»¤ï¼ŒåŒæ—¶å®ƒçš„replayBakedOps()æ–¹æ³•è¿˜ç”¨äºè¯¥å¸§çš„ç»˜åˆ¶å‘½ä»¤é‡æ”¾ã€‚ä¸€å¸§ä¸­å¯èƒ½éœ€è¦ç»˜åˆ¶å¤šä¸ªå±‚ï¼Œæ¯ä¸€å±‚çš„ä¸Šä¸‹æ–‡éƒ½ä¼šå­˜åœ¨ç›¸åº”çš„LayerBuilderä¸­ã€‚åœ¨FrameBuilderä¸­é€šè¿‡mLayerBuilderså’ŒmLayerStackå­˜å‚¨ä¸€ä¸ªlayer stackã€‚å®ƒæ›¿ä»£äº†åŸSnapshotç±»çš„ä¸€éƒ¨åˆ†åŠŸèƒ½ã€‚ â˜¯ OffscreenBuffer: ç”¨äºæ›¿ä»£Layerç±»ï¼Œä½†æ˜¯è®¾è®¡ä¸Šæ›´è½»é‡ï¼Œè€Œä¸”è‡ªå¸¦å†…å­˜æ± ï¼ˆé€šè¿‡OffscreenBufferPoolï¼‰ã€‚ â˜¯ LayerUpdateQueueï¼šç”¨äºè®°å½•ç±»å‹ä¸ºç¡¬ä»¶ç»˜åˆ¶å±‚çš„RenderNodeçš„æ›´æ–°æ“ä½œã€‚ä¹‹åä¼šé€šè¿‡FrameBuilderå°†è¯¥layerå¯¹åº”çš„RenderNodeé€šè¿‡deferNodeOps()æ–¹æ³•è¿›è¡Œå¤„ç†ã€‚ â˜¯ RecordedOp: ç”±RecordedCanvaså°†Viewä¸­çš„ç»˜åˆ¶å‘½ä»¤è½¬åŒ–ä¸ºRecordedOpã€‚RecordedOpä¹Ÿæ˜¯DisplayListä¸­çš„åŸºæœ¬å…ƒç´ ï¼Œç”¨äºæ›¿ä»£Android Nä¹‹å‰çš„DisplayListOpã€‚å®ƒæœ‰ä¸€å¨å„å¼å„æ ·çš„ç»§æ‰¿ç±»ä»£è¡¨å„ç§å„æ ·çš„ç»˜åˆ¶æ“ä½œã€‚BakedOpStateæ˜¯RecordedOpå’Œç›¸åº”çš„çŠ¶æ€çš„è‡ªåŒ…å«å°è£…ï¼ˆå°è£…çš„è¿‡ç¨‹ç§°ä¸ºbakeï¼‰ã€‚ â˜¯ BatchBase: LayerBuilderä¸­å¯¹DisplayListè¿›è¡Œbatch/mergeå¤„ç†åçš„ç»“æœä»¥BatchBaseå½¢å¼ä¿å­˜åœ¨LayerBuilderçš„mBatchesæˆå‘˜ä¸­ã€‚å®ƒæœ‰ä¸¤ä¸ªç»§æ‰¿ç±»åˆ†åˆ«ä¸ºOpBatchå’ŒMergingOpBatchï¼Œåˆ†åˆ«ç”¨äºä¸å¯åˆå¹¶å’Œå¯åˆå¹¶æ“ä½œã€‚ æ¦‚æ‹¬ä¸‹å®ƒä»¬å’Œç›¸å…³ç±»çš„å…³ç³»å›¾å¦‚ä¸‹ï¼Œæ¥ä¸‹æ¥ä»DisplayList(RenderNode)çš„æ„å»ºå’Œç»˜åˆ¶ä¸¤ä¸ªé˜¶æ®µåˆ†æä¸‹å…·ä½“æœ‰å“ªäº›æ”¹åŠ¨ã€‚ é¦–å…ˆçœ‹çœ‹æ€»ä½“æ—¶åºå›¾ï¼šç„¶åä¸€æ­¥ä¸€æ­¥åˆ†æï¼š ï¼ˆä¸€ï¼‰ã€Androidç¡¬ä»¶æ¸²æŸ“ç¯å¢ƒåˆå§‹åŒ–ViewRootImpl.enableHardwareAcceleration()åœ¨ViewRootImpl.javaçš„setViewé‡Œï¼Œä¼šå»enableç¡¬ä»¶åŠ é€ŸåŠŸèƒ½ã€‚å¦‚æœå½“å‰åˆ›å»ºçš„çª—å£æ”¯æŒç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“ï¼Œé‚£ä¹ˆå°±ä¼šåˆ›å»ºä¸€ä¸ªHardwareRendererå¯¹è±¡ï¼Œè¿™ä¸ªHardwareRendererå¯¹è±¡ä»¥åå°†è´Ÿè´£æ‰§è¡Œçª—å£ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“çš„ç›¸å…³æ“ä½œã€‚123456789101112131415[-&gt;\\frameworks\\base\\core\\java\\android\\view\\ViewRootImpl.java]private void enableHardwareAcceleration(WindowManager.LayoutParams attrs) &#123; ...... if (hardwareAccelerated) &#123; ...... if (fakeHwAccelerated) &#123; ...... &#125; else if (!ThreadedRenderer.sRendererDisabled || (ThreadedRenderer.sSystemRendererDisabled &amp;&amp; forceHwAccelerated)) &#123; ...... mAttachInfo.mHardwareRenderer = ThreadedRenderer.create(mContext, translucent); ...... &#125; &#125; &#125; ThreadedRendererç±»çš„é™æ€æˆå‘˜å‡½æ•°createçš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 1.1ã€ThreadedRendereråˆ›å»ºè¿‡ç¨‹123456789101112131415161718192021[-&gt;frameworks\\base\\core\\java\\android\\view\\ThreadedRenderer.java] public static ThreadedRenderer create(Context context, boolean translucent) &#123; ThreadedRenderer renderer = null; if (DisplayListCanvas.isAvailable()) &#123; renderer = new ThreadedRenderer(context, translucent); &#125; return renderer; &#125; ThreadedRenderer(Context context, boolean translucent) &#123; ...... //1ã€nCreateRootRenderNodeåœ¨Nativeå±‚åˆ›å»ºäº†ä¸€ä¸ªRender Node long rootNodePtr = nCreateRootRenderNode(); mRootNode = RenderNode.adopt(rootNodePtr); ...... //2ã€nCreateProxyåœ¨Nativeå±‚åˆ›å»ºäº†ä¸€ä¸ªRender Proxyå¯¹è±¡ mNativeProxy = nCreateProxy(translucent, rootNodePtr); //3ã€åˆå§‹åŒ–ä¸€ä¸ªç³»ç»Ÿé¢„åŠ è½½èµ„æºçš„åœ°å›¾é›†,ä¼˜åŒ–èµ„æºçš„å†…å­˜ä½¿ç”¨ ProcessInitializer.sInstance.init(context, mNativeProxy); loadSystemProperties(); &#125; 1.1.1ã€åˆ›å»ºRenderNodenCreateRootRenderNodeåœ¨Nativeå±‚åˆ›å»ºäº†ä¸€ä¸ªRender Nodeã€‚ ä»è¿™é‡Œå°±å¯ä»¥çœ‹å‡ºï¼Œçª—å£åœ¨Nativeå±‚çš„Root Render Nodeå®é™…ä¸Šæ˜¯ä¸€ä¸ªRootRenderNodeå¯¹è±¡ã€‚12345678910111213141516[-&gt;\\frameworks\\base\\core\\jni\\android_view_ThreadedRenderer.cpp]class RootRenderNode : public RenderNode, ErrorHandler &#123;public: RootRenderNode(JNIEnv* env) : RenderNode() &#123; mLooper = Looper::getForThread(); env-&gt;GetJavaVM(&amp;mVm); &#125; ......&#125;static jlong android_view_ThreadedRenderer_createRootRenderNode(JNIEnv* env, jobject clazz) &#123; RootRenderNode* node = new RootRenderNode(env); node-&gt;incStrong(0); node-&gt;setName(\"RootRenderNode\"); return reinterpret_cast&lt;jlong&gt;(node);&#125; å¯ä»¥çœ‹å‡ºä¼šåˆ›å»ºä¸€ä¸ªC++å±‚çš„RootRenderNodeå¯¹è±¡ï¼ŒRootRenderNodeç»§æ‰¿è‡ªRenderNodeï¼Œå»çœ‹çœ‹RenderNodeæ„é€ å‡½æ•°ã€‚ 123456789[-&gt;\\frameworks\\base\\libs\\hwui\\RenderNode.cpp]RenderNode::RenderNode() : mDirtyPropertyFields(0) , mNeedsDisplayListSync(false) , mDisplayList(nullptr) , mStagingDisplayList(nullptr) , mAnimatorManager(*this) , mParentCount(0) &#123;&#125; æœ‰äº†è¿™ä¸ªRootRenderNodeå¯¹è±¡ä¹‹åï¼Œå‡½æ•°android_view_ThreadedRenderer_createProxyå°±åˆ›å»ºäº†ä¸€ä¸ªRenderProxyå¯¹è±¡ã€‚ 1.1.2ã€åˆ›å»ºRenderProxy1234567[-&gt;\\frameworks\\base\\core\\jni\\android_view_ThreadedRenderer.cpp]static jlong android_view_ThreadedRenderer_createProxy(JNIEnv* env, jobject clazz, jboolean translucent, jlong rootRenderNodePtr) &#123; RootRenderNode* rootRenderNode = reinterpret_cast&lt;RootRenderNode*&gt;(rootRenderNodePtr); ContextFactoryImpl factory(rootRenderNode); return (jlong) new RenderProxy(translucent, rootRenderNode, &amp;factory);&#125; RenderProxyå¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹å¦‚ä¸‹æ‰€ç¤º 123456789101112 [-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderProxy.cpp] RenderProxy::RenderProxy(bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory) : mRenderThread(RenderThread::getInstance()) , mContext(nullptr) &#123; SETUP_TASK(createContext); args-&gt;translucent = translucent; args-&gt;rootRenderNode = rootRenderNode; args-&gt;thread = &amp;mRenderThread; args-&gt;contextFactory = contextFactory; mContext = (CanvasContext*) postAndWait(task); mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);&#125; RenderProxyç±»æœ‰ä¸‰ä¸ªé‡è¦çš„æˆå‘˜å˜é‡mRenderThreadã€mContextå’ŒmDrawFrameTaskï¼ŒmRenderThreadæè¿°çš„å°±æ˜¯Render Threadï¼ŒmContextæè¿°çš„æ˜¯ä¸€ä¸ªç”»å¸ƒä¸Šä¸‹æ–‡ï¼ŒmDrawFrameTaskæè¿°çš„æ˜¯ä¸€ä¸ªç”¨æ¥æ‰§è¡Œæ¸²æŸ“ä»»åŠ¡çš„Task 1.1.2.1ã€RenderThread å®ä¾‹åŒ–æ¥çœ‹çœ‹RenderThread::getInstance()å®ä¾‹åŒ–è¿‡ç¨‹ 123456789101112131415161718192021222324252627282930313233343536373839404142434445[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderThread.cpp]RenderThread&amp; RenderThread::getInstance() &#123; static RenderThread* sInstance = new RenderThread(); gHasRenderThreadInstance = true; return *sInstance;&#125;RenderThread::RenderThread() : Thread(true) , mNextWakeup(LLONG_MAX) , mDisplayEventReceiver(nullptr) , mVsyncRequested(false) , mFrameCallbackTaskPending(false) , mFrameCallbackTask(nullptr) , mRenderState(nullptr) , mEglManager(nullptr) &#123; Properties::load(); mFrameCallbackTask = new DispatchFrameCallbacks(this); mLooper = new Looper(false); run(\"RenderThread\");&#125;//RenderThreadç±»çš„æˆå‘˜å˜é‡mFrameCallbackTaskæè¿°çš„Taskæ˜¯ç”¨æ¥åšä»€ä¹ˆçš„å‘¢ï¼ŸåŸæ¥å°±æ˜¯ç”¨æ¥æ˜¾ç¤ºåŠ¨ç”»çš„ã€‚å½“Javaå±‚æ³¨å†Œä¸€ä¸ªåŠ¨ç”»//ç±»å‹çš„Render Nodeåˆ°Render Threadæ—¶ï¼Œä¸€ä¸ªç±»å‹ä¸ºIFrameCallbackçš„å›è°ƒæ¥å£å°±ä¼šé€šè¿‡RenderThreadç±»çš„æˆå‘˜å‡½æ•°//postFrameCallbackæ³¨å†Œåˆ°Render Threadçš„ä¸€ä¸ªPending Registration Frame Callbacksåˆ—è¡¨ä¸­class DispatchFrameCallbacks : public RenderTask &#123;private: RenderThread* mRenderThread;public: DispatchFrameCallbacks(RenderThread* rt) : mRenderThread(rt) &#123;&#125; virtual void run() override &#123; mRenderThread-&gt;dispatchFrameCallbacks(); &#125;&#125;;void RenderThread::dispatchFrameCallbacks() &#123; ...... if (callbacks.size()) &#123; ...... requestVsync(); for (std::set&lt;IFrameCallback*&gt;::iterator it = callbacks.begin(); it != callbacks.end(); it++) &#123; (*it)-&gt;doFrame(); &#125; &#125;&#125; 1ã€mFrameCallbackTaskæŒ‡å‘ä¸€ä¸ªDispatchFrameCallbackså¯¹è±¡ï¼Œç”¨æ¥æè¿°ä¸€ä¸ªå¸§ç»˜åˆ¶ä»»åŠ¡2ã€mLooperæŒ‡å‘ä¸€ä¸ªLooperå¯¹è±¡ï¼Œæ¶ˆæ¯é©±åŠ¨æ¨¡å‹3ã€RenderThreadç±»æ˜¯ä»Threadç±»ç»§æ‰¿ä¸‹æ¥çš„ï¼Œå½“æˆ‘ä»¬è°ƒç”¨å®ƒçš„æˆå‘˜å‡½æ•°runçš„æ—¶å€™ï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ã€‚è¿™ä¸ªæ–°çš„çº¿ç¨‹çš„å…¥å£ç‚¹å‡½æ•°ä¸ºRenderThreadç±»çš„æˆå‘˜å‡½æ•°threadLoopï¼Œå®ƒçš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderThread.cpp]bool RenderThread::threadLoop() &#123; setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY); initThreadLocals(); int timeoutMillis = -1; for (;;) &#123; int result = mLooper-&gt;pollOnce(timeoutMillis); nsecs_t nextWakeup; // Process our queue, if we have anything while (RenderTask* task = nextTask(&amp;nextWakeup)) &#123; task-&gt;run(); // task may have deleted itself, do not reference it again &#125; ...... if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123; drainDisplayEventQueue(); mFrameCallbacks.insert( mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end()); mPendingRegistrationFrameCallbacks.clear(); requestVsync(); &#125; if (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123; requestVsync(); &#125; &#125; return false;&#125; è¿™é‡Œæˆ‘ä»¬å°±å¯ä»¥çœ‹åˆ°Render Threadçš„è¿è¡Œæ¨¡å‹ï¼š1ã€ç©ºé—²çš„æ—¶å€™ï¼ŒRender Threadå°±ç¡çœ åœ¨æˆå‘˜å˜é‡mLooperæŒ‡å‘çš„ä¸€ä¸ªLooperå¯¹è±¡çš„æˆå‘˜å‡½æ•°pollOnceä¸­ã€‚2ã€å½“å…¶å®ƒçº¿ç¨‹éœ€è¦è°ƒåº¦Render Threadï¼Œå°±ä¼šå‘å®ƒçš„ä»»åŠ¡é˜Ÿåˆ—å¢åŠ ä¸€ä¸ªä»»åŠ¡ï¼Œç„¶åå”¤é†’Render Threadè¿›è¡Œå¤„ç†ã€‚Render Threadé€šè¿‡æˆå‘˜å‡½æ•°nextTaskè·å¾—éœ€è¦å¤„ç†çš„ä»»åŠ¡ï¼Œå¹¶ä¸”è°ƒç”¨å®ƒçš„æˆå‘˜å‡½æ•°runè¿›è¡Œå¤„ç†ã€‚RenderThreadç±»çš„æˆå‘˜å‡½æ•°nextTaskçš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderThread.cpp]RenderTask* RenderThread::nextTask(nsecs_t* nextWakeup) &#123; AutoMutex _lock(mLock); RenderTask* next = mQueue.peek(); if (!next) &#123; mNextWakeup = LLONG_MAX; &#125; else &#123; ...... if (next-&gt;mRunAt &lt;= 0 || next-&gt;mRunAt &lt;= systemTime(SYSTEM_TIME_MONOTONIC)) &#123; next = mQueue.next(); &#125; else &#123; next = nullptr; &#125; &#125; ...... return next;&#125; æ³¨æ„ï¼Œå¦‚æœæ²¡æœ‰ä¸‹ä¸€ä¸ªä»»åŠ¡å¯ä»¥æ‰§è¡Œï¼Œé‚£ä¹ˆRenderThreadç±»çš„æˆå‘˜å‡½æ•°nextTaské€šè¿‡å‚æ•°nextWakeupè¿”å›çš„å€¼ä¸ºLLONG_MAXï¼Œè¡¨ç¤ºRender Threadæ¥ä¸‹æ¥æ— é™æœŸè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œç›´åˆ°è¢«å…¶å®ƒçº¿ç¨‹å”¤é†’ä¸ºæ­¢ã€‚ RenderThreadç±»æä¾›äº†queueã€queueAndWaitã€queueAtFrontå’ŒqueueAtå››ä¸ªæˆå‘˜å‡½æ•°å‘Task Queueå¢åŠ ä¸€ä¸ªTaskï¼Œå®ƒä»¬çš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderThread.cpp]void RenderThread::queue(RenderTask* task) &#123; AutoMutex _lock(mLock); mQueue.queue(task); if (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123; mNextWakeup = 0; mLooper-&gt;wake(); &#125;&#125;void RenderThread::queueAndWait(RenderTask* task) &#123; Mutex mutex; Condition condition; SignalingRenderTask syncTask(task, &amp;mutex, &amp;condition); AutoMutex _lock(mutex); queue(&amp;syncTask); condition.wait(mutex);&#125;void RenderThread::queueAtFront(RenderTask* task) &#123; AutoMutex _lock(mLock); mQueue.queueAtFront(task); mLooper-&gt;wake();&#125;void RenderThread::queueAt(RenderTask* task, nsecs_t runAtNs) &#123; task-&gt;mRunAt = runAtNs; queue(task);&#125; å†æ¥çœ‹Render Threadåœ¨è¿›å…¥æ— é™å¾ªç¯ä¹‹å‰è°ƒç”¨çš„initThreadLocals()å‡½æ•° 1234567891011[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderThread.cpp]void RenderThread::initThreadLocals() &#123; sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay( ISurfaceComposer::eDisplayIdMain)); status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;mDisplayInfo); ...... initializeDisplayEventReceiver(); mEglManager = new EglManager(*this); mRenderState = new RenderState(*this); mJankTracker = new JankTracker(mDisplayInfo);&#125; 1ã€initializeDisplayEventReceiveråˆ›å»ºå’Œåˆå§‹åŒ–ä¸€ä¸ªDisplayEventReceiverå¯¹è±¡ï¼Œç”¨æ¥æ¥æ”¶Vsyncä¿¡å·ã€‚äº§ç”ŸVsyncä¿¡å·æ—¶ï¼ŒSurfaceFlingeræœåŠ¡ï¼ˆVsyncä¿¡å·ç”±SurfaceFlingeræœåŠ¡è¿›è¡Œç®¡ç†å’Œåˆ†å‘ï¼‰ä¼šé€šè¿‡ä¸Šè¿°æ–‡ä»¶æè¿°ç¬¦å·å”¤é†’Render Threadã€‚è¿™æ—¶å€™Render Threadå°±ä¼šè°ƒç”¨RenderThreadç±»çš„é™æ€æˆå‘˜å‡½æ•°displayEventReceiverCallback()-&gt;drainDisplayEventQueue()-&gt;2ã€åˆ›å»ºä¸€ä¸ªEglManagerå¯¹è±¡ï¼Œä¹‹åä¼šè°ƒç”¨EglManager::initialize() Open GL ESç¯å¢ƒåˆå§‹åŒ–3ã€åˆ›å»ºä¸€ä¸ªRenderStateå¯¹è±¡ï¼ˆè®°å½•Render Threadå½“å‰çš„ä¸€äº›æ¸²æŸ“çŠ¶æ€ï¼‰ 1.1.2.2ã€CanvasContext(ç”»å¸ƒä¸Šä¸‹æ–‡)çš„åˆå§‹åŒ–è¿‡ç¨‹äº†è§£äº†Render Threadçš„åˆ›å»ºè¿‡ç¨‹ä¹‹åï¼Œå›åˆ°RenderProxyç±»çš„æ„é€ å‡½æ•°ä¸­ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­åˆ†æå®ƒçš„æˆå‘˜å˜é‡mContextçš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯ç”»å¸ƒä¸Šä¸‹æ–‡çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚è¿™æ˜¯é€šè¿‡å‘Render Threadå‘é€ä¸€ä¸ªcreateContextå‘½ä»¤æ¥å®Œæˆçš„ã€‚ä¸ºäº†æ–¹ä¾¿æè¿°ï¼Œæˆ‘ä»¬å°†ç›¸å…³çš„ä»£ç åˆ—å‡ºæ¥ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderProxy.cpp]#define ARGS(method) method ## Args #define CREATE_BRIDGE4(name, a1, a2, a3, a4) CREATE_BRIDGE(name, a1,a2,a3,a4,,,,) #define CREATE_BRIDGE(name, a1, a2, a3, a4, a5, a6, a7, a8) \\ typedef struct &#123; \\ a1; a2; a3; a4; a5; a6; a7; a8; \\ &#125; ARGS(name); \\ static void* Bridge_ ## name(ARGS(name)* args) #define SETUP_TASK(method) \\ ....... MethodInvokeRenderTask* task = new MethodInvokeRenderTask((RunnableMethod) Bridge_ ## method); \\ ARGS(method) *args = (ARGS(method) *) task-&gt;payload() CREATE_BRIDGE4(createContext, RenderThread* thread, bool translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory) &#123; return new CanvasContext(*args-&gt;thread, args-&gt;translucent, args-&gt;rootRenderNode, args-&gt;contextFactory); &#125; æˆ‘ä»¬é¦–å…ˆçœ‹å®SETUP_TASKï¼Œå®ƒéœ€è¦ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ã€‚è¿™ä¸ªå‡½æ•°é€šè¿‡CREATE_BRIDGEXæ¥å£°æ˜ï¼Œå…¶ä¸­Xæ˜¯ä¸€ä¸ªæ•°å­—ï¼Œæ•°å­—çš„å¤§å°å°±ç­‰äºå‡½æ•°éœ€è¦çš„å‚æ•°çš„ä¸ªæ•°ã€‚ä¾‹å¦‚ï¼Œé€šè¿‡CREATE_BRIDGE4å£°æ˜çš„å‡½æ•°æœ‰4ä¸ªå‚æ•°ã€‚åœ¨ä¸Šé¢çš„ä»£ç æ®µä¸­ï¼Œæˆ‘ä»¬é€šè¿‡CREATE_BRIDGE4å®å£°æ˜äº†ä¸€ä¸ªcreateContextå‡½æ•°ã€‚ å®SETUP_TASKçš„ä½œç”¨åˆ›å»ºä¸€ä¸ªç±»å‹MethodInvokeRenderTaskçš„Taskã€‚è¿™ä¸ªTaskå…³è”æœ‰ä¸€ä¸ªç”±CREATE_BRIDGEXå®å£°æ˜çš„å‡½æ•°ã€‚ä¾‹å¦‚ï¼ŒSETUP_TASK(createContext)åˆ›å»ºçš„MethodInvokeRenderTaskå…³è”çš„å‡½æ•°æ˜¯ç”±CREATE_BRIDGE4å£°æ˜çš„å‡½æ•°createContextã€‚è¿™ä¸ªTaskæœ€ç»ˆä¼šé€šè¿‡RenderProxyç±»çš„æˆå‘˜å‡½æ•°postAndWaitæ·»åŠ åˆ°Render Threadçš„Task Queueä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\RenderProxy.cpp]void* RenderProxy::postAndWait(MethodInvokeRenderTask* task) &#123; void* retval; task-&gt;setReturnPtr(&amp;retval); SignalingRenderTask syncTask(task, &amp;mSyncMutex, &amp;mSyncCondition); AutoMutex _lock(mSyncMutex); mRenderThread.queue(&amp;syncTask); mSyncCondition.wait(mSyncMutex); return retval;&#125; RenderProxyå¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹å°±åˆ†æå®Œæˆäº†ï¼Œä»ä¸­æˆ‘ä»¬ä¹Ÿçœ‹åˆ°Render Threadçš„åˆ›å»ºè¿‡ç¨‹å’Œè¿è¡Œæ¨¡å‹ï¼Œä»¥åŠRender Proxyä¸Render Threadçš„äº¤äº’æ¨¡å‹ï¼Œæ€»ç»“æ¥è¯´ï¼š 1ã€RenderProxyå†…éƒ¨æœ‰ä¸€ä¸ªæˆå‘˜å˜é‡mRenderThreadï¼Œå®ƒæŒ‡å‘çš„æ˜¯ä¸€ä¸ªRenderThreadå¯¹è±¡ï¼Œé€šè¿‡å®ƒå¯ä»¥å‘Render Threadçº¿ç¨‹å‘é€å‘½ä»¤ã€‚ 2ã€ RenderProxyå†…éƒ¨æœ‰ä¸€ä¸ªæˆå‘˜å˜é‡mContextï¼Œå®ƒæŒ‡å‘çš„æ˜¯ä¸€ä¸ªCanvasContextå¯¹è±¡ï¼ŒRender Threadçš„æ¸²æŸ“å·¥ä½œå°±æ˜¯é€šè¿‡å®ƒæ¥å®Œæˆçš„ã€‚ 3ã€RenderProxyå†…éƒ¨æœ‰ä¸€ä¸ªæˆå‘˜å˜é‡mDrawFrameTaskï¼Œå®ƒæŒ‡å‘çš„æ˜¯ä¸€ä¸ªDrawFrameTaskå¯¹è±¡ï¼ŒMain Threadé€šè¿‡å®ƒå‘Render Threadçº¿ç¨‹å‘é€æ¸²æŸ“ä¸‹ä¸€å¸§çš„å‘½ä»¤ã€‚ ï¼ˆäºŒï¼‰ã€Open GL ESç¯å¢ƒåˆå§‹åŒ– (ç»‘å®šçª—å£åˆ°Render Threadä¸­)Activityçª—å£çš„ç»˜åˆ¶æµç¨‹æ˜¯åœ¨ViewRoot(Impl)ç±»çš„æˆå‘˜å‡½æ•°performTraversalså‘èµ·çš„ã€‚åœ¨ç»˜åˆ¶ä¹‹å‰ï¼Œé¦–å…ˆè¦è·å¾—ä¸€ä¸ªSurfaceã€‚è¿™ä¸ªSurfaceæè¿°çš„å°±æ˜¯ä¸€ä¸ªçª—å£ã€‚å› æ­¤ï¼Œä¸€æ—¦è·å¾—äº†å¯¹åº”çš„Surfaceï¼Œå°±éœ€è¦å°†å®ƒç»‘å®šåˆ°Render Threadä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910[-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java]public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks &#123; ...... private void performTraversals() &#123; ...... hwInitialized = mAttachInfo.mHardwareRenderer.initialize( mSurface); &#125;&#125; mHardwareRendererå¯¹è±¡ï¼Œå®ƒçš„æˆå‘˜å‡½æ•°initializeçš„å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678[-&gt;\\frameworks\\base\\core\\java\\android\\view\\ThreadedRenderer.java] boolean initialize(Surface surface) throws OutOfResourcesException &#123; boolean status = !mInitialized; mInitialized = true; updateEnabledState(surface); nInitialize(mNativeProxy, surface); return status; &#125; nInitializeæ˜¯ä¸€ä¸ªJNIå‡½æ•°ï¼Œç”±Nativeå±‚çš„å‡½æ•°android_view_ThreadedRenderer_initializeå®ç° 1234567[-&gt;\\frameworks\\base\\core\\jni\\android_view_ThreadedRenderer.cpp]static void android_view_ThreadedRenderer_initialize(JNIEnv* env, jobject clazz, jlong proxyPtr, jobject jsurface) &#123; RenderProxy* proxy = reinterpret_cast&lt;RenderProxy*&gt;(proxyPtr); sp&lt;Surface&gt; surface = android_view_Surface_getSurface(env, jsurface); proxy-&gt;initialize(surface);&#125; Javaå±‚çš„Surfaceåœ¨Nativeå±‚å¯¹åº”çš„æ˜¯ä¸€ä¸ªANativeWindowã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å‡½æ•°android_view_Surface_getNativeWindowæ¥è·å¾—ä¸€ä¸ªJavaå±‚çš„Surfaceåœ¨Nativeå±‚å¯¹åº”çš„ANativeWindowRenderProxy-&gt;initialize()å‡½æ•°å®ç° 1234567891011CREATE_BRIDGE2(initialize, CanvasContext* context, Surface* surface) &#123; args-&gt;context-&gt;initialize(args-&gt;surface); return nullptr;&#125;void RenderProxy::initialize(const sp&lt;Surface&gt;&amp; surface) &#123; SETUP_TASK(initialize); args-&gt;context = mContext; args-&gt;surface = surface.get(); post(task);&#125; å½“è¿™ä¸ªTaskåœ¨Render Threadä¸­æ‰§è¡Œæ—¶ï¼Œç”±å®CREATE_BRIDGE2å£°æ˜çš„å‡½æ•°initializeå°±ä¼šè¢«æ‰§è¡Œã€‚ åœ¨ç”±å®CREATE_BRIDGE2å£°æ˜çš„å‡½æ•°initializeä¸­ï¼Œå‚æ•°contextæŒ‡å‘çš„æ˜¯RenderProxyç±»çš„æˆå‘˜å˜é‡mContextæŒ‡å‘çš„ä¸€ä¸ªCanvasContextå¯¹è±¡ï¼Œè€Œå‚æ•°windowæŒ‡å‘çš„ANativeWindowå°±æ˜¯è¦ç»‘å®šåˆ°Render Threadçš„ANativeWindowã€‚ ç”±å®CREATE_BRIDGE2å£°æ˜çš„å‡½æ•°initializeé€šè¿‡è°ƒç”¨å‚æ•°contextæŒ‡å‘çš„CanvasContextå¯¹è±¡çš„æˆå‘˜å‡½æ•°initializeæ¥ç»‘å®šå‚æ•°windowæŒ‡å‘çš„ANativeWindowï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122232425[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\CanvasContext.cpp]void CanvasContext::initialize(Surface* surface) &#123; setSurface(surface);#if !HWUI_NEW_OPS if (mCanvas) return; mCanvas = new OpenGLRenderer(mRenderThread.renderState()); mCanvas-&gt;initProperties();#endif&#125;void CanvasContext::setSurface(Surface* surface) &#123; mNativeSurface = surface; ...... if (surface) &#123; mEglSurface = mEglManager.createSurface(surface); &#125; if (mEglSurface != EGL_NO_SURFACE) &#123; ...... mHaveNewSurface = true; ..... &#125; else &#123; mRenderThread.removeFrameCallback(this); &#125;&#125; æ¯ä¸€ä¸ªOpen GLæ¸²æŸ“ä¸Šä¸‹æ–‡éƒ½éœ€è¦å…³è”æœ‰ä¸€ä¸ªEGL Surfaceã€‚è¿™ä¸ªEGL Surfaceæè¿°çš„æ˜¯ä¸€ä¸ªç»˜å›¾è¡¨é¢ï¼Œå®ƒå°è£…çš„å®é™…ä¸Šæ˜¯ä¸€ä¸ªANativeWindowã€‚æœ‰äº†è¿™ä¸ªEGL Surfaceä¹‹åï¼Œæˆ‘ä»¬åœ¨æ‰§è¡ŒOpen GLå‘½ä»¤çš„æ—¶å€™ï¼Œæ‰èƒ½ç¡®å®šè¿™äº›å‘½ä»¤æ˜¯ä½œç”¨åœ¨å“ªä¸ªçª—å£ä¸Šã€‚ 12345678910111213141516171819[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\EglManager.cpp]EGLSurface EglManager::createSurface(EGLNativeWindowType window) &#123; initialize(); EGLSurface surface = eglCreateWindowSurface(mEglDisplay, mEglConfig, window, nullptr); ...... &#125; return surface;&#125;void EglManager::initialize() &#123; ...... loadConfig();// createContext();// createPBufferSurface();// makeCurrent(mPBufferSurface);// DeviceInfo::initialize(); mRenderThread.renderState().onGLContextCreated(); initAtlas();&#125; ä½¿ç”¨EGLçš„ç»˜å›¾çš„ä¸€èˆ¬æ­¥éª¤ï¼š1ã€è·å– EGL Display å¯¹è±¡ï¼šeglGetDisplay()2ã€åˆå§‹åŒ–ä¸ EGLDisplay ä¹‹é—´çš„è¿æ¥ï¼šeglInitialize()3ã€è·å– EGLConfig å¯¹è±¡ï¼šeglChooseConfig()4ã€åˆ›å»º EGLContext å®ä¾‹ï¼šeglCreateContext()5ã€åˆ›å»º EGLSurface å®ä¾‹ï¼šeglCreateWindowSurface()6ã€è¿æ¥ EGLContext å’Œ EGLSurfaceï¼šeglMakeCurrent()7ã€ä½¿ç”¨ OpenGL ES API ç»˜åˆ¶å›¾å½¢ï¼šgl_*()8ã€åˆ‡æ¢ front buffer å’Œ back buffer é€æ˜¾ï¼šeglSwapBuffer()9ã€æ–­å¼€å¹¶é‡Šæ”¾ä¸ EGLSurface å…³è”çš„ EGLContext å¯¹è±¡ï¼šeglRelease()10ã€åˆ é™¤ EGLSurface å¯¹è±¡11ã€åˆ é™¤ EGLContext å¯¹è±¡12ã€ç»ˆæ­¢ä¸ EGLDisplay ä¹‹é—´çš„è¿æ¥ Android EGL &amp;&amp; OpenGLåˆ†æè¯·å‚è€ƒã€Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æ ä¹‹ Android EGL &amp;&amp; OpenGLã€‘ è‡³æ­¤ï¼Œå°†å½“å‰çª—å£ç»‘å®šåˆ°Render Threadçš„è¿‡ç¨‹å°±åˆ†æå®Œæˆäº†ï¼Œæ•´ä¸ªAndroidåº”ç”¨ç¨‹åºUIç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“ç¯å¢ƒçš„åˆå§‹åŒ–è¿‡ç¨‹ä¹Ÿåˆ†æå®Œæˆäº†ã€‚ ï¼ˆä¸‰ï¼‰ã€RenderNodeæ„å»ºæˆ‘ä»¬çŸ¥é“ï¼Œé€šå¸¸æƒ…å†µä¸‹ï¼ŒAppè¦å®Œæˆä¸€å¸§æ¸²æŸ“ï¼Œæ˜¯é€šè¿‡ViewRootImplçš„performTraversals()å‡½æ•°æ¥å®ç°ã€‚è€Œå®ƒåˆå¯åˆ†ä¸ºmeasure, layout, drawä¸‰ä¸ªé˜¶æ®µã€‚ä¸Šé¢è¿™äº›æ”¹åŠ¨ä¸»è¦å½±å“çš„æ˜¯æœ€åè¿™æ­¥ï¼Œå› æ­¤æˆ‘ä»¬å°±ä¸»è¦focusåœ¨drawè¿™ä¸ªé˜¶æ®µçš„æµç¨‹ã€‚é¦–å…ˆçœ‹DisplayListæ˜¯æ€ä¹ˆå½•åˆ¶çš„ã€‚åœ¨ViewRootImpl::performDraw()ä¸­ä¼šè°ƒç”¨draw()å‡½æ•°ã€‚å½“åˆ¤æ–­éœ€è¦è¿›è¡Œç»˜åˆ¶æ—¶ï¼ˆæ¯”å¦‚æœ‰è„åŒºåŸŸï¼Œæˆ–åœ¨åŠ¨ç”»ä¸­æ—¶ï¼‰ï¼Œåˆå¦‚æœç¡¬ä»¶åŠ é€Ÿå¯ç”¨ï¼ˆé€šè¿‡ThreadedRendererçš„isEnabled()ï¼‰ï¼Œä¼šè¿›è¡Œä¸‹é¢çš„é‡ç»˜åŠ¨ä½œã€‚æ¥ä¸‹æ¥æ ¹æ®æ˜¯å¦æœ‰ç›¸å…³è¯·æ±‚ï¼ˆå¦‚resizeæ—¶ï¼‰æˆ–offsetæ˜¯å¦æœ‰å˜åŒ–æ¥åˆ¤æ–­æ˜¯å¦è¦è°ƒç”¨ThreadedRendererçš„invalidRoot()æ¥æ ‡è®°æ›´æ–°RootRenderNodeã€‚ æ‰¯ä¸ªé¢˜å¤–è¯ã€‚å’ŒAndroid Mç›¸æ¯”ï¼ŒNä¸­UIå­ç³»ç»Ÿä¸­åŠ å…¥äº†ä¸å°‘å¯¹ç”¨æˆ·è¿›è¡Œçª—å£resizeçš„å¤„ç†ï¼Œä¸»è¦åº”è¯¥æ˜¯ä¸ºäº†Android Næ–°å¢åŠ çš„å¤šçª—å£åˆ†å±æ¨¡å¼ã€‚æ¯”å¦‚å½“ç”¨æˆ·æ‹–æ‹½åˆ†å±çª—å£è¾¹ç¼˜æ—¶ï¼ŒonWindowDragResizeStart()è¢«è°ƒç”¨ã€‚å®ƒå…¶ä¸­ä¼šåˆ›å»ºBackdropFrameRendererã€‚BackdropFrameRendereræœ¬èº«è¿è¡Œå•ç‹¬çš„çº¿ç¨‹ï¼Œå®ƒè´Ÿè´£åœ¨resizeçª—å£è€Œçª—å£ç»˜åˆ¶æ¥ä¸åŠçš„æƒ…å†µä¸‹å¡«å……èƒŒæ™¯ã€‚å®ƒä¼šé€šè¿‡addRenderNode()åŠ å…¥ä¸“ç”¨çš„RenderNodeã€‚åŒæ—¶ï¼ŒAndroid Nä¸­å°†DecorViewä»PhoneWindowä¸­åˆ†ç¦»æˆä¸€ä¸ªå•ç‹¬çš„æ–‡ä»¶ï¼Œå¹¶å®ç°æ–°åŠ çš„WindowCallbacksæ¥å£ã€‚å®ƒä¸»è¦ç”¨äºå½“ç”¨æˆ·å˜åŒ–çª—å£å¤§å°æ—¶ViewRootImplå¯¹DecorViewçš„å›è°ƒã€‚å› ä¸ºViewRootImplå’ŒWindowManagerServiceé€šä¿¡ï¼Œå®ƒä¼šè¢«é€šçŸ¥åˆ°çª—å£å˜åŒ–ï¼Œç„¶åå›è°ƒåˆ°DecorViewä¸­ã€‚è€ŒDecorViewä¸­çš„ç›¸åº”å›è°ƒä¼šå’ŒBackupdropFrameRendereräº¤äº’ã€‚å¦‚updateContentDrawBounds()ä¸­æœ€åä¼šè°ƒç”¨åˆ°äº†BackupdropFrmeRendererçš„onContentDrawn()å‡½æ•°ï¼Œå…¶è¿”å›å€¼ä»£è¡¨åœ¨ä¸‹é¢çš„å†…å®¹ç»˜åˆ¶åæ˜¯å¦éœ€è¦å†å‘èµ·ä¸€æ¬¡ç»˜åˆ¶ã€‚å¦‚æœéœ€è¦ï¼Œä¹‹åä¼šè°ƒç”¨requestDrawWindow()ã€‚ å›åˆ°ViewRootImpl::performDraw()å‡½æ•°ï¼Œæ¥ä¸‹æ¥ï¼Œæœ€é‡è¦çš„å°±æ˜¯é€šè¿‡ThreadedRendererçš„draw()æ¥è¿›è¡Œç»˜åˆ¶ã€‚åœ¨è¿™ä¸ªdraw()å‡½æ•°ä¸­ï¼Œæ¯”è¾ƒé‡è¦çš„ä¸€æ­¥æ˜¯é€šè¿‡updateRootDisplayList()å‡½æ•°æ¥æ›´æ–°æ ¹ç»“ç‚¹çš„DisplayListã€‚ 12345678910111213141516171819202122232425262728293031323334[-&gt;\\frameworks\\base\\core\\java\\android\\view\\ThreadedRenderer.java] private void updateViewTreeDisplayList(View view) &#123; view.mPrivateFlags |= View.PFLAG_DRAWN; view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED) == View.PFLAG_INVALIDATED; view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED; view.updateDisplayListIfDirty(); view.mRecreateDisplayList = false; &#125; private void updateRootDisplayList(View view, HardwareDrawCallbacks callbacks) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"Record View#draw()\"); updateViewTreeDisplayList(view); if (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123; DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight); try &#123; final int saveCount = canvas.save(); canvas.translate(mInsetLeft, mInsetTop); callbacks.onHardwarePreDraw(canvas); canvas.insertReorderBarrier(); canvas.drawRenderNode(view.updateDisplayListIfDirty()); canvas.insertInorderBarrier(); callbacks.onHardwarePostDraw(canvas); canvas.restoreToCount(saveCount); mRootNodeNeedsUpdate = false; &#125; finally &#123; mRootNode.end(canvas); &#125; &#125; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;...... å‡½æ•°updateRootDisplayList()ä¸­çš„updateViewTreeDisplayList()ä¼šè°ƒåˆ°DecorViewçš„updateDisplayListIfDirty()å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¸»è¦åŠŸèƒ½æ˜¯æ›´æ–°DecorViewå¯¹åº”çš„RenderNodeä¸­çš„DisplayListã€‚å®ƒè¿”å›çš„RenderNodeä¼šé€šè¿‡RecordingCanvas::drawRenderNode()å‡½æ•°å°†ä¹‹ä½œä¸ºRenderNodeOpåŠ å…¥åˆ°RootRenderNodeçš„DisplayListä¸­ã€‚å‡½æ•°updateDisplayListIfDirty()ä¸­é¦–å…ˆåˆ¤æ–­å½“å‰Viewæ˜¯å¦éœ€è¦æ›´æ–°ã€‚å¦‚æœä¸éœ€è¦å°±è°ƒç”¨dispatchGetDisplayList()è®©å­Viewæ›´æ–°ï¼Œç„¶åç›´æ¥è¿”å›ã€‚å¦åˆ™å°±æ˜¯å½“å‰Viewçš„DisplayListéœ€è¦æ›´æ–°ã€‚è¿™é‡Œæˆ‘ä»¬å‡è®¾æ˜¯ç¬¬ä¸€æ¬¡ç»˜åˆ¶ï¼Œæ›´æ–°DisplayListçš„æµç¨‹é¦–å…ˆé€šè¿‡RenderNodeçš„start()æ¥è·å¾—ä¸€ä¸ªç”¨äºè®°å½•ç»˜åˆ¶æ“ä½œçš„Canvasï¼Œå³DisplayListCanvasï¼ˆåœ¨Android Mä¸­Javaå±‚ç”±GLES20RecordingCanvasæ”¹ä¸ºDisplayListCanvasï¼Œnativeå±‚ä¸­çš„DisplayListRendereræ”¹ä¸ºDisplayListCanvasï¼ŒAndroid Nä¸­nativeå±‚ä¸­çš„DisplayListCanvasæ”¹ä¸ºRecordingCanvasï¼‰ã€‚ æ¥ä¸‹å»å°±æ˜¯æ¯”è¾ƒå…³é”®çš„æ­¥éª¤äº†ã€‚è¿™é‡Œå°±è¦åˆ†å‡ ç§æƒ…å†µäº†ï¼Œä¸€ä¸ªViewå¯ä»¥ä¸ºä¸‰ç§ç±»å‹ï¼ˆLAYER_TYPE_NONE, LAYER_TYPE_SOFTWARE, LAYER_TYPE_HARDWAREï¼‰ä¸­çš„ä¸€ç§ã€‚LAYER_TYPE_NONEä¸ºé»˜è®¤å€¼ï¼Œä»£è¡¨æ²¡æœ‰layerã€‚LAYER_TYPE_SOFTWAREä»£è¡¨è¯¥Viewæœ‰è½¯ä»¶å±‚ï¼Œä»¥bitmapä¸ºbackï¼Œå†…å®¹ç”¨è½¯ä»¶æ¸²æŸ“ã€‚LAYER_TYPE_HARDWAREå’ŒLAYER_TYPE_SOFTWAREç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºå…¶æœ‰ç¡¬ä»¶å±‚ï¼Œä»¥FBOï¼ˆFramebuffer objectï¼‰ä¸ºbackï¼Œå†…å®¹ä½¿ç”¨ç¡¬ä»¶æ¸²æŸ“ã€‚å¦‚æœç¡¬ä»¶åŠ é€Ÿæ²¡æœ‰æ‰“å¼€ï¼Œå®ƒçš„è¡Œä¸ºå’ŒLAYER_TYPE_SOFTWAREæ˜¯ä¸€æ ·çš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[-&gt;\\frameworks\\base\\core\\java\\android\\view\\ThreadedRenderer.java] public RenderNode updateDisplayListIfDirty() &#123; final RenderNode renderNode = mRenderNode; ....... if ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == 0 || !renderNode.isValid() || (mRecreateDisplayList)) &#123; // Don't need to recreate the display list, just need to tell our // children to restore/recreate theirs if (renderNode.isValid() &amp;&amp; !mRecreateDisplayList) &#123; mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; dispatchGetDisplayList(); return renderNode; // no work needed &#125; // If we got here, we're recreating it. Mark it as such to ensure that // we copy in child display lists into ours in drawChild() mRecreateDisplayList = true; int width = mRight - mLeft; int height = mBottom - mTop; int layerType = getLayerType(); final DisplayListCanvas canvas = renderNode.start(width, height); canvas.setHighContrastText(mAttachInfo.mHighContrastText); try &#123; if (layerType == LAYER_TYPE_SOFTWARE) &#123; buildDrawingCache(true); Bitmap cache = getDrawingCache(true); if (cache != null) &#123; canvas.drawBitmap(cache, 0, 0, mLayerPaint); &#125; &#125; else &#123; computeScroll(); canvas.translate(-mScrollX, -mScrollY); mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123; dispatchDraw(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().draw(canvas); &#125; &#125; else &#123; draw(canvas); &#125; &#125; &#125; finally &#123; renderNode.end(canvas); setDisplayListProperties(renderNode); &#125; &#125; else &#123; mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; &#125; return renderNode; &#125; å¦‚æœå½“å‰Viewæ˜¯è½¯ä»¶æ¸²æŸ“å±‚ï¼ˆç±»å‹ä¸ºLAYER_TYPE_SOFTWAREï¼‰çš„è¯ï¼Œåˆ™è°ƒç”¨buildDrawingCache()è·å¾—Bitmapåè°ƒç”¨drawBitmap()å°†è¯¥Bitmapè®°å½•åˆ°DisplayListCanvasä¸­ã€‚ç°åœ¨Androidä¸­éƒ½é»˜è®¤ç¡¬ä»¶æ¸²æŸ“äº†ï¼Œä¸ºä»€ä¹ˆè¿˜è¦è€ƒè™‘è½¯ä»¶æ¸²æŸ“å±‚å‘¢?ä¸€æ–¹é¢æœ‰äº›å¹³å°ä¸æ”¯æŒç¡¬ä»¶æ¸²æŸ“ï¼Œæˆ–appä¸å¯ç”¨ç¡¬ä»¶åŠ é€Ÿï¼Œå¦ä¸€æ–¹é¢æœ‰äº›UIæ§ä»¶ä¸æ”¯æŒç¡¬ä»¶æ¸²æŸ“ ã€‚åœ¨å¤æ‚çš„Viewï¼ˆåŠå­Viewï¼‰åœ¨åŠ¨ç”»è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥è¢«ç»˜åˆ¶æˆçº¹ç†ï¼Œè¿™æ ·åªéœ€è¦ç”»ä¸€æ¬¡ã€‚æ˜¾ç„¶ï¼Œåœ¨Viewç»å¸¸æ›´æ–°çš„æƒ…å†µä¸‹å¹¶ä¸é€‚ç”¨ã€‚å› ä¸ºè¿™æ ·æ¯æ¬¡éƒ½éœ€è¦é‡æ–°ç”¨è½¯ä»¶æ¸²æŸ“ï¼Œå¦‚æœç¡¬ä»¶æ¸²æŸ“æ‰“å¼€æ—¶è¿˜è¦ä¸Šä¼ æˆç¡¬ä»¶çº¹ç†ï¼ˆä¸Šä¼ çº¹ç†æ˜¯ä¸ªæ¯”è¾ƒæ…¢çš„æ“ä½œï¼‰ã€‚ç±»ä¼¼çš„ï¼Œç¡¬ä»¶æ¸²æŸ“å±‚ï¼ˆLAYER_TYPE_HARDWAREï¼‰ä¹Ÿæ˜¯é€‚ç”¨äºç±»ä¼¼çš„å¤æ‚Viewç»“æ„è¿›è¡Œå±æ€§åŠ¨ç”»çš„åœºæ™¯ï¼Œä½†å®ƒä¸LAYER_TYPE_SOFTWAREçš„å±‚çš„åŒºåˆ«ä¸ºå®ƒå¯¹åº”FBOï¼Œå¯ä»¥ç›´æ¥ç¡¬ä»¶æ¸²æŸ“ç”Ÿæˆçº¹ç†ã€‚å› æ­¤æ¸²æŸ“çš„è¿‡ç¨‹ä¸­ä¸éœ€è¦å…ˆç”ŸæˆBitmapï¼Œä»è€Œçœå»äº†ä¸Šä¼ æˆç¡¬ä»¶çº¹ç†çš„è¿™ä¸€æ­¥æ“ä½œã€‚ å¦‚æœå½“å‰Viewå¯¹åº”LAYER_TYPE_NONEæˆ–è€…LAYER_TYPE_HARDWAREï¼Œä¸‹é¢ä¼šè€ƒæŸ¥æ˜¯å¦ä¸ºæ²¡æœ‰èƒŒæ™¯çš„Layoutã€‚è¿™ç§æƒ…å†µä¸‹å½“å‰Viewæ²¡ä»€ä¹ˆå¥½ç”»çš„ï¼Œä¼šèµ°å¿«é€Ÿè·¯å¾„ã€‚å³é€šè¿‡dispatchDraw()ç›´æ¥è®©å­Viewé‡ç»˜ã€‚å¦åˆ™å°±è°ƒdraw()æ¥ç»˜åˆ¶å½“å‰ViewåŠå…¶å­Viewã€‚æ³¨æ„Viewä¸­çš„draw()æœ‰ä¸¤ä¸ªé‡è½½åŒåå‡½æ•°ã€‚ä¸€ä¸ªå‚æ•°çš„ç‰ˆæœ¬ç”¨äºç›´æ¥è°ƒç”¨ã€‚ä¸‰ä¸ªå‚æ•°çš„ç‰ˆæœ¬ç”¨äºViewGroupä¸­drawChild()æ—¶è°ƒç”¨ã€‚è¿™é‡Œè°ƒçš„æ˜¯ä¸€ä¸ªå‚æ•°çš„ç‰ˆæœ¬ã€‚è¿™ä¸ªdraw()å‡½æ•°ä¸­ä¼šæŒ‰ä¸‹é¢çš„é¡ºåºè¿›è¡Œç»˜åˆ¶ï¼ˆDisplayListçš„æ›´æ–°ï¼‰ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@CallSuperpublic void draw(Canvas canvas) &#123; final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas' layers to prepare for fading * 3. Draw view's content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed ...... drawBackground(canvas); // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; // Step 3, draw the content if (!dirtyOpaque) onDraw(canvas); // Step 4, draw the children dispatchDraw(canvas); // Step 5, draw the fade effect and restore layers final Paint p = scrollabilityCache.paint; final Matrix matrix = scrollabilityCache.matrix; final Shader fade = scrollabilityCache.shader; if (drawTop) &#123; matrix.setScale(1, fadeHeight * topFadeStrength); matrix.postTranslate(left, top); fade.setLocalMatrix(matrix); p.setShader(fade); canvas.drawRect(left, top, right, top + length, p); &#125; ...... canvas.restoreToCount(saveCount); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123; mOverlay.getOverlayView().dispatchDraw(canvas); &#125; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas);&#125; è¿™äº›æ˜¯é€šè¿‡drawBackground(), onDraw(), dispatchDraw()å’ŒonDrawForeground()ç­‰å‡½æ•°å®ç°ã€‚è¿™äº›å‡½æ•°æœ¬è´¨ä¸Šå°±æ˜¯å°†ç›¸åº”å†…å®¹ç»˜åˆ¶åˆ°æä¾›çš„DisplayListCanvasä¸Šã€‚ç”±äºViewæ˜¯ä»¥æ ‘å½¢å±‚æ¬¡ç»“æ„ç»„ç»‡çš„ï¼Œdraw()ä¸­ä¼šé€šè¿‡dispatchDraw()æ¥æ›´æ–°å­Viewçš„DisplayListã€‚dispatchDraw()ä¸ºå¯¹æ¯ä¸ªå­Viewè°ƒç”¨drawChild()ã€‚ç„¶åè°ƒç”¨å­Viewçš„draw()å‡½æ•°ï¼ˆè¿™æ¬¡å°±æ˜¯ä¸Šé¢è¯´çš„draw()çš„ä¸‰ä¸ªå‚æ•°çš„ç‰ˆæœ¬äº†ï¼‰ã€‚è¿™ä¸ªç‰ˆæœ¬çš„draw()å‡½æ•°é‡Œä¼šæ›´æ–°å…¶Viewçš„DisplayListï¼Œç„¶åè°ƒç”¨DisplayListCanvasçš„drawRenderNode()å°†è¯¥å­viewå¯¹åº”çš„RenderNodeè®°å½•åˆ°å…¶çˆ¶viewçš„DisplayListä¸­å»ã€‚è¿™æ ·ä¾¿æ ¹æ®Viewçš„æ ‘å‹ç»“æ„ç”Ÿæˆäº†DisplayListçš„æ ‘å‹ç»“æ„ã€‚ å…¶ä¸­onDraw()ç”¨äºç»˜åˆ¶å½“å‰Viewçš„è‡ªå®šä¹‰UIï¼Œå®ƒæ˜¯æ¯ä¸ªViewéœ€è¦è‡ªå®šä¹‰çš„æˆå‘˜å‡½æ•°ã€‚æ¯”è¾ƒå…¸å‹åœ°ï¼Œåœ¨Viewçš„ç»˜åˆ¶å‡½æ•°ä¸­ä¼šè°ƒç”¨canvasçš„drawXXXå‡½æ•°ã€‚æ¯”å¦‚canvas.drawLine()-&gt;drawLines(android_graphics_Canvas.cpp)ï¼Œå®ƒä¼šé€šè¿‡JNIæœ€åè°ƒåˆ°RecordingCanvas.cppä¸­çš„RecordingCanvas::drawLines()ï¼š 1234567891011[-&gt;\\frameworks\\base\\libs\\hwui\\RecordingCanvas.cpp]void RecordingCanvas::drawLines(const float* points, int floatCount, const SkPaint&amp; paint) &#123; if (CC_UNLIKELY(floatCount &lt; 4 || PaintUtils::paintWillNotDraw(paint))) return; floatCount &amp;= ~0x3; // round down to nearest four addOp(alloc().create_trivial&lt;LinesOp&gt;( calcBoundsOfPoints(points, floatCount), *mState.currentSnapshot()-&gt;transform, getRecordedClip(), refPaint(&amp;paint), refBuffer&lt;float&gt;(points, floatCount), floatCount));&#125; RecordingCanvasä¸­ç»å¤§å¤šæ•°çš„drawXXXç³»å‡½æ•°éƒ½æ˜¯ç±»ä¼¼äºè¿™æ ·ï¼Œé€šè¿‡addOp()å°†ä¸€ä¸ªRecordedOpçš„ç»§æ‰¿ç±»å­˜åˆ°å…¶æˆå‘˜mDisplayListä¸­ã€‚RecordedOpå®¶åº­æˆå‘˜å¾ˆå¤šï¼Œæœ‰ä¸å°‘ç»§æ‰¿ç±»ï¼Œæ¯ä¸ªå¯¹åº”ä¸€ç§æ“ä½œã€‚æ“ä½œçš„ç§ç±»å¯ä»¥å‚ç…§ä¸‹è¿™ä¸ªè¡¨ï¼š 12345678910111213141516171819202122232425262728293031323334[-&gt;\\frameworks\\base\\libs\\hwui\\RecordedOp.h]#define MAP_OPS_BASED_ON_TYPE(PRE_RENDER_OP_FN, RENDER_ONLY_OP_FN, UNMERGEABLE_OP_FN, MERGEABLE_OP_FN) \\ PRE_RENDER_OP_FN(RenderNodeOp) \\ PRE_RENDER_OP_FN(CirclePropsOp) \\ PRE_RENDER_OP_FN(RoundRectPropsOp) \\ PRE_RENDER_OP_FN(BeginLayerOp) \\ PRE_RENDER_OP_FN(EndLayerOp) \\ PRE_RENDER_OP_FN(BeginUnclippedLayerOp) \\ PRE_RENDER_OP_FN(EndUnclippedLayerOp) \\ PRE_RENDER_OP_FN(VectorDrawableOp) \\ \\ RENDER_ONLY_OP_FN(ShadowOp) \\ RENDER_ONLY_OP_FN(LayerOp) \\ RENDER_ONLY_OP_FN(CopyToLayerOp) \\ RENDER_ONLY_OP_FN(CopyFromLayerOp) \\ \\ UNMERGEABLE_OP_FN(ArcOp) \\ UNMERGEABLE_OP_FN(BitmapMeshOp) \\ UNMERGEABLE_OP_FN(BitmapRectOp) \\ UNMERGEABLE_OP_FN(ColorOp) \\ UNMERGEABLE_OP_FN(FunctorOp) \\ UNMERGEABLE_OP_FN(LinesOp) \\ UNMERGEABLE_OP_FN(OvalOp) \\ UNMERGEABLE_OP_FN(PathOp) \\ UNMERGEABLE_OP_FN(PointsOp) \\ UNMERGEABLE_OP_FN(RectOp) \\ UNMERGEABLE_OP_FN(RoundRectOp) \\ UNMERGEABLE_OP_FN(SimpleRectsOp) \\ UNMERGEABLE_OP_FN(TextOnPathOp) \\ UNMERGEABLE_OP_FN(TextureLayerOp) \\ \\ MERGEABLE_OP_FN(BitmapOp) \\ MERGEABLE_OP_FN(PatchOp) \\ MERGEABLE_OP_FN(TextOp) å„ä¸ªViewçš„DisplayListæ›´æ–°å¥½åï¼Œå›åˆ°udpateRootDisplayList()ã€‚å¦‚æœå‘ç°RootRenderNodeä¹Ÿéœ€è¦æ›´æ–°ï¼Œåˆ™å…ˆé€šè¿‡Javaå±‚çš„RenderNode::start()è·å¾—DisplayListCanvasï¼Œåœ¨è¿™ä¸ªCanvasä¸Šçš„åŠ¨ä½œéƒ½ä¼šè¢«è®°å½•åˆ°DisplayListä¸­ï¼Œç›´åˆ°è°ƒç”¨RenderNode.end()ã€‚ç„¶åä¸ºäº†é˜²æ­¢å¯¹ä¸Šä¸‹æ–‡çŠ¶æ€çš„å½±å“ï¼Œç”¨Canvas::save()å’ŒCanvas::restoreToCount()æ¥ç”Ÿæˆä¸´æ—¶çš„ç”»å¸ƒçŠ¶æ€ã€‚å†æ¥ä¸‹æ¥å°±æ˜¯é€šè¿‡drawRenderNode()å°†DecorViewçš„RenderNodeä»¥RenderNodeOpçš„å½¢å¼è®°å½•åˆ°RootRenderNodeã€‚ DisplayListæ„å»ºå®ä¾‹ï¼šAndroid DisplayList æ„å»ºè¿‡ç¨‹activity_main.xml 12345678910111213141516171819é“¾æ¥ï¼šhttps://www.jianshu.com/p/7bf306c09c7e&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/sample_text&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:gravity=&quot;center&quot; android:textSize=&quot;20sp&quot; android:text=&quot;Hello World!&quot; /&gt; &lt;cc.bobby.debugapp.MyView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; /&gt;&lt;/LinearLayout&gt; udpateRootDisplayList() çˆ¶Viewä¸å­Viewçš„DisplayList ï¼ˆå››ï¼‰ã€RenderNodeç»˜åˆ¶åœ¨ThreadedRendererçš„draw()å‡½æ•°ä¸­æ„å»ºå®ŒDisplayListåï¼Œæ¥ä¸‹æ¥éœ€è¦å‡†å¤‡æ¸²æŸ“äº†ã€‚é¦–å…ˆé€šè¿‡JNIè°ƒç”¨nSyncAndDrawFrame()è°ƒç”¨åˆ°nativeå±‚çš„android_view_ThreadedRenderer_syncAndDrawFrame()ã€‚å…¶ä¸­å°†å‚æ•°ä¸­çš„FrameInfoæ•°ç»„ä¼ åˆ°RenderProxyçš„mFrameInfoæˆå‘˜ä¸­ã€‚å®ƒæ˜¯Android Må¼€å§‹åŠ å…¥ç”¨æ¥ç»†åŒ–hwuiæ€§èƒ½ç»Ÿè®¡çš„ã€‚åŒæ—¶è°ƒç”¨RenderProxyçš„syncAndDrawFrame()å‡½æ•°ï¼Œå¹¶å°†åˆ›å»ºçš„TreeObserverä½œä¸ºå‚æ•°ã€‚å‡½æ•°syncAndDrawFrame()ä¸­å³è°ƒç”¨DrawFrameTaskï¼ˆè¿™æ˜¯RenderThreadçš„TaskQueueä¸­çš„ç‰¹æ®ŠTaskå®ä¾‹ï¼‰çš„drawFrame()å‡½æ•°ã€‚ç»§è€Œé€šè¿‡postAndWait()å¾€RenderThreadçš„TaskQueueé‡Œæ’å…¥è‡ªèº«ï¼ˆå³DrawFrameTaskï¼‰æ¥ç”³è¯·æ–°ä¸€å¸§çš„æ¸²æŸ“ã€‚åœ¨RenderThreadçš„queue()å‡½æ•°ä¸­ä¼šæŒ‰Taskçš„è¿è¡Œæ—¶é—´å°†ä¹‹æ’å…¥åˆ°é€‚å½“çš„ä½ç½®ã€‚æ¥ç€postAndWait()å‡½æ•°ä¸­ä¼šblock UIçº¿ç¨‹ç­‰å¾…æ¸²æŸ“çº¿ç¨‹å°†ä¹‹unblockã€‚æ¸²æŸ“çº¿ç¨‹åœ¨Nä¸­çš„æ”¹åŠ¨ä¸å¤§ï¼Œè¿™é‡Œå°±ä¸èŠ±å¤ªå¤šæ–‡å­—ä»‹ç»äº†ï¼Œéœ€è¦çš„æ—¶å€™æŠŠå®ƒå½“ä½œè·¨çº¿ç¨‹è°ƒç”¨å³å¯ã€‚ å¦ä¸€è¾¹ï¼Œæ¸²æŸ“çº¿ç¨‹å¤„ç†è¿™ä¸ªDrawFrameTaskæ—¶ä¼šè°ƒç”¨åˆ°å…¶run()å‡½æ•°ï¼š 1234567891011121314151617181920212223242526272829303132[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\DrawFrameTask.cpp]void DrawFrameTask::run() &#123; ATRACE_NAME(\"DrawFrame\"); bool canUnblockUiThread; bool canDrawThisFrame; &#123; TreeInfo info(TreeInfo::MODE_FULL, *mContext); info.observer = mObserver; canUnblockUiThread = syncFrameState(info); canDrawThisFrame = info.out.canDrawThisFrame; &#125; // Grab a copy of everything we need CanvasContext* context = mContext; // From this point on anything in \"this\" is *UNSAFE TO ACCESS* if (canUnblockUiThread) &#123; unblockUiThread(); &#125; if (CC_LIKELY(canDrawThisFrame)) &#123; context-&gt;draw(); &#125; else &#123; // wait on fences so tasks don't overlap next frame context-&gt;waitOnFences(); &#125; if (!canUnblockUiThread) &#123; unblockUiThread(); &#125;&#125; å…¶ä¸­é¦–å…ˆé€šè¿‡DrawFrameTask::syncFrameState()å‡½æ•°å°†ä¸»çº¿ç¨‹çš„æ¸²æŸ“ä¿¡æ¯ï¼ˆå¦‚DisplayListï¼ŒPropertyå’ŒBitmapç­‰ï¼‰åŒæ­¥åˆ°æ¸²æŸ“çº¿ç¨‹ã€‚ 12345678syncFrameState() -&gt; eglMakeCurrent -&gt; eglMakeCurrent(OEM EGL) -&gt; egl_window_surface_v2_t::connect() -&gt; Surface::hook_dequeueBuffer() -&gt; Surface::dequeueBuffer() -&gt; BpGraphicBufferProducer::dequeueBuffer() -&gt; BpGraphicBufferProducer::requestBuffer() è¿™ä¸ªå‡½æ•°ä¸­é¦–å…ˆä¼šå¤„ç†DrawFrameTaskä¸­çš„mLayersã€‚å®ƒæ˜¯DeferredLayerUpdaterçš„vectorï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯å»¶è¿Ÿå¤„ç†çš„layeræ›´æ–°ä»»åŠ¡ã€‚è¿™ä¸»è¦ç”¨äºTextureViewã€‚TextureViewæ˜¯æ¯”è¾ƒç‰¹æ®Šçš„ç±»ã€‚å®ƒé€šå¸¸ç”¨äºæ˜¾ç¤ºå†…å®¹æµï¼Œç”Ÿäº§è€…ç«¯å¯ä»¥æ˜¯å¦ä¸€ä¸ªè¿›ç¨‹ã€‚ä¸­é—´é€šè¿‡BufferQueueè¿›è¡Œbufferçš„ä¼ è¾“å’Œäº¤æ¢ã€‚å½“æœ‰æ–°çš„bufferæ¥åˆ°ï¼ˆæˆ–è€…æœ‰å±æ€§å˜åŒ–ï¼Œå¦‚visibilityç­‰ï¼‰æ˜¯ï¼Œä¼šé€šè¿‡å›è°ƒè®¾ç½®æ ‡å¿—ä½(mUpdateLayer)å¹¶é€šè¿‡invalidate()è°ƒåº¦ä¸‹ä¸€æ¬¡é‡ç»˜ã€‚å½“ä¸‹ä¸€æ¬¡draw()è¢«è°ƒç”¨æ—¶ï¼Œå…ˆé€šè¿‡applyUpdate()-&gt;updateSurfaceTexture()-&gt;ThreadedRenderer::pushLayerUpdate()ï¼Œå†è°ƒåˆ°æ¸²æŸ“çº¿ç¨‹ä¸­çš„ DrawFrameTask::pushLayerUpdate()ï¼Œå°†æœ¬æ¬¡æ›´æ–°è®°å½•åœ¨DrawFrameTaskçš„mLayersä¸­ã€‚è¿™æ ·ï¼Œåœ¨åé¢è°ƒç”¨DrawFrameTask::syncFrameState()æ˜¯ä¼šä¾æ¬¡è°ƒç”¨mLayersä¸­çš„apply()è¿›è¡ŒçœŸæ­£çš„æ›´æ–°ã€‚è¿™é‡Œè°ƒç”¨å®ƒçš„apply()å‡½æ•°å°±ä¼šå–æ–°å¯ç”¨bufferï¼ˆé€šè¿‡doUpdateTexImage()å‡½æ•°ï¼‰ï¼Œå¹¶å°†ç›¸å…³çº¹ç†ä¿¡æ¯æ›´æ–°åˆ°mLayerã€‚åœ¨syncFrameState()å‡½æ•°ä¸­ï¼Œæ¥ä¸‹æ¥ï¼Œé€šè¿‡CanvasContextçš„prepareTree()ç»§è€Œè°ƒç”¨RenderNodeçš„prepareTree()åŒæ­¥æ¸²æŸ“ä¿¡æ¯ã€‚æœ€åä¼šè¾“å‡ºTreeInfoç»“æ„ï¼Œå…¶ä¸­çš„prepareTexturesä»£è¡¨çº¹ç†ä¸Šä¼ æ˜¯å¦æˆåŠŸã€‚å¦‚æœä¸ºfalseï¼Œè¯´æ˜texture cacheç”¨å®Œäº†ã€‚è¿™æ ·ä¸ºäº†é˜²æ­¢æ¸²æŸ“çº¿ç¨‹åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­ä½¿ç”¨çš„èµ„æºå’Œä¸»çº¿ç¨‹ç«äº‰ï¼Œåœ¨æ¸²æŸ“çº¿ç¨‹ç»˜åˆ¶å½“å‰å¸§æ—¶å°±ä¸èƒ½è®©ä¸»çº¿ç¨‹ç»§ç»­å¾€ä¸‹è·‘äº†ï¼Œä¹Ÿå°±ä¸èƒ½åšåˆ°çœŸæ­£å¹¶è¡Œã€‚åœ¨syncå®Œæ•°æ®åï¼ŒDrawFrameTask::run()æœ€åä¼šè°ƒç”¨CanvasContext::draw()æ¥è¿›è¡Œæ¥ä¸‹æ¥çš„æ¸²æŸ“ã€‚è¿™éƒ¨åˆ†çš„å¤§ä½“æµç¨‹å¦‚ä¸‹ï¼š æ¥ä¸‹æ¥ç„ä¸‹CanvasContext::draw()é‡Œåšäº†ä»€ä¹ˆã€‚å…ˆè¦å°å°å‡†å¤‡ä¸‹EGLç¯å¢ƒï¼Œæ¯”å¦‚é€šè¿‡EglManagerçš„beginFrame()å‡½æ•°ï¼Œ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061beginFrame() -&gt; eglMakeCurrent -&gt; eglMakeCurrent(OEM EGL) -&gt; Surface::hook_dequeueBuffer() -&gt; Surface::dequeueBuffer() -&gt; BpGraphicBufferProducer::dequeueBuffer() -&gt; BpGraphicBufferProducer::requestBuffer()[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]Frame EglManager::beginFrame(EGLSurface surface) &#123; ..... makeCurrent(surface); ....&#125;bool EglManager::makeCurrent(EGLSurface surface, EGLint* errOut) &#123; if (!eglMakeCurrent(mEglDisplay, surface, surface, mEglContext)) &#123; .... &#125; .....&#125;EGLBoolean eglMakeCurrent( EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)&#123; if (ctx == EGL_NO_CONTEXT) &#123; // if we're detaching, we need the current context current_ctx = (EGLContext)getGlThreadSpecific(); &#125; else &#123; egl_surface_t* d = (egl_surface_t*)draw; &#125; if (d) &#123; if (d-&gt;connect() == EGL_FALSE) &#123; return EGL_FALSE; &#125; &#125; return setError(EGL_BAD_ACCESS, EGL_FALSE);&#125;EGLBoolean egl_window_surface_v2_t::connect()&#123; // dequeue a buffer int fenceFd = -1; if (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer, &amp;fenceFd) != NO_ERROR) &#123; return setError(EGL_BAD_ALLOC, EGL_FALSE); &#125; // wait for the buffer sp&lt;Fence&gt; fence(new Fence(fenceFd)); if (fence-&gt;wait(Fence::TIMEOUT_NEVER) != NO_ERROR) &#123; nativeWindow-&gt;cancelBuffer(nativeWindow, buffer, fenceFd); return setError(EGL_BAD_ALLOC, EGL_FALSE); &#125; return EGL_TRUE;&#125; ç»§è€Œç”¨eglMakeCurrent()å°†æ¸²æŸ“contextåˆ‡æ¢åˆ°ç›¸åº”çš„surfaceã€‚ç„¶åEglManagerçš„damageFrame()è®¾å®šå½“å‰å¸§çš„è„åŒºåŸŸï¼ˆå¦‚æœgfxå¹³å°æ”¯æŒå±€éƒ¨æ›´æ–°çš„è¯ï¼‰ã€‚æ¥ä¸‹æ¥å°±æ˜¯ç»˜åˆ¶çš„ä¸»ä½“éƒ¨åˆ†äº†ã€‚è¿™ä¹Ÿæ˜¯Nä¸­æ”¹åŠ¨æ¯”è¾ƒå¤§çš„éƒ¨åˆ†ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980[-&gt;\\frameworks\\base\\libs\\hwui\\renderthread\\CanvasContext.cpp]void CanvasContext::draw() &#123; SkRect dirty; mDamageAccumulator.finish(&amp;dirty); mCurrentFrameInfo-&gt;markIssueDrawCommandsStart(); Frame frame = mEglManager.beginFrame(mEglSurface); ...... SkRect screenDirty(dirty); ...... mEglManager.damageFrame(frame, dirty);#if HWUI_NEW_OPS auto&amp; caches = Caches::getInstance(); FrameBuilder frameBuilder(dirty, frame.width(), frame.height(), mLightGeometry, caches); frameBuilder.deferLayers(mLayerUpdateQueue); mLayerUpdateQueue.clear(); frameBuilder.deferRenderNodeScene(mRenderNodes, mContentDrawBounds); BakedOpRenderer renderer(caches, mRenderThread.renderState(), mOpaque, mLightInfo); frameBuilder.replayBakedOps&lt;BakedOpDispatcher&gt;(renderer); profiler().draw(&amp;renderer); bool drew = renderer.didDraw(); // post frame cleanup caches.clearGarbage(); caches.pathCache.trim(); caches.tessellationCache.trim(); ...... mCanvas-&gt;prepareDirty(frame.width(), frame.height(), dirty.fLeft, dirty.fTop, dirty.fRight, dirty.fBottom, mOpaque); Rect outBounds; // It there are multiple render nodes, they are laid out as follows: // #0 - backdrop (content + caption) // #1 - content (positioned at (0,0) and clipped to - its bounds mContentDrawBounds) // #2 - additional overlay nodes ...... // Draw all render nodes. Note that for (const sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123; if (layer == 0) &#123; // Backdrop. ....... // Check if we have to draw something on the left side ... if (targetBounds.left &lt; contentBounds.left) &#123; mCanvas-&gt;save(SaveFlags::Clip); if (mCanvas-&gt;clipRect(targetBounds.left, targetBounds.top, contentBounds.left, targetBounds.bottom, SkRegion::kIntersect_Op)) &#123; mCanvas-&gt;drawRenderNode(node.get(), outBounds); &#125; // Reduce the target area by the area we have just painted. targetBounds.left = std::min(contentBounds.left, targetBounds.right); mCanvas-&gt;restore(); &#125; // ... or on the right side ... // ... or at the top ... // ... or at the bottom. &#125; else if (layer == 1) &#123; // Content // It gets cropped against the bounds of the backdrop to stay inside. mCanvas-&gt;save(SaveFlags::MatrixClip); ...... mCanvas-&gt;translate(dx, dy); if (mCanvas-&gt;clipRect(left, top, left + width, top + height, SkRegion::kIntersect_Op)) &#123; mCanvas-&gt;drawRenderNode(node.get(), outBounds); &#125; mCanvas-&gt;restore(); &#125; else &#123; // draw the rest on top at will! mCanvas-&gt;drawRenderNode(node.get(), outBounds); &#125; layer++; &#125; profiler().draw(mCanvas); bool drew = mCanvas-&gt;finish(); ...... å…ˆå¾—åˆ°Cachesçš„å®ä¾‹ã€‚å®ƒæ˜¯ä¸€ä¸ªå•ä¾‹ç±»ï¼ŒåŒ…å«äº†å„ç§ç»˜åˆ¶èµ„æºçš„cacheã€‚ç„¶ååˆ›å»ºFrameBuilderã€‚è¯¥ç±»ç”¨äºå½“å‰å¸§çš„æ„å»ºã€‚FrameBuilderçš„æ„é€ å‡½æ•°ä¸­åˆä¼šåˆ›å»ºå¯¹åº”fbo0çš„LayerBuilderã€‚fbo0å³å¯¹åº”é€šè¿‡SurfaceFlingerç”³è¯·æ¥çš„on-screen surfaceï¼Œç„¶åå°†ä¹‹æ”¾å…¥layer stackï¼ˆé€šè¿‡mLayerBuilderså’ŒmLayerStackä¸¤ä¸ªæˆå‘˜ç»´æŠ¤ï¼‰ã€‚åŒæ—¶è¿˜ä¼šåœ¨initializeSaveStack()å‡½æ•°ä¸­åˆ›å»ºå’Œåˆå§‹åŒ–Snapshotã€‚å°±åƒåå­—ä¸€æ ·ï¼Œå®ƒä¿å­˜äº†æ¸²æŸ“surfaceçš„å½“å‰çŠ¶æ€çš„ä¸€ä¸ªâ€œå¿«ç…§â€ã€‚æ¯ä¸ªSnapshotæœ‰ä¸€ä¸ªæŒ‡å‘å‰ç»§çš„Snapshotï¼Œä»è€Œå½¢æˆä¸€ä¸ªâ€æ ˆâ€ã€‚æ¯æ¬¡è°ƒç”¨save()å’Œrestore()å°±ç›¸å½“äºå‹æ ˆå’Œå¼¹æ ˆã€‚ æ¥ä¸‹æ¥deferLayers()å‡½æ•°å¤„ç†LayerUpdateQueueä¸­çš„å…ƒç´ ã€‚ä¹‹å‰åœ¨æ¸²æŸ“çº¿ç¨‹æ¯ç”»ä¸€å¸§å‰åŒæ­¥ä¿¡æ¯æ—¶è°ƒç”¨RenderNode::prepareTree()ä¼šéå†DisplayListçš„æ ‘å½¢ç»“æ„ï¼Œå¯¹äºå­èŠ‚ç‚¹é€’å½’è°ƒç”¨prepareTreeImpl()ï¼Œå¦‚æœæ˜¯render layerï¼Œåœ¨RenderNode::pushLayerUpdate()ä¸­ä¼šå°†è¯¥layerçš„æ›´æ–°æ“ä½œè®°å½•åˆ°LayerUpdateQueueä¸­ã€‚è‡³äºå“ªäº›èŠ‚ç‚¹æ˜¯render layerã€‚ä¸»è¦æ˜¯æ ¹æ®ä¹‹å‰æåˆ°çš„viewç±»å‹ï¼ˆLAYER_TYPE_NONE/SOFTWARE/HARDWAREï¼‰ã€‚ä½†ä¼šæœ‰ä¸€ä¸ªä¼˜åŒ–ï¼Œå¦‚æœä¸€ä¸ªæ™®é€šviewæ»¡è¶³promotedToLayer()å®šä¹‰çš„æ¡ä»¶ï¼Œå®ƒä¼šè¢«å½“åšrender layerå¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233[-&gt;\\frameworks\\base\\libs\\hwui\\FrameBuilder.cpp]void FrameBuilder::deferLayers(const LayerUpdateQueue&amp; layers) &#123; // Render all layers to be updated, in order. Defer in reverse order, so that they'll be // updated in the order they're passed in (mLayerBuilders are issued to Renderer in reverse) for (int i = layers.entries().size() - 1; i &gt;= 0; i--) &#123; RenderNode* layerNode = layers.entries()[i].renderNode; // only schedule repaint if node still on layer - possible it may have been // removed during a dropped frame, but layers may still remain scheduled so // as not to lose info on what portion is damaged OffscreenBuffer* layer = layerNode-&gt;getLayer(); if (CC_LIKELY(layer)) &#123; ATRACE_FORMAT(\"Optimize HW Layer DisplayList %s %ux%u\", layerNode-&gt;getName(), layerNode-&gt;getWidth(), layerNode-&gt;getHeight()); Rect layerDamage = layers.entries()[i].damage; // TODO: ensure layer damage can't be larger than layer layerDamage.doIntersect(0, 0, layer-&gt;viewportWidth, layer-&gt;viewportHeight); layerNode-&gt;computeOrdering(); // map current light center into RenderNode's coordinate space Vector3 lightCenter = mCanvasState.currentSnapshot()-&gt;getRelativeLightCenter(); layer-&gt;inverseTransformInWindow.mapPoint3d(lightCenter); saveForLayer(layerNode-&gt;getWidth(), layerNode-&gt;getHeight(), 0, 0, layerDamage, lightCenter, nullptr, layerNode); if (layerNode-&gt;getDisplayList()) &#123; deferNodeOps(*layerNode); &#125; restoreForLayer(); &#125; &#125;&#125; å›åˆ°deferLayers()å‡½æ•°ã€‚è¿™é‡Œå°±æ˜¯æŠŠLayerUpdateQueueé‡Œçš„å…ƒç´ æŒ‰é€†åºæ‹¿å‡ºæ¥ï¼Œä¾æ¬¡è°ƒç”¨saveForLayer()ï¼ŒdeferNodeOps()å’ŒrestoreForLayer()ã€‚saveForLayer()ä¸ºè¯¥render layeåˆ›å»ºSnapshotå’ŒLayerBuilderå¹¶æ”¾è¿›mLayerStackå’ŒmLayerBuildersã€‚è€ŒrestoreForLayer()åˆ™æ˜¯å®ƒçš„é€†æ“ä½œã€‚Layer stackå’Œcanvas stateæ˜¯æ ˆçš„ç»“æ„ã€‚saveForLayer() å’ŒrestoreForLayer()å°±ç›¸å½“äºä¸€ä¸ªpush stackï¼Œä¸€ä¸ªpop stackã€‚è¿™é‡Œæ ¸å¿ƒçš„deferNodeOps()å‡½æ•°å¤„ç†è¯¥layerå¯¹åº”çš„DisplayListï¼Œå°†å®ƒä»¬æŒ‰ä»¥ä¸‹ç±»å‹ä»¥batchçš„å½¢å¼ç»„ç»‡å­˜æ”¾åœ¨LayerBuilderçš„mBatchesæˆå‘˜ä¸­ã€‚å…¶ä¸­åŒä¸€ç±»å‹ä¸­èƒ½åˆå¹¶çš„æ“ä½œè¿˜ä¼šè¿›è¡Œåˆå¹¶ï¼ˆç›®å‰åªæ”¯æŒBitmap, Textå’ŒPatchä¸‰ç§ç±»å‹çš„æ“ä½œåˆå¹¶ï¼‰ã€‚Batchçš„ç±»å‹æœ‰ä»¥ä¸‹å‡ ç§ï¼š 12345678910111213141516171819[-&gt;\\frameworks\\base\\libs\\hwui\\LayerBuilder.h]namespace OpBatchType &#123; enum &#123; Bitmap, MergedPatch, AlphaVertices, Vertices, AlphaMaskTexture, Text, ColorText, Shadow, TextureLayer, Functor, CopyToLayer, CopyFromLayer, Count // must be last &#125;;&#125; ä¸‹é¢çœ‹ä¸‹deferNodeOps()å‡½æ•°é‡Œæ˜¯æ€ä¹ˆå¤„ç†RenderNodeçš„ã€‚ 123456789101112131415161718192021222324252627282930313233[-&gt;\\frameworks\\base\\libs\\hwui\\FrameBuilder.cpp]/** * Used to define a list of lambdas referencing private FrameBuilder::onXX::defer() methods. * * This allows opIds embedded in the RecordedOps to be used for dispatching to these lambdas. * E.g. a BitmapOp op then would be dispatched to FrameBuilder::onBitmapOp(const BitmapOp&amp;) */#define OP_RECEIVER(Type) \\ [](FrameBuilder&amp; frameBuilder, const RecordedOp&amp; op) &#123; frameBuilder.defer##Type(static_cast&lt;const Type&amp;&gt;(op)); &#125;,void FrameBuilder::deferNodeOps(const RenderNode&amp; renderNode) &#123; typedef void (*OpDispatcher) (FrameBuilder&amp; frameBuilder, const RecordedOp&amp; op); static OpDispatcher receivers[] = BUILD_DEFERRABLE_OP_LUT(OP_RECEIVER); // can't be null, since DL=null node rejection happens before deferNodePropsAndOps const DisplayList&amp; displayList = *(renderNode.getDisplayList()); for (auto&amp; chunk : displayList.getChunks()) &#123; FatVector&lt;ZRenderNodeOpPair, 16&gt; zTranslatedNodes; buildZSortedChildList(&amp;zTranslatedNodes, displayList, chunk); defer3dChildren(chunk.reorderClip, ChildrenSelectMode::Negative, zTranslatedNodes); for (size_t opIndex = chunk.beginOpIndex; opIndex &lt; chunk.endOpIndex; opIndex++) &#123; const RecordedOp* op = displayList.getOps()[opIndex]; receivers[op-&gt;opId](*this, *op); if (CC_UNLIKELY(!renderNode.mProjectedNodes.empty() &amp;&amp; displayList.projectionReceiveIndex &gt;= 0 &amp;&amp; static_cast&lt;int&gt;(opIndex) == displayList.projectionReceiveIndex)) &#123; deferProjectedChildren(renderNode); &#125; &#125; defer3dChildren(chunk.reorderClip, ChildrenSelectMode::Positive, zTranslatedNodes); &#125;&#125; DisplayListä»¥chunkä¸ºå•ä½ç»„åˆRecordedOpã€‚è¿™äº›RecordedOpçš„opIdä»£è¡¨å®ƒä»¬çš„ç±»å‹ã€‚æ ¹æ®è¿™ä¸ªç±»å‹è°ƒç”¨receiversè¿™ä¸ªæŸ¥æ‰¾è¡¨ï¼ˆé€šè¿‡BUILD_DEFERABLE_OP_LUTæ„é€ ï¼‰ä¸­çš„å‡½æ•°ã€‚å®ƒä¼šè°ƒç”¨FrameBuilderä¸­ç›¸åº”çš„deferXXXå‡½æ•°ï¼ˆæ¯”å¦‚deferArcOp, deferBitmapOp, deferRenderNodeOpç­‰ï¼‰ã€‚è¿™äº›deferXXXç³»å‡½æ•°ä¸€èˆ¬ä¼šå°†RecordedOpç”¨BakedOpStateå°è£…ä¸€ä¸‹ï¼Œç„¶åä¼šè°ƒç”¨LayerBuilderçš„deferUnmergeableOp()å’ŒdeferMergeableOp()å‡½æ•°å°†BakedOpStateç»„ç»‡è¿›mBatchesæˆå‘˜ã€‚åŒæ—¶è¿˜æœ‰ä¸¤ä¸ªæŸ¥æ‰¾è¡¨mBatchLookupå’ŒmMergingBatchLookupåˆ†åˆ«ç”¨äºä¸èƒ½åˆå¹¶çš„batchï¼ˆOpBatchï¼‰å’Œèƒ½åˆå¹¶çš„batchï¼ˆMergingOpBatchï¼‰ã€‚å®ƒä»¬åˆ†åˆ«ç”¨äºæŸ¥æ‰¾ç‰¹å®šç±»å‹çš„æœ€è¿‘ä¸€ä¸ªOpBatchæˆ–è€…MergingOpBatchã€‚ å…ˆçœ‹ä¸‹deferUnmergeableOp()å‡½æ•°ã€‚å®ƒä¼šå°†BakedOpStateæŒ‰batchç±»å‹æ”¾è¿›mBatchesä¸­ã€‚mBatchesæ˜¯æŒ‡å‘BatchBaseå¯¹è±¡çš„vectorï¼Œæ¯ä¸ªå¤„ç†å¥½çš„BakedOpStateéƒ½ä¼šæŒ‰ç±»å‹æ”¾è¿›æ¥ã€‚å¦‚æœè¿˜æœªæœ‰è¯¥ç±»å‹çš„batchåˆ™åˆ›å»ºOpBatchï¼Œå¹¶æŠŠå®ƒæ’å…¥åˆ°mBatchesçš„æœ«å°¾ã€‚åŒæ—¶æ’å…¥mBatchLookupè¿™ä¸ªæŸ¥æ‰¾è¡¨ï¼ˆbatchIdåˆ°æœ€è¿‘ä¸€ä¸ªè¯¥ç±»å‹çš„OpBatchå¯¹è±¡çš„æ˜ å°„ï¼‰ã€‚è¿™æ ·ä¹‹åå¤„ç†åŒç±»å‹çš„BakedOpStateæ—¶å€™ï¼Œå°±ä¼šå…ˆæœç´¢è¿™ä¸ªæŸ¥æ‰¾è¡¨ã€‚å‡å¦‚æ‰¾åˆ°äº†ï¼Œåˆ™è¿›ä¸€æ­¥åœ¨mBatchesæ•°ç»„ä¸­æ‰¾åˆ°ç›¸åº”çš„OpBatchå¹¶é€šè¿‡å®ƒçš„batchOp()å°†è¯¥BakedOpStateåŠ å…¥ã€‚ 123456789101112131415161718192021[-&gt;\\frameworks\\base\\libs\\hwui\\LayerBuilder.cpp]void LayerBuilder::deferUnmergeableOp(LinearAllocator&amp; allocator, BakedOpState* op, batchid_t batchId) &#123; onDeferOp(allocator, op); OpBatch* targetBatch = mBatchLookup[batchId]; size_t insertBatchIndex = mBatches.size(); if (targetBatch) &#123; locateInsertIndex(batchId, op-&gt;computedState.clippedBounds, (BatchBase**)(&amp;targetBatch), &amp;insertBatchIndex); &#125; if (targetBatch) &#123; targetBatch-&gt;batchOp(op); &#125; else &#123; // new non-merging batch targetBatch = allocator.create&lt;OpBatch&gt;(batchId, op); mBatchLookup[batchId] = targetBatch; mBatches.insert(mBatches.begin() + insertBatchIndex, targetBatch); &#125;&#125; æ¥ä¸‹æ¥çœ‹ç”¨äºåˆå¹¶æ“ä½œçš„deferMergeableOp()å‡½æ•°ã€‚å®ƒä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œå½“æ²¡æœ‰å¯ä»¥åˆå¹¶çš„MergingOpBatchæ—¶ä¼šåˆ›å»ºæ–°çš„ï¼Œå¹¶ä¸”æ’å…¥åˆ°mBatchesã€‚å› ä¸ºå¯èƒ½å­˜åœ¨æƒ…å†µè¿™ä¸ªbatchIdåœ¨mBatchesä¸­æœ‰ä½†æ˜¯mMergingBatchLookupä¸­æ²¡æ‰¾åˆ°ï¼ˆè¯´æ˜è¿˜æ²¡æœ‰å¯åˆå¹¶çš„MergingOpBatchå¯¹è±¡ï¼‰æˆ–è€…é€šè¿‡MergingOpBatch::canMergeWidth()åˆ¤æ–­ä¸æ»¡è¶³åˆå¹¶æ¡ä»¶ã€‚è¿™æ—¶å€™å°±è¦æ’å…¥åˆ°mBatchesä¸­è¯¥ç±»å‹æ‰€åœ¨ä½ç½®ã€‚å¦‚æœå¾ˆé¡ºåˆ©çš„æƒ…å†µä¸‹ï¼Œå‰é¢å·²ç»æœ‰MergingOpBatchåœ¨mMergingBatchLookupä¸­è€Œä¸”åˆæ»¡è¶³åˆå¹¶æ¡ä»¶ï¼Œå°±é€šè¿‡MergingOpBatch::mergeOp()å°†è¯¥BakedOpStateå’Œå·²æœ‰çš„è¿›è¡Œåˆå¹¶ã€‚1234567891011121314151617181920212223242526272829[-&gt;\\frameworks\\base\\libs\\hwui\\LayerBuilder.cpp]void LayerBuilder::deferMergeableOp(LinearAllocator&amp; allocator, BakedOpState* op, batchid_t batchId, mergeid_t mergeId) &#123; onDeferOp(allocator, op); MergingOpBatch* targetBatch = nullptr; // Try to merge with any existing batch with same mergeId auto getResult = mMergingBatchLookup[batchId].find(mergeId); if (getResult != mMergingBatchLookup[batchId].end()) &#123; targetBatch = getResult-&gt;second; if (!targetBatch-&gt;canMergeWith(op)) &#123; targetBatch = nullptr; &#125; &#125; size_t insertBatchIndex = mBatches.size(); locateInsertIndex(batchId, op-&gt;computedState.clippedBounds, (BatchBase**)(&amp;targetBatch), &amp;insertBatchIndex); if (targetBatch) &#123; targetBatch-&gt;mergeOp(op); &#125; else &#123; // new merging batch targetBatch = allocator.create&lt;MergingOpBatch&gt;(batchId, op); mMergingBatchLookup[batchId].insert(std::make_pair(mergeId, targetBatch)); mBatches.insert(mBatches.begin() + insertBatchIndex, targetBatch); &#125;&#125; å›åˆ°CanvasContext::draw()å‡½æ•°ï¼Œå¤„ç†å¥½layeråï¼Œä¸‹é¢å¾—å°±æ˜¯é€šè¿‡FrameBuilder::deferRenderNodeScene()å‡½æ•°å¤„ç†FrameBuilderæˆå‘˜mRenderNodesä¸­çš„RenderNodeï¼Œå…¶ä¸­åŒ…å«äº†RootRenderNodeï¼ˆä¹Ÿå¯èƒ½æœ‰å…¶å®ƒçš„RenderNodeï¼Œæ¯”å¦‚backdropå’Œoverlay nodesï¼‰ã€‚å¯¹äºæ¯ä¸ªRenderNodeï¼Œå¦‚æœéœ€è¦ç»˜åˆ¶åˆ™è°ƒç”¨FrameBuilderçš„deferRenderNode()å‡½æ•°ï¼š 12345678[-&gt;\\frameworks\\base\\libs\\hwui\\FrameBuilder.cpp]void FrameBuilder::deferRenderNode(RenderNode&amp; renderNode) &#123; renderNode.computeOrdering(); mCanvasState.save(SaveFlags::MatrixClip); deferNodePropsAndOps(renderNode); mCanvasState.restore();&#125; è¿™é‡Œå’Œå‰é¢ç±»ä¼¼ï¼Œä¼šä¸ºä¹‹åˆ›å»ºç‹¬ç«‹çš„Snapshotï¼ˆCanvasæ¸²æŸ“çŠ¶æ€ï¼‰ï¼ŒdeferNodePropsAndOps()æ ¹æ®RenderNodeä¸­çš„RenderPropertiesé€šè¿‡CanvasStateè®¾ç½®ä¸€å †çŠ¶æ€ã€‚å¦‚æœè¯¥RenderNodeå¯¹åº”æ˜¯ä¸€ä¸ªrender layerï¼Œåˆ™å°†å®ƒå°è£…ä¸ºLayerOpï¼ˆç»˜åˆ¶offscreen bufferï¼‰å¹¶é€šè¿‡deferUnmergeableOp()åŠ å…¥batchã€‚å¦‚æœè¯¥RenderNodeå¯¹åº”RenderPropertiesæœ‰åŠé€æ˜æ•ˆæœä¸”ä¸æ˜¯render layerï¼Œåˆ™å¯ä»¥å°†è¯¥RenderNodeç»˜åˆ¶åˆ°ä¸€ä¸ªä¸´æ—¶çš„layerï¼ˆç§°ä¸ºsave layerï¼‰ã€‚è¿™æ˜¯é€šè¿‡BeginLayerOpå’ŒEndLayerOpæ¥è®°å½•çš„ã€‚æ­£å¸¸æƒ…å†µä¸‹ï¼Œè¿˜æ˜¯é€šè¿‡deferNodeOps()æ¥å°†RenderNodeè¿›è¡Œbatch/mergeã€‚è¿™ä¸ªå‡½æ•°å‰é¢å·²æœ‰è¯´æ˜ã€‚ å†æ¬¡å›åˆ°CanvasContext::draw()å‡½æ•°ï¼Œä¸‹é¢ç»ˆäºè¦çœŸå¾—è¿›è¡Œæ¸²æŸ“äº†ã€‚é¦–å…ˆåˆ›å»ºBakedOpRendererï¼Œç„¶åè°ƒç”¨FrameBuilder::replayBakedOps()å‡½æ•°å¹¶å°†BakedOpRendererä½œä¸ºå‚æ•°ä¼ è¿›å»ã€‚æ³¨æ„è¿™æ˜¯ä¸ªæ¨¡æ¿å‡½æ•°ï¼Œè¿™é‡Œæ¨¡æ¿å‚æ•°ä¸ºBakedOpDispatcherã€‚åœ¨replayBakedOps()å‡½æ•°ä¸­ä¼šæ„é€ ä¸¤ä¸ªç”¨äºå¤„ç†BakedOpStateçš„å‡½æ•°æŸ¥æ‰¾è¡¨ã€‚å®ƒä»¬å°†BakedOpStateæŒ‰æ“ä½œç±»å‹åˆ†å‘åˆ°BakedOpDispatcherçš„ç›¸åº”é™æ€å¤„ç†å‡½æ•°ï¼ˆonXXXæˆ–è€…onMergedXXXï¼Œåˆ†åˆ«ç”¨äºéåˆå¹¶å’Œåˆå¹¶çš„æ“ä½œï¼‰ ã€‚ 12345678910111213141516171819202122232425262728293031[-&gt;\\frameworks\\base\\libs\\hwui\\FrameBuilder.h]template &lt;typename StaticDispatcher, typename Renderer&gt; void replayBakedOps(Renderer&amp; renderer) &#123; std::vector&lt;OffscreenBuffer*&gt; temporaryLayers; finishDefer(); /** * Defines a LUT of lambdas which allow a recorded BakedOpState to use state-&gt;op-&gt;opId to * dispatch the op via a method on a static dispatcher when the op is replayed. * * For example a BitmapOp would resolve, via the lambda lookup, to calling: * * StaticDispatcher::onBitmapOp(Renderer&amp; renderer, const BitmapOp&amp; op, const BakedOpState&amp; state); */ #define X(Type) \\ [](void* renderer, const BakedOpState&amp; state) &#123; \\ StaticDispatcher::on##Type(*(static_cast&lt;Renderer*&gt;(renderer)), \\ static_cast&lt;const Type&amp;&gt;(*(state.op)), state); \\ &#125;, static BakedOpReceiver unmergedReceivers[] = BUILD_RENDERABLE_OP_LUT(X); #undef X /** * Defines a LUT of lambdas which allow merged arrays of BakedOpState* to be passed to a * static dispatcher when the group of merged ops is replayed. */ #define X(Type) \\ [](void* renderer, const MergedBakedOpList&amp; opList) &#123; \\ StaticDispatcher::onMerged##Type##s(*(static_cast&lt;Renderer*&gt;(renderer)), opList); \\ &#125;, static MergedOpReceiver mergedReceivers[] = BUILD_MERGEABLE_OP_LUT(X); #undef X å¦‚å‰é¢å¦‚è¿°ï¼Œä¹‹å‰å·²ç»åœ¨FrameBuilderä¸­æ„é€ äº†LayerBuilderçš„stackã€‚æ¥ä¸‹æ¥ï¼Œè¿™å„¿å°±æ˜¯æŒ‰pushæ—¶çš„é€†åºï¼ˆz-orderé«˜åˆ°åº•ï¼‰å¯¹å…¶ä¸­çš„BakedOpStateè¿›è¡Œreplayï¼Œå› ä¸ºä¸‹é¢çš„layerå¯èƒ½ä¼šä¾èµ–çš„ä¸Šé¢layerçš„æ¸²æŸ“ç»“æœã€‚æ¯”å¦‚è¦æŠŠä¸Šé¢layerç”»åœ¨FBOä¸Šçš„ä¸œè¥¿å½“æˆçº¹ç†ç”»åˆ°ä¸‹ä¸€å±‚layerä¸Šã€‚å¯¹äºlayerï¼ˆpersistentæˆ–è€…temporaryçš„ï¼‰ï¼Œå…ˆåœ¨BakedOpRenderer::startRepaintLayer()ä¸­åˆå§‹åŒ–ç›¸å…³GLç¯å¢ƒï¼Œæ¯”å¦‚åˆ›å»ºFBOï¼Œç»‘å®šlayerå¯¹åº”OffscreenBufferä¸­çš„çº¹ç†ï¼Œè®¾ç½®viewportï¼Œæ¸…color bufferç­‰ç­‰ã€‚å¯¹åº”åœ°ï¼ŒBakedOpRenderer::endLayer()ä¸­æœ€ç›¸åº”çš„é”€æ¯å’Œæ¸…ç†å·¥ä½œã€‚ä¸­é—´è°ƒç”¨LayerBuilder::replayBakedOpsImpl()å‡½æ•°åšçœŸæ­£çš„replayåŠ¨ä½œã€‚å¯¹äºfbo0ï¼ˆå³on-screen surfaceï¼‰ï¼Œä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œåªæ˜¯æŠŠstartRepaintLayer()å’ŒendLayer()æ¢æˆBakedOpRenderer::startFrame()å’ŒBakedOpRenderer::endFrame()ã€‚å®ƒä»¬çš„åŠŸèƒ½ä¹Ÿæ˜¯åˆå§‹åŒ–å’Œé”€æ¯GLç¯å¢ƒã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041[-&gt;\\frameworks\\base\\libs\\hwui\\FrameBuilder.h]template &lt;typename StaticDispatcher, typename Renderer&gt; void replayBakedOps(Renderer&amp; renderer) &#123; ..... // Relay through layers in reverse order, since layers // later in the list will be drawn by earlier ones for (int i = mLayerBuilders.size() - 1; i &gt;= 1; i--) &#123; GL_CHECKPOINT(MODERATE); LayerBuilder&amp; layer = *(mLayerBuilders[i]); if (layer.renderNode) &#123; // cached HW layer - can&apos;t skip layer if empty renderer.startRepaintLayer(layer.offscreenBuffer, layer.repaintRect); GL_CHECKPOINT(MODERATE); layer.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers); GL_CHECKPOINT(MODERATE); renderer.endLayer(); &#125; else if (!layer.empty()) &#123; // save layer - skip entire layer if empty (in which case, LayerOp has null layer). layer.offscreenBuffer = renderer.startTemporaryLayer(layer.width, layer.height); temporaryLayers.push_back(layer.offscreenBuffer); GL_CHECKPOINT(MODERATE); layer.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers); GL_CHECKPOINT(MODERATE); renderer.endLayer(); &#125; &#125; GL_CHECKPOINT(MODERATE); if (CC_LIKELY(mDrawFbo0)) &#123; const LayerBuilder&amp; fbo0 = *(mLayerBuilders[0]); renderer.startFrame(fbo0.width, fbo0.height, fbo0.repaintRect); GL_CHECKPOINT(MODERATE); fbo0.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers); GL_CHECKPOINT(MODERATE); renderer.endFrame(fbo0.repaintRect); &#125; for (auto&amp; temporaryLayer : temporaryLayers) &#123; renderer.recycleTemporaryLayer(temporaryLayer); &#125; &#125; åœ¨replayBakedOpsImpl()å‡½æ•°ä¸­ï¼Œä¼šæ ¹æ®æ“ä½œçš„ç±»å‹è°ƒç”¨å‰é¢ç”Ÿæˆçš„unmergedReceiverså’ŒmergedReceiversä¸¤ä¸ªå‡½æ•°åˆ†å‘è¡¨ä¸­çš„å¯¹åº”å¤„ç†å‡½æ•°ã€‚å®ƒä»¬å®è´¨æŒ‡å‘BakedOpDispatcherä¸­çš„é™æ€å‡½æ•°ã€‚è¿™äº›å‡½æ•°onXXXOp()å’ŒonMergedXXXOps()å‡½æ•°å¤§åŒå°å¼‚ï¼ŒåŸºæœ¬éƒ½æ˜¯é€šè¿‡GlopBuilderå°†BakedOpStateå’Œç›¸å…³çš„ä¿¡æ¯å°è£…æˆGlopå¯¹è±¡ï¼Œç„¶åè°ƒç”¨BakedOpRenderer::renderGlop()ï¼Œæ¥ç€é€šè¿‡DefaultGlopReceiver()è°ƒç”¨BakedOpRenderer::renderGlopImpl()å‡½æ•°ï¼Œæœ€ååœ¨RenderState::render()ä¸­é€šè¿‡GLå‘½ä»¤å°†Glopæ¸²æŸ“å‡ºæ¥ã€‚å¤§åŠŸå‘Šæˆã€‚ ç»“è¯­åˆå¹¶ä¹‹åï¼ŒDeferredDisplayList Vector mBatches åŒ…å«å…¨éƒ¨æ•´åˆåçš„ç»˜åˆ¶å‘½ä»¤ï¼Œä¹‹åæ¸²æŸ“å³å¯ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œçš„åˆå¹¶å¹¶ä¸æ˜¯å¤šä¸ªå˜ä¸€ä¸ªï¼Œåªæ˜¯åšäº†ä¸€ä¸ªé›†åˆï¼Œä¸»è¦æ˜¯æ–¹ä¾¿ä½¿ç”¨å„èµ„æºçº¹ç†ç­‰ï¼Œæ¯”å¦‚ç»˜åˆ¶æ–‡å­—çš„æ—¶å€™ï¼Œéœ€è¦æ ¹æ®æ–‡å­—çš„çº¹ç†è¿›è¡Œæ¸²æŸ“ï¼Œè€Œè¿™ä¸ªæ—¶å€™å°±éœ€è¦æŸ¥è¯¢æ–‡å­—çš„çº¹ç†åæ ‡ç³»ï¼Œåˆå¹¶åˆ°ä¸€èµ·æ–¹ä¾¿ç»Ÿä¸€å¤„ç†ï¼Œä¸€æ¬¡æ¸²æŸ“ï¼Œå‡å°‘èµ„æºåŠ è½½çš„æµªè´¹ï¼Œå½“ç„¶å¯¹äºç†è§£ç¡¬ä»¶åŠ é€Ÿçš„æ•´ä½“æµç¨‹ï¼Œè¿™ä¸ªåˆå¹¶æ“ä½œå¯ä»¥å®Œå…¨æ— è§†ï¼Œç”šè‡³å¯ä»¥ç›´è§‚è®¤ä¸ºï¼Œæ„å»ºå®Œä¹‹åï¼Œå°±å¯ä»¥ç›´æ¥æ¸²æŸ“ï¼Œå®ƒçš„ä¸»è¦ç‰¹ç‚¹æ˜¯åœ¨å¦ä¸€ä¸ªRenderçº¿ç¨‹ä½¿ç”¨OpenGLè¿›è¡Œç»˜åˆ¶ï¼Œè¿™ä¸ªæ˜¯å®ƒæœ€é‡è¦çš„ç‰¹ç‚¹ã€‚è€ŒmBatchesä¸­æ‰€æœ‰çš„DrawOpéƒ½ä¼šé€šè¿‡OpenGLè¢«ç»˜åˆ¶åˆ°GraphicBufferä¸­ï¼Œæœ€åé€šè¿‡swapBufferså‡½æ•°è°ƒç”¨queueBuffer()é€šçŸ¥SurfaceFlingeråˆæˆã€‚ 12345678[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLBoolean egl_window_surface_v2_t::swapBuffers()&#123;......nativeWindow-&gt;queueBuffer(nativeWindow, buffer); nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);......&#125; æ€»çš„æ¥è¯´ï¼Œå¯ä»¥çœ‹åˆ°ä¸€ä¸ªViewä¸Šçš„ä¸œè¥¿è¦ç»˜åˆ¶å‡ºæ¥ï¼Œè¦ç»è¿‡å¤šæ­¥çš„è½¬åŒ–ã€‚ è¿™æ ·åšæœ‰å‡ ä¸ªå¥½å¤„ï¼šç¬¬ä¸€ã€å¯¹ç»˜åˆ¶æ“ä½œè¿›è¡Œbatch/mergeå¯ä»¥å‡å°‘GLçš„draw callï¼Œä»è€Œå‡å°‘æ¸²æŸ“çŠ¶æ€åˆ‡æ¢ï¼Œæé«˜äº†æ€§èƒ½ã€‚ç¬¬äºŒã€å› ä¸ºå°†Viewå±‚æ¬¡ç»“æ„è¦ç»˜åˆ¶çš„ä¸œè¥¿è½¬åŒ–ä¸ºDisplayListè¿™ç§â€œä¸­é—´è¯­è¨€â€çš„å½¢å¼ï¼Œå½“éœ€è¦ç»˜åˆ¶æ—¶æ‰è½¬åŒ–ä¸ºGLå‘½ä»¤ã€‚å› æ­¤åœ¨Viewä¸­å†…å®¹æ²¡æœ‰æ›´æ”¹æˆ–åªæœ‰éƒ¨åˆ†å±æ€§æ›´æ”¹æ—¶åªè¦ä¿®æ”¹ä¸­é—´è¡¨ç¤ºï¼ˆå³RenderNodeå’ŒRenderPropertiesï¼‰å³å¯ï¼Œä»è€Œé¿å…å¾ˆå¤šé‡å¤åŠ³åŠ¨ã€‚ç¬¬ä¸‰ã€ç”±äºDisplayListä¸­åŒ…å«äº†è¦ç»˜åˆ¶çš„æ‰€æœ‰ä¿¡æ¯ï¼Œä¸€äº›å±æ€§åŠ¨ç”»å¯ä»¥ç”±æ¸²æŸ“çº¿ç¨‹å…¨æƒå¤„ç†ï¼Œæ— éœ€ä¸»çº¿ç¨‹ä»‹å…¥ï¼Œä¸»çº¿ç¨‹å¡ä½ä¹Ÿä¸ä¼šè®©ç•Œé¢å¡ä½ã€‚å¦ä¸€æ–¹é¢ï¼Œä¹Ÿå¯ä»¥çœ‹åˆ°ä¸€äº›æ½œåŠ›å¯æŒ–ã€‚æ¯”å¦‚å½“å‰å¯ä»¥åˆå¹¶çš„æ“ä½œç±»å‹æœ‰é™ã€‚å¦å¤–ä¸»çº¿ç¨‹å’Œæ¸²æŸ“çº¿ç¨‹é—´çš„å¾ˆå¤šè°ƒç”¨è¿˜æ˜¯åŒæ­¥çš„ï¼Œå¹¶è¡Œåº¦æˆ–è®¸å¯ä»¥è¿›ä¸€æ­¥æé«˜ã€‚å¦å¤–Vulkançš„å¼•å…¥ä¹Ÿå¯ä»¥å¸®åŠ©è¿›ä¸€æ­¥æ¦¨å¹²GPUçš„èƒ½åŠ›ã€‚ä¾‹å¦‚ï¼š ç»˜åˆ¶çš„æ‰¹æ¬¡æŒ‰æ–‡æœ¬ã€å›¾ç‰‡èµ„æºã€å‡ ä½•å›¾å½¢ç­‰è¿›è¡Œåˆ†ç±»ï¼Œåˆ†æ‰¹ç»˜åˆ¶çš„æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤º: ï¼ˆäº”ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroid Nä¸­UIç¡¬ä»¶æ¸²æŸ“ï¼ˆhwuiï¼‰çš„HWUI_NEW_OPS(åŸºäºAndroid 7.1) Androidåº”ç”¨ç¨‹åºUIç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“æŠ€æœ¯ç®€è¦ä»‹ç»å’Œå­¦ä¹ è®¡åˆ’ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Nä¸­UIç¡¬ä»¶æ¸²æŸ“ï¼ˆhwuiï¼‰çš„HWUI_NEW_OPS(åŸºäºAndroid 7.1)ã€‘Android DisplayList æ„å»ºè¿‡ç¨‹Android5.0ä¸­ hwui ä¸­ RenderThread å·¥ä½œæµç¨‹","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL && OpenGL","slug":"Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL && OpenGL","date":"2018-07-19T16:00:00.000Z","updated":"2018-06-20T15:11:14.394Z","comments":true,"path":"2018/07/20/Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL && OpenGL/","link":"","permalink":"http://zhoujinjian.cc/2018/07/20/Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL && OpenGL/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Graphics and Android EGLã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android 4.4 (KitKat) Design Pattern-Graphics Subsystemã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android 4.4 (KitKat) in virtualization VSync signalã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Androidæ˜¾ç¤ºç³»ç»Ÿè®¾è®¡æ¡†æ¶ä»‹ç»ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - å›¾è§£Android - Android GUI ç³»ç»Ÿ (2) - çª—å£ç®¡ç† (View, Canvas, Window Manager)ã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ğŸŒ€ğŸŒ€ï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ ã€Android Display System ç³»ç»Ÿåˆ†æç³»åˆ—ã€‘ï¼šã€Android Display Systemï¼ˆ1ï¼‰ï¼šAndroid 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æã€‘ã€Android Display Systemï¼ˆ2ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Android EGL &amp;&amp; OpenGLã€‘ã€Android Display Systemï¼ˆ3ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹HardwareRenderer.draw()ç»˜åˆ¶æµç¨‹åˆ†æã€‘ã€Android Display Systemï¼ˆ4ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Gralloc &amp;&amp; HWComposeræ¨¡å—åˆ†æã€‘ã€Android Display Systemï¼ˆ5ï¼‰ï¼šAndroid Display System ç³»ç»Ÿåˆ†æä¹‹Display Driver Architectureã€‘ Android EGLã€GLES_CMã€GLES2ï¼š \\frameworks\\native\\opengl\\libs\\EGL egl.cpp egl_display.cpp eglApi.cpp Loader.cpp \\frameworks\\native\\opengl\\libs\\GLES_CM gl.cpp gl_api.in glext_api.in \\frameworks\\native\\opengl\\libs\\GLES2 gl2.cpp gl2_api.in gl2ext_api.in OpenGL Native &amp;&amp; JNI ï¼š \\frameworks\\base\\core\\jni\\ android_opengl_GLES10.cpp android_opengl_GLES10Ext.cpp android_opengl_GLES11.cpp android_opengl_GLES11Ext.cpp android_opengl_GLES20.cpp android_opengl_GLES30.cpp android_opengl_GLES31.cpp android_opengl_GLES31Ext.cpp android_opengl_GLES32.cpp com_google_android_gles_jni_EGLImpl.cpp com_google_android_gles_jni_GLImpl.cpp Opengl Javaï¼š \\frameworks\\base\\opengl\\java\\android\\opengl GLES10.java GLES10Ext.java GLLogWrapper.java GLSurfaceView.java EGLDisplay.java EGLConfig.java EGLContext.java EGLSurface.java \\frameworks\\base\\opengl\\java\\javax\\microedition\\khronos\\opengles GL10.java GL11.java \\frameworks\\base\\opengl\\java\\com\\google\\android\\gles_jni GLImpl.java EGLImpl.java EGLConfigImpl.java EGLContextImpl.java EGLDisplayImpl.java æ€»ä½“æ¶æ„ï¼š ã€Android Display Systemï¼ˆ1ï¼‰- Android Graphics ç³»ç»Ÿ åˆ†æã€‘ ####ï¼ˆä¸€ï¼‰ã€ Android EGL åº”ç”¨å®ä¾‹ 1.1ã€Android Graphics æµ‹è¯•ç¨‹åºé¦–å…ˆçœ‹ä¸€ä¸‹Androidæµ‹è¯•ç¨‹åºï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207å‚è€ƒ\\frameworks\\native\\services\\surfaceflinger\\tests\\Transaction_test.cppæ‹·è´åŒç›®å½•ä¸‹.mkæ–‡ä»¶pushåˆ°æ‰‹æœºè¿è¡Œå³å¯çœ‹åˆ°æ•ˆæœã€‚#include &lt;gtest/gtest.h&gt;#include &lt;android/native_window.h&gt;#include &lt;binder/IMemory.h&gt;#include &lt;gui/ISurfaceComposer.h&gt;#include &lt;gui/Surface.h&gt;#include &lt;gui/SurfaceComposerClient.h&gt;#include &lt;private/gui/ComposerService.h&gt;#include &lt;private/gui/LayerState.h&gt;#include &lt;utils/String8.h&gt;#include &lt;ui/DisplayInfo.h&gt;#include &lt;math.h&gt;namespace android &#123;// Fill an RGBA_8888 formatted surface with a single color.static void fillSurfaceRGBA8(const sp&lt;SurfaceControl&gt;&amp; sc, uint8_t r, uint8_t g, uint8_t b) &#123; ANativeWindow_Buffer outBuffer; sp&lt;Surface&gt; s = sc-&gt;getSurface(); ASSERT_TRUE(s != NULL); ASSERT_EQ(NO_ERROR, s-&gt;lock(&amp;outBuffer, NULL)); uint8_t* img = reinterpret_cast&lt;uint8_t*&gt;(outBuffer.bits); for (int y = 0; y &lt; outBuffer.height; y++) &#123; for (int x = 0; x &lt; outBuffer.width; x++) &#123; uint8_t* pixel = img + (4 * (y*outBuffer.stride + x)); pixel[0] = r; pixel[1] = g; pixel[2] = b; pixel[3] = 255; &#125; &#125; ASSERT_EQ(NO_ERROR, s-&gt;unlockAndPost());&#125;class LayerTest : public ::testing::Test &#123;protected: virtual void SetUp() &#123; mComposerClient = new SurfaceComposerClient; ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck()); sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay( ISurfaceComposer::eDisplayIdMain)); DisplayInfo info; SurfaceComposerClient::getDisplayInfo(display, &amp;info); ssize_t displayWidth = info.w; ssize_t displayHeight = info.h; // Background surface black mBGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"BG Test Surface\"), displayWidth, displayHeight-720, PIXEL_FORMAT_RGBA_8888, 0); ASSERT_TRUE(mBGSurfaceControl != NULL); ASSERT_TRUE(mBGSurfaceControl-&gt;isValid()); fillSurfaceRGBA8(mBGSurfaceControl, 0, 0, 0); // Foreground surface red mFGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"FG Test Surface\"), 360, 360, PIXEL_FORMAT_RGBA_8888, 0); ASSERT_TRUE(mFGSurfaceControl != NULL); ASSERT_TRUE(mFGSurfaceControl-&gt;isValid()); fillSurfaceRGBA8(mFGSurfaceControl, 255, 0, 0); // Foreground surface blue mFGSurfaceControlBlue = mComposerClient-&gt;createSurface( String8(\"FG Test Surface\"), 360, 360, PIXEL_FORMAT_RGBA_8888, 0); ASSERT_TRUE(mFGSurfaceControlBlue != NULL); ASSERT_TRUE(mFGSurfaceControlBlue-&gt;isValid()); fillSurfaceRGBA8(mFGSurfaceControl, 0, 255, 0); // Foreground surface green mFGSurfaceControlGreen = mComposerClient-&gt;createSurface( String8(\"FG Test Surface\"), 360, 360, PIXEL_FORMAT_RGBA_8888, 0); ASSERT_TRUE(mFGSurfaceControlGreen != NULL); ASSERT_TRUE(mFGSurfaceControlGreen-&gt;isValid()); fillSurfaceRGBA8(mFGSurfaceControl, 0, 0, 255); // Synchronization surface mSyncSurfaceControl = mComposerClient-&gt;createSurface( String8(\"Sync Test Surface\"), 1, 1, PIXEL_FORMAT_RGBA_8888, 0); ASSERT_TRUE(mSyncSurfaceControl != NULL); ASSERT_TRUE(mSyncSurfaceControl-&gt;isValid()); fillSurfaceRGBA8(mSyncSurfaceControl, 31, 31, 31); //SurfaceComposerClient::openGlobalTransaction() SurfaceComposerClient::openGlobalTransaction(); mComposerClient-&gt;setDisplayLayerStack(display, 0); //black ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX-4)); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show()); //red ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX-3)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(0, 0)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show()); //blue ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX-2)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(360, 360)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show()); //green ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX-1)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(720, 720)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show()); ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX-1)); ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth-2, displayHeight-2)); ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show()); SurfaceComposerClient::closeGlobalTransaction(true); waitForPostedBuffers(); &#125; virtual void TearDown() &#123; mComposerClient-&gt;dispose(); mBGSurfaceControl = 0; mFGSurfaceControl = 0; mSyncSurfaceControl = 0; mComposerClient = 0; &#125; void waitForPostedBuffers() &#123; // Since the sync surface is in synchronous mode (i.e. double buffered) // posting three buffers to it should ensure that at least two // SurfaceFlinger::handlePageFlip calls have been made, which should // guaranteed that a buffer posted to another Surface has been retired. fillSurfaceRGBA8(mFGSurfaceControl, 255, 0, 0); fillSurfaceRGBA8(mFGSurfaceControlBlue, 0, 255, 0); fillSurfaceRGBA8(mFGSurfaceControlGreen, 0, 0, 255); fillSurfaceRGBA8(mSyncSurfaceControl, 0, 0, 0); &#125; sp&lt;SurfaceComposerClient&gt; mComposerClient; sp&lt;SurfaceControl&gt; mBGSurfaceControl; sp&lt;SurfaceControl&gt; mFGSurfaceControl;//red sp&lt;SurfaceControl&gt; mFGSurfaceControlBlue; sp&lt;SurfaceControl&gt; mFGSurfaceControlGreen; // This surface is used to ensure that the buffers posted to // mFGSurfaceControl have been picked up by SurfaceFlinger. sp&lt;SurfaceControl&gt; mSyncSurfaceControl;&#125;;TEST_F(LayerTest, LayerWorks) &#123; SurfaceComposerClient::openGlobalTransaction(); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(0, 0)); SurfaceComposerClient::closeGlobalTransaction(true); for(;;)&#123; sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay( ISurfaceComposer::eDisplayIdMain)); DisplayInfo info; SurfaceComposerClient::getDisplayInfo(display, &amp;info); ssize_t displayWidth = info.w; ssize_t displayHeight = info.h; SurfaceComposerClient::openGlobalTransaction(); mComposerClient-&gt;setDisplayLayerStack(display, 0); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX-4)); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show()); //red ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX-3)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(0, 0)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show()); //blue ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX-2)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(360, 360)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show()); //green ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX-1)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(720, 720)); ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show()); //Sync ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX-1)); ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth-2, displayHeight-2)); ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show()); SurfaceComposerClient::closeGlobalTransaction(true); &#125;&#125; å®ç°æ•ˆæœï¼ˆä¿æŒè¿è¡Œï¼Œå¯ä»¥çœ‹åˆ°ç•Œé¢æœ€é¡¶å±‚ä¼šç»˜åˆ¶é»‘è‰²èƒŒæ™¯å’Œçº¢ç»¿è“ä¸‰ä¸ªè‰²å—ï¼‰ï¼š å¯ä»¥çœ‹åˆ°æ¯”è¾ƒå…³é”®çš„ä»£ç ï¼š 1234567891011121314151617181920212223//åˆ›å»ºSurfaceComposerClientmComposerClient = new SurfaceComposerClient;ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());//è·å–displayä¿¡æ¯sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay( ISurfaceComposer::eDisplayIdMain));DisplayInfo info;SurfaceComposerClient::getDisplayInfo(display, &amp;info);ssize_t displayWidth = info.w;ssize_t displayHeight = info.h;// Background surface black//è¯·æ±‚SurfaceFlingeråˆ›å»ºSurfacemBGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"BG Test Surface\"), displayWidth, displayHeight-720, PIXEL_FORMAT_RGBA_8888, 0);//å¡«å……SurfacefillSurfaceRGBA8(mBGSurfaceControl, 0, 0, 0);//è®¾ç½®Layerå±‚çº§ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX-4));//SurfaceControl-&gt;show()æ˜¾ç¤ºsurfaceASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show()); è¿™éƒ¨åˆ†çš„åˆ†æè¯·å‚è€ƒã€Android Display Systemï¼ˆ1ï¼‰- Android Graphics ç³»ç»Ÿ åˆ†æã€‘æˆ‘ä»¬è¿™é‡Œä¸»è¦ä¸ºäº†å¼•å‡ºAndroidåº•å±‚å¦‚ä½•åˆ©ç”¨EGLç»˜å›¾ã€‚ 1.2ã€Android BootAnimation å¼€æœºåŠ¨ç”»(EGLåœ¨Androidä¸­åº”ç”¨) å…³é”®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[-&gt;\\frameworks\\base\\cmds\\bootanimation\\BootAnimation.cpp]status_t BootAnimation::readyToRun() &#123; mAssets.addDefaultAssets(); sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay( ISurfaceComposer::eDisplayIdMain)); DisplayInfo dinfo; status_t status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo); // create the native surface sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(\"BootAnimation\"), dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565); SurfaceComposerClient::openGlobalTransaction(); control-&gt;setLayer(0x40000000); SurfaceComposerClient::closeGlobalTransaction(); sp&lt;Surface&gt; s = control-&gt;getSurface(); // initialize opengl and egl ...... // (1)ã€è·å¾— EGLDisplay å¯¹è±¡ã€‚ EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY); // (2)ã€åˆå§‹åŒ– EGLDisplay å¯¹è±¡ eglInitialize(display, 0, 0); // (3)ã€é€‰æ‹© EGLConfig eglChooseConfig(display, attribs, &amp;config, 1, &amp;numConfigs); // (4)ã€åˆ›å»º Windows Surface surface = eglCreateWindowSurface(display, config, s.get(), NULL); // (5)ã€åˆ›å»º EGL context context = eglCreateContext(display, config, NULL, NULL); eglQuerySurface(display, surface, EGL_WIDTH, &amp;w); eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h); // (6)ã€å¯ç”¨å‰é¢åˆ›å»ºçš„ EGL context if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE) return NO_INIT; &#125;bool BootAnimation::playAnimation(const Animation&amp; animation)&#123; ...... // (7)ã€OpenGL ES API ç»˜åˆ¶å›¾å½¢ï¼šgl_*() glDrawTexiOES(xc, mHeight - (yc + frame.trimHeight), 0, frame.trimWidth, frame.trimHeight); ...... // (8)ã€SwapBuffersæ˜¾ç¤º eglSwapBuffers(mDisplay, mSurface); ...... &#125; ä½¿ç”¨EGLä¸€èˆ¬ä¼šç»å†ä»¥ä¸Šå‡ ä¸ªæ­¥éª¤ã€‚ 1.2ã€Understanding Android Graphics Internalsè¦æ·±å…¥äº†è§£Android Graphicsæœºåˆ¶ï¼Œéœ€è¦äº†è§£ç†Ÿæ‚‰ä»¥ä¸‹çŸ¥è¯†ï¼ˆåŒ…æ‹¬ä½†ä¸é™äºï¼‰ã€‚ ####ï¼ˆäºŒï¼‰ã€OpenGL ES 2.0 çŸ¥è¯†ä¸²è®²åœ¨äº†è§£EGLä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹å‰äººæ€»ç»“çš„çŸ¥è¯†OPENGL ES 2.0 çŸ¥è¯†ä¸²è®²ï¼š 2.1ã€å†™åœ¨å‰é¢çš„è¯2.1.1ã€ç”µè„‘æ˜¯åšä»€ä¹ˆç”¨çš„?ç”µè„‘åˆè¢«ç§°ä¸ºè®¡ç®—æœº,é‚£ä¹ˆæœ€é‡è¦çš„å·¥ä½œå°±æ˜¯è®¡ç®—ã€‚çœ‹è¿‡ä¸‰ä½“çš„åŒå­¦éƒ½çŸ¥é“, ç”µè„‘ä¸­æœ‰æ— æ•°çº³ç±³çº§åˆ«çš„è®¡ç®—å•å…ƒ,é€šè¿‡ 0 å’Œ 1 çš„è½¬æ¢,å®ŒæˆåŠ å‡ä¹˜é™¤çš„æ“ä½œã€‚ 2.1.2ã€æ˜¯ä»€ä¹ˆä½¿å¾—ç”µè„‘å·¥ä½œ?é©±åŠ¨,é©±ä½¿ç€ç¡¬ä»¶å®Œæˆå·¥ä½œã€‚ 2.1.3ã€è°æ¥å†™é©±åŠ¨?åˆ¶é€ ç”µè„‘çš„å…¬å¸è‡ªå·±æ¥å†™é©±åŠ¨,å› ä¸ºä»–ä»¬å¯¹è‡ªå·±çš„åº•å±‚ç¡¬ä»¶æ¶æ„æœ€ç†Ÿæ‚‰ã€‚ 2.1.4ã€è°ä¼šä½¿ç”¨é©±åŠ¨?æ‰€æœ‰çš„è½¯ä»¶å·¥ç¨‹å¸ˆéƒ½ä¼šç›´æ¥æˆ–è€…é—´æ¥çš„ä½¿ç”¨åˆ°é©±åŠ¨ã€‚ é‚£ä¹ˆé—®é¢˜æ¥äº†,å¦‚æœè¯´ä¸åŒçš„ç”µè„‘å…¬å¸,åˆ¶é€ å‡ºæ¥ä¸åŒçš„ç¡¬ä»¶,ä½¿ç”¨ä¸åŒçš„ é©±åŠ¨,æä¾›å‡ºæ¥ä¸åŒçš„æ¥å£ä¾›è½¯ä»¶å·¥ç¨‹å¸ˆè¿›è¡Œä½¿ç”¨,é‚£ä¹ˆè½¯ä»¶å·¥ç¨‹å¸ˆå°±è¦å´©æºƒäº†ã€‚ æ‰€ä»¥,ä¸€å®šæ˜¯éœ€è¦ä¸€ä¸ªæ ‡å‡†,æ¥ç»Ÿä¸€ä¸€ä¸‹ã€‚ 2.1.5ã€é‚£ä¹ˆåœ¨å“ªé‡Œè¿›è¡Œç»Ÿä¸€?ç¡¬ä»¶æ²¡æœ‰åŠæ³•ç»Ÿä¸€,æ¯ä¸ªç”µè„‘å…¬å¸ä¸ºäº†ä¼˜åŒ–è‡ªå·±ç”µè„‘æ€§èƒ½å’ŒåŠŸè€—,åˆ¶é€ å‡ºæ¥ ä¸åŒçš„ç¡¬ä»¶æ¶æ„,è¿™æ˜¯éœ€è¦æ— æ•°çš„å¿ƒè¡€å®Œæˆçš„,å¦‚æœç»Ÿä¸€äº†,é‚£ä¹ˆå°±ä¸éœ€è¦é‚£ä¹ˆ å¤šç”µè„‘å…¬å¸äº†ã€‚ æ‰€ä»¥åªèƒ½ç»Ÿä¸€é©±åŠ¨çš„æ¥å£ã€‚ ç”µè„‘ç»„ä»¶å¤§è‡´åˆ†ä¸º:CPUã€GPUã€å†…å­˜ã€æ€»çº¿ç­‰ã€‚è€Œ OpenGL å°±æ˜¯ GPU é©±åŠ¨ çš„ä¸€å¥—æ ‡å‡†æ¥å£(OpenGL ES ä¸ºåµŒå…¥å¼è®¾å¤‡ GPU é©±åŠ¨çš„æ ‡å‡†æ¥å£,æ¯”å¦‚æ‰‹æœº, OpenGL ES å…¨ç§°:OpenGL for Embedded Systems)ã€‚ æ‰€ä»¥ç»¼ä¸Šæ‰€è¿°,æˆ‘ä½¿ç”¨äº† 5 ä¸ªé—®é¢˜,å¼•å‡ºäº† OpenGL çš„ç”¨å¤„:å°±æ˜¯å°†å¤æ‚çš„ã€ å„ç§å„æ ·çš„ GPU ç¡¬ä»¶åŒ…è£…èµ·æ¥,å„ä¸ªç”µè„‘å…¬å¸ç¼–å†™è‡ªå®¶çš„é©±åŠ¨,ç„¶åæä¾›å‡ºæ¥ ä¸€å¥—ç»Ÿä¸€çš„æ¥å£,ä¾›ä¸Šå±‚è½¯ä»¶å·¥ç¨‹å¸ˆè°ƒç”¨ã€‚è¿™æ ·,ä¸–ç•Œå°±å’Œå¹³äº†ã€‚ 2.1.6ã€è°è¿™ä¹ˆç‰›,å®šä¹‰äº† OpenGL è¿™å¥—æ ‡å‡†?Khronosã€‚æ¯å½“æˆ‘æ‰“è¿™å‡ ä¸ªå­—æ¯çš„æ—¶å€™,éƒ½ä¼šæŠ±æœ‰ä¸€ç§æ•¬ç•çš„å¿ƒç†,å› ä¸ºå®ƒ ä¸æ˜¯ä¸€å®¶å…¬å¸,å®ƒæ˜¯ä¸€ä¸ªç»„ç»‡,å®ƒæ˜¯ç”±ä¼—å¤šå¤§å…¬å¸è”åˆç»„å»ºè€Œæ¥,æ¯”å¦‚ Appleã€ Intelã€AMDã€Googleã€ARMã€Qualcommã€Nvidia ç­‰ç­‰ç­‰ç­‰ã€‚å„ä¸ªå¤§å…¬å¸æŠ•å…¥äº†å¤§ é‡çš„äººåŠ›ã€èµ„é‡‘ç­‰åˆ›å»ºäº†è¿™ä¸ªç»„ç»‡ã€‚å¯¹ç”µè„‘ GPU å®šä¹‰äº†ç»Ÿä¸€çš„æ¥å£ OpenGL,å¯¹ æ‰‹æœº GPU å®šä¹‰äº†ç»Ÿä¸€çš„æ¥å£ OpenGL ES(æˆ‘ä¹Ÿéå¸¸æœ‰å¹¸,åœ¨ Intel å·¥ä½œæœŸé—´,è·Ÿ Intel é©» Khronos çš„ 3D è´Ÿè´£äººå…±äº‹äº†ä¸€æ®µæ—¶é—´,æ¯å‘¨ä¸€æ¬¡çš„è·¨æ´‹ç”µè¯,éƒ½ä¼šè®©æˆ‘å—ç›ŠåŒªæµ…) è¿™ä¸ªç»„ç»‡é™¤äº†å®šä¹‰äº† OpenGL æ¥å£ä¹‹å¤–,è¿˜å®šä¹‰äº†å¾ˆå¤šå…¶ä»–æ¥å£ã€‚ç›®å‰é’ˆå¯¹ GPU åˆæå‡ºäº†å¦å¤–ä¸€å¥—æ›´åº•å±‚çš„æ¥å£ Vulkan,è¿™æ˜¯ä¸€å¥—æ¯” OpenGL æ›´åº•å±‚çš„æ¥å£, ä½¿ç”¨å…¶å¯ä»¥æ›´å®¹æ˜“ä¼˜åŒ–,ä¸è¿‡ç›®å‰ç¡¬ä»¶å‚å•†çš„é©±åŠ¨è¿˜æœ‰å¾…å¼€å‘,å¯èƒ½æ™®åŠ Vulkan è¿˜éœ€è¦å¾ˆå¤šå¹´ã€‚å°±å¥½æ¯” OpenGL ES å·²ç»å‘å±•åˆ°äº† 3.1,è€Œå¸‚é¢ä¸Šçš„æ‰‹æœºå¾ˆå¤šè¿˜æ˜¯ åªèƒ½æ”¯æŒ OpenGL ES 2.0 ä¸€æ ·ã€‚æ‰€ä»¥æ–°çš„ç§‘æŠ€ä»æå‡º,åˆ°å®ç°,åˆ°é‡äº§,åˆ°ä½¿ç”¨, åˆ°æ™®åŠ,æ˜¯ä¸€æ®µå¾ˆé•¿çš„è·¯ã€‚ æ‰€ä»¥,æˆ‘ä»¬ç°åœ¨å­¦ä¹  OpenGL ES 2.0 æ˜¯é€‚æ—¶çš„,ä¸”æ˜¯éå¸¸å¿…è¦çš„(ä¸æ‡‚ 2.0, æƒ³ç›´æ¥å­¦ä¹ æ›´éš¾çš„ 3.0ã€3.1ã€Vulkan,å¾ˆéš¾)ã€‚ äº‹å…ˆé¢„å‘Šä¸€ä¸‹,OpenGL ES 2.0 ä¼šåˆ†åä¸‰ä¸ªè¯¾ç¨‹,ç»“æŸä¹‹å,æˆ‘ä¼šç«‹å³å¥‰ä¸Š OpenGL ES 3.0 åœ¨ OpenGL ES 2.0 åŸºç¡€ä¸Šçš„æ”¹å˜ã€‚ 2.1.7ã€OpenGL å’Œæˆ‘ä»¬æ¸¸æˆï¼ˆAndroid ï¼‰å¼€å‘è€…æœ‰ä»€ä¹ˆå…³ç³»?ç”µè„‘/æ‰‹æœºå±å¹•ä¸Šæ˜¾ç¤ºçš„ä¸œè¥¿,è¦ä¹ˆæ˜¯ 2D çš„,è¦ä¹ˆæ˜¯ 3D çš„,é‚£ä¹ˆå¦‚æœæ˜¯ 3D çš„,ä¸ç®¡æ˜¯ App ä¹Ÿå¥½,æ¸¸æˆä¹Ÿå¥½,ç®€å•çš„å›¾ç‰‡ç•Œé¢ä¹Ÿå¥½,åº•å±‚éƒ½æ˜¯é€šè¿‡ GPUã€ é€šè¿‡ OpenGL(ES)ç»˜åˆ¶å‡ºæ¥çš„ã€‚ å¼€å‘ App çš„æ—¶å€™,æ˜¯é€šè¿‡åˆ›å»ºæ§ä»¶çš„æ–¹å¼,è€Œæ§ä»¶å·²ç»å¯¹åº•å±‚è¿›è¡Œäº†ä¸€å±‚å°è£…,æ‰€ä»¥ App å¼€å‘è€…å¾ˆå°‘ä¼šæ¥è§¦åˆ° OpenGL(ES)ã€‚ æ¸¸æˆçš„å¼€å‘æ˜¯é€šè¿‡æ¸¸æˆå¼•æ“,è€Œæ¸¸æˆå¼•æ“çš„æœ€åº•å±‚,æ˜¯ç›´æ¥è°ƒç”¨äº† OpenGL(ES),ç›´æ¥å¯¹ GPU è¿›è¡Œæ§åˆ¶ã€‚ æ‰€ä»¥è¯´æ¸¸æˆå¼•æ“å·¥ç¨‹å¸ˆå¿…é¡»æ‡‚ OpenGL(ES),è€Œæ¸¸æˆå¼€å‘è€…,æƒ³è¦æ›´å¥½çš„å¯¹æ¸¸æˆè¿›è¡Œæ›´å¥½çš„ç†è§£å’Œä¼˜åŒ–,ä¹Ÿå»ºè®®å­¦ä¸€äº› OpenGL(ES)ã€‚ 2.1.8ã€DirectX æ˜¯ä»€ä¹ˆ?æœ€åä¸€ä¸ªé—®é¢˜ã€‚æˆ‘ä»¬å‘ç° Khronos ç»„ç»‡çš„æˆå‘˜ä¸­,æˆ‘æ²¡æœ‰æåˆ°å¤§åé¼é¼çš„å¾® è½¯,å› ä¸ºå¾®è½¯ä¸åœ¨ç»„ç»‡ä¸­,è€Œå®ƒæå‡ºäº†è‡ªå·±çš„ GPU é©±åŠ¨æ ‡å‡†,DirectXã€‚ æ‰€ä»¥ç›®å‰æ‰‹æœº,ä¸ç®¡æ˜¯ iOS è¿˜æ˜¯ Android,éƒ½æ˜¯æ”¯æŒ OpenGL ESã€‚ç”µè„‘,Windows ç³»ç»Ÿæ”¯æŒ DirectX å’Œ OpenGL,Linux/Mac(Unix)ç³»ç»Ÿæ”¯æŒ OpenGLã€‚ 2.2ã€OpenGL ES çš„ä¸¤ä¸ªå°ä¼™ä¼´è™½ç„¶,æˆ‘ä»¬æ•™ç¨‹çš„æ ‡é¢˜æ˜¯ OpenGL ES,ä½†æ˜¯æˆ‘ä»¬çš„å†…å®¹å°†ä¸ä»…é™äº OpenGL ESã€‚ OpenGL ES æ˜¯è´Ÿè´£ GPU å·¥ä½œçš„,ç›®çš„æ˜¯é€šè¿‡ GPU è®¡ç®—,å¾—åˆ°ä¸€å¼ å›¾ç‰‡,è¿™å¼ å›¾ ç‰‡åœ¨å†…å­˜ä¸­å…¶å®å°±æ˜¯ä¸€å— buffer,å­˜å‚¨æœ‰æ¯ä¸ªç‚¹çš„é¢œè‰²ä¿¡æ¯ç­‰ã€‚è€Œè¿™å¼ å›¾ç‰‡æœ€ç»ˆæ˜¯è¦æ˜¾ç¤ºåˆ°å±å¹•ä¸Š,æ‰€ä»¥è¿˜éœ€è¦å…·ä½“çš„çª—å£ç³»ç»Ÿæ¥æ“ä½œ,OpenGL ES å¹¶æ²¡æœ‰ç›¸å…³çš„å‡½æ•°ã€‚æ‰€ä»¥,OpenGL ES æœ‰ä¸€ä¸ªå¥½æ­æ¡£ EGLã€‚ EGL,å…¨ç§°:embedded Graphic Interface,æ˜¯ OpenGL ES å’Œåº•å±‚ Native å¹³å° è§†çª—ç³»ç»Ÿä¹‹é—´çš„æ¥å£ã€‚æ‰€ä»¥å¤§æ¦‚æµç¨‹æ˜¯è¿™æ ·çš„:é¦–å…ˆ,é€šè¿‡ EGL è·å–åˆ°æ‰‹æœºå±å¹• çš„ handle,è·å–åˆ°æ‰‹æœºæ”¯æŒçš„é…ç½®(RGBA8888/RGB565 ä¹‹ç±»,è¡¨ç¤ºæ¯ä¸ªåƒç´ ä¸­åŒ… å«çš„é¢œè‰²ç­‰ä¿¡æ¯çš„å­˜å‚¨ç©ºé—´æ˜¯å¤šå°‘ä½),ç„¶åæ ¹æ®è¿™ä¸ªé…ç½®åˆ›å»ºä¸€å—åŒ…å«é»˜è®¤ buffer çš„ surface(buffer çš„å¤§å°æ˜¯æ ¹æ®å±å¹•åˆ†è¾¨ç‡ä¹˜ä»¥æ¯ä¸ªåƒç´ ä¿¡æ¯æ‰€å å¤§å°è®¡ ç®—è€Œå¾—)å’Œç”¨äºå­˜æ”¾ OpenGL ES çŠ¶æ€é›†çš„ context,å¹¶å°†å®ƒä»¬ enable èµ·æ¥ã€‚ç„¶å, é€šè¿‡ OpenGL ES æ“ä½œ GPU è¿›è¡Œè®¡ç®—,å°†è®¡ç®—çš„ç»“æœä¿å­˜åœ¨ surface çš„ buffer ä¸­ã€‚ æœ€å,ä½¿ç”¨ EGL,å°†ç»˜åˆ¶çš„å›¾ç‰‡æ˜¾ç¤ºåˆ°æ‰‹æœºå±å¹•ä¸Šã€‚ è€Œåœ¨ OpenGL ES æ“ä½œ GPU è®¡ç®—çš„æ—¶å€™,è¿˜éœ€è¦ä»‹ç» OpenGL ES çš„å¦å¤–ä¸€ä¸ªå¥½æ­æ¡£ GLSLã€‚ GLSL,å…¨ç§°:OpenGL Shading Language,æ˜¯ OpenGL ES ä¸­ä½¿ç”¨åˆ°çš„ç€è‰²å™¨çš„ è¯­è¨€,ç”¨è¿™ä¸ªè¯­è¨€å¯ä»¥ç¼–å†™å°ç¨‹åºè¿è¡Œåœ¨ GPU ä¸Šã€‚ åœ¨è¿™é‡Œéœ€è¦å…ˆæåˆ° CPU å’Œ GPU çš„åŒºåˆ«,å®ƒä»¬çš„åŠŸèƒ½éƒ½æ˜¯ç”¨äºè®¡ç®—,ä¹Ÿéƒ½æ˜¯ç”±å¾ˆå¤šæ ¸ç»„æˆ,åŒºåˆ«åœ¨äº CPU çš„æ ¸æ¯”è¾ƒå°‘,ä½†æ˜¯å•ä¸ªæ ¸çš„è®¡ç®—èƒ½åŠ›æ¯”è¾ƒå¼º,è€Œ GPU çš„æ ¸å¾ˆå¤š,ä½†æ˜¯æ¯ä¸ªæ ¸çš„è®¡ç®—èƒ½åŠ›éƒ½ä¸ç®—ç‰¹åˆ«å¼ºã€‚ç›®å‰ GPU çš„ä¸»è¦å·¥ä½œæ˜¯ç”¨äºç”Ÿæˆå›¾ç‰‡(ç°åœ¨ä¹Ÿæœ‰é€šè¿‡ GPU è¿›è¡Œé«˜æ€§èƒ½è¿ç®—_å¹¶è¡Œè¿ç®—,ä½†æ˜¯åœ¨è¿™é‡Œä¸å±äºè®¨è®ºçš„èŒƒå›´),åŸå› å°±æ˜¯å›¾ç‰‡æ˜¯ç”±å¾ˆå¤šåƒç´ ç»„æˆ,æ¯ä¸ªåƒç´ éƒ½åŒ…å«æœ‰é¢œè‰²ã€æ·±åº¦ç­‰ä¿¡æ¯,è€Œä¸ºäº†å¾—åˆ°è¿™äº›ä¿¡æ¯æ•°æ®,é’ˆå¯¹æ¯ä¸ªåƒç´ ç‚¹çš„è®¡ç®—,æ˜¯å¯ä»¥é€šè¿‡ç»Ÿä¸€çš„ç®—æ³•æ¥å®Œæˆã€‚GPU å°±æ“…é•¿å¤„ç†é’ˆå¯¹è¿™ç§å¤§è§„æ¨¡æ•°æ®,ä½¿ç”¨åŒä¸€ä¸ªç®—æ³•è¿›è¡Œè®¡ç®—ã€‚è€Œè¿™ä¸ªç®—æ³•,å°±æ˜¯ä½¿ç”¨ GLSL å†™æˆ Shader,ä¾› GPU è¿ç®—ä½¿ç”¨ã€‚ åœ¨å›¾å½¢å­¦çš„è§†è§’ä¸­,æ‰€æœ‰çš„å›¾ç‰‡éƒ½æ˜¯ç”±ä¸‰è§’å½¢æ„æˆçš„ã€‚æ‰€ä»¥é€šè¿‡ OpenGL ES ç»˜åˆ¶å›¾ç‰‡çš„æ—¶å€™,æˆ‘ä»¬éœ€è¦é€šè¿‡ OpenGL ES API åˆ›å»ºç”¨äºåœ¨ GPU ä¸Šè¿è¡Œçš„ shader, ç„¶åå°†é€šè¿‡ CPU è·å–åˆ°çš„å›¾ç‰‡é¡¶ç‚¹ä¿¡æ¯,ä¼ å…¥ GPU ä¸­çš„ Shader ä¸­ã€‚åœ¨ Vertex Shader ä¸­é€šè¿‡çŸ©é˜µå˜æ¢,å°†é¡¶ç‚¹åæ ‡ä»æ¨¡å‹åæ ‡ç³»è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»,å†åˆ°è§‚å¯Ÿåæ ‡ç³»,åˆ°è£å‰ªåæ ‡ç³»,æœ€åæŠ•å½±åˆ°å±å¹•åæ ‡ç³»ä¸­,è®¡ç®—å‡ºåœ¨å±å¹•ä¸Šå„ä¸ªé¡¶ç‚¹çš„åæ ‡ã€‚ç„¶å,é€šè¿‡å…‰æ …åŒ–,ä»¥æ’å€¼çš„æ–¹æ³•å¾—åˆ°æ‰€æœ‰åƒç´ ç‚¹çš„ä¿¡æ¯,å¹¶åœ¨ Fragment shader ä¸­è®¡ç®—å‡ºæ‰€æœ‰åƒç´ ç‚¹çš„é¢œè‰²ã€‚æœ€å,é€šè¿‡ OpenGL ES çš„ API è®¾å®šçš„çŠ¶æ€,å°†å¾—åˆ°çš„åƒç´ ä¿¡æ¯è¿›è¡Œ depth/stencil testã€blend,å¾—åˆ°æœ€ç»ˆçš„å›¾ç‰‡ã€‚ 2.3ã€å±å¹•å›¾ç‰‡çš„æœ¬è´¨å’Œäº§ç”Ÿè¿‡ç¨‹å½“æˆ‘ä»¬ä¹°ä¸€ä¸ªæ‰‹æœºçš„æ—¶å€™,æˆ‘ä»¬ä¼šéå¸¸å…³æ³¨è¿™ä¸ªæ‰‹æœºçš„åˆ†è¾¨ç‡ã€‚åˆ†è¾¨ç‡ä»£è¡¨ç€åƒç´ çš„å¤šå°‘,æ¯”å¦‚æˆ‘ä»¬ç†ŸçŸ¥çš„ iphone6 çš„åˆ†è¾¨ç‡ä¸º 1334Ã—750,è€Œ iphone6 plus çš„åˆ†è¾¨ç‡æ˜¯1920Ã—1080ã€‚ æ‰‹æœºå±å¹•ä¸Šçš„å›¾ç‰‡,æ˜¯ç”±ä¸€ä¸ªä¸€ä¸ªçš„åƒç´ ç»„æˆ,é‚£ä¹ˆå¯ä»¥è®¡ç®—å‡ºæ¥,ä¸€ä¸ªå±å¹•ä¸Šçš„å›¾ç‰‡,æ˜¯ç”±ä¸Šç™¾ä¸‡ä¸ªåƒç´ ç‚¹ç»„æˆã€‚è€Œæ¯ä¸ªåƒç´ ç‚¹éƒ½æœ‰è‡ªå·±çš„é¢œè‰²,æ¯ç§é¢œè‰²éƒ½æ˜¯ç”± RGB ä¸‰åŸè‰²ç»„æˆã€‚ä¸‰åŸè‰²æŒ‰ç…§ä¸åŒçš„æ¯”ä¾‹æ··åˆ,ç»„æˆäº†æ‰‹æœºæ‰€èƒ½æ˜¾ç¤ºå‡ºæ¥çš„é¢œè‰²ã€‚ æ¯ä¸ªåƒç´ çš„é¢œè‰²ä¿¡æ¯éƒ½ä¿å­˜åœ¨ buffer ä¸­,è¿™å— buffer å¯ä»¥åˆ†ç»™ RGB æ¯ä¸ªé€š é“å„ 8bit è¿›è¡Œä¿¡æ¯ä¿å­˜,ä¹Ÿå¯ä»¥åˆ†ç»™ RGB æ¯ä¸ªé€šé“ä¸åŒçš„ç©ºé—´è¿›è¡Œä¿¡æ¯ä¿å­˜, æ¯”å¦‚ç”±äºäººçœ¼å¯¹ç»¿è‰²æœ€æ•æ„Ÿ,é‚£ä¹ˆå¯ä»¥åˆ†é…ç»™ G é€šé“ 6 ä½,R å’Œ B é€šé“å„ 5 ä½ã€‚è¿™äº›éƒ½æ˜¯å¸¸è§çš„æ‰‹æœºé…ç½®ã€‚å‡å¦‚ä½¿ç”¨ RGB888 çš„æ‰‹æœºé…ç½®,ä¹Ÿå°±æ˜¯æ¯ç§é¢œè‰²çš„å–å€¼ä» 0 åˆ° 255,0 æœ€å°,255 æœ€å¤§ã€‚é‚£ä¹ˆçº¢ç»¿è“éƒ½ä¸º 0 çš„æ—¶å€™,è¿™ä¸ªåƒç´ ç‚¹çš„é¢œè‰²å°±æ˜¯é»‘è‰²,çº¢ç»¿è“éƒ½ä¸º 255 çš„æ—¶å€™,è¿™ä¸ªåƒç´ ç‚¹çš„é¢œè‰²å°±æ˜¯ç™½è‰²ã€‚å½“çº¢ä¸º 255, ç»¿è“éƒ½ä¸º 0 çš„æ—¶å€™,è¿™ä¸ªåƒç´ ç‚¹çš„é¢œè‰²å°±æ˜¯çº¢è‰²ã€‚å½“çº¢ç»¿ä¸º 255,è“ä¸º 0 çš„æ—¶å€™, è¿™ä¸ªåƒç´ ç‚¹çš„é¢œè‰²å°±æ˜¯é»„è‰²ã€‚å½“ç„¶ä¸æ˜¯åªå– 0 æˆ–è€… 255,å¯ä»¥å– 0-255 ä¸­é—´çš„å€¼, 100,200,ä»»æ„åœ¨ 0 å’Œ 255 ä¸­é—´çš„å€¼éƒ½æ²¡æœ‰é—®é¢˜ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç®—ä¸€ä¸‹,æŒ‰ç…§çº¢ç»¿è“ä¸åŒæ¯”ä¾‹è¿›è¡Œæ­é…,æ¯ä¸ªåƒç´ ç‚¹,å¯ä»¥æ˜¾ç¤ºçš„é¢œè‰²æœ‰ 255255255=16581375 ç§,è¿™ä¸ªæ•°å­—æ˜¯éå¸¸ææ€–,æ‰€ä»¥æˆ‘ä»¬çš„æ‰‹æœºå¯ä»¥æ˜¾ç¤ºå‡ºæ¥å„ç§å„æ ·çš„é¢œè‰²ã€‚ è¿™é‡Œåœ¨å»¶ä¼¸çš„ç§‘æ™®ä¸€ä¸‹,æˆ‘ä»¬çœ‹åˆ°æ‰‹æœºå¯ä»¥æ˜¾ç¤ºé‚£ä¹ˆå¤šç§é¢œè‰²äº†,ä½†æ˜¯æ˜¯ä¸æ˜¯è¯´æˆ‘ä»¬çš„æ‰‹æœºåœ¨é¢œè‰²ä¸Šå°±å·²ç»å‘å±•åˆ°æè‡´äº†å‘¢?å…¶å®æ˜¯è¿œè¿œæ²¡æœ‰çš„,åœ¨è¿™ä¸ªæ‰‹æœºé…ç½®ä¸‹,ä¸‰åŸè‰²ä¸­æ¯ä¸€ç§çš„å–å€¼å¯ä»¥ä» 0 åˆ° 255,è€Œåœ¨ç°å®ç”Ÿæ´»ä¸­,å®ƒä»¬çš„å– å€¼å¯ä»¥ä» 0 åˆ° 1 äº¿,è€Œæˆ‘ä»¬äººç±»çš„çœ¼ç›æ‰€èƒ½çœ‹åˆ°çš„èŒƒå›´æ˜¯,ä» 0 åˆ° 10 ä¸‡ã€‚æ‰€ä»¥æ‰‹æœºç¡¬ä»¶è¿˜å­˜åœ¨å¾ˆå¤§çš„æå‡ç©ºé—´ã€‚è€Œåœ¨æ‰‹æœºç¡¬ä»¶æå‡ä¹‹å‰,æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ HDR ç­‰æŠ€æœ¯å°½é‡çš„åœ¨æ‰‹æœºä¸­å¤šæ˜¾ç¤ºä¸€äº›é¢œè‰²ã€‚æ‰€ä»¥,è®²åˆ°è¿™é‡Œ,æˆ‘ä»¬çŸ¥é“äº†,æ‰‹æœºå±å¹•ä¸Šæ˜¾ç¤ºçš„å›¾ç‰‡,æ˜¯ç”±è¿™ä¸Šç™¾ä¸‡ä¸ªåƒç´ ç‚¹,ä»¥åŠè¿™ä¸Šç™¾ä¸‡ä¸ªåƒç´ ç‚¹å¯¹åº”çš„é¢œè‰²ç»„æˆçš„ã€‚ ç”¨ç¨‹åºå‘˜çš„è§’åº¦æ¥çœ‹,å°±æ˜¯æ‰‹æœºå±å¹•å¯¹åº”ç€ä¸€å— buffer,è¿™å— buffer å¯¹åº”ä¸Šç™¾ä¸‡ä¸ªåƒç´ ç‚¹,æ¯ä¸ªåƒç´ ç‚¹éœ€è¦ä¸€å®šçš„ç©ºé—´æ¥å­˜å‚¨å…¶é¢œè‰²ã€‚å¦‚æœä½¿ç”¨æ›´åŠ å½¢è±¡çš„ä¾‹å­æ¥æ¯”å–»,æ‰‹æœºå±å¹•å¯¹åº”çš„ buffer å°±å¥½åƒä¸€å—å·¨å¤§çš„æ£‹ç›˜,æ£‹ç›˜ä¸Šæœ‰ä¸Šç™¾ä¸‡ä¸ªæ ¼å­,æ¯ä¸ªæ ¼å­éƒ½æœ‰è‡ªå·±çš„é¢œè‰²,é‚£ä¹ˆä»è¿œå¤„æ•´ä½“çš„çœ‹è¿™ä¸ªæ£‹ç›˜,å°±æ˜¯æˆ‘ä»¬çœ‹æ‰‹æœºçš„æ—¶å€™æ˜¾ç¤ºçš„æ ·å­ã€‚è¿™å°±æ˜¯æ‰‹æœºå±å¹•ä¸Šå›¾ç‰‡çš„æœ¬è´¨ã€‚ é€šè¿‡æˆ‘ä»¬å¯¹ EGLã€GLSLã€OpenGL ES çš„ç†è§£,å€ŸåŠ©ä¸€å¼ å›¾ç‰‡,ä»ä¸“ä¸šçš„è§’åº¦æ¥è§£é‡Šä¸€ä¸‹æ‰‹æœºå±å¹•ä¸Šçš„å›¾ç‰‡æ˜¯å¦‚ä½•ç”Ÿæˆçš„ã€‚ é¦–å…ˆ,é€šè¿‡ EGL è·å–æ‰‹æœºå±å¹•,è¿›è€Œè·å–åˆ°æ‰‹æœºå±å¹•å¯¹åº”çš„è¿™ä¸ªæ£‹ç›˜,åŒæ—¶, åœ¨æ‰‹æœºçš„ GPU ä¸­æ ¹æ®æ‰‹æœºçš„é…ç½®ä¿¡æ¯,ç”Ÿæˆå¦å¤–ä¸€ä¸ªçš„æ£‹ç›˜å’Œä¸€ä¸ªæœ¬å­,æœ¬å­æ˜¯ç”¨äºè®°å½•è¿™ä¸ªæ£‹ç›˜åˆå§‹é¢œè‰²ç­‰ä¿¡æ¯ã€‚ ç„¶å,OpenGL ES å°±å¥½åƒç¨‹åºå‘˜çš„ç”»ç¬”,ç¨‹åºå‘˜éœ€è¦çŸ¥é“è‡ªå·±æƒ³ç”»ä»€ä¹ˆä¸œè¥¿,æ¯”å¦‚æƒ³ç”»ä¸€ä¸ªè‹¹æœ,é‚£ä¹ˆå°±éœ€è¦é€šè¿‡ä¸ºæ•°ä¸å¤šçš„åŸºæœ¬å‡ ä½•å›¾å…ƒ(å¦‚ç‚¹ã€ç›´çº¿ã€ä¸‰ è§’å½¢)æ¥åˆ›å»ºæ‰€éœ€è¦çš„æ¨¡å‹ã€‚æ¯”å¦‚ç”¨å‡ ä¸ªä¸‰è§’å½¢å’Œç‚¹å’Œçº¿æ¥è¿‘ä¼¼çš„ç»„æˆè¿™ä¸ªè‹¹æœ (å›¾å½¢å­¦çš„æ ¹æœ¬å°±æ˜¯ç‚¹ã€çº¿å’Œä¸‰è§’å½¢,æ‰€æœ‰çš„å›¾å½¢,éƒ½å¯ä»¥ç”±è¿™äº›åŸºæœ¬å›¾å½¢ç»„æˆ, æ¯”å¦‚æ­£æ–¹å½¢æˆ–è€…é•¿æ–¹å½¢,å°±å¯ä»¥ç”±ä¸¤ä¸ªä¸‰è§’å½¢ç»„æˆ,åœ†å½¢å¯ä»¥ç”±æ— æ•°ä¸ªä¸‰è§’å½¢ç»„æˆ,åªæ˜¯ä¸‰è§’å½¢çš„æ•°é‡è¶Šå¤š,åœ†å½¢çœ‹ä¸Šå»è¶Šåœ†æ¶¦)ã€‚ æ ¹æ®è¿™äº›å‡ ä½•å›¾å…ƒ,å»ºç«‹æ•°å­¦æè¿°,æ¯”å¦‚æ¯ä¸ªä¸‰è§’å½¢æˆ–è€…çº¿çš„é¡¶ç‚¹åæ ‡ä½ç½®ã€æ¯ä¸ªé¡¶ç‚¹çš„é¢œè‰²ã€‚å¾—åˆ°è¿™äº›ä¿¡æ¯ä¹‹å,å¯ä»¥å…ˆé€šè¿‡ OpenGL ES å°† EGL ç”Ÿæˆçš„æ£‹ç›˜ (buffer)è¿›è¡Œé¢œè‰²åˆå§‹åŒ–,ä¸€èˆ¬ä¼šè¢«åˆå§‹åŒ–ä¸ºé»‘è‰²ã€‚ç„¶åå°†åˆšæ‰æˆ‘ä»¬è·å–åˆ°çš„é¡¶ç‚¹åæ ‡ä½ç½®,é€šè¿‡çŸ©é˜µå˜åŒ–çš„æ–¹å¼,è¿›è¡Œæ¨¡å‹å˜æ¢ã€è§‚å¯Ÿå˜æ¢ã€æŠ•å½±å˜æ¢,æœ€åæ˜ å°„åˆ°å±å¹•ä¸Š,å¾—åˆ°å±å¹•ä¸Šçš„åæ ‡ã€‚è¿™ä¸ªæ­¥éª¤å¯ä»¥åœ¨ CPU ä¸­å®Œæˆ,ä¹Ÿå°±æ˜¯åœ¨ OpenGL ES æŠŠåæ ‡ä¿¡æ¯ä¼ ç»™ Shader ä¹‹å‰,åœ¨ CPU ä¸­é€šè¿‡çŸ©é˜µç›¸ä¹˜ç­‰æ–¹å¼è¿›è¡Œæ›´æ–°,æˆ–è€…æ˜¯ç›´æ¥æŠŠåæ ‡ä¿¡æ¯é€šè¿‡ OpenGL ES ä¼ ç»™ Shader,åŒæ—¶ä¹ŸæŠŠçŸ©é˜µä¿¡æ¯ä¼ ç»™ Shader,é€šè¿‡ Shader åœ¨ GPU ç«¯è¿›è¡Œåæ ‡æ›´æ–°,æ›´æ–°çš„ç®—æ³•é€šè¿‡ GLSL å†™åœ¨ Shader ä¸­ã€‚è¿™ä¸ªè¿›è¡Œåæ ‡æ›´æ–°çš„ Shader è¢«ç§°ä¸º vertex shader,ç®€ç§° VS,æ˜¯ OpenGL ES2.0, ä¹Ÿæ˜¯ GLSL130 ç‰ˆæœ¬å¯¹åº”çš„æœ€é‡è¦ä¸¤ä¸ª shader ä¹‹ä¸€,ä½œç”¨æ˜¯å®Œæˆé¡¶ç‚¹æ“ä½œé˜¶æ®µä¸­çš„æ‰€æœ‰æ“ä½œã€‚ç»è¿‡çŸ©é˜µå˜æ¢åçš„åƒç´ åæ ‡ä¿¡æ¯,ä¸ºå±å¹•åæ ‡ç³»ä¸­çš„åæ ‡ä¿¡æ¯ã€‚åœ¨ VS ä¸­,æœ€é‡è¦çš„è¾“å…¥ä¸ºé¡¶ç‚¹åæ ‡ã€çŸ©é˜µ(è¿˜å¯ä»¥ä¼ å…¥é¡¶ç‚¹çš„é¢œè‰²ã€æ³•çº¿ã€çº¹ç† åæ ‡ç­‰ä¿¡æ¯),è€Œæœ€é‡è¦çš„è¿ç®—ç»“æœ,å°±æ˜¯è¿™ä¸ªå°†è¦æ˜¾ç¤ºåœ¨å±å¹•ä¸Šçš„åæ ‡ä¿¡æ¯ã€‚ VS ä¼šé’ˆå¯¹ä¼ å…¥çš„æ‰€æœ‰é¡¶ç‚¹è¿›è¡Œè¿ç®—,æ¯”å¦‚åœ¨ OpenGL ES ä¸­åªæƒ³ç»˜åˆ¶ä¸€ä¸ªä¸‰è§’å½¢ å’Œä¸€æ¡çº¿,è¿™ä¸¤ä¸ªå›¾å…ƒä¸å…±äº«é¡¶ç‚¹,é‚£ä¹ˆåœ¨ VS ä¸­,ä¹Ÿå°±ä¼ å…¥äº† 5 ä¸ªé¡¶ç‚¹ä¿¡æ¯, æ ¹æ®çŸ©é˜µå˜æ¢,è¿™ 5 ä¸ªé¡¶ç‚¹çš„åæ ‡è½¬æ¢æˆäº†å±å¹•ä¸Šçš„é¡¶ç‚¹åæ ‡ä¿¡æ¯,ä»å›¾ä¸Šæ˜¾ç¤º, ä¹Ÿå°±æ˜¯ä»å·¦ä¸Šè§’çš„å›¾ä¸€,æ›´æ–°æˆäº†ä¸­ä¸Šå›¾çš„å›¾äºŒã€‚ å†ç„¶å,å½“å›¾äºŒç”Ÿæˆä¹‹å,æˆ‘ä»¬çŸ¥é“äº†å›¾å…ƒåœ¨å±å¹•ä¸Šçš„é¡¶ç‚¹ä½ç½®,è€Œé¡¶ç‚¹çš„é¢œè‰²åœ¨ VS ä¸­æ²¡æœ‰å‘ç”Ÿå˜åŒ–,æ‰€ä»¥å›¾å…ƒçš„é¡¶ç‚¹é¢œè‰²æˆ‘ä»¬ä¹Ÿæ˜¯çŸ¥é“çš„ã€‚ä¸‹é¢å°±æ˜¯æ ¹æ® OpenGL ES ä¸­è®¾ç½®çš„çŠ¶æ€,è¡¨æ˜å“ªäº›ç‚¹è¿æˆçº¿,å“ªäº›ç‚¹ç»„æˆä¸‰è§’å½¢,è¿›è¡Œå›¾å…ƒè£…é…,ä¹Ÿå°±æ˜¯æˆ‘ä»¬åœ¨å³ä¸Šè§’çš„å›¾ä¸‰ä¸­çœ‹åˆ°çš„æ ·å­ã€‚è¿™ä¸ªæ ·å­åœ¨ GPU ä¸­ä¸ä¼šæ˜¾ç¤º, é‚£å‡ æ¡çº¿ä¹Ÿæ˜¯è™šæ‹Ÿçš„çº¿,æ˜¯ä¸ä¼šæ˜¾ç¤ºåœ¨æ£‹ç›˜ buffer ä¸­çš„,è€Œ GPU åšçš„æ˜¯å…‰çŠåŒ–,è¿™ä¸€æ­¥æ˜¯å‘ç”Ÿåœ¨ä» VS å‡ºæ¥,è¿›å…¥å¦å¤–ä¸€ä¸ªShader (Pixel shader,ä¹Ÿç§° fragment shader)ä¹‹å‰,åœ¨ GPU ä¸­è¿›è¡Œçš„ã€‚ä½œç”¨æ˜¯æŠŠçº¿ä¸Š,æˆ–è€…ä¸‰è§’å½¢å†…éƒ¨æ‰€æœ‰çš„åƒç´ ç‚¹æ‰¾åˆ°,å¹¶æ ¹æ®æ’å€¼æˆ–è€…å…¶ä»–æ–¹å¼è®¡ç®—å‡ºå…¶é¢œè‰²ç­‰ä¿¡æ¯(å¦‚æœä¸é€šè¿‡æ’å€¼,å¯ä»¥ä½¿ç”¨å…¶ä»–çš„æ–¹æ³•,è¿™äº›åœ¨ OpenGL ES å’Œ GLSL ä¸­éƒ½å¯ä»¥è¿›è¡Œè®¾ç½®)ã€‚ä¹Ÿå°±ç”Ÿæˆäº†ä¸‹é¢ä¸€è¡Œçš„å›¾å››å’Œå›¾äº”ã€‚ æˆ‘ä»¬å¤§æ¦‚å¯ä»¥çœ‹åˆ°åœ¨å›¾ 4 å’Œå›¾ 5 ç§å‡ºç°äº†å¤§é‡çš„é¡¶ç‚¹,å¤§æ¦‚æ•°ä¸€ä¸‹ä¼°è®¡æœ‰ 40 ä¸ªç‚¹å·¦å³,è¿™äº›ç‚¹å…¨éƒ¨éƒ½ä¼šè¿›å…¥ PS è¿›è¡Œæ“ä½œ,åœ¨ PS ä¸­å¯ä»¥å¯¹è¿™äº›ç‚¹çš„é¢œè‰²è¿›è¡Œæ“ä½œ,æ¯”å¦‚å¯ä»¥åªæ˜¾ç¤ºè¿™äº›ç‚¹çš„çº¢è‰²é€šé“,å…¶ä»–çš„ç»¿è“é€šé“çš„å€¼è®¾ç½®ä¸º 0, æ¯”å¦‚ä¹‹å‰æŸä¸ªç‚¹çš„ RGB ä¸º 200,100,100ã€‚åœ¨ PS ä¸­å¯ä»¥å°†å…¶é€šè¿‡è®¡ç®—,æ›´æ–°ä¸º 200,0,0ã€‚è¿™æ ·åšçš„ç»“æœå°±æ˜¯æ‰€æ˜¾ç¤ºçš„å›¾ç‰‡å‡ä¸ºçº¢è‰²,åªæ˜¯æ·±æµ…ä¸åŒã€‚è¿™ä¹Ÿå°±å¥½åƒæˆ´ä¸Šäº†ä¸€å±‚çº¢è‰²çš„æ»¤é•œ,å…¶ä»–é¢œè‰²å‡ä¸ºæ»¤æ‰äº†ã€‚æ‰€ä»¥ç”¨ PS æ¥åšæ»¤é•œæ˜¯éå¸¸æ–¹ä¾¿çš„ã€‚å†æ¯”å¦‚,å‡å¦‚ä¸€ç›çº¢è‰²çš„ç¯ç…§åˆ°äº†è‹¹æœä¸Š,é‚£ä¹ˆæ˜¾ç¤ºå‡ºæ¥çš„é¢œè‰²å°±æ˜¯åœ¨è‹¹æœåŸæœ¬çš„é¢œè‰²åŸºç¡€ä¸Š,çº¢è‰²å€¼è¿›è¡Œä¸€å®šçš„å¢å€¼ã€‚ æ‰€ä»¥,æ€»ç»“ä¸€ä¸‹,ç»è¿‡ VS å’Œ PS ä¹‹å,ç¨‹åºå‘˜æƒ³è¦ç”»çš„ä¸œè¥¿,å°±å·²ç»è¢«ç”»å‡ºæ¥äº†ã€‚æƒ³è¦ç»˜åˆ¶çš„ä¸œè¥¿,ä¹Ÿå°±æ˜¯å·¦ä¸‹è§’å›¾äº”çš„æ ·å­ã€‚ç„¶åå†æ ¹æ® OpenGL ES çš„è®¾ç½®,å¯¹æ–°ç»˜åˆ¶å‡ºæ¥çš„ä¸œè¥¿è¿›è¡Œ Depth/Stencil Test,å‰”é™¤æ‰è¢«é®æŒ¡çš„éƒ¨åˆ†,å°†å‰©ä½™éƒ¨åˆ†ä¸åŸå›¾ç‰‡è¿›è¡Œ Blend,ç”Ÿæˆæ–°çš„å›¾ç‰‡ã€‚ æœ€å,é€šè¿‡ EGL,æŠŠè¿™ä¸ªç”Ÿæˆçš„æ£‹ç›˜ buffer å’Œæ‰‹æœºå±å¹•ä¸Šå¯¹åº”çš„æ£‹ç›˜ buffer è¿›è¡Œè°ƒæ¢,è®©æ‰‹æœºå±å¹•æ˜¾ç¤ºè¿™ä¸ªæ–°ç”Ÿæˆçš„æ£‹ç›˜,æ—§çš„é‚£ä¸ªæ£‹ç›˜å†å»ç»˜åˆ¶æ–°çš„å›¾ç‰‡ä¿¡æ¯ã€‚å‘¨è€Œå¤å§‹,ä¸åœçš„æŠŠæ£‹ç›˜è¿›è¡Œåˆ‡æ¢,ä¹Ÿå°±åƒè¿‡å»çœ‹è¿ç¯ç”»ä¸€æ ·,åŠ¨ç”»å°±æ˜¯ç”±ä¸€å¹…å¹…çš„å›¾ç‰‡ç»„æˆ,å½“æ¯ç§’åˆ‡æ¢çš„å›¾ç‰‡æ•°é‡è¶…è¿‡ 30 å¼ çš„æ—¶å€™,æˆ‘ä»¬çš„æ‰‹æœºä¹Ÿå°±çœ‹åˆ°äº†åŠ¨æ€çš„æ•ˆæœã€‚è¿™å°±æ˜¯å±å¹•ä¸Šå›¾ç‰‡çš„äº§ç”Ÿè¿‡ç¨‹ã€‚ åœ¨è¿™é‡Œå†è¿›è¡Œä¸€ä¸‹å»¶ä¼¸,è¿™ä¸ªä¾‹å­ä¸­,VS è®¡ç®—äº† 5 ä¸ªé¡¶ç‚¹çš„æ•°æ®,PS è®¡ç®— äº†å¤§æ¦‚ 40 ä¸ªé¡¶ç‚¹çš„æ•°æ®,è€Œæˆ‘ä»¬åˆšæ‰è¯´è¿‡,æ‰‹æœºä¸­å­˜åœ¨ä¸Šç™¾ä¸‡ä¸ªåƒç´ ç‚¹,è¿™ä¸Šç™¾ä¸‡ä¸ªåƒç´ ç‚¹éƒ½å¯ä»¥æ˜¯é¡¶ç‚¹,é‚£ä¹ˆè¿™ä¸ªè®¡ç®—é‡æ˜¯éå¸¸å¤§çš„ã€‚è€Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦å°† shader è¿ç®—æ”¾åœ¨ GPU ä¸­çš„åŸå› ,å› ä¸º GPU æ“…é•¿è¿›è¡Œè¿™ç§è¿ç®—ã€‚ æˆ‘ä»¬çŸ¥é“ CPU ç°åœ¨ä¸€èˆ¬éƒ½æ˜¯åŒæ ¸æˆ–è€… 4 æ ¸,å¤šçš„ä¹Ÿå°±æ˜¯ 8 æ ¸æˆ–è€… 16 æ ¸,ä½†æ˜¯ GPU åŠ¨è¾„å°±æ˜¯ 72 æ ¸,å¤šçš„è¿˜æœ‰ä¸Šåƒæ ¸,è¿™ä¹ˆå¤šæ ¸çš„ç›®çš„å°±æ˜¯è¿›è¡Œå¹¶è¡Œè¿ç®—, è™½ç„¶å•ä¸ªçš„ GPU æ ¸ä¸å¦‚ CPU æ ¸,ä½†æ˜¯å•ä¸ªçš„ GPU æ ¸è¶³å¤Ÿè¿›è¡ŒåŠ å‡ä¹˜é™¤è¿ç®—,æ‰€ä»¥å¤§é‡çš„ GPU æ ¸ç”¨åœ¨å›¾å½¢å­¦åƒç´ ç‚¹è¿ç®—ä¸Š,æ˜¯éå¸¸æœ‰æ•ˆçš„ã€‚è€Œ CPU è™½ç„¶å•ä¸ªå¾ˆå¼ºå¤§,è€Œä¸”ä¹Ÿå¯ä»¥é€šè¿‡å¤šçº§æµæ°´æ¥æé«˜ååç‡,ä½†æ˜¯ç»ˆç©¶è¿˜æ˜¯ä¸å¦‚ GPU çš„å¤šæ ¸æ¥å¾—å¿«ã€‚ä½†æ˜¯åœ¨é€šè¿‡ GPU è¿›è¡Œå¤šæ ¸è¿ç®—çš„æ—¶å€™,éœ€è¦æ³¨æ„çš„æ˜¯:å¦‚æœ shader ä¸­å­˜æ”¾åˆ¤æ–­è¯­å¥,å°±ä¼šå¯¹ GPU é€ æˆæ¯”è¾ƒå¤§çš„è´Ÿè·,ä¸åŒ GPU çš„å®ç°æ–¹å¼ä¸åŒ,å¤šæ•° GPU ä¼šå¯¹åˆ¤æ–­è¯­å¥çš„ä¸¤ç§æƒ…å†µéƒ½è¿›è¡Œè¿ç®—,ç„¶åæ ¹æ®åˆ¤æ–­ç»“æœå–å…¶ä¸­ä¸€ä¸ªã€‚ æˆ‘ä»¬é€šè¿‡è¿™ä¸ªä¾‹å­å†æ¬¡æ¸…æ¥šäº† OpenGL ES ç»˜åˆ¶çš„æ•´ä¸ªæµç¨‹,è€Œè¿™ä¸ªä¾‹å­ä¹Ÿæ˜¯æœ€ç®€å•çš„ä¸€ä¸ªä¾‹å­,å…¶ä¸­æœ‰å¾ˆå¤š OpenGL ES çš„å…¶ä»–æ“ä½œæ²¡æœ‰è¢«æ¶‰åŠåˆ°ã€‚æ¯”å¦‚,æˆ‘ä»¬ç»˜åˆ¶ç‰©ä½“çš„é¢œè‰²å¤§å¤šæ˜¯ä»çº¹ç†ä¸­é‡‡æ ·å‡ºæ¥,é‚£ä¹ˆè®¾è®¡åˆ°é€šè¿‡ OpenGL ES å¯¹çº¹ç† è¿›è¡Œæ“ä½œã€‚è€Œ OpenGL ES çš„è¿™äº›åŠŸèƒ½,æˆ‘ä»¬ä¼šåœ¨ä¸‹é¢ä¸€ç‚¹ä¸€ç‚¹è¿›è¡Œå­¦ä¹ ã€‚ 2.4.2ã€OpenGL æµæ°´çº¿ï¼ˆpipelineï¼‰ EGL æ˜¯ç”¨äºä¸æ‰‹æœºè®¾å¤‡æ‰“äº¤é“,æ¯”å¦‚è·å–ç»˜åˆ¶ buffer,å°†ç»˜åˆ¶ buffer å±•ç°åˆ°æ‰‹æœºå±å¹•ä¸­ã€‚é‚£ä¹ˆæŠ›å¼€ EGL ä¸è¯´,OpenGL ES ä¸ GLSL çš„ä¸»è¦åŠŸèƒ½,å°±æ˜¯å¾€è¿™å— buffer ä¸Šç»˜åˆ¶å›¾ç‰‡ã€‚ æ‰€ä»¥,æˆ‘ä»¬å¯ä»¥æŠŠOpenGL ESå’ŒGLSLçš„æµç¨‹å•ç‹¬æ‹¿å‡ºæ¥è¿›è¡Œå½’çº³æ€»ç»“,è€Œè¿™å¹…æµç¨‹å›¾å°±æ˜¯è‘—åçš„ OpenGL ES2.0 pipelineã€‚ é¦–å…ˆ,æœ€å·¦è¾¹çš„ API æŒ‡çš„å°±æ˜¯ OpenGL ES çš„ API,OpenGL ES å…¶å®æ˜¯ä¸€ä¸ªå›¾å½¢å­¦åº“,ç”± 109 ä¸ª API ç»„æˆ,åªè¦æ˜ç™½äº†è¿™ 109 ä¸ª API çš„æ„ä¹‰å’Œç”¨é€”,å°±æŒæ¡äº†OpenGL ES 2.0ã€‚ ç„¶å,æˆ‘ä»¬é€šè¿‡ API å…ˆè®¾å®šäº†é¡¶ç‚¹çš„ä¿¡æ¯,é¡¶ç‚¹çš„åæ ‡ã€ç´¢å¼•ã€é¢œè‰²ç­‰ä¿¡æ¯,å°†è¿™äº›ä¿¡æ¯ä¼ å…¥ VSã€‚ åœ¨ VS ä¸­è¿›è¡Œè¿ç®—,å¾—åˆ°æœ€ç»ˆçš„é¡¶ç‚¹åæ ‡ã€‚å†æŠŠç®—å‡ºæ¥çš„é¡¶ç‚¹åæ ‡è¿›è¡Œå›¾å…ƒè£…é…,æ„å»ºæˆè™šæ‹Ÿçš„çº¿å’Œä¸‰è§’å½¢ã€‚å†è¿›è¡Œå…‰çŠåŒ–(åœ¨å…‰çŠåŒ–çš„æ—¶å€™,æŠŠé¡¶ç‚¹è¿æ¥èµ·æ¥å½¢æˆç›´çº¿,æˆ–è€…å¡«å……å¤šè¾¹å½¢çš„æ—¶å€™,éœ€è¦è€ƒè™‘ç›´çº¿å’Œå¤šè¾¹å½¢çš„ç›´çº¿å®½åº¦ã€ç‚¹çš„å¤§å°ã€æ¸å˜ç®—æ³•ä»¥åŠæ˜¯å¦ä½¿ç”¨æ”¯æŒæŠ—é”¯é½¿å¤„ç†çš„è¦†ç›–ç®—æ³•ã€‚æœ€ç»ˆçš„æ¯ä¸ªåƒç´ ç‚¹,éƒ½å…·æœ‰å„è‡ªçš„é¢œè‰²å’Œæ·±åº¦å€¼)ã€‚ å°†å…‰çŠåŒ–çš„ç»“æœä¼ å…¥ PS,è¿›è¡Œæœ€ç»ˆçš„é¢œè‰²è®¡ç®—ã€‚ ç„¶å,è¿™æ‰€è°“æœ€ç»ˆçš„ç»“æœåœ¨è¢«å®é™…å­˜å‚¨åˆ°ç»˜åˆ¶ buffer ä¹‹å‰,è¿˜éœ€è¦è¿›è¡Œä¸€ç³»åˆ—çš„æ“ä½œã€‚è¿™äº›æ“ä½œå¯èƒ½ä¼šä¿®æ”¹ç”šè‡³ä¸¢å¼ƒè¿™äº›åƒç´ ç‚¹ã€‚ è¿™äº›æ“ä½œä¸»è¦ä¸º alpha testã€Depth/Stencil testã€Blendã€Ditherã€‚ Alpha Test é‡‡ç”¨ä¸€ç§å¾ˆéœ¸é“æç«¯çš„æœºåˆ¶,åªè¦ä¸€ä¸ªåƒç´ çš„ alpha ä¸æ»¡è¶³æ¡ä»¶, é‚£ä¹ˆå®ƒå°±ä¼šè¢« fragment shader èˆå¼ƒ,è¢«èˆå¼ƒçš„ fragments ä¸ä¼šå¯¹åé¢çš„å„ç§ Tests äº§ç”Ÿå½±å“;å¦åˆ™,å°±ä¼šæŒ‰æ­£å¸¸æ–¹å¼ç»§ç»­ä¸‹é¢çš„æ£€éªŒã€‚Alpha Test äº§ç”Ÿçš„æ•ˆæœä¹Ÿå¾ˆæç«¯,è¦ä¹ˆå®Œå…¨é€æ˜,å³çœ‹ä¸åˆ°,è¦ä¹ˆå®Œå…¨ä¸é€æ˜ã€‚ Depth/stencil test æ¯”è¾ƒå®¹æ˜“ç†è§£ã€‚ç”±äºæˆ‘ä»¬ç»˜åˆ¶çš„æ˜¯ 3D å›¾å½¢,é‚£ä¹ˆåæ ‡ä¸º XYZ,è€Œ Z ä¸€èˆ¬å°±æ˜¯æ·±åº¦å€¼,OpenGL ES å¯ä»¥å¯¹æ·±åº¦æµ‹è¯•è¿›è¡Œè®¾å®š,æ¯”å¦‚è®¾å®šæ·±åº¦å€¼å¤§çš„è¢«æŠ›å¼ƒ,é‚£ä¹ˆå‡å¦‚ç»˜åˆ¶ buffer ä¸ŠæŸä¸ªåƒç´ ç‚¹çš„æ·±åº¦å€¼ä¸º 0,è€Œ PS è¾“å‡ºçš„ åƒç´ ç‚¹çš„æ·±åº¦å€¼ä¸º 1,é‚£ä¹ˆ PS è¾“å‡ºçš„åƒç´ ç‚¹å°±è¢«æŠ›å¼ƒäº†ã€‚è€Œ stencil æµ‹è¯•æ›´åŠ ç®€å•,å…¶åˆè¢«ç§°ä¸ºè’™ç‰ˆæµ‹è¯•,æ¯”å¦‚å¯ä»¥é€šè¿‡ OpenGL ES è®¾å®šä¸åŒ stencil å€¼çš„é…æŠ›å¼ƒ, é‚£ä¹ˆå‡å¦‚ç»˜åˆ¶ buffer ä¸ŠæŸä¸ªåƒç´ ç‚¹çš„ stencil å€¼ä¸º 0,è€Œ PS è¾“å‡ºçš„åƒç´ ç‚¹çš„ stencil å€¼ä¸º 1,é‚£ä¹ˆ PS è¾“å‡ºçš„åƒç´ ç‚¹å°±è¢«æŠ›å¼ƒäº†ã€‚ æ—¢ç„¶è¯´åˆ°äº† Depth/stencil,é‚£ä¹ˆå°±åœ¨è¿™é‡Œè¯´ä¸€ä¸‹ç»˜åˆ¶ buffer åˆ°åº•æœ‰å¤šå¤§,å­˜ å‚¨äº†å¤šå°‘ä¿¡æ¯ã€‚æŒ‰ç…§æˆ‘ä»¬åˆšæ‰çš„è¯´æ³•,æ‰‹æœºå¯ä»¥æ”¯æŒä¸€ç™¾ä¸‡ä¸ªåƒç´ ,é‚£ä¹ˆç”Ÿæˆçš„ ç»˜åˆ¶ buffer å°±éœ€è¦å­˜å‚¨è¿™ä¸€ç™¾ä¸‡ä¸ªåƒç´ æ‰€åŒ…å«çš„ä¿¡æ¯,è€Œæ¯ä¸ªåƒç´ åŒ…å«çš„ä¿¡æ¯, ä¸æ‰‹æœºé…ç½®æœ‰å…³,å‡å¦‚æ‰‹æœºæ”¯æŒ Depth/stencilã€‚é‚£ä¹ˆé€šè¿‡ EGL è·å–çš„ç»˜åˆ¶ buffer ä¸­,æ¯ä¸ªåƒç´ ç‚¹å°±åŒ…å«äº† RGBA çš„é¢œè‰²å€¼,depth å€¼å’Œ stencil å€¼,å…¶ä¸­ RGBA æ¯ä¸ªåˆ†é‡ä¸€èˆ¬å æ® 8 ä½,ä¹Ÿå°±æ˜¯ 8bit,ä¹Ÿå°±æ˜¯ 1byte,è€Œ depth å¤§å¤šæ•°å  24 ä½,stencil å  8 ä½ã€‚æ‰€ä»¥æ¯ä¸ªåƒç´ å  64bit,ä¹Ÿå°±æ˜¯ 8byteã€‚é‚£ä¹ˆ iphone6 plus çš„ç»˜åˆ¶ buffer çš„å°ºå¯¸ä¸º 1920Ã—1080Ã—8=16588800byte=16200KB=15.8MBã€‚ ä¸‹é¢è¿˜æœ‰ blend,é€šè¿‡ OpenGL ES å¯ä»¥è®¾ç½® blend æ··åˆæ¨¡å¼ã€‚ç”±äºç»˜åˆ¶ buffer ä¸­åŸæœ¬æ¯ä¸ªåƒç´ ç‚¹å·²ç»æœ‰é¢œè‰²äº†,é‚£ä¹ˆ PS è¾“å‡ºçš„é¢œè‰²ä¸ç»˜åˆ¶ buffer ä¸­çš„é¢œè‰²å¦‚ä½•æ··åˆ,ç”Ÿæˆæ–°çš„é¢œè‰²å­˜å‚¨åœ¨ç»˜åˆ¶ buffer ä¸­,å°±æ˜¯é€šè¿‡ blend æ¥è¿›è¡Œè®¾å®šã€‚ æœ€åçš„ dither,dither æ˜¯ä¸€ç§å›¾åƒå¤„ç†æŠ€æœ¯,æ˜¯æ•…æ„é€ æˆçš„å™ªéŸ³,ç”¨ä»¥éšæœºåŒ–é‡åŒ–è¯¯å·®,é˜»æ­¢å¤§å¹…åº¦æ‹‰å‡å›¾åƒæ—¶,å¯¼è‡´çš„åƒ banding(è‰²å¸¦)è¿™æ ·çš„é—®é¢˜ã€‚ä¹Ÿ æ˜¯é€šè¿‡OpenGL ES å¯ä»¥å¼€å¯æˆ–è€…å…³é—­ã€‚ ç»è¿‡äº†è¿™ä¸€ç³»åˆ—çš„è¿ç®—å’Œæµ‹è¯•,ä¹Ÿå°±å¾—åˆ°äº†æœ€ç»ˆçš„åƒç´ ç‚¹ä¿¡æ¯,å°†å…¶å­˜å‚¨åˆ°ç»˜åˆ¶ buffer ä¸Šä¹‹å,OpenGL ES çš„ pipeline ä¹Ÿå°±ç»“æŸäº†ã€‚ æ•´ä¸ªpipelineä¸­ï¼Œçºµå‘æŒ‰ç…§æµæ°´çº¿ä½œä¸šï¼Œæ¨ªçº¿æŒ‰ç…§ç‹¬ç«‹ä½œä¸šï¼Œå¤šçº§å¹¶è¡Œã€æé«˜æ¸²æŸ“æ€§èƒ½ ####ï¼ˆä¸‰ï¼‰ã€ Android EGL Overviewï¼š OpenGL ES å’Œ EGL ä»‹ç» 3.1.0ã€OpenGL ESOpenGL ESï¼ˆOpenGL for Embedded Systemsï¼‰æ˜¯ OpenGL ä¸‰ç»´å›¾å½¢APIçš„å­é›†ï¼Œé’ˆå¯¹æ‰‹æœºã€PDAå’Œæ¸¸æˆä¸»æœºç­‰åµŒå…¥å¼è®¾å¤‡è€Œè®¾è®¡ï¼Œå„æ˜¾å¡åˆ¶é€ å•†å’Œç³»ç»Ÿåˆ¶é€ å•†æ¥å®ç°è¿™ç»„ APIã€‚ 3.1.1ã€OpenGL åŸºæœ¬æ¦‚å¿µOpenGL çš„ç»“æ„å¯ä»¥ä»é€»è¾‘ä¸Šåˆ’åˆ†ä¸ºä¸‹é¢ 3 ä¸ªéƒ¨åˆ†ï¼š â˜¯ å›¾å…ƒï¼ˆPrimitivesï¼‰â˜¯ ç¼“å†²åŒºï¼ˆBuffersï¼‰â˜¯ å…‰æ …åŒ–ï¼ˆRasterizeï¼‰ å›¾å…ƒï¼ˆPrimitivesï¼‰åœ¨ OpenGL çš„ä¸–ç•Œé‡Œï¼Œæˆ‘ä»¬åªèƒ½ç”»ç‚¹ã€çº¿ã€ä¸‰è§’å½¢è¿™ä¸‰ç§åŸºæœ¬å›¾å½¢ï¼Œè€Œå…¶å®ƒå¤æ‚çš„å›¾å½¢éƒ½å¯ä»¥é€šè¿‡ä¸‰è§’å½¢æ¥ç»„æˆã€‚æ‰€ä»¥è¿™é‡Œçš„å›¾å…ƒæŒ‡çš„å°±æ˜¯è¿™ä¸‰ç§åŸºç¡€å›¾å½¢ï¼š â˜¯ ç‚¹ï¼šç‚¹å­˜åœ¨äºä¸‰ç»´ç©ºé—´ï¼Œåæ ‡ç”¨ï¼ˆx,y,zï¼‰è¡¨ç¤ºã€‚â˜¯ çº¿ï¼šç”±ä¸¤ä¸ªä¸‰ç»´ç©ºé—´ä¸­çš„ç‚¹ç»„æˆã€‚â˜¯ ä¸‰è§’å½¢ï¼šç”±ä¸‰ä¸ªä¸‰ç»´ç©ºé—´çš„ç‚¹ç»„æˆã€‚ç¼“å†²åŒºï¼ˆBuffersï¼‰OpenGL ä¸­ä¸»è¦æœ‰ 3 ç§ Bufferï¼š å¸§ç¼“å†²åŒºï¼ˆFrame Buffersï¼‰ å¸§ç¼“å†²åŒºï¼šè¿™ä¸ªæ˜¯å­˜å‚¨OpenGL æœ€ç»ˆæ¸²æŸ“è¾“å‡ºç»“æœçš„åœ°æ–¹ï¼Œå®ƒæ˜¯ä¸€ä¸ªåŒ…å«å¤šä¸ªå›¾åƒçš„é›†åˆï¼Œä¾‹å¦‚é¢œè‰²å›¾åƒã€æ·±åº¦å›¾åƒã€æ¨¡æ¿å›¾åƒç­‰ã€‚ æ¸²æŸ“ç¼“å†²åŒºï¼ˆRender Buffersï¼‰ æ¸²æŸ“ç¼“å†²åŒºï¼šæ¸²æŸ“ç¼“å†²åŒºå°±æ˜¯ä¸€ä¸ªå›¾åƒï¼Œå®ƒæ˜¯ Frame Buffer çš„ä¸€ä¸ªå­é›†ã€‚ ç¼“å†²åŒºå¯¹è±¡ï¼ˆBuffer Objectsï¼‰ ç¼“å†²åŒºå¯¹è±¡å°±æ˜¯ç¨‹åºå‘˜è¾“å…¥åˆ° OpenGL çš„æ•°æ®ï¼Œåˆ†ä¸ºç»“æ„ç±»å’Œç´¢å¼•ç±»çš„ã€‚å‰è€…è¢«ç§°ä¸ºâ€œæ•°ç»„ç¼“å†²åŒºå¯¹è±¡â€æˆ–â€œé¡¶ç‚¹ç¼“å†²åŒºå¯¹è±¡â€ï¼ˆâ€œArray Buffer Objectâ€æˆ–â€œVertex Buff er Objectâ€ï¼‰ï¼Œå³ç”¨æ¥æè¿°æ¨¡å‹çš„æ•°ç»„ï¼Œå¦‚é¡¶ç‚¹æ•°ç»„ã€çº¹ç†æ•°ç»„ç­‰ï¼› åè€…è¢«ç§°ä¸ºâ€œç´¢å¼•ç¼“å†²åŒºå¯¹è±¡â€ï¼ˆâ€œIndex Buffer Objectâ€ï¼‰ï¼Œæ˜¯å¯¹ä¸Šè¿°æ•°ç»„çš„ç´¢å¼•ã€‚ å…‰æ …åŒ–ï¼ˆRasterizeï¼‰åœ¨ä»‹ç»å…‰æ …åŒ–ä¹‹å‰ï¼Œé¦–å…ˆæ¥è¡¥å…… OpenGL ä¸­çš„ä¸¤ä¸ªéå¸¸é‡è¦çš„æ¦‚å¿µï¼š Vertex Vertex å°±æ˜¯å›¾å½¢ä¸­é¡¶ç‚¹ï¼Œä¸€ç³»åˆ—çš„é¡¶ç‚¹å°±å›´æˆäº†ä¸€ä¸ªå›¾å½¢ã€‚Fragment Fragment æ˜¯ä¸‰ç»´ç©ºé—´çš„ç‚¹ã€çº¿ã€ä¸‰è§’å½¢è¿™äº›åŸºæœ¬å›¾å…ƒæ˜ å°„åˆ°äºŒç»´å¹³é¢ä¸Šçš„æ˜ å°„åŒºåŸŸï¼Œé€šå¸¸ä¸€ä¸ª Fragment å¯¹åº”äºå±å¹•ä¸Šçš„ä¸€ä¸ªåƒç´ ï¼Œä½†é«˜åˆ†è¾¨ç‡çš„å±å¹•å¯èƒ½ä¼šç”¨å¤šä¸ªåƒç´ ç‚¹æ˜ å°„åˆ°ä¸€ä¸ª Fragmentï¼Œä»¥å‡å°‘ GPU çš„å·¥ä½œã€‚è€Œå…‰æ …åŒ–æ˜¯æŠŠç‚¹ã€çº¿ã€ä¸‰è§’å½¢æ˜ å°„åˆ°å±å¹•ä¸Šçš„åƒç´ ç‚¹çš„è¿‡ç¨‹ã€‚ ç€è‰²å™¨ç¨‹åºï¼ˆShaderï¼‰Shader ç”¨æ¥æè¿°å¦‚ä½•ç»˜åˆ¶ï¼ˆæ¸²æŸ“ï¼‰ï¼ŒGLSL æ˜¯ OpenGL çš„ç¼–ç¨‹è¯­è¨€ï¼Œå…¨ç§° OpenGL Shader Languageï¼Œå®ƒçš„è¯­æ³•ç±»ä¼¼äº C è¯­è¨€ã€‚OpenGL æ¸²æŸ“éœ€è¦ä¸¤ç§ Shaderï¼šVertex Shader å’Œ Fragment Shaderã€‚ Vertex Shader Vertex Shader å¯¹äº3Dæ¨¡å‹ç½‘æ ¼çš„æ¯ä¸ªé¡¶ç‚¹æ‰§è¡Œä¸€æ¬¡ï¼Œä¸»è¦æ˜¯ç¡®å®šè¯¥é¡¶ç‚¹çš„æœ€ç»ˆä½ç½®ã€‚Fragment Shader Fragment Shaderå¯¹å…‰æ …åŒ–ä¹‹å2Då›¾åƒä¸­çš„æ¯ä¸ªåƒç´ å¤„ç†ä¸€æ¬¡ã€‚3Dç‰©ä½“çš„è¡¨é¢æœ€ç»ˆæ˜¾ç¤ºæˆä»€ä¹ˆæ ·å°†ç”±å®ƒå†³å®šï¼Œä¾‹å¦‚ä¸ºæ¨¡å‹çš„å¯è§è¡¨é¢æ·»åŠ çº¹ç†ï¼Œå¤„ç†å…‰ç…§ã€é˜´å½±çš„å½±å“ç­‰ç­‰ã€‚ 3.2ã€EGL Overview What is the Direction?SW : Standard API (Java, NDK Stable API)HW : OpenGLES, OpenSLES, OpenMAXEGLâ„¢ is an interface between Khronos rendering APIs such as OpenGL ES or OpenVG and the underlying native platform window system 3.2.1ã€ä»€ä¹ˆæ˜¯ EGLï¼ŸEGL æ˜¯ OpenGL ES æ¸²æŸ“ API å’Œæœ¬åœ°çª—å£ç³»ç»Ÿ(native platform window system)ä¹‹é—´çš„ä¸€ä¸ªä¸­é—´æ¥å£å±‚ï¼Œå®ƒä¸»è¦ç”±ç³»ç»Ÿåˆ¶é€ å•†å®ç°ã€‚ EGLæä¾›å¦‚ä¸‹æœºåˆ¶ï¼šä¸è®¾å¤‡çš„åŸç”Ÿçª—å£ç³»ç»Ÿé€šä¿¡æŸ¥è¯¢ç»˜å›¾è¡¨é¢çš„å¯ç”¨ç±»å‹å’Œé…ç½®åˆ›å»ºç»˜å›¾è¡¨é¢åœ¨OpenGL ES å’Œå…¶ä»–å›¾å½¢æ¸²æŸ“APIä¹‹é—´åŒæ­¥æ¸²æŸ“ç®¡ç†çº¹ç†è´´å›¾ç­‰æ¸²æŸ“èµ„æºä¸ºäº†è®©OpenGL ESèƒ½å¤Ÿç»˜åˆ¶åœ¨å½“å‰è®¾å¤‡ä¸Šï¼Œæˆ‘ä»¬éœ€è¦EGLä½œä¸ºOpenGL ESä¸è®¾å¤‡çš„æ¡¥æ¢ã€‚ 3.2.2ã€ä½¿ç”¨ EGL ç»˜å›¾çš„åŸºæœ¬æ­¥éª¤ â˜¯ Display(EGLDisplay) æ˜¯å¯¹å®é™…æ˜¾ç¤ºè®¾å¤‡çš„æŠ½è±¡ã€‚â˜¯ Surfaceï¼ˆEGLSurfaceï¼‰æ˜¯å¯¹ç”¨æ¥å­˜å‚¨å›¾åƒçš„å†…å­˜åŒºåŸŸâ˜¯ FrameBuffer çš„æŠ½è±¡ï¼ŒåŒ…æ‹¬ Color Bufferï¼Œ Stencil Buffer ï¼ŒDepth Bufferã€‚Context (EGLContext) å­˜å‚¨ OpenGL ESç»˜å›¾çš„ä¸€äº›çŠ¶æ€ä¿¡æ¯ã€‚ä½¿ç”¨EGLçš„ç»˜å›¾çš„ä¸€èˆ¬æ­¥éª¤ï¼š 1ã€è·å– EGL Display å¯¹è±¡ï¼šeglGetDisplay()2ã€åˆå§‹åŒ–ä¸ EGLDisplay ä¹‹é—´çš„è¿æ¥ï¼šeglInitialize()3ã€è·å– EGLConfig å¯¹è±¡ï¼šeglChooseConfig()4ã€åˆ›å»º EGLContext å®ä¾‹ï¼šeglCreateContext()5ã€åˆ›å»º EGLSurface å®ä¾‹ï¼šeglCreateWindowSurface()6ã€è¿æ¥ EGLContext å’Œ EGLSurfaceï¼šeglMakeCurrent()7ã€ä½¿ç”¨ OpenGL ES API ç»˜åˆ¶å›¾å½¢ï¼šgl_*()8ã€åˆ‡æ¢ front buffer å’Œ back buffer é€æ˜¾ï¼šeglSwapBuffer()9ã€æ–­å¼€å¹¶é‡Šæ”¾ä¸ EGLSurface å…³è”çš„ EGLContext å¯¹è±¡ï¼šeglRelease()10ã€åˆ é™¤ EGLSurface å¯¹è±¡11ã€åˆ é™¤ EGLContext å¯¹è±¡12ã€ç»ˆæ­¢ä¸ EGLDisplay ä¹‹é—´çš„è¿æ¥ 3.3ã€EGLSurface and ANativeWindow å…³ç³»OpenGL ES å®šä¹‰äº†ä¸€ä¸ªæ¸²æŸ“å›¾å½¢çš„ APIï¼Œä½†æ²¡æœ‰å®šä¹‰çª—å£ç³»ç»Ÿã€‚ä¸ºäº†è®© GLES èƒ½å¤Ÿé€‚åˆå„ç§å¹³å°ï¼ŒGLES å°†ä¸çŸ¥é“å¦‚ä½•é€šè¿‡æ“ä½œç³»ç»Ÿåˆ›å»ºå’Œè®¿é—®çª—å£çš„åº“ç»“åˆä½¿ç”¨ã€‚ç”¨äº Android çš„åº“ç§°ä¸º EGLã€‚å¦‚æœè¦ç»˜åˆ¶çº¹ç†å¤šè¾¹å½¢ï¼Œåº”ä½¿ç”¨ GLES è°ƒç”¨ï¼›å¦‚æœè¦åœ¨å±å¹•ä¸Šè¿›è¡Œæ¸²æŸ“ï¼Œåº”ä½¿ç”¨ EGL è°ƒç”¨ã€‚ åœ¨ä½¿ç”¨ GLES è¿›è¡Œä»»ä½•æ“ä½œä¹‹å‰ï¼Œéœ€è¦åˆ›å»ºä¸€ä¸ª GL ä¸Šä¸‹æ–‡ã€‚åœ¨ EGL ä¸­ï¼Œè¿™æ„å‘³ç€è¦åˆ›å»ºä¸€ä¸ª EGLContext å’Œä¸€ä¸ª EGLSurfaceã€‚GLES æ“ä½œé€‚ç”¨äºå½“å‰ä¸Šä¸‹æ–‡ï¼Œè¯¥ä¸Šä¸‹æ–‡é€šè¿‡çº¿ç¨‹å±€éƒ¨å­˜å‚¨è®¿é—®ï¼Œè€Œä¸æ˜¯ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ã€‚è¿™æ„å‘³ç€æ‚¨å¿…é¡»æ³¨æ„æ¸²æŸ“ä»£ç åœ¨å“ªä¸ªçº¿ç¨‹ä¸Šæ‰§è¡Œï¼Œä»¥åŠè¯¥çº¿ç¨‹ä¸Šçš„å½“å‰ä¸Šä¸‹æ–‡ã€‚ 3.3.1ã€EGLSurface EGLSurface å¯ä»¥æ˜¯ç”± EGL åˆ†é…çš„ç¦»å±ç¼“å†²åŒºï¼ˆç§°ä¸ºâ€œpbufferâ€ï¼‰ï¼Œæˆ–ç”±æ“ä½œç³»ç»Ÿåˆ†é…çš„çª—å£ã€‚EGL çª—å£ Surface é€šè¿‡ eglCreateWindowSurface() è°ƒç”¨è¢«åˆ›å»ºã€‚è¯¥è°ƒç”¨å°†â€œçª—å£å¯¹è±¡â€ä½œä¸ºå‚æ•°ï¼Œåœ¨ Android ä¸Šï¼Œè¯¥å¯¹è±¡å¯ä»¥æ˜¯ SurfaceViewã€SurfaceTextureã€SurfaceHolder æˆ– Surfaceï¼Œæ‰€æœ‰è¿™äº›å¯¹è±¡ä¸‹é¢éƒ½æœ‰ä¸€ä¸ª BufferQueueã€‚å½“æ‚¨è¿›è¡Œæ­¤è°ƒç”¨æ—¶ï¼ŒEGL å°†åˆ›å»ºä¸€ä¸ªæ–°çš„ EGLSurface å¯¹è±¡ï¼Œå¹¶å°†å…¶è¿æ¥åˆ°çª—å£å¯¹è±¡çš„ BufferQueue çš„ç”Ÿäº§æ–¹æ¥å£ã€‚æ­¤åï¼Œæ¸²æŸ“åˆ°è¯¥ EGLSurface ä¼šå¯¼è‡´ä¸€ä¸ªç¼“å†²åŒºç¦»å¼€é˜Ÿåˆ—ã€è¿›è¡Œæ¸²æŸ“ï¼Œç„¶åæ’é˜Ÿç­‰å¾…æ¶ˆè€—æ–¹ä½¿ç”¨ã€‚ï¼ˆæœ¯è¯­â€œçª—å£â€è¡¨ç¤ºé¢„æœŸç”¨é€”ï¼Œä½†è¯·æ³¨æ„ï¼Œè¾“å‡ºå†…å®¹ä¸ä¸€å®šä¼šæ˜¾ç¤ºåœ¨æ˜¾ç¤ºå±ä¸Šã€‚ï¼‰ EGL ä¸æä¾›é”å®š/è§£é”è°ƒç”¨ï¼Œè€Œæ˜¯ç”±æ‚¨å‘å‡ºç»˜åˆ¶å‘½ä»¤ï¼Œç„¶åè°ƒç”¨ eglSwapBuffers() æ¥æäº¤å½“å‰å¸§ã€‚æ–¹æ³•åç§°æ¥è‡ªä¼ ç»Ÿçš„å‰åç¼“å†²åŒºäº¤æ¢ï¼Œä½†å®é™…å®ç°å¯èƒ½ä¼šæœ‰å¾ˆå¤§çš„ä¸åŒã€‚ ä¸€ä¸ª Surface ä¸€æ¬¡åªèƒ½ä¸ä¸€ä¸ª EGLSurface å…³è”ï¼ˆæ‚¨åªèƒ½å°†ä¸€ä¸ªç”Ÿäº§æ–¹è¿æ¥åˆ°ä¸€ä¸ª BufferQueueï¼‰ï¼Œä½†æ˜¯å¦‚æœæ‚¨é”€æ¯è¯¥ EGLSurfaceï¼Œå®ƒå°†ä¸è¯¥ BufferQueue æ–­å¼€è¿æ¥ï¼Œå¹¶å…è®¸å…¶ä»–å†…å®¹è¿æ¥åˆ°è¯¥ BufferQueueã€‚ é€šè¿‡æ›´æ”¹â€œå½“å‰â€EGLSurfaceï¼ŒæŒ‡å®šçº¿ç¨‹å¯åœ¨å¤šä¸ª EGLSurface ä¹‹é—´è¿›è¡Œåˆ‡æ¢ã€‚ä¸€ä¸ª EGLSurface ä¸€æ¬¡åªèƒ½åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸Šå¤„äºå½“å‰çŠ¶æ€ã€‚ å…³äº EGLSurface æœ€å¸¸è§çš„ä¸€ä¸ªé”™è¯¯ç†è§£å°±æ˜¯å‡è®¾å®ƒåªæ˜¯ Surface çš„å¦ä¸€æ–¹é¢ï¼ˆå¦‚ SurfaceHolderï¼‰ã€‚å®ƒæ˜¯ä¸€ä¸ªç›¸å…³ä½†ç‹¬ç«‹çš„æ¦‚å¿µã€‚æ‚¨å¯ä»¥åœ¨æ²¡æœ‰ Surface ä½œä¸ºæ”¯æŒçš„ EGLSurface ä¸Šç»˜åˆ¶ï¼Œä¹Ÿå¯ä»¥åœ¨æ²¡æœ‰ EGL çš„æƒ…å†µä¸‹ä½¿ç”¨ Surfaceã€‚EGLSurface ä»…ä¸º GLES æä¾›ä¸€ä¸ªç»˜åˆ¶çš„åœ°æ–¹ã€‚ 3.3.2ã€ANativeWindowå…¬å¼€çš„ Surface ç±»ä»¥ Java ç¼–ç¨‹è¯­è¨€å®ç°ã€‚C/C++ ä¸­çš„åŒç­‰é¡¹æ˜¯ ANATIONWindow ç±»ï¼Œç”± Android NDK åŠå…¬å¼€ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ ANativeWindow_fromSurface() è°ƒç”¨ä» Surface è·å– ANativeWindowã€‚å°±åƒå®ƒçš„ Java è¯­è¨€åŒç­‰é¡¹ä¸€æ ·ï¼Œæ‚¨å¯ä»¥å¯¹ ANativeWindow è¿›è¡Œé”å®šã€åœ¨è½¯ä»¶ä¸­è¿›è¡Œæ¸²æŸ“ï¼Œä»¥åŠè§£é”å¹¶å‘å¸ƒã€‚ è¦ä»åŸç”Ÿä»£ç åˆ›å»º EGL çª—å£ Surfaceï¼Œå¯å°† EGLNativeWindowType çš„å®ä¾‹ä¼ é€’åˆ° eglCreateWindowSurface()ã€‚EGLNativeWindowType æ˜¯ ANativeWindow çš„åŒä¹‰è¯ï¼Œæ‚¨å¯ä»¥è‡ªç”±åœ°åœ¨å®ƒä»¬ä¹‹é—´è½¬æ¢ã€‚ åŸºæœ¬çš„â€œåŸç”Ÿçª—å£â€ç±»å‹åªæ˜¯å°è£… BufferQueue çš„ç”Ÿäº§æ–¹ï¼Œè¿™ä¸€ç‚¹å¹¶ä¸è¶³ä¸ºå¥‡ã€‚ 3.3.3ã€egl_surface_t å…³ç³»å›¾ 1234567891011121314151617181920212223242526272829303132[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]static EGLSurface createWindowSurface(EGLDisplay dpy, EGLConfig config, NativeWindowType window, const EGLint* /*attrib_list*/)&#123; ...... EGLint surfaceType; if (!(surfaceType &amp; EGL_WINDOW_BIT)) return setError(EGL_BAD_MATCH, EGL_NO_SURFACE); if (static_cast&lt;ANativeWindow*&gt;(window)-&gt;common.magic != ANDROID_NATIVE_WINDOW_MAGIC) &#123; return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE); &#125; EGLint configID; if (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE) return EGL_FALSE; int32_t depthFormat; int32_t pixelFormat; if (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123; return setError(EGL_BAD_MATCH, EGL_NO_SURFACE); &#125; ...... egl_surface_t* surface; surface = new egl_window_surface_v2_t(dpy, config, depthFormat, static_cast&lt;ANativeWindow*&gt;(window)); ...... return surface;&#125; 3.3.4ã€EGLContext and Thread Local Storage3.3.4.1ã€EGLContext 3.3.4.2ã€Thread Local Storage 3.3.5ã€EGLImplementation : HWCompser and SurfaceFlinger3.3.5.1ã€HWCompser 3.3.5.2ã€SurfaceFlinger ####ï¼ˆå››ï¼‰ã€Android EGLï¼šOpenGL ES åº“å’Œ EGL åº“åŠ è½½è¿‡ç¨‹åœ¨è¯¦ç»†åˆ†æ EGL ç»˜å›¾åŸºæœ¬æ­¥éª¤ å‰ï¼Œå…ˆæ¥çœ‹çœ‹OpenGL ES åº“å’Œ EGL åº“åŠ è½½è¿‡ç¨‹ã€‚ 4.1ã€OpenGL ES å’Œ OpenGL ES åº“çš„åŒºåˆ«OpenGL ES ï¼š å®ƒæœ¬èº«åªæ˜¯ä¸€ä¸ªåè®®è§„èŒƒï¼Œå®šä¹‰äº†ä¸€å¥—å¯ä»¥ä¾›ä¸Šå±‚åº”ç”¨ç¨‹åºè¿›è¡Œè°ƒç”¨çš„ APIï¼Œå®ƒæŠ½è±¡äº† GPU çš„åŠŸèƒ½ï¼Œä½¿åº”ç”¨å¼€å‘è€…ä¸å¿…å…³å¿ƒåº•å±‚çš„ GPU ç±»å‹å’Œå…·ä½“å®ç°ã€‚OpenGL ES åº“ï¼šOpenGL ES åº“å°±æ˜¯ä¸Šé¢ OpenGL ES ä¸­å®šä¹‰çš„ API çš„å…·ä½“å®ç°ã€‚ç”±äºæ¯ä¸ªæ˜¾å¡åˆ¶é€ å‚å•†çš„ GPU ç¡¬ä»¶ç»“æ„ä¸åŒï¼Œä»è€Œå¯¼è‡´å„ä¸ªå‚å•†çš„OpenGL ES åº“ä¹Ÿå„ä¸ç›¸åŒï¼Œæ‰€ä»¥ Android ç³»ç»Ÿä¸­çš„ OpenGL ES åº“é€šå¸¸æ˜¯ç”±ç¡¬ä»¶å‚å•†æä¾›çš„ï¼Œé€šå¸¸å­˜æ”¾åœ¨ Android ç³»ç»Ÿä¸­çš„ /system/lib64/ï¼ˆ/system/lib/ï¼‰ ã€‚OpenGL ES Wrapper åº“ï¼šOpenGL ES Wrapper åº“æ˜¯ä¸€ä¸ªå¯¹ OpenGL ES API è¿›è¡Œå°è£…çš„ä¸€ä¸ªåŒ…è£¹åº“ï¼Œå®ƒå‘ä¸Šä¸ºåº”ç”¨ç¨‹åºæä¾›äº†æ ‡å‡†çš„ OpenGL ES APIï¼Œå‘ä¸‹å¯ä»¥å’Œä¸åŒå‚å•†å®ç°çš„ OpenGL ES åº“è¿›è¡Œç»‘å®šï¼Œå°† OpenGL ES API å’Œå¯¹åº”çš„å®ç°å‡½æ•°ä¸€ä¸€ç»‘å®šåœ¨ä¸€èµ·ã€‚å¹¶ä¸”ï¼ŒOpenGL ES åº“çš„å®ç°åˆ†ä¸ºï¼šè½¯ä»¶æ¨¡æ‹Ÿå®ç°ç¡¬ä»¶åŠ é€Ÿå®ç°ç°åœ¨ï¼Œå› ä¸ºæˆ‘ä»¬ Android æ‰‹æœºä¸­çš„ Soc ç‰‡ä¸ŠèŠ¯ç‰‡ä¸­éƒ½é›†æˆäº† GPU æ¨¡å—ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨çš„å°±æ˜¯ç¡¬ä»¶åŠ é€Ÿå®ç°çš„ OpenGL ES åº“ã€‚ä½†æ˜¯ï¼Œåƒ Android Emulator ä¸­çš„ Android ç³»ç»Ÿï¼Œå¦‚æœä¸æ”¯æŒå°† OpenGL ES API æŒ‡ä»¤é‡å®šå‘åˆ°ä¸»æœºç³»ç»Ÿçš„ GPU åŠ é€Ÿæ‰§è¡Œçš„è¯ï¼Œå®ƒæ‰€é‡‡ç”¨çš„ OpenGL ES åº“å°±æ˜¯è½¯ä»¶æ¨¡æ‹Ÿå®ç°çš„ã€‚ è¡¥å……ï¼šå¦‚å‰é¢å°èŠ‚ã€OpenGL ES å’Œ EGL ä»‹ç»ã€‘ä¸­ä»‹ç»çš„ï¼ŒEGL ä¹Ÿæ˜¯ä¸€å¥— APIï¼Œå®ƒçš„å®ç°ä¹Ÿéœ€è¦ç³»ç»Ÿå‚å•†æ¥æä¾›ã€‚ç³»ç»Ÿå‚å•†é€šå¸¸ä¼šå°†è¿™ä¸¤å¥— API çš„å®ç°å°è£…åœ¨ä¸€ä¸ªå…±äº«é“¾æ¥åº“ä¸­ï¼Œä½†æ˜¯æ ¹æ®æœ€æ–°çš„æ ‡å‡†ï¼ŒOpenGL ES API å®ç°çš„å…±äº«é“¾æ¥åº“å’Œ EGL API å®ç°çš„å…±äº«é“¾æ¥åº“æ˜¯ç‹¬ç«‹åˆ†å¼€çš„ï¼Œä¾‹å¦‚ Nexus 9 å¹³æ¿è®¾å¤‡ä¸­ OpenGL ES å’Œ EGL API å®ç°åº“å°±æ˜¯ç‹¬ç«‹åˆ†å¼€çš„ã€‚ 4.2ã€Android ä¸­ OpenGL ES è½¯ä»¶å±‚æ¬¡æ ˆæŒ‰ç…§åˆ†å±‚ç†å¿µçš„è®¾è®¡ï¼ŒAndroid ä¸­çš„ OpenGL ES å®ç°ä¹Ÿæ˜¯å±‚æ¬¡è®¾è®¡çš„ï¼Œå½¢æˆä¸€ä¸ªè½¯ä»¶å±‚æ¬¡æ ˆã€‚æœ€ä¸Šé¢çš„æ˜¯ Java å±‚ï¼Œæ¥ç€ä¸‹é¢æ˜¯ JNI å±‚ï¼Œå†è°ƒç”¨ä¸‹é¢çš„ wrapper å±‚ï¼Œwrapper å±‚ä¸‹é¢åˆ™æ˜¯ OpenGL ES API çš„å…·ä½“è½¯ä»¶å®æˆ–è€…ç¡¬ä»¶å®ç°äº†ã€‚æ•´ä¸ª OpenGL è½¯ä»¶å±‚æ¬¡æ ˆçš„è°ƒç”¨å…³ç³»å¦‚ä¸‹æ‰€ç¤ºï¼š 4.3ã€OpenGL ES/EGL Wrapper åº“å‰é¢æˆ‘ä»¬å·²ç»ä»‹ç»è¿‡ OpenGL ES/EGL Wrapper åº“æ˜¯ä¸€ä¸ªå°† OpenGL ES API å’Œ OpenGL ES API å…·ä½“å®ç°ç»‘å®šåœ¨ä¸€èµ·çš„åº“ï¼Œå®ƒå¯¹åº”çš„æºç è·¯å¾„æ˜¯ï¼š/frameworks/native/opengl/libs/ï¼Œå…¶ä¸­: 123libGLESv1_CM.soï¼šOpenGL ES 1.x API çš„ Wrapper åº“libGLESv2.soï¼šOpenGL ES 2.0 çš„ Wrapper åº“libGLESv3.soï¼šOpenGL ES 3.0 çš„ Wrapper åº“ å…¶ä¸­å› ä¸º OpenGL ES 3.0 API æ˜¯å…¼å®¹ OpenGL ES 2.0 API çš„ï¼Œæ‰€ä»¥ libGLESv2.so åº“æœ¬è´¨ä¸Šå’Œ libGLESv3.so åº“æ˜¯ä¸€æ ·çš„ã€‚ 4.3.1ã€OpenGL ES/EGL å®ç°åº“å¦‚æœAndroidç³»ç»Ÿå¹³å°æ”¯æŒ OpenGL ES ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“ï¼Œé‚£ä¹ˆ OpenGL ES/EGL å®ç°åº“ç”±ç³»ç»Ÿå‚å•†ä»¥.soçš„å…±äº«é“¾æ¥åº“çš„å½¢å¼æä¾›ï¼Œä¾‹å¦‚ï¼Œé«˜é€šçš„å®ç°ï¼šsystem\\vendor\\lib\\egl 123libEGL_adreno.so libGLESv1_CM_adreno.solibGLESv2_adreno.so å¦‚æœAndroidç³»ç»Ÿå¹³å°ä¸æ”¯æŒ OpenGL ES ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šé»˜è®¤å¯ç”¨è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“ï¼Œè¿™æ—¶ OpenGL ES/EGL å®ç°åº“å°±æ˜¯ç”± AOSP æä¾›ï¼Œé“¾æ¥åº“çš„å­˜åœ¨çš„è·¯å¾„ä¸ºï¼š /system/lib64/egl/libGLES_android.soã€‚è€Œ libGLES_android.so åº“åœ¨ Android 7.1 ç³»ç»Ÿå¯¹åº”çš„å®ç°æºç è·¯å¾„ä¸ºï¼š/frameworks/native/opengl/libagl/ ã€‚ 4.3.2ã€Android 7.1 ä¸­åŠ è½½ OpenGL ES åº“çš„è¿‡ç¨‹Android ä¸­å›¾å½¢æ¸²æŸ“æ‰€é‡‡ç”¨çš„æ–¹å¼ï¼ˆç¡¬ä»¶ or è½¯ä»¶ï¼‰æ˜¯åœ¨ç³»ç»Ÿå¯åŠ¨ä¹‹ååŠ¨æ€ç¡®å®šçš„ï¼Œè€Œç¡®å®šæ¸²æŸ“æ–¹å¼çš„è¿™ä¸ªæºç æ–‡ä»¶å°±æ˜¯ /frameworks/native/opengl/libs/EGL/Loader.cpp ã€‚ 4.3.2.1ã€ Android 7.1 OpenGL ES åº“å’Œ EGL åº“åŠ è½½è¯´æ˜How Android finds OpenGL libraries, and the death of egl.cfg è¿™ç¯‡æ–‡ç« ä¸­æåˆ°äº†éå¸¸å…³é”®çš„ä¸€ç‚¹ï¼Œå°±æ˜¯ä» Android Kitkat 4.4 ä¹‹åï¼ŒAndroid ä¸­åŠ è½½ OpenGL ES/EGL åº“çš„æ–¹æ³•å‘ç”Ÿäº†å˜åŒ–äº†ï¼ˆä½†æ˜¯æ•´ä¸ªåŠ è½½è¿‡ç¨‹éƒ½æ˜¯ç”± /frameworks/native/opengl/libs/EGL/Loader.cpp ç¨‹åºæ‰€å†³å®šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ Loader.cpp æ–‡ä»¶å‘ç”Ÿäº†å˜åŒ–ï¼‰ã€‚ åœ¨ Android 4.4 ä¹‹å‰ï¼ŒåŠ è½½ OpenGL ES åº“æ˜¯ç”± /system/lib/egl/egl.cfg æ–‡ä»¶æ‰€å†³å®šçš„ï¼Œé€šè¿‡è¯»å–è¿™ä¸ªé…ç½®æ–‡ä»¶æ¥ç¡®å®šæ˜¯åŠ è½½ OpenGL ES è½¯ä»¶æ¨¡æ‹Ÿå®ç°çš„åº“ï¼Œè¿˜æ˜¯OpenGL ES ç¡¬ä»¶åŠ é€Ÿå®ç°çš„åº“ã€‚ ä½†æ˜¯ï¼Œåœ¨Android 4.4 ä¹‹åï¼ŒAndroid ä¸å†é€šè¿‡è¯»å– egl.cfg é…ç½®æ–‡ä»¶çš„æ–¹å¼æ¥åŠ è½½ OpenGL ES åº“ï¼Œæ–°çš„åŠ è½½ OpenGL ES åº“çš„è§„åˆ™ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š ä» /system/lib/egl æˆ–è€… /system/vendor/lib/egl/ ç›®å½•ä¸‹åŠ è½½ libGLES.so åº“æ–‡ä»¶æˆ–è€… libEGL_vendor.soï¼ŒlibGLESv1_CM_vendor.soï¼ŒlibGLESv2vendor.so åº“æ–‡ä»¶ã€‚ä¸ºäº†å‘ä¸‹å…¼å®¹æ—§çš„åº“çš„å‘½åæ–¹å¼ï¼ŒåŒæ ·ä¹Ÿä¼šåŠ è½½ /system/lib/egl æˆ–è€… /vendor/lib/egl/ ç›®å½•ä¸‹çš„ libGLES.so æˆ–è€… libEGL_.soï¼ŒlibGLESv1CM.soï¼ŒlibGLESv2_.so åº“æ–‡ä»¶ã€‚ 4.3.2.2ã€ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“ or è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“ï¼Ÿå‰é¢æˆ‘ä»¬æåˆ° OpenGL ES åº“çš„å®ç°æ–¹å¼æœ‰ä¸¤ç§ï¼Œä¸€ç§æ˜¯ç¡¬ä»¶åŠ é€Ÿå®ç°ï¼Œä¸€ç§æ˜¯è½¯ä»¶æ¨¡æ‹Ÿå®ç°ï¼Œé‚£ä¹ˆç³»ç»Ÿæ˜¯æ€ä¹ˆç¡®å®šåŠ è½½é‚£ä¸€ç§ OpenGL ES åº“çš„å‘¢ï¼Ÿ Android 7.1 æºç ä¸­è´Ÿè´£åŠ è½½ OpenGL ES/EGL åº“éƒ¨åˆ†çš„ä»£ç ä½äºï¼š/frameworks/native/opengl/libs/EGL/Loader.cpp æ–‡ä»¶ä¸­ï¼Œè¿™ä¸ªæ–‡ä»¶ä¸­ä»£ç çš„ä¸»è¦å…¥å£å‡½æ•°æ˜¯ Loader::open() å‡½æ•°ï¼Œè€Œå†³å®šåŠ è½½ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“åº“è¿˜æ˜¯è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“åº“ä¸»è¦æ¶‰åŠåˆ°ä¸‹é¢ä¸¤ä¸ªå‡½æ•°ï¼š 12setEmulatorGlesValue()checkGlesEmulationStatus() ä¸‹é¢å°±æ¥ç®€è¦çš„åˆ†æä¸€ä¸‹ Android ç³»ç»Ÿæ˜¯å¦‚ä½•é€‰æ‹©åŠ è½½ç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“åº“è¿˜æ˜¯è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“åº“ï¼š é¦–å…ˆï¼ŒLoader::open() å…¥å£å‡½æ•°ä¼šè°ƒç”¨ setEmulatorGlesValue() ä» property å±æ€§ç³»ç»Ÿä¸­è·å–ä¸€äº›å±æ€§å€¼æ¥åˆ¤æ–­å½“å‰ Android ç³»ç»Ÿæ˜¯å¦åœ¨ Emulator ç¯å¢ƒä¸­è¿è¡Œï¼Œå¹¶æ ¹æ®è¯»å–å‡ºæ¥çš„ä¿¡æ¯æ¥é‡æ–°è®¾ç½®æ–°çš„å±æ€§é”®å€¼å¯¹ï¼ŒsetEmulatorGlesValue() å‡½æ•°çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112131415161718192021222324252627282930313233[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]static void setEmulatorGlesValue(void) &#123; char prop[PROPERTY_VALUE_MAX]; property_get(\"ro.kernel.qemu\", prop, \"0\"); //è¯»å– ro.kernel.qemu å±æ€§å€¼ï¼Œåˆ¤æ–­Androidç³»ç»Ÿæ˜¯å¦è¿è¡Œåœ¨ qemu ä¸­ if (atoi(prop) != 1) return; property_get(\"ro.kernel.qemu.gles\", prop, \"0\"); //è¯»å– ro.kernel.qemu.gles å±æ€§å€¼ï¼Œåˆ¤æ–­ qemu ä¸­ OpenGL ES åº“çš„å®ç°æ–¹å¼ if (atoi(prop) == 1) &#123; ALOGD(\"Emulator has host GPU support, qemu.gles is set to 1.\"); property_set(\"qemu.gles\", \"1\"); return; &#125; // for now, checking the following // directory is good enough for emulator system images const char* vendor_lib_path = #if defined(__LP64__) \"/vendor/lib64/egl\"; #else \"/vendor/lib/egl\"; #endif const bool has_vendor_lib = (access(vendor_lib_path, R_OK) == 0); //å¦‚æœå­˜åœ¨ vendor_lib_path è¿™ä¸ªè·¯å¾„ï¼Œé‚£ä¹ˆå°±è¯´æ˜å‚å•†æä¾›äº† OpenGL ESåº“è‡ªå·±çš„è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“åº“ï¼Œè€Œä¸æ˜¯ Android ç³»ç»Ÿè‡ªå·±ç¼–è¯‘å¾—åˆ°çš„è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“åº“ if (has_vendor_lib) &#123; ALOGD(\"Emulator has vendor provided software renderer, qemu.gles is set to 2.\"); property_set(\"qemu.gles\", \"2\"); &#125; else &#123; ALOGD(\"Emulator without GPU support detected. \" \"Fallback to legacy software renderer, qemu.gles is set to 0.\"); property_set(\"qemu.gles\", \"0\"); //æœ€åï¼Œé»˜è®¤é‡‡å–çš„æ˜¯æ–¹æ¡ˆå°±æ˜¯è°ƒç”¨ä¼ ç»Ÿçš„Androidç³»ç»Ÿè‡ªå·±ç¼–è¯‘å¾—åˆ°è½¯ä»¶æ¨¡æ‹Ÿæ¸²æŸ“åº“ &#125; &#125; åœ¨ load_system_driver() å‡½æ•°ä¸­ï¼Œå†…éƒ¨ç±» MatchFile ç±»ä¸­ä¼šè°ƒç”¨ checkGlesEmulationStatus() å‡½æ•°æ¥æ£€æŸ¥ Android ç³»ç»Ÿæ˜¯å¦è¿è¡Œåœ¨æ¨¡æ‹Ÿå™¨ä¸­ï¼Œä»¥åŠåœ¨æ¨¡æ‹Ÿå™¨ä¸­æ˜¯å¦å¯ç”¨äº†ä¸»æœºç¡¬ä»¶åŠ é€Ÿçš„åŠŸèƒ½ï¼Œç„¶åæ ¹æ® checkGlesEmulationStatus() å‡½æ•°çš„è¿”å›çŠ¶æ€å€¼æ¥ç¡®å®šè¦åŠ è½½å…±äº«é“¾æ¥åº“çš„æ–‡ä»¶ç»å¯¹è·¯å¾„ã€‚load_system_driver() å’Œ checkGlesEmulationStatus() å‡½æ•°ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]static void* load_system_driver(const char* kind) &#123; ATRACE_CALL(); class MatchFile &#123; public: //è¿™ä¸ªå‡½æ•°ä½œç”¨æ˜¯è¿”å›éœ€è¦åŠ è½½æ‰“å¼€çš„ OpenGL ES å’Œ EGL API å®ç°åº“æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ static String8 find(const char* kind) &#123; String8 result; int emulationStatus = checkGlesEmulationStatus(); //æ£€æŸ¥ Android ç³»ç»Ÿæ˜¯å¦è¿è¡Œåœ¨æ¨¡æ‹Ÿå™¨ä¸­ï¼Œä»¥åŠåœ¨æ¨¡æ‹Ÿå™¨ä¸­æ˜¯å¦å¯ç”¨äº†ä¸»æœºç¡¬ä»¶åŠ é€Ÿçš„åŠŸèƒ½ switch (emulationStatus) &#123; case 0: //Android è¿è¡Œåœ¨æ¨¡æ‹Ÿå™¨ä¸­ï¼Œä½¿ç”¨ç³»ç»Ÿè½¯ä»¶æ¨¡æ‹Ÿå®ç°çš„ OpenGL ES API åº“ libGLES_android.so #if defined(__LP64__) result.setTo(\"/system/lib64/egl/libGLES_android.so\"); #else result.setTo(\"/system/lib/egl/libGLES_android.so\"); #endif return result; case 1: // Android è¿è¡Œåœ¨æ¨¡æ‹Ÿå™¨ä¸­ï¼Œé€šè¿‡ä¸»æœºç³»ç»Ÿä¸­å®ç° OpenGL ES åŠ é€Ÿæ¸²æŸ“ï¼Œé€šè¿‡ libGLES_emulation.so åº“å°† OpenGL ES API æŒ‡ä»¤é‡å®šå‘åˆ° host ä¸­æ‰§è¡Œ // Use host-side OpenGL through the \"emulation\" library #if defined(__LP64__) result.appendFormat(\"/system/lib64/egl/lib%s_emulation.so\", kind); #else result.appendFormat(\"/system/lib/egl/lib%s_emulation.so\", kind); #endif return result; default: // Not in emulator, or use other guest-side implementation break; &#125; // å¦‚æœä¸æ˜¯ä¸Šé¢ä¸¤ç§æƒ…å†µï¼Œå°±æ ¹æ®åº“çš„å‘½åè§„åˆ™å»æ‰¾åˆ°å‚å•†å®ç°åº“æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ String8 pattern; pattern.appendFormat(\"lib%s\", kind); const char* const searchPaths[] = &#123; #if defined(__LP64__) \"/vendor/lib64/egl\", \"/system/lib64/egl\" #else \"/vendor/lib/egl\", \"/system/lib/egl\" #endif &#125;; ...... &#125; &#125; æ€»ç»“ä¸€ä¸‹ä¸Šé¢ä»£ç çš„åŠŸèƒ½å°±æ˜¯ï¼Œé¦–å…ˆåˆ¤æ–­ Android æ˜¯å¦åœ¨ qemu è™šæ‹Ÿæœºä¸­è¿è¡Œï¼Œå¦‚æœä¸æ˜¯ï¼Œé‚£ä¹ˆå°±ç›´æ¥å»åŠ è½½å‚å•†å­˜æ”¾åº“çš„è·¯å¾„ä¸­å»åŠ è½½ OpenGL ES å®ç°åº“ï¼ˆä¸ç®¡æ˜¯ç¡¬ä»¶åŠ é€Ÿå®ç°çš„ï¼Œè¿˜æ˜¯è½¯ä»¶æ¨¡æ‹Ÿå®ç°çš„ï¼‰ï¼›å¦‚æœæ˜¯åœ¨ qemu ä¸­è¿è¡Œï¼Œé‚£ä¹ˆå°±è¦æ ¹æ®è¿”å›çš„ emulationStatus å€¼ æ¥ç¡®å®šæ˜¯åŠ è½¯ä»¶æ¨¡æ‹Ÿå®ç°çš„ OpenGL ES API åº“ libGLES_android.soï¼Œè¿˜æ˜¯åŠ è½½ libGLES_emulation.soåº“å°† OpenGL ES æŒ‡ä»¤é‡å®šå‘åˆ° Host ç³»ç»Ÿä¸­å»æ‰§è¡Œã€‚ 4.3.3ã€OpenGL ES/EGL åº“åŠ è½½å’Œè§£æè¿‡ç¨‹æ­£å¦‚å‰é¢åˆ†æï¼Œåœ¨è¿›è¡Œ OpenGL ç¼–ç¨‹æ—¶ï¼Œæœ€å…ˆå¼€å§‹éœ€è¦è·å– Displayï¼Œè¿™å°†è°ƒç”¨ eglgGetDisplay() å‡½æ•°è¢«è°ƒç”¨ã€‚åœ¨ eglGetDisplay() é‡Œåˆ™ä¼šè°ƒç”¨ egl_init_drivers() åˆå§‹åŒ–é©±åŠ¨ï¼šè£…è½½å„ä¸ªåº“è¿›è¡Œè§£æï¼Œå°† OpenGL ES/EGL API å‡½æ•°æ¥å£å’Œå…·ä½“çš„å®ç°ç»‘å®šåœ¨ä¸€èµ·ï¼Œå¹¶å°†ç»“æœä¿å­˜åœ¨ egl_connection_t ç±»å‹çš„å…¨å±€å˜é‡ gEGLImpl çš„ç»“æ„ä½“çš„æˆå‘˜å˜é‡ä¸­ã€‚ ä¸‹é¢ä»¥ SurfaceFlinger è¿›ç¨‹init()ä¸ºä¾‹è¿›è¡Œåˆ†æï¼Œæ•´ä¸ª OpenGL ES/EGL åº“çš„åŠ è½½å’Œè§£ææµç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š è¿™é‡Œé€šè¿‡è°ƒç”¨ EGL åº“çš„ eglGetDisplay() è·å¾— Displayã€‚ 123456789101112[-&gt;\\frameworks\\native\\opengl\\libs\\EGL\\eglApi.cpp]EGLDisplay eglGetDisplay(EGLNativeDisplayType display)&#123; ...... if (egl_init_drivers() == EGL_FALSE) &#123; return setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY); &#125; EGLDisplay dpy = egl_display_t::getFromNativeDisplay(display); return dpy;&#125; å‡½æ•°EGLBoolean egl_init_drivers()å°±æ˜¯è´Ÿè´£OpenGLåº“çš„åŠ è½½ã€‚12345678[-&gt;\\frameworks\\native\\opengl\\libs\\EGL\\egl.cpp]EGLBoolean egl_init_drivers() &#123; EGLBoolean res; pthread_mutex_lock(&amp;sInitDriverMutex); res = egl_init_drivers_locked(); pthread_mutex_unlock(&amp;sInitDriverMutex); return res;&#125; ä¸ºä¿è¯å¤šçº¿ç¨‹è®¿é—®çš„å®‰å…¨æ€§ï¼Œä½¿ç”¨çº¿ç¨‹é”æ¥æ”¾å®Œå¦ä¸€ä¸ªæ¥å£å‡½æ•°egl_init_drivers_locked()123456789101112131415161718192021222324252627282930313233343536[-&gt;\\frameworks\\native\\opengl\\libs\\EGL\\egl.cpp]//åœ¨è¯¥æ–‡ä»¶èµ·å§‹ä½ç½®å®šä¹‰çš„å…¨å±€å˜é‡egl_connection_t gEGLImpl; // æè¿°EGLå®ç°å†…å®¹çš„ç»“æ„ä½“å¯¹è±¡gl_hooks_t gHooks[2]; // gl_hooks_t æ˜¯åŒ…å« OpenGL ES API å‡½æ•°å£°æ˜å¯¹åº”çš„å‡½æ•°æŒ‡é’ˆç»“æ„ä½“gl_hooks_t gHooksNoContext;pthread_key_t gGLWrapperKey = -1;static EGLBoolean egl_init_drivers_locked() &#123; if (sEarlyInitState) &#123; // initialized by static ctor. should be set here. return EGL_FALSE; &#125; // å¾—åˆ° Loader å¯¹è±¡å•ä¾‹ // get our driver loader Loader&amp; loader(Loader::getInstance()); // gEGLImple æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œæ•°æ®ç±»å‹ä¸º egl_connection_t ç»“æ„ä½“ç±»å‹ // dynamically load our EGL implementation egl_connection_t* cnx = &amp;gEGLImpl; // cnx-&gt;dso æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª (void *)ç±»å‹çš„æŒ‡é’ˆï¼Œå®ƒæŒ‡å‘çš„å¯¹è±¡æ˜¯ EGL å…±äº«åº“æ‰“å¼€ä¹‹åçš„å¥æŸ„ if (cnx-&gt;dso == 0) &#123; // &gt;= å°†cnxä¸­çš„ hooks æ•°ç»„ä¸­æŒ‡å‘OpenGL ES API å‡½æ•°æŒ‡é’ˆç»“æ„ä½“æŒ‡çš„æ•°ç»„æˆå‘˜ï¼Œç”¨ gHooks ä¸­çš„æˆå‘˜çš„åœ°å€å»åˆå§‹åŒ– //ä¹Ÿå°±æ˜¯è¯´ gEGLImpl ä¸­ hook æ•°ç»„æŒ‡å‘ gHooks æ•°ç»„ï¼Œæœ€ç»ˆæŒ‡å‘åŒä¸€ä¸ª OpenGL ES API å‡½æ•°æŒ‡é’ˆçš„å®ç° cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX] = &amp;gHooks[egl_connection_t::GLESv1_INDEX]; cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX] = &amp;gHooks[egl_connection_t::GLESv2_INDEX]; // &gt;= æœ€åé€šè¿‡loaderå¯¹è±¡çš„openå‡½æ•°å¼€å§‹åŠ è½½ OpenGL ES å’Œ EGL wrapper åº“ cnx-&gt;dso = loader.open(cnx); &#125; return cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;&#125; åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œæœ‰ä¸€ä¸ªéå¸¸å…³é”®çš„ egl_connection_t æŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªå…¨å±€å˜é‡ gEGLImplï¼Œå½“ç¬¬ä¸€æ¬¡åˆå§‹åŒ–åŠ è½½ OpenGL ES å®ç°åº“å’Œ EGL å®ç°åº“æ—¶ï¼Œè¿˜éœ€è¦å°† gEGLImpl ä¸­çš„ hooks æ•°ç»„ä¸­çš„ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªå…¨å±€çš„ gl_hooks_t æ•°ç»„ gHooksï¼ˆè¿™å°±æ˜¯ä¸¤ä¸ªæŒ‡é’ˆé’©å­ï¼Œæœ€ç»ˆåˆå§‹åŒ–å®Œæˆåå°†åˆ†åˆ«å‹¾ä½ OpenGL ES 1.0 å’Œ OpenGL ES 2.0 çš„å®ç°åº“ï¼‰ï¼Œæ¥ç€è°ƒç”¨ Loader ç±»çš„å®ä¾‹çš„ open() å‡½æ•°å®Œæˆä» OpenGL ES å®ç°åº“ä¸­å®Œæˆç¬¦å·è§£æå·¥ä½œã€‚ Loader::open() å‡½æ•°çš„ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526[/frameworks/native/opengl/libs/EGL/Loader.cpp]// &gt;= Loader ç±»å¯¹è±¡æ„é€ å®Œæˆåï¼Œå°±åœ¨ /EGL/egl.cpp æ–‡ä»¶ä¸­çš„ egl_init_drivers_locked() ä¸­è¢«è°ƒç”¨void* Loader::open(egl_connection_t* cnx)&#123; void* dso; driver_t* hnd = 0; setEmulatorGlesValue(); dso = load_driver(\"GLES\", cnx, EGL | GLESv1_CM | GLESv2); if (dso) &#123; hnd = new driver_t(dso); &#125; else &#123; // Always load EGL first dso = load_driver(\"EGL\", cnx, EGL); if (dso) &#123; hnd = new driver_t(dso); hnd-&gt;set( load_driver(\"GLESv1_CM\", cnx, GLESv1_CM), GLESv1_CM ); hnd-&gt;set( load_driver(\"GLESv2\", cnx, GLESv2), GLESv2 ); &#125; &#125; ...... cnx-&gt;libEgl = load_wrapper(EGL_WRAPPER_DIR \"/libEGL.so\"); cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR \"/libGLESv2.so\"); cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR \"/libGLESv1_CM.so\"); ...... return (void*)hnd;&#125; open() å‡½æ•°ä¸»è¦è´Ÿè´£ OpenGL ES åº“åŠ è½½å‰çš„å‡†å¤‡å·¥ä½œï¼Œå…·ä½“çš„åŠ è½½ç»†èŠ‚ï¼Œåˆ™æ˜¯é€šè¿‡è°ƒç”¨ load_driver() å»å®Œæˆçš„ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[/frameworks/native/opengl/libs/EGL/Loader.cpp]oid *Loader::load_driver(const char* kind, egl_connection_t* cnx, uint32_t mask)&#123; void* dso = nullptr; if (mGetDriverNamespace) &#123; android_namespace_t* ns = mGetDriverNamespace(); if (ns) &#123; dso = load_updated_driver(kind, ns); //åŠ è½½ OpenGL ES å®ç°åº“ï¼Œæ”¾å›æ‰“å¼€çš„å…±äº«é“¾æ¥åº“çš„å¥æŸ„ &#125; &#125; if (!dso) &#123; dso = load_system_driver(kind); ...... &#125; // è§£æ EGL åº“ï¼Œå¹¶å°†wrapper åº“ libEGL.so ä¸­çš„å‡½æ•° API æŒ‡é’ˆå’Œå…·ä½“çš„å®ç°ç»‘å®šåœ¨ä¸€èµ· if (mask &amp; EGL) &#123; getProcAddress = (getProcAddressType)dlsym(dso, \"eglGetProcAddress\"); ...... egl_t* egl = &amp;cnx-&gt;egl; //å°† egl æŒ‡é’ˆæŒ‡å‘æè¿°å½“å‰ç³»ç»Ÿæ”¯æŒ OpenGL ESå’Œ EGL å…¨å±€å˜é‡çš„ gEGLImpl __eglMustCastToProperFunctionPointerType* curr = (__eglMustCastToProperFunctionPointerType*)egl; char const * const * api = egl_names; //egl_names æ˜¯å®šä¹‰åœ¨ egl.cpp æ–‡ä»¶ä¸­çš„ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ æ˜¯ EGL API å‡½æ•°æŒ‡é’ˆ while (*api) &#123; char const * name = *api; __eglMustCastToProperFunctionPointerType f = (__eglMustCastToProperFunctionPointerType)dlsym(dso, name); if (f == NULL) &#123; // couldn't find the entry-point, use eglGetProcAddress() f = getProcAddress(name); if (f == NULL) &#123; f = (__eglMustCastToProperFunctionPointerType)0; &#125; &#125; *curr++ = f; //è¿™ä¸€æ­¥å°±æ˜¯æœ€å…³é”®çš„å°†å…±äº«é“¾æ¥åº“ä¸­çš„ EGL API çš„å®ç°å’Œä¸Šå±‚è°ƒç”¨çš„ API å‡½æ•°æŒ‡é’ˆç»‘å®šåœ¨ä¸€èµ· api++; //æŒ‡å‘ä¸‹ä¸€ä¸ªéœ€è¦ç»‘å®šçš„ api å‡½æ•° &#125; &#125; // è§£æ OpenGL ES åº“ä¸­çš„ OpenGL ES 1.x API ç¬¦å· if (mask &amp; GLESv1_CM) &#123; // è°ƒç”¨ init_api å®ç° OpenGL API å’Œå¯¹åº”å®ç°å‡½æ•°çš„ç»‘å®š init_api(dso, gl_names, // gl_names æ˜¯å®šä¹‰åœ¨ egl.cpp æ–‡ä»¶ä¸­çš„ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ æ˜¯ OpenGL ES API å‡½æ•°æŒ‡é’ˆ (__eglMustCastToProperFunctionPointerType*) &amp;cnx-&gt;hooks[egl_connection_t::GLESv1_INDEX]-&gt;gl, //glæˆå‘˜å˜é‡æ˜¯ä¸€ä¸ªç»“æ„ä½“å˜é‡ï¼Œç»“æ„ä½“ä¸­çš„æ˜¯ OpenGL ES API å‡½æ•°æŒ‡é’ˆ getProcAddress); &#125; // è§£æ OpenGL ES åº“ä¸­çš„ OpenGL ES 2.0 API ç¬¦å· if (mask &amp; GLESv2) &#123; init_api(dso, gl_names, (__eglMustCastToProperFunctionPointerType*) &amp;cnx-&gt;hooks[egl_connection_t::GLESv2_INDEX]-&gt;gl, getProcAddress); &#125; return dso;&#125; Loader::load_driver() å®ƒä¸»è¦å®ç°äº†ä¸¤ä¸ªåŠŸèƒ½ï¼š é€šè¿‡ load_system_driver() å‡½æ•°æŸ¥æ‰¾ OpenGL ES/EGL å®ç°åº“ï¼Œå¹¶åœ¨æŒ‡å®šçš„å­˜æ”¾è·¯å¾„ä¸­æ‰¾åˆ°å…±äº«é“¾æ¥åº“æ–‡ä»¶å¹¶æ‰“å¼€å®ƒã€‚è°ƒç”¨ init_api()è§£ææ‰“å¼€çš„ OpenGL ES/EGL å…±äº«é“¾æ¥åº“ï¼Œå°† OpenGL ES/EGL API å‡½æ•°æŒ‡é’ˆå’Œå…±äº«é“¾æ¥åº“ä¸­å®ç°çš„å¯¹åº”çš„å‡½æ•°ç¬¦å·ç»‘å®šåœ¨ä¸€èµ·ï¼Œè¿™æ ·è°ƒç”¨ OpenGL ES/EGL API å°±ä¼šè°ƒç”¨åˆ°å…·ä½“å®ç°çš„OpenGL ES/EGL å…±äº«é“¾æ¥åº“ä¸­å¯¹åº”å‡½æ•°ã€‚ 4.4ã€å°ç»“Android OpenGL ES å›¾å½¢åº“ç»“æ„Android çš„ OpenGL ES å›¾å½¢ç³»ç»Ÿæ¶‰åŠå¤šä¸ªåº“ï¼Œæ ¹æ®è®¾å¤‡ç±»å‹çš„ä¸åŒï¼Œè¿™äº›åº“æœ‰ç€ä¸åŒçš„ç»“æ„ã€‚ å¯¹äºæ¨¡æ‹Ÿå™¨ï¼Œæ²¡æœ‰å¼€å¯ OpenGL ES çš„ GPU ç¡¬ä»¶æ¨¡æ‹Ÿçš„æƒ…å†µï¼ŒAndroid OpenGL ES å›¾å½¢åº“ç»“æ„å¦‚ä¸‹ï¼š å½“ä¸ºæ¨¡æ‹Ÿå™¨å¼€å¯äº† OpenGL ES çš„ GPU ç¡¬ä»¶æ¨¡æ‹Ÿï¼Œå®é™…çš„ EGL å’Œ OpenGL ES å®ç°åº“ä¼šé‡‡ç”¨ç”± android-7.1.1_r22/device/generic/goldfish-opengl ä¸‹çš„æºç ç¼–è¯‘å‡ºæ¥çš„å‡ ä¸ªåº“æ–‡ä»¶ï¼Œå³ libGLESv2_emulation.soã€libGLESv1_CM_emulation.so å’Œ libEGL_emulation.soã€‚æ­¤æ—¶ï¼ŒOpenGL ES å›¾å½¢åº“ç»“æ„å¦‚ä¸‹ï¼š å¯¹äºçœŸå®çš„ç‰©ç† Android è®¾å¤‡ï¼ŒOpenGL ES å›¾å½¢åº“ç»“æ„å¦‚ä¸‹ï¼Œä¾‹å¦‚é«˜é€šå®ç°ï¼ˆlibEGL_adreno.solibGLESv1_CM_adreno.so libGLESv2_adreno.so [\\system\\vendor\\lib64\\egl]ï¼‰ï¼š ####ï¼ˆäº”ï¼‰ã€OpenGL ESï¼šEGLæ¥å£è§£æä¸ç†è§£ ç”±å‰é¢çš„åˆ†æçŸ¥é“EGLçš„ç»˜å›¾çš„ä¸€èˆ¬æ­¥éª¤å¦‚ä¸‹ï¼Œæ¥ä¸‹æ¥åˆ†æä¸»è¦çš„1-8ä¸ªå°æ­¥éª¤ï¼š ä½¿ç”¨EGLçš„ç»˜å›¾çš„ä¸€èˆ¬æ­¥éª¤ï¼š1ã€è·å– EGL Display å¯¹è±¡ï¼šeglGetDisplay()2ã€åˆå§‹åŒ–ä¸ EGLDisplay ä¹‹é—´çš„è¿æ¥ï¼šeglInitialize()3ã€è·å– EGLConfig å¯¹è±¡ï¼šeglChooseConfig()4ã€åˆ›å»º EGLContext å®ä¾‹ï¼šeglCreateContext()5ã€åˆ›å»º EGLSurface å®ä¾‹ï¼šeglCreateWindowSurface()6ã€è¿æ¥ EGLContext å’Œ EGLSurfaceï¼šeglMakeCurrent()7ã€ä½¿ç”¨ OpenGL ES API ç»˜åˆ¶å›¾å½¢ï¼šgl_*()8ã€åˆ‡æ¢ front buffer å’Œ back buffer é€æ˜¾ï¼šeglSwapBuffer()9ã€æ–­å¼€å¹¶é‡Šæ”¾ä¸ EGLSurface å…³è”çš„ EGLContext å¯¹è±¡ï¼šeglRelease()10ã€åˆ é™¤ EGLSurface å¯¹è±¡11ã€åˆ é™¤ EGLContext å¯¹è±¡12ã€ç»ˆæ­¢ä¸ EGLDisplay ä¹‹é—´çš„è¿æ¥ æ ‡å‡† EGL æ•°æ®ç±»å‹å¦‚ä¸‹æ‰€ç¤ºï¼š EGLBoolean â€”â€”EGL_TRUE =1, EGL_FALSE=0EGLint â€”â€”int æ•°æ®ç±»å‹EGLDisplay â€”â€”ç³»ç»Ÿæ˜¾ç¤º ID æˆ–å¥æŸ„ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå‰ç«¯çš„æ˜¾ç¤ºçª—å£EGLConfig â€”â€”Surfaceçš„EGLé…ç½®ï¼Œå¯ä»¥ç†è§£ä¸ºç»˜åˆ¶ç›®æ ‡framebufferçš„é…ç½®å±æ€§EGLSurface â€”â€”ç³»ç»Ÿçª—å£æˆ– frame buffer å¥æŸ„ ï¼Œå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªåç«¯çš„æ¸²æŸ“ç›®æ ‡çª—å£ã€‚EGLContext â€”â€”OpenGL ES å›¾å½¢ä¸Šä¸‹æ–‡ï¼Œå®ƒä»£è¡¨äº†OpenGLçŠ¶æ€æœºï¼›å¦‚æœæ²¡æœ‰å®ƒï¼ŒOpenGLæŒ‡ä»¤å°±æ²¡æœ‰æ‰§è¡Œçš„ç¯å¢ƒã€‚ ä¸‹é¢å‡ ä¸ªç±»å‹æ¯”è¾ƒå¤æ‚ï¼Œé€šè¿‡ä¾‹å­å¯ä»¥æ›´æ·±å…¥çš„ç†è§£ã€‚è¿™é‡Œè¦è¯´æ˜çš„æ˜¯è¿™å‡ ä¸ªç±»å‹åœ¨ä¸åŒå¹³å°å…¶å®ç°æ˜¯ä¸åŒçš„ï¼ŒEGLåªæä¾›æŠ½è±¡æ ‡å‡†ã€‚ NativeDisplayTypeâ€”â€”Native ç³»ç»Ÿæ˜¾ç¤ºç±»å‹ï¼Œæ ‡è¯†ä½ æ‰€å¼€å‘è®¾å¤‡çš„ç‰©ç†å±å¹•NativeWindowType â€”â€”Native ç³»ç»Ÿçª—å£ç¼“å­˜ç±»å‹ï¼Œæ ‡è¯†ç³»ç»Ÿçª—å£NativePixmapType â€”â€”Native ç³»ç»Ÿ frame bufferï¼Œå¯ä»¥ä½œä¸º Framebuffer çš„ç³»ç»Ÿå›¾åƒï¼ˆå†…å­˜ï¼‰æ•°æ®ç±»å‹ï¼Œè¯¥ç±»å‹åªç”¨äºç¦»å±æ¸²æŸ“. 5.1ã€eglGetDisplay()EGLDisplay æ˜¯ä¸€ä¸ªå…³è”ç³»ç»Ÿç‰©ç†å±å¹•çš„é€šç”¨æ•°æ®ç±»å‹ï¼Œè¡¨ç¤ºæ˜¾ç¤ºè®¾å¤‡å¥æŸ„ï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªå‰ç«¯æ˜¾ç¤ºçª—ã€‚ä¸ºäº†ä½¿ç”¨ç³»ç»Ÿçš„æ˜¾ç¤ºè®¾å¤‡ï¼Œ EGL æä¾›äº† EGLDisplay æ•°æ®ç±»å‹ï¼Œä»¥åŠä¸€ç»„æ“ä½œè®¾å¤‡æ˜¾ç¤ºçš„ API ã€‚ä¸‹é¢çš„å‡½æ•°åŸå‹ç”¨äºè·å– Native Display ï¼š12345678910111213141516[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLDisplay eglGetDisplay(NativeDisplayType display)&#123;...... if (display == EGL_DEFAULT_DISPLAY) &#123; EGLDisplay dpy = (EGLDisplay)1; egl_display_t&amp; d = egl_display_t::get_display(dpy); d.type = display; return dpy; &#125; return EGL_NO_DISPLAY;&#125;egl_display_t&amp; egl_display_t::get_display(EGLDisplay dpy) &#123; return gDisplays[uintptr_t(dpy)-1U];&#125; å…¶ ä¸­ display å‚æ•°æ˜¯ native ç³»ç»Ÿçš„çª—å£æ˜¾ç¤º ID å€¼ã€‚å¦‚æœä½ åªæ˜¯æƒ³å¾—åˆ°ä¸€ä¸ªç³»ç»Ÿé»˜è®¤çš„ Display ï¼Œä½ å¯ä»¥ä½¿ç”¨ EGL_DEFAULT_DISPLAY å‚æ•°ã€‚å¦‚æœç³»ç»Ÿä¸­æ²¡æœ‰ä¸€ä¸ªå¯ç”¨çš„ native display ID ä¸ç»™å®šçš„ display å‚æ•°åŒ¹é…ï¼Œå‡½æ•°å°†è¿”å› EGL_NO_DISPLAY ï¼Œè€Œæ²¡æœ‰ä»»ä½• Error çŠ¶æ€è¢«è®¾ç½®ã€‚ 5.2ã€eglInitialize()æ¯ä¸ª EGLDisplay åœ¨ä½¿ç”¨å‰éƒ½éœ€è¦åˆå§‹åŒ–ã€‚åˆå§‹åŒ– EGLDisplay çš„åŒæ—¶ï¼Œä½ å¯ä»¥å¾—åˆ°ç³»ç»Ÿä¸­ EGL çš„å®ç°ç‰ˆæœ¬å·ã€‚äº†è§£å½“å‰çš„ç‰ˆæœ¬å·åœ¨å‘åå…¼å®¹æ€§æ–¹é¢æ˜¯éå¸¸æœ‰ä»·å€¼çš„ã€‚åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œé€šè¿‡åŠ¨æ€æŸ¥è¯¢ EGL ç‰ˆæœ¬å·ï¼Œä½ å¯ä»¥ä¸ºæ–°æ—§ç‰ˆæœ¬çš„ EGL é™„åŠ é¢å¤–çš„ç‰¹æ€§æˆ–è¿è¡Œç¯å¢ƒã€‚åŸºäºå¹³å°é…ç½®ï¼Œè½¯ä»¶å¼€å‘å¯ç”¨æ¸…æ¥šçŸ¥é“å“ªäº› API å¯ç”¨è®¿é—®ï¼Œè¿™å°†ä¼šä¸ºä½ çš„ä»£ç æä¾›æœ€å¤§é™åº¦çš„å¯ç§»æ¤æ€§ã€‚12345678910111213141516171819[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLBoolean eglInitialize(EGLDisplay dpy, EGLint *major, EGLint *minor)&#123; if (egl_display_t::is_valid(dpy) == EGL_FALSE) return setError(EGL_BAD_DISPLAY, EGL_FALSE); EGLBoolean res = EGL_TRUE; egl_display_t&amp; d = egl_display_t::get_display(dpy); if (d.initialized.fetch_add(1, std::memory_order_acquire) == 0) &#123; ...... &#125; if (res == EGL_TRUE) &#123; if (major != NULL) *major = VERSION_MAJOR; if (minor != NULL) *minor = VERSION_MINOR; &#125; return res;&#125; å…¶ä¸­ dpy åº”è¯¥æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ EGLDisplay ã€‚å‡½æ•°è¿”å›æ—¶ï¼Œ major å’Œ minor å°†è¢«èµ‹äºˆå½“å‰ EGL ç‰ˆæœ¬å·ã€‚æ¯”å¦‚ EGL1.0 ï¼Œ major è¿”å› 1 ï¼Œ minor åˆ™è¿”å› 0 ã€‚ç»™ major å’Œ minor ä¼  NULL æ˜¯æœ‰æ•ˆçš„ï¼Œå¦‚æœä½ ä¸å…³å¿ƒç‰ˆæœ¬å·ã€‚eglQueryString() å‡½æ•°æ˜¯å¦å¤–ä¸€ä¸ªè·å–ç‰ˆæœ¬ä¿¡æ¯å’Œå…¶ä»–ä¿¡æ¯çš„é€”å¾„ã€‚é€šè¿‡ eglQueryString() è·å–ç‰ˆæœ¬ä¿¡æ¯éœ€è¦è§£æç‰ˆæœ¬å­—ç¬¦ä¸²ï¼Œæ‰€ä»¥é€šè¿‡ä¼ é€’ä¸€ä¸ªæŒ‡é’ˆç»™ eglInitializ() å‡½æ•°æ¯”è¾ƒå®¹æ˜“è·å¾—è¿™ä¸ªä¿¡æ¯ã€‚æ³¨æ„åœ¨è°ƒç”¨ eglQueryString() å¿…é¡»å…ˆä½¿ç”¨ eglInitialize() åˆå§‹åŒ– EGLDisplay ï¼Œå¦åˆ™å°†å¾—åˆ° EGL_NOT_INITIALIZED é”™è¯¯ä¿¡æ¯ã€‚ 5.3ã€eglChooseConfig()åŸº äº EGL çš„å±æ€§ï¼Œå¯ä»¥å¾—åˆ°ä¸€ä¸ªå’Œéœ€æ±‚æ¥è¿‘çš„Configï¼Œä½†ä¹Ÿå¯ä»¥é€‰æ‹©è‡ªå·±éœ€è¦çš„Configï¼Œåªè¦å¹³å°æ”¯æŒã€‚ä¸æ˜¯æ‰€æœ‰çš„Configéƒ½æ˜¯æœ‰æ•ˆçš„ï¼Œä¹Ÿå°±æ˜¯ä¸æ˜¯æ‰€æœ‰Configéƒ½ä¼šæ”¯æŒã€‚ eglChooseConfig() å‡½æ•°å°†é€‚é…ä¸€ä¸ªæ‰€æœŸæœ›çš„é…ç½®ï¼Œå¹¶ä¸”å°½å¯èƒ½æ¥è¿‘ä¸€ä¸ªæœ‰æ•ˆçš„ç³»ç»Ÿé…ç½®ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLBoolean eglChooseConfig( EGLDisplay dpy, const EGLint *attrib_list, EGLConfig *configs, EGLint config_size, EGLint *num_config)&#123; if (egl_display_t::is_valid(dpy) == EGL_FALSE) return setError(EGL_BAD_DISPLAY, EGL_FALSE); if (ggl_unlikely(num_config==0)) &#123; return setError(EGL_BAD_PARAMETER, EGL_FALSE); &#125; if (ggl_unlikely(attrib_list==0)) &#123; /* * A NULL attrib_list should be treated as though it was an empty * one (terminated with EGL_NONE) as defined in * section 3.4.1 \"Querying Configurations\" in the EGL specification. */ static const EGLint dummy = EGL_NONE; attrib_list = &amp;dummy; &#125; int numAttributes = 0; int numConfigs = NELEM(gConfigs); uint32_t possibleMatch = (1&lt;&lt;numConfigs)-1; while(possibleMatch &amp;&amp; *attrib_list != EGL_NONE) &#123; numAttributes++; EGLint attr = *attrib_list++; EGLint val = *attrib_list++; for (int i=0 ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123; if (!(possibleMatch &amp; (1&lt;&lt;i))) continue; if (isAttributeMatching(i, attr, val) == 0) &#123; possibleMatch &amp;= ~(1&lt;&lt;i); &#125; &#125; &#125; // now, handle the attributes which have a useful default value for (size_t j=0 ; possibleMatch &amp;&amp; j&lt;NELEM(config_defaults) ; j++) &#123; // see if this attribute was specified, if not, apply its // default value if (binarySearch&lt;config_pair_t&gt;( (config_pair_t const*)attrib_list, 0, numAttributes-1, config_defaults[j].key) &lt; 0) &#123; for (int i=0 ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123; if (!(possibleMatch &amp; (1&lt;&lt;i))) continue; if (isAttributeMatching(i, config_defaults[j].key, config_defaults[j].value) == 0) &#123; possibleMatch &amp;= ~(1&lt;&lt;i); &#125; &#125; &#125; &#125; // return the configurations found int n=0; if (possibleMatch) &#123; if (configs) &#123; for (int i=0 ; config_size &amp;&amp; i&lt;numConfigs ; i++) &#123; if (possibleMatch &amp; (1&lt;&lt;i)) &#123; *configs++ = (EGLConfig)(uintptr_t)i; config_size--; n++; &#125; &#125; &#125; else &#123; for (int i=0 ; i&lt;numConfigs ; i++) &#123; if (possibleMatch &amp; (1&lt;&lt;i)) &#123; n++; &#125; &#125; &#125; &#125; *num_config = n; return EGL_TRUE;&#125; å‚æ•° attrib_list æŒ‡å®šäº†é€‰æ‹©é…ç½®æ—¶éœ€è¦å‚ç…§çš„å±æ€§ã€‚å‚æ•° configs å°†è¿”å›ä¸€ä¸ªæŒ‰ç…§ attrib_list æ’åºçš„å¹³å°æœ‰æ•ˆçš„æ‰€æœ‰ EGL framebuffer é…ç½®åˆ—è¡¨ã€‚å‚æ•° config_size æŒ‡å®šäº†å¯ä»¥è¿”å›åˆ° configs çš„æ€»é…ç½®ä¸ªæ•°ã€‚å‚æ•° num_config è¿”å›äº†å®é™…åŒ¹é…çš„é…ç½®æ€»æ•°ã€‚ 5.4ã€eglCreateContext()OpenGL ESçš„pipelineä»ç¨‹åºçš„è§’åº¦çœ‹å°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼Œæœ‰å½“å‰çš„é¢œè‰²ã€çº¹ç†åæ ‡ã€å˜æ¢çŸ©é˜µã€ç»šæŸ“æ¨¡å¼ç­‰ä¸€å¤§å †çŠ¶æ€ï¼Œè¿™äº›çŠ¶æ€ä½œç”¨äºOpenGL APIç¨‹åºæäº¤çš„é¡¶ç‚¹åæ ‡ç­‰å›¾å…ƒä»è€Œå½¢æˆå¸§ç¼“å†²å†…çš„åƒç´ ã€‚åœ¨OpenGLçš„ç¼–ç¨‹æ¥å£ä¸­ï¼ŒContextå°±ä»£è¡¨è¿™ä¸ªçŠ¶æ€æœºï¼ŒOpenGL APIç¨‹åºçš„ä¸»è¦å·¥ä½œå°±æ˜¯å‘Contextæä¾›å›¾å…ƒã€è®¾ç½®çŠ¶æ€ï¼Œå¶å°”ä¹Ÿä»Contexté‡Œè·å–ä¸€äº›ä¿¡æ¯ã€‚123456789101112131415161718[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLContext eglCreateContext(EGLDisplay dpy, EGLConfig config, EGLContext /*share_list*/, const EGLint* /*attrib_list*/)&#123; if (egl_display_t::is_valid(dpy) == EGL_FALSE) return setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE); ogles_context_t* gl = ogles_init(sizeof(egl_context_t)); if (!gl) return setError(EGL_BAD_ALLOC, EGL_NO_CONTEXT); egl_context_t* c = static_cast&lt;egl_context_t*&gt;(gl-&gt;rasterizer.base); c-&gt;flags = egl_context_t::NEVER_CURRENT; c-&gt;dpy = dpy; c-&gt;config = config; c-&gt;read = 0; c-&gt;draw = 0; return (EGLContext)gl;&#125; 5.5ã€eglCreateWindowSurface()Surfaceå®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªFrameBufferï¼Œä¹Ÿå°±æ˜¯æ¸²æŸ“ç›®çš„åœ°ï¼Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLSurface eglCreateWindowSurface( EGLDisplay dpy, EGLConfig config, NativeWindowType window, const EGLint *attrib_list)&#123; return createWindowSurface(dpy, config, window, attrib_list);&#125;static EGLSurface createWindowSurface(EGLDisplay dpy, EGLConfig config, NativeWindowType window, const EGLint* /*attrib_list*/)&#123; if (egl_display_t::is_valid(dpy) == EGL_FALSE) return setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE); if (window == 0) return setError(EGL_BAD_MATCH, EGL_NO_SURFACE); EGLint surfaceType; if (getConfigAttrib(dpy, config, EGL_SURFACE_TYPE, &amp;surfaceType) == EGL_FALSE) return EGL_FALSE; if (!(surfaceType &amp; EGL_WINDOW_BIT)) return setError(EGL_BAD_MATCH, EGL_NO_SURFACE); if (static_cast&lt;ANativeWindow*&gt;(window)-&gt;common.magic != ANDROID_NATIVE_WINDOW_MAGIC) &#123; return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE); &#125; EGLint configID; if (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE) return EGL_FALSE; int32_t depthFormat; int32_t pixelFormat; if (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123; return setError(EGL_BAD_MATCH, EGL_NO_SURFACE); &#125; ...... egl_surface_t* surface; surface = new egl_window_surface_v2_t(dpy, config, depthFormat, static_cast&lt;ANativeWindow*&gt;(window)); if (!surface-&gt;initCheck()) &#123; delete surface; surface = 0; &#125; return surface;&#125; æ¥åˆ›å»ºä¸€ä¸ªå¯å®é™…æ˜¾ç¤ºçš„Surfaceã€‚ ç³»ç»Ÿé€šå¸¸è¿˜æ”¯æŒå¦å¤–ä¸¤ç§Surfaceï¼šPixmapSurfaceå’ŒPBufferSurfaceï¼Œè¿™ä¸¤ç§éƒ½ä¸æ˜¯å¯æ˜¾ç¤ºçš„Surfaceï¼ŒPixmapSurfaceæ˜¯ä¿å­˜åœ¨ç³»ç»Ÿå†…å­˜ä¸­çš„ä½å›¾ï¼ŒPBufferåˆ™æ˜¯ä¿å­˜åœ¨æ˜¾å­˜ä¸­çš„å¸§ã€‚ å¯¹äºè¿™ä¸¤ç§surfaceï¼ŒAndroidç³»ç»Ÿä¸­ï¼Œæ”¯æŒPBufferSurfaceã€‚ 5.6ã€eglMakeCurrent()è¯¥æ¥å£å°†ç”³è¯·åˆ°çš„displayï¼Œdrawï¼ˆsurfaceï¼‰å’Œ contextè¿›è¡Œäº†ç»‘å®šã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨contextä¸‹çš„OpenGLAPIæŒ‡ä»¤å°†drawï¼ˆsurfaceï¼‰ä½œä¸ºå…¶æ¸²æŸ“æœ€ç»ˆç›®çš„åœ°ã€‚è€Œdisplayä½œä¸ºdrawï¼ˆsurfaceï¼‰çš„å‰ç«¯æ˜¾ç¤ºã€‚è°ƒç”¨åï¼Œå½“å‰çº¿ç¨‹ä½¿ç”¨çš„EGLContexä¸ºcontextã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLBoolean eglMakeCurrent( EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx)&#123; if (egl_display_t::is_valid(dpy) == EGL_FALSE) return setError(EGL_BAD_DISPLAY, EGL_FALSE); if (draw) &#123; egl_surface_t* s = (egl_surface_t*)draw; if (!s-&gt;isValid()) return setError(EGL_BAD_SURFACE, EGL_FALSE); if (s-&gt;dpy != dpy) return setError(EGL_BAD_DISPLAY, EGL_FALSE); // TODO: check that draw is compatible with the context &#125; if (read &amp;&amp; read!=draw) &#123; egl_surface_t* s = (egl_surface_t*)read; if (!s-&gt;isValid()) return setError(EGL_BAD_SURFACE, EGL_FALSE); if (s-&gt;dpy != dpy) return setError(EGL_BAD_DISPLAY, EGL_FALSE); // TODO: check that read is compatible with the context &#125; EGLContext current_ctx = EGL_NO_CONTEXT; if ((read == EGL_NO_SURFACE &amp;&amp; draw == EGL_NO_SURFACE) &amp;&amp; (ctx != EGL_NO_CONTEXT)) return setError(EGL_BAD_MATCH, EGL_FALSE); if ((read != EGL_NO_SURFACE || draw != EGL_NO_SURFACE) &amp;&amp; (ctx == EGL_NO_CONTEXT)) return setError(EGL_BAD_MATCH, EGL_FALSE); if (ctx == EGL_NO_CONTEXT) &#123; // if we're detaching, we need the current context current_ctx = (EGLContext)getGlThreadSpecific(); &#125; else &#123; egl_context_t* c = egl_context_t::context(ctx); egl_surface_t* d = (egl_surface_t*)draw; egl_surface_t* r = (egl_surface_t*)read; if ((d &amp;&amp; d-&gt;ctx &amp;&amp; d-&gt;ctx != ctx) || (r &amp;&amp; r-&gt;ctx &amp;&amp; r-&gt;ctx != ctx)) &#123; // one of the surface is bound to a context in another thread return setError(EGL_BAD_ACCESS, EGL_FALSE); &#125; &#125; ogles_context_t* gl = (ogles_context_t*)ctx; if (makeCurrent(gl) == 0) &#123; if (ctx) &#123; egl_context_t* c = egl_context_t::context(ctx); egl_surface_t* d = (egl_surface_t*)draw; egl_surface_t* r = (egl_surface_t*)read; if (c-&gt;draw) &#123; egl_surface_t* s = reinterpret_cast&lt;egl_surface_t*&gt;(c-&gt;draw); s-&gt;disconnect(); s-&gt;ctx = EGL_NO_CONTEXT; if (s-&gt;zombie) delete s; &#125; if (c-&gt;read) &#123; // FIXME: unlock/disconnect the read surface too &#125; c-&gt;draw = draw; c-&gt;read = read; if (c-&gt;flags &amp; egl_context_t::NEVER_CURRENT) &#123; c-&gt;flags &amp;= ~egl_context_t::NEVER_CURRENT; GLint w = 0; GLint h = 0; if (draw) &#123; w = d-&gt;getWidth(); h = d-&gt;getHeight(); &#125; ogles_surfaceport(gl, 0, 0); ogles_viewport(gl, 0, 0, w, h); ogles_scissor(gl, 0, 0, w, h); &#125; if (d) &#123; if (d-&gt;connect() == EGL_FALSE) &#123; return EGL_FALSE; &#125; d-&gt;ctx = ctx; d-&gt;bindDrawSurface(gl); &#125; if (r) &#123; // FIXME: lock/connect the read surface too r-&gt;ctx = ctx; r-&gt;bindReadSurface(gl); &#125; &#125; else &#123; // if surfaces were bound to the context bound to this thread // mark then as unbound. if (current_ctx) &#123; egl_context_t* c = egl_context_t::context(current_ctx); egl_surface_t* d = (egl_surface_t*)c-&gt;draw; egl_surface_t* r = (egl_surface_t*)c-&gt;read; if (d) &#123; c-&gt;draw = 0; d-&gt;disconnect(); d-&gt;ctx = EGL_NO_CONTEXT; if (d-&gt;zombie) delete d; &#125; if (r) &#123; c-&gt;read = 0; r-&gt;ctx = EGL_NO_CONTEXT; // FIXME: unlock/disconnect the read surface too &#125; &#125; &#125; return EGL_TRUE; &#125; return setError(EGL_BAD_ACCESS, EGL_FALSE);&#125; 5.7ã€ç»˜åˆ¶gl_*()åº”ç”¨ç¨‹åºé€šè¿‡OpenGL APIè¿›è¡Œç»˜åˆ¶ï¼Œä¸€å¸§å®Œæˆä¹‹åï¼Œè°ƒç”¨eglSwapBuffers(EGLDisplay dpy, EGLContext ctx)æ¥æ˜¾ç¤ºã€‚ 5.8ã€eglSwapBuffersæ¥å£å®ç°è¯´æ˜Androidå¹³å°ï¼š ä¸ºäº†å®ç°eglSwapBuffersï¼Œ eglSurfaceå…¶å®ä»£è¡¨äº†ä¸€ä¸ªä»NativeWindow ç”³è¯·åˆ°çš„ä¸€ä¸ªBufferï¼ˆDequeueæ“ä½œï¼‰ã€‚å½“è°ƒç”¨eglSwapBuffersæ—¶ï¼Œå¯¹äºä¸€èˆ¬åº”ç”¨çª—å£è€Œè¨€ï¼ŒNativeWindowå°†è¯¥Surfaceçš„Buffer æäº¤å›å»ç»™SurfaceFlingerï¼ˆQueueæ“ä½œ)ï¼Œ 12345678[-&gt;\\frameworks\\native\\opengl\\libagl\\egl.cpp]EGLBoolean egl_window_surface_v2_t::swapBuffers()&#123;......nativeWindow-&gt;queueBuffer(nativeWindow, buffer); nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);......&#125; ç„¶ååˆé‡æ–°ä»NativeWindowä¸­é‡æ–°Dequeueå‡ºæ¥ä¸€ä¸ªæ–°çš„Bufferç»™eglSurfaceã€‚è€ŒeglDisplayå¹¶ä¸ä»£è¡¨å®é™…çš„æ„ä¹‰ã€‚æˆ‘ä»¬åªæ˜¯ä»æ¥å£ä¸Šæ„Ÿè§‰æ˜¯ï¼Œsurfaceå’Œdisplayè¿›è¡Œäº†äº¤æ¢ã€‚ï¼ˆæ³¨ï¼šç°åœ¨æ˜¯Triple Bufferï¼‰ æ€»ç»“ï¼šä»å‰é¢å…³äºAndroid EGLã€OpenGL ESçš„åˆ†æçŸ¥é“ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥é€šè¿‡SurfaceFlingerç”³è¯·ä¸€å—Surfaceï¼ˆBufferï¼‰ï¼Œç„¶åå¯ä»¥åˆ©ç”¨OpenGL ESæ¥å£åœ¨Native å±‚ç»˜åˆ¶ç›¸å…³çš„å›¾ç‰‡ã€æ–‡å­—ï¼›é‚£ä¹ˆç–‘é—®æ¥äº†ï¼ŒAndroidä¸Šå±‚ç»šä¸½å¤šå½©çš„Appç•Œé¢æ˜¯å¦‚ä½•ç»˜åˆ¶è€Œæˆçš„å‘¢ã€Appå±‚å¦‚ä½•é€šè¿‡åº•å±‚çš„OpenGL ESæ¥å£æ¥å®Œæˆç»˜åˆ¶å‘¢ï¼Ÿï¼Ÿï¼Ÿ ï¼ˆå…­ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šKhronos GroupAndroidå›¾å½¢æ¶æ„ å®˜æ–¹æ–‡æ¡£OPENGL ES 2.0 çŸ¥è¯†ä¸²è®²OpenGL ES EGL Spec&amp;APIsUnderstaing-Android-EglAndroid ç³»ç»Ÿå›¾å½¢æ ˆ(1) &amp;&amp;(2)ï¼š OpenGL ES å’Œ EGLAndroid L çš„å¼€æœºåŠ¨ç”»æµç¨‹ - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Camera Systemï¼ˆ2ï¼‰ï¼šCamera System(Camera ç³»ç»Ÿ)startPreviewã€takePictureã€Recorderæµç¨‹åˆ†æ","slug":"Android Camera Systemï¼ˆ2ï¼‰ï¼šCamera System[Camera ç³»ç»Ÿ]startPreviewã€takePictureã€Recorderæµç¨‹åˆ†æ","date":"2018-07-09T16:00:00.000Z","updated":"2018-05-25T12:12:49.620Z","comments":true,"path":"2018/07/10/Android Camera Systemï¼ˆ2ï¼‰ï¼šCamera System[Camera ç³»ç»Ÿ]startPreviewã€takePictureã€Recorderæµç¨‹åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/07/10/Android Camera Systemï¼ˆ2ï¼‰ï¼šCamera System[Camera ç³»ç»Ÿ]startPreviewã€takePictureã€Recorderæµç¨‹åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Camera fwå­¦ä¹ -Armwindã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Camera API2åˆ†æ-Gzzaigcnforeverã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Camera æµç¨‹å­¦ä¹ è®°å½• Android 7.12-QQ_16775897ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - ä¸“æ ï¼šå¤å†¥çš„android6.0ä¸‹çš„Camera API2.0çš„æºç åˆ†æä¹‹æ—…ã€‘Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ğŸŒ€ğŸŒ€ï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ â˜¯ Applicationï¼šâ˜¯ /packages/apps/Camera2/src/com/android/camera/ â˜¯ Frameworkï¼šâ˜¯ /frameworks/base/core/java/android/hardware/Camera.java â˜¯ JNI:â˜¯ /frameworks/base/core/jni/android_hardware_Camera.cpp â˜¯ Native:â˜¯ Clientï¼šframeworks/av/camera/CameraBase.cppframeworks/av/camera/Camera.cppframeworks/av/camera/ICamera.cppframeworks/av/camera/aidl/android/hardware/ICamera.aidlframeworks/av/camera/aidl/android/hardware/ICameraClient.aidlâ˜¯ Serverï¼šframeworks/av/camera/cameraserver/main_cameraserver.cppframeworks/av/services/camera/libcameraservice/CameraService.cppframeworks/av/services/camera/libcameraservice/api1/CameraClient.cppframeworks/av/camera/aidl/android/hardware/ICameraService.aidl â˜¯ HALï¼šâ˜¯ /frameworks/av/services/camera/libcameraservice/device3/â˜¯ /hardware/qcom/camera/QCamera2(é«˜é€šHAL)â˜¯ /vendor/qcom/proprietary/mm-camera(é«˜é€šmm-camera)â˜¯ /vendor/qcom/proprietary/mm-still(é«˜é€šJPEG) â˜¯ Kernelï¼šâ˜¯ /kernel/drivers/media/platform/msm/camera_v2(é«˜é€šV4L2)â˜¯ /kernel/arch/arm/boot/dts/(é«˜é€šdts) ï¼ˆä¸€ï¼‰ã€Camera System startPreviewæµç¨‹åˆ†æ1.1ã€Camera2 startPreviewçš„åº”ç”¨å±‚(Java)æµç¨‹åˆ†æpreviewæµç¨‹éƒ½æ˜¯ä»startPreviewå¼€å§‹çš„ï¼Œæ‰€ä»¥æ¥çœ‹startPreviewæ–¹æ³•çš„ä»£ç ï¼š1234567[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]Overridepublic void startPreview(Surface previewSurface, CaptureReadyCallback listener) &#123; mPreviewSurface = previewSurface; //æ ¹æ®Surfaceä»¥åŠCaptureReadyCallbackå›è°ƒæ¥å»ºç«‹previewç¯å¢ƒ setupAsync(mPreviewSurface, listener);&#125; è¿™å…¶ä¸­æœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„å›è°ƒCaptureReadyCallbackï¼Œå…ˆåˆ†æsetupAsyncæ–¹æ³•ï¼š12345678910[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]private void setupAsync(final Surface previewSurface, final CaptureReadyCallback listener) &#123; mCameraHandler.post(new Runnable() &#123; @Override public void run() &#123; //å»ºç«‹previewç¯å¢ƒ setup(previewSurface, listener); &#125; &#125;);&#125; è¿™é‡Œé€šè¿‡CameraHandleræ¥postä¸€ä¸ªRunnableå¯¹è±¡ï¼Œå®ƒåªä¼šè°ƒç”¨Runnableçš„runæ–¹æ³•ï¼Œå®ƒä»ç„¶å±äºUIçº¿ç¨‹ï¼Œå¹¶æ²¡æœ‰åˆ›å»ºæ–°çš„çº¿ç¨‹ã€‚æ‰€ä»¥ï¼Œç»§ç»­åˆ†æsetupæ–¹æ³•ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]private void setup(Surface previewSurface, final CaptureReadyCallback listener) &#123; try &#123; if (mCaptureSession != null) &#123; mCaptureSession.abortCaptures(); mCaptureSession = null; &#125; List&lt;Surface&gt; outputSurfaces = new ArrayList&lt;Surface&gt;(2); outputSurfaces.add(previewSurface); outputSurfaces.add(mCaptureImageReader.getSurface()); //åˆ›å»ºCaptureSessionä¼šè¯æ¥ä¸Camera Deviceå‘é€Previewè¯·æ±‚ mDevice.createCaptureSession(outputSurfaces, new CameraCaptureSession.StateCallback() &#123; @Override public void onConfigureFailed(CameraCaptureSession session) &#123; //å¦‚æœé…ç½®å¤±è´¥ï¼Œåˆ™å›è°ƒCaptureReadyCallbackçš„onSetupFailedæ–¹æ³• listener.onSetupFailed(); &#125; @Override public void onConfigured(CameraCaptureSession session) &#123; mCaptureSession = session; mAFRegions = ZERO_WEIGHT_3A_REGION; mAERegions = ZERO_WEIGHT_3A_REGION; mZoomValue = 1f; mCropRegion = cropRegionForZoom(mZoomValue); //è°ƒç”¨repeatingPreviewæ¥å¯åŠ¨preview boolean success = repeatingPreview(null); if (success) &#123; //è‹¥å¯åŠ¨æˆåŠŸï¼Œåˆ™å›è°ƒCaptureReadyCallbackçš„onReadyForCaptureï¼Œè¡¨ç¤ºå‡†å¤‡æ‹ç…§æˆåŠŸ listener.onReadyForCapture(); &#125; else &#123; //è‹¥å¯åŠ¨å¤±è´¥ï¼Œåˆ™å›è°ƒCaptureReadyCallbackçš„onSetupFailedï¼Œè¡¨ç¤ºpreviewå»ºç«‹å¤±è´¥ listener.onSetupFailed(); &#125; &#125; @Override public void onClosed(CameraCaptureSession session) &#123; super.onClosed(session); &#125; &#125;, mCameraHandler); &#125; catch (CameraAccessException ex) &#123; Log.e(TAG, \"Could not set up capture session\", ex); listener.onSetupFailed(); &#125;&#125; é¦–å…ˆï¼Œè°ƒç”¨Deviceçš„createCaptureSessionæ–¹æ³•æ¥åˆ›å»ºä¸€ä¸ªä¼šè¯ï¼Œå¹¶å®šä¹‰äº†ä¼šè¯çš„çŠ¶æ€å›è°ƒCameraCaptureSession.StateCallback()ï¼Œå…¶ä¸­ï¼Œå½“ä¼šè¯åˆ›å»ºæˆåŠŸï¼Œåˆ™ä¼šå›è°ƒonConfigured()æ–¹æ³•,åœ¨å…¶ä¸­ï¼Œé¦–å…ˆè°ƒç”¨repeatingPreviewæ¥å¯åŠ¨previewï¼Œç„¶åå¤„ç†previewçš„ç»“æœå¹¶è°ƒç”¨å…ˆå‰å®šä¹‰çš„CaptureReadyCallbackæ¥é€šçŸ¥ç”¨æˆ·è¿›è¡ŒCaptureæ“ä½œã€‚å…ˆåˆ†ærepeatingPreviewæ–¹æ³•ï¼š 1234567891011121314151617181920[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]private boolean repeatingPreview(Object tag) &#123; try &#123; //é€šè¿‡CameraDeviceå¯¹è±¡åˆ›å»ºä¸€ä¸ªCaptureRequestçš„previewè¯·æ±‚ CaptureRequest.Builder builder = mDevice.createCaptureRequest( CameraDevice.TEMPLATE_PREVIEW); //æ·»åŠ é¢„è§ˆçš„ç›®æ ‡Surface builder.addTarget(mPreviewSurface); //è®¾ç½®é¢„è§ˆæ¨¡å¼ builder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO); addBaselineCaptureKeysToRequest(builder); //åˆ©ç”¨ä¼šè¯å‘é€è¯·æ±‚ï¼ŒmCaptureCallbackä¸º mCaptureSession.setRepeatingRequest(builder.build(), mCaptureCallback,mCameraHandler); Log.v(TAG, String.format(\"Sent repeating Preview request, zoom = %.2f\", mZoomValue)); return true; &#125; catch (CameraAccessException ex) &#123; Log.e(TAG, \"Could not access camera setting up preview.\", ex); return false; &#125;&#125; é¦–å…ˆè°ƒç”¨CameraDeviceImplçš„createCaptureRequestæ–¹æ³•åˆ›å»ºç±»å‹ä¸ºTEMPLATE_PREVIEW çš„CaptureRequestï¼Œç„¶åè°ƒç”¨CameraCaptureSessionImplçš„setRepeatingRequestæ–¹æ³•å°†æ­¤è¯·æ±‚å‘é€å‡ºå»ï¼š 1234567891011121314151617[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]Overridepublic synchronized int setRepeatingRequest(CaptureRequest request, CaptureCallback callback, Handler handler) throws CameraAccessException &#123; if (request == null) &#123; throw new IllegalArgumentException(&quot;request must not be null&quot;); &#125; else if (request.isReprocess()) &#123; throw new IllegalArgumentException(&quot;repeating reprocess requests are not supported&quot;); &#125; checkNotClosed(); handler = checkHandler(handler, callback); ... //å°†æ­¤è¯·æ±‚æ·»åŠ åˆ°å¾…å¤„ç†çš„åºåˆ—é‡Œ return addPendingSequence(mDeviceImpl.setRepeatingRequest(request,createCaptureCallbackProxy( handler, callback), mDeviceHandler));&#125; è‡³æ­¤åº”ç”¨å±‚çš„previewçš„è¯·æ±‚æµç¨‹åˆ†æç»“æŸï¼Œç»§ç»­åˆ†æå…¶ç»“æœå¤„ç†ï¼Œå¦‚æœpreviewå¼€å¯æˆåŠŸï¼Œåˆ™ä¼šå›è°ƒCaptureReadyCallbackçš„onReadyForCaptureæ–¹æ³•ï¼Œç°åœ¨åˆ†æCaptureReadyCallbackå›è°ƒï¼š 12345678910111213141516171819202122232425262728293031323334353637383940[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]new CaptureReadyCallback() &#123; @Override public void onSetupFailed() &#123; mCameraOpenCloseLock.release(); Log.e(TAG, \"Could not set up preview.\"); mMainThread.execute(new Runnable() &#123; @Override public void run() &#123; if (mCamera == null) &#123; Log.d(TAG, \"Camera closed, aborting.\"); return; &#125; mCamera.close(); mCamera = null; &#125; &#125;); &#125; @Override public void onReadyForCapture() &#123; mCameraOpenCloseLock.release(); mMainThread.execute(new Runnable() &#123; @Override public void run() &#123; Log.d(TAG, \"Ready for capture.\"); if (mCamera == null) &#123; Log.d(TAG, \"Camera closed, aborting.\"); return; &#125; // onPreviewStarted(); onReadyStateChanged(true); mCamera.setReadyStateChangedListener(CaptureModule.this); mUI.initializeZoom(mCamera.getMaxZoom()); mCamera.setFocusStateListener(CaptureModule.this); &#125; &#125;); &#125;&#125; æ ¹æ®å‰é¢çš„åˆ†æï¼Œé¢„è§ˆæˆåŠŸåä¼šå›è°ƒonReadyForCaptureæ–¹æ³•ï¼Œå®ƒä¸»è¦æ˜¯é€šçŸ¥ä¸»çº¿ç¨‹çš„çŠ¶æ€æ”¹å˜ï¼Œå¹¶è®¾ç½®Cameraçš„ReadyStateChangedListenerçš„ç›‘å¬ï¼Œå…¶å›è°ƒæ–¹æ³•å¦‚ä¸‹ï¼š 12345678[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]Overridepublic void onReadyStateChanged(boolean readyForCapture) &#123; if (readyForCapture) &#123; mAppController.getCameraAppUI().enableModeOptions(); &#125; mAppController.setShutterEnabled(readyForCapture);&#125; å¦‚ä»£ç æ‰€ç¤ºï¼Œå½“å…¶çŠ¶æ€å˜æˆå‡†å¤‡å¥½æ‹ç…§ï¼Œåˆ™å°†ä¼šè°ƒç”¨CameraActivityçš„setShutterEnabledæ–¹æ³•ï¼Œå³ä½¿èƒ½å¿«é—¨æŒ‰é”®ï¼Œæ­¤æ—¶ä¹Ÿå°±æ˜¯è¯´é¢„è§ˆæˆåŠŸç»“æŸï¼Œå¯ä»¥æŒ‰å¿«é—¨è¿›è¡Œæ‹ç…§äº†ï¼Œæ‰€ä»¥ï¼Œåˆ°è¿™é‡Œï¼Œåº”ç”¨å±‚çš„previewçš„æµç¨‹åŸºæœ¬åˆ†æå®Œæ¯•ï¼Œä¸‹å›¾æ˜¯åº”ç”¨å±‚çš„å…³é”®è°ƒç”¨çš„æµç¨‹æ—¶åºå›¾ï¼š 1.2ã€Camera2 startPreviewçš„Nativeå±‚æµç¨‹åˆ†æåˆ†æPreviewçš„Nativeçš„ä»£ç çœŸæ˜¯è´¹äº†ä¹ç‰›äºŒè™ä¹‹åŠ›ï¼Œè‹¥æœ‰åˆ†æä¸æ­£ç¡®ä¹‹å¤„ï¼Œè¯·å„ä½å¤§ç¥æŒ‡æ­£ï¼Œåœ¨ç¬¬ä¸€å°èŠ‚çš„åæ®µæœ€åä¼šè°ƒç”¨CameraDeviceImplçš„setRepeatingRequestæ–¹æ³•æ¥æäº¤è¯·æ±‚ï¼Œè€Œåœ¨android6.0æºç åˆ†æä¹‹Camera API2.0ç®€ä»‹ä¸­ï¼Œåˆ†æäº†Camera2æ¡†æ¶Java IPCé€šä¿¡ä½¿ç”¨äº†CameraDeviceUseræ¥è¿›è¡Œé€šä¿¡ï¼Œæ‰€ä»¥çœ‹Nativeå±‚çš„ICameraDeviceUserçš„onTransactæ–¹æ³•æ¥å¤„ç†è¯·æ±‚çš„æäº¤ï¼š 12345678910111213141516171819202122232425262728293031[-&gt;/frameworks/av/camera/aidl/android/hardware/camera2/ICameraDeviceUser.aidl]status_t BnCameraDeviceUser::onTransact(uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; switch(code) &#123; â€¦ //è¯·æ±‚æäº¤ case SUBMIT_REQUEST: &#123; CHECK_INTERFACE(ICameraDeviceUser, data, reply); // arg0 = request sp&lt;CaptureRequest&gt; request; if (data.readInt32() != 0) &#123; request = new CaptureRequest(); request-&gt;readFromParcel(const_cast&lt;Parcel*&gt;(&amp;data)); &#125; // arg1 = streaming (bool) bool repeating = data.readInt32(); // return code: requestId (int32) reply-&gt;writeNoException(); int64_t lastFrameNumber = -1; //å°†å®ç°BnCameraDeviceUserçš„å¯¹ä¸‹å²—çš„submitRequestæ–¹æ³•ä»£ç å†™å…¥Binder reply-&gt;writeInt32(submitRequest(request, repeating, &amp;lastFrameNumber)); reply-&gt;writeInt32(1); reply-&gt;writeInt64(lastFrameNumber); return NO_ERROR; &#125; break; ...&#125; CameraDeviceClientBaseç»§æ‰¿äº†BnCameraDeviceUserç±»ï¼Œæ‰€ä»¥CameraDeviceClientBaseç›¸å½“äºIPC Binderä¸­çš„clientï¼Œæ‰€ä»¥ä¼šè°ƒç”¨å…¶submitRequestæ–¹æ³•ï¼Œæ­¤å¤„ï¼Œè‡³äºIPC Binderé€šä¿¡åŸç†ä¸åšåˆ†æï¼Œå…¶å‚ç…§å…¶å®ƒèµ„æ–™ï¼š 1234567[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\api2\\CameraDeviceClient.cpp]status_t CameraDeviceClient::submitRequest(sp&lt;CaptureRequest&gt; request,bool streaming, /*out*/int64_t* lastFrameNumber) &#123; List&lt;sp&lt;CaptureRequest&gt; &gt; requestList; requestList.push_back(request); return submitRequestList(requestList, streaming, lastFrameNumber);&#125; ç®€å•çš„è°ƒç”¨ï¼Œç»§ç»­åˆ†æsubmitRequestListï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\api2\\CameraDeviceClient.cpp]status_t CameraDeviceClient::submitRequestList(List&lt;sp&lt;CaptureRequest&gt; &gt; requests,bool streaming, int64_t* lastFrameNumber) &#123; ... //Metadataé“¾è¡¨ List&lt;const CameraMetadata&gt; metadataRequestList; ... for (List&lt;sp&lt;CaptureRequest&gt; &gt;::iterator it = requests.begin(); it != requests.end(); ++it) &#123; sp&lt;CaptureRequest&gt; request = *it; ... //åˆå§‹åŒ–Metadataæ•°æ® CameraMetadata metadata(request-&gt;mMetadata); ... //è®¾ç½®Streamçš„å®¹é‡ Vector&lt;int32_t&gt; outputStreamIds; outputStreamIds.setCapacity(request-&gt;mSurfaceList.size()); //å¾ªç¯åˆå§‹åŒ–Surface for (size_t i = 0; i &lt; request-&gt;mSurfaceList.size(); ++i) &#123; sp&lt;Surface&gt; surface = request-&gt;mSurfaceList[i]; if (surface == 0) continue; sp&lt;IGraphicBufferProducer&gt; gbp = surface-&gt;getIGraphicBufferProducer(); int idx = mStreamMap.indexOfKey(IInterface::asBinder(gbp)); ... int streamId = mStreamMap.valueAt(idx); outputStreamIds.push_back(streamId); &#125; //æ›´æ–°æ•°æ® metadata.update(ANDROID_REQUEST_OUTPUT_STREAMS, &amp;outputStreamIds[0], outputStreamIds.size()); if (request-&gt;mIsReprocess) &#123; metadata.update(ANDROID_REQUEST_INPUT_STREAMS, &amp;mInputStream.id, 1); &#125; metadata.update(ANDROID_REQUEST_ID, &amp;requestId, /*size*/1); loopCounter++; // loopCounter starts from 1 //å‹æ ˆ metadataRequestList.push_back(metadata); &#125; mRequestIdCounter++; if (streaming) &#123; //é¢„è§ˆä¼šèµ°æ­¤æ¡é€šé“ res = mDevice-&gt;setStreamingRequestList(metadataRequestList, lastFrameNumber); if (res != OK) &#123; ... &#125; else &#123; mStreamingRequestList.push_back(requestId); &#125; &#125; else &#123; //Captureç­‰èµ°æ­¤æ¡é€šé“ res = mDevice-&gt;captureList(metadataRequestList, lastFrameNumber); if (res != OK) &#123; ... &#125; &#125; if (res == OK) &#123; return requestId; &#125; return res;&#125; setStreamingRequestListå’ŒcaptureListæ–¹æ³•éƒ½è°ƒç”¨äº†submitRequestsHelperæ–¹æ³•ï¼Œåªæ˜¯ä»–ä»¬çš„repeatingå‚æ•°ä¸€ä¸ªture,ä¸€ä¸ªä¸ºfalseï¼Œè€Œæœ¬èŠ‚åˆ†æçš„previewè°ƒç”¨çš„æ˜¯setStreamingRequestListæ–¹æ³•ï¼Œå¹¶ä¸”API2.0ä¸‹Deviceçš„å®ç°ä¸ºCamera3Deviceï¼Œæ‰€ä»¥çœ‹å®ƒçš„submitRequestsHelperå®ç°ï¼š 123456789101112131415161718[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]status_t Camera3Device::submitRequestsHelper(const List&lt;const CameraMetadata&gt; &amp;requests, bool repeating,/*out*/int64_t *lastFrameNumber) &#123; ... RequestList requestList; //åœ¨è¿™é‡Œé¢ä¼šè¿›è¡ŒCaptureRequestçš„åˆ›å»ºï¼Œå¹¶è°ƒç”¨configureStreamLockedè¿›è¡Œstreamçš„é…ç½®ï¼Œä¸»è¦æ˜¯è®¾ç½®äº†ä¸€ä¸ªå›è°ƒcaptureResultCbï¼Œå³åé¢è¦åˆ†æçš„é‡è¦çš„å›è°ƒ res = convertMetadataListToRequestListLocked(requests, /*out*/&amp;requestList); ... if (repeating) &#123; //çœ¼ç†Ÿä¸ï¼Œè¿™ä¸ªæ–¹æ³•åå’Œåº”ç”¨å±‚ä¸­CameraDeviceçš„setRepeatingRequestsä¸€æ · res = mRequestThread-&gt;setRepeatingRequests(requestList, lastFrameNumber); &#125; else &#123; //ä¸éœ€é‡å¤ï¼Œå³repeatingä¸ºfalseæ—¶ï¼Œè°ƒç”¨æ­¤æ–¹æ³•æ¥è®²è¯·æ±‚æäº¤ res = mRequestThread-&gt;queueRequestList(requestList, lastFrameNumber); &#125; ... return res;&#125; ä»ä»£ç å¯çŸ¥ï¼Œåœ¨Camera3Deviceé‡Œåˆ›å»ºäº†è¦ç»™RequestThreadçº¿ç¨‹ï¼Œè°ƒç”¨å®ƒçš„setRepeatingRequestsæˆ–è€…queueRequestListæ–¹æ³•æ¥å°†åº”ç”¨å±‚å‘é€è¿‡æ¥çš„Requestæäº¤ï¼Œç»§ç»­çœ‹setRepeatingRequestsæ–¹æ³•ï¼š 1234567891011121314151617[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]status_t Camera3Device::RequestThread::setRepeatingRequests(const RequestList &amp;requests, /*out*/int64_t *lastFrameNumber) &#123; Mutex::Autolock l(mRequestLock); if (lastFrameNumber != NULL) &#123; *lastFrameNumber = mRepeatingLastFrameNumber; &#125; mRepeatingRequests.clear(); //å°†å…¶æ’å…¥mRepeatingRequesté“¾è¡¨ mRepeatingRequests.insert(mRepeatingRequests.begin(), requests.begin(), requests.end()); unpauseForNewRequests(); mRepeatingLastFrameNumber = NO_IN_FLIGHT_REPEATING_FRAMES; return OK;&#125; è‡³æ­¤ï¼ŒNativeå±‚çš„previewè¿‡ç¨‹åŸºæœ¬åˆ†æç»“æŸï¼Œä¸‹é¢çš„å·¥ä½œå°†ä¼šäº¤ç»™Camera HALå±‚æ¥å¤„ç†ï¼Œå…ˆç»™å‡ºNativeå±‚çš„è°ƒç”¨æ—¶åºå›¾ï¼š 1.3ã€Camera2 startPreviewçš„HALå±‚æµç¨‹åˆ†ææœ¬èŠ‚å°†ä¸å†å¯¹Cameraçš„HALå±‚çš„åˆå§‹åŒ–ä»¥åŠç›¸å…³é…ç½®è¿›è¡Œåˆ†æï¼Œåªå¯¹previewç­‰ç›¸å…³æµç¨‹ä¸­çš„frame metadataçš„å¤„ç†æµç¨‹è¿›è¡Œåˆ†æï¼Œå…·ä½“çš„CameraHALåˆ†æè¯·å‚è€ƒå‰ä¸€ç¯‡åˆ†æï¼Œåœ¨ç¬¬äºŒå°èŠ‚çš„submitRequestsHelperæ–¹æ³•ä¸­è°ƒç”¨convertMetadataListToRequestListLockedçš„æ—¶å€™ä¼šè¿›è¡ŒCaptureRequestçš„åˆ›å»ºï¼Œå¹¶è°ƒç”¨configureStreamLockedè¿›è¡Œstreamçš„é…ç½®ï¼Œä¸»è¦æ˜¯è®¾ç½®äº†ä¸€ä¸ªå›è°ƒcaptureResultCbï¼Œæ‰€ä»¥Nativeå±‚åœ¨requestæäº¤åï¼Œä¼šå›è°ƒæ­¤captureResultCbæ–¹æ³•ï¼Œé¦–å…ˆåˆ†æcaptureResultCbï¼š 123456789101112131415161718192021[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]void QCamera3HardwareInterface::captureResultCb(mm_camera_super_buf_t *metadata_buf, camera3_stream_buffer_t *buffer, uint32_t frame_number)&#123; if (metadata_buf) &#123; if (mBatchSize) &#123; //æ‰¹å¤„ç†æ¨¡å¼ï¼Œä½†ä»£ç ä¹Ÿæ˜¯å¾ªç¯è°ƒç”¨handleMetadataWithLockæ–¹æ³• handleBatchMetadata(metadata_buf, true /* free_and_bufdone_meta_buf */); &#125; else &#123; /* mBatchSize = 0 */ pthread_mutex_lock(&amp;mMutex); //å¤„ç†å…ƒæ•°æ® handleMetadataWithLock(metadata_buf, true /* free_and_bufdone_meta_buf */); pthread_mutex_unlock(&amp;mMutex); &#125; &#125; else &#123; pthread_mutex_lock(&amp;mMutex); handleBufferWithLock(buffer, frame_number); pthread_mutex_unlock(&amp;mMutex); &#125; return;&#125; ä¸€ç§æ˜¯é€šè¿‡å¾ªç¯æ¥è¿›è¡Œå…ƒæ•°æ®çš„æ‰¹å¤„ç†ï¼Œå¦ä¸€ç§æ˜¯ç›´æ¥è¿›è¡Œå…ƒæ•°æ®çš„å¤„ç†ï¼Œä½†æ˜¯æ‰¹å¤„ç†æœ€ç»ˆä¹Ÿæ˜¯å¾ªç¯è°ƒç”¨handleMetadataWithLockæ¥å¤„ç†ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]void QCamera3HardwareInterface::handleMetadataWithLock(mm_camera_super_buf_t *metadata_buf, bool free_and_bufdone_meta_buf)&#123; ... //Partial result on process_capture_result for timestamp if (urgent_frame_number_valid) &#123; ... for (List&lt;PendingRequestInfo&gt;::iterator i =mPendingRequestsList.begin(); i != mPendingRequestsList.end(); i++) &#123; ... if (i-&gt;frame_number == urgent_frame_number &amp;&amp;i-&gt;bUrgentReceived == 0) &#123; camera3_capture_result_t result; memset(&amp;result, 0, sizeof(camera3_capture_result_t)); i-&gt;partial_result_cnt++; i-&gt;bUrgentReceived = 1; //æå–3Aæ•°æ® result.result =translateCbUrgentMetadataToResultMetadata(metadata); ... //å¯¹Capture Resultè¿›è¡Œå¤„ç† mCallbackOps-&gt;process_capture_result(mCallbackOps, &amp;result); //é‡Šæ”¾camera_metadata_t free_camera_metadata((camera_metadata_t *)result.result); break; &#125; &#125; &#125; ... for (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin(); i != mPendingRequestsList.end() &amp;&amp; i-&gt;frame_number &lt;= frame_number;) &#123; camera3_capture_result_t result; memset(&amp;result, 0, sizeof(camera3_capture_result_t)); ... if (i-&gt;frame_number &lt; frame_number) &#123; //æ¸…ç©ºæ•°æ®ç»“æ„ camera3_notify_msg_t notify_msg; memset(&amp;notify_msg, 0, sizeof(camera3_notify_msg_t)); //å®šä¹‰æ¶ˆæ¯ç±»å‹ notify_msg.type = CAMERA3_MSG_SHUTTER; notify_msg.message.shutter.frame_number = i-&gt;frame_number; notify_msg.message.shutter.timestamp = (uint64_t)capture_time (urgent_frame_number - i-&gt;frame_number) * NSEC_PER_33MSEC; //è°ƒç”¨å›è°ƒé€šçŸ¥åº”ç”¨å±‚å‘ç”ŸCAMERA3_MSG_SHUTTERæ¶ˆæ¯ mCallbackOps-&gt;notify(mCallbackOps, &amp;notify_msg); ... CameraMetadata dummyMetadata; //æ›´æ–°å…ƒæ•°æ® dummyMetadata.update(ANDROID_SENSOR_TIMESTAMP, &amp;i-&gt;timestamp, 1); dummyMetadata.update(ANDROID_REQUEST_ID, &amp;(i-&gt;request_id), 1); //å¾—åˆ°å…ƒæ•°æ®é‡Šæ”¾ç»“æœ result.result = dummyMetadata.release(); &#125; else &#123; camera3_notify_msg_t notify_msg; memset(&amp;notify_msg, 0, sizeof(camera3_notify_msg_t)); // Send shutter notify to frameworks notify_msg.type = CAMERA3_MSG_SHUTTER; ... //ä»HALä¸­è·å¾—Metadata result.result = translateFromHalMetadata(metadata, i-&gt;timestamp, i-&gt;request_id, i-&gt;jpegMetadata, i-&gt;pipeline_depth, i-&gt;capture_intent); saveExifParams(metadata); if (i-&gt;blob_request) &#123; ... if (enabled &amp;&amp; metadata-&gt;is_tuning_params_valid) &#123; //å°†Metadataå¤åˆ¶åˆ°æ–‡ä»¶ dumpMetadataToFile(metadata-&gt;tuning_params, mMetaFrameCount, enabled, \"Snapshot\",frame_number); &#125; mPictureChannel-&gt;queueReprocMetadata(metadata_buf); &#125; else &#123; // Return metadata buffer if (free_and_bufdone_meta_buf) &#123; mMetadataChannel-&gt;bufDone(metadata_buf); free(metadata_buf); &#125; &#125; &#125; ... &#125;&#125; å…¶ä¸­ï¼Œé¦–å…ˆä¼šè°ƒç”¨å›è°ƒçš„process_capture_resultæ–¹æ³•æ¥å¯¹Capture Resultè¿›è¡Œå¤„ç†ï¼Œç„¶åä¼šè°ƒç”¨å›è°ƒçš„notifyæ–¹æ³•æ¥å‘é€ä¸€ä¸ªCAMERA3_MSG_SHUTTERæ¶ˆæ¯ï¼Œè€Œprocess_capture_resultæ‰€å¯¹åº”çš„å®ç°å…¶å®å°±æ˜¯Camera3Deviceçš„processCaptureResultæ–¹æ³•ï¼Œå…ˆåˆ†æprocessCaptureResultï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]void Camera3Device::processCaptureResult(const camera3_capture_result *result) &#123; ... //å¯¹äºHAL3.2+,å¦‚æœHALä¸æ”¯æŒpartialï¼Œå½“metadataè¢«åŒ…å«åœ¨resultä¸­æ—¶ï¼Œå®ƒå¿…é¡»å°†partial_resultè®¾ç½®ä¸º1 ... &#123; Mutex::Autolock l(mInFlightLock); ssize_t idx = mInFlightMap.indexOfKey(frameNumber); ... InFlightRequest &amp;request = mInFlightMap.editValueAt(idx); if (result-&gt;partial_result != 0) request.resultExtras.partialResultCount = result-&gt;partial_result; // æ£€æŸ¥ç»“æœæ˜¯å¦åªæœ‰partial metadata if (mUsePartialResult &amp;&amp; result-&gt;result != NULL) &#123; if (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;//HALç‰ˆæœ¬é«˜äº3.2 if (result-&gt;partial_result &gt; mNumPartialResults || result-&gt;partial_result &lt; 1) &#123; //Logæ˜¾ç¤ºé”™è¯¯ return; &#125; isPartialResult = (result-&gt;partial_result &lt; mNumPartialResults); if (isPartialResult) &#123; //å°†ç»“æœåŠ å…¥åˆ°è¯·æ±‚çš„ç»“æœé›†ä¸­ request.partialResult.collectedResult.append(result-&gt;result); &#125; &#125; else &#123;//ä½äº3.2 ... &#125; if (isPartialResult) &#123; // Fire off a 3A-only result if possible if (!request.partialResult.haveSent3A) &#123; request.partialResult.haveSent3A =processPartial3AResult(frameNumber, request.partialResult.collectedResult,request.resultExtras); &#125; &#125; &#125; ... if (result-&gt;result != NULL &amp;&amp; !isPartialResult) &#123; if (shutterTimestamp == 0) &#123; request.pendingMetadata = result-&gt;result; request.partialResult.collectedResult = collectedPartialResult; &#125; else &#123; CameraMetadata metadata; metadata = result-&gt;result; //å‘é€Capture Result sendCaptureResult(metadata, request.resultExtras, collectedPartialResult, frameNumber, hasInputBufferInRequest,request.aeTriggerCancelOverride); &#125; &#125; //ç»“æœå¤„ç†å¥½äº†ï¼Œå°†è¯·æ±‚ç§»é™¤ removeInFlightRequestIfReadyLocked(idx); &#125; // scope for mInFlightLock ...&#125; ç”±ä»£ç å¯çŸ¥ï¼Œå®ƒä¼šå¤„ç†å±€éƒ¨çš„æˆ–è€…å…¨éƒ¨çš„metadataæ•°æ®ï¼Œæœ€åå¦‚æœresultä¸ä¸ºç©ºï¼Œä¸”å¾—åˆ°çš„æ˜¯è¯·æ±‚å¤„ç†çš„å…¨éƒ¨æ•°æ®ï¼Œåˆ™ä¼šè°ƒç”¨sendCaptureResultæ–¹æ³•æ¥å°†è¯·æ±‚ç»“æœå‘é€å‡ºå»ï¼š 12345678910111213141516171819202122232425262728293031323334353637[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]void Camera3Device::sendCaptureResult(CameraMetadata &amp;pendingMetadata,CaptureResultExtras &amp;resultExtras,CameraMetadata &amp;collectedPartialResult,uint32_t frameNumber,bool reprocess, const AeTriggerCancelOverride_t &amp;aeTriggerCancelOverride) &#123; if (pendingMetadata.isEmpty())//å¦‚æœæ•°æ®ä¸ºç©ºï¼Œç›´æ¥è¿”å› return; ... CaptureResult captureResult; captureResult.mResultExtras = resultExtras; captureResult.mMetadata = pendingMetadata; //æ›´æ–°metadata if (captureResult.mMetadata.update(ANDROID_REQUEST_FRAME_COUNT(int32_t*)&amp;frameNumber, 1) != OK) &#123; SET_ERR(\"Failed to set frame# in metadata (%d)\",frameNumber); return; &#125; else &#123; ... &#125; // Append any previous partials to form a complete result if (mUsePartialResult &amp;&amp; !collectedPartialResult.isEmpty()) &#123; captureResult.mMetadata.append(collectedPartialResult); &#125; //æ’åº captureResult.mMetadata.sort(); // Check that there's a timestamp in the result metadata camera_metadata_entry entry = captureResult.mMetadata.find(ANDROID_SENSOR_TIMESTAMP); ... overrideResultForPrecaptureCancel(&amp;captureResult.mMetadata, aeTriggerCancelOverride); // æœ‰æ•ˆçš„ç»“æœï¼Œå°†å…¶æ’å…¥Buffer List&lt;CaptureResult&gt;::iterator queuedResult =mResultQueue.insert(mResultQueue.end(), CaptureResult(captureResult)); ... mResultSignal.signal();&#125; æœ€åï¼Œå®ƒå°†Capture Resultæ’å…¥äº†ç»“æœé˜Ÿåˆ—ï¼Œå¹¶é‡Šæ”¾äº†ç»“æœçš„ä¿¡å·é‡ï¼Œæ‰€ä»¥åˆ°è¿™é‡Œï¼ŒCapture Resultå¤„ç†æˆåŠŸï¼Œä¸‹é¢åˆ†æå‰é¢çš„notifyå‘é€CAMERA3_MSG_SHUTTERæ¶ˆæ¯ï¼š 1234567891011121314151617181920212223[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]void Camera3Device::notify(const camera3_notify_msg *msg) &#123; NotificationListener *listener; &#123; Mutex::Autolock l(mOutputLock); listener = mListener; &#125; ... switch (msg-&gt;type) &#123; case CAMERA3_MSG_ERROR: &#123; notifyError(msg-&gt;message.error, listener); break; &#125; case CAMERA3_MSG_SHUTTER: &#123; notifyShutter(msg-&gt;message.shutter, listener); break; &#125; default: SET_ERR(\"Unknown notify message from HAL: %d\", msg-&gt;type); &#125;&#125; å®ƒè°ƒç”¨äº†notifyShutteræ–¹æ³•ï¼š123456789101112131415161718192021222324252627282930[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]void Camera3Device::notifyShutter(const camera3_shutter_msg_t &amp;msg, NotificationListener *listener) &#123; ... // Set timestamp for the request in the in-flight tracking // and get the request ID to send upstream &#123; Mutex::Autolock l(mInFlightLock); idx = mInFlightMap.indexOfKey(msg.frame_number); if (idx &gt;= 0) &#123; InFlightRequest &amp;r = mInFlightMap.editValueAt(idx); // Call listener, if any if (listener != NULL) &#123; //è°ƒç”¨ç›‘å¬çš„notifyShutteræ³•å›½æ³• listener-&gt;notifyShutter(r.resultExtras, msg.timestamp); &#125; ... //å°†å¾…å¤„ç†çš„resultå‘é€åˆ°Buffer sendCaptureResult(r.pendingMetadata, r.resultExtras, r.partialResult.collectedResult, msg.frame_number, r.hasInputBuffer, r.aeTriggerCancelOverride); returnOutputBuffers(r.pendingOutputBuffers.array(), r.pendingOutputBuffers.size(), r.shutterTimestamp); r.pendingOutputBuffers.clear(); removeInFlightRequestIfReadyLocked(idx); &#125; &#125; ...&#125; é¦–å…ˆå®ƒä¼šé€šçŸ¥listener previewæˆåŠŸï¼Œæœ€åä¼šè°ƒç”¨sendCaptureResultå°†ç»“æœåŠ å…¥åˆ°ç»“æœé˜Ÿåˆ—ã€‚å®ƒä¼šè°ƒç”¨listenerçš„notifyShutteræ–¹æ³•ï¼Œæ­¤å¤„çš„listenerå…¶å®æ˜¯CameraDeviceClientç±»ï¼Œæ‰€ä»¥ä¼šè°ƒç”¨CameraDeviceClientç±»çš„notifyShutteræ–¹æ³•ï¼š 123456789[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\api2\\CameraDeviceClient.cpp]void CameraDeviceClient::notifyShutter(const CaptureResultExtras&amp; resultExtras,nsecs_t timestamp) &#123; // Thread safe. Don't bother locking. sp&lt;ICameraDeviceCallbacks&gt; remoteCb = getRemoteCallback(); if (remoteCb != 0) &#123; //è°ƒç”¨åº”ç”¨å±‚çš„å›è°ƒ(CaptureCallbackçš„onCaptureStartedæ–¹æ³•) remoteCb-&gt;onCaptureStarted(resultExtras, timestamp); &#125;&#125; æ­¤å¤„çš„ICameraDeviceCallbackså¯¹åº”çš„æ˜¯Javaå±‚çš„CameraDeviceImpl.javaä¸­çš„å†…éƒ¨ç±»CameraDeviceCallbacksï¼Œæ‰€ä»¥ä¼šè°ƒç”¨å®ƒçš„onCaptureStartedæ–¹æ³•ï¼š123456789101112131415161718192021222324[-&gt;\\frameworks\\base\\core\\java\\android\\hardware\\camera2\\impl\\CameraDeviceImpl.java]@Overridepublic void onCaptureStarted(final CaptureResultExtras resultExtras, final long timestamp) &#123; int requestId = resultExtras.getRequestId(); final long frameNumber = resultExtras.getFrameNumber(); final CaptureCallbackHolder holder; synchronized(mInterfaceLock) &#123; if (mRemoteDevice == null) return; // Camera already closed // Get the callback for this frame ID, if there is one holder = CameraDeviceImpl.this.mCaptureCallbackMap.get(requestId); ... // Dispatch capture start notice holder.getHandler().post(new Runnable() &#123; @Override public void run() &#123; if (!CameraDeviceImpl.this.isClosed()) &#123; holder.getCallback().onCaptureStarted(CameraDeviceImpl.this,holder.getRequest( resultExtras.getSubsequenceId()),timestamp, frameNumber); &#125; &#125; &#125;); &#125;&#125; å®ƒä¼šè°ƒç”¨OneCameraImpl.javaä¸­çš„mCaptureCallbackçš„onCaptureStartedæ–¹æ³•ï¼š12345678910111213[-&gt;\\frameworks\\base\\core\\java\\android\\hardware\\camera2\\impl\\CameraDeviceImpl.java]//Common listener for preview frame metadata. private final CameraCaptureSession.CaptureCallback mCaptureCallback = new CameraCaptureSession.CaptureCallback() &#123; @Override public void onCaptureStarted(CameraCaptureSession session,CaptureRequest request, long timestamp,long frameNumber) &#123; if (request.getTag() == RequestTag.CAPTURE&amp;&amp; mLastPictureCallback != null) &#123; mLastPictureCallback.onQuickExpose(); &#125; &#125; â€¦&#125; cameraå·¥ä½œæ—¶ï¼Œå­˜åœ¨äº†ï¼•ä¸­æµå¤„ç†çº¿ç¨‹å’Œä¸€ä¸ªä¸“é—¨å‘halå‘é€è¯·æ±‚çš„requestçº¿ç¨‹ã€‚çº¿ç¨‹ä¹‹é—´é€šè¿‡ä¿¡å·æ¥åŒæ­¥ï¼Œç¨ä¸æ³¨æ„å°±æä¸æ˜ç™½ä»£ç æ˜¯å¦‚ä½•è¿è¡Œçš„äº†ã€‚å…¶ä¸­å¾ˆå®¹æ˜“è®©æˆ‘ä»¬å¿½è§†çš„å°±æ˜¯åœ¨æµå‘é€ä¹‹å‰çš„parent-&gt;registerInFlight()è¯¥æ“ä½œå°†å½“å‰çš„è¯·æ±‚ä¿å­˜åˆ°ä¸€ä¸ªæ•°ç»„(å¯ä»¥ç†è§£æˆ)ä¸­ã€‚è¿™ä¸ªæ•°ç»„å¯¹è±¡åœ¨åç»­å›å¸§æ“ä½œä¸­ï¼Œä¼šå°†ç›¸åº”å¸§çš„shutter,æ—¶é—´æˆ³ä¿¡æ¯å¡«å……åˆ°å¯¹åº”çš„requestä¸­ï¼Œç´§æ¥ç€å°±æŠŠå¯¹åº”å¸§çš„ä¿¡æ¯è¿”å›ç»™appã€‚å¥½äº†å…ˆåˆ°è¿™å§ï¼Œä¸‹ä¸€ç¯‡åˆ†æCamera recordingæµç¨‹ã€‚ æ³¨æ„ï¼šCapture,previewä»¥åŠautoFocuséƒ½æ˜¯ä½¿ç”¨çš„è¿™ä¸ªå›è°ƒï¼Œè€ŒCaptureè°ƒç”¨çš„æ—¶å€™ï¼Œå…¶RequestTagä¸ºCAPTUREï¼Œè€ŒautoFocusçš„æ—¶å€™ä¸ºTAP_TO_FOCUS,è€Œpreviewè¯·æ±‚æ—¶æ²¡æœ‰å¯¹RequestTagè¿›è¡Œè®¾ç½®ï¼Œæ‰€ä»¥å›è°ƒåˆ°onCaptureStartedæ–¹æ³•æ—¶ï¼Œä¸éœ€è¦è¿›è¡Œå¤„ç†ï¼Œä½†æ˜¯åˆ°æ­¤æ—¶ï¼Œpreviewå·²ç»å¯åŠ¨æˆåŠŸï¼Œå¯ä»¥è¿›è¡Œé¢„è§ˆäº†ï¼Œå…¶æ•°æ®éƒ½åœ¨bufferé‡Œã€‚æ‰€ä»¥åˆ°æ­¤æ—¶ï¼Œpreviewçš„æµç¨‹å…¨éƒ¨åˆ†æç»“æŸï¼Œä¸‹é¢ç»™å‡ºHALå±‚ä¸Šçš„æµç¨‹æ—¶åºå›¾ ï¼ˆäºŒï¼‰ã€Camera System takePictureæµç¨‹åˆ†æä¸TakePictureæ¯æ¯ç›¸å…³çš„ä¸»è¦æœ‰4ä¸ªçº¿ç¨‹CaptureSequencer,JpegProcessor,Camera3Device::RequestThread,FrameProcessorBaseå¦‚ä¸‹é¢çš„ä»£ç å¯ä»¥å‘ç°ï¼Œåœ¨Camera2clientå¯¹è±¡åˆå§‹åŒ–åï¼Œå·²ç»æœ‰ï¼“ä¸ªçº¿ç¨‹å·²ç»runèµ·æ¥äº†ï¼Œè¿˜æœ‰æœ‰ä¸€ä¸ªRequestThreadçº¿ç¨‹ä¼šåœ¨Camera3Deviceåˆå§‹åŒ–æ—¶åˆ›å»ºçš„ã€‚ä»–ä»¬å·¥ä½œéå¸¸å¯†åˆ‡ï¼Œå¦‚ä¸‹å¤§æ¦‚ç”»äº†ä¸€ä¸ªä»–ä»¬çš„å·¥ä½œæœºåˆ¶ï¼Œï¼”ä¸ªçº¿ç¨‹éƒ½æ˜¯é€šè¿‡Conditonæ¡ä»¶å˜é‡æ¥åŒæ­¥çš„ã€‚ å‰é¢åˆ†æpreviewçš„æ—¶å€™ï¼Œå½“é¢„è§ˆæˆåŠŸåï¼Œä¼šä½¿èƒ½ShutterButtonï¼Œå³å¯ä»¥è¿›è¡Œæ‹ç…§ï¼Œå®šä½åˆ°ShutterButtonçš„ç›‘å¬äº‹ä»¶ä¸ºonShutterButtonClickæ–¹æ³•ï¼š 12345678910111213141516171819202122[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]@Overridepublic void onShutterButtonClick() &#123; //Cameraæœªæ‰“å¼€ if (mCamera == null) &#123; return; &#125; int countDownDuration = mSettingsManager.getInteger(SettingsManager .SCOPE_GLOBAL,Keys.KEY_COUNTDOWN_DURATION); if (countDownDuration &gt; 0) &#123; // å¼€å§‹å€’è®¡æ—¶ mAppController.getCameraAppUI().transitionToCancel(); mAppController.getCameraAppUI().hideModeOptions(); mUI.setCountdownFinishedListener(this); mUI.startCountdown(countDownDuration); // Will take picture later via listener callback. &#125; else &#123; //å³åˆ»æ‹ç…§ takePictureNow(); &#125;&#125; é¦–å…ˆï¼Œè¯»å–Cameraçš„é…ç½®ï¼Œåˆ¤æ–­é…ç½®æ˜¯å¦éœ€è¦å»¶æ—¶æ‹ç…§ï¼Œæ­¤å¤„åˆ†æä¸éœ€å»¶æ—¶çš„æƒ…å†µï¼Œå³è°ƒç”¨takePictureNowæ–¹æ³•ï¼š 123456789101112131415161718192021[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]private void takePictureNow() &#123; if (mCamera == null) &#123; Log.i(TAG, \"Not taking picture since Camera is closed.\"); return; &#125; //åˆ›å»ºCaptureä¼šè¯å¹¶å¼€å¯ä¼šè¯ CaptureSession session = createAndStartCaptureSession(); //è·å–Cameraçš„æ–¹å‘ int orientation = mAppController.getOrientationManager() .getDeviceOrientation().getDegrees(); //åˆå§‹åŒ–å›¾ç‰‡å‚æ•° PhotoCaptureParameters params = new PhotoCaptureParameters( session.getTitle(), orientation, session.getLocation(), mContext.getExternalCacheDir(), this, mPictureSaverCallback, mHeadingSensor.getCurrentHeading(), mZoomValue, 0); //è£…é…Session decorateSessionAtCaptureTime(session); //æ‹ç…§ mCamera.takePicture(params, session);&#125; å®ƒé¦–å…ˆè°ƒç”¨createAndStartCaptureSessionæ¥åˆ›å»ºä¸€ä¸ªCaptureSessionå¹¶ä¸”å¯åŠ¨ä¼šè¯,è¿™é‡Œå¹¶ä¸”ä¼šè¿›è¡Œåˆå§‹å‚æ•°çš„è®¾ç½®ï¼Œè­¬å¦‚è®¾ç½®CaptureModule(æ­¤å¤„å®å‚ä¸ºthis)ä¸ºå›¾ç‰‡å¤„ç†çš„å›è°ƒ(åé¢å†åˆ†æ)ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]private CaptureSession createAndStartCaptureSession() &#123; //è·å–ä¼šè¯æ—¶é—´ long sessionTime = getSessionTime(); //å½“å‰ä½ç½® Location location = mLocationManager.getCurrentLocation(); //è®¾ç½®picture name String title = CameraUtil.instance().createJpegName(sessionTime); //åˆ›å»ºä¼šè¯ CaptureSession session = getServices().getCaptureSessionManager() .createNewSession(title, sessionTime, location); //å¼€å¯ä¼šè¯ session.startEmpty(new CaptureStats(mHdrPlusEnabled),new Size( (int) mPreviewArea.width(), (int) mPreviewArea.height())); return session;&#125;``` é¦–å…ˆï¼Œè·å–ä¼šè¯çš„ç›¸å…³å‚æ•°ï¼ŒåŒ…æ‹¬ä¼šè¯æ—¶é—´ï¼Œæ‹ç…§çš„ç…§ç‰‡åå­—ä»¥åŠä½ç½®ä¿¡æ¯ç­‰ï¼Œç„¶åè°ƒç”¨Sessionç®¡ç†æ¥åˆ›å»ºCaptureSessionï¼Œæœ€åå°†æ­¤CaptureSessionå¯åŠ¨ã€‚åˆ°è¿™é‡Œï¼Œä¼šè¯å°±åˆ›å»ºå¹¶å¯åŠ¨äº†ï¼Œæ‰€ä»¥æ¥ç€åˆ†æä¸Šé¢çš„æ‹ç…§æµç¨‹ï¼Œå®ƒä¼šè°ƒç”¨OneCameraImplçš„takePictureæ–¹æ³•æ¥è¿›è¡Œæ‹ç…§ï¼š``` java[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]@Overridepublic void takePicture(final PhotoCaptureParameters params, final CaptureSession session) &#123; ... // é™¤éæ‹ç…§å·²ç»è¿”å›ï¼Œå¦åˆ™å°±å¹¿æ’­ä¸€ä¸ªæœªå‡†å¤‡å¥½çŠ¶æ€çš„å¹¿æ’­ï¼Œå³ç­‰å¾…æœ¬æ¬¡æ‹ç…§ç»“æŸ broadcastReadyState(false); //åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ mTakePictureRunnable = new Runnable() &#123; @Override public void run() &#123; //æ‹ç…§ takePictureNow(params, session); &#125; &#125;; //è®¾ç½®å›è°ƒï¼Œæ­¤å›è°ƒåé¢å°†åˆ†æï¼Œå®ƒå…¶å®å°±æ˜¯CaptureModule,å®ƒå®ç°äº†PictureCallback mLastPictureCallback = params.callback; mTakePictureStartMillis = SystemClock.uptimeMillis(); //å¦‚æœéœ€è¦è‡ªåŠ¨èšç„¦ if (mLastResultAFState == AutoFocusState.ACTIVE_SCAN) &#123; mTakePictureWhenLensIsStopped = true; &#125; else &#123; //æ‹ç…§ takePictureNow(params, session); &#125;&#125; åœ¨æ‹ç…§é‡Œï¼Œé¦–å…ˆå¹¿æ’­ä¸€ä¸ªæœªå‡†å¤‡å¥½çš„çŠ¶æ€å¹¿æ’­ï¼Œç„¶åè¿›è¡Œæ‹ç…§çš„å›è°ƒè®¾ç½®ï¼Œå¹¶ä¸”åˆ¤æ–­æ˜¯å¦æœ‰è‡ªåŠ¨èšç„¦ï¼Œå¦‚æœæ˜¯åˆ™å°†mTakePictureWhenLensIsStopped è®¾ä¸ºtureï¼Œå³å³åˆ»æ‹ç…§è¢«åœæ­¢äº†ï¼Œå¦åˆ™åˆ™è°ƒç”¨OneCameraImplçš„takePictureNowæ–¹æ³•æ¥å‘èµ·æ‹ç…§è¯·æ±‚ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]public void takePictureNow(PhotoCaptureParameters params, CaptureSession session) &#123; long dt = SystemClock.uptimeMillis() - mTakePictureStartMillis; try &#123; // æ„é€ JPEGå›¾ç‰‡æ‹ç…§çš„è¯·æ±‚ CaptureRequest.Builder builder = mDevice.createCaptureRequest( CameraDevice.TEMPLATE_STILL_CAPTURE); builder.setTag(RequestTag.CAPTURE); addBaselineCaptureKeysToRequest(builder); // Enable lens-shading correction for even better DNGs. if (sCaptureImageFormat == ImageFormat.RAW_SENSOR) &#123; builder.set(CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE, CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE_ON); &#125; else if (sCaptureImageFormat == ImageFormat.JPEG) &#123; builder.set(CaptureRequest.JPEG_QUALITY, JPEG_QUALITY); .getJpegRotation(params.orientation, mCharacteristics)); &#125; //ç”¨äºpreviewçš„æ§ä»¶ builder.addTarget(mPreviewSurface); //ç”¨äºå›¾ç‰‡æ˜¾ç¤ºçš„æ§ä»¶ builder.addTarget(mCaptureImageReader.getSurface()); CaptureRequest request = builder.build(); if (DEBUG_WRITE_CAPTURE_DATA) &#123; final String debugDataDir = makeDebugDir(params.debugDataFolder, \"normal_capture_debug\"); Log.i(TAG, \"Writing capture data to: \" + debugDataDir); CaptureDataSerializer.toFile(\"Normal Capture\", request, new File(debugDataDir,\"capture.txt\")); &#125; //æ‹ç…§ï¼ŒmCaptureCallbackä¸ºå›è°ƒ mCaptureSession.capture(request, mCaptureCallback, mCameraHandler); &#125; catch (CameraAccessException e) &#123; Log.e(TAG, \"Could not access camera for still image capture.\"); broadcastReadyState(true); params.callback.onPictureTakingFailed(); return; &#125; synchronized (mCaptureQueue) &#123; mCaptureQueue.add(new InFlightCapture(params, session)); &#125;&#125; ä¸previewç±»ä¼¼ï¼Œéƒ½æ˜¯é€šè¿‡CaptureRequestæ¥ä¸Cameraè¿›è¡Œé€šä¿¡çš„ï¼Œé€šè¿‡sessionçš„captureæ¥è¿›è¡Œæ‹ç…§ï¼Œå¹¶è®¾ç½®æ‹ç…§çš„å›è°ƒå‡½æ•°ä¸ºmCaptureCallbackï¼š 12345678[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]@Overridepublic synchronized int capture(CaptureRequest request,CaptureCallback callback,Handler handler)throws CameraAccessException&#123; ... handler = checkHandler(handler,callback); return addPendingSequence(mDeviceImpl.capture(request,createCaptureCallbackProxy( handler,callback),mDeviceHandler));&#125; ä»£ç ä¸previewä¸­çš„ç±»ä¼¼ï¼Œéƒ½æ˜¯å°†è¯·æ±‚åŠ å…¥åˆ°å¾…å¤„ç†çš„è¯·æ±‚é›†ï¼Œç°åœ¨çœ‹CaptureCallbackå›è°ƒï¼š 1234567891011121314151617181920212223242526272829303132333435[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]private final CameraCaptureSession.CaptureCallback mCaptureCallback = new CameraCaptureSession.CaptureCallback()&#123; @Override public void onCaptureStarted(CameraCaptureSession session,CaptureRequest request,long timestamp,long frameNumber)&#123; //ä¸previewç±»ä¼¼ if(request.getTag() == RequestTag.CAPTURE&amp;&amp;mLastPictureCallback!=null)&#123; mLastPictureCallback.onQuickExpose(); &#125; &#125; ... @Override public void onCaptureCompleted(CameraCaptureSession session,CaptureRequest request ,TotalCaptureResult result)&#123; autofocusStateChangeDispatcher(result); if(result.get(CaptureResult.CONTROL_AF_STATE) == null)&#123; //æ£€æŸ¥è‡ªåŠ¨èšç„¦çš„çŠ¶æ€ AutoFocusHelper.checkControlAfState(result); &#125; ... if(request.getTag() == RequestTag.CAPTURE)&#123; synchronized(mCaptureQueue)&#123; if(mCaptureQueue.getFirst().setCaptureResult(result).isCaptureComplete())&#123; capture = mCaptureQueue.removeFirst(); &#125; &#125; if(capture != null)&#123; //æ‹ç…§ç»“æŸ OneCameraImpl.this.onCaptureCompleted(capture); &#125; &#125; super.onCaptureCompleted(session,request,result); &#125; ...&#125; è¿™æ˜¯Nativeå±‚åœ¨å¤„ç†è¯·æ±‚æ—¶ï¼Œä¼šè°ƒç”¨ç›¸åº”çš„å›è°ƒï¼Œå¦‚captureå¼€å§‹æ—¶ï¼Œä¼šå›è°ƒonCaptureStarted,å…·ä½“çš„åœ¨previewä¸­æœ‰è¿‡åˆ†æï¼Œå½“æ‹ç…§ç»“æŸæ—¶ï¼Œä¼šå›è°ƒonCaptureCompletedæ–¹æ³•ï¼Œå…¶ä¸­ä¼šæ ¹æ®CaptureResultæ¥æ£€æŸ¥è‡ªåŠ¨èšç„¦çš„çŠ¶æ€ï¼Œå¹¶é€šè¿‡TAGåˆ¤æ–­å…¶æ˜¯CaptureåŠ¨ä½œæ—¶ï¼Œå†æ¥çœ‹å®ƒæ˜¯å¦æ˜¯é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªè¯·æ±‚ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å°†è¯·æ±‚ç§»é™¤ï¼Œå› ä¸ºè¯·æ±‚å·²ç»å¤„ç†æˆåŠŸï¼Œæœ€åå†è°ƒç”¨OneCameraImplçš„onCaptureCompletedæ–¹æ³•æ¥è¿›è¡Œå¤„ç†ï¼š 12345678910111213141516[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]private void onCaptureCompleted(InFlightCapture capture)&#123; if(isCaptureImageFormat == ImageFormat.RAW_SENSOR)&#123; ... File dngFile = new File(RAW_DIRECTORY,capture.session.getTitle()+\".dng\"); writeDngBytesAndClose(capture.image,capture.totalCaptureResult,mCharacteristics,dngFile); &#125;else&#123; //è§£æresultä¸­çš„å›¾ç‰‡æ•°æ® byte[] imageBytes = acquireJpegBytesAndClose(capture.image); //ä¿å­˜Jpegå›¾ç‰‡ saveJpegPicture(imageBytes,capture.parameters,capture.session,capture.totalCaptureResult); &#125; broadcastReadyState(true); //è°ƒç”¨å›è°ƒ capture.parameters.callback.onPictureTaken(capture.session);&#125; å¦‚ä»£ç æ‰€ç¤ºï¼Œé¦–å…ˆï¼Œå¯¹resultä¸­çš„å›¾ç‰‡æ•°æ®è¿›è¡Œäº†è§£æï¼Œç„¶åè°ƒç”¨saveJpegPictureæ–¹æ³•å°†è§£æå¾—åˆ°çš„å›¾ç‰‡æ•°æ®è¿›è¡Œä¿å­˜ï¼Œæœ€åå†è°ƒç”¨é‡Œé¢çš„å›è°ƒ(å³CaptureModuleï¼Œå‰é¢åœ¨åˆå§‹åŒ–Parametersæ—¶è¯´æ˜äº†ï¼Œå®ƒå®ç°äº†PictureCallbakæ¥å£)çš„onPictureTakenæ–¹æ³•ï¼Œæ‰€ä»¥ï¼Œæ¥ä¸‹æ¥å…ˆåˆ†æsaveJpegPictureæ–¹æ³•ï¼š 1234567891011121314151617[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]private void saveJpegPicture(byte[] jpegData,final PhotoCaptureParameters captureParams,CaptureSession session,CaptureResult result)&#123; ... ListenableFuture&lt;Optional&lt;Uri&gt;&gt; futureUri = session.saveAndFinish(jpegData,width, height,rotation,exif); Futures.addCallback(futureUri,new FutureCallback&lt;Optional&lt;Uri&gt;&gt;()&#123; @Override public void onSuccess(Optional&lt;Uri&gt; uriOptional)&#123; captureParams.callback.onPictureSaved(mOptional.orNull()); &#125; @Override public void onFailure(Throwable throwable)&#123; captureParams.callback.onPictureSaved(null); &#125; &#125;);&#125; å®ƒæœ€åä¼šå›è°ƒonPictureSavedæ–¹æ³•æ¥å¯¹å›¾ç‰‡è¿›è¡Œä¿å­˜ï¼Œæ‰€ä»¥éœ€è¦åˆ†æCaptureModuleçš„onPictureSavedæ–¹æ³•ï¼š 12345[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]@Overridepublic void onPictureSaved(Uri uri)&#123; mAppController.notifyNewMedia(uri);&#125; mAppControllerçš„å®ç°ä¸ºCameraActivityï¼Œæ‰€ä»¥åˆ†ænotifyNewMediaæ–¹æ³•ï¼š 123456789101112131415161718192021222324252627[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]@Overridepublic void notifyNewMedia(Uri uri)&#123; ... if(FilmstripItemUtils.isMimeTypeVideo(mimeType))&#123; //å¦‚æœæ‹æ‘„çš„æ˜¯video sendBroadcast(new Intent(CameraUtil.ACTION_NEW_VIDEO,uri)); newData = mVideoItemFactory.queryContentUri(uri); ... &#125;else if(FilmstripItemUtils.isMimeTypeImage(mimeType))&#123; //å¦‚æœæ˜¯æ‹æ‘„å›¾ç‰‡ CameraUtil.broadcastNewPicture(mAppContext,uri); newData = mPhotoItemFactory.queryCotentUri(uri); ... &#125;else&#123; return; &#125; new AsyncTask&lt;FilmstripItem,Void,FilmstripItem&gt;()&#123; @Override protected FilmstripItem doInBackground(FilmstripItem... Params)&#123; FilmstripItem data = params[0]; MetadataLoader.loadMetadata(getAndroidContet(),data); return data; &#125; ... &#125;&#125; ç”±ä»£ç å¯çŸ¥ï¼Œè¿™é‡Œæœ‰ä¸¤ç§æ•°æ®çš„å¤„ç†ï¼Œä¸€ç§æ˜¯videoï¼Œå¦ä¸€ç§æ˜¯imageã€‚è€Œæˆ‘ä»¬è¿™é‡Œåˆ†æçš„æ˜¯captureå›¾ç‰‡æ•°æ®ï¼Œæ‰€ä»¥é¦–å…ˆä¼šæ ¹æ®åœ¨å›è°ƒå‡½æ•°ä¼ å…¥çš„å‚æ•°Uriå’ŒPhotoItemFactoryæ¥æŸ¥è¯¢åˆ°ç›¸åº”çš„æ‹ç…§æ•°æ®ï¼Œç„¶åå†å¼€å¯ä¸€ä¸ªå¼‚æ­¥çš„Taskæ¥å¯¹æ­¤æ•°æ®è¿›è¡Œå¤„ç†ï¼Œå³é€šè¿‡MetadataLoaderçš„loadMetadataæ¥åŠ è½½æ•°æ®ï¼Œå¹¶è¿”å›ã€‚è‡³æ­¤ï¼Œcaptureçš„æµç¨‹å°±åŸºæœ¬åˆ†æç»“æŸäº†ï¼Œä¸‹é¢å°†ç»™å‡ºcaptureæµç¨‹çš„æ•´ä¸ªè¿‡ç¨‹ä¸­çš„æ—¶åºå›¾ï¼š ï¼ˆä¸‰ï¼‰ã€Camera System takepicture(ZSL)æµç¨‹åˆ†æï¼ˆæœ¬å°èŠ‚åŸºäº Android 5.1 API11æºç ï¼‰ZSL(zear shutter lag)å³é›¶å»¶æ—¶ï¼Œå°±æ˜¯åœ¨æ‹ç…§æ—¶ä¸åœé¢„è§ˆå°±å¯ä»¥æ‹ç…§.ç”±äºæœ‰è¾ƒå¥½çš„ç”¨æˆ·ä½“éªŒåº¦ï¼Œè¯¥featureæ˜¯ç°åœ¨å¤§éƒ¨åˆ†æ‰‹æœºéƒ½æ‹¥æœ‰çš„åŠŸèƒ½ã€‚é¢ä¸å†è´´å‡ºå¤§é‡ä»£ç æ¥æè¿°è¿‡ç¨‹ï¼Œç›´æ¥ä¸Šå›¾ã€‚ä¸‹å›¾æ˜¯ç”»äº†2ä¸ªå°æ—¶æ•´ç†å‡ºæ¥çš„Android5.1 Zslçš„åŸºæœ¬æµç¨‹ï¼Œå¯ä»¥çœ‹åˆ°ä¸ZSLå¯†åˆ‡ç›¸å…³çš„æœ‰5ä¸ªçº¿ç¨‹frameprocessorã€captureSequencerã€ZslProcessor3ã€JpegProcessorã€Camera3Device:requestThreadã€‚å…¶å®è¿˜æœ‰ä¸€ä¸ªä¸»çº¿ç¨‹ç”¨äºæ›´æ–°å‚æ•°ã€‚é’ˆå¯¹Android5.1çœ‹ä»£ç æ‰€å¾—ï¼ŒZSLè¿‡ç¨‹ä¸­å¤§æ¦‚åˆ†æˆä¸‹é¢7ä¸ªæµç¨‹. æ›´æ­£ï¼šå›¾ä¸­å·¦ä¸Šè§’çš„FrameProcessorçº¿ç¨‹èµ·æ¥åä¼šåœ¨waitForNextFrameä¸­æ‰§è¡ŒmResultSignal.waitRelative()ï¼Œå›¾ä¸­æ²¡æœ‰æ›´æ”¹è¿‡æ¥ã€‚ 3.0ã€æ³¨å†Œå¸§ç›‘å¬å¯¹è±¡3.0.1ã€captureSequenceçº¿ç¨‹æ³¨å†Œå¸§ç›‘å¬å¯¹è±¡3.0.1.1ã€æ³¨å†Œæ—¶æœºå½“ä¸Šå±‚å‘å‡ºZSLæ‹ç…§è¯·æ±‚æ—¶ï¼Œåº•å±‚å°±ä¼šè§¦å‘æ‹ç…§æ•è·çŠ¶æ€æœºï¼Œæ”¹çŠ¶æ€æœºçš„åŸºæœ¬æµç¨‹å›¾åœ¨ä¸Šç¯‡ç¬”è®°ä¸­å·²ç»æ•´ç†å‡ºæ¥è¿‡ï¼Œè¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚ç”±äºcamera2Clientä¸å…¶å®ƒå¤„ç†çº¿ç¨‹å¯¹è±¡åŸºæœ¬ç¬¦åˆé‡‘å­—å¡”å½¢çš„æ¶æ„ï¼Œå¯ä»¥çœ‹åˆ°è¿™é‡Œæ˜¯é€šè¿‡camera2Clientçš„å¯¹è±¡å°†å¸§å¯ç”¨ç›‘å¬å¯¹è±¡æ³¨å†Œåˆ°FrameProcesså¯¹è±¡ä¸­çš„List mRangeListeners;å¯¹è±¡ä¸­ã€‚ 1234567891011121314[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]CaptureSequencer::CaptureState CaptureSequencer::manageZslStart( sp&lt;Camera2Client&gt; &amp;client) &#123; ALOGV(\"%s\", __FUNCTION__); status_t res; sp&lt;ZslProcessorInterface&gt; processor = mZslProcessor.promote(); // We don't want to get partial results for ZSL capture. client-&gt;registerFrameListener(mCaptureId, mCaptureId + 1, this, /*sendPartials*/false); // TODO: Actually select the right thing here. res = processor-&gt;pushToReprocess(mCaptureId); //.......&#125; ç‰¹åˆ«æ³¨æ„ï¼šå¯ä»¥çœ‹åˆ°åœ¨æ³¨å†Œå¸§ç›‘å¬å¯¹è±¡æ—¶ï¼Œä¼ å…¥çš„ä¸¤ä¸ªå‚æ•°æ˜¯mCaptureId, mCaptureId + 1,ä¸ºä»€ä¹ˆä¼šæ˜¯è¿™æ ·å‘¢,å› ä¸ºè¿™ä¸ªå°±æ˜¯æ ‡è®°æˆ‘ä»¬æƒ³æŠ“çš„æ˜¯å“ªä¸€å¸§,å½“æ‹ç…§bufferä»halä¸Šæ¥ä¹‹å,Camera3Deviceå°±ä¼šå›è°ƒå¸§å¯ç”¨ç›‘å¬å¯¹è±¡ï¼Œç„¶åå¾—åˆ°æ‹ç…§å¸§çš„æ—¶é—´æˆ³ï¼Œç´§æ¥ç€æ ¹æ®æ—¶é—´æˆ³ä»ZSL RingBufferä¸­æ‰¾åˆ°æœ€ç†æƒ³çš„inputBufferï¼Œç„¶åä¸‹å‘ç»™halè¿›è¡ŒJpegç¼–è§£ç ã€‚å¯¹æ¯”ä¸‹é¢ZSLçº¿ç¨‹çš„CaptureId,åº”è¯¥å°±ç†è§£äº†. 3.0.1.2ã€æ•è·æ—¶æœº123456789101112[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]void CaptureSequencer::onResultAvailable(const CaptureResult &amp;result) &#123; ATRACE_CALL(); ALOGV(\"%s: New result available.\", __FUNCTION__); Mutex::Autolock l(mInputMutex); mNewFrameId = result.mResultExtras.requestId; mNewFrame = result.mMetadata; if (!mNewFrameReceived) &#123; mNewFrameReceived = true; .signal(); &#125;&#125; ä¸Šé¢å³æ˜¯æ‹ç…§çŠ¶æ€æœºæ³¨å†Œçš„å›è°ƒå‡½æ•°ï¼Œå…¶ä¸­å½“ZSLæ‹ç…§å¸§ä¸Šæ¥ä¹‹åï¼Œæœºä¼šæ¿€æ´»æ­£åœ¨ç­‰å¾…ä¸­çš„CaptureSequencerçº¿ç¨‹ï¼Œä»¥è¿›è¡Œåç»­çš„æ“ä½œã€‚ 3.0.2ã€ZslProcess3çº¿ç¨‹æ³¨å†Œå¸§ç›‘å¬å¯¹è±¡3.0.2.1ã€æ³¨å†Œæ—¶æœº12345678910111213141516171819202122[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]status_t ZslProcessor::updateStream(const Parameters &amp;params) &#123; if (mZslStreamId == NO_STREAM) &#123; // Create stream for HAL production // TODO: Sort out better way to select resolution for ZSL // Note that format specified internally in Camera3ZslStream res = device-&gt;createZslStream( params.fastInfo.arrayWidth, params.fastInfo.arrayHeight, mBufferQueueDepth, &amp;mZslStreamId, &amp;mZslStream); // Only add the camera3 buffer listener when the stream is created. mZslStream-&gt;addBufferListener(this);//è¿™é‡Œæ˜¯åœ¨BufferQueueæ³¨å†Œçš„callbackï¼Œæš‚æ—¶ä¸ç”¨å…³å¿ƒã€‚ &#125; client-&gt;registerFrameListener(Camera2Client::kPreviewRequestIdStart, Camera2Client::kPreviewRequestIdEnd, this, /*sendPartials*/false); return OK;&#125; ä¸Šé¢çš„å³ä¸ºæ›´æ–°zslæµæ—¶è°ƒç”¨çš„å‡½æ•°,å¯ä»¥çœ‹åˆ°å…¶ä¸­ä½¿ç”¨registerFrameListeneræ³¨å†Œäº†RingBufferå¯ç”¨ç›‘å¬å¯¹è±¡ï¼Œè¿™é‡Œæˆ‘ä»¬è¦ç‰¹åˆ«æ³¨æ„çš„æ˜¯ä¸‹é¢2ä¸ªå®ã€‚è¿™ä¸ªæ˜¯ä¸“é—¨ä¸ºé¢„è§ˆé¢„ç•™çš„requestIdï¼Œè€ƒè™‘è¿™æ ·ä¹Ÿä¼šæœ‰å½•åƒå’Œæ‹ç…§çš„requestId,æ¯æ¬¡æ›´æ–°å‚æ•°åï¼Œè¿™ä¸ªrequestIdä¼šæœ‰+1æ“ä½œï¼Œæ²¡æœ‰å‚æ•°æ›´æ–°ï¼Œåˆ™ä¸ä¼š+1ï¼Œè¿™ä¸ªå¯ä»¥åœ¨å„è‡ªçš„Debugæ‰‹æœºä¸Šå‘ç°ã€‚ 123[-&gt;/frameworks/av/services/camera/libcameraservice/api1/Camera2Client.h]static const int32_t kPreviewRequestIdStart = 10000000;static const int32_t kPreviewRequestIdEnd = 20000000; 3.0.2.2ã€æ•è·æ—¶æœº123456789101112131415161718[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]void ZslProcessor::onResultAvailable(const CaptureResult &amp;result) &#123; ATRACE_CALL(); ALOGV(\"%s:\", __FUNCTION__); Mutex::Autolock l(mInputMutex); camera_metadata_ro_entry_t entry; entry = result.mMetadata.find(ANDROID_SENSOR_TIMESTAMP); nsecs_t timestamp = entry.data.i64[0]; entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT); int32_t frameNumber = entry.data.i32[0]; // Corresponding buffer has been cleared. No need to push into mFrameList if (timestamp &lt;= mLatestClearedBufferTimestamp) return; mFrameList.editItemAt(mFrameListHead) = result.mMetadata; mFrameListHead = (mFrameListHead + 1) % mFrameListDepth;&#125; å»æ‰é”™è¯¯æ£€æŸ¥ä»£ç ï¼Œä¸Šé¢ç”±äºCaptureIDæ˜¯ä¸‹é¢2ä¸ªï¼Œä¹Ÿå°±æ˜¯ZSLçš„æ‰€æœ‰é¢„è§ˆBufferå¯ç”¨ä¹‹åéƒ½ä¼šå›è°ƒè¿™ä¸ªæ–¹æ³•,å½“é˜Ÿåˆ—æ»¡ä¹‹åï¼Œæ–°bufferä¼šè¦†ç›–æ—§bufferä½ç½®ã€‚ä¸Šé¢å¯ä»¥çœ‹åˆ°mFrameListä¸­ä¼šä¿å­˜æ¯ä¸€å¸§çš„metadataæ•°æ®ï¼ŒmFrameListHeadç”¨æ¥æ ‡è¯†ä¸‹ä¸€æ¬¡å­˜æ”¾æ•°æ®çš„ä½ç½®ã€‚ 3.1ã€æŸ¥æ‰¾ZSLæ‹ç…§æœ€åˆé€‚çš„bufferä¸€å¼€å§‹æˆ‘ä»¥ä¸ºæ˜¯æ˜¯æ ¹æ®æƒ³è¦æŠ“å–é‚£å¸§çš„captureIdæ¥æ‰¾åˆ°zslæ‹ç…§bufferçš„ï¼Œä½†æ˜¯ç°åœ¨çœ‹æ¥å°±æ˜¯æ‰¾æ—¶é—´æˆ³æœ€è¿‘çš„é‚£ä¸ªbufferæ¥è¿›è¡Œjpegç¼–è§£ç (è€Œä¸”googleå·¥ç¨‹å¸ˆåœ¨æºç ä¸­æ³¨é‡Šä¹Ÿæ˜¯è¿™æ ·è¯´çš„). 123456789101112131415161718192021222324252627282930313233343536373839[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]status_t ZslProcessor::pushToReprocess(int32_t requestId) &#123; ALOGV(\"%s: Send in reprocess request with id %d\", __FUNCTION__, requestId); Mutex::Autolock l(mInputMutex); status_t res; sp&lt;Camera2Client&gt; client = mClient.promote(); //ä¸‹é¢æ˜¯å°±æ˜¯åœ¨mFrameListæŸ¥æ‰¾æ—¶é—´æˆ³æœ€è¿‘çš„å¸§ã€‚ size_t metadataIdx; nsecs_t candidateTimestamp = getCandidateTimestampLocked(&amp;metadataIdx); //æ ¹æ®ä¸Šä¸€æ¬¡æŸ¥æ‰¾çš„æ—¶é—´æˆ³ï¼Œä»ZSL BufferQueueä¸­æŸ¥æ‰¾æ—¶é—´æœ€æ¥è¿‘çš„Bufferï¼Œå¹¶å°† //bufferä¿å­˜åˆ°mInputBufferQueueé˜Ÿåˆ—ä¸­ã€‚ res = mZslStream-&gt;enqueueInputBufferByTimestamp(candidateTimestamp, /*actualTimestamp*/NULL); //----------------- &#123;//è·å–zsl ç¼–è§£ç çš„metadataIdï¼Œç¨åä¼šä¼ å…¥ç»™halç¼–è§£ç ã€‚ CameraMetadata request = mFrameList[metadataIdx]; // Verify that the frame is reasonable for reprocessing camera_metadata_entry_t entry; entry = request.find(ANDROID_CONTROL_AE_STATE); if (entry.data.u8[0] != ANDROID_CONTROL_AE_STATE_CONVERGED &amp;&amp; entry.data.u8[0] != ANDROID_CONTROL_AE_STATE_LOCKED) &#123; ALOGV(\"%s: ZSL queue frame AE state is %d, need full capture\", __FUNCTION__, entry.data.u8[0]); return NOT_ENOUGH_DATA; &#125; //è¿™ä¸­é—´ä¼šæ›´æ–°è¾“å…¥streamçš„æµIDã€æ›´æ–°æ•è·æ„å›¾ä¸ºé™æ€æ‹ç…§ã€åˆ¤æ–­è¿™ä¸€å¸§æ˜¯å¦AEç¨³å®šã€ //è·å–jpegStreamIDå¹¶æ›´æ–°åˆ°metadataä¸­ã€æ›´æ–°è¯·æ±‚IDï¼Œæœ€åæ ¹æ®æ›´æ–°åçš„request metadata //æ›´æ–°jpeg metadataã€‚æœ€åä¸€æ­¥å¯åŠ¨Camera3DeviceæŠ“å–å›¾ç‰‡ã€‚ // Update post-processing settings res = updateRequestWithDefaultStillRequest(request); mLatestCapturedRequest = request; res = client-&gt;getCameraDevice()-&gt;capture(request); mState = LOCKED; &#125; return OK;&#125; è¿˜è®°å¾—åœ¨å¯åŠ¨çŠ¶æ€æœºå™¨æ—¶ï¼Œæ³¨å†Œçš„å¸§ç›‘å¬å¯¹è±¡å§ã€‚è¿™é‡Œå‚æ•°requestIdå°±æ˜¯æˆ‘ä»¬æƒ³è¦æŠ“æ‹çš„å›¾ç‰‡çš„è¯·æ±‚ID,ç›®å‰å‘ç°è¯¥è¯·æ±‚IDåé¢ä¼šæ›´æ–°åˆ°metadataä¸­ã€‚è¿™é‡Œåªè¦çŸ¥é“è¯¥å‡½æ•°åŠŸèƒ½å°±å¯ä»¥äº†ã€‚ â˜¯ 1ã€ä»mFrameListä¸­æŸ¥æ‰¾æ—¶é—´æˆ³æœ€å°çš„metadataã€‚â˜¯ 2ã€æ ¹æ®ä»ç¬¬ä¸€æ­¥è·å–åˆ°æ—¶é—´æˆ³ï¼Œä»ZSL BufferQueueé€‰æ‹©æ—¶é—´æœ€æ¥è¿‘Buffer.â˜¯3ã€å°†Bufferæ”¾åˆ°mInputBufferQueueä¸­ï¼Œæ›´æ–°jpegç¼–è§£ç metadataï¼Œå¯åŠ¨CaptureåŠŸèƒ½ã€‚ 3.2ã€è®¾ç½®zsl input bufferå’Œ jpeg out buffer å…¶å®è¿™ä¸€æ­¥ä¹‹å‰å·²ç»è®¨è®ºè¿‡ï¼ŒinputBufferæ˜¯ZslProcess3çº¿ç¨‹æŸ¥æ‰¾åˆ°æœ€åˆé€‚çš„ç”¨äºjpegç¼–è§£ç çš„bufferã€‚outputBufferä¸ºJpegProcessorçº¿ç¨‹æ›´æ–°çš„bufferç”¨äºå­˜æ”¾halç¼–è§£ç ä¹‹åçš„jpegå›¾ç‰‡ã€‚å…¶ä¸­å‡†å¤‡jpeg OutBufferçš„æ“ä½œå°±æ˜¯åœ¨ä¸‹é¢æ“ä½œçš„ã€‚å¯ä»¥çœ‹åˆ°å°†outputStreamçš„IDï¼Œä¿å­˜åˆ°metadataä¸­äº†ã€‚è¿™æ ·å°±ä¼šåœ¨Camera3Deviceä¸­æ ¹æ®è¿™é¡¹metadataæ¥æ·»åŠ outputBufferåˆ°halã€‚ 1234567status_t ZslProcessor::pushToReprocess(int32_t requestId) &#123; // TODO: Shouldn't we also update the latest preview frame? int32_t outputStreams[1] = &#123; client-&gt;getCaptureStreamId() &#125;; res = request.update(ANDROID_REQUEST_OUTPUT_STREAMS, outputStreams, 1); &#125; 3.3ã€å½’è¿˜jpeg Bufferå¹²äº†ä»€ä¹ˆ. å½“frameworkå°†ZSL inputBufferå’Œjpeg outputBuffer,ä¼ ç»™halåï¼Œhalå°±ä¼šå¯åŠ¨STLL_CAPTUREæµç¨‹ï¼Œå°†inputBufferä¸­çš„å›¾åƒæ•°æ®ï¼Œè¿›è¡Œä¸€ç³»åˆ—çš„åå¤„ç†æµç¨‹ã€‚å½“åå¤„ç†å®Œæˆåï¼Œhalåˆ™ä¼šå°†ä¸´æ—¶Bufferæ‹·è´åˆ°outPutBufferä¸­(æ³¨æ„ï¼šè¿™é‡Œè¦è®°å¾—åšflushæ“ä½œï¼Œå³åˆ·æ–°Buffer,è¦ä¸ç„¶å›¾ç‰‡æœ‰å¯èƒ½ä¼šå‡ºç°ç»¿æ¡). å› ä¸ºJpegBufferä¹Ÿæ˜¯ä»BufferQueue Dequeueå‡ºæ¥çš„buffer,è€Œä¸”åœ¨åˆ›å»ºBufferQueueæ—¶ï¼Œä¹Ÿæ³¨å†Œäº†å¸§ç›‘å¬å¯¹è±¡(å³ï¼šonFrameAvailable()å›è°ƒ).è¿™æ ·çš„è¯å½“å¸§å¯ç”¨(å³ï¼šè¿›è¡Œäº†enqueueæ“ä½œï¼‰ï¼Œå°±ä¼šå›è°ƒonFrameAvailable()æ–¹æ³•ï¼Œè¿™æ ·å½“halå½’è¿˜jpegBufferæ—¶å°±æ˜¯è¦è¿›è¡Œenqueue()æ“ä½œã€‚åœ¨onFrameAvailable()æ–¹æ³•ä¸­ï¼Œä¼šæ¿€æ´»jpegprocesçº¿ç¨‹ï¼Œè¿›è¡Œåç»­çš„å¤„ç†ï¼Œæœ€åæ¿€æ´»captureSequeueæ‹ç…§çŠ¶æ€æœºçº¿ç¨‹ã€‚ 3.4ã€ä¿å­˜ZSLBuffer. è¿™é‡Œç”±äºZSL Bufferä¸€ç›´ä¼šä»halä¸Šæ¥ï¼Œæ‰€ä»¥å½“zslBufferä¸Šæ¥åï¼Œå°±ä¼šæ¿€æ´»FrameProcesorçº¿ç¨‹ä¿å­˜è¿™ä¸€ZslBufferï¼Œç›®å‰FrameWorké‚£è¾¹é»˜è®¤æ˜¯4ä¸ªbufferï¼Œè¿™æ ·çš„è¯å½“é˜Ÿåˆ—æ»¡ä¹‹åï¼Œå°±ä¼šè¦†ç›–ä¹‹å‰æœ€è€çš„buffer,å¦‚æ­¤åå¤æ“ä½œã€‚ 3.5ã€è·å–æ‹ç…§jpeg Buffer å½“halä¸Šæ¥jpegå¸§åï¼Œå°±ä¼šæ¿€æ´»jpegProcessçº¿ç¨‹,å¹¶ä»BufferQueueä¸­æ‹¿åˆ°jpegbufferï¼Œä¸‹é¢å¯ä»¥å‘ç°è¿›è¡ŒlockNextBuffer,unlockBufferæ“ä½œã€‚ 12345678910[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp]status_t JpegProcessor::processNewCapture() &#123; res = mCaptureConsumer-&gt;lockNextBuffer(&amp;imgBuffer); mCaptureConsumer-&gt;unlockBuffer(imgBuffer); sp&lt;CaptureSequencer&gt; sequencer = mSequencer.promote(); //...... if (sequencer != 0) &#123; sequencer-&gt;onCaptureAvailable(imgBuffer.timestamp, captureBuffer); &#125;&#125; ä¸Šé¢å¯ä»¥å‘ç°æœ€åå›è°ƒäº†captureSequencerçº¿ç¨‹çš„onCaptureAvailable()å›è°ƒæ–¹æ³•ã€‚è¯¥å›è°ƒæ–¹æ³•ä¸»è¦ä½œç”¨å°±æ˜¯å°†æ—¶é—´æˆ³å’Œjpeg bufferçš„ä¼ é€åˆ°CaptureSequencerçº¿ç¨‹ä¸­,ç„¶åæ¿€æ´»CaptureSequencerçº¿ç¨‹ã€‚æœ€åå°†Buffer CallBackåˆ°åº”ç”¨å±‚ã€‚ 12345678910111213[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]void CaptureSequencer::onCaptureAvailable(nsecs_t timestamp, sp&lt;MemoryBase&gt; captureBuffer) &#123; ATRACE_CALL(); ALOGV(\"%s\", __FUNCTION__); Mutex::Autolock l(mInputMutex); mCaptureTimestamp = timestamp; mCaptureBuffer = captureBuffer; if (!mNewCaptureReceived) &#123; mNewCaptureReceived = true; mNewCaptureSignal.signal(); &#125;&#125; 3.6ã€æ‹ç…§å¸§å¯ç”¨å›è°ƒå½“æ‹ç…§å¸§å›åˆ°Frameworkåï¼Œå°±ä¼šå›è°ƒCaptureSequencerçš„onResultAvailable()æ¥å£ï¼Œç”¨äºè®¾ç½®captureSequencerçŠ¶æ€æœºçš„æ ‡å¿—ä½å’Œæ¡ä»¶æ¿€æ´»,å¦‚ä¸‹ä»£ç æ‰€ç¤ºã€‚æ¡ä»¶å˜é‡å’Œæ ‡å¿—ä½çš„ä½¿ç”¨å¯ä»¥åœ¨çŠ¶æ€æœºæ–¹æ³•manageStandardCaptureWait()çœ‹åˆ°ä½¿ç”¨ã€‚ 123456789101112[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]void CaptureSequencer::onResultAvailable(const CaptureResult &amp;result) &#123; ATRACE_CALL(); ALOGV(\"%s: New result available.\", __FUNCTION__); Mutex::Autolock l(mInputMutex); mNewFrameId = result.mResultExtras.requestId; mNewFrame = result.mMetadata; if (!mNewFrameReceived) &#123; mNewFrameReceived = true; mNewFrameSignal.signal(); &#125;&#125; 3.7ã€jpeg bufferå›è°ƒåˆ°appè¯¥callbackæ˜¯åº”ç”¨æ³¨å†Œè¿‡æ¥çš„ä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œä¸‹é¢å°±æ˜¯é€šè¿‡binderè¿›ç¨‹é—´è°ƒç”¨å°†jpeg Bufferä¼ é€åˆ°APPç«¯ï¼Œæ³¨æ„è¿™é‡Œçš„msgTyep = CAMERA_MSG_COMPRESSED_IMAGE,å°±æ˜¯å‘Šè¯‰ä¸Šå±‚è¿™æ˜¯ä¸€ä¸ªå‹ç¼©çš„å›¾åƒæ•°æ®ã€‚ 1234567891011121314151617[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]CaptureSequencer::CaptureState CaptureSequencer::manageDone(sp&lt;Camera2Client&gt; &amp;client) &#123; status_t res = OK; ATRACE_CALL(); mCaptureId++; ...... Camera2Client::SharedCameraCallbacks::Lock l(client-&gt;mSharedCameraCallbacks); ALOGV(\"%s: Sending still image to client\", __FUNCTION__); if (l.mRemoteCallback != 0) &#123; l.mRemoteCallback-&gt;dataCallback(CAMERA_MSG_COMPRESSED_IMAGE, mCaptureBuffer, NULL); &#125; else &#123; ALOGV(\"%s: No client!\", __FUNCTION__); &#125; ......&#125; ï¼ˆå››ï¼‰ã€Camera System Recorderæµç¨‹åˆ†æcamera Video.è™½ç„¶æ ‡é¢˜æ˜¯recordingæµç¨‹åˆ†æï¼Œä½†è¿™é‡Œå¾ˆå¤šå’Œpreviewæ˜¯ç›¸ä¼¼çš„(åŒ…å«æ›´æ–°ï¼Œåˆ›å»ºStream,åˆ›å»ºRequest)ï¼Œè¿™é‡Œä¸»è¦åˆ†æMediaRecorderå¯¹è±¡åˆ›å»ºã€videoå¸§ç›‘å¬å¯¹è±¡æ³¨å†Œã€å¸§å¯ç”¨äº‹ä»¶ä»¥åŠä¸€ç³»åˆ—callbackæµç¨‹åˆ†æã€‚ 4.1ã€è®¤è¯†video(mediaRecorder)çŠ¶æ€æœº Used to record audio and video. The recording control is based on asimple state machine (see below).çŠ¶æ€æœºè¯·çœ‹ä¸Šé¢æºç ä¸­ç»™çš„æµç¨‹å›¾ã€‚A common case of using MediaRecorder to record audio works as follows:1.MediaRecorder recorder = new MediaRecorder();2.recorder.setAudioSource(MediaRecorder.AudioSource.MIC);3.recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);4.recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);5.recorder.setOutputFile(PATH_NAME);6.recorder.prepare();7.recorder.start(); // Recording is now started8â€¦.9.recorder.stop();10.recorder.reset(); // You can reuse the object by going back to setAudioSource() steprecorder.release(); // Now the object cannot be reused Applications may want to register for informational and errorevents in order to be informed of some internal update and possibleruntime errors during recording. Registration for such events isdone by setting the appropriate listeners (via calls(to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or{@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).In order to receive the respective callback associated with these listeners,applications are required to create MediaRecorder objects on threads with aLooper running (the main UI thread by default already has a Looper running). ä¸Šé¢æ˜¯googoleå·¥ç¨‹å¸ˆåŠ çš„æ³¨é‡Šï¼Œæœ€æƒå¨çš„èµ„æ–™ã€‚å¤§æ¦‚æ„æ€å°±æ˜¯è¯´â€œä½¿ç”¨mediaRecorderè®°å½•éŸ³è§†é¢‘ï¼Œéœ€è¦ä¸€ä¸ªç®€å•çš„çŠ¶æ€æœºæ¥æ§åˆ¶â€ã€‚ä¸Šé¢çš„1,2,3â€¦å°±æ˜¯åœ¨æ“ä½œæ—¶éœ€è¦å‡†å®ˆçš„æ­¥éª¤ã€‚ç®—äº†å§ï¼Œç¿»è¯‘æ°´å¹³æœ‰é™ï¼Œé‡ç‚¹è¿˜æ˜¯æ”¾åˆ°cameraè¿™è¾¹å§ã€‚ 4.2ã€Camera appå¦‚ä½•å¯åŠ¨å½•åƒ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//æºç è·¯å¾„:pdk/apps/TestingCamera/src/com/android/testingcamera/TestingCamera.java private void startRecording() &#123; log(\"Starting recording\"); logIndent(1); log(\"Configuring MediaRecoder\"); //è¿™é‡Œä¼šæ£€æŸ¥æ˜¯å¦æ‰“å¼€äº†å½•åƒåŠŸèƒ½ã€‚è¿™é‡Œæˆ‘ä»¬çœç•¥äº†ï¼Œç›´æ¥ä¸å¦‚æ­£é¢˜//ä¸Šé¢é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªMediaRecorderçš„javaå¯¹è±¡(æ³¨æ„è¿™é‡ŒåŒcamera.javaç±»ä¼¼ï¼Œjavaå¯¹è±¡ä¸­è‚¯å®šåŒ…å«äº†ä¸€ä¸ªmediaRecorder jniæœ¬åœ°å¯¹è±¡ï¼Œç»§ç»­å¾€ä¸‹çœ‹) mRecorder = new MediaRecorder(); //ä¸‹é¢å°±æ˜¯è®¾ç½®ä¸€äº›callback. mRecorder.setOnErrorListener(mRecordingErrorListener); mRecorder.setOnInfoListener(mRecordingInfoListener); if (!mRecordHandoffCheckBox.isChecked()) &#123; //å°†å½“å‰camera javaå¯¹è±¡è®¾ç½®ç»™äº†mediaRecorder javaå¯¹è±¡ã€‚ //è¿™é‡ŒsetCameraæ˜¯jniæ¥å£ï¼Œåé¢æˆ‘ä»¬è´´ä»£ç åœ¨åˆ†æã€‚ mRecorder.setCamera(mCamera); &#125; //å°†preview surface javaå¯¹è±¡è®¾ç½®ç»™mediaRecorder javaå¯¹è±¡ï¼Œåé¢è´´ä»£ç  //è¯¦ç»†è¯´æ˜ã€‚ mRecorder.setPreviewDisplay(mPreviewHolder.getSurface()); //ä¸‹é¢ï¼’ä¸ªæ˜¯è®¾ç½®éŸ³é¢‘å’Œè§†é¢‘çš„èµ„æºã€‚ mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER); mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mRecorder.setProfile(mCamcorderProfiles.get(mCamcorderProfile)); //ä»appæ§ä»¶é€‰æ‹©å½•åƒå¸§å¤§å°ï¼Œå¹¶è®¾ç½®ç»™mediaRecorder Camera.Size videoRecordSize = mVideoRecordSizes.get(mVideoRecordSize); if (videoRecordSize.width &gt; 0 &amp;&amp; videoRecordSize.height &gt; 0) &#123; mRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height); &#125; //ä»appæ§ä»¶é€‰æ‹©å½•åƒå¸§ç‡ï¼Œå¹¶è®¾ç½®ç»™mediaRecorder. if (mVideoFrameRates.get(mVideoFrameRate) &gt; 0) &#123; mRecorder.setVideoFrameRate(mVideoFrameRates.get(mVideoFrameRate)); &#125; File outputFile = getOutputMediaFile(MEDIA_TYPE_VIDEO); log(\"File name:\" + outputFile.toString()); mRecorder.setOutputFile(outputFile.toString()); boolean ready = false; log(\"Preparing MediaRecorder\"); try &#123; //å‡†å¤‡ä¸€ä¸‹ï¼Œè¯·çœ‹ä¸‹é¢googleç»™çš„ä½¿ç”¨mediaRecorderæ ‡å‡†æµç¨‹ mRecorder.prepare(); ready = true; &#125; catch (Exception e) &#123;//------å¼‚å¸¸å¤„ç†çœç•¥ &#125; if (ready) &#123; try &#123; log(\"Starting MediaRecorder\"); mRecorder.start();//å¯åŠ¨å½•åƒ mState = CAMERA_RECORD; log(\"Recording active\"); mRecordingFile = outputFile; &#125; catch (Exception e) &#123;//-----å¼‚å¸¸å¤„ç†çœç•¥ &#125;//------------ &#125; å¯ä»¥çœ‹åˆ°åº”ç”¨å¯åŠ¨å½•åƒåŠŸèƒ½æ˜¯æ˜¯ç¬¦åˆçŠ¶æ€æœºæµç¨‹çš„ã€‚åœ¨åº”ç”¨å¼€å‘ä¸­ï¼Œä¹Ÿè¦è¿™æ ·æ¥åšã€‚ â˜¯ 1.åˆ›å»ºmediaRecorderjavaå¯¹è±¡ï¼ŒmRecorder = new MediaRecorder();â˜¯ 2.è®¾ç½®camera javaå¯¹è±¡åˆ°mediaRecorderä¸­ï¼ŒmRecorder.setCamera(mCamera);â˜¯ 3.å°†preview surfaceå¯¹è±¡è®¾ç½®ç»™mediaRecorder,mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());â˜¯ 4.è®¾ç½®éŸ³é¢‘æºï¼ŒmRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);â˜¯ 5.è®¾ç½®è§†é¢‘æºï¼ŒmRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);â˜¯ 6.è®¾ç½®å½•åƒå¸§å¤§å°å’Œå¸§ç‡ï¼Œä»¥åŠsetOutputFileâ˜¯ 8.å‡†å¤‡å·¥ä½œï¼ŒmRecorder.prepare();â˜¯ 9.å¯åŠ¨mdiaRecorder,mRecorder.start(); 4.3ã€ä¸MediaPlayerServiceç›¸å…³çš„ç±»æ¥å£ä¹‹é—´çš„å…³ç³»ç®€ä»‹4.3.1ã€mediaRecorderä½•æ—¶ä¸MediaPlayerServiceå‘é€å…³ç³» 12345678910111213/frameworks/base/media/java/android/media/MediaRecorder.javaMediaRecorder::MediaRecorder() : mSurfaceMediaSource(NULL)&#123; ALOGV(\"constructor\"); const sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService()); if (service != NULL) &#123; mMediaRecorder = service-&gt;createMediaRecorder(); &#125; if (mMediaRecorder != NULL) &#123; mCurrentState = MEDIA_RECORDER_IDLE; &#125; doCleanUp();&#125; åœ¨jniä¸­åˆ›å»ºmediaRecorderå¯¹è±¡æ—¶ï¼Œå…¶å®åœ¨æ„é€ å‡½æ•°ä¸­å·å·çš„é“¾æ¥äº†mediaPlayerServiceï¼Œè¿™ä¹Ÿæ˜¯Androidä¹ æƒ¯ç”¨çš„æ–¹æ³•ã€‚è·å–åˆ°MediaPlayerServiceä»£ç†å¯¹è±¡åï¼Œé€šè¿‡åŒ¿åbinderè·å–mediaRecorderä»£ç†å¯¹è±¡ã€‚ 4.3.2ã€mediaPlayerServiceç±»å’Œæ¥å£ä¹‹é—´å…³ç³» æ¥å£ç±»å‹ æ¥å£è¯´æ˜ virtual sp createMediaRecorder() = 0; åˆ›å»ºmediaRecorderå½•è§†é¢‘æœåŠ¡å¯¹è±¡çš„æ¥å£ virtual sp create(const sp&amp; client, int audioSessionId = 0) = 0; åˆ›å»ºmediaPlayeræ’­æ”¾éŸ³ä¹æœåŠ¡å¯¹è±¡çš„æ¥å£ï¼Œæ’­æ”¾éŸ³ä¹éƒ½æ˜¯é€šè¿‡mediaPlayerå¯¹è±¡æ’­æ”¾çš„ virtual status_t decode() = 0; éŸ³é¢‘è§£ç å™¨ 4.3.3ã€MediaRecorderç±»å’Œæ¥å£ä¹‹é—´å…³ç³» mediaRecorderåŠŸèƒ½å°±æ˜¯æ¥å½•åƒçš„ã€‚å…¶ä¸­MediaRecorderç±»ä¸­ï¼ŒåŒ…å«äº†BpMediaRecorderä»£ç†å¯¹è±¡å¼•ç”¨ã€‚MediaRecorderClientæœ¬åœ°å¯¹è±¡é©»ç•™åœ¨mediaPlayServiceä¸­ã€‚å®ƒçš„æ¥å£æ¯”è¾ƒå¤šï¼Œè¿™é‡Œå°±åˆ—å‡ºæˆ‘ä»¬ä»Šå¤©å…³æ³¨çš„å‡ ä¸ªæ¥å£ã€‚å…¶å®ƒæ¥å£æŸ¥çœ‹æºç å§è¯¦ç»†ä»‹ç»å¯ä»¥å‚è€ƒæºç ï¼šframeworks/av/include/media/IMediaRecorder.h| æ¥å£ç±»å‹ | æ¥å£è¯´æ˜|| :â€”â€”â€“ |: â€”â€”â€“|| virtual status_t setCamera(const sp&amp; camera,const sp&amp; proxy) = 0; | è¿™ä¸ªæ¥å£ä¹Ÿæ˜¯éå¸¸éœ€è¦æˆ‘ä»¬å…³æ³¨çš„ï¼Œè¿™é‡Œè·å–åˆ°äº†å¯åŠ¨å½•åƒæ“ä½œçš„æœ¬åœ°å¯¹è±¡(BnCameraRecordingProxyï¼‰ï¼Œå¹¶é€šè¿‡åŒ¿åbinderé€šä¿¡æ–¹å¼ï¼Œç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯æœ¬åœ°å¯¹è±¡.ç„¶ååœ¨startRecordingæ—¶å°†å¸§ç›‘å¬å¯¹è±¡æ³¨å†Œåˆ°cameraæœ¬åœ°å¯¹è±¡ä¸­äº†|| virtual status_t setPreviewSurface(const sp&amp; surface) = 0; | å°†previewé¢„è§ˆsurfaceå¯¹è±¡è®¾ç½®ç»™medaiRecorderï¼Œå› ä¸ºmediaRecorderä¹Ÿæœ‰ä¸€ä¸ªcameraæœ¬åœ°client,æ‰€ä»¥è¿™ä¸ªsurfaceå¯¹è±¡æœ€ç»ˆè¿˜æ˜¯ä¼šè®¾ç½®åˆ°cameraServiceç”¨äºæ˜¾ç¤ºã€‚è€Œå½•åƒçš„å¸§ä¼šåœ¨CameraServiceæœ¬åœ°åˆ›å»ºä¸€ä¸ªbufferQueueï¼Œå…·ä½“ä¸‹é¢ä¼šè¯¦ç»†è¯´æ˜|| virtual status_t setListener(const sp&amp; listener) = 0; | è¿™é‡Œä¸€çœ‹å°±æ˜¯è®¾ç½®ç›‘å¬å¯¹è±¡ï¼Œç›‘å¬å¯¹è±¡æ˜¯jniä¸­çš„JNIMediaRecorderListenerå¯¹è±¡ï¼Œè¯¥å¯¹è±¡å¯ä»¥å›è°ƒMediaRecorder.javaç±»ä¸­çš„postEventFromNativeæ–¹æ³•ï¼Œå°†æ—¶é—´é€åˆ°javaå±‚ã€‚å…¶å®MediaRecorderå®ç°äº†BnMediaRecorderClientæ¥å£ï¼Œå³å®ç°notifyæ¥å£ï¼Œé‚£ä¹ˆè¿™é‡Œå…¶å®å°†æœ¬åœ°å¯¹è±¡ä¼ åˆ°MediaRecorderæœ¬åœ°çš„å®¢æˆ·ç«¯å¯¹è±¡ä¸­ï¼ˆæœ¬åœ°å¯¹è±¡æ‹¿åˆ°çš„å°±æ˜¯ä»£ç†å¯¹è±¡äº†ï¼‰ï¼Œå‚è€ƒä»£ç ç‰‡æ®µ1|| virtual status_t start() = 0; | å¯åŠ¨å½•åƒåŠŸèƒ½ï¼Œå‡½æ•°è¿½ç©¶ä¸‹å»å’ŒCameraå…³ç³»ä¸å¤§äº†ï¼Œè¿™é‡Œå°±ä¸ç»†è¯´äº†| 4.3.3.1ã€ä»£ç ç‰‡æ®µ11234æºç è·¯å¾„ï¼šframeworks/base/media/jni/android_media_MediaRecorder.cpp// create new listener and give it to MediaRecordersp&lt;JNIMediaRecorderListener&gt; listener = new JNIMediaRecorderListener(env, thiz, weak_this);mr-&gt;setListener(listener); mediaRecorder jniæ¥å£å›è°ƒjavaæ–¹æ³•ï¼Œé€šçŸ¥ä¸Šå±‚nativeäº‹ä»¶ã€‚ 4.3.3.2ã€ä»£ç ç‰‡æ®µ2123456789101112131415161718192021222324252627282930313233343536373839404142434445[-&gt;\\frameworks\\base\\media\\jni\\android_media_MediaRecorder.cpp]static void android_media_MediaRecorder_setCamera(JNIEnv* env, jobject thiz, jobject camera)&#123;// we should not pass a null camera to get_native_camera() call.//è¿™é‡Œæ£€æŸ¥cameraæ˜¯ä¸æ˜¯ç©ºçš„ï¼Œæ˜¾ç„¶ä¸æ˜¯ç©ºçš„ã€‚ //è¿™ä¸ªåœ°æ–¹éœ€è¦å¥½å¥½ç ”ç©¶ä¸€ä¸‹ï¼Œå…¶ä¸­cameraæ˜¯javaå±‚çš„cameraå¯¹è±¡(å³camera.java) //è¿™é‡Œç”±javaå¯¹è±¡è·å–åˆ°cameraåº”ç”¨ç«¯æœ¬åœ°å¯¹è±¡ã€‚ sp&lt;Camera&gt; c = get_native_camera(env, camera, NULL); if (c == NULL) &#123; // get_native_camera will throw an exception in this case return; &#125; //è·å–mediaRecorderæœ¬åœ°å¯¹è±¡ sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz); //ä¸‹é¢è¦ç‰¹åˆ«æ³¨æ„ï¼Œè¿™é‡Œä¸ºä»€ä¹ˆä¼ å…¥çš„ä¸æ˜¯Cameraå¯¹è±¡è€Œæ˜¯c-&gt;remote()ï¼Œå½“æ—¶ç¢ç£¨ //ç€ï¼Œcamera.cppä¹Ÿæ²¡å®ç°ä»€ä¹ˆä»£ç†ç±»çš„æ¥å£å•Šï¼Œä¸è¿‡åæ¥åœ¨cameraBaseç±»ä¸­å‘ç° //é‡è½½äº†remote()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•è¿”å›ICameraä»£ç†å¯¹è±¡ï¼Œå‘µå‘µã€‚è¿™æ ·çš„è¯å°±ä¼šåœ¨ //mediaRecorderä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„ICameraä»£ç†å¯¹è±¡ã€‚å¹¶åœ¨mediaPlayerServiceä¸­ //åˆ›å»ºäº†ä¸€ä¸ªæœ¬åœ°çš„Cameraå¯¹è±¡ã€‚ //c-&gt;getRecordingProxy():è·å–cameraæœ¬åœ°å¯¹è±¡å®ç°çš„Recordingæœ¬åœ°å¯¹è±¡ã€‚è¿™é‡Œ //è°ƒç”¨setCameraè®¾ç½®åˆ°mediaRecorderæœ¬åœ°å¯¹è±¡ä¸­äº†(è§ä»£ç ç‰‡æ®µï¼“) process_media_recorder_call(env, mr-&gt;setCamera(c-&gt;remote(), c-&gt;getRecordingProxy()), \"java/lang/RuntimeException\", \"setCamera failed.\");&#125;//cameraç«¯sp&lt;ICameraRecordingProxy&gt; Camera::getRecordingProxy() &#123; ALOGV(\"getProxy\"); return new RecordingProxy(this);&#125;//çœ‹çœ‹ä¸‹é¢RecordingProxyå®ç°äº†BnCameraRecordingProxyæ¥å£ï¼Œ//æ˜¯ä¸ªæœ¬åœ°å¯¹è±¡ï¼Œæ°´è½çŸ³å‡ºäº†ã€‚class RecordingProxy : public BnCameraRecordingProxy &#123; public: RecordingProxy(const sp&lt;Camera&gt;&amp; camera); // ICameraRecordingProxy interface virtual status_t startRecording(const sp&lt;ICameraRecordingProxyListener&gt;&amp; listener); virtual void stopRecording(); virtual void releaseRecordingFrame(const sp&lt;IMemory&gt;&amp; mem); private: //è¿™é‡Œçš„æ˜¯mCameraå·²ç»ä¸å†æ˜¯ä¹‹å‰previewå¯åŠ¨æ—¶å¯¹åº”çš„é‚£ä¸ªæœ¬åœ°Cameraå¯¹è±¡ //è¿™æ˜¯mediaRecorderé‡æ–°åˆ›å»ºçš„cameraæœ¬åœ°å¯¹è±¡ã€‚ sp&lt;Camera&gt; mCamera; &#125;; 4.3.3.3ã€ä»£ç ç‰‡æ®µ3-setCameraæœ¬åœ°å®ç°123456789101112131415161718192021222324252627282930[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\MediaRecorderClient.cpp]status_t MediaRecorderClient::setCamera(const sp&lt;ICamera&gt;&amp; camera, const sp&lt;ICameraRecordingProxy&gt;&amp; proxy)&#123; ALOGV(\"setCamera\"); Mutex::Autolock lock(mLock); if (mRecorder == NULL) &#123; ALOGE(\"recorder is not initialized\"); return NO_INIT; &#125; return mRecorder-&gt;setCamera(camera, proxy);&#125;//æ„é€ å‡½æ•°ä¸­å¯ä»¥çœ‹åˆ°åˆ›å»ºäº†ä¸€ä¸ªStagefrightRecorderå¯¹è±¡ï¼Œåç»­çš„å…¶å®ƒæ“ä½œ//éƒ½æ˜¯é€šè¿‡mRecorderå¯¹è±¡å®ç°çš„MediaRecorderClient::MediaRecorderClient(const sp&lt;MediaPlayerService&gt;&amp; service, pid_t pid)&#123; ALOGV(\"Client constructor\"); mPid = pid; mRecorder = new StagefrightRecorder; mMediaPlayerService = service;&#125;//StagefrightRecorder::setCameraå®ç°struct StagefrightRecorder : public MediaRecorderBase &#123;&#125;status_t StagefrightRecorder::setCamera(const sp&lt;ICamera&gt; &amp;camera, const sp&lt;ICameraRecordingProxy&gt; &amp;proxy) &#123;//çœå»ä¸€äº›é”™è¯¯æ£€æŸ¥ä»£ç  mCamera = camera; mCameraProxy = proxy; return OK;&#125; æœ€ç»ˆICamera,ICameraRecordingProxyä»£ç†å¯¹è±¡éƒ½å­˜æ”¾åˆ°StagefrightRecorderå¯¹åº”çš„æˆå‘˜å˜é‡ä¸­ï¼Œçœ‹æ¥çŒªè„šå°±åœ¨è¿™ä¸ªç±»ä¸­ã€‚ 4.3.3.4ã€ä»£ç ç‰‡æ®µ412345678910111213141516171819202122232425262728[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]status_t CameraSource::isCameraAvailable( const sp&lt;ICamera&gt;&amp; camera, const sp&lt;ICameraRecordingProxy&gt;&amp; proxy, int32_t cameraId, const String16&amp; clientName, uid_t clientUid) &#123; if (camera == 0) &#123; mCamera = Camera::connect(cameraId, clientName, clientUid); if (mCamera == 0) return -EBUSY; mCameraFlags &amp;= ~FLAGS_HOT_CAMERA; &#125; else &#123; // We get the proxy from Camera, not ICamera. We need to get the proxy // to the remote Camera owned by the application. Here mCamera is a // local Camera object created by us. We cannot use the proxy from // mCamera here. //æ ¹æ®ICameraä»£ç†å¯¹è±¡é‡æ–°åˆ›å»ºCameraæœ¬åœ°å¯¹è±¡ mCamera = Camera::create(camera); if (mCamera == 0) return -EBUSY; mCameraRecordingProxy = proxy; //ç›®å‰è¿˜ä¸æ¸…æ¥šæ˜¯ä»€ä¹ˆæ ‡è®°ï¼Œæƒä¸”ç†è§£æˆæ”¯æŒçƒ­æ’æ‹”æ ‡è®° mCameraFlags |= FLAGS_HOT_CAMERA; //ä»£ç†å¯¹è±¡ç»‘å®šæ­»äº¡é€šçŸ¥å¯¹è±¡ mDeathNotifier = new DeathNotifier(); // isBinderAlive needs linkToDeath to work. mCameraRecordingProxy-&gt;asBinder()-&gt;linkToDeath(mDeathNotifier); &#125; mCamera-&gt;lock(); return OK;&#125; ç”±ä¸Šé¢çš„ç±»å›¾ä¹‹é—´çš„å…³ç³»çš„ï¼Œå°±çŸ¥é“mediaRecorderé—´æ¥åŒ…å«äº†cameaSourceå¯¹è±¡ï¼Œè¿™é‡Œä¸ºäº†ç®€å•ç›´æ¥è¦å®³ä»£ç ã€‚ â˜¯ 1.åœ¨åˆ›å»ºCameraSourceå¯¹è±¡æ—¶ï¼Œä¼šå»æ£€æŸ¥ä¸€ä¸‹Cameraå¯¹è±¡æ˜¯å¦å¯ç”¨ï¼Œå¯ç”¨çš„è¯å°±ä¼šæ ¹æ®ä¼ è¿›æ¥çš„ä»£ç†å¯¹è±¡é‡æ–°åˆ›å»ºCameraæœ¬åœ°å¯¹è±¡ï¼ˆæ³¨æ„è¿™ä¸ªæ—¶å€™Cameraä»£ç†å¯¹è±¡åœ¨mediaRecorderä¸­ï¼‰â˜¯ 2.ç„¶åä¿å­˜RecordingProxyä»£ç†å¯¹è±¡åˆ°mCameraRecordingProxyæˆå‘˜ä¸­ï¼Œç„¶åç»‘å®šæ­»äº¡é€šçŸ¥å¯¹è±¡åˆ°RecordingProxyä»£ç†å¯¹è±¡ã€‚ 4.3.3.5ã€ä»£ç ç‰‡æ®µ512345678910111213141516171819202122232425[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]status_t CameraSource::startCameraRecording() &#123; ALOGV(\"startCameraRecording\"); // Reset the identity to the current thread because media server owns the // camera and recording is started by the applications. The applications // will connect to the camera in ICameraRecordingProxy::startRecording. int64_t token = IPCThreadState::self()-&gt;clearCallingIdentity(); status_t err; if (mNumInputBuffers &gt; 0) &#123; err = mCamera-&gt;sendCommand( CAMERA_CMD_SET_VIDEO_BUFFER_COUNT, mNumInputBuffers, 0); &#125; err = OK; if (mCameraFlags &amp; FLAGS_HOT_CAMERA) &#123;//å‰é¢å·²ç»ç½®ä½FLAGS_HOT_CAMERAï¼Œæˆç«‹ mCamera-&gt;unlock(); mCamera.clear(); //é€šè¿‡recordingä»£ç†å¯¹è±¡ï¼Œç›´æ¥å¯åŠ¨cameraæœ¬åœ°ç«¯çš„recording if ((err = mCameraRecordingProxy-&gt;startRecording( new ProxyListener(this))) != OK) &#123; &#125; &#125; else &#123; &#125; IPCThreadState::self()-&gt;restoreCallingIdentity(token); return err;&#125; ä¸Šé¢ä»£ç éœ€è¦æˆ‘ä»¬æ³¨æ„çš„æ˜¯åœ¨å¯åŠ¨startRecording()æ—¶ï¼Œåˆ›å»ºçš„ç›‘å¬å¯¹è±¡new ProxyListener(this),è¯¥ç›‘å¬å¯¹è±¡ä¼šä¼ åˆ°Cameraæœ¬åœ°å¯¹è±¡ä¸­ã€‚å½“å¸§å¯ç”¨æ—¶ï¼Œç”¨æ¥é€šçŸ¥mediaRecorderæœ‰å¸§å¯ä»¥ä½¿ç”¨äº†ï¼Œèµ¶ç´§ç¼–ç å§ã€‚ 4.3.3.6ã€ä»£ç ç‰‡æ®µ6-mediaRecorderæ³¨å†Œå¸§å¯ç”¨ç›‘å¬å¯¹è±¡1234567891011121314151617[-&gt;/frameworks/av/include/media/stagefright/CameraSource.h]class ProxyListener: public BnCameraRecordingProxyListener &#123; public: ProxyListener(const sp&lt;CameraSource&gt;&amp; source); virtual void dataCallbackTimestamp(int64_t timestampUs, int32_t msgType, const sp&lt;IMemory&gt; &amp;data); private: sp&lt;CameraSource&gt; mSource; &#125;;//frameworks/av/camera/Camera.cppstatus_t Camera::RecordingProxy::startRecording(const sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)&#123; ALOGV(\"RecordingProxy::startRecording\"); mCamera-&gt;setRecordingProxyListener(listener); mCamera-&gt;reconnect(); return mCamera-&gt;startRecording();&#125; æ³¨å†Œå¸§ç›‘å¬å¯¹è±¡å°±æ˜¯åœ¨å¯åŠ¨Recordingæ—¶æ³¨å†Œï¼Œä¸»è¦æœ‰ä¸‹é¢å‡ æ­¥ï¼š â˜¯ 1.ä½¿ç”¨setRecordingProxyListeneræ¥å£ï¼Œå°†ç›‘å¬å¯¹è±¡è®¾ç½®ç»™mRecordingProxyListener æˆå‘˜ã€‚â˜¯ 2.é‡æ–°å’ŒcameraServiceæ¡æ‰‹(previewåœæ­¢æ—¶å°±ä¼šæ–­å¼€é“¾æ¥ï¼Œåœ¨åˆ‡æ¢ç¬é—´å°±æ–­å¼€äº†)â˜¯ 3.ä½¿ç”¨ICameraä»£ç†å¯¹è±¡å¯åŠ¨å½•åƒã€‚ 4.4ã€é˜¶æ®µå°ç»“åˆ°è¿™é‡ŒCameraå¦‚ä½•ä½¿ç”¨medaiRecorderå½•åƒçš„åŸºæœ¬æµç¨‹å·²ç»æ¸…æ¥šäº†ï¼Œè¿™é‡Œæˆ‘ç”»äº†ä¸€ä¸ªæµç¨‹å›¾ï¼Œå¤§æ¦‚åŒ…å«ä¸‹é¢9ä¸ªæµç¨‹ã€‚ â˜¯ è¿‡ç¨‹1ï¼šä¸Šå±‚ç‚¹å‡»äº†å½•åƒåŠŸèƒ½ï¼Œæˆ–è€…å½•åƒpreviewæ¨¡å¼ä¸‹ï¼Œä¼šåˆ›å»ºä¸€ä¸ªmediaRecorDer Javaå±‚å¯¹è±¡ã€‚â˜¯ è¿‡ç¨‹2:javaå±‚mediaRecorderå¯¹è±¡è°ƒç”¨native_jni native_setupæ–¹æ³•ï¼Œåˆ›å»ºä¸€ä¸ªnativeçš„mediaRecorderå¯¹è±¡ã€‚åˆ›å»ºçš„è¿‡ç¨‹ä¸­è¿æ¥mediaPlayerService,å¹¶é€šè¿‡åŒ¿åbinderé€šä¿¡æ–¹å¼è·å–åˆ°ä¸€ä¸ªmediaRecorderClientä»£ç†å¯¹è±¡ï¼Œå¹¶ä¿å­˜åˆ°mediaRecorderå¯¹è±¡çš„æˆå‘˜å˜é‡mMediaRecorderä¸­ã€‚â˜¯ è¿‡ç¨‹3:avaå±‚çš„Cameraå¯¹è±¡ä¼ ç»™mediaRecorder nativeå±‚æ—¶ï¼Œå¯ä»¥é€šè¿‡æœ¬åœ°æ–¹æ³•è·å–åˆ°Cameraæœ¬åœ°å¯¹è±¡å’ŒICameraä»£ç†å¯¹è±¡ã€‚è¿™é‡Œæ˜¯è·å–ICameraä»£ç†å¯¹è±¡å’ŒRecordingProxyæœ¬åœ°å¯¹è±¡â˜¯ è¿‡ç¨‹4:å°†ICameraä»£ç†å¯¹è±¡å’ŒRecordingProxyæœ¬åœ°å¯¹è±¡ä¼ ç»™åœ¨MedaiServiceæœ¬åœ°ç«¯çš„MediaRecorderClientå¯¹è±¡ï¼Œè¿™æ—¶ICameraæ˜¯é‡æ–°åˆ›å»ºçš„ICamerä»£ç†å¯¹è±¡ï¼Œä»¥åŠè·å–åˆ°RecordingProxyä»£ç†å¯¹è±¡ã€‚â˜¯ è¿‡ç¨‹5ï¼šæ ¹æ®è¿‡ç¨‹ï¼”è·å–åˆ°çš„æ–°çš„ICameraä»£ç†å¯¹è±¡å’ŒRecordingProxyä»£ç†å¯¹è±¡ï¼Œåˆ›å»ºæ–°çš„æœ¬åœ°Cameraå¯¹è±¡Camera2ï¼Œä»¥åŠæ³¨å†Œå½•åƒå¸§ç›‘å¬å¯¹è±¡åˆ°Camera2ä¸­ã€‚â˜¯ è¿‡ç¨‹6ï¼šå¯åŠ¨StartRecordingâ˜¯ è¿‡ç¨‹7:å½“å½•åƒå¸§å¯ç”¨æ—¶ï¼Œé€šçŸ¥é©»ç•™åœ¨MedaiRecorderClientä¸­çš„Camera2æœ¬åœ°å¯¹è±¡æ”¶å¸§ï¼Œäºæ­¤åŒæ—¶Camera2åˆæ˜¯é€šè¿‡æ³¨å†Œçš„å¸§ç›‘å¬å¯¹è±¡å‘ŠçŸ¥MediaClientClientå¯¹è±¡ã€‚MediaClientClientå¯¹è±¡æ‹¿åˆ°å¸§åè¿›è¡Œå½•åƒç¼–ç ã€‚â˜¯ è¿‡ç¨‹8,è¿‡ç¨‹ï¼™ï¼šé€šè¿‡å›è°ƒå‡½æ•°ï¼Œå°†ä¸€äº›æ¶ˆæ¯å‘é€ç»™åº”ç”¨ç«¯ã€‚ 4.5ã€Camera videoåˆ›å»ºBufferQueue.12345678910111213141516171819202122232425262728293031323334353637383940[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]status_t StreamingProcessor::updateRecordingStream(const Parameters &amp;params) &#123; ATRACE_CALL(); status_t res; Mutex::Autolock m(mMutex); sp&lt;CameraDeviceBase&gt; device = mDevice.promote(); //---------------- bool newConsumer = false; if (mRecordingConsumer == 0) &#123; ALOGV(\"%s: Camera %d: Creating recording consumer with %zu + 1 \" \"consumer-side buffers\", __FUNCTION__, mId, mRecordingHeapCount); // Create CPU buffer queue endpoint. We need one more buffer here so that we can // always acquire and free a buffer when the heap is full; otherwise the consumer // will have buffers in flight we'll never clear out. sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferConsumer&gt; consumer; //åˆ›å»ºbufferQueueï¼ŒåŒæ—¶è·å–åˆ°ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…å¯¹è±¡ã€‚ BufferQueue::createBufferQueue(&amp;producer, &amp;consumer); //æ³¨æ„ä¸‹é¢è®¾ç½®bufferçš„ç”¨å¤„æ˜¯GRALLOC_USAGE_HW_VIDEO_ENCODERï¼Œè¿™ä¸ªä¼šåœ¨ //mediaRecorderä¸­ä½¿ç”¨åˆ°ã€‚ mRecordingConsumer = new BufferItemConsumer(consumer, GRALLOC_USAGE_HW_VIDEO_ENCODER, mRecordingHeapCount + 1); mRecordingConsumer-&gt;setFrameAvailableListener(this); mRecordingConsumer-&gt;setName(String8(\"Camera2-RecordingConsumer\")); mRecordingWindow = new Surface(producer); newConsumer = true; // Allocate memory later, since we don't know buffer size until receipt &#125;//æ›´æ–°éƒ¨åˆ†ä»£ç ï¼Œå°±ä¸è´´å‡ºæ¥äº†ï¼ï¼ï¼ï¼//æ³¨æ„ä¸‹é¢video å½•åƒbufferçš„åƒç´ æ ¼å¼æ˜¯CAMERA2_HAL_PIXEL_FORMAT_OPAQUE if (mRecordingStreamId == NO_STREAM) &#123; mRecordingFrameCount = 0; res = device-&gt;createStream(mRecordingWindow, params.videoWidth, params.videoHeight, CAMERA2_HAL_PIXEL_FORMAT_OPAQUE, &amp;mRecordingStreamId); &#125; return OK;&#125; ä¸»è¦å¤„ç†ä¸‹é¢å‡ ä»¶äº‹æƒ…ã€‚ â˜¯ 1.ç”±äºå½•åƒä¸éœ€è¦æ˜¾ç¤ºï¼Œè¿™é‡Œåˆ›å»ºCameraService BufferQueueæœ¬åœ°å¯¹è±¡ï¼Œè¿™ä¸ªæ—¶å€™è·å–åˆ°çš„ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…éƒ½æ˜¯æœ¬åœ°çš„ï¼Œåªæœ‰BufferQueueä¿å­˜çš„æœ‰IGraphicBufferAllocä»£ç†å¯¹è±¡mAllocatorï¼Œä¸“é—¨ç”¨æ¥åˆ†é…bufferã€‚â˜¯ 2.ç”±äºStremingProcess.cppä¸­å®ç°äº†FrameAvailableListenerç›‘å¬æ¥å£æ–¹æ³•onFrameAvailable()ã€‚è¿™é‡Œä¼šé€šè¿‡setFrameAvailableListeneræ–¹æ³•æ³¨å†Œåˆ°BufferQueueä¸­ã€‚â˜¯ 3.æ ¹æ®ç”Ÿäº§è€…å¯¹è±¡åˆ›å»ºsurfaceå¯¹è±¡ï¼Œå¹¶ä¼ ç»™Camera3Deviceç”³è¯·å½•åƒbuffer.â˜¯ 4.å¦‚æœå‚æ•°æœ‰åå·®æˆ–è€…ä¹‹å‰å·²ç»åˆ›å»ºè¿‡video Stream.è¿™é‡Œä¼šåˆ é™¤æˆ–è€…æ›´æ–°videoStream.å¦‚æœå‹æ ¹æ²¡æœ‰åˆ›å»ºVideoStream,ç›´æ¥åˆ›å»ºVideoStreamå¹¶æ ¹æ®å‚æ•°æ›´æ–°æµä¿¡æ¯ã€‚ 4.6ã€ä½•æ—¶å½•åƒå¸§å¯ç”¨4.6.1ã€onFrameAvailable()12345678910[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]void StreamingProcessor::onFrameAvailable(const BufferItem&amp; /*item*/) &#123; ATRACE_CALL(); Mutex::Autolock l(mMutex); if (!mRecordingFrameAvailable) &#123; mRecordingFrameAvailable = true; mRecordingFrameAvailableSignal.signal(); &#125;&#125; å½“video bufferè¿›è¡Œenqueueæ“ä½œå,è¯¥å‡½æ•°ä¼šè¢«è°ƒç”¨ã€‚å‡½æ•°ä¸­å¯ç”¨å‘ç°ï¼Œæ¿€æ´»äº†StreamingProcessorä¸»çº¿ç¨‹ã€‚ 4.6.2ã€StreamingProcessorçº¿ç¨‹loop12345678910111213141516171819[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]bool StreamingProcessor::threadLoop() &#123; status_t res; &#123; Mutex::Autolock l(mMutex); while (!mRecordingFrameAvailable) &#123; //ä¹‹å‰æ˜¯åœ¨è¿™é‡ŒæŒ‚èµ·çš„,ç°åœ¨æœ‰å¸§å¯ç”¨å°±ä¼šä»è¿™é‡Œå”¤é†’ã€‚ res = mRecordingFrameAvailableSignal.waitRelative( mMutex, kWaitDuration); if (res == TIMED_OUT) return true; &#125; mRecordingFrameAvailable = false; &#125; do &#123; res = processRecordingFrame();//è¿›ä¸€æ­¥å¤„ç†ã€‚ &#125; while (res == OK); return true;&#125; åˆ°è¿™é‡Œå‘ç°ï¼ŒåŸæ¥StreamingProcessorä¸»çº¿ç¨‹åªä¸ºå½•åƒæœåŠ¡ï¼ŒpreviewStreamåªæ˜¯ä½¿ç”¨äº†å®ƒçš„å‡ ä¸ªæ–¹æ³•è€Œå·²ã€‚ 4.6.3ã€å¸§å¯ç”¨æ¶ˆæ¯å‘é€ç»™Cameraæœ¬åœ°å¯¹è±¡123456789101112131415161718192021222324[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\api1\\client2\\StreamingProcessor.cpp]status_t StreamingProcessor::processRecordingFrame() &#123; ATRACE_CALL(); status_t res; sp&lt;Camera2Heap&gt; recordingHeap; size_t heapIdx = 0; nsecs_t timestamp; sp&lt;Camera2Client&gt; client = mClient.promote(); BufferItemConsumer::BufferItem imgBuffer; //å–å‡ºbufferæ¶ˆè´¹ï¼Œå°±æ˜¯æ‹¿ç»™mediaRecorderç¼–ç  res = mRecordingConsumer-&gt;acquireBuffer(&amp;imgBuffer, 0); //---------------------------- // Call outside locked parameters to allow re-entrancy from notification Camera2Client::SharedCameraCallbacks::Lock l(client-&gt;mSharedCameraCallbacks); if (l.mRemoteCallback != 0) &#123; //è°ƒç”¨Callbacké€šçŸ¥Cameaæœ¬åœ°å¯¹è±¡ã€‚ l.mRemoteCallback-&gt;dataCallbackTimestamp(timestamp, CAMERA_MSG_VIDEO_FRAME, recordingHeap-&gt;mBuffers[heapIdx]); &#125; else &#123; ALOGW(\"%s: Camera %d: Remote callback gone\", __FUNCTION__, mId); &#125; return OK; ä¹‹å‰æˆ‘ä»¬å·²ç»çŸ¥é“Cameraè¿è¡Œæ—¶å­˜åœ¨ç±»å‹ä¸ºICameraClientçš„ä¸¤ä¸ªå¯¹è±¡,å…¶ä¸­ä¸€ä¸ªä»£ç†å¯¹è±¡ä¿å­˜åœ¨CameraServiceä¸­ï¼Œæœ¬åœ°å¯¹è±¡ä¿å­˜çš„Cameraæœ¬åœ°å¯¹è±¡ä¸­ã€‚è¿™é‡Œä»£ç†å¯¹è±¡é€šçŸ¥æœ¬åœ°å¯¹è±¡å–å¸§äº†ã€‚æ³¨æ„è¿™é‡Œæ¶ˆæ¯å‘é€çš„æ˜¯â€œCAMERA_MSG_VIDEO_FRAMEâ€ã€‚ 4.6.4ã€Cameraæœ¬åœ°å¯¹è±¡è½¬å‘æ¶ˆæ¯ç»™mediaRecorder.12345678910111213141516171819[-&gt;/frameworks/av/camera/Camera.cpp]void Camera::dataCallbackTimestamp(nsecs_t timestamp, int32_t msgType, const sp&lt;IMemory&gt;&amp; dataPtr)&#123; // If recording proxy listener is registered, forward the frame and return. // The other listener (mListener) is ignored because the receiver needs to // call releaseRecordingFrame. sp&lt;ICameraRecordingProxyListener&gt; proxylistener; &#123; //è¿™é‡ŒmRecordingProxyListenerå°±æ˜¯mediaRecorderæ³¨å†Œè¿‡æ¥çš„ç›‘å¬ä»£ç†å¯¹è±¡ Mutex::Autolock _l(mLock); proxylistener = mRecordingProxyListener; &#125; if (proxylistener != NULL) &#123; //è¿™é‡Œå°±æŠŠbufferé€åˆ°äº†mediaRecorderä¸­è¿›è¡Œç¼–ç  proxylistener-&gt;dataCallbackTimestamp(timestamp, msgType, dataPtr); return; &#125; //---------çœç•¥ä»£ç &#125; åˆ°è¿™é‡ŒCameraæœ¬åœ°å¯¹è±¡å°±ä¼šè°ƒç”¨mediaRecorderæ³¨å†Œæ¥çš„å¸§ç›‘å¬å¯¹è±¡ã€‚å‰é¢æˆ‘ä»¬å·²ç»åšäº†é‚£ä¹ˆé•¿çš„é“ºå«ï¼Œæˆ‘æƒ³åº”è¯¥å¯ä»¥ç†è§£äº†ã€‚å¥½äº†,mediaRecorderæœ‰é¥­åƒäº†ã€‚ 4.7ã€æ€»ç»“1.ä¸€å¼€å§‹æˆ‘è‡ªä»¥ä¸ºpreviewå’ŒVideoä½¿ç”¨åŒä¸€ä¸ªcameraæœ¬åœ°å¯¹è±¡ï¼Œçœ‹äº†ä»£ç å‘ç°ï¼ŒåŸæ¥æ˜¯ä¸åŒçš„å¯¹è±¡ã€‚2.é¢„è§ˆçš„BufferQueueæ˜¯åœ¨CameraServiceä¸­åˆ›å»ºçš„ï¼Œå’ŒsurfaceFlingeræ²¡æœ‰å…³ç³»ï¼Œåªæ˜¯ä¿ç•™äº†IGraphicBufferAllocä»£ç†å¯¹è±¡mAllocatorï¼Œç”¨äºåˆ†é…buffer.3.ä¹‹åŒ¿åbinderæ²¡æœ‰ç†è§£é€å½»ï¼Œä»¥ä¸ºåªæœ‰ä¼ é€’æœ¬åœ°å¯¹è±¡æ‰èƒ½ä½¿ç”¨writeStrongBinder()æ¥å£ä¿å­˜binderå¯¹è±¡ï¼ŒåŒæ—¶åœ¨ä½¿ç”¨ç«¯ä½¿ç”¨readStrongBinder()å°±å¯ä»¥è·å–åˆ°ä»£ç†å¯¹è±¡äº†ã€‚å…¶å®ä¹Ÿå¯ä»¥ä¼ é€’ä»£ç†å¯¹è±¡ï¼Œåªä¸è¿‡ä»£ç ä¼šèµ°å¦å¤–ä¸€å¥—é€»è¾‘ï¼Œåœ¨kernelä¸­é‡æ–°åˆ›å»ºä¸€ä¸ªbinder_refç´¢å¼•å¯¹è±¡è¿”å›ç»™å¦ä¸€ç«¯ã€‚å¦‚ä¸‹mediaRecorderè®¾ç½®cameraæ—¶å°±æ˜¯ä¼ é€’çš„ICameraä»£ç†å¯¹è±¡ã€‚ 123456789101112[-&gt;/frameworks/av/media/libmedia/IMediaRecorder.cpp] status_t setCamera(const sp&lt;ICamera&gt;&amp; camera, const sp&lt;ICameraRecordingProxy&gt;&amp; proxy) &#123; ALOGV(\"setCamera(%p,%p)\", camera.get(), proxy.get()); Parcel data, reply; data.writeInterfaceToken(IMediaRecorder::getInterfaceDescriptor()); //camera-&gt;asBinder()æ˜¯ICameraä»£ç†å¯¹è±¡ data.writeStrongBinder(camera-&gt;asBinder()); data.writeStrongBinder(proxy-&gt;asBinder()); remote()-&gt;transact(SET_CAMERA, data, &amp;reply); return reply.readInt32(); &#125; ï¼ˆäº”ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroid Cameraå®˜æ–¹æ–‡æ¡£Android 5.0 Cameraç³»ç»Ÿæºç åˆ†æ-CSDNåšå®¢Android Camera æµç¨‹å­¦ä¹ è®°å½• - StoneDemo - åšå®¢å›­Android Camera ç³»ç»Ÿæ¶æ„æºç åˆ†æ - CSDNåšå®¢Cameraå®‰å“æºç -é«˜é€šmm_cameraæ¶æ„å‰–æ - CSDNåšå®¢5.2 åº”ç”¨ç¨‹åºå’Œé©±åŠ¨ç¨‹åºä¸­bufferçš„ä¼ è¾“æµç¨‹ - CSDNåšå®¢Camera2 æ•°æ®æµä»frameworkåˆ°Halæºç åˆ†æ - ç®€ä¹¦mm-cameraå±‚frameæ•°æ®æµæºç åˆ†æ - ç®€ä¹¦v4l2_capture.cåˆ†æâ€”probeå‡½æ•°åˆ†æ - CSDNåšå®¢@@Android Camera fwå­¦ä¹  - CSDNåšå®¢@@Android Camera API2åˆ†æ - CSDNåšå®¢@@Android Camera æµç¨‹å­¦ä¹ è®°å½• 7.12- CSDNåšå®¢@@ä¸“æ ï¼šå¤å†¥çš„android6.0ä¸‹çš„Camera API2.0çš„æºç åˆ†æä¹‹æ—… - CSDNåšå®¢linux3.3 v4l2è§†é¢‘é‡‡é›†é©±åŠ¨æ¡†æ¶(vfe, camera i2c driverï¼Œv4l2_subdevç­‰ä¹‹é—´çš„è”ç³») - CSDNåšå®¢Android Cameraä»Camera HAL1åˆ°Camera HAL3çš„è¿‡æ¸¡ï¼ˆå·²æ›´æ–°åˆ°Android6.0 HAL3.3ï¼‰ - CSDNåšå®¢æˆ‘å¿ƒä¾æ—§ä¹‹Android Cameraæ¨¡å—FW/HAL3æ¢å­¦åº - CSDNåšå®¢Android Camera fwå­¦ä¹ (å››)-recordingæµç¨‹åˆ†æ - CSDNåšå®¢android cameraåŠ¨æ€åº“åŠ è½½è¿‡ç¨‹ - CSDNåšå®¢Android Camera API2.0ä¸‹å…¨æ–°çš„Camera FW/HALæ¶æ„ç®€è¿° - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Camera Systemï¼ˆ1ï¼‰ï¼šCamera System(Camera ç³»ç»Ÿ)æ¡†æ¶ã€Open()è¿‡ç¨‹åˆ†æ","slug":"Android Camera Systemï¼ˆ1ï¼‰ï¼šCamera System[Camera ç³»ç»Ÿ]æ¡†æ¶ã€Openè¿‡ç¨‹åˆ†æ","date":"2018-06-29T16:00:00.000Z","updated":"2018-05-25T12:12:49.774Z","comments":true,"path":"2018/06/30/Android Camera Systemï¼ˆ1ï¼‰ï¼šCamera System[Camera ç³»ç»Ÿ]æ¡†æ¶ã€Openè¿‡ç¨‹åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/06/30/Android Camera Systemï¼ˆ1ï¼‰ï¼šCamera System[Camera ç³»ç»Ÿ]æ¡†æ¶ã€Openè¿‡ç¨‹åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Camera fwå­¦ä¹ -Armwindã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Camera API2åˆ†æ-Gzzaigcnforeverã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android Camera æµç¨‹å­¦ä¹ è®°å½• Android 7.12-QQ_16775897ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - ä¸“æ ï¼šå¤å†¥çš„android6.0ä¸‹çš„Camera API2.0çš„æºç åˆ†æä¹‹æ—…ã€‘Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ğŸŒ€ğŸŒ€ï¼šä¸“æ³¨äºLinux &amp;&amp; Android Multimediaï¼ˆCameraã€Videoã€Audioã€Displayï¼‰ç³»ç»Ÿåˆ†æä¸ç ”ç©¶ â˜¯ Applicationï¼šâ˜¯ /packages/apps/Camera2/src/com/android/camera/ â˜¯ Frameworkï¼šâ˜¯ /frameworks/base/core/java/android/hardware/Camera.java â˜¯ JNI:â˜¯ /frameworks/base/core/jni/android_hardware_Camera.cpp â˜¯ Native:â˜¯ Clientï¼šframeworks/av/camera/CameraBase.cppframeworks/av/camera/Camera.cppframeworks/av/camera/ICamera.cppframeworks/av/camera/aidl/android/hardware/ICamera.aidlframeworks/av/camera/aidl/android/hardware/ICameraClient.aidlâ˜¯ Serverï¼šframeworks/av/camera/cameraserver/main_cameraserver.cppframeworks/av/services/camera/libcameraservice/CameraService.cppframeworks/av/services/camera/libcameraservice/api1/CameraClient.cppframeworks/av/camera/aidl/android/hardware/ICameraService.aidl â˜¯ HALï¼šâ˜¯ /frameworks/av/services/camera/libcameraservice/device3/â˜¯ /hardware/qcom/camera/QCamera2(é«˜é€šHAL)â˜¯ /vendor/qcom/proprietary/mm-camera(é«˜é€šmm-camera)â˜¯ /vendor/qcom/proprietary/mm-still(é«˜é€šJPEG) â˜¯ Kernelï¼šâ˜¯ /kernel/drivers/media/platform/msm/camera_v2(é«˜é€šV4L2)â˜¯ /kernel/arch/arm/boot/dts/(é«˜é€šdts) ï¼ˆä¸€ï¼‰ã€Android Camera System Architectureï¼ˆCameraç³»ç»Ÿæ¡†æ¶ï¼‰1.1ã€Android Camera Systemæ€»ä½“æ¡†æ¶ï¼ˆQualcommå¹³å°ï¼‰1.1.1ã€é¦–å…ˆçœ‹çœ‹Android å®˜æ–¹Cameraæ€»ä½“æ¶æ„ï¼š â˜¯åº”ç”¨æ¡†æ¶åº”ç”¨ä»£ç ä½äºåº”ç”¨æ¡†æ¶çº§åˆ«ï¼Œå®ƒåˆ©ç”¨ android.hardware.Camera API æ¥ä¸ç›¸æœºç¡¬ä»¶è¿›è¡Œäº’åŠ¨ã€‚åœ¨å†…éƒ¨ï¼Œæ­¤ä»£ç ä¼šè°ƒç”¨ç›¸åº”çš„ JNI ç²˜åˆç±»ï¼Œä»¥è®¿é—®ä¸è¯¥ç›¸æœºäº’åŠ¨çš„åŸç”Ÿä»£ç ã€‚â˜¯JNIä¸ android.hardware.Camera å…³è”çš„ JNI ä»£ç ä½äº frameworks/base/core/jni/android_hardware_Camera.cpp ä¸­ã€‚æ­¤ä»£ç ä¼šè°ƒç”¨è¾ƒä½çº§åˆ«çš„åŸç”Ÿä»£ç ä»¥è·å–å¯¹ç‰©ç†ç›¸æœºçš„è®¿é—®æƒé™ï¼Œå¹¶è¿”å›ç”¨äºåœ¨æ¡†æ¶çº§åˆ«åˆ›å»º android.hardware.Camera å¯¹è±¡çš„æ•°æ®ã€‚â˜¯åŸç”Ÿæ¡†æ¶åœ¨ frameworks/av/camera/Camera.cpp ä¸­å®šä¹‰çš„åŸç”Ÿæ¡†æ¶å¯æä¾›ç›¸å½“äº android.hardware.Camera ç±»çš„åŸç”Ÿç±»ã€‚æ­¤ç±»ä¼šè°ƒç”¨ IPC binder ä»£ç†ï¼Œä»¥è·å–å¯¹ç›¸æœºæœåŠ¡çš„è®¿é—®æƒé™ã€‚â˜¯Binder IPC ä»£ç†IPC binder ä»£ç†ç”¨äºä¿ƒè¿›è·¨è¶Šè¿›ç¨‹è¾¹ç•Œçš„é€šä¿¡ã€‚è°ƒç”¨ç›¸æœºæœåŠ¡çš„ frameworks/av/camera ç›®å½•ä¸­æœ‰ 3 ä¸ªç›¸æœº binder ç±»ã€‚ICameraService æ˜¯ç›¸æœºæœåŠ¡çš„æ¥å£ï¼ŒICamera æ˜¯å·²æ‰“å¼€çš„ç‰¹å®šç›¸æœºè®¾å¤‡çš„æ¥å£ï¼ŒICameraClient æ˜¯è¿”å›åº”ç”¨æ¡†æ¶çš„è®¾å¤‡æ¥å£ã€‚â˜¯ç›¸æœºæœåŠ¡ä½äº frameworks/av/services/camera/libcameraservice/CameraService.cpp ä¸‹çš„ç›¸æœºæœåŠ¡æ˜¯ä¸ HAL è¿›è¡Œäº’åŠ¨çš„å®é™…ä»£ç ã€‚â˜¯HALç¡¬ä»¶æŠ½è±¡å±‚å®šä¹‰äº†ç”±ç›¸æœºæœåŠ¡è°ƒç”¨ä¸”æ‚¨å¿…é¡»å®ç°ä»¥ç¡®ä¿ç›¸æœºç¡¬ä»¶æ­£å¸¸è¿è¡Œçš„æ ‡å‡†æ¥å£ã€‚â˜¯å†…æ ¸é©±åŠ¨ç¨‹åºç›¸æœºçš„é©±åŠ¨ç¨‹åºå¯ä¸å®é™…ç›¸æœºç¡¬ä»¶ä»¥åŠæ‚¨çš„ HAL å®ç°è¿›è¡Œäº’åŠ¨ã€‚ç›¸æœºå’Œé©±åŠ¨ç¨‹åºå¿…é¡»æ”¯æŒ YV12 å’Œ NV21 å›¾ç‰‡æ ¼å¼ï¼Œä»¥ä¾¿åœ¨æ˜¾ç¤ºå’Œè§†é¢‘å½•åˆ¶æ—¶æ”¯æŒé¢„è§ˆç›¸æœºå›¾ç‰‡ã€‚ 1.1.2ã€Qualcommå¹³å°Camera æ¶æ„Qualcommå¹³å°Camera æ¶æ„ä¸»è¦åŒºåˆ«åœ¨äºHALå±‚å’ŒKernelå±‚çš„å˜åŒ–ï¼Œæ€»ä½“æ¶æ„å›¾å¦‚ä¸‹ï¼š 1.1.2.1ã€Qualcommå¹³å°Cameraæ€»ä½“æ¶æ„ 1.1.2.2ã€Qualcommå¹³å°Cameraçš„HALã€mm-camera 1.1.2.3ã€Qualcommå¹³å°Cameraçš„Kernel 1.2ã€Android Camera API 2.0 å…¨æ–°çš„HAL å­ç³»ç»ŸAndroid 7.1.2ç°åœ¨ä½¿ç”¨çš„æ˜¯Camera API 2.0 å’Œ Camera Device 3ä»¥åŠ HAL3ã€‚ 1.2.1ã€è¯·æ±‚åº”ç”¨æ¡†æ¶é’ˆå¯¹æ•è·çš„ç»“æœå‘ç›¸æœºå­ç³»ç»Ÿå‘å‡ºè¯·æ±‚ã€‚ä¸€ä¸ªè¯·æ±‚å¯¹åº”ä¸€ç»„ç»“æœã€‚è¯·æ±‚åŒ…å«æœ‰å…³æ•è·å’Œå¤„ç†è¿™äº›ç»“æœçš„æ‰€æœ‰é…ç½®ä¿¡æ¯ã€‚å…¶ä¸­åŒ…æ‹¬åˆ†è¾¨ç‡å’Œåƒç´ æ ¼å¼ï¼›æ‰‹åŠ¨ä¼ æ„Ÿå™¨ã€é•œå¤´å’Œé—ªå…‰ç¯æ§ä»¶ï¼›3A æ“ä½œæ¨¡å¼ï¼›RAW åˆ° YUV å¤„ç†æ§ä»¶ï¼›ä»¥åŠç»Ÿè®¡ä¿¡æ¯çš„ç”Ÿæˆã€‚è¿™æ ·ä¸€æ¥ï¼Œä¾¿å¯æ›´å¥½åœ°æ§åˆ¶ç»“æœçš„è¾“å‡ºå’Œå¤„ç†ã€‚ä¸€æ¬¡å¯å‘èµ·å¤šä¸ªè¯·æ±‚ï¼Œè€Œä¸”æäº¤çš„è¯·æ±‚ä¸ä¼šå‡ºç°é˜»å¡çš„æƒ…å†µã€‚è¯·æ±‚å§‹ç»ˆæŒ‰ç…§æ¥æ”¶çš„é¡ºåºè¿›è¡Œå¤„ç†ã€‚ 1.2.2ã€HAL å’Œç›¸æœºå­ç³»ç»Ÿç›¸æœºå­ç³»ç»ŸåŒ…æ‹¬ç›¸æœºç®¡é“ä¸­ç»„ä»¶çš„å®ç°ï¼Œä¾‹å¦‚ 3A ç®—æ³•å’Œå¤„ç†æ§ä»¶ã€‚ç›¸æœº HAL ä¸ºæ‚¨æä¾›äº†å®ç°æ‚¨ç‰ˆæœ¬çš„è¿™äº›ç»„ä»¶æ‰€éœ€çš„æ¥å£ã€‚ä¸ºäº†ä¿æŒå¤šä¸ªè®¾å¤‡åˆ¶é€ å•†å’Œå›¾åƒä¿¡å·å¤„ç†å™¨ï¼ˆISPï¼Œä¹Ÿç§°ä¸ºç›¸æœºä¼ æ„Ÿå™¨ï¼‰ä¾›åº”å•†ä¹‹é—´çš„è·¨å¹³å°å…¼å®¹æ€§ï¼Œç›¸æœºç®¡é“æ¨¡å‹æ˜¯è™šæ‹Ÿçš„ï¼Œä¸”ä¸ç›´æ¥å¯¹åº”ä»»ä½•çœŸæ­£çš„ ISPã€‚ä¸è¿‡ï¼Œå®ƒä¸çœŸæ­£çš„å¤„ç†ç®¡é“è¶³å¤Ÿç›¸ä¼¼ï¼Œå› æ­¤æ‚¨å¯ä»¥æœ‰æ•ˆåœ°å°†å…¶æ˜ å°„åˆ°ç¡¬ä»¶ã€‚æ­¤å¤–ï¼Œå®ƒè¶³å¤ŸæŠ½è±¡ï¼Œå¯æ”¯æŒå¤šç§ä¸åŒçš„ç®—æ³•å’Œæ“ä½œé¡ºåºï¼Œè€Œä¸ä¼šå½±å“è´¨é‡ã€æ•ˆç‡æˆ–è·¨è®¾å¤‡å…¼å®¹æ€§ã€‚ç›¸æœºç®¡é“è¿˜æ”¯æŒåº”ç”¨æ¡†æ¶å¼€å¯è‡ªåŠ¨å¯¹ç„¦ç­‰åŠŸèƒ½çš„è§¦å‘å™¨ã€‚å®ƒè¿˜ä¼šå°†é€šçŸ¥å‘é€å›åº”ç”¨æ¡†æ¶ï¼Œä»¥é€šçŸ¥åº”ç”¨è‡ªåŠ¨å¯¹ç„¦é”å®šæˆ–é”™è¯¯ç­‰äº‹ä»¶ã€‚ RAW Bayer è¾“å‡ºåœ¨ ISP å†…éƒ¨ä¸ç»è¿‡ä»»ä½•å¤„ç†ã€‚ç»Ÿè®¡ä¿¡æ¯æ ¹æ®åŸå§‹ä¼ æ„Ÿå™¨æ•°æ®ç”Ÿæˆã€‚å°†åŸå§‹ä¼ æ„Ÿå™¨æ•°æ®è½¬æ¢ä¸º YUV çš„å„ç§å¤„ç†å—æŒ‰ä»»æ„é¡ºåºæ’åˆ—ã€‚å½“æ˜¾ç¤ºå¤šä¸ªåˆ»åº¦å’Œå‰ªè£å•å…ƒæ—¶ï¼Œæ‰€æœ‰çš„ç¼©æ”¾å™¨å•å…ƒå…±äº«è¾“å‡ºåŒºåŸŸæ§ä»¶ï¼ˆæ•°å­—ç¼©æ”¾ï¼‰ã€‚ä¸è¿‡ï¼Œæ¯ä¸ªå•å…ƒéƒ½å¯èƒ½å…·æœ‰ä¸åŒçš„è¾“å‡ºåˆ†è¾¨ç‡å’Œåƒç´ æ ¼å¼ã€‚ 1.2.3ã€HAL æ“ä½œæ‘˜è¦â˜¯ æ•è·çš„å¼‚æ­¥è¯·æ±‚æ¥è‡ªäºæ¡†æ¶ã€‚â˜¯ HAL è®¾å¤‡å¿…é¡»æŒ‰é¡ºåºå¤„ç†è¯·æ±‚ã€‚å¯¹äºæ¯ä¸ªè¯·æ±‚ï¼Œå‡äº§ç”Ÿè¾“å‡ºç»“æœå…ƒæ•°æ®ä»¥åŠä¸€ä¸ªæˆ–å¤šä¸ªè¾“å‡ºå›¾ç‰‡ç¼“å†²åŒºã€‚â˜¯ è¯·æ±‚å’Œç»“æœä»¥åŠåç»­è¯·æ±‚å¼•ç”¨çš„æµéµå®ˆå…ˆè¿›å…ˆå‡ºè§„åˆ™ã€‚â˜¯ æŒ‡å®šè¯·æ±‚çš„æ‰€æœ‰è¾“å‡ºçš„æ—¶é—´æˆ³å¿…é¡»å®Œå…¨ç›¸åŒï¼Œä»¥ä¾¿æ¡†æ¶å¯ä»¥æ ¹æ®éœ€è¦å°†å®ƒä»¬åŒ¹é…åœ¨ä¸€èµ·ã€‚â˜¯ æ‰€æœ‰æ•è·é…ç½®å’ŒçŠ¶æ€ï¼ˆä¸åŒ…æ‹¬ 3A ä¾‹ç¨‹ï¼‰éƒ½åŒ…å«åœ¨è¯·æ±‚å’Œç»“æœä¸­ã€‚ 1.2.4ã€å¯åŠ¨å’Œé¢„æœŸæ“ä½œé¡ºåº1ã€æ¡†æ¶è°ƒç”¨ camera_module_t-&gt;common.open()ï¼Œè€Œè¿™ä¼šè¿”å›ä¸€ä¸ª hardware_device_t ç»“æ„ã€‚2ã€æ¡†æ¶æ£€æŸ¥ hardware_device_t-&gt;version å­—æ®µï¼Œå¹¶ä¸ºè¯¥ç‰ˆæœ¬çš„ç›¸æœºç¡¬ä»¶è®¾å¤‡å®ä¾‹åŒ–ç›¸åº”çš„å¤„ç†ç¨‹åºã€‚å¦‚æœç‰ˆæœ¬æ˜¯ CAMERA_DEVICE_API_VERSION_3_0ï¼Œåˆ™è¯¥è®¾å¤‡ä¼šè½¬å‹ä¸º camera3_device_tã€‚3ã€æ¡†æ¶è°ƒç”¨ camera3_device_t-&gt;ops-&gt;initialize() å¹¶æ˜¾ç¤ºæ¡†æ¶å›è°ƒå‡½æ•°æŒ‡é’ˆã€‚åœ¨è°ƒç”¨ ops ç»“æ„ä¸­çš„ä»»ä½•å…¶ä»–å‡½æ•°ä¹‹å‰ï¼Œè¿™åªä¼šåœ¨ open() ä¹‹åè°ƒç”¨ä¸€æ¬¡ã€‚4ã€æ¡†æ¶è°ƒç”¨ camera3_device_t-&gt;ops-&gt;configure_streams() å¹¶æ˜¾ç¤ºåˆ° HAL è®¾å¤‡çš„è¾“å…¥/è¾“å‡ºæµåˆ—è¡¨ã€‚5ã€æ¡†æ¶ä¸º configure_streams ä¸­åˆ—å‡ºçš„è‡³å°‘ä¸€ä¸ªè¾“å‡ºæµåˆ†é… gralloc ç¼“å†²åŒºå¹¶è°ƒç”¨ camera3_device_t-&gt;ops-&gt;register_stream_buffers()ã€‚ç›¸åŒçš„æµä»…æ³¨å†Œä¸€æ¬¡ã€‚6ã€æ¡†æ¶é€šè¿‡è°ƒç”¨ camera3_device_t-&gt;ops-&gt;construct_default_request_settings() æ¥ä¸ºæŸäº›ä½¿ç”¨æƒ…å½¢è¯·æ±‚é»˜è®¤è®¾ç½®ã€‚è¿™å¯èƒ½ä¼šåœ¨ç¬¬ 3 æ­¥ä¹‹åçš„ä»»ä½•æ—¶é—´å‘ç”Ÿã€‚7ã€æ¡†æ¶é€šè¿‡åŸºäºå…¶ä¸­ä¸€ç»„é»˜è®¤è®¾ç½®çš„è®¾ç½®ä»¥åŠè‡³å°‘ä¸€ä¸ªæ¡†æ¶ä¹‹å‰æ³¨å†Œçš„è¾“å‡ºæµæ¥æ„å»ºç¬¬ä¸€ä¸ªæ•è·è¯·æ±‚å¹¶å°†å…¶å‘é€åˆ° HALã€‚å®ƒé€šè¿‡ camera3_device_t-&gt;ops-&gt;process_capture_request() å‘é€åˆ° HALã€‚HAL å¿…é¡»é˜»æ­¢æ­¤è°ƒç”¨è¿”å›ï¼Œç›´åˆ°å‡†å¤‡å¥½å‘é€ä¸‹ä¸€ä¸ªè¯·æ±‚ã€‚8ã€æ¡†æ¶ç»§ç»­æäº¤è¯·æ±‚ï¼Œå¹¶ä¸”å¯èƒ½ä¼šä¸ºå°šæœªæ³¨å†Œçš„æµè°ƒç”¨ register_stream_buffers()ï¼Œå¹¶è°ƒç”¨ construct_default_request_settings æ¥ä¸ºå…¶ä»–ä½¿ç”¨æƒ…å½¢è·å–é»˜è®¤è®¾ç½®ç¼“å†²åŒºã€‚9ã€å½“è¯·æ±‚æ•è·å¼€å§‹ï¼ˆä¼ æ„Ÿå™¨å¼€å§‹æ›å…‰ä»¥è¿›è¡Œæ•è·ï¼‰æ—¶ï¼ŒHAL ä¼šè°ƒç”¨ camera3_callback_ops_t-&gt;notify() å¹¶æ˜¾ç¤º SHUTTER äº‹ä»¶ï¼ŒåŒ…æ‹¬å¸§å·å’Œå¼€å§‹æ›å…‰çš„æ—¶é—´æˆ³ã€‚æ­¤é€šçŸ¥è°ƒç”¨å¿…é¡»åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨è¯¥å¸§å·çš„ process_capture_result() ä¹‹å‰è¿›è¡Œã€‚10ã€åœ¨æŸä¸ªç®¡é“å»¶è¿Ÿåï¼ŒHAL å¼€å§‹ä½¿ç”¨ camera3_callback_ops_t-&gt;process_capture_result() å°†å®Œæˆçš„æ•è·è¿”å›åˆ°æ¡†æ¶ã€‚è¿™äº›æ•è·æŒ‰ç…§ä¸æäº¤è¯·æ±‚ç›¸åŒçš„é¡ºåºè¿”å›ã€‚ä¸€æ¬¡å¯å‘èµ·å¤šä¸ªè¯·æ±‚ï¼Œå…·ä½“å–å†³äºç›¸æœº HAL è®¾å¤‡çš„ç®¡é“æ·±åº¦ã€‚11ã€ä¸€æ®µæ—¶é—´åï¼Œæ¡†æ¶å¯èƒ½ä¼šåœæ­¢æäº¤æ–°çš„è¯·æ±‚ã€ç­‰å¾…ç°æœ‰æ•è·å®Œæˆï¼ˆæ‰€æœ‰ç¼“å†²åŒºéƒ½å·²å¡«å……ï¼Œæ‰€æœ‰ç»“æœéƒ½å·²è¿”å›ï¼‰ï¼Œç„¶åå†æ¬¡è°ƒç”¨ configure_streams()ã€‚è¿™ä¼šé‡ç½®ç›¸æœºç¡¬ä»¶å’Œç®¡é“ï¼Œä»¥è·å¾—ä¸€ç»„æ–°çš„è¾“å…¥/è¾“å‡ºæµã€‚å¯é‡å¤ä½¿ç”¨å…ˆå‰é…ç½®ä¸­çš„éƒ¨åˆ†æµï¼›å¦‚æœè¿™äº›æµçš„ç¼“å†²åŒºå·²ç»è¿‡ HAL æ³¨å†Œï¼Œåˆ™ä¸ä¼šå†æ¬¡æ³¨å†Œã€‚å¦‚æœè‡³å°‘è¿˜æœ‰ä¸€ä¸ªå·²æ³¨å†Œçš„è¾“å‡ºæµï¼Œåˆ™æ¡†æ¶ä»ç¬¬ 7 æ­¥ç»§ç»­ï¼ˆå¦åˆ™ï¼Œéœ€è¦å…ˆå®Œæˆç¬¬ 5 æ­¥ï¼‰ã€‚12ã€æˆ–è€…ï¼Œæ¡†æ¶å¯èƒ½ä¼šè°ƒç”¨ camera3_device_t-&gt;common-&gt;close() ä»¥ç»“æŸç›¸æœºä¼šè¯ã€‚å½“æ¡†æ¶ä¸­æ²¡æœ‰å…¶ä»–å¤„äºæ´»åŠ¨çŠ¶æ€çš„è°ƒç”¨æ—¶ï¼Œå®ƒå¯èƒ½éšæ—¶ä¼šè¢«è°ƒç”¨ï¼›å°½ç®¡åœ¨æ‰€æœ‰å‘èµ·çš„æ•è·å®Œæˆï¼ˆæ‰€æœ‰ç»“æœéƒ½å·²è¿”å›ï¼Œæ‰€æœ‰ç¼“å†²åŒºéƒ½å·²å¡«å……ï¼‰ä¹‹å‰ï¼Œè°ƒç”¨å¯èƒ½ä¼šé˜»å¡ã€‚åœ¨ close è°ƒç”¨è¿”å›åï¼Œä¸å…è®¸å†ä» HAL å¯¹ camera3_callback_ops_t å‡½æ•°è¿›è¡Œæ›´å¤šè°ƒç”¨ã€‚ä¸€æ—¦è¿›è¡Œ close() è°ƒç”¨ï¼Œè¯¥æ¡†æ¶å¯èƒ½ä¸ä¼šè°ƒç”¨ä»»ä½•å…¶ä»– HAL è®¾å¤‡å‡½æ•°ã€‚13ã€åœ¨å‘ç”Ÿé”™è¯¯æˆ–å…¶ä»–å¼‚æ­¥äº‹ä»¶æ—¶ï¼ŒHAL å¿…é¡»è°ƒç”¨ camera3_callback_ops_t-&gt;notify() å¹¶è¿”å›ç›¸åº”çš„é”™è¯¯/äº‹ä»¶æ¶ˆæ¯ã€‚ä»ä¸¥é‡çš„è®¾å¤‡èŒƒå›´é”™è¯¯é€šçŸ¥è¿”å›åï¼ŒHAL åº”è¡¨ç°ä¸ºåœ¨å…¶ä¸Šè°ƒç”¨äº† close()ã€‚ä½†æ˜¯ï¼ŒHAL å¿…é¡»åœ¨è°ƒç”¨ notify() ä¹‹å‰å–æ¶ˆæˆ–å®Œæˆæ‰€æœ‰å¾…å¤„ç†çš„æ•è·ï¼Œä»¥ä¾¿åœ¨è°ƒç”¨ notify() å¹¶è¿”å›ä¸¥é‡é”™è¯¯æ—¶ï¼Œæ¡†æ¶ä¸ä¼šæ”¶åˆ°æ¥è‡ªè®¾å¤‡çš„æ›´å¤šå›è°ƒã€‚åœ¨ä¸¥é‡çš„é”™è¯¯æ¶ˆæ¯è¿”å› notify() æ–¹æ³•åï¼Œclose() ä¹‹å¤–çš„æ–¹æ³•åº”è¯¥è¿”å› -ENODEV æˆ– NULLã€‚ 1.3ã€Android Graphics å­¦ä¹ ï¼ç”Ÿäº§è€…ã€æ¶ˆè´¹è€…ã€BufferQueueä»‹ç» Graphics ç³»ç»Ÿè¯¦ç»†åˆ†æè¯·å‚è€ƒï¼šã€Android 7.1.2 (Android N) Android Graphics ç³»ç»Ÿåˆ†æã€‘(http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/) 1.4ã€Cameraç±»ä¹‹é—´çš„å…³ç³»å’Œä½œç”¨1.4.1ã€Cameraç±»å…³ç³»æ€»ä½“æ¦‚è§ˆ â˜¯ 1ã€ICameraClient: è¿™ä¸»è¦æ˜¯ä¸€äº›æ¶ˆæ¯å‘é€çš„æ¥å£ï¼ŒåŒ…æ‹¬å¸§å¯ç”¨é€šçŸ¥ï¼Œå›è°ƒä¸€äº›ä¿¡æ¯ç»™clientç­‰æ¶ˆæ¯ã€‚ä¸è¿‡è¿™é‡Œè¦æ³¨æ„çš„æ˜¯ï¼ŒBnCameraClientå¯¹è±¡å…¶å®æ˜¯åœ¨clientè¿™ç«¯ï¼Œä¸åœ¨CameraServiceç«¯ã€‚â˜¯ 2ã€ICamera:cameraçš„ä¸€äº›æ ‡å‡†æ“ä½œæ¥å£ï¼Œæ¯”å¦‚startpreviewï¼Œtakepicuture,autofocus,æ‰€æœ‰çš„æ“ä½œåŠ¨ä½œéƒ½æ˜¯ç”¨çš„è¿™ä¸€å¥—æ¥å£ã€‚â˜¯ 3ã€ICameraService: é“¾æ¥CameraæœåŠ¡ï¼ŒCamera device,è·å–Cameraæ•°é‡ï¼ŒCameraç¡¬ä»¶ä¿¡æ¯ï¼Œè§†å‚è§’ï¼Œé•œå¤´ç­‰ä¿¡æ¯ã€‚ 1.4.2ã€ICameraClient 1.4.3ã€ICamera 1.4.4ã€ICameraService ï¼ˆäºŒï¼‰ã€Android CameraServiceå¼€æœºåˆå§‹åŒ–åˆ†æé¦–å…ˆçœ‹ä¸‹æ€»ä½“æ—¶åºå›¾ï¼š 2.1ã€CameraService åˆå§‹åŒ–è¿‡ç¨‹Androidå¯åŠ¨çš„æ—¶å€™ä¼šæ”¶é›†ç³»ç»Ÿçš„.rcæ–‡ä»¶ï¼Œå¯åŠ¨å¯¹åº”çš„Native Serviceï¼š 1234567[-&gt;\\frameworks\\av\\camera\\cameraserver\\cameraserver.rc]service cameraserver /system/bin/cameraserver class main user cameraserver group audio camera input drmrpc ioprio rt 4 writepid /dev/cpuset/camera-daemon/tasks /dev/stune/top-app/tasks 1234567891011[-&gt;\\frameworks\\av\\camera\\cameraserver\\main_cameraserver.cpp]int main(int argc __unused, char** argv __unused)&#123; signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(\"ServiceManager: %p\", sm.get()); CameraService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool();&#125; CameraServiceç»§æ‰¿è‡ªBinderServiceï¼Œinstantiateä¹Ÿæ˜¯åœ¨BinderServiceä¸­å®šä¹‰çš„ï¼Œæ­¤æ–¹æ³•å°±æ˜¯è°ƒç”¨publishæ–¹æ³•ï¼Œæ‰€ä»¥æ¥çœ‹publishæ–¹æ³•ï¼š 123456[-&gt;\\frameworks\\native\\include\\binder\\BinderService.h]static status_t publish(bool allowIsolated = false) &#123; sp&lt;IServiceManager&gt; sm(defaultServiceManager()); //å°†æœåŠ¡æ·»åŠ åˆ°ServiceManager return sm-&gt;addService(String16(SERVICE::getServiceName()),new SERVICE(), allowIsolated);&#125; è¿™é‡Œï¼Œå°†ä¼šæŠŠCameraServiceæœåŠ¡åŠ å…¥åˆ°ServiceManagerè¿›è¡Œç®¡ç†ã€‚ CameraServiceçš„æ„é€ æ—¶ï¼Œä¼šè°ƒç”¨CameraServiceçš„onFirstRefæ–¹æ³•ï¼š 2.1.1ã€CameraService::onFirstRef()12345678910111213141516171819202122232425262728void CameraService::onFirstRef()&#123; ALOGI(\"CameraService process starting\"); BnCameraService::onFirstRef(); // Update battery life tracking if service is restarting BatteryNotifier&amp; notifier(BatteryNotifier::getInstance()); notifier.noteResetCamera(); notifier.noteResetFlashlight(); camera_module_t *rawModule; int err = hw_get_module(CAMERA_HARDWARE_MODULE_ID, (const hw_module_t **)&amp;rawModule); ...... mModule = new CameraModule(rawModule); err = mModule-&gt;init(); ...... mFlashlight = new CameraFlashlight(*mModule, *this); status_t res = mFlashlight-&gt;findFlashUnits(); ...... if (mModule-&gt;getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_1) &#123; mModule-&gt;setCallbacks(this); &#125; CameraService::pingCameraServiceProxy();&#125; é¦–å…ˆä¼šé€šè¿‡HALæ¡†æ¶çš„hw_get_moduleæ¥åˆ›å»ºCameraModuleå¯¹è±¡ï¼Œç„¶åä¼šå¯¹å…¶è¿›è¡Œç›¸åº”çš„åˆå§‹åŒ–ï¼Œå¹¶ä¼šè¿›è¡Œä¸€äº›å‚æ•°çš„è®¾ç½®ï¼Œå¦‚cameraçš„æ•°é‡ï¼Œé—ªå…‰ç¯çš„åˆå§‹åŒ–ï¼Œä»¥åŠå›è°ƒå‡½æ•°çš„è®¾ç½®ç­‰ï¼Œåˆ°è¿™é‡Œï¼ŒCamera2 HALçš„æ¨¡å—å°±åˆå§‹åŒ–ç»“æŸäº†ã€‚ 2.1.2ã€Camera åŠ¨æ€åº“åŠ è½½è¿‡ç¨‹åœ¨æºç ä¸­ä¸çŸ¥å¤§å®¶æœ‰æ²¡æœ‰æ³¨æ„åˆ°ç¬¬äºŒä¸ªå‚æ•°æ˜¯hw_module_t module,è¿™é‡Œæ˜¯æŒ‡é’ˆçš„æŒ‡é’ˆï¼Œè€Œæˆ‘ä»¬åˆšæ‰ä¼ çš„æ˜¯camera_module_tæŒ‡é’ˆã€‚å¤§å®¶å¯ä»¥çœ‹åˆ°camera_module_t ç»“æ„ç¬¬ä¸€ä¸ªåŸŸå°±æ˜¯hw_module_t æ‰€ä»¥è¿™é‡Œå°±ä¸éš¾ç†è§£äº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102æºç è·¯å¾„ï¼šhardware/libhardware/hardware.c/** Base path of the hal modules */#define HAL_LIBRARY_PATH1 \"/system/lib/hw\" #define HAL_LIBRARY_PATH2 \"/vendor/lib/hw\"int hw_get_module(const char *id, const struct hw_module_t **module)&#123; return hw_get_module_by_class(id, NULL, module); //è¿™é‡Œçš„idå°±æ˜¯cameraæ¨¡å—çš„idï¼Œæ¯ä¸€ä¸ªhal moduleéƒ½æœ‰å¯¹åº”çš„idï¼Œ //åŒºåˆ†ä»–ä»¬å°±é€šè¿‡è¿™ä¸ªidæ¥åŒºåˆ†äº†ã€‚ &#125;int hw_get_module_by_class(const char *class_id, const char *inst, const struct hw_module_t **module)&#123; int status; int i; const struct hw_module_t *hmi = NULL; char prop[PATH_MAX]; char path[PATH_MAX]; char name[PATH_MAX]; ...... /* Loop through the configuration variants looking for a module */ for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT+1 ; i++) &#123; if (i &lt; HAL_VARIANT_KEYS_COUNT) &#123; if (property_get(variant_keys[i], prop, NULL) == 0) &#123; //å…³é”®å­—æ•°ç»„ï¼Œä¸Šé¢æœ‰å®ä»£ç ã€‚ continue; &#125; snprintf(path, sizeof(path), \"%s/%s.%s.so\", HAL_LIBRARY_PATH2, name, prop); if (access(path, R_OK) == 0) break; snprintf(path, sizeof(path), \"%s/%s.%s.so\", //æ‹¼æ¥å®Œæ•´çš„cameraåº“ã€‚ HAL_LIBRARY_PATH1, name, prop); if (access(path, R_OK) == 0) break; &#125; else &#123; snprintf(path, sizeof(path), \"%s/%s.default.so\", HAL_LIBRARY_PATH2, name); if (access(path, R_OK) == 0) break; snprintf(path, sizeof(path), \"%s/%s.default.so\", HAL_LIBRARY_PATH1, name); if (access(path, R_OK) == 0) break; &#125; &#125; status = -ENOENT; if (i &lt; HAL_VARIANT_KEYS_COUNT+1) &#123; status = load(class_id, path, module); //å¦‚æœä¸Šé¢éƒ½è¿›è¡Œå®Œæ¯•ï¼Œèµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜å·²ç»æ‰¾åˆ°åº“äº†ï¼Œè¿™é‡Œå°±å»åŠ è½½ã€‚ &#125; return status;&#125;//æ ¹æ®idæ¥åŠ è½½halçš„modulestatic int load(const char *id, const char *path, const struct hw_module_t **pHmi)&#123; int status; void *handle; struct hw_module_t *hmi; ...... handle = dlopen(path, RTLD_NOW); //åŠ¨æ€åŠ è½½å†…å­˜çš„apiï¼Œè¿™é‡Œçš„path=/system/lib/hw/camera.msm8996.so ...... /* Get the address of the struct hal_module_info. */ const char *sym = HAL_MODULE_INFO_SYM_AS_STR; //åˆ«çš„åœ°æ–¹å®šä¹‰#define HAL_MODULE_INFO_SYM_AS_STR \"HMI\" hmi = (struct hw_module_t *)dlsym(handle, sym); //æˆ‘ä»¬åŠ¨æ€é“¾æ¥çš„æ˜¯\"HMI\"è¿™ä¸ªç¬¦å·ã€‚ ...... *pHmi = hmi; //æœ€åå°†è¿™ä¸ªæŒ‡é’ˆï¼Œèµ‹ç»™æˆ‘ä»¬ä¹‹å‰å®šä¹‰çš„ struct camera_moduleå˜é‡ã€‚è¿™é‡Œæ¨¡å—å°±åŠ è½½è¿›æ¥äº†ã€‚ return status;&#125;//halä»£ç [-&gt;\\hardware\\qcom\\camera\\QCamera2\\QCamera2Hal.cpp]static hw_module_t camera_common = &#123; .tag = HARDWARE_MODULE_TAG, .module_api_version = CAMERA_MODULE_API_VERSION_2_4, .hal_api_version = HARDWARE_HAL_API_VERSION, .id = CAMERA_HARDWARE_MODULE_ID, .name = \"QCamera Module\", .author = \"Qualcomm Innovation Center Inc\", .methods = &amp;qcamera::QCamera2Factory::mModuleMethods, //å®ƒçš„æ–¹æ³•æ•°ç»„é‡Œç»‘å®šäº†openæ¥å£ .dso = NULL, .reserved = &#123;0&#125;&#125;;camera_module_t HAL_MODULE_INFO_SYM = &#123; .common = camera_common, .get_number_of_cameras = qcamera::QCamera2Factory::get_number_of_cameras, .get_camera_info = qcamera::QCamera2Factory::get_camera_info, .set_callbacks = qcamera::QCamera2Factory::set_callbacks, .get_vendor_tag_ops = qcamera::QCamera3VendorTags::get_vendor_tag_ops, .open_legacy = qcamera::QCamera2Factory::open_legacy, .set_torch_mode = qcamera::QCamera2Factory::set_torch_mode, .init = NULL, .reserved = &#123;0&#125;&#125;;struct hw_module_methods_t QCamera2Factory::mModuleMethods = &#123; //openæ–¹æ³•çš„ç»‘å®š open: QCamera2Factory::camera_device_open,&#125;; Camera HALå±‚çš„openå…¥å£å…¶å®å°±æ˜¯camera_device_openæ–¹æ³•ï¼š 2.1.3ã€å›¾è§£camera_moduleå’Œcamera_device_tå…³ç³»camer moduleåœ¨ç³»ç»Ÿä¸­è½¬æŒ‡cameraæ¨¡å—ï¼Œcamera_device_t è½¬æŒ‡æŸä¸€ä¸ªcamera è®¾å¤‡ã€‚åœ¨æµç¨‹ä¸Šï¼Œnative framwork å…ˆåŠ è½½åœ¨halå±‚å®šä¹‰çš„camer_moduleå¯¹è±¡ï¼Œç„¶åé€šè¿‡camera_moduleçš„methods openæ–¹æ³•å¡«å……camera_device_t ç»“æ„ä½“ï¼Œå¹¶æœ€ç»ˆè·å–åˆ°camera opsè¿™ä¸€æ•´ä¸ªcameraæœ€é‡è¦çš„æ“ä½œé›†åˆã€‚ä¸‹å›¾ä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°struct hw_module_tåœ¨camera_moduleæœ€ä¸Šé¢ è€Œcamera_device_tæœ€å¼€å§‹ä¿å­˜çš„æ˜¯struct hw_device_t. ç”±æ­¤æˆ‘ä»¬å¹³æ—¶åœ¨çœ‹ä»£ç æ—¶ï¼Œè¦æ³¨æ„ä¸€äº›æŒ‡é’ˆè½¬æ¢ã€‚ ï¼ˆä¸‰ï¼‰ã€Android Camera Openè¿‡ç¨‹3.1ã€Camera2 HALå±‚Open()è¿‡ç¨‹åˆ†æé«˜é€šçš„Cameraï¼Œå®ƒåœ¨åå°ä¼šæœ‰ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹daemonï¼Œdaemonæ˜¯ä»‹äºåº”ç”¨å’Œé©±åŠ¨ä¹‹é—´ç¿»è¯‘ioctlçš„ä¸­é—´å±‚(å§”æ‰˜å¤„ç†)ã€‚æœ¬èŠ‚å°†ä»¥Cameraä¸­çš„openæµç¨‹ä¸ºä¾‹ï¼Œæ¥åˆ†æCamera HALçš„å·¥ä½œè¿‡ç¨‹ï¼Œåœ¨åº”ç”¨å¯¹ç¡¬ä»¶å‘å‡ºopenè¯·æ±‚åï¼Œä¼šé€šè¿‡Camera HALæ¥å‘èµ·openè¯·æ±‚ï¼Œè€ŒCamera HALçš„openå…¥å£åœ¨QCamera2Hal.cppè¿›è¡Œäº†å®šä¹‰ï¼Œå³å‰é¢åˆ†æçš„Camera HALå±‚çš„openå…¥å£å…¶å®å°±æ˜¯camera_device_openæ–¹æ³•ï¼š 123456[-&gt;\\hardware\\qcom\\camera\\QCamera2\\QCamera2Factory.cpp]int QCamera2Factory::camera_device_open(const struct hw_module_t *module, const char *id, struct hw_device_t **hw_device)&#123; ... return gQCamera2Factory-&gt;cameraDeviceOpen(atoi(id), hw_device);&#125; å®ƒè°ƒç”¨äº†cameraDeviceOpenæ–¹æ³•ï¼Œè€Œå…¶ä¸­çš„hw_deviceå°±æ˜¯æœ€åè¦è¿”å›ç»™åº”ç”¨å±‚çš„CameraDeviceImplåœ¨Camera HALå±‚çš„å¯¹è±¡ï¼Œç»§ç»­åˆ†æcameraDeviceOpenæ–¹æ³•ï¼š 12345678910111213141516171819202122[-&gt;\\hardware\\qcom\\camera\\QCamera2\\QCamera2Factory.cpp]int QCamera2Factory::cameraDeviceOpen(int camera_id, struct hw_device_t **hw_device)&#123; ... //Camera2é‡‡ç”¨çš„Camera HALç‰ˆæœ¬ä¸ºHAL3.0 if ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123; //åˆå§‹åŒ–QCamera3HardwareInterfaceå¯¹è±¡ï¼Œè¿™é‡Œæ„é€ å‡½æ•°é‡Œå°†ä¼šè¿›è¡Œconfigure_streamsä»¥åŠ //process_capture_resultç­‰çš„ç»‘å®š QCamera3HardwareInterface *hw = new QCamera3HardwareInterface( mHalDescriptors[camera_id].cameraId, mCallbacks); //é€šè¿‡QCamera3HardwareInterfaceæ¥æ‰“å¼€Camera rc = hw-&gt;openCamera(hw_device); ... &#125; else if (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123; //HAL APIä¸º2.0 QCamera2HardwareInterface *hw = new QCamera2HardwareInterface((uint32_t)camera_id); rc = hw-&gt;openCamera(hw_device); ... &#125; else &#123; ... &#125; return rc;&#125; æ­¤æ–¹æ³•æœ‰ä¸¤ä¸ªå…³é”®ç‚¹ï¼šä¸€ä¸ªæ˜¯QCamera3HardwareInterfaceå¯¹è±¡çš„åˆ›å»ºï¼Œå®ƒæ˜¯ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´è¿›è¡Œäº¤äº’çš„æ¥å£ï¼›å¦ä¸€ä¸ªæ˜¯è°ƒç”¨å®ƒçš„openCameraæ–¹æ³•æ¥æ‰“å¼€Cameraï¼Œä¸‹é¢å°†åˆ†åˆ«è¿›è¡Œåˆ†æã€‚ 3.1.1ã€QCamera3HardwareInterfaceæ„é€ å‡½æ•°åˆ†æåœ¨å®ƒçš„æ„é€ å‡½æ•°é‡Œé¢æœ‰ä¸€ä¸ªå…³é”®çš„åˆå§‹åŒ–ï¼Œå³mCameraDevice.ops = &amp;mCameraOpsï¼Œå®ƒä¼šå®šä¹‰Deviceæ“ä½œçš„æ¥å£ï¼š 12345678910111213141516[-&gt;\\frameworks\\base\\core\\java\\android\\hardware\\camera2\\impl\\CameraDeviceImpl.java]camera3_device_ops_t QCamera3HardwareInterface::mCameraOps = &#123; initialize: QCamera3HardwareInterface::initialize, //é…ç½®æµæ•°æ®çš„ç›¸å…³å¤„ç† configure_streams: QCamera3HardwareInterface::configure_streams, register_stream_buffers: NULL, construct_default_request_settings: QCamera3HardwareInterface::construct_default_request_settings, //å¤„ç†ç»“æœçš„æ¥å£ process_capture_request: QCamera3HardwareInterface::process_capture_request, get_metadata_vendor_tag_ops: NULL, dump: QCamera3HardwareInterface::dump, flush: QCamera3HardwareInterface::flush, reserved: &#123;0&#125;,&#125;; å…¶ä¸­ï¼Œä¼šåœ¨configure_streamsä¸­é…ç½®å¥½æµçš„å¤„ç†handleï¼š 1234567891011[-&gt;\\frameworks\\base\\core\\java\\android\\hardware\\camera2\\impl\\CameraDeviceImpl.java]int QCamera3HardwareInterface::configure_streams(const struct camera3_device *device, camera3_stream_configuration_t *stream_list)&#123; //è·å¾—QCamera3HardwareInterfaceå¯¹è±¡ QCamera3HardwareInterface *hw =reinterpret_cast&lt;QCamera3HardwareInterface *&gt;(device-&gt;priv); ... //è°ƒç”¨å®ƒçš„configureStreamsè¿›è¡Œé…ç½® int rc = hw-&gt;configureStreams(stream_list); .. return rc;&#125; ç»§ç»­è¿½è¸ªconfigureStreamæ–¹æ³•ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165[-&gt;\\frameworks\\base\\core\\java\\android\\hardware\\camera2\\impl\\CameraDeviceImpl.java]int QCamera3HardwareInterface::configureStreams(camera3_stream_configuration_t *streamList)&#123; ... //åˆå§‹åŒ–Cameraç‰ˆæœ¬ al_version = CAM_HAL_V3; ... //å¼€å§‹é…ç½®stream ... //åˆå§‹åŒ–ç›¸å…³Channelä¸ºNULL if (mMetadataChannel) &#123; delete mMetadataChannel; mMetadataChannel = NULL; &#125; if (mSupportChannel) &#123; delete mSupportChannel; mSupportChannel = NULL; &#125; if (mAnalysisChannel) &#123; delete mAnalysisChannel; mAnalysisChannel = NULL; &#125; //åˆ›å»ºMetadata Channelï¼Œå¹¶å¯¹å…¶è¿›è¡Œåˆå§‹åŒ– mMetadataChannel = new QCamera3MetadataChannel(mCameraHandle-&gt;camera_handle, mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-&gt;padding_info, CAM_QCOM_FEATURE_NONE, this); ... //åˆå§‹åŒ– rc = mMetadataChannel-&gt;initialize(IS_TYPE_NONE); ... //å¦‚æœh/w supportå¯ç”¨ï¼Œåˆ™åˆ›å»ºåˆ†æstreamçš„Channel if (gCamCapability[mCameraId]-&gt;hw_analysis_supported) &#123; mAnalysisChannel = new QCamera3SupportChannel(mCameraHandle-&gt;camera_handle, mCameraHandle-&gt;ops,&amp;gCamCapability[mCameraId]-&gt;padding_info, CAM_QCOM_FEATURE_PP_SUPERSET_HAL3,CAM_STREAM_TYPE_ANALYSIS, &amp;gCamCapability[mCameraId]-&gt;analysis_recommended_res,this); ... &#125; bool isRawStreamRequested = false; //æ¸…ç©ºstreamé…ç½®ä¿¡æ¯ memset(&amp;mStreamConfigInfo, 0, sizeof(cam_stream_size_info_t)); //ä¸ºrequested streamåˆ†é…ç›¸å…³çš„channelå¯¹è±¡ for (size_t i = 0; i &lt; streamList-&gt;num_streams; i++) &#123; camera3_stream_t *newStream = streamList-&gt;streams[i]; uint32_t stream_usage = newStream-&gt;usage; mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].width = (int32_t)newStream- &gt;width; mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].height = (int32_t)newStream- &gt;height; if ((newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL||newStream-&gt;usage &amp; GRALLOC_USAGE_HW_CAMERA_ZSL) &amp;&amp;newStream-&gt;format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &amp;&amp; jpegStream)&#123; mStreamConfigInfo.type[mStreamConfigInfo.num_streams] = CAM_STREAM_TYPE_SNAPSHOT; mStreamConfigInfo.postprocess_mask[mStreamConfigInfo.num_streams] = CAM_QCOM_FEATURE_NONE; &#125; else if(newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123; &#125; else &#123; switch (newStream-&gt;format) &#123; //ä¸ºézsl streamsæŸ¥æ‰¾ä»–ä»¬çš„format ... &#125; &#125; if (newStream-&gt;priv == NULL) &#123; //ä¸ºæ–°çš„streamæ„é€ Channel switch (newStream-&gt;stream_type) &#123;//åˆ†ç±»å‹æ„é€  case CAMERA3_STREAM_INPUT: newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_READ; newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_WRITE;//WR for inplace algo's break; case CAMERA3_STREAM_BIDIRECTIONAL: ... break; case CAMERA3_STREAM_OUTPUT: ... break; default: break; &#125; //æ ¹æ®å‰é¢çš„å¾—åˆ°çš„streamçš„å‚æ•°ç±»å‹ä»¥åŠformatåˆ†åˆ«å¯¹å„ç±»å‹çš„channelè¿›è¡Œæ„é€  if (newStream-&gt;stream_type == CAMERA3_STREAM_OUTPUT || newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL) &#123; QCamera3Channel *channel = NULL; switch (newStream-&gt;format) &#123; case HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED: /* use higher number of buffers for HFR mode */ ... //åˆ›å»ºRegular Channel channel = new QCamera3RegularChannel(mCameraHandle-&gt;camera_handle, mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]- &gt;padding_info,this,newStream,(cam_stream_type_t)mStreamConfigInfo.type[ mStreamConfigInfo.num_streams],mStreamConfigInfo.postprocess_mask[ mStreamConfigInfo.num_streams],mMetadataChannel,numBuffers); ... newStream-&gt;max_buffers = channel-&gt;getNumBuffers(); newStream-&gt;priv = channel; break; case HAL_PIXEL_FORMAT_YCbCr_420_888: //åˆ›å»ºYWV Channel ... break; case HAL_PIXEL_FORMAT_RAW_OPAQUE: case HAL_PIXEL_FORMAT_RAW16: case HAL_PIXEL_FORMAT_RAW10: //åˆ›å»ºRaw Channel ... break; case HAL_PIXEL_FORMAT_BLOB: //åˆ›å»ºQCamera3PicChannel ... break; default: break; &#125; &#125; else if (newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123; newStream-&gt;max_buffers = MAX_INFLIGHT_REPROCESS_REQUESTS; &#125; else &#123; &#125; for (List&lt;stream_info_t*&gt;::iterator it=mStreamInfo.begin();it != mStreamInfo.end(); it++) &#123; if ((*it)-&gt;stream == newStream) &#123; (*it)-&gt;channel = (QCamera3Channel*) newStream-&gt;priv; break; &#125; &#125; &#125; else &#123; &#125; if (newStream-&gt;stream_type != CAMERA3_STREAM_INPUT) mStreamConfigInfo.num_streams++; &#125; &#125; if (isZsl) &#123; if (mPictureChannel) &#123; mPictureChannel-&gt;overrideYuvSize(zslStream-&gt;width, zslStream-&gt;height); &#125; &#125; else if (mPictureChannel &amp;&amp; m_bIs4KVideo) &#123; mPictureChannel-&gt;overrideYuvSize(videoWidth, videoHeight); &#125; //RAW DUMP channel if (mEnableRawDump &amp;&amp; isRawStreamRequested == false)&#123; cam_dimension_t rawDumpSize; rawDumpSize = getMaxRawSize(mCameraId); mRawDumpChannel = new QCamera3RawDumpChannel(mCameraHandle-&gt;camera_handle, mCameraHandle-&gt;ops,rawDumpSize,&amp;gCamCapability[mCameraId]-&gt;padding_info, this, CAM_QCOM_FEATURE_NONE); ... &#125; //è¿›è¡Œç›¸å…³Channelçš„é…ç½® ... /* Initialize mPendingRequestInfo and mPendnigBuffersMap */ for (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin(); i != mPendingRequestsList.end(); i++) &#123; clearInputBuffer(i-&gt;input_buffer); i = mPendingRequestsList.erase(i); &#125; mPendingFrameDropList.clear(); // Initialize/Reset the pending buffers list mPendingBuffersMap.num_buffers = 0; mPendingBuffersMap.mPendingBufferList.clear(); mPendingReprocessResultList.clear(); return rc;&#125; æ­¤æ–¹æ³•å†…å®¹æ¯”è¾ƒå¤šï¼ŒåªæŠ½å–å…¶ä¸­æ ¸å¿ƒçš„ä»£ç è¿›è¡Œè¯´æ˜ï¼Œå®ƒé¦–å…ˆä¼šæ ¹æ®HALçš„ç‰ˆæœ¬æ¥å¯¹streamè¿›è¡Œç›¸åº”çš„é…ç½®åˆå§‹åŒ–ï¼Œç„¶åå†æ ¹æ®streamç±»å‹å¯¹stream_listçš„streamåˆ›å»ºç›¸åº”çš„Channelï¼Œä¸»è¦æœ‰QCamera3MetadataChannelï¼ŒQCamera3SupportChannelç­‰ï¼Œç„¶åå†è¿›è¡Œç›¸åº”çš„é…ç½®ï¼Œå…¶ä¸­QCamera3MetadataChannelåœ¨åé¢çš„å¤„ç†capture requestçš„æ—¶å€™ä¼šç”¨åˆ°ï¼Œè¿™é‡Œå°±ä¸åšåˆ†æï¼Œè€ŒCamerametadataåˆ™æ˜¯Javaå±‚å’ŒCameraServiceä¹‹é—´ä¼ é€’çš„å…ƒæ•°æ®ï¼Œè§android6.0æºç åˆ†æä¹‹Camera API2.0ç®€ä»‹ä¸­çš„Camera2æ¶æ„å›¾ï¼Œè‡³æ­¤ï¼ŒQCamera3HardwareInterfaceæ„é€ ç»“æŸï¼Œä¸æœ¬æ–‡ç›¸å…³çš„å°±æ˜¯é…ç½®äº†mCameraDevice.opsã€‚ 3.1.2ã€openCamera()åˆ†ææœ¬èŠ‚ä¸»è¦åˆ†æModuleæ˜¯å¦‚ä½•æ‰“å¼€Cameraçš„ï¼ŒopenCameraçš„ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718[-&gt;\\hardware\\qcom\\camera\\QCamera2\\HAL3\\QCamera3HWI.cpp]int QCamera3HardwareInterface::openCamera(struct hw_device_t **hw_device)&#123; int rc = 0; if (mCameraOpened) &#123;//å¦‚æœCameraå·²ç»è¢«æ‰“å¼€ï¼Œåˆ™æ­¤æ¬¡æ‰“å¼€çš„è®¾å¤‡ä¸ºNULLï¼Œå¹¶ä¸”æ‰“å¼€ç»“æœä¸ºPERMISSION_DENIED *hw_device = NULL; return PERMISSION_DENIED; &#125; //è°ƒç”¨openCameraæ–¹æ³•æ¥æ‰“å¼€ rc = openCamera(); //æ‰“å¼€ç»“æœå¤„ç† if (rc == 0) &#123; //è·å–æ‰“å¼€æˆåŠŸçš„hw_device_tå¯¹è±¡ *hw_device = &amp;mCameraDevice.common; &#125; else *hw_device = NULL; &#125; return rc;&#125; å®ƒè°ƒç”¨äº†openCamera()æ–¹æ³•æ¥æ‰“å¼€Camera: 12345678910111213[-&gt;\\hardware\\qcom\\camera\\QCamera2\\HAL3\\QCamera3HWI.cpp]int QCamera3HardwareInterface::openCamera()&#123; ... //æ‰“å¼€cameraï¼Œè·å–mCameraHandle mCameraHandle = camera_open((uint8_t)mCameraId); ... mCameraOpened = true; //æ³¨å†Œmm-camera-interfaceé‡Œçš„äº‹ä»¶å¤„ç†,å…¶ä¸­camEctHandleä¸ºäº‹ä»¶å¤„ç†Handle rc = mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,camEvtHandle ,(void *)this); return NO_ERROR;&#125; å®ƒè°ƒç”¨camera_openæ–¹æ³•æ¥æ‰“å¼€Cameraï¼Œå¹¶ä¸”å‘CameraHandleæ³¨å†Œäº†Camera æ—¶é—´å¤„ç†çš„Handleâ€“camEvtHandleï¼Œé¦–å…ˆåˆ†æcamera_openæ–¹æ³•ï¼Œè¿™é‡Œå°±å°†è¿›å…¥é«˜é€šçš„Cameraçš„å®ç°äº†ï¼Œè€ŒMm_camera_interface.cæ˜¯é«˜é€šæä¾›çš„ç›¸å…³æ“ä½œçš„æ¥å£ï¼Œæ¥ä¸‹æ¥åˆ†æé«˜é€šCameraçš„camera_openæ–¹æ³•ï¼š 1234567891011121314151617181920212223242526272829303132333435[-&gt;\\vendor\\qcom\\proprietary\\mm-camera\\apps\\appslib\\mm_camera_interface.c]mm_camera_vtbl_t * camera_open(uint8_t camera_idx)&#123; int32_t rc = 0; mm_camera_obj_t* cam_obj = NULL; /* opened already å¦‚æœå·²ç»æ‰“å¼€*/ if(NULL != g_cam_ctrl.cam_obj[camera_idx]) &#123; /* Add reference */ g_cam_ctrl.cam_obj[camera_idx]-&gt;ref_count++; pthread_mutex_unlock(&amp;g_intf_lock); return &amp;g_cam_ctrl.cam_obj[camera_idx]-&gt;vtbl; &#125; cam_obj = (mm_camera_obj_t *)malloc(sizeof(mm_camera_obj_t)); ... /* initialize camera obj */ memset(cam_obj, 0, sizeof(mm_camera_obj_t)); cam_obj-&gt;ctrl_fd = -1; cam_obj-&gt;ds_fd = -1; cam_obj-&gt;ref_count++; cam_obj-&gt;my_hdl = mm_camera_util_generate_handler(camera_idx); cam_obj-&gt;vtbl.camera_handle = cam_obj-&gt;my_hdl; /* set handler */ //mm_camera_opsé‡Œç»‘å®šäº†ç›¸å…³çš„æ“ä½œæ¥å£ cam_obj-&gt;vtbl.ops = &amp;mm_camera_ops; pthread_mutex_init(&amp;cam_obj-&gt;cam_lock, NULL); pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock); pthread_mutex_unlock(&amp;g_intf_lock); //è°ƒç”¨mm_camera_openæ–¹æ³•æ¥æ‰“å¼€camera rc = mm_camera_open(cam_obj); pthread_mutex_lock(&amp;g_intf_lock); ... //ç»“æœå¤„ç†ï¼Œå¹¶è¿”å› ...&#125; ç”±ä»£ç å¯çŸ¥ï¼Œè¿™é‡Œå°†ä¼šåˆå§‹åŒ–ä¸€ä¸ªmm_camera_obj_tå¯¹è±¡ï¼Œå…¶ä¸­ï¼Œds_fdä¸ºsocket fdï¼Œè€Œmm_camera_opsåˆ™ç»‘å®šäº†ç›¸å…³çš„æ¥å£ï¼Œæœ€åè°ƒç”¨mm_camera_openæ¥æ‰“å¼€Cameraï¼Œé¦–å…ˆæ¥çœ‹çœ‹mm_camera_opsç»‘å®šäº†å“ªäº›æ–¹æ³•ï¼š 1234567891011121314151617181920212223242526272829303132333435363738[-&gt;\\vendor\\qcom\\proprietary\\mm-camera\\apps\\appslib\\mm_camera_interface.c]static mm_camera_ops_t mm_camera_ops = &#123; .query_capability = mm_camera_intf_query_capability, //æ³¨å†Œäº‹ä»¶é€šçŸ¥çš„æ–¹æ³• .register_event_notify = mm_camera_intf_register_event_notify, .close_camera = mm_camera_intf_close, .set_parms = mm_camera_intf_set_parms, .get_parms = mm_camera_intf_get_parms, .do_auto_focus = mm_camera_intf_do_auto_focus, .cancel_auto_focus = mm_camera_intf_cancel_auto_focus, .prepare_snapshot = mm_camera_intf_prepare_snapshot, .start_zsl_snapshot = mm_camera_intf_start_zsl_snapshot, .stop_zsl_snapshot = mm_camera_intf_stop_zsl_snapshot, .map_buf = mm_camera_intf_map_buf, .unmap_buf = mm_camera_intf_unmap_buf, .add_channel = mm_camera_intf_add_channel, .delete_channel = mm_camera_intf_del_channel, .get_bundle_info = mm_camera_intf_get_bundle_info, .add_stream = mm_camera_intf_add_stream, .link_stream = mm_camera_intf_link_stream, .delete_stream = mm_camera_intf_del_stream, //é…ç½®streamçš„æ–¹æ³• .config_stream = mm_camera_intf_config_stream, .qbuf = mm_camera_intf_qbuf, .get_queued_buf_count = mm_camera_intf_get_queued_buf_count, .map_stream_buf = mm_camera_intf_map_stream_buf, .unmap_stream_buf = mm_camera_intf_unmap_stream_buf, .set_stream_parms = mm_camera_intf_set_stream_parms, .get_stream_parms = mm_camera_intf_get_stream_parms, .start_channel = mm_camera_intf_start_channel, .stop_channel = mm_camera_intf_stop_channel, .request_super_buf = mm_camera_intf_request_super_buf, .cancel_super_buf_request = mm_camera_intf_cancel_super_buf_request, .flush_super_buf_queue = mm_camera_intf_flush_super_buf_queue, .configure_notify_mode = mm_camera_intf_configure_notify_mode, //å¤„ç†captureçš„æ–¹æ³• .process_advanced_capture = mm_camera_intf_process_advanced_capture&#125;; æ¥ç€åˆ†æmm_camera_openæ–¹æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637[-&gt;/hardware/qcom/camera/QCamera2/stack/mm-camera-interface/src/mm_camera.c]int32_t mm_camera_open(mm_camera_obj_t *my_obj)&#123; ... do&#123; n_try--; //æ ¹æ®è®¾å¤‡åå­—ï¼Œæ‰“å¼€ç›¸åº”çš„è®¾å¤‡é©±åŠ¨fd my_obj-&gt;ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK); if((my_obj-&gt;ctrl_fd &gt;= 0) || (errno != EIO) || (n_try &lt;= 0 )) &#123; break; &#125; usleep(sleep_msec * 1000U); &#125;while (n_try &gt; 0); ... //æ‰“å¼€domain socket n_try = MM_CAMERA_DEV_OPEN_TRIES; do &#123; n_try--; my_obj-&gt;ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP); usleep(sleep_msec * 1000U); &#125; while (n_try &gt; 0); ... //åˆå§‹åŒ–é” pthread_mutex_init(&amp;my_obj-&gt;msg_lock, NULL); pthread_mutex_init(&amp;my_obj-&gt;cb_lock, NULL); pthread_mutex_init(&amp;my_obj-&gt;evt_lock, NULL); pthread_cond_init(&amp;my_obj-&gt;evt_cond, NULL); //å¼€å¯çº¿ç¨‹ï¼Œå®ƒçš„çº¿ç¨‹ä½“åœ¨mm_camera_dispatch_app_eventæ–¹æ³•ä¸­ mm_camera_cmd_thread_launch(&amp;my_obj-&gt;evt_thread, mm_camera_dispatch_app_event, (void *)my_obj); mm_camera_poll_thread_launch(&amp;my_obj-&gt;evt_poll_thread, MM_CAMERA_POLL_TYPE_EVT); mm_camera_evt_sub(my_obj, TRUE); return rc; ...&#125; ç”±ä»£ç å¯çŸ¥ï¼Œå®ƒä¼šæ‰“å¼€Cameraçš„è®¾å¤‡æ–‡ä»¶ï¼Œç„¶åå¼€å¯dispatch_app_eventçº¿ç¨‹ï¼Œçº¿ç¨‹æ–¹æ³•ä½“mm_camera_dispatch_app_eventæ–¹æ³•ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920[-&gt;/hardware/qcom/camera/QCamera2/stack/mm-camera-interface/src/mm_camera.c]static void mm_camera_dispatch_app_event(mm_camera_cmdcb_t *cmd_cb,void* user_data)&#123; mm_camera_cmd_thread_name(\"mm_cam_event\"); int i; mm_camera_event_t *event = &amp;cmd_cb-&gt;u.evt; mm_camera_obj_t * my_obj = (mm_camera_obj_t *)user_data; if (NULL != my_obj) &#123; pthread_mutex_lock(&amp;my_obj-&gt;cb_lock); for(i = 0; i &lt; MM_CAMERA_EVT_ENTRY_MAX; i++) &#123; if(my_obj-&gt;evt.evt[i].evt_cb) &#123; //è°ƒç”¨camEvtHandleæ–¹æ³• my_obj-&gt;evt.evt[i].evt_cb( my_obj-&gt;my_hdl, event, my_obj-&gt;evt.evt[i].user_data); &#125; &#125; pthread_mutex_unlock(&amp;my_obj-&gt;cb_lock); &#125;&#125; æœ€åä¼šè°ƒç”¨mm-camera-interfaceä¸­æ³¨å†Œå¥½çš„äº‹ä»¶å¤„ç†evt_cbï¼Œå®ƒå°±æ˜¯åœ¨å‰é¢æ³¨å†Œå¥½çš„camEvtHandleï¼š 12345678910111213141516171819202122232425262728293031[-&gt;\\hardware\\qcom\\camera\\QCamera2\\HAL3\\QCamera3HWI.cpp]void QCamera3HardwareInterface::camEvtHandle(uint32_t /*camera_handle*/,mm_camera_event_t *evt, void *user_data)&#123; //è·å–QCamera3HardwareInterfaceæ¥å£æŒ‡é’ˆ QCamera3HardwareInterface *obj = (QCamera3HardwareInterface *)user_data; if (obj &amp;&amp; evt) &#123; switch(evt-&gt;server_event_type) &#123; case CAM_EVENT_TYPE_DAEMON_DIED: camera3_notify_msg_t notify_msg; memset(&amp;notify_msg, 0, sizeof(camera3_notify_msg_t)); notify_msg.type = CAMERA3_MSG_ERROR; notify_msg.message.error.error_code = CAMERA3_MSG_ERROR_DEVICE; notify_msg.message.error.error_stream = NULL; notify_msg.message.error.frame_number = 0; obj-&gt;mCallbackOps-&gt;notify(obj-&gt;mCallbackOps, &amp;notify_msg); break; case CAM_EVENT_TYPE_DAEMON_PULL_REQ: pthread_mutex_lock(&amp;obj-&gt;mMutex); obj-&gt;mWokenUpByDaemon = true; //å¼€å¯process_capture_request obj-&gt;unblockRequestIfNecessary(); pthread_mutex_unlock(&amp;obj-&gt;mMutex); break; default: break; &#125; &#125; else &#123; &#125;&#125; ç”±ä»£ç å¯çŸ¥ï¼Œå®ƒä¼šè°ƒç”¨QCamera3HardwareInterfaceçš„unblockRequestIfNecessaryæ¥å‘èµ·ç»“æœå¤„ç†è¯·æ±‚ï¼š 1234567[-&gt;\\hardware\\qcom\\camera\\QCamera2\\HAL3\\QCamera3HWI.cpp]void QCamera3HardwareInterface::unblockRequestIfNecessary()&#123; // Unblock process_capture_request //å¼€å¯process_capture_request pthread_cond_signal(&amp;mRequestCond);&#125; åœ¨åˆå§‹åŒ–QCamera3HardwareInterfaceå¯¹è±¡çš„æ—¶å€™ï¼Œå°±ç»‘å®šäº†å¤„ç†Metadataçš„å›è°ƒcaptureResultCbæ–¹æ³•ï¼šå®ƒä¸»è¦æ˜¯å¯¹æ•°æ®æºè¿›è¡Œç›¸åº”çš„å¤„ç†ï¼Œè€Œå…·ä½“çš„captureè¯·æ±‚çš„ç»“æœå¤„ç†è¿˜æ˜¯ç”±process_capture_requestæ¥è¿›è¡Œå¤„ç†çš„ï¼Œè€Œè¿™é‡Œä¼šè°ƒç”¨æ–¹æ³•unblockRequestIfNecessaryæ¥è§¦å‘process_capture_requestæ–¹æ³•æ‰§è¡Œï¼Œè€Œåœ¨Cameraæ¡†æ¶ä¸­ï¼Œå‘èµ·è¯·æ±‚æ—¶ä¼šå¯åŠ¨ä¸€ä¸ªRequestThreadçº¿ç¨‹ï¼Œåœ¨å®ƒçš„threadLoopæ–¹æ³•ä¸­ï¼Œä¼šä¸åœçš„è°ƒç”¨process_capture_requestæ–¹æ³•æ¥è¿›è¡Œè¯·æ±‚çš„å¤„ç†ï¼Œè€Œå®ƒæœ€åä¼šå›è°ƒCamera3Deviceä¸­çš„processCaptureResultæ–¹æ³•æ¥è¿›è¡Œç»“æœå¤„ç†ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]void Camera3Device::processCaptureResult(const camera3_capture_result *result) &#123; ... &#123; ... if (mUsePartialResult &amp;&amp; result-&gt;result != NULL) &#123; if (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123; ... if (isPartialResult) &#123; request.partialResult.collectedResult.append(result-&gt;result); &#125; &#125; else &#123; camera_metadata_ro_entry_t partialResultEntry; res = find_camera_metadata_ro_entry(result-&gt;result, ANDROID_QUIRKS_PARTIAL_RESULT, &amp;partialResultEntry); if (res != NAME_NOT_FOUND &amp;&amp;partialResultEntry.count &gt; 0 &amp;&amp; partialResultEntry.data.u8[0] ==ANDROID_QUIRKS_PARTIAL_RESULT_PARTIAL) &#123; isPartialResult = true; request.partialResult.collectedResult.append( result-&gt;result); request.partialResult.collectedResult.erase( ANDROID_QUIRKS_PARTIAL_RESULT); &#125; &#125; if (isPartialResult) &#123; // Fire off a 3A-only result if possible if (!request.partialResult.haveSent3A) &#123; //å¤„ç†3Aç»“æœ request.partialResult.haveSent3A =processPartial3AResult(frameNumber, request.partialResult.collectedResult,request.resultExtras); &#125; &#125; &#125; ... //æŸ¥æ‰¾cameraå…ƒæ•°æ®å…¥å£ camera_metadata_ro_entry_t entry; res = find_camera_metadata_ro_entry(result-&gt;result, ANDROID_SENSOR_TIMESTAMP, &amp;entry); if (shutterTimestamp == 0) &#123; request.pendingOutputBuffers.appendArray(result-&gt;output_buffers, result-&gt;num_output_buffers); &#125; else &#123; é‡è¦çš„åˆ†æ//è¿”å›å¤„ç†çš„outputbuffer returnOutputBuffers(result-&gt;output_buffers, result-&gt;num_output_buffers, shutterTimestamp); &#125; if (result-&gt;result != NULL &amp;&amp; !isPartialResult) &#123; if (shutterTimestamp == 0) &#123; request.pendingMetadata = result-&gt;result; request.partialResult.collectedResult = collectedPartialResult; &#125; else &#123; CameraMetadata metadata; metadata = result-&gt;result; //å‘é€Captureç»“æ„ï¼Œå³è°ƒç”¨é€šçŸ¥å›è°ƒ sendCaptureResult(metadata, request.resultExtras, collectedPartialResult, frameNumber, hasInputBufferInRequest, request.aeTriggerCancelOverride); &#125; &#125; removeInFlightRequestIfReadyLocked(idx); &#125; // scope for mInFlightLock if (result-&gt;input_buffer != NULL) &#123; if (hasInputBufferInRequest) &#123; Camera3Stream *stream = Camera3Stream::cast(result-&gt;input_buffer-&gt;stream); é‡è¦çš„åˆ†æ//è¿”å›å¤„ç†çš„inputbuffer res = stream-&gt;returnInputBuffer(*(result-&gt;input_buffer)); &#125; else &#123;&#125; &#125;&#125; åˆ†æreturnOutputBuffersæ–¹æ³•ï¼Œinputbufferçš„runturnInputBufferæ–¹æ³•æµç¨‹ç±»ä¼¼ï¼š 12345678910[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]void Camera3Device::returnOutputBuffers(const camera3_stream_buffer_t *outputBuffers, size_t numBuffers, nsecs_t timestamp) &#123; for (size_t i = 0; i &lt; numBuffers; i++) &#123; Camera3Stream *stream = Camera3Stream::cast(outputBuffers[i].stream); status_t res = stream-&gt;returnBuffer(outputBuffers[i], timestamp); ... &#125;&#125; æ–¹æ³•é‡Œè°ƒç”¨äº†returnBufferæ–¹æ³•ï¼š 12345678910[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Stream.cpp]status_t Camera3Stream::returnBuffer(const camera3_stream_buffer &amp;buffer,nsecs_t timestamp) &#123; //è¿”å›buffer status_t res = returnBufferLocked(buffer, timestamp); if (res == OK) &#123; fireBufferListenersLocked(buffer, /*acquired*/false, /*output*/true); mOutputBufferReturnedSignal.signal(); &#125; return res;&#125; å†ç»§ç»­çœ‹returnBufferLocked,å®ƒè°ƒç”¨äº†returnAnyBufferLockedæ–¹æ³•ï¼Œè€ŒreturnAnyBufferLockedæ–¹æ³•åˆè°ƒç”¨äº†returnBufferCheckedLockedæ–¹æ³•ï¼Œç°åœ¨åˆ†æreturnBufferCheckedLockedï¼š 12345678910111213141516171819202122232425[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3OutputStream.cpp]status_t Camera3OutputStream::returnBufferCheckedLocked(const camera3_stream_buffer &amp;buffer, nsecs_t timestamp,bool output,/*out*/sp&lt;Fence&gt; *releaseFenceOut) &#123; ... // Fence management - always honor release fence from HAL sp&lt;Fence&gt; releaseFence = new Fence(buffer.release_fence); int anwReleaseFence = releaseFence-&gt;dup(); if (buffer.status == CAMERA3_BUFFER_STATUS_ERROR) &#123; // Cancel buffer res = currentConsumer-&gt;cancelBuffer(currentConsumer.get(), container_of(buffer.buffer, ANativeWindowBuffer, handle), anwReleaseFence); ... &#125; else &#123; ... res = currentConsumer-&gt;queueBuffer(currentConsumer.get(), container_of(buffer.buffer, ANativeWindowBuffer, handle), anwReleaseFence); ... &#125; ... return res;&#125; ç”±ä»£ç å¯çŸ¥ï¼Œå¦‚æœBufferæ²¡æœ‰å‡ºç°çŠ¶æ€é”™è¯¯ï¼Œå®ƒä¼šè°ƒç”¨currentConsumerçš„queueBufferæ–¹æ³•ï¼Œè€Œå…·ä½“çš„Consumeråˆ™æ˜¯åœ¨åº”ç”¨å±‚åˆå§‹åŒ–Cameraæ—¶è¿›è¡Œç»‘å®šçš„ï¼Œå…¸å‹çš„Consumeræœ‰SurfaceTextureï¼ŒImageReaderç­‰ï¼Œè€Œåœ¨Nativeå±‚ä¸­ï¼Œå®ƒä¼šè°ƒç”¨BufferQueueProducerçš„queueBufferæ–¹æ³•ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[-&gt;\\frameworks\\native\\libs\\gui\\BufferQueueProducer.cpp]status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123; ... //åˆå§‹åŒ–Frameå¯ç”¨çš„ç›‘å¬å™¨ sp&lt;IConsumerListener&gt; frameAvailableListener; sp&lt;IConsumerListener&gt; frameReplacedListener; int callbackTicket = 0; BufferItem item; &#123; // Autolock scope ... const sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[slot].mGraphicBuffer); Rect bufferRect(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight()); Rect croppedRect; crop.intersect(bufferRect, &amp;croppedRect); ... //å¦‚æœé˜Ÿåˆ—ä¸ºç©º if (mCore-&gt;mQueue.empty()) &#123; mCore-&gt;mQueue.push_back(item); frameAvailableListener = mCore-&gt;mConsumerListener; &#125; else &#123; //å¦åˆ™ï¼Œä¸ä¸ºç©ºï¼Œå¯¹Bufferè¿›è¡Œå¤„ç†ï¼Œå¹¶è·å–FrameAvailableListenerç›‘å¬ BufferQueueCore::Fifo::iterator front(mCore-&gt;mQueue.begin()); if (front-&gt;mIsDroppable) &#123; if (mCore-&gt;stillTracking(front)) &#123; mSlots[front-&gt;mSlot].mBufferState = BufferSlot::FREE; mCore-&gt;mFreeBuffers.push_front(front-&gt;mSlot); &#125; *front = item; frameReplacedListener = mCore-&gt;mConsumerListener; &#125; else &#123; mCore-&gt;mQueue.push_back(item); frameAvailableListener = mCore-&gt;mConsumerListener; &#125; &#125; mCore-&gt;mBufferHasBeenQueued = true; mCore-&gt;mDequeueCondition.broadcast(); output-&gt;inflate(mCore-&gt;mDefaultWidth, mCore-&gt;mDefaultHeight,mCore-&gt;mTransformHint, static_cast&lt;uint32_t&gt;(mCore-&gt;mQueue.size())); // Take a ticket for the callback functions callbackTicket = mNextCallbackTicket++; mCore-&gt;validateConsistencyLocked(); &#125; // Autolock scope ... &#123; ... if (frameAvailableListener != NULL) &#123; //å›è°ƒSurfaceTextureä¸­å®šä¹‰å¥½çš„ç›‘å¬IConsumerListenerçš„onFrameAvailableæ–¹æ³•æ¥å¯¹æ•°æ®è¿›è¡Œå¤„ç† frameAvailableListener-&gt;onFrameAvailable(item); &#125; else if (frameReplacedListener != NULL) &#123; frameReplacedListener-&gt;onFrameReplaced(item); &#125; ++mCurrentCallbackTicket; mCallbackCondition.broadcast(); &#125; return NO_ERROR;&#125; ç”±ä»£ç å¯çŸ¥ï¼Œå®ƒæœ€åä¼šè°ƒç”¨Consumerçš„å›è°ƒFrameAvailableListenerçš„onFrameAvailableæ–¹æ³•ï¼Œåˆ°è¿™é‡Œï¼Œå°±æ¯”è¾ƒæ¸…æ™°ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨å†™Cameraåº”ç”¨ï¼Œä¸ºå…¶åˆå§‹åŒ–Surfaceæ—¶ï¼Œæˆ‘ä»¬éœ€è¦é‡å†™FrameAvailableListeneräº†ï¼Œå› ä¸ºåœ¨æ­¤æ–¹æ³•é‡Œé¢ï¼Œä¼šè¿›è¡Œç»“æœçš„å¤„ç†ï¼Œè‡³æ­¤ï¼ŒCamera HALçš„Openæµç¨‹å°±åˆ†æç»“æŸäº†ã€‚ä¸‹é¢ç»™å‡ºæµç¨‹çš„æ—¶åºå›¾ï¼š ï¼ˆå››ï¼‰ã€Camera API2.0 åˆå§‹åŒ–æµç¨‹åˆ†æ4.1ã€Camera2 åº”ç”¨å±‚ï¼ˆJavaå±‚ï¼‰Open()è¿‡ç¨‹åˆ†æCamera2çš„åˆå§‹åŒ–æµç¨‹ä¸Camera1.0æœ‰æ‰€åŒºåˆ«ï¼Œæœ¬æ–‡å°†å°±Camera2çš„å†…ç½®åº”ç”¨æ¥åˆ†æCamera2.0çš„åˆå§‹åŒ–è¿‡ç¨‹ã€‚Camera2.0é¦–å…ˆå¯åŠ¨çš„æ˜¯CameraActivityï¼Œè€Œå®ƒç»§æ‰¿è‡ªQuickActivityï¼Œåœ¨ä»£ç ä¸­ä½ ä¼šå‘ç°æ²¡æœ‰é‡å†™OnCreateç­‰ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ï¼Œå› ä¸ºæ­¤å¤„é‡‡ç”¨çš„æ˜¯æ¨¡æ¿æ–¹æ³•çš„è®¾è®¡æ¨¡å¼ï¼Œåœ¨QuickActivityä¸­çš„onCreateæ–¹æ³•è°ƒç”¨çš„æ˜¯onCreateTasksç­‰æ–¹æ³•ï¼Œæ‰€ä»¥è¦çœ‹onCreateæ–¹æ³•å°±åªé¡»çœ‹onCreateTasksæ–¹æ³•å³å¯ï¼š 12345678910111213141516171819202122232425[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]Overridepublic void onCreateTasks(Bundle state) &#123; Profile profile = mProfiler.create(\"CameraActivity.onCreateTasks\") .start(); ... mOnCreateTime = System.currentTimeMillis(); mAppContext = getApplicationContext(); mMainHandler = new MainHandler(this, getMainLooper()); â€¦ try &#123; //åˆå§‹åŒ–OneCameraOpenerå¯¹è±¡ â‘ mOneCameraOpener = OneCameraModule.provideOneCameraOpener( mFeatureConfig, mAppContext,mActiveCameraDeviceTracker, ResolutionUtil.getDisplayMetrics(this)); mOneCameraManager = OneCameraModule.provideOneCameraManager(); &#125; catch (OneCameraException e) &#123;...&#125; â€¦ //å»ºç«‹æ¨¡å—ä¿¡æ¯ â‘¡ModulesInfo.setupModules(mAppContext, mModuleManager, mFeatureConfig); â€¦ //è¿›è¡Œåˆå§‹åŒ– â‘¢mCurrentModule.init(this, isSecureCamera(), isCaptureIntent()); â€¦&#125; å¦‚ä»£ç æ‰€ç¤ºï¼Œé‡è¦çš„æœ‰ä»¥ä¸Šä¸‰ç‚¹ï¼Œå…ˆçœ‹ç¬¬ä¸€ç‚¹ï¼š 1234567891011121314[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]public static OneCameraOpener provideOneCameraOpener(OneCameraFeatureConfig featureConfig, Context context, ActiveCameraDeviceTracker activeCameraDeviceTracker,DisplayMetrics displayMetrics) throws OneCameraException &#123; //åˆ›å»ºOneCameraOpenerå¯¹è±¡ Optional&lt;OneCameraOpener&gt; manager = Camera2OneCameraOpenerImpl.create( featureConfig, context, activeCameraDeviceTracker, displayMetrics); if (!manager.isPresent()) &#123; manager = LegacyOneCameraOpenerImpl.create(); &#125; ... return manager.get();&#125; å®ƒè°ƒç”¨Camera2OneCameraOpenerImplçš„createæ–¹æ³•æ¥è·å¾—ä¸€ä¸ªOneCameraOpenerå¯¹è±¡ï¼Œä»¥ä¾›CameraActivityä¹‹åçš„æ“ä½œä½¿ç”¨ï¼Œç»§ç»­çœ‹createæ–¹æ³•ï¼š 123456789101112131415[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]public static Optional&lt;OneCameraOpener&gt; create(OneCameraFeatureConfig featureConfig, Context context, ActiveCameraDeviceTracker activeCameraDeviceTracker, DisplayMetrics displayMetrics) &#123; ... CameraManager cameraManager; try &#123; cameraManager = AndroidServices.instance().provideCameraManager(); &#125; catch (IllegalStateException ex) &#123;...&#125; //æ–°å»ºä¸€ä¸ªCamera2OneCameraOpenerImplå¯¹è±¡ OneCameraOpener oneCameraOpener = new Camera2OneCameraOpenerImpl( featureConfig, context, cameraManager, activeCameraDeviceTracker, displayMetrics); return Optional.of(oneCameraOpener);&#125; å¾ˆæ˜æ˜¾ï¼Œå®ƒé¦–å…ˆè·å–ä¸€ä¸ªcameraMangerå¯¹è±¡ï¼Œç„¶åæ ¹æ®è¿™ä¸ªcameraManagerå¯¹è±¡æ¥æ–°åˆ›å»ºäº†ä¸€ä¸ªCamera2OneCameraOpenerImplå¯¹è±¡ï¼Œæ‰€ä»¥ç¬¬ä¸€æ­¥ä¸»è¦æ˜¯ä¸ºäº†è·å–ä¸€ä¸ªOneCameraOpenerå¯¹è±¡ï¼Œå®ƒçš„å®ç°ä¸ºCamera2OneCameraOpenerImplç±»ã€‚ç»§ç»­çœ‹ç¬¬äºŒæ­¥ï¼ŒModulesInfo.setupModules: 1234567891011121314151617181920212223242526272829303132333435363738394041424344[-&gt;/packages/apps/Camera2/src/com/android/camera/module/ModulesInfo.java]public static void setupModules(Context context, ModuleManager moduleManager, OneCameraFeatureConfig config) &#123; Resources res = context.getResources(); int photoModuleId = context.getResources().getInteger( R.integer.camera_mode_photo); //æ³¨å†ŒPhotoæ¨¡å— registerPhotoModule(moduleManager, photoModuleId, SettingsScopeNamespaces.PHOTO,config.isUsingCaptureModule()); //è®¡ç®—ä½ è¿˜Photoæ¨¡å—è®¾ç½®ä¸ºé»˜è®¤çš„æ¨¡å— moduleManager.setDefaultModuleIndex(photoModuleId); //æ³¨å†ŒVideaæ¨¡å— registerVideoModule(moduleManager, res.getInteger( R.integer.camera_mode_video),SettingsScopeNamespaces.VIDEO); if (PhotoSphereHelper.hasLightCycleCapture(context)) &#123;//å¼€å¯é—ªå…‰ //æ³¨å†Œå¹¿è§’é•œå¤´ registerWideAngleModule(moduleManager, res.getInteger( R.integer.camera_mode_panorama),SettingsScopeNamespaces .PANORAMA); //æ³¨å†Œå…‰çƒæ¨¡å— registerPhotoSphereModule(moduleManager,res.getInteger( R.integer.camera_mode_photosphere), SettingsScopeNamespaces.PANORAMA); &#125; //è‹¥éœ€é‡æ–°èšç„¦ if (RefocusHelper.hasRefocusCapture(context)) &#123; //æ³¨å†Œé‡èšç„¦æ¨¡å— registerRefocusModule(moduleManager, res.getInteger( R.integer.camera_mode_refocus), SettingsScopeNamespaces.REFOCUS); &#125; //å¦‚æœæœ‰è‰²åˆ†ç¦»æ¨¡å— if (GcamHelper.hasGcamAsSeparateModule(config)) &#123; //æ³¨å†Œè‰²åˆ†ç¦»æ¨¡å— registerGcamModule(moduleManager, res.getInteger( R.integer.camera_mode_gcam),SettingsScopeNamespaces.PHOTO, config.getHdrPlusSupportLevel(OneCamera.Facing.BACK)); &#125; int imageCaptureIntentModuleId = res.getInteger( R.integer.camera_mode_capture_intent); registerCaptureIntentModule(moduleManager, imageCaptureIntentModuleId,SettingsScopeNamespaces.PHOTO, config.isUsingCaptureModule());&#125; ä»£ç æ ¹æ®é…ç½®ä¿¡æ¯ï¼Œè¿›è¡Œä¸€ç³»åˆ—æ¨¡å—çš„æ³¨å†Œï¼Œå…¶ä¸­PhotoModuleå’ŒVideoModuleè¢«æ³¨å†Œï¼Œè€Œå…¶ä»–çš„moduleåˆ™æ˜¯æ ¹æ®é…ç½®æ¥è¿›è¡Œçš„ï¼Œå› ä¸ºæ‰“å¼€Cameraåº”ç”¨ï¼Œæ—¢å¯ä»¥æ‹ç…§ç‰‡ä¹Ÿå¯ä»¥æ‹è§†é¢‘ï¼Œæ­¤å¤„ï¼Œåªåˆ†æPhoneModuleçš„æ³¨å†Œï¼š 1234567891011121314151617181920212223242526272829303132[-&gt;/packages/apps/Camera2/src/com/android/camera/module/ModulesInfo.java]private static void registerPhotoModule(ModuleManager moduleManager, final int moduleId, final String namespace, final boolean enableCaptureModule) &#123; //å‘ModuleManageræ³¨å†ŒPhotoModuleæ¨¡å— moduleManager.registerModule(new ModuleManager.ModuleAgent() &#123; @Override public int getModuleId() &#123; return moduleId; &#125; @Override public boolean requestAppForCamera() &#123; return !enableCaptureModule; &#125; @Override public String getScopeNamespace() &#123; return namespace; &#125; @Override public ModuleController createModule(AppController app, Intent intent) &#123; Log.v(TAG, \"EnableCaptureModule = \" + enableCaptureModule); //åˆ›å»ºModuleController return enableCaptureModule ? new CaptureModule(app) : new PhotoModule(app); &#125; &#125;);&#125; ç”±ä»£ç å¯çŸ¥ï¼Œå®ƒæœ€ç»ˆæ˜¯ç”±ModuleManageræ¥æ–°å»ºä¸€ä¸ªCaptureModuleå®ä¾‹ï¼Œè€ŒCaptureModuleå…¶å®å®ç°äº†ModuleController ï¼Œå³åˆ›å»ºäº†ä¸€ä¸ªCaptureModuleæ¨¡å¼ä¸‹çš„ModuleControllerå¯¹è±¡ï¼Œè€ŒçœŸæ­£çš„CaptureModuleçš„å…·ä½“å®ç°ä¸ºModuleManagerImplã€‚è‡³æ­¤ï¼Œå‰ä¸¤æ­¥å·²ç»è·å¾—äº†OneCameraOpenerä»¥åŠæ–°å»ºäº†ModuleControllerï¼Œå¹¶è¿›è¡Œäº†æ³¨å†Œï¼Œæ¥ä¸‹æ¥åˆ†æç¬¬ä¸‰æ­¥ï¼ŒmCurrentModule.init(this, isSecureCamera(), isCaptureIntent()): 12345678910111213141516171819202122232425262728[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]public void init(CameraActivity activity, boolean isSecureCamera, boolean isCaptureIntent) &#123; ... HandlerThread thread = new HandlerThread(\"CaptureModule.mCameraHandler\"); thread.start(); mCameraHandler = new Handler(thread.getLooper()); //è·å–ç¬¬ä¸€æ­¥ä¸­åˆ›å»ºçš„OneCameraOpenerå¯¹è±¡ mOneCameraOpener = mAppController.getCameraOpener(); try &#123; //è·å–å‰é¢åˆ›å»ºçš„OneCameraManagerå¯¹è±¡ mOneCameraManager = OneCameraModule.provideOneCameraManager(); &#125; catch (OneCameraException e) &#123; Log.e(TAG, \"Unable to provide a OneCameraManager. \", e); &#125; `... //æ–°å»ºCaptureModuleçš„UI mUI = new CaptureModuleUI(activity, mAppController. getModuleLayoutRoot(), mUIListener); //è®¾ç½®é¢„è§ˆçŠ¶æ€çš„ç›‘å¬ mAppController.setPreviewStatusListener(mPreviewStatusListener); synchronized (mSurfaceTextureLock) &#123; //è·å–SurfaceTexture mPreviewSurfaceTexture = mAppController.getCameraAppUI() .getSurfaceTexture(); &#125; &#125; é¦–å…ˆè·å–å‰é¢åˆ›å»ºçš„OneCameraOpenerå¯¹è±¡ä»¥åŠOneCameraManagerå¯¹è±¡ï¼Œç„¶åå†è®¾ç½®é¢„è§ˆçŠ¶æ€ç›‘å¬ï¼Œè¿™é‡Œä¸»è¦åˆ†æé¢„è§ˆçŠ¶æ€çš„ç›‘å¬ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]private final PreviewStatusListener mPreviewStatusListener = new PreviewStatusListener() &#123; ... @Override public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) &#123; updatePreviewTransform(width, height, true); synchronized (mSurfaceTextureLock) &#123; mPreviewSurfaceTexture = surface; &#125; //æ‰“å¼€Camera reopenCamera(); &#125; @Override public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) &#123; Log.d(TAG, \"onSurfaceTextureDestroyed\"); synchronized (mSurfaceTextureLock) &#123; mPreviewSurfaceTexture = null; &#125; //å…³é—­Camera closeCamera(); return true; &#125; @Override public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) &#123; //æ›´æ–°é¢„è§ˆå°ºå¯¸ updatePreviewBufferSize(); &#125; ... &#125;;``` ç”±ä»£ç å¯çŸ¥ï¼Œå½“SurfaceTextureçš„çŠ¶æ€å˜æˆå¯ç”¨çš„æ—¶å€™ï¼Œä¼šè°ƒç”¨reopenCamera()æ–¹æ³•æ¥æ‰“å¼€Cameraï¼Œæ‰€ä»¥ç»§ç»­åˆ†æreopenCamera()æ–¹æ³•ï¼š``` java[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]private void reopenCamera() &#123; if (mPaused) &#123; return; &#125; AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() &#123; @Override public void run() &#123; closeCamera(); if(!mAppController.isPaused()) &#123; //å¼€å¯Cameraå¹¶å¼€å§‹é¢„è§ˆ openCameraAndStartPreview(); &#125; &#125; &#125;);&#125;``` å®ƒé‡‡ç”¨å¼‚æ­¥ä»»åŠ¡çš„æ–¹æ³•ï¼Œå¼€å¯ä¸€ä¸ªå¼‚æ­¥çº¿ç¨‹æ¥è¿›è¡Œå¯åŠ¨æ“ä½œï¼Œé¦–å…ˆå…³é—­æ‰“å¼€çš„Cameraï¼Œç„¶åå¦‚æœAppControllerä¸å¤„äºæš‚åœçŠ¶æ€ï¼Œåˆ™æ‰“å¼€Cameraå¹¶å¯åŠ¨Previewæ“ä½œï¼Œæ‰€ä»¥ç»§ç»­åˆ†æopenCameraAndStartPreviewæ–¹æ³•ï¼š``` java[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]private void openCameraAndStartPreview() &#123; ... if (mOneCameraOpener == null) &#123; Log.e(TAG, \"no available OneCameraManager, showing error dialog\"); //é‡Šæ”¾CameraOpenCloseLocké” mCameraOpenCloseLock.release(); mAppController.getFatalErrorHandler().onGenericCameraAccessFailure(); guard.stop(\"No OneCameraManager\"); return; &#125; // Derive objects necessary for camera creation. MainThread mainThread = MainThread.create(); //æŸ¥æ‰¾éœ€è¦æ‰“å¼€çš„CameraId CameraId cameraId = mOneCameraManager.findFirstCameraFacing( mCameraFacing); ... //æ‰“å¼€Camera mOneCameraOpener.open(cameraId, captureSetting, mCameraHandler, mainThread, imageRotationCalculator, mBurstController, mSoundPlayer,new OpenCallback() &#123; @Override public void onFailure() &#123; //è¿›è¡Œå¤±è´¥çš„å¤„ç† ... &#125; @Override public void onCameraClosed() &#123; ... &#125; @Override public void onCameraOpened(@Nonnull final OneCamera camera) &#123; Log.d(TAG, \"onCameraOpened: \" + camera); mCamera = camera; if (mAppController.isPaused()) &#123; onFailure(); return; &#125; ... mMainThread.execute(new Runnable() &#123; @Override public void run() &#123; //é€šçŸ¥UIï¼ŒCameraçŠ¶æ€å˜åŒ– mAppController.getCameraAppUI().onChangeCamera(); //ä½¿èƒ½æ‹ç…§æŒ‰é’® mAppController.getButtonManager().enableCameraButton(); &#125; &#125;); //è‡³æ­¤ï¼ŒCameraæ‰“å¼€æˆåŠŸï¼Œå¼€å§‹é¢„è§ˆ camera.startPreview(new Surface(getPreviewSurfaceTexture()), new CaptureReadyCallback() &#123; @Override public void onSetupFailed() &#123; ... &#125; @Override public void onReadyForCapture() &#123; //é‡Šæ”¾é” mCameraOpenCloseLock.release(); mMainThread.execute(new Runnable() &#123; @Override public void run() &#123; ... onPreviewStarted(); ... onReadyStateChanged(true); //è®¾ç½®CaptureModuleä¸ºCaptureå‡†å¤‡çš„çŠ¶æ€ç›‘å¬ mCamera.setReadyStateChangedListener( CaptureModule.this); mUI.initializeZoom(mCamera.getMaxZoom()); mCamera.setFocusStateListener( CaptureModule.this); &#125; &#125;); &#125; &#125;); &#125; &#125;, mAppController.getFatalErrorHandler()); guard.stop(\"mOneCameraOpener.open()\"); &#125;&#125;``` é¦–å…ˆï¼Œå®ƒä¸»è¦ä¼šè°ƒç”¨Camera2OneCameraOpenerImplçš„openæ–¹æ³•æ¥æ‰“å¼€Cameraï¼Œå¹¶å®šä¹‰äº†å¼€å¯çš„å›è°ƒå‡½æ•°ï¼Œå¯¹å¼€å¯ç»“æŸåçš„ç»“æœè¿›è¡Œå¤„ç†ï¼Œå¦‚å¤±è´¥åˆ™é‡Šæ”¾mCameraOpenCloseLockï¼Œå¹¶æš‚åœmAppControllerï¼Œå¦‚æœæ‰“å¼€æˆåŠŸï¼Œé€šçŸ¥UIæˆåŠŸï¼Œå¹¶å¼€å¯Cameraçš„Previewï¼Œå¹¶ä¸”å®šä¹‰äº†Previewçš„å„ç§å›è°ƒæ“ä½œï¼Œè¿™é‡Œä¸»è¦åˆ†æOpenè¿‡ç¨‹ï¼Œæ‰€ä»¥ç»§ç»­åˆ†æï¼š``` java[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/Camera2OneCameraOpenerImpl.java]Overridepublic void open( ... mActiveCameraDeviceTracker.onCameraOpening(cameraKey); //æ‰“å¼€Cameraï¼Œæ­¤å¤„è°ƒç”¨æ¡†æ¶å±‚çš„CameraManagerç±»çš„openCameraï¼Œè¿›å…¥frameworkså±‚ mCameraManager.openCamera(cameraKey.getValue(), new CameraDevice.StateCallback() &#123; private boolean isFirstCallback = true; @Override ... @Override public void onOpened(CameraDevice device) &#123; //ç¬¬ä¸€æ¬¡è°ƒç”¨æ­¤å›è°ƒ if (isFirstCallback) &#123; isFirstCallback = false; try &#123; CameraCharacteristics characteristics = mCameraManager .getCameraCharacteristics(device.getId()); ... //åˆ›å»ºOneCameraå¯¹è±¡ OneCamera oneCamera = OneCameraCreator.create(device, characteristics, mFeatureConfig, captureSetting, mDisplayMetrics, mContext, mainThread, imageRotationCalculator, burstController, soundPlayer, fatalErrorHandler); if (oneCamera != null) &#123; //å¦‚æœoneCameraä¸ä¸ºç©ºï¼Œåˆ™å›è°ƒonCameraOpenedï¼Œåé¢å°†åšåˆ†æ openCallback.onCameraOpened(oneCamera); &#125; else &#123; ... openCallback.onFailure(); &#125; &#125; catch (CameraAccessException e) &#123; openCallback.onFailure(); &#125; catch (OneCameraAccessException e) &#123; Log.d(TAG, \"Could not create OneCamera\", e); openCallback.onFailure(); &#125; &#125; &#125; &#125;, handler); ...&#125; è‡³æ­¤ï¼ŒCameraçš„åˆå§‹åŒ–æµç¨‹ä¸­åº”ç”¨å±‚çš„åˆ†æå°±å·®ä¸å¤šäº†ï¼Œä¸‹ä¸€æ­¥å°†ä¼šè°ƒç”¨CameraManagerçš„openCameraæ–¹æ³•æ¥è¿›å…¥æ¡†æ¶å±‚ï¼Œå¹¶è¿›è¡ŒCameraçš„åˆå§‹åŒ–ï¼Œä¸‹é¢å°†åº”ç”¨å±‚çš„åˆå§‹åŒ–æ—¶åºå›¾ï¼š 4.2ã€Camera2 æ¡†æ¶å±‚ï¼ˆJNI &amp; Nativeï¼‰Open()è¿‡ç¨‹åˆ†æç”±ä¸Šé¢çš„åˆ†æå¯çŸ¥ï¼Œå°†ç”±åº”ç”¨å±‚è¿›å…¥åˆ°æ¡†æ¶å±‚å¤„ç†ï¼Œå°†ä¼šè°ƒç”¨CameraManagerçš„openCameraæ–¹æ³•ï¼Œå¹¶ä¸”å®šä¹‰äº†CameraDeviceçš„çŠ¶æ€å›è°ƒå‡½æ•°ï¼Œå…·ä½“çš„å›è°ƒæ“ä½œæ­¤å¤„ä¸åšåˆ†æï¼Œç»§ç»­è·Ÿè¸ªopenCamera()æ–¹æ³•ï¼š 12345678//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)@RequiresPermission(android.Manifest.permission.CAMERA)public void openCamera(@NonNull String cameraId,@NonNull final CameraDevice.StateCallback callback, @Nullable Handler handler) throws CameraAccessException &#123; ... openCameraDeviceUserAsync(cameraId, callback, handler);&#125; ç”±ä»£ç å¯çŸ¥ï¼Œæ­¤å¤„ä¸Camera1.0æœ‰æ˜æ˜¾ä¸åŒï¼ŒCamera1.0æ˜¯é€šè¿‡ä¸€ä¸ªå¼‚æ­¥çš„çº¿ç¨‹ä»¥åŠJNIæ¥è°ƒç”¨android_hardware_camera.javaé‡Œé¢çš„native_setupæ–¹æ³•æ¥è¿æ¥Cameraï¼Œå…¶ä½¿ç”¨çš„æ˜¯C++çš„Binderæ¥ä¸CameraServiceè¿›è¡Œé€šä¿¡çš„ï¼Œè€Œæ­¤å¤„åˆ™ä¸ä¸€æ ·ï¼Œå®ƒç›´æ¥ä½¿ç”¨çš„æ˜¯Javaå±‚çš„Binderæ¥è¿›è¡Œé€šä¿¡ï¼Œå…ˆçœ‹openCameraDeviceUserAsyncä»£ç : 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)private CameraDevice openCameraDeviceUserAsync(String cameraId, CameraDevice.StateCallback callback, Handler handler) throws CameraAccessException &#123; CameraCharacteristics characteristics = getCameraCharacteristics( cameraId); CameraDevice device = null; try &#123; synchronized (mLock) &#123; ICameraDeviceUser cameraUser = null; //åˆå§‹åŒ–ä¸€ä¸ªCameraDeviceå¯¹è±¡ android.hardware.camera2.impl.CameraDeviceImpl deviceImpl = new android.hardware.camera2.impl.CameraDeviceImpl(cameraId, callback, handler, characteristics); BinderHolder holder = new BinderHolder(); //è·å–å›è°ƒ ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks(); int id = Integer.parseInt(cameraId); try &#123; if (supportsCamera2ApiLocked(cameraId)) &#123; //é€šè¿‡Javaå±‚çš„Binderè·å–CameraService ICameraService cameraService = CameraManagerGlobal.get() .getCameraService(); ... //é€šè¿‡CameraServiceè¿æ¥Cameraè®¾å¤‡ cameraService.connectDevice(callbacks, id, mContext .getOpPackageName(), USE_CALLING_UID, holder); //è·å–è¿æ¥æˆåŠŸçš„CameraUserå¯¹è±¡ï¼Œå®ƒç”¨æ¥ä¸CameraServiceé€šä¿¡ cameraUser = ICameraDeviceUser.Stub.asInterface( holder.getBinder()); &#125; else &#123; //ä½¿ç”¨é—ç•™çš„API cameraUser = CameraDeviceUserShim.connectBinderShim( callbacks, id); &#125; &#125; catch (CameraRuntimeException e) &#123; ... &#125; catch (RemoteException e) &#123; ... //å°†å…¶åŒ…è£…æˆDeviceImplå¯¹è±¡ï¼Œä¾›åº”ç”¨å±‚ä½¿ç”¨ deviceImpl.setRemoteDevice(cameraUser); device = deviceImpl; &#125; &#125; catch (NumberFormatException e) &#123; ... &#125; catch (CameraRuntimeException e) &#123; throw e.asChecked(); &#125; return device;&#125; æ­¤æ–¹æ³•çš„ç›®çš„æ˜¯é€šè¿‡CameraServiceæ¥è¿æ¥å¹¶è·å–CameraDeviceå¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨æ¥ä¸Cameraè¿›è¡Œé€šä¿¡æ“ä½œã€‚ä»£ç é¦–å…ˆé€šè¿‡Javaå±‚çš„Binderæœºåˆ¶è·å–CameraServiceï¼Œç„¶åè°ƒç”¨å…¶connectDeviceæ–¹æ³•æ¥è¿æ¥CaneraDeviceï¼Œæœ€åCameraè¿”å›çš„æ˜¯CameraDeviceUserå¯¹è±¡ï¼Œè€Œæ¥ç€å°†å…¶å°è£…æˆJavå±‚CameraDeviceå¯¹è±¡ï¼Œè€Œä¹‹åæ‰€æœ‰ä¸Cameraçš„é€šä¿¡éƒ½é€šè¿‡CameraDeviceçš„æ¥å£æ¥è¿›è¡Œã€‚æ¥ä¸‹æ¥åˆ†æä¸€ä¸‹Nativeå±‚ä¸‹çš„CameraDeviceçš„åˆå§‹åŒ–è¿‡ç¨‹ï¼š 123456789101112131415[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\CameraService.cpp]//CameraService.cppï¼Œå…¶ä¸­deviceä¸ºè¾“å‡ºå¯¹è±¡status_t CameraService::connectDevice(const sp&lt;ICameraDeviceCallbacks&gt;&amp; cameraCb,int cameraId, const String16&amp; clientPackageName,int clientUid,/*out*/sp&lt;ICameraDeviceUser&gt;&amp; device) &#123; status_t ret = NO_ERROR; String8 id = String8::format(\"%d\", cameraId); sp&lt;CameraDeviceClient&gt; client = nullptr; ret = connectHelper&lt;ICameraDeviceCallbacks,CameraDeviceClient&gt;(cameraCb, id, CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, API_2, false, false, /*out*/client);//clientä¸ºè¾“å‡ºå¯¹è±¡ ... device = client; return NO_ERROR;&#125; Nativeå±‚çš„connectDeviceæ–¹æ³•å°±æ˜¯è°ƒç”¨äº†connectHelperæ–¹æ³•ï¼Œæ‰€ä»¥ç»§ç»­åˆ†æconnectHelperï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\CameraService.h]//CameraService.htemplate&lt;class CALLBACK, class CLIENT&gt;status_t CameraService::connectHelper(const sp&lt;CALLBACK&gt;&amp; cameraCb, const String8&amp; cameraId, int halVersion, const String16&amp; clientPackageName, int clientUid, apiLevel effectiveApiLevel, bool legacyMode, bool shimUpdateOnly, /*out*/sp&lt;CLIENT&gt;&amp; device) &#123; status_t ret = NO_ERROR; String8 clientName8(clientPackageName); int clientPid = getCallingPid(); ... sp&lt;CLIENT&gt; client = nullptr; &#123; ... //å¦‚æœæœ‰å¿…è¦ï¼Œç»™FlashLightå…³é—­è®¾å¤‡çš„æœºä¼š mFlashlight-&gt;prepareDeviceOpen(cameraId); //è·å–CameraId int id = cameraIdToInt(cameraId); ... //è·å–Deviceçš„ç‰ˆæœ¬ï¼Œæ­¤å¤„ä¸ºDevice3 int deviceVersion = getDeviceVersion(id, /*out*/&amp;facing); sp&lt;BasicClient&gt; tmp = nullptr; //è·å–clientå¯¹è±¡ if((ret = makeClient(this, cameraCb, clientPackageName, cameraId, facing, clientPid, clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel, /*out*/&amp;tmp)) != NO_ERROR) &#123; return ret; &#125; client = static_cast&lt;CLIENT*&gt;(tmp.get()); //è°ƒç”¨clientçš„åˆå§‹åŒ–å‡½æ•°æ¥åˆå§‹åŒ–æ¨¡å— if ((ret = client-&gt;initialize(mModule)) != OK) &#123; ALOGE(\"%s: Could not initialize client from HAL module.\", __FUNCTION__); return ret; &#125; sp&lt;IBinder&gt; remoteCallback = client-&gt;getRemote(); if (remoteCallback != nullptr) &#123; remoteCallback-&gt;linkToDeath(this); &#125; &#125; // lock is destroyed, allow further connect calls //å°†clientèµ‹å€¼ç»™è¾“å‡ºDevice device = client; return NO_ERROR;&#125; CameraServiceæ ¹æ®Cameraçš„ç›¸å…³å‚æ•°æ¥è·å–ä¸€ä¸ªclientï¼Œå¦‚makeClientæ–¹æ³•ï¼Œç„¶åå†è°ƒç”¨clientçš„initializeæ¥è¿›è¡Œåˆå§‹åŒ–ï¼Œé¦–å…ˆçœ‹makeClientï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\CameraService.cpp]//CameraService.cppï¼Œå…¶ä¸­deviceä¸ºè¾“å‡ºå¯¹è±¡status_t CameraService::makeClient(const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;IInterface&gt;&amp; cameraCb, const String16&amp; packageName, const String8&amp; cameraId, int facing, int clientPid, uid_t clientUid, int servicePid, bool legacyMode, int halVersion, int deviceVersion, apiLevel effectiveApiLevel, /*out*/sp&lt;BasicClient&gt;* client) &#123; //å°†å­—ç¬¦ä¸²çš„CameraIdè½¬æ¢æˆæ•´å½¢ int id = cameraIdToInt(cameraId); ... if (halVersion &lt; 0 || halVersion == deviceVersion) &#123;//åˆ¤æ–­Camera HALç‰ˆæœ¬æ˜¯å¦å’ŒDeviceçš„ç‰ˆæœ¬ç›¸åŒ switch(deviceVersion) &#123; case CAMERA_DEVICE_API_VERSION_1_0: if (effectiveApiLevel == API_1) &#123; // Camera1 API route sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get()); *client = new CameraClient(cameraService, tmp, packageName, id, facing, clientPid, clientUid, getpid(), legacyMode); &#125; else &#123; // Camera2 API route ALOGW(\"Camera using old HAL version: %d\", deviceVersion); return -EOPNOTSUPP; &#125; break; case CAMERA_DEVICE_API_VERSION_2_0: case CAMERA_DEVICE_API_VERSION_2_1: case CAMERA_DEVICE_API_VERSION_3_0: case CAMERA_DEVICE_API_VERSION_3_1: case CAMERA_DEVICE_API_VERSION_3_2: case CAMERA_DEVICE_API_VERSION_3_3: if (effectiveApiLevel == API_1) &#123; // Camera1 API route sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get()); *client = new Camera2Client(cameraService, tmp, packageName, id, facing, clientPid, clientUid, servicePid, legacyMode); &#125; else &#123; // Camera2 API route sp&lt;ICameraDeviceCallbacks&gt; tmp = static_cast&lt;ICameraDeviceCallbacks*&gt;(cameraCb.get()); *client = new CameraDeviceClient(cameraService, tmp, packageName, id, facing, clientPid, clientUid, servicePid); &#125; break; default: // Should not be reachable ALOGE(\"Unknown camera device HAL version: %d\", deviceVersion); return INVALID_OPERATION; &#125; &#125; else &#123; // A particular HAL version is requested by caller. Create CameraClient // based on the requested HAL version. if (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp; halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123; // Only support higher HAL version device opened as HAL1.0 device. sp&lt;ICameraClient&gt; tmp = static_cast&lt;ICameraClient*&gt;(cameraCb.get()); *client = new CameraClient(cameraService, tmp, packageName, id, facing, clientPid, clientUid, servicePid, legacyMode); &#125; else &#123; // Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet. ALOGE(\"Invalid camera HAL version %x: HAL %x device can only be\" \" opened as HAL %x device\", halVersion, deviceVersion, CAMERA_DEVICE_API_VERSION_1_0); return INVALID_OPERATION; &#125; &#125; return NO_ERROR;&#125; å…¶ä¸­å°±æ˜¯åˆ›å»ºä¸€ä¸ªClientå¯¹è±¡ï¼Œç”±äºæ­¤å¤„åˆ†æçš„æ˜¯Camera API2.0ï¼Œå…¶HALçš„ç‰ˆæœ¬æ˜¯3.0+ï¼Œè€ŒDeviceçš„ç‰ˆæœ¬åˆ™å…¶Deviceçš„ç‰ˆæœ¬å³ä¸º3.0+ï¼Œæ‰€ä»¥ä¼šåˆ›å»ºä¸€ä¸ªCameraDeviceClientå¯¹è±¡ï¼Œè‡³æ­¤ï¼ŒmakeClientå·²ç»åˆ›å»ºäº†clientå¯¹è±¡ï¼Œå¹¶è¿”å›äº†ï¼Œæ¥ç€çœ‹å®ƒçš„åˆå§‹åŒ–ï¼š 123456789101112131415161718192021[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\api2\\CameraDeviceClient.cpp]status_t CameraDeviceClient::initialize(CameraModule *module)&#123; ATRACE_CALL(); status_t res; //è°ƒç”¨Camera2ClientBaseçš„åˆå§‹åŒ–å‡½æ•°æ¥åˆå§‹åŒ–CameraModuleæ¨¡å— res = Camera2ClientBase::initialize(module); if (res != OK) &#123; return res; &#125; String8 threadName; //åˆå§‹åŒ–FrameProcessor mFrameProcessor = new FrameProcessorBase(mDevice); threadName = String8::format(\"CDU-%d-FrameProc\", mCameraId); mFrameProcessor-&gt;run(threadName.string()); //å¹¶æ³¨å†Œç›‘å¬ï¼Œç›‘å¬çš„å®ç°å°±åœ¨CameraDeviceClientç±»ä¸­ mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID, FRAME_PROCESSOR_LISTENER_MAX_ID, /*listener*/this,/*sendPartials*/true); return OK;&#125; å®ƒä¼šè°ƒç”¨Camera2ClientBaseçš„initializeæ–¹æ³•æ¥åˆå§‹åŒ–ï¼Œå¹¶ä¸”ä¼šåˆå§‹åŒ–ä¸€ä¸ªFrameProcessoræ¥è¿›è¡Œå¸§å¤„ç†ï¼Œä¸»è¦æ˜¯å›è°ƒæ¯ä¸€å¸§çš„ExtraResultåˆ°åº”ç”¨ä¸­ï¼Œä¹Ÿå°±æ˜¯3Aç›¸å…³çš„æ•°æ®ä¿¡æ¯ã€‚è€ŒCamera1.0ä¸­å„ç§Processoræ¨¡å—ï¼Œå³å°†æ•°æ®æ‰“åŒ…å¤„ç†åå†è¿”å›åˆ°åº”ç”¨çš„æ¨¡å—éƒ½å·²ç»ä¸å­˜åœ¨ï¼Œè€ŒCamera2.0ä¸­å°†ç”±MediaRecorderã€SurfaceViewã€ImageReaderç­‰æ¥ç›´æ¥å¤„ç†ï¼Œæ€»ä½“æ¥è¯´æ•ˆç‡æ›´å¥½ã€‚ç»§ç»­çœ‹initializeï¼š 12345678910[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\common\\Camera2ClientBase.cpp]template &lt;typename TClientBase&gt;status_t Camera2ClientBase&lt;TClientBase&gt;::initialize(CameraModule *module) &#123; ... //è°ƒç”¨Deviceçš„initialieæ–¹æ³• res = mDevice-&gt;initialize(module); ... res = mDevice-&gt;setNotifyCallback(this); return OK;&#125; ä»£ç å°±æ˜¯è°ƒç”¨äº†Deviceçš„initializeæ–¹æ³•ï¼Œæ­¤å¤„çš„Deviceæ˜¯åœ¨Camera2ClientBaseçš„æ„é€ å‡½æ•°ä¸­åˆ›å»ºçš„ï¼š 123456789101112131415161718192021222324[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\common\\Camera2ClientBase.cpp]template &lt;typename TClientBase&gt;Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase( const sp&lt;CameraService&gt;&amp; cameraService, const sp&lt;TCamCallbacks&gt;&amp; remoteCallback, const String16&amp; clientPackageName, int cameraId, int cameraFacing, int clientPid, uid_t clientUid, int servicePid): TClientBase(cameraService, remoteCallback, clientPackageName, cameraId, cameraFacing, clientPid, clientUid, servicePid), mSharedCameraCallbacks(remoteCallback), mDeviceVersion(cameraService-&gt;getDeviceVersion(cameraId)), mDeviceActive(false)&#123; ALOGI(\"Camera %d: Opened. Client: %s (PID %d, UID %d)\", cameraId, String8(clientPackageName).string(), clientPid, clientUid); mInitialClientPid = clientPid; mDevice = new Camera3Device(cameraId); LOG_ALWAYS_FATAL_IF(mDevice == 0, \"Device should never be NULL here.\");&#125; ç›®å‰Camera APIæ˜¯2.0ï¼Œè€ŒDeviceçš„APIå·²ç»æ˜¯3.0+äº†ï¼Œç»§ç»­çœ‹Camera3Deviceçš„æ„é€ æ–¹æ³•ã€‚ 123456789101112131415161718192021[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]Camera3Device::Camera3Device(int id): mId(id), mIsConstrainedHighSpeedConfiguration(false), mHal3Device(NULL), mStatus(STATUS_UNINITIALIZED), mStatusWaiters(0), mUsePartialResult(false), mNumPartialResults(1), mTimestampOffset(0), mNextResultFrameNumber(0), mNextReprocessResultFrameNumber(0), mNextShutterFrameNumber(0), mNextReprocessShutterFrameNumber(0), mListener(NULL)&#123; ATRACE_CALL(); camera3_callback_ops::notify = &amp;sNotify; camera3_callback_ops::process_capture_result = &amp;sProcessCaptureResult; ALOGV(\"%s: Created device for camera %d\", __FUNCTION__, id);&#125; å¾ˆæ˜¾ç„¶ï¼Œå®ƒå°†ä¼šåˆ›å»ºä¸€ä¸ªCamera3Deviceå¯¹è±¡ï¼Œæ‰€ä»¥ï¼ŒDeviceçš„initializeå°±æ˜¯è°ƒç”¨äº†Camera3Deviceçš„initializeæ–¹æ³•ï¼š 123456789101112131415161718192021222324252627282930313233343536373839[-&gt;\\frameworks\\av\\services\\camera\\libcameraservice\\device3\\Camera3Device.cpp]status_t Camera3Device::initialize(CameraModule *module)&#123; ... camera3_device_t *device; //æ‰“å¼€Camera HALå±‚çš„Deivce res = module-&gt;open(deviceName.string(), reinterpret_cast&lt;hw_device_t**&gt;(&amp;device)); ... //äº¤å‰æ£€æŸ¥Deviceçš„ç‰ˆæœ¬ if (device-&gt;common.version &lt; CAMERA_DEVICE_API_VERSION_3_0) &#123; SET_ERR_L(\"Could not open camera: \" \"Camera device should be at least %x, reports %x instead\", CAMERA_DEVICE_API_VERSION_3_0, device-&gt;common.version); device-&gt;common.close(&amp;device-&gt;common); return BAD_VALUE; &#125; ... //è°ƒç”¨å›è°ƒå‡½æ•°æ¥è¿›è¡Œåˆå§‹åŒ–ï¼Œå³è°ƒç”¨æ‰“å¼€Deviceçš„initializeæ–¹æ³•æ¥è¿›è¡Œåˆå§‹åŒ– res = device-&gt;ops-&gt;initialize(device, this); ... //å¯åŠ¨è¯·æ±‚é˜Ÿåˆ—çº¿ç¨‹ mRequestThread = new RequestThread(this, mStatusTracker, device, aeLockAvailable); res = mRequestThread-&gt;run(String8::format(\"C3Dev-%d-ReqQueue\", mId).string()); if (res != OK) &#123; SET_ERR_L(\"Unable to start request queue thread: %s (%d)\", strerror(-res), res); device-&gt;common.close(&amp;device-&gt;common); mRequestThread.clear(); return res; &#125; ... //è¿”å›åˆå§‹æˆåŠŸ return OK;&#125; é¦–å…ˆï¼Œä¼šä¾èµ–HALæ¡†æ¶æ‰“å¼€å¹¶è·å¾—ç›¸åº”çš„Deviceå¯¹è±¡ï¼Œå…·ä½“çš„æµç¨‹è¯·å‚è€ƒandroid6.0æºç åˆ†æä¹‹Camera2 HALåˆ†æï¼Œç„¶åå†å›è°ƒæ­¤å¯¹è±¡çš„initializeæ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ï¼Œæœ€åå†å¯åŠ¨RequestThreadç­‰çº¿ç¨‹ï¼Œå¹¶è¿”å›initializeæˆåŠŸã€‚è‡³æ­¤Camera API2.0ä¸‹çš„åˆå§‹åŒ–è¿‡ç¨‹å°±åˆ†æç»“æŸäº†ã€‚æ¡†æ¶å±‚çš„åˆå§‹åŒ–æ—¶åºå›¾å¦‚ä¸‹ï¼š 4.2ã€æ€»ç»“Open()è¿‡ç¨‹é“è·¯è‰°è¾›ï¼Œä¸»è¦ä¸ºäº†åç»­Cameraæ­£å¸¸å·¥ä½œï¼Œæ·»ç –åŠ ç“¦ï¼Œé“ºè·¯ã€‚ä¸‹é¢æˆ‘ä»¬åˆ—ä¸¾ä¸€ä¸‹ï¼Œä¸»è¦éƒ½å‡†å¤‡äº†ä»€ä¹ˆã€‚1ã€Cameraåº”ç”¨å°†ä¸€äº›Callbackå‡½æ•°ï¼Œæ³¨å†Œåˆ°Camera.javaä¸­ï¼Œä»¥ä½¿åœ¨çº¿ç¨‹å¤„ç†å‡½æ•°ä¸­å¯ä»¥è°ƒç”¨åˆ°ç›¸åº”çš„å›è°ƒå‡½æ•°ã€‚2ã€camera connectæˆåŠŸåï¼Œåˆ›å»ºäº†BpCameraä»£ç†å¯¹è±¡å’ŒBnCameraClientæœ¬åœ°å¯¹è±¡ã€‚3ã€åœ¨JNICameraContextå®ç°CameraListeneræ¥å£ï¼Œå¹¶å°†æ¥å£æ³¨å†Œåˆ°å®¢æˆ·ç«¯cameraæœ¬åœ°å¯¹è±¡ä¸­ï¼Œå¹¶åœ¨BnCameraClientæœ¬åœ°å¯¹è±¡ä¸­å›è°ƒè¿™äº›æ¥å£ã€‚4ã€CameraService connectè¿‡ç¨‹ä¸­ï¼Œæ ¹æ®halç¡¬ä»¶ç‰ˆæœ¬ï¼Œåˆ›å»ºå¯¹åº”çš„CameraClientå¯¹è±¡ã€‚åœ¨åç»­çš„åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œåˆ›å»º6å¤§çº¿ç¨‹ã€‚æœ€åä»¥ä¸€ä¸ªç®€å•çš„å·¥ä½œæµç¨‹å›¾æ¥ç»“æŸåšæ–‡ ï¼ˆäº”ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroid Cameraå®˜æ–¹æ–‡æ¡£Android 5.0 Cameraç³»ç»Ÿæºç åˆ†æ-CSDNåšå®¢Android Camera æµç¨‹å­¦ä¹ è®°å½• - StoneDemo - åšå®¢å›­Android Camera ç³»ç»Ÿæ¶æ„æºç åˆ†æ - CSDNåšå®¢Cameraå®‰å“æºç -é«˜é€šmm_cameraæ¶æ„å‰–æ - CSDNåšå®¢5.2 åº”ç”¨ç¨‹åºå’Œé©±åŠ¨ç¨‹åºä¸­bufferçš„ä¼ è¾“æµç¨‹ - CSDNåšå®¢Camera2 æ•°æ®æµä»frameworkåˆ°Halæºç åˆ†æ - ç®€ä¹¦mm-cameraå±‚frameæ•°æ®æµæºç åˆ†æ - ç®€ä¹¦v4l2_capture.cåˆ†æâ€”probeå‡½æ•°åˆ†æ - CSDNåšå®¢@@Android Camera fwå­¦ä¹  - CSDNåšå®¢@@Android Camera API2åˆ†æ - CSDNåšå®¢@@Android Camera æµç¨‹å­¦ä¹ è®°å½• 7.12- CSDNåšå®¢@@ä¸“æ ï¼šå¤å†¥çš„android6.0ä¸‹çš„Camera API2.0çš„æºç åˆ†æä¹‹æ—… - CSDNåšå®¢linux3.3 v4l2è§†é¢‘é‡‡é›†é©±åŠ¨æ¡†æ¶(vfe, camera i2c driverï¼Œv4l2_subdevç­‰ä¹‹é—´çš„è”ç³») - CSDNåšå®¢Android Cameraä»Camera HAL1åˆ°Camera HAL3çš„è¿‡æ¸¡ï¼ˆå·²æ›´æ–°åˆ°Android6.0 HAL3.3ï¼‰ - CSDNåšå®¢æˆ‘å¿ƒä¾æ—§ä¹‹Android Cameraæ¨¡å—FW/HAL3æ¢å­¦åº - CSDNåšå®¢Android Camera fwå­¦ä¹ (å››)-recordingæµç¨‹åˆ†æ - CSDNåšå®¢android cameraåŠ¨æ€åº“åŠ è½½è¿‡ç¨‹ - CSDNåšå®¢Android Camera API2.0ä¸‹å…¨æ–°çš„Camera FW/HALæ¶æ„ç®€è¿° - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Video Systemï¼ˆ3ï¼‰ï¼šéŸ³è§†é¢‘å½•åˆ¶Recorderã€ç¼–ç Encoderã€æ··åˆMediaMuxeræºç åˆ†æ","slug":"Android Video Systemï¼ˆ3ï¼‰ï¼šéŸ³è§†é¢‘å½•åˆ¶Recorderã€ç¼–ç Encoderã€æ··åˆMediaMuxeræºç åˆ†æ","date":"2018-06-17T16:00:00.000Z","updated":"2018-07-03T12:51:51.638Z","comments":true,"path":"2018/06/18/Android Video Systemï¼ˆ3ï¼‰ï¼šéŸ³è§†é¢‘å½•åˆ¶Recorderã€ç¼–ç Encoderã€æ··åˆMediaMuxeræºç åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/06/18/Android Video Systemï¼ˆ3ï¼‰ï¼šéŸ³è§†é¢‘å½•åˆ¶Recorderã€ç¼–ç Encoderã€æ··åˆMediaMuxeræºç åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android NuPlayeræ’­æ”¾æ¡†æ¶ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - android ACodec MediaCodec NuPlayer flowã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) â˜¯ V4l2 æ¡†æ¶ä»£ç â˜¯ kernel/drivers/media/v4l2-core/ï¼ˆæ–‡ä»¶å‰ç¼€ä¸º videobuf2ï¼‰ â˜¯ MSM è§†é¢‘é©±åŠ¨ç¨‹åºæ–‡ä»¶â˜¯ kernel/drivers/media/platform/msm/vidc/ â˜¯ è®¾å¤‡æ ‘â˜¯ /kernel/arch/arm/boot/dts/qcomï¼ˆVenus çš„å¯„å­˜å™¨åŸºå€ï¼Œæ—¶é’Ÿé¢‘ç‡ï¼‰ â˜¯ Stagefrightã€libmediaã€libmediaplayerserviceã€mediaserverâ˜¯ /frameworks/av/media/ â˜¯ OMXâ˜¯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/ â˜¯ OMX æ ¸å¿ƒâ˜¯ /hardware/qcom/media/mm-core â˜¯ è½¯ä»¶ç¼–è§£ç å™¨è·¯å¾„â˜¯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) â†’ è§£ç å™¨ä»£ç â˜¯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) â†’ ç¼–ç å™¨ä»£ç  é¦–å…ˆçœ‹ä¸€ä¸‹ä½¿ç”¨MediaRecorder å½•åˆ¶éŸ³é¢‘çš„Javaå®ä¾‹ï¼š 1234567891011MediaRecorder recorder=newMediaRecorder();recorder.setAudioSource(MediaRecorder.AudioSource.MIC);recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);recorder.setOutputFile(PATH_NAME);recorder.prepare();recorder.start(); // Recording is now started...recorder.stop(); //recorder.reset(); // You can reuse the object by going back to setAudioSource() steprecorder.release();// Now the object cannot be reused ä¹‹å‰åœ¨Audio Systemï¼ˆ2ï¼‰ï¼šLinux ALSAéŸ³é¢‘ç³»ç»Ÿåˆ†æ ç¬¬ï¼ˆå…«ï¼‰èŠ‚ç”»è¿‡tinyplay captureå½•éŸ³æ—¶åºå›¾ï¼Œä½†å½“æ—¶æ²¡æœ‰ä»”ç»†åˆ†æï¼Œä»Šå¤©æ¥åˆ†æAudioå½•éŸ³å¦‚ä½•ä»Javaå±‚ä¸€æ­¥æ­¥æœ€ç»ˆåˆ°è¾¾tinyalsaå±‚çš„pcm_open()ã€pcm_read()å‡½æ•°çš„ 12345678910111213141516171819202122232425[-&gt;E:\\android-7.1.2_r1\\external\\tinyalsa\\tinycap.c]unsigned int capture_sample(FILE *file, unsigned int card, unsigned int device, unsigned int channels, unsigned int rate, enum pcm_format format, unsigned int period_size, unsigned int period_count)&#123; struct pcm_config config; struct pcm *pcm; char *buffer; unsigned int size; unsigned int bytes_read = 0; memset(&amp;config, 0, sizeof(config)); config.channels = channels; config.rate = rate; config.period_size = period_size; config.period_count = period_count; config.format = format; config.start_threshold = 0; config.stop_threshold = 0; config.silence_threshold = 0; //æ‰“å¼€å½•åˆ¶èŠ‚ç‚¹ pcm = pcm_open(card, device, PCM_IN, &amp;config); ......&#125; å¹¶è¯»å–ä»Kernelå†…æ ¸ä¼ è¿‡æ¥çš„æ•°æ®æœ€ç»ˆåˆæˆéŸ³é¢‘æ–‡ä»¶çš„è¿‡ç¨‹1234567891011121314151617[-&gt;E:\\android-7.1.2_r1\\external\\tinyalsa\\tinycap.c]unsigned int capture_sample(FILE *file, unsigned int card, unsigned int device, unsigned int channels, unsigned int rate, enum pcm_format format, unsigned int period_size, unsigned int period_count)&#123; ...... //å¾ªç¯è¯»å–éŸ³é¢‘æ•°æ® size = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm)); buffer = malloc(size); while (capturing &amp;&amp; !pcm_read(pcm, buffer, size)) &#123; if (fwrite(buffer, 1, size, file) != size) &#123; fprintf(stderr,\"Error capturing sample\\n\"); break; &#125; bytes_read += size; &#125; å¼€å§‹åˆ†æéŸ³é¢‘å½•åˆ¶ç¼–ç åˆæˆä¹‹æ—…ï¼Œä¹‹ååˆ†æè§†é¢‘å½•åˆ¶ç¼–ç åˆæˆè¿‡ç¨‹ã€‚ ï¼ˆä¸€ï¼‰ã€Audio Recorder éŸ³é¢‘å½•åˆ¶æºç åˆ†æ ï¼ˆäºŒï¼‰ã€Media Recorder è§†é¢‘å½•åˆ¶æºç åˆ†æ12345678910111213141516171819202122232425mCamera = getCameraInstance();mCamera .open()mCamera.startPreview() mMediaRecorder = new MediaRecorder(); mMediaRecorder.setCamera(mCamera); mMediaRecorder.setPreviewDisplay(android.view.SurfaceHolder); mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER); mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA); mMediaRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height);mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH)); mMediaRecorder.setOutputFile(outputFile.toString()); //MediaRecorder.OutputFormat.MPEG_4. mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB) mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.MPEG_4_SP) mMediaRecorder.prepare(); mMediaRecorder.start();mMediaRecorder.stop()mMediaRecorder.release()mCamera.stopPreview() ï¼ˆä¸‰ï¼‰ã€éŸ³é¢‘Recorderç¼–ç Encoder1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 Line 3036: 07-02 17:00:07.175 8430 8479 V ACodec : Now uninitialized Line 3674: 07-02 17:00:35.717 745 1949 V ACodec : Now uninitialized Line 3675: 07-02 17:00:35.718 745 8649 V ACodec : onAllocateComponent Line 3678: 07-02 17:00:35.721 731 921 I OMXMaster: makeComponentInstance(OMX.google.amrnb.encoder) in mediacodec process Line 3679: 07-02 17:00:35.742 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Loaded Line 3680: 07-02 17:00:35.742 745 8649 I MediaCodec: MediaCodec will operate in async mode Line 3680: 07-02 17:00:35.742 745 8649 I MediaCodec: MediaCodec will operate in async mode Line 3681: 07-02 17:00:35.742 745 8649 V MediaCodec: Found 0 pieces of codec specific data. Line 3682: 07-02 17:00:35.742 745 8649 V ACodec : onConfigureComponent Line 3684: 07-02 17:00:35.744 745 8649 I ACodec : codec does not support config priority (err -2147483648) Line 3686: 07-02 17:00:35.751 745 8649 I ACodec : codec does not support config priority (err -2147483648) Line 3687: 07-02 17:00:35.755 745 8649 V MediaCodec: [OMX.google.amrnb.encoder] configured as input format: AMessage(what = 0x00000000) = &#123; Line 3688: 07-02 17:00:35.755 745 8649 V MediaCodec: string mime = &quot;audio/raw&quot; Line 3689: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t channel-count = 1 Line 3690: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t sample-rate = 8000 Line 3691: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t pcm-encoding = 2 Line 3692: 07-02 17:00:35.755 745 8649 V MediaCodec: &#125;, output format: AMessage(what = 0x00000000) = &#123; Line 3693: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t bitrate = 12200 Line 3694: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t max-bitrate = 12200 Line 3695: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t channel-count = 1 Line 3696: 07-02 17:00:35.755 745 8649 V MediaCodec: string mime = &quot;audio/3gpp&quot; Line 3697: 07-02 17:00:35.755 745 8649 V MediaCodec: int32_t sample-rate = 8000 Line 3698: 07-02 17:00:35.755 745 8649 V MediaCodec: &#125; Line 3699: 07-02 17:00:35.757 745 8649 V ACodec : onStart Line 3700: 07-02 17:00:35.758 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Loaded-&gt;Idle Line 3701: 07-02 17:00:35.758 745 8649 V ACodec : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 2048/2048 (from 2048 using Invalid) on input port Line 3702: 07-02 17:00:35.766 745 8649 V ACodec : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 8192/8192 (from 8192 using Invalid) on output port Line 3703: 07-02 17:00:35.771 745 8649 V MediaCodec: input buffers allocated Line 3704: 07-02 17:00:35.771 745 8649 V MediaCodec: output buffers allocated Line 3705: 07-02 17:00:35.772 745 8646 I MediaCodecSource: MediaCodecSource (audio) starting Line 3706: 07-02 17:00:35.772 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Idle-&gt;Executing Line 3701: 07-02 17:00:35.758 745 8649 V ACodec : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 2048/2048 (from 2048 using Invalid) on input port Line 3702: 07-02 17:00:35.766 745 8649 V ACodec : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 8192/8192 (from 8192 using Invalid) on output port Line 3706: 07-02 17:00:35.772 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Idle-&gt;Executing Line 3707: 07-02 17:00:35.773 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 5 Line 3708: 07-02 17:00:35.773 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 6 Line 3711: 07-02 17:00:35.775 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 7 Line 3715: 07-02 17:00:35.775 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 8 Line 3717: 07-02 17:00:35.776 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Executing Line 3833: 07-02 17:00:35.902 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 20000 us Line 3834: 07-02 17:00:35.904 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1 Line 3835: 07-02 17:00:35.907 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20000 us, flags = 0x00000010 Line 3836: 07-02 17:00:35.911 745 8649 V MediaCodec: [OMX.google.amrnb.encoder] output format changed to: AMessage(what = 0x00000000) = &#123; Line 3843: 07-02 17:00:35.913 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 5 Line 3844: 07-02 17:00:35.925 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling emptyBuffer 2 w/ time 40000 us Line 3845: 07-02 17:00:35.926 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 2 Line 3846: 07-02 17:00:35.927 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 6 time 40000 us, flags = 0x00000010 Line 3847: 07-02 17:00:35.927 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 6 Line 3848: 07-02 17:00:35.942 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling emptyBuffer 3 w/ time 60000 us Line 3849: 07-02 17:00:35.945 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 3 Line 3850: 07-02 17:00:35.945 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 7 time 60000 us, flags = 0x00000010 Line 3851: 07-02 17:00:35.946 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 7 Line 3852: 07-02 17:00:35.963 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling emptyBuffer 4 w/ time 80000 us Line 3853: 07-02 17:00:35.965 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 4 Line 3854: 07-02 17:00:35.966 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 8 time 80000 us, flags = 0x00000010 Line 3855: 07-02 17:00:35.967 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 8 Line 3856: 07-02 17:00:35.982 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 100000 us Line 3857: 07-02 17:00:35.983 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1 Line 3858: 07-02 17:00:35.985 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 100000 us, flags = 0x00000010...... Line 8217: 07-02 17:00:56.446 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 8 Line 8218: 07-02 17:00:56.462 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 20580000 us Line 8219: 07-02 17:00:56.464 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1 Line 8220: 07-02 17:00:56.466 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20580000 us, flags = 0x00000010 Line 8221: 07-02 17:00:56.467 745 8649 V ACodec : [OMX.google.amrnb.encoder] calling fillBuffer 5 Line 8222: 07-02 17:00:56.468 745 8646 I MediaCodecSource: encoder (audio) stopping Line 8223: 07-02 17:00:56.483 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Executing-&gt;Idle Line 8224: 07-02 17:00:56.484 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20580000 us, flags = 0x00000000 Line 8225: 07-02 17:00:56.484 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 6 time 20520000 us, flags = 0x00000000 Line 8226: 07-02 17:00:56.484 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 7 time 20540000 us, flags = 0x00000000 Line 8227: 07-02 17:00:56.484 745 8649 V ACodec : [OMX.google.amrnb.encoder] onOMXFillBufferDone 8 time 20560000 us, flags = 0x00000000 Line 8228: 07-02 17:00:56.496 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Idle-&gt;Loaded Line 8229: 07-02 17:00:56.496 745 8649 V ACodec : [OMX.google.amrnb.encoder] Now Loaded Line 8231: 07-02 17:00:56.499 745 8646 I MediaCodecSource: encoder (audio) stopped ï¼ˆå››ï¼‰ã€è§†é¢‘Recorderç¼–ç Encoder12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565707-03 11:43:44.947 6238 6238 V CAM_VideoModule: startVideoRecording07-03 11:43:44.974 6238 6238 D CameraStorage: External storage state=mounted07-03 11:43:44.995 6238 6238 D CameraStorage: External storage state=mounted07-03 11:43:44.998 6238 6238 V CAM_VideoModule: initializeRecorder07-03 11:43:45.003 741 1966 V MediaPlayerService: Create new media recorder client from pid 623807-03 11:43:45.009 6238 6238 I CAM_VideoModule: NOTE: hfr = off : hsr = off07-03 11:43:45.024 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 378: tintless40_algo_process_be: failed: update_func rc -407-03 11:43:45.024 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 851: tintless40_algo_execute: failed: tintless40_trigger_algo07-03 11:43:45.024 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 98: isp_algo_execute_internal_algo: failed to run algo tintless07-03 11:43:45.024 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 710: isp_parser_thread_func: failed: isp_parser_process07-03 11:43:45.031 6238 6238 D LocationManager: No location received yet.07-03 11:43:45.033 6238 6238 D LocationManager: No location received yet.07-03 11:43:45.033 6238 6238 V CAM_VideoModule: New video filename: /storage/emulated/0/DCIM/Camera/VID_20180703_114345.mp407-03 11:43:45.059 1391 2526 I MediaFocusControl: AudioFocus requestAudioFocus() from uid/pid 10025/6238 clientId=android.media.AudioManager@11f939d req=2 flags=0x007-03 11:43:45.062 4966 4966 D AudioManager: AudioManager dispatching onAudioFocusChange(-2) for android.media.AudioManager@e6fb066com.android.music.MediaPlaybackService$4@2315fa707-03 11:43:45.063 4966 4966 V MediaPlaybackService: AudioFocus: received AUDIOFOCUS_LOSS_TRANSIENT07-03 11:43:45.079 726 6266 E QCamera : &lt;HAL&gt;&lt;ERROR&gt; status_t qcamera::QCameraParameters::setSkinBeautify(const qcamera::QCameraParameters &amp;): 15184: gpw status_t qcamera::QCameraParameters::setSkinBeautify(const qcamera::QCameraParameters &amp;): str=off , prev_str=off07-03 11:43:45.079 726 6266 E QCamera : &lt;HAL&gt;&lt;ERROR&gt; int32_t qcamera::QCameraParameters::setAjustLevel(const qcamera::QCameraParameters &amp;): 15302: gpw -1 -1 -1 -1 -107-03 11:43:45.079 726 6266 E QCamera : &lt;HAL&gt;&lt;ERROR&gt; int32_t qcamera::QCameraParameters::setAjustLevel(int, int, int, int, int): 15232: ggw3 -1 -1 07-03 11:43:45.091 726 2209 E CameraClient: setVideoBufferMode: 535: videoBufferMode 2 is not supported.07-03 11:43:45.100 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 378: tintless40_algo_process_be: failed: update_func rc -407-03 11:43:45.101 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 851: tintless40_algo_execute: failed: tintless40_trigger_algo07-03 11:43:45.101 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 98: isp_algo_execute_internal_algo: failed to run algo tintless07-03 11:43:45.101 802 6282 E mm-camera: &lt;ISP &gt;&lt;ERROR&gt; 710: isp_parser_thread_func: failed: isp_parser_process07-03 11:43:45.105 802 6296 E mm-camera: &lt;IMGLIB&gt;&lt;ERROR&gt; 318: faceproc_comp_set_param: Error param=52307-03 11:43:45.111 726 6266 E QCamera : &lt;HAL&gt;&lt;ERROR&gt; status_t qcamera::QCameraParameters::setSkinBeautify(const qcamera::QCameraParameters &amp;): 15184: gpw status_t qcamera::QCameraParameters::setSkinBeautify(const qcamera::QCameraParameters &amp;): str=off , prev_str=off07-03 11:43:45.111 726 6266 E QCamera : &lt;HAL&gt;&lt;ERROR&gt; int32_t qcamera::QCameraParameters::setAjustLevel(const qcamera::QCameraParameters &amp;): 15302: gpw -1 -1 -1 -1 -107-03 11:43:45.111 726 6266 E QCamera : &lt;HAL&gt;&lt;ERROR&gt; int32_t qcamera::QCameraParameters::setAjustLevel(int, int, int, int, int): 15232: ggw3 -1 -1 07-03 11:43:45.121 741 6349 I MediaPlayerService: MediaPlayerService::getOMX07-03 11:43:45.122 741 6349 I OMXClient: MuxOMX ctor Line 5362: 07-03 11:43:41.712 6238 6238 V CAM_VideoModule: Video Encoder selected = 2 Line 5363: 07-03 11:43:41.712 6238 6238 V CAM_VideoModule: Audio Encoder selected = 3 Line 5449: 07-03 11:43:41.944 6238 6238 V CAM_VideoModule: Video Encoder selected = 2 Line 5450: 07-03 11:43:41.944 6238 6238 V CAM_VideoModule: Audio Encoder selected = 3 Line 6011: 07-03 11:43:45.123 732 2029 I OMXMaster: makeComponentInstance(OMX.qcom.video.encoder.avc) in mediacodec process Line 6014: 07-03 11:43:45.170 732 2029 I OMX-VENC: Component_init : OMX.qcom.video.encoder.avc : return = 0x0 Line 6017: 07-03 11:43:45.180 732 2168 E OMXNodeInstance: getParameter(2dc0040:qcom.encoder.avc, ParamConsumerUsageBits(0x6f800004)) ERROR: UnsupportedIndex(0x8000101a) Line 6019: 07-03 11:43:45.181 732 1863 W OMXNodeInstance: [2dc0040:qcom.encoder.avc] component does not support metadata mode; using fallback Line 6020: 07-03 11:43:45.181 741 6349 E ACodec : [OMX.qcom.video.encoder.avc] storeMetaDataInBuffers (output) failed w/ err -1010 Line 6021: 07-03 11:43:45.182 741 6349 I ExtendedACodec: setupVideoEncoder() Line 6026: 07-03 11:43:45.231 741 6349 I ACodec : setupAVCEncoderParameters with [profile: Baseline] [level: Level1] Line 6028: 07-03 11:43:45.241 732 1863 E OMXNodeInstance: getConfig(2dc0040:qcom.encoder.avc, ??(0x7f000062)) ERROR: UnsupportedSetting(0x80001019) Line 6029: 07-03 11:43:45.245 741 6349 I ACodec : [OMX.qcom.video.encoder.avc] cannot encode HDR static metadata. Ignoring. Line 6030: 07-03 11:43:45.245 741 6349 I ACodec : setupVideoEncoder succeeded Line 6031: 07-03 11:43:45.245 741 6349 I ExtendedACodec: [OMX.qcom.video.encoder.avc] configure, AMessage : AMessage(what = 'conf', target = 75) = &#123; Line 6044: 07-03 11:43:45.245 741 6349 I ExtendedACodec: int32_t encoder = 1 Line 6174: 07-03 11:43:45.455 732 2169 I OMXMaster: makeComponentInstance(OMX.qcom.audio.encoder.aac) in mediacodec process Line 6180: 07-03 11:43:45.460 732 2169 E QC_AACENC: component init: role = OMX.qcom.audio.encoder.aac Line 6182: 07-03 11:43:45.491 732 732 E OMXNodeInstance: setConfig(2dc0041:qcom.encoder.aac, ConfigPriority(0x6f800002)) ERROR: UnsupportedIndex(0x8000101a) Line 6184: 07-03 11:43:45.502 732 2169 E OMXNodeInstance: setConfig(2dc0041:qcom.encoder.aac, ConfigPriority(0x6f800002)) ERROR: UnsupportedIndex(0x8000101a) Line 6193: 07-03 11:43:45.537 741 6363 I CameraSource: Using encoder format: 0x22 Line 6194: 07-03 11:43:45.537 741 6363 I CameraSource: Using encoder data space: 0x104 Line 7431: 07-03 11:43:56.472 741 6347 I MediaCodecSource: encoder (video) stopping Line 7456: 07-03 11:43:56.611 741 6347 I MediaCodecSource: encoder (video) stopped Line 7494: 07-03 11:43:56.677 741 6347 I MediaCodecSource: encoder (audio) stopping Line 7534: 07-03 11:43:56.800 741 6347 I MediaCodecSource: encoder (audio) stopped ï¼ˆäº”ï¼‰ã€éŸ³è§†é¢‘æ··åˆMediaMuxeræºç åˆ†æ12345678910111213sp&lt;MediaWriter&gt; mWriter;[-&gt;\\android\\frameworks\\av\\media\\libstagefright\\MediaMuxer.cpp]status_t MediaMuxer::start() &#123; Mutex::Autolock autoLock(mMuxerLock); if (mState == INITIALIZED) &#123; mState = STARTED; mFileMeta-&gt;setInt32(kKeyRealTimeRecording, false); return mWriter-&gt;start(mFileMeta.get()); &#125; else &#123; ALOGE(\"start() is called in invalid state %d\", mState); return INVALID_OPERATION; &#125;&#125; å¯ä»¥çœ‹åˆ°å…·ä½“è¿˜æ˜¯è°ƒç”¨çš„MediaWriterå®ç°çš„ã€‚æˆ‘ä»¬æ¥åˆ†æå…·ä½“å®ä¾‹ï¼šMPEG4Writer.cppï¼Œå³MP4æ–‡ä»¶çš„æ ¼å¼å°è£…è¿‡ç¨‹ã€‚ 1) å½•åˆ¶å¼€å§‹æ—¶ï¼Œå†™å…¥æ–‡ä»¶å¤´éƒ¨ã€‚ 2) å½•åˆ¶è¿›è¡Œæ—¶ï¼Œå®æ—¶å†™å…¥éŸ³è§†é¢‘è½¨è¿¹çš„æ•°æ®å—ã€‚ 3) å½•åˆ¶ç»“æŸæ—¶ï¼Œå†™å…¥ç´¢å¼•ä¿¡æ¯å¹¶æ›´æ–°å¤´éƒ¨å‚æ•°ã€‚ ç´¢å¼•è´Ÿè´£æè¿°éŸ³è§†é¢‘è½¨è¿¹çš„ç‰¹å¾ï¼Œä¼šéšç€éŸ³è§†é¢‘è½¨è¿¹çš„å­˜å‚¨è€Œå˜åŒ–ï¼Œæ‰€ä»¥é€šå¸¸åšæ³•ä¼šå°†å½•åƒæ–‡ä»¶ç´¢å¼•ä¿¡æ¯æ”¾åœ¨éŸ³è§†é¢‘è½¨è¿¹æµåé¢ï¼Œåœ¨åª’ä½“æµæ•°æ®å†™å®Œï¼ˆå½•åƒç»“æŸï¼‰åæ‰èƒ½å†™å…¥ã€‚å¯ä»¥çœ‹åˆ°ï¼Œå­˜æ”¾éŸ³è§†é¢‘æ•°æ®çš„mdat boxæ˜¯ä½äºç¬¬äºŒä½çš„ï¼Œè€Œè´Ÿè´£æ£€ç´¢éŸ³è§†é¢‘çš„moov boxæ˜¯ä½äºæœ€åçš„ï¼Œè¿™ä¸é€šå¸¸çš„MP4å°è£…çš„æ’åˆ—é¡ºåºä¸åŒï¼Œå½“ç„¶è¿™æ˜¯ä¸ºäº†ç¬¦åˆå½•åˆ¶è€Œäº§ç”Ÿçš„ç»“æœã€‚å› ä¸º moovçš„å¤§å°æ˜¯éšç€ mdat å˜åŒ–çš„ï¼Œè€Œæˆ‘ä»¬å½•åˆ¶è§†é¢‘çš„æ—¶é—´é¢„å…ˆæ˜¯ä¸çŸ¥é“çš„ï¼Œæ‰€ä»¥éœ€è¦å…ˆå°†mdat æ•°æ®å†™å…¥ï¼Œæœ€åå†å†™å…¥moovï¼Œå®Œæˆå°è£…ã€‚ ç°æœ‰Androidç³»ç»Ÿä¸Šå½•åƒéƒ½æ˜¯å½•åˆ¶æ˜¯MP4æˆ–3GPæ ¼å¼ï¼Œåº•å±‚å°±æ˜¯ä½¿ç”¨MPEG4Writerç»„åˆå™¨ç±»æ¥å®Œæˆçš„ï¼Œå®ƒå°†ç¼–ç åçš„éŸ³è§†é¢‘è½¨è¿¹æŒ‰ç…§MPEG4è§„èŒƒè¿›è¡Œå°è£…ï¼Œå¡«å…¥å„ä¸ªå‚æ•°ï¼Œå°±ç»„åˆæˆå®Œæ•´çš„MP4æ ¼å¼æ–‡ä»¶ã€‚MPEG4Writerçš„ç»„åˆåŠŸèƒ½ä¸»è¦ç”±ä¸¤ç§çº¿ç¨‹å®Œæˆï¼Œä¸€ç§æ˜¯è´Ÿè´£éŸ³è§†é¢‘æ•°æ®å†™å…¥å°è£…æ–‡ä»¶çš„å†™çº¿ç¨‹ï¼ˆWriterThreadï¼‰ï¼Œä¸€ç§æ˜¯éŸ³è§†é¢‘æ•°æ®è¯»å–å¤„ç†çš„è½¨è¿¹çº¿ç¨‹ï¼ˆTrackThreadï¼‰ã€‚è½¨è¿¹çº¿ç¨‹ä¸€èˆ¬æœ‰ä¸¤ä¸ªï¼šè§†é¢‘è½¨è¿¹æ•°æ®è¯»å–çº¿ç¨‹å’ŒéŸ³é¢‘è½¨è¿¹æ•°æ®è¯»å–çº¿ç¨‹ï¼Œè€Œå†™çº¿ç¨‹åªæœ‰ä¸€ä¸ªï¼Œè´Ÿè´£å°†è½¨è¿¹çº¿ç¨‹ä¸­æ‰“åŒ…æˆChunkçš„æ•°æ®å†™å…¥å°è£…æ–‡ä»¶ã€‚ å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œè½¨è¿¹çº¿ç¨‹æ˜¯ä»¥å¸§ä¸ºå•ä½è·å–æ•°æ®å¸§ï¼ˆSampleï¼‰ï¼Œå¹¶å°†æ¯å¸§ä¸­çš„ä¿¡æ¯åŠç³»ç»Ÿç¯å¢ƒä¿¡æ¯æå–æ±‡æ€»å­˜å‚¨åœ¨å†…å­˜çš„trakè¡¨ä¸­ï¼Œå…¶ä¸­éœ€è¦ç»´æŒçš„ä¿¡æ¯æœ‰Chunkå†™å…¥æ–‡ä»¶çš„åç§»åœ°å€Stcoï¼ˆChunk Offsetï¼‰ã€Sampleä¸Chunkçš„æ˜ å°„å…³ç³»Stscï¼ˆSample-to-Chunkï¼‰ã€å…³é”®å¸§Stssï¼ˆSync Sampleï¼‰ã€æ¯ä¸€å¸§çš„æŒç»­æ—¶é—´Sttsï¼ˆTime-to-Sampleï¼‰ç­‰ï¼Œè¿™äº›ä¿¡æ¯æ˜¯è·Ÿæ¯ä¸€å¸§çš„ä¿¡æ¯å¯†åˆ‡ç›¸å…³çš„ï¼Œç”±å›¾å¯ä»¥çœ‹å‡ºtrakè¡¨ç”±å„è‡ªçš„çº¿ç¨‹ç»´æŠ¤ï¼Œå½“å½•åƒç»“æŸæ—¶trakè¡¨ä¼šå°±ä¼šå†™å…¥å°è£…æ–‡ä»¶ã€‚è€Œæ¯ä¸€å¸§çš„æ•°æ®æµä¼šå…ˆå­˜å…¥ä¸€ä¸ªé“¾è¡¨ç¼“å­˜ä¸­ï¼Œå½“å¸§çš„æ•°é‡è¾¾åˆ°ä¸€å®šå€¼æ—¶ï¼Œè½¨è¿¹çº¿ç¨‹ä¼šå°†è¿™äº›å¸§æ•°æ®æ‰“åŒ…æˆå—ï¼ˆChunkï¼‰å¹¶é€šçŸ¥å†™çº¿ç¨‹å†™å…¥åˆ°å°è£…æ–‡ä»¶ã€‚å†™çº¿ç¨‹æ¥åˆ°Chunkå·²å‡†å¤‡å¥½çš„é€šçŸ¥åå°±é©¬ä¸Šæœç´¢Chunké“¾è¡¨ï¼ˆé“¾è¡¨ä¸ªæ•°ä¸è½¨è¿¹çº¿ç¨‹ä¸ªæ•°ç›¸å…³ï¼Œä¸€èˆ¬æœ‰ä¸¤ä¸ªï¼ŒéŸ³è§†é¢‘è½¨è¿¹çº¿ç¨‹å„æœ‰ä¸€ä¸ªï¼‰ï¼Œå°†æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªChunkåä¾¿å†™å…¥å°è£…æ–‡ä»¶ï¼Œå¹¶ä¼šå°†å†™å…¥çš„åç§»åœ°å€æ›´æ–°åˆ°ç›¸åº”çš„trakè¡¨çš„Stcoé¡¹ï¼ˆä½†trakè¡¨ä¸­å…¶å®ƒæ•°æ®æ˜¯ç”±è½¨è¿¹çº¿ç¨‹æ›´æ–°ï¼‰ã€‚éŸ³è§†é¢‘çš„Chunkæ•°æ®æ˜¯å­˜å‚¨äºåŒä¸€mdat boxä¸­ï¼ŒæŒ‰æ·»åŠ åˆ°Chunké“¾è¡¨æ—¶é—´å…ˆåé¡ºåºæ’åˆ—ã€‚ç­‰åˆ°å½•åƒç»“æŸæ—¶ï¼Œå½•åƒåº”ç”¨ä¼šè°ƒç”¨MPEG4Writerçš„stopæ–¹æ³•ï¼Œæ­¤æ—¶å°±ä¼šå°†éŸ³è§†é¢‘çš„trakè¡¨åˆ†åˆ«å†™å…¥moovã€‚ å…¶å®çœ‹å®Œä¸Šé¢çš„å†…å®¹ï¼Œåº”è¯¥å¯¹Androidå½•åˆ¶è§†é¢‘è¿‡ç¨‹ä¸­ï¼Œå½•åˆ¶çš„è§†é¢‘çš„å°è£…è¿‡ç¨‹æœ‰ä¸€ä¸ªå¤§ä½“äº†è§£ï¼Œæˆ‘ä»¬å¹³æ—¶æ‰€è¯´çš„è§†é¢‘åç¼€å.mp4/.mkvç­‰ç­‰å°±æ˜¯è§†é¢‘å°è£…çš„å„ç§æ ¼å¼ã€‚å…ˆçœ‹çœ‹æ„é€ å‡½æ•°ï¼šåœ¨è¿™é‡Œå°†å®ç°ä¸€äº›å‚æ•°çš„åˆå§‹åŒ–ï¼Œfdæ˜¯ä¼ è¿›æ¥çš„å½•åˆ¶æ–‡ä»¶çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738[-&gt;\\android\\frameworks\\av\\media\\libstagefright\\MPEG4Writer.cpp]MPEG4Writer::MPEG4Writer(int fd) : mFd(dup(fd)), mInitCheck(mFd &lt; 0? NO_INIT: OK), mIsRealTimeRecording(true), mUse4ByteNalLength(true), mUse32BitOffset(true), mIsFileSizeLimitExplicitlyRequested(false), mPaused(false), mStarted(false), mWriterThreadStarted(false), mOffset(0), mMdatOffset(0), mMoovBoxBuffer(NULL), mMoovBoxBufferOffset(0), mWriteMoovBoxToMemory(false), mFreeBoxOffset(0), mStreamableFile(false), mEstimatedMoovBoxSize(0), mMoovExtraSize(0), mInterleaveDurationUs(1000000), mTimeScale(-1), mStartTimestampUs(-1ll), mLatitudex10000(0), mLongitudex10000(0), mAreGeoTagsAvailable(false), mStartTimeOffsetMs(-1), mMetaKeys(new AMessage()), mIsAudioAMR(false) &#123; addDeviceMeta(); // Verify mFd is seekable off64_t off = lseek64(mFd, 0, SEEK_SET); if (off &lt; 0) &#123; ALOGE(\"cannot seek mFd: %s (%d)\", strerror(errno), errno); release(); &#125;&#125; æ¥ç€ä» MPEG4Writer.cpp çš„start()å‡½æ•°å¼€å§‹ï¼šåœ¨startéƒ¨åˆ†ï¼Œæˆ‘ä»¬çœ‹åˆ°åœ¨è¿™ä¸€éƒ¨åˆ†ï¼ŒwriteFtypBox(param) å°†å®ç°å½•åˆ¶æ–‡ä»¶æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯çš„ç›¸å…³ä¿¡æ¯çš„å†™å…¥æ“ä½œï¼›startWriterThread() å¼€å¯å°è£…è§†é¢‘æ–‡ä»¶çš„å†™çº¿ç¨‹ï¼›startTracks(param) å¼€å¯è§†é¢‘æ•°æ®çš„è¯»çº¿ç¨‹ï¼Œä¹Ÿå°±æ˜¯å‰é¢æ–‡ä»¶éƒ¨åˆ†æ‰€è¯´çš„è½¨è¿¹çº¿ç¨‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849status_t MPEG4Writer::start(MetaData *param) &#123; ...... if (mStarted) &#123; if (mPaused) &#123; mPaused = false; return startTracks(param); &#125; return OK; &#125; ...... mWriteMoovBoxToMemory = false; mMoovBoxBuffer = NULL; mMoovBoxBufferOffset = 0; writeFtypBox(param); mFreeBoxOffset = mOffset; if (mEstimatedMoovBoxSize == 0) &#123; int32_t bitRate = -1; if (param) &#123; param-&gt;findInt32(kKeyBitRate, &amp;bitRate); &#125; mEstimatedMoovBoxSize = estimateMoovBoxSize(bitRate); &#125; CHECK_GE(mEstimatedMoovBoxSize, 8); if (mStreamableFile) &#123; // Reserve a &apos;free&apos; box only for streamable file lseek64(mFd, mFreeBoxOffset, SEEK_SET); writeInt32(mEstimatedMoovBoxSize); write(&quot;free&quot;, 4); mMdatOffset = mFreeBoxOffset + mEstimatedMoovBoxSize; &#125; else &#123; mMdatOffset = mOffset; &#125; mOffset = mMdatOffset; lseek64(mFd, mMdatOffset, SEEK_SET); ...... status_t err = startWriterThread(); ...... err = startTracks(param); ...... mStarted = true; return OK;&#125; ç»§ç»­çœ‹ä¸‹ startWriterThreadï¼ˆï¼‰éƒ¨åˆ†ï¼Œåœ¨startWriterThreadï¼ˆï¼‰å‡½æ•°ä¸­ï¼Œå°†çœŸæ­£å»ºç«‹æ–°çš„å­çº¿ç¨‹ï¼Œå¹¶åœ¨å­çº¿ç¨‹ä¸­æ‰§è¡ŒThreadWrappeå‡½æ•°ä¸­çš„æ“ä½œã€‚ 1234567891011121314151617181920212223status_t MPEG4Writer::startWriterThread() &#123; ALOGV(\"startWriterThread\"); mDone = false; mIsFirstChunk = true; mDriftTimeUs = 0; for (List&lt;Track *&gt;::iterator it = mTracks.begin(); it != mTracks.end(); ++it) &#123; ChunkInfo info; info.mTrack = *it; info.mPrevChunkTimestampUs = 0; info.mMaxInterChunkDurUs = 0; mChunkInfos.push_back(info); &#125; pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, this); pthread_attr_destroy(&amp;attr); mWriterThreadStarted = true; return OK;&#125; æ¥ç€ç»§ç»­çœ‹ ThreadWrapperï¼ˆï¼‰å‡½æ•°,åœ¨è¿™é‡Œnew äº†ä¸€ä¸ªMPEGWriterå¯¹è±¡ï¼ŒçœŸæ­£çš„æ“ä½œåœ¨threadFunc()ä¸­ä½“ç° 123456void *MPEG4Writer::ThreadWrapper(void *me) &#123; ALOGV(\"ThreadWrapper: %p\", me); MPEG4Writer *writer = static_cast&lt;MPEG4Writer *&gt;(me); writer-&gt;threadFunc(); return NULL;&#125; ä¸‹é¢çœ‹ä¸‹threadFun()ã€‚åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œå°†æ ¹æ®å˜é‡mDone è¿›è¡Œwhileå¾ªç¯ï¼Œä¸€ç›´æ£€æµ‹æ˜¯å¦æœ‰æ•°æ®å—Chunkå¯å†™ã€‚è½¨è¿¹çº¿ç¨‹æ˜¯ä¸€ç›´å°†è¯»æ•°æ®çš„æ•°æ®å¾€bufferä¸­å†™å…¥ï¼Œbufferåˆ°äº†ä¸€å®šé‡åï¼Œå°±æ˜¯chunk,è¿™æ—¶å°±ä¼šé€šè¿‡ä¿¡å·é‡ mChunkReadyConditionæ¥é€šçŸ¥å°è£…æ–‡ä»¶çš„å†™çº¿ç¨‹å»æ£€æµ‹é“¾è¡¨ï¼Œç„¶åå°†æ£€ç´¢åˆ°çš„Chunkæ•°æ®å†™å…¥æ–‡ä»¶çš„æ•°æ®åŒºï¼Œå½“ç„¶å†™ä¹‹å‰ï¼Œè‚¯å®šä¼šå»åˆ¤æ–­ä¸‹æ˜¯å¦çœŸçš„æœ‰æ•°æ®å¯å†™ã€‚ 1234567891011121314151617181920212223242526void MPEG4Writer::threadFunc() &#123; ALOGV(\"threadFunc\"); prctl(PR_SET_NAME, (unsigned long)\"MPEG4Writer\", 0, 0, 0); Mutex::Autolock autoLock(mLock); while (!mDone) &#123; Chunk chunk; bool chunkFound = false; while (!mDone &amp;&amp; !(chunkFound = findChunkToWrite(&amp;chunk))) &#123; mChunkReadyCondition.wait(mLock); &#125; if (chunkFound) &#123; if (mIsRealTimeRecording) &#123; mLock.unlock(); &#125; writeChunkToFile(&amp;chunk); if (mIsRealTimeRecording) &#123; mLock.lock(); &#125; &#125; &#125; writeAllChunks();&#125; ä¸‹é¢çœ‹ä¸‹writerChunkToFile(&amp;chunk);è½¨è¿¹çº¿ç¨‹è¯»æ•°æ®æ—¶æ˜¯ä»¥æ•°æ®å¸§Sampleä¸ºå•ä½ï¼Œæ‰€ä»¥è¿™é‡Œå°†Chunkå†™å…¥å°è£…æ–‡ä»¶ï¼Œä¹Ÿæ˜¯ä»¥Sampleä¸ºå•ä½ï¼Œéå†æ•´ä¸ªé“¾è¡¨ï¼Œå°†æ•°æ®å†™å…¥å°è£…æ–‡ä»¶ï¼ŒçœŸæ­£çš„å†™å…¥æ“ä½œæ˜¯addSamole_l(*it); 1234567891011121314151617181920212223242526272829303132333435363738void MPEG4Writer::writeAllChunks() &#123; ALOGV(\"writeAllChunks\"); size_t outstandingChunks = 0; Chunk chunk; while (findChunkToWrite(&amp;chunk)) &#123; writeChunkToFile(&amp;chunk); ++outstandingChunks; &#125; sendSessionSummary(); mChunkInfos.clear(); ALOGD(\"%zu chunks are written in the last batch\", outstandingChunks);&#125;void MPEG4Writer::writeChunkToFile(Chunk* chunk) &#123; ALOGV(\"writeChunkToFile: %\" PRId64 \" from %s track\", chunk-&gt;mTimeStampUs, chunk-&gt;mTrack-&gt;isAudio()? \"audio\": \"video\"); int32_t isFirstSample = true; while (!chunk-&gt;mSamples.empty()) &#123; List&lt;MediaBuffer *&gt;::iterator it = chunk-&gt;mSamples.begin(); off64_t offset = (chunk-&gt;mTrack-&gt;isAvc() || chunk-&gt;mTrack-&gt;isHevc()) ? addMultipleLengthPrefixedSamples_l(*it) : addSample_l(*it); if (isFirstSample) &#123; chunk-&gt;mTrack-&gt;addChunkOffset(offset); isFirstSample = false; &#125; (*it)-&gt;release(); (*it) = NULL; chunk-&gt;mSamples.erase(it); &#125; chunk-&gt;mSamples.clear();&#125; ä¸‹é¢çœ‹ä¸‹addSamole_l(*it) å‡½æ•°ï¼Œwirteå†™å…¥æ“ä½œï¼ŒmFd æ˜¯ä¸Šå±‚è®¾ç½®å½•åˆ¶çš„æ–‡ä»¶è·¯å¾„ä¼ ä¸‹æ¥çš„æ–‡ä»¶æè¿°ç¬¦ 1234567891011off64_t MPEG4Writer::addSample_l(MediaBuffer *buffer) &#123; off64_t old_offset = mOffset; ::write(mFd, (const uint8_t *)buffer-&gt;data() + buffer-&gt;range_offset(), buffer-&gt;range_length()); mOffset += buffer-&gt;range_length(); return old_offset;&#125; åˆ°æ­¤ï¼Œå°è£…æ–‡ä»¶çš„å†™å…¥çº¿ç¨‹çš„æ“ä½œå¤§ä½“èµ°å®Œï¼Œä¸‹é¢çœ‹è½¨è¿¹çº¿ç¨‹çš„æ“ä½œã€‚ startTracks(param) è½¨è¿¹çº¿ç¨‹çš„å¼€å¯ã€‚æ–‡ä»¶çš„å½•åˆ¶è¿‡ç¨‹ä¸­æ˜¯æœ‰2æ¡è½¨è¿¹çº¿ç¨‹ï¼Œä¸€ä¸ªæ˜¯è§†é¢‘çš„è½¨è¿¹çº¿ç¨‹ï¼Œå¦ä¸€æ¡åˆ™æ˜¯éŸ³é¢‘çš„è½¨è¿¹çº¿ç¨‹ï¼Œåœ¨starTrackï¼ˆparamï¼‰ä¸­æ˜¯åœ¨for å¾ªç¯ä¸­startäº†ä¸¤æ¡è½¨è¿¹çº¿ç¨‹ã€‚ 123456789101112131415161718192021status_t MPEG4Writer::startTracks(MetaData *params) &#123; if (mTracks.empty()) &#123; ALOGE(\"No source added\"); return INVALID_OPERATION; &#125; for (List&lt;Track *&gt;::iterator it = mTracks.begin(); it != mTracks.end(); ++it) &#123; status_t err = (*it)-&gt;start(params); if (err != OK) &#123; for (List&lt;Track *&gt;::iterator it2 = mTracks.begin(); it2 != it; ++it2) &#123; (*it2)-&gt;stop(); &#125; return err; &#125; &#125; return OK;&#125; ï¼ˆit)-&gt;start(params) å°†ä¼šæ‰§è¡Œstatus_t MPEG4Writer::Track::start(MetaData params) {} ã€‚åœ¨è¿™è¾¹ä¹Ÿæ˜¯åŒæ ·æ–°å»ºå­çº¿ç¨‹ï¼Œåœ¨å­çº¿ç¨‹ä¸­æ‰§è¡Œè½¨è¿¹çº¿ç¨‹çš„ç›¸åº”æ“ä½œã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243status_t MPEG4Writer::Track::start(MetaData *params) &#123; int64_t startTimeUs; ...... mStartTimeRealUs = startTimeUs; int32_t rotationDegrees; ...... initTrackingProgressStatus(params); sp&lt;MetaData&gt; meta = new MetaData; if (mOwner-&gt;isRealTimeRecording() &amp;&amp; mOwner-&gt;numTracks() &gt; 1) &#123; int64_t startTimeOffsetUs = mOwner-&gt;getStartTimeOffsetMs() * 1000LL; if (startTimeOffsetUs &lt; 0) &#123; // Start time offset was not set startTimeOffsetUs = kInitialDelayTimeUs; &#125; startTimeUs += startTimeOffsetUs; ALOGI(\"Start time offset: %\" PRId64 \" us\", startTimeOffsetUs); &#125; meta-&gt;setInt64(kKeyTime, startTimeUs); status_t err = mSource-&gt;start(meta.get()); ...... pthread_attr_t attr; pthread_attr_init(&amp;attr); pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE); mDone = false; mStarted = true; mTrackDurationUs = 0; mReachedEOS = false; mEstimatedTrackSizeBytes = 0; mMdatSizeBytes = 0; mMaxChunkDurationUs = 0; mLastDecodingTimeUs = -1; pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, this); pthread_attr_destroy(&amp;attr); return OK;&#125; ä¸‹é¢çœ‹ä¸‹ä¸Šé¢ThreadWrapperå‡½æ•°,çœŸæ­£çš„æ“ä½œåˆæ˜¯æ”¾åˆ°äº†threadEntry()ä¸­å»æ‰§è¡Œ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464void *MPEG4Writer::Track::ThreadWrapper(void *me) &#123; Track *track = static_cast&lt;Track *&gt;(me); status_t err = track-&gt;threadEntry(); return (void *) err;&#125;status_t MPEG4Writer::Track::threadEntry() &#123; int32_t count = 0; const int64_t interleaveDurationUs = mOwner-&gt;interleaveDuration(); const bool hasMultipleTracks = (mOwner-&gt;numTracks() &gt; 1); int64_t chunkTimestampUs = 0; int32_t nChunks = 0; int32_t nActualFrames = 0; // frames containing non-CSD data (non-0 length) int32_t nZeroLengthFrames = 0; int64_t lastTimestampUs = 0; // Previous sample time stamp int64_t lastDurationUs = 0; // Between the previous two samples int64_t currDurationTicks = 0; // Timescale based ticks int64_t lastDurationTicks = 0; // Timescale based ticks int32_t sampleCount = 1; // Sample count in the current stts table entry uint32_t previousSampleSize = 0; // Size of the previous sample int64_t previousPausedDurationUs = 0; int64_t timestampUs = 0; int64_t cttsOffsetTimeUs = 0; int64_t currCttsOffsetTimeTicks = 0; // Timescale based ticks int64_t lastCttsOffsetTimeTicks = -1; // Timescale based ticks int32_t cttsSampleCount = 0; // Sample count in the current ctts table entry uint32_t lastSamplesPerChunk = 0; if (mIsAudio) &#123; prctl(PR_SET_NAME, (unsigned long)\"AudioTrackEncoding\", 0, 0, 0); &#125; else &#123; prctl(PR_SET_NAME, (unsigned long)\"VideoTrackEncoding\", 0, 0, 0); &#125; if (mOwner-&gt;isRealTimeRecording()) &#123; androidSetThreadPriority(0, ANDROID_PRIORITY_AUDIO); &#125; sp&lt;MetaData&gt; meta_data; status_t err = OK; MediaBuffer *buffer; const char *trackName = mIsAudio ? \"Audio\" : \"Video\"; while (!mDone &amp;&amp; (err = mSource-&gt;read(&amp;buffer)) == OK) &#123; if (buffer-&gt;range_length() == 0) &#123; buffer-&gt;release(); buffer = NULL; ++nZeroLengthFrames; continue; &#125; // If the codec specific data has not been received yet, delay pause. // After the codec specific data is received, discard what we received // when the track is to be paused. if (mPaused &amp;&amp; !mResumed) &#123; buffer-&gt;release(); buffer = NULL; continue; &#125; ++count; int32_t isCodecConfig; if (buffer-&gt;meta_data()-&gt;findInt32(kKeyIsCodecConfig, &amp;isCodecConfig) &amp;&amp; isCodecConfig) &#123; // if config format (at track addition) already had CSD, keep that // UNLESS we have not received any frames yet. // TODO: for now the entire CSD has to come in one frame for encoders, even though // they need to be spread out for decoders. if (mGotAllCodecSpecificData &amp;&amp; nActualFrames &gt; 0) &#123; ALOGI(\"ignoring additional CSD for video track after first frame\"); &#125; else &#123; mMeta = mSource-&gt;getFormat(); // get output format after format change if (mIsAvc) &#123; status_t err = makeAVCCodecSpecificData( (const uint8_t *)buffer-&gt;data() + buffer-&gt;range_offset(), buffer-&gt;range_length()); CHECK_EQ((status_t)OK, err); &#125; else if (mIsHevc) &#123; status_t err = makeHEVCCodecSpecificData( (const uint8_t *)buffer-&gt;data() + buffer-&gt;range_offset(), buffer-&gt;range_length()); CHECK_EQ((status_t)OK, err); &#125; else if (mIsMPEG4) &#123; copyCodecSpecificData((const uint8_t *)buffer-&gt;data() + buffer-&gt;range_offset(), buffer-&gt;range_length()); &#125; &#125; if (!mIsAudio) &#123; int32_t fps; mMeta-&gt;findInt32(kKeyFrameRate, &amp;fps); int64_t cttsOffsetTimeUs = 1000000LL/fps; mCttsOffsetTimeUs = cttsOffsetTimeUs + kMinCttsOffsetTimeUs; //delta factor &#125; buffer-&gt;release(); buffer = NULL; mGotAllCodecSpecificData = true; continue; &#125; ++nActualFrames; MediaBuffer *copy = NULL; // Check if the upstream source hints it is OK to hold on to the // buffer without releasing immediately and avoid cloning the buffer if (AVUtils::get()-&gt;canDeferRelease(buffer-&gt;meta_data())) &#123; copy = buffer; meta_data = new MetaData(*buffer-&gt;meta_data().get()); &#125; else &#123; // Make a deep copy of the MediaBuffer and Metadata and release // the original as soon as we can copy = new MediaBuffer(buffer-&gt;range_length()); memcpy(copy-&gt;data(), (uint8_t *)buffer-&gt;data() + buffer-&gt;range_offset(), buffer-&gt;range_length()); copy-&gt;set_range(0, buffer-&gt;range_length()); meta_data = new MetaData(*buffer-&gt;meta_data().get()); buffer-&gt;release(); buffer = NULL; &#125; if (mIsAvc || mIsHevc) StripStartcode(copy); size_t sampleSize = copy-&gt;range_length(); if (mIsAvc || mIsHevc) &#123; if (mOwner-&gt;useNalLengthFour()) &#123; sampleSize += 4; &#125; else &#123; sampleSize += 2; &#125; &#125; // Max file size or duration handling mMdatSizeBytes += sampleSize; updateTrackSizeEstimate(); if (mOwner-&gt;exceedsFileSizeLimit()) &#123; ALOGW(\"Recorded file size exceeds limit %\" PRId64 \"bytes\", mOwner-&gt;mMaxFileSizeLimitBytes); mOwner-&gt;notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, 0); copy-&gt;release(); mSource-&gt;stop(); break; &#125; if (mOwner-&gt;exceedsFileDurationLimit()) &#123; ALOGW(\"Recorded file duration exceeds limit %\" PRId64 \"microseconds\", mOwner-&gt;mMaxFileDurationLimitUs); mOwner-&gt;notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, 0); copy-&gt;release(); mSource-&gt;stop(); break; &#125; int32_t isSync = false; meta_data-&gt;findInt32(kKeyIsSyncFrame, &amp;isSync); CHECK(meta_data-&gt;findInt64(kKeyTime, &amp;timestampUs));//////////////////////////////////////////////////////////////////////////////// if (mStszTableEntries-&gt;count() == 0) &#123; mFirstSampleTimeRealUs = systemTime() / 1000; mStartTimestampUs = timestampUs; mOwner-&gt;setStartTimestampUs(mStartTimestampUs); previousPausedDurationUs = mStartTimestampUs; &#125; if (mResumed) &#123; int64_t durExcludingEarlierPausesUs = timestampUs - previousPausedDurationUs; if (WARN_UNLESS(durExcludingEarlierPausesUs &gt;= 0ll, \"for %s track\", trackName)) &#123; copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; int64_t pausedDurationUs = durExcludingEarlierPausesUs - mTrackDurationUs; if (WARN_UNLESS(pausedDurationUs &gt;= lastDurationUs, \"for %s track\", trackName)) &#123; copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; previousPausedDurationUs += pausedDurationUs - lastDurationUs; mResumed = false; &#125; timestampUs -= previousPausedDurationUs; if (WARN_UNLESS(timestampUs &gt;= 0ll, \"for %s track\", trackName)) &#123; copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; if (!mIsAudio) &#123; /* * Composition time: timestampUs * Decoding time: decodingTimeUs * Composition time offset = composition time - decoding time */ int64_t decodingTimeUs; CHECK(meta_data-&gt;findInt64(kKeyDecodingTime, &amp;decodingTimeUs)); decodingTimeUs -= previousPausedDurationUs; // ensure non-negative, monotonic decoding time if (mLastDecodingTimeUs &lt; 0) &#123; decodingTimeUs = std::max((int64_t)0, decodingTimeUs); &#125; else &#123; // increase decoding time by at least 1 tick decodingTimeUs = std::max( mLastDecodingTimeUs + divUp(1000000, mTimeScale), decodingTimeUs); &#125; mLastDecodingTimeUs = decodingTimeUs; cttsOffsetTimeUs = timestampUs + mCttsOffsetTimeUs - decodingTimeUs; if (cttsOffsetTimeUs &lt; 0) &#123; cttsOffsetTimeUs = 0; &#125; if (WARN_UNLESS(cttsOffsetTimeUs &gt;= 0ll, \"for %s track\", trackName)) &#123; copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; timestampUs = decodingTimeUs; ALOGV(\"decoding time: %\" PRId64 \" and ctts offset time: %\" PRId64, timestampUs, cttsOffsetTimeUs); // Update ctts box table if necessary currCttsOffsetTimeTicks = (cttsOffsetTimeUs * mTimeScale + 500000LL) / 1000000LL; if (WARN_UNLESS(currCttsOffsetTimeTicks &lt;= 0x0FFFFFFFFLL, \"for %s track\", trackName)) &#123; copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; if (mStszTableEntries-&gt;count() == 0) &#123; lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks; //addOneCttsTableEntry(1, currCttsOffsetTimeTicks); //cttsSampleCount = 0; // No sample in ctts box is pending cttsSampleCount = 1; &#125; else &#123; if (currCttsOffsetTimeTicks != lastCttsOffsetTimeTicks) &#123; addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks); lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks; cttsSampleCount = 1; // One sample in ctts box is pending &#125; else &#123; ++cttsSampleCount; &#125; &#125; // Update ctts time offset range if (mStszTableEntries-&gt;count() == 0) &#123; mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks; mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks; &#125; else &#123; if (currCttsOffsetTimeTicks &gt; mMaxCttsOffsetTimeUs) &#123; mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks; &#125; else if (currCttsOffsetTimeTicks &lt; mMinCttsOffsetTimeUs) &#123; mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks; &#125; &#125; &#125; if (mOwner-&gt;isRealTimeRecording()) &#123; if (mIsAudio) &#123; updateDriftTime(meta_data); &#125; &#125; if (WARN_UNLESS(timestampUs &gt;= 0ll, \"for %s track\", trackName)) &#123; copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; ALOGV(\"%s media time stamp: %\" PRId64 \" and previous paused duration %\" PRId64, trackName, timestampUs, previousPausedDurationUs); if (timestampUs &gt; mTrackDurationUs) &#123; mTrackDurationUs = timestampUs; &#125; // We need to use the time scale based ticks, rather than the // timestamp itself to determine whether we have to use a new // stts entry, since we may have rounding errors. // The calculation is intended to reduce the accumulated // rounding errors. currDurationTicks = ((timestampUs * mTimeScale + 500000LL) / 1000000LL - (lastTimestampUs * mTimeScale + 500000LL) / 1000000LL); if (currDurationTicks &lt; 0ll) &#123; ALOGE(\"do not support out of order frames (timestamp: %lld &lt; last: %lld for %s track\", (long long)timestampUs, (long long)lastTimestampUs, trackName); copy-&gt;release(); mSource-&gt;stop(); mIsMalformed = true; break; &#125; // if the duration is different for this sample, see if it is close enough to the previous // duration that we can fudge it and use the same value, to avoid filling the stts table // with lots of near-identical entries. // \"close enough\" here means that the current duration needs to be adjusted by less // than 0.1 milliseconds if (lastDurationTicks &amp;&amp; (currDurationTicks != lastDurationTicks)) &#123; int64_t deltaUs = ((lastDurationTicks - currDurationTicks) * 1000000LL + (mTimeScale / 2)) / mTimeScale; if (deltaUs &gt; -100 &amp;&amp; deltaUs &lt; 100) &#123; // use previous ticks, and adjust timestamp as if it was actually that number // of ticks currDurationTicks = lastDurationTicks; timestampUs += deltaUs; &#125; &#125; mStszTableEntries-&gt;add(htonl(sampleSize)); if (mStszTableEntries-&gt;count() &gt; 2) &#123; // Force the first sample to have its own stts entry so that // we can adjust its value later to maintain the A/V sync. if (mStszTableEntries-&gt;count() == 3 || currDurationTicks != lastDurationTicks) &#123; addOneSttsTableEntry(sampleCount, lastDurationTicks); sampleCount = 1; &#125; else &#123; ++sampleCount; &#125; &#125; if (mSamplesHaveSameSize) &#123; if (mStszTableEntries-&gt;count() &gt;= 2 &amp;&amp; previousSampleSize != sampleSize) &#123; mSamplesHaveSameSize = false; &#125; previousSampleSize = sampleSize; &#125; ALOGV(\"%s timestampUs/lastTimestampUs: %\" PRId64 \"/%\" PRId64, trackName, timestampUs, lastTimestampUs); lastDurationUs = timestampUs - lastTimestampUs; lastDurationTicks = currDurationTicks; lastTimestampUs = timestampUs; if (isSync != 0) &#123; addOneStssTableEntry(mStszTableEntries-&gt;count()); &#125; if (mTrackingProgressStatus) &#123; if (mPreviousTrackTimeUs &lt;= 0) &#123; mPreviousTrackTimeUs = mStartTimestampUs; &#125; trackProgressStatus(timestampUs); &#125; if (!hasMultipleTracks) &#123; off64_t offset = (mIsAvc || mIsHevc) ? mOwner-&gt;addMultipleLengthPrefixedSamples_l(copy) : mOwner-&gt;addSample_l(copy); uint32_t count = (mOwner-&gt;use32BitFileOffset() ? mStcoTableEntries-&gt;count() : mCo64TableEntries-&gt;count()); if (count == 0) &#123; addChunkOffset(offset); &#125; copy-&gt;release(); copy = NULL; continue; &#125; mChunkSamples.push_back(copy); if (interleaveDurationUs == 0) &#123; addOneStscTableEntry(++nChunks, 1); bufferChunk(timestampUs); &#125; else &#123; if (chunkTimestampUs == 0) &#123; chunkTimestampUs = timestampUs; &#125; else &#123; int64_t chunkDurationUs = timestampUs - chunkTimestampUs; if (chunkDurationUs &gt; interleaveDurationUs) &#123; if (chunkDurationUs &gt; mMaxChunkDurationUs) &#123; mMaxChunkDurationUs = chunkDurationUs; &#125; ++nChunks; if (nChunks == 1 || // First chunk lastSamplesPerChunk != mChunkSamples.size()) &#123; lastSamplesPerChunk = mChunkSamples.size(); addOneStscTableEntry(nChunks, lastSamplesPerChunk); &#125; bufferChunk(timestampUs); chunkTimestampUs = timestampUs; &#125; &#125; &#125; &#125; if (isTrackMalFormed()) &#123; err = ERROR_MALFORMED; &#125; mOwner-&gt;trackProgressStatus(mTrackId, -1, err); // Last chunk if (!hasMultipleTracks) &#123; addOneStscTableEntry(1, mStszTableEntries-&gt;count()); &#125; else if (!mChunkSamples.empty()) &#123; addOneStscTableEntry(++nChunks, mChunkSamples.size()); bufferChunk(timestampUs); &#125; // We don't really know how long the last frame lasts, since // there is no frame time after it, just repeat the previous // frame's duration. if (mStszTableEntries-&gt;count() == 1) &#123; lastDurationUs = 0; // A single sample's duration lastDurationTicks = 0; &#125; else &#123; ++sampleCount; // Count for the last sample &#125; if (mStszTableEntries-&gt;count() &lt;= 2) &#123; addOneSttsTableEntry(1, lastDurationTicks); if (sampleCount - 1 &gt; 0) &#123; addOneSttsTableEntry(sampleCount - 1, lastDurationTicks); &#125; &#125; else &#123; addOneSttsTableEntry(sampleCount, lastDurationTicks); &#125; // The last ctts box may not have been written yet, and this // is to make sure that we write out the last ctts box. if (currCttsOffsetTimeTicks == lastCttsOffsetTimeTicks) &#123; if (cttsSampleCount &gt; 0) &#123; addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks); &#125; &#125; mTrackDurationUs += lastDurationUs; mReachedEOS = true; sendTrackSummary(hasMultipleTracks); ALOGI(\"Received total/0-length (%d/%d) buffers and encoded %d frames. - %s\", count, nZeroLengthFrames, mStszTableEntries-&gt;count(), trackName); if (mIsAudio) &#123; ALOGI(\"Audio track drift time: %\" PRId64 \" us\", mOwner-&gt;getDriftTimeUs()); &#125; // if err is ERROR_IO (ex: during SSR), return OK to save the // recorded file successfully. Session tear down will happen as part of // client callback if ((err == ERROR_IO) || (err == ERROR_END_OF_STREAM)) &#123; return OK; &#125; return err;&#125; ä¸‹é¢çœ‹ä¸‹ï¼Œå½•åˆ¶æ–‡ä»¶ç»“æŸæ—¶çš„ä¸€äº›æ“ä½œã€‚å½•åˆ¶æ–‡ä»¶ç»“æŸæ—¶ï¼Œä¸Šå±‚åº”ç”¨åˆ†åˆ«æ˜¯è°ƒç”¨ MediaRecorderçš„stop()ã€reset()å’Œrelease()æ³•ï¼Œä¸‹é¢çœ‹ä¸‹MPEG4Writer.cppä¸­ç›¸å¯¹åº”çš„æ“ä½œã€‚ 12345678910111213141516171819202122232425262728293031status_t MPEG4Writer::Track::stop() &#123; ALOGD(\"%s track stopping\", mIsAudio? \"Audio\": \"Video\"); if (!mStarted) &#123; ALOGE(\"Stop() called but track is not started\"); return ERROR_END_OF_STREAM; &#125; if (mDone) &#123; return OK; &#125; mDone = true; ALOGD(\"%s track source stopping\", mIsAudio? \"Audio\": \"Video\"); mSource-&gt;stop(); ALOGD(\"%s track source stopped\", mIsAudio? \"Audio\": \"Video\"); void *dummy; pthread_join(mThread, &amp;dummy); status_t err = static_cast&lt;status_t&gt;(reinterpret_cast&lt;uintptr_t&gt;(dummy)); ALOGD(\"%s track stopped\", mIsAudio? \"Audio\": \"Video\"); return err;&#125;void MPEG4Writer::release() &#123; close(mFd); mFd = -1; mInitCheck = NO_INIT; mStarted = false; free(mMoovBoxBuffer); mMoovBoxBuffer = NULL;&#125; ï¼ˆå…­ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šCamera#capture-videoAndroid NuPlayeræ’­æ”¾æ¡†æ¶ android ACodec MediaCodec NuPlayer flow - CSDNåšå®¢android MediaCodec ACodec - CSDNåšå®¢ffmpegå¼€å‘ä¹‹æ—…(1)-(7)ï¼ˆæ€»å…±ä¸ƒç¯‡ï¼‰æ·±å…¥ç†è§£AndroidéŸ³è§†é¢‘åŒæ­¥æœºåˆ¶ï¼ˆæ€»å…±äº”ç¯‡ï¼‰Androidç¡¬ç¼–ç â€”â€”éŸ³é¢‘ç¼–ç ã€è§†é¢‘ç¼–ç åŠéŸ³è§†é¢‘æ··åˆAndroid é«˜é€šå¹³å°Cameraå½•åˆ¶â€“MPEG4Writer.cpp ç®€å•è·Ÿè¯»","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Video Systemï¼ˆ2ï¼‰ï¼šéŸ³è§†é¢‘åˆ†ç¦»MediaExtractorã€è§£ç Decoderã€æ¸²æŸ“Rendereræºç åˆ†æ","slug":"Android Video Systemï¼ˆ2ï¼‰ï¼šéŸ³è§†é¢‘åˆ†ç¦»MediaExtractorã€è§£ç Decoderã€æ¸²æŸ“Rendereræºç åˆ†æ","date":"2018-06-05T16:00:00.000Z","updated":"2018-05-17T16:23:42.126Z","comments":true,"path":"2018/06/06/Android Video Systemï¼ˆ2ï¼‰ï¼šéŸ³è§†é¢‘åˆ†ç¦»MediaExtractorã€è§£ç Decoderã€æ¸²æŸ“Rendereræºç åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/06/06/Android Video Systemï¼ˆ2ï¼‰ï¼šéŸ³è§†é¢‘åˆ†ç¦»MediaExtractorã€è§£ç Decoderã€æ¸²æŸ“Rendereræºç åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android NuPlayeræ’­æ”¾æ¡†æ¶ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - android ACodec MediaCodec NuPlayer flowã€‘Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) â˜¯ V4l2 æ¡†æ¶ä»£ç â˜¯ kernel/drivers/media/v4l2-core/ï¼ˆæ–‡ä»¶å‰ç¼€ä¸º videobuf2ï¼‰ â˜¯ MSM è§†é¢‘é©±åŠ¨ç¨‹åºæ–‡ä»¶â˜¯ kernel/drivers/media/platform/msm/vidc/ â˜¯ è®¾å¤‡æ ‘â˜¯ /kernel/arch/arm/boot/dts/qcomï¼ˆVenus çš„å¯„å­˜å™¨åŸºå€ï¼Œæ—¶é’Ÿé¢‘ç‡ï¼‰ â˜¯ Stagefrightã€libmediaã€libmediaplayerserviceã€mediaserverâ˜¯ /frameworks/av/media/ â˜¯ OMXâ˜¯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/ â˜¯ OMX æ ¸å¿ƒâ˜¯ /hardware/qcom/media/mm-core â˜¯ è½¯ä»¶ç¼–è§£ç å™¨è·¯å¾„â˜¯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)â†’ è§£ç å™¨ä»£ç â˜¯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) â†’ ç¼–ç å™¨ä»£ç  Androidåœ¨Javaå±‚ä¸­æä¾›äº†ä¸€ä¸ªMediaPlayerçš„ç±»æ¥ä½œä¸ºæ’­æ”¾åª’ä½“èµ„æºçš„æ¥å£ï¼Œåœ¨ä½¿ç”¨ä¸­æˆ‘ä»¬é€šå¸¸ä¼šç¼–å†™ä»¥ä¸‹çš„ä»£ç ï¼š 12345678910mMediaPlayer = new MediaPlayer();mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+\"/test_video.mp4\");mMediaPlayer.setDisplay(...);mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mMediaPlayer.prepareAsync();mMediaPlayer.start();mediaPlayer.pause(); mediaPlayer.stop();mediaPlayer.reset();mediaPlayer.release(); å‰é¢ç¬¬ä¸€ç« èŠ‚å·²ç»åˆ†æè¿‡mMediaPlayer.setDataSource()ã€mMediaPlayer.setDisplay()ä¸‹æ¥çš„åˆ†æå°è¯•åˆ†æè§£ç­”å¦‚ä¸‹ç–‘é—®ï¼š ä¸åŒæ ¼å¼çš„å¤šåª’ä½“æ–‡ä»¶å¦‚ä½•æ¢æµ‹å¹¶è§£æçš„ï¼ŸéŸ³è§†é¢‘æ•°æ®ç¼“å†²åŒºåœ¨å“ªé‡Œï¼Ÿï¼ˆSourceï¼‰éŸ³é¢‘è§£ç çº¿ç¨‹ã€è§†é¢‘è§£ç çº¿ç¨‹åœ¨å“ªé‡Œï¼Ÿ ï¼ˆDecoderBaseï¼‰è§†é¢‘å¦‚ä½•æ˜¾ç¤ºçš„ï¼ŸéŸ³é¢‘å¦‚ä½•æ’­æ”¾çš„ï¼ŸéŸ³è§†é¢‘åŒæ­¥åœ¨å“ªé‡Œï¼Ÿï¼ˆRendererï¼‰ ï¼ˆä¸€ï¼‰ã€å¤šåª’ä½“æ–‡ä»¶è§£æ - MediaExtractoråˆ†ç¦»éŸ³è§†é¢‘æ¥ä¸‹æ¥ç»§ç»­åˆ†æmMediaPlayer.prepareAsync() 1.1ã€mMediaPlayer.prepareAsync()12[-&gt;\\frameworks\\base\\media\\java\\android\\media\\MediaPlayer.java]public native void prepareAsync() throws IllegalStateException; é€šè¿‡JNIè°ƒç”¨ 1234567891011121314151617[-&gt;\\frameworks\\base\\media\\jni\\android_media_MediaPlayer.cpp]static voidandroid_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)&#123; sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz); if (mp == NULL ) &#123; jniThrowException(env, \"java/lang/IllegalStateException\", NULL); return; &#125; // Handle the case where the display surface was set before the mp was // initialized. We try again to make it stick. sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz); mp-&gt;setVideoSurfaceTexture(st); process_media_player_call( env, thiz, mp-&gt;prepareAsync(), \"java/io/IOException\", \"Prepare Async failed.\" );&#125; é¦–å…ˆè®¾ç½®è§†é¢‘çš„ display surfaceï¼ˆå…³äºIGraphicBufferProducerç›¸å…³çŸ¥è¯†è¯·å‚è€ƒï¼šAndroid 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æ [i.wonder~]ï¼‰ï¼Œ 1.1.1ã€MediaPlayer.setVideoSurfaceTexture()123456789[-&gt;\\frameworks\\av\\media\\libmedia\\mediaplayer.cpp]status_t MediaPlayer::setVideoSurfaceTexture( const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)&#123; ALOGV(\"setVideoSurfaceTexture\"); Mutex::Autolock _l(mLock); if (mPlayer == 0) return NO_INIT; return mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);&#125; å‰é¢setDataSource()åˆ†æè¿‡ï¼Œæ­¤å¤„ä¼šè°ƒç”¨NuPlayerçš„setVideoSurfaceTexture()å‡½æ•° 12345678910111213[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::setVideoSurfaceTextureAsync( const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatSetVideoSurface, this); if (bufferProducer == NULL) &#123; msg-&gt;setObject(\"surface\", NULL); &#125; else &#123; msg-&gt;setObject(\"surface\", new Surface(bufferProducer, true /* controlledByApp */)); &#125; msg-&gt;post();&#125; æ­¤å¤„é¦–å…ˆæ„é€ äº†ä¸€ä¸ªAMessageæ¶ˆæ¯ï¼Œç„¶ånew Surface()ï¼Œæ¥ä¸‹æ¥çœ‹çœ‹æ¶ˆæ¯å¤„ç†è¿‡ç¨‹ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]case kWhatSetVideoSurface: &#123; sp&lt;RefBase&gt; obj; CHECK(msg-&gt;findObject(\"surface\", &amp;obj)); sp&lt;Surface&gt; surface = static_cast&lt;Surface *&gt;(obj.get()); if (mSource == NULL || !mStarted || mSource-&gt;getFormat(false /* audio */) == NULL // NOTE: mVideoDecoder's mSurface is always non-null || (mVideoDecoder != NULL &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123; performSetSurface(surface); break; &#125; mDeferredActions.push_back( new FlushDecoderAction(FLUSH_CMD_FLUSH /* audio */, FLUSH_CMD_SHUTDOWN /* video */)); mDeferredActions.push_back(new SetSurfaceAction(surface)); if (obj != NULL || mAudioDecoder != NULL) &#123; if (mStarted) &#123; int64_t currentPositionUs = 0; if (getCurrentPosition(&amp;currentPositionUs) == OK) &#123; mDeferredActions.push_back( new SeekAction(currentPositionUs)); &#125; &#125; mDeferredActions.push_back( new SimpleAction(&amp;NuPlayer::performScanSources)); &#125; mDeferredActions.push_back( new ResumeDecoderAction(false /* needNotify */)); processDeferredActions(); break; &#125;void NuPlayer::performSetSurface(const sp&lt;Surface&gt; &amp;surface) &#123; ALOGV(\"performSetSurface\"); mSurface = surface; // XXX - ignore error from setVideoScalingMode for now setVideoScalingMode(mVideoScalingMode); if (mDriver != NULL) &#123; sp&lt;NuPlayerDriver&gt; driver = mDriver.promote(); if (driver != NULL) &#123; driver-&gt;notifySetSurfaceComplete(); &#125; &#125;&#125; å¯ä»¥çœ‹åˆ°å°†surface èµ‹å€¼ç»™NuPlayerçš„mSurface ï¼Œå¾…è§†é¢‘è§£ç åå°±å¯ä»¥åœ¨æ­¤surface ä¸Šæ¸²æŸ“ç”»é¢äº†ï¼Œè¿™ä¸ªç¨åå†ä½œåˆ†æã€‚ 1.1.2ã€MediaPlayer.prepareAsync()ç„¶åæ¥ç€è°ƒç”¨MediaPlayer prepareAsync()å‡½æ•°ã€‚12345678910111213141516171819202122[-&gt;\\frameworks\\av\\media\\libmedia\\mediaplayer.cpp]status_t MediaPlayer::prepareAsync()&#123; ALOGV(\"prepareAsync\"); Mutex::Autolock _l(mLock); return prepareAsync_l();&#125;status_t MediaPlayer::prepareAsync_l()&#123; if ( (mPlayer != 0) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123; if (mAudioAttributesParcel != NULL) &#123; mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel); &#125; else &#123; mPlayer-&gt;setAudioStreamType(mStreamType); &#125; mCurrentState = MEDIA_PLAYER_PREPARING; return mPlayer-&gt;prepareAsync(); &#125; ALOGE(\"prepareAsync called in state %d, mPlayer(%p)\", mCurrentState, mPlayer.get()); return INVALID_OPERATION;&#125; æ­¤å¤„ä¼šè°ƒç”¨NuPlayerçš„prepareAsync()å‡½æ•°ï¼ŒprepareAsync()å‘é€äº†ä¸€ä¸ªkWhatPrepareçš„AMessageï¼Œæˆ‘ä»¬ç›´æ¥çœ‹çœ‹æ¶ˆæ¯å¤„ç†ã€‚ 123456789[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::prepareAsync() &#123; (new AMessage(kWhatPrepare, this))-&gt;post();&#125; case kWhatPrepare:&#123; mSource-&gt;prepareAsync(); break;&#125; æ­¤å¤„åˆè°ƒç”¨äº†GenericSourceçš„prepareAsync()å‡½æ•°ï¼Œå‘é€äº†ä¸€ä¸ªkWhatPrepareAsyncæ¶ˆæ¯ã€‚ç›´æ¥çœ‹çœ‹GenericSourceå¦‚ä½•å¤„ç†çš„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\GenericSource.cpp]void NuPlayer::GenericSource::prepareAsync() &#123; if (mLooper == NULL) &#123; mLooper = new ALooper; mLooper-&gt;setName(\"generic\"); mLooper-&gt;start(); mLooper-&gt;registerHandler(this); &#125; sp&lt;AMessage&gt; msg = new AMessage(kWhatPrepareAsync, this); msg-&gt;post();&#125; switch (msg-&gt;what()) &#123; case kWhatPrepareAsync: &#123; onPrepareAsync(); break; &#125;void NuPlayer::GenericSource::onPrepareAsync() &#123; // delayed data source creation if (mDataSource == NULL) &#123; // set to false first, if the extractor // comes back as secure, set it to true then. mIsSecure = false; if (!mUri.empty()) &#123; const char* uri = mUri.c_str(); String8 contentType; mIsWidevine = !strncasecmp(uri, \"widevine://\", 11); if (!strncasecmp(\"http://\", uri, 7) || !strncasecmp(\"https://\", uri, 8) || mIsWidevine) &#123; mHttpSource = DataSource::CreateMediaHTTP(mHTTPService); ...... &#125; mDataSource = DataSource::CreateFromURI( mHTTPService, uri, &amp;mUriHeaders, &amp;contentType, static_cast&lt;HTTPBase *&gt;(mHttpSource.get())); &#125; else &#123; mIsWidevine = false; mDataSource = new FileSource(mFd, mOffset, mLength); mFd = -1; &#125; ...... &#125; if (mDataSource-&gt;flags() &amp; DataSource::kIsCachingDataSource) &#123; mCachedSource = static_cast&lt;NuCachedSource2 *&gt;(mDataSource.get()); &#125; mIsStreaming = (mIsWidevine || mCachedSource != NULL); // init extractor from data source status_t err = initFromDataSource(); if (mVideoTrack.mSource != NULL) &#123; sp&lt;MetaData&gt; meta = doGetFormatMeta(false /* audio */); sp&lt;AMessage&gt; msg = new AMessage; err = convertMetaDataToMessage(meta, &amp;msg); ...... notifyVideoSizeChanged(msg); &#125; ...... if (mIsSecure) &#123; // secure decoders must be instantiated before starting widevine source sp&lt;AMessage&gt; reply = new AMessage(kWhatSecureDecodersInstantiated, this); notifyInstantiateSecureDecoders(reply); &#125; else &#123; finishPrepareAsync(); &#125;&#125; é¦–å…ˆæ„é€ äº† mDataSource = new FileSourceï¼Œç„¶åè°ƒç”¨äº†initFromDataSource()ï¼Œè¿™é‡Œé¢åŒ…å«å¤šåª’ä½“æ–‡ä»¶æ ¼å¼æ¢æµ‹ï¼Œã€‚ 1.1.3ã€GenericSource.initFromDataSource()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\GenericSource.cpp]status_t NuPlayer::GenericSource::initFromDataSource() &#123; sp&lt;IMediaExtractor&gt; extractor; String8 mimeType; float confidence; sp&lt;AMessage&gt; dummy; bool isWidevineStreaming = false; CHECK(mDataSource != NULL); if (mIsWidevine) &#123; ...... &#125; else if (mIsStreaming) &#123; if (!mDataSource-&gt;sniff(&amp;mimeType, &amp;confidence, &amp;dummy)) &#123; return UNKNOWN_ERROR; &#125; isWidevineStreaming = !strcasecmp( mimeType.string(), MEDIA_MIMETYPE_CONTAINER_WVM); &#125; if (isWidevineStreaming) &#123; ...... &#125; else &#123; extractor = MediaExtractor::Create(mDataSource, mimeType.isEmpty() ? NULL : mimeType.string()); &#125; ...... if (extractor-&gt;getDrmFlag()) &#123; checkDrmStatus(mDataSource); &#125; mFileMeta = extractor-&gt;getMetaData(); if (mFileMeta != NULL) &#123; int64_t duration; if (mFileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123; mDurationUs = duration; &#125;...... &#125; int32_t totalBitrate = 0; size_t numtracks = extractor-&gt;countTracks(); for (size_t i = 0; i &lt; numtracks; ++i) &#123; sp&lt;IMediaSource&gt; track = extractor-&gt;getTrack(i); sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i); const char *mime; CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime)); // Do the string compare immediately with \"mime\", // we can't assume \"mime\" would stay valid after another // extractor operation, some extractors might modify meta // during getTrack() and make it invalid. if (!strncasecmp(mime, \"audio/\", 6)) &#123; if (mAudioTrack.mSource == NULL) &#123; mAudioTrack.mIndex = i; mAudioTrack.mSource = track; mAudioTrack.mPackets = new AnotherPacketSource(mAudioTrack.mSource-&gt;getFormat()); if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123; mAudioIsVorbis = true; &#125; else &#123; mAudioIsVorbis = false; &#125; &#125; &#125; else if (!strncasecmp(mime, \"video/\", 6)) &#123; if (mVideoTrack.mSource == NULL) &#123; mVideoTrack.mIndex = i; mVideoTrack.mSource = track; mVideoTrack.mPackets = new AnotherPacketSource(mVideoTrack.mSource-&gt;getFormat()); // check if the source requires secure buffers int32_t secure; if (meta-&gt;findInt32(kKeyRequiresSecureBuffers, &amp;secure) &amp;&amp; secure) &#123; mIsSecure = true; if (mUIDValid) &#123; extractor-&gt;setUID(mUID); &#125; &#125; &#125; &#125; mSources.push(track); int64_t durationUs; if (meta-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123; if (durationUs &gt; mDurationUs) &#123; mDurationUs = durationUs; &#125; &#125; int32_t bitrate; if (totalBitrate &gt;= 0 &amp;&amp; meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123; totalBitrate += bitrate; &#125; else &#123; totalBitrate = -1; &#125; &#125; ...... mBitrate = totalBitrate; return OK;&#125; å¯ä»¥çœ‹åˆ°é€šè¿‡MediaExtractor::Create()å¾—åˆ°MediaExtractorï¼Œç„¶åå°†æ•°æ®è§£ææˆtrack èµ‹å€¼ç»™mAudioTrack.mSourceã€mVideoTrack.mSourceã€‚ 1.1.4ã€MediaExtractor::Create()123456789101112131415161718192021222324252627282930313233343536373839404142434445[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaExtractor.cpp]sp&lt;IMediaExtractor&gt; MediaExtractor::Create( const sp&lt;DataSource&gt; &amp;source, const char *mime) &#123; ALOGV(\"MediaExtractor::Create %s\", mime); char value[PROPERTY_VALUE_MAX]; if (property_get(\"media.stagefright.extractremote\", value, NULL) &amp;&amp; (!strcmp(\"0\", value) || !strcasecmp(\"false\", value))) &#123; // local extractor ALOGW(\"creating media extractor in calling process\"); return CreateFromService(source, mime); &#125; else &#123; // Check if it's WVM, since WVMExtractor needs to be created in the media server process, // not the extractor process. String8 mime8; float confidence; sp&lt;AMessage&gt; meta; if (SniffWVM(source, &amp;mime8, &amp;confidence, &amp;meta) &amp;&amp; !strcasecmp(mime8, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123; return new WVMExtractor(source); &#125; ...... if (SniffDRM(source, &amp;mime8, &amp;confidence, &amp;meta)) &#123; const char *drmMime = mime8.string(); ALOGV(\"Detected media content as '%s' with confidence %.2f\", drmMime, confidence); if (!strncmp(drmMime, \"drm+es_based+\", 13)) &#123; // DRMExtractor sets container metadata kKeyIsDRM to 1 return new DRMExtractor(source, drmMime + 14); &#125; &#125; // remote extractor ALOGV(\"get service manager\"); sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(\"media.extractor\")); if (binder != 0) &#123; sp&lt;IMediaExtractorService&gt; mediaExService(interface_cast&lt;IMediaExtractorService&gt;(binder)); sp&lt;IMediaExtractor&gt; ex = mediaExService-&gt;makeExtractor(RemoteDataSource::wrap(source), mime); return ex; &#125; else &#123; ...... &#125; &#125; return NULL;&#125; å¯ä»¥çœ‹åˆ°é€šè¿‡Binderé€šä¿¡è·å–â€media.extractorâ€æœåŠ¡å¾—åˆ°ä¸€ä¸ªExtractorã€‚ 1.1.5ã€IMediaExtractor-&gt;getTrack()æ ¹æ®ä¸åŒç±»åˆ«è§£æå‡ºä¸åŒçš„Track 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[-&gt;\\frameworks\\av\\media\\libstagefright\\]AACExtractor.cpp sp&lt;IMediaSource&gt; AACExtractor::getTrack(size_t index)AMRExtractor.cpp sp&lt;IMediaSource&gt; AMRExtractor::getTrack(size_t index)MP3Extractor.cpp sp&lt;IMediaSource&gt; MP3Extractor::getTrack(size_t index)NuMediaExtractor.cpp sp&lt;IMediaSource&gt; source = mImpl-&gt;getTrack(index)WAVExtractor.cpp sp&lt;IMediaSource&gt; WAVExtractor::getTrack(size_t index)FLACExtractor.cpp sp&lt;IMediaSource&gt; FLACExtractor::getTrack(size_t index) StagefrightMetadataRetriever.cpp sp&lt;IMediaSource&gt; source = mExtractor-&gt;getTrack(i)AVIExtractor.cpp sp&lt;MediaSource&gt; AVIExtractor::getTrack(size_t index)OggExtractor.cpp sp&lt;IMediaSource&gt; OggExtractor::getTrack(size_t index)MPEG4Extractor.cpp sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(size_t index)//MP3sp&lt;IMediaSource&gt; MP3Extractor::getTrack(size_t index) &#123; return new MP3Source( mMeta, mDataSource, mFirstFramePos, mFixedHeader, mSeeker);&#125;//MPEG4sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(size_t index) &#123; status_t err; ...... Track *track = mFirstTrack; while (index &gt; 0) &#123; if (track == NULL) &#123; return NULL; &#125; track = track-&gt;next; --index; &#125; ...... Trex *trex = NULL; int32_t trackId; if (track-&gt;meta-&gt;findInt32(kKeyTrackID, &amp;trackId)) &#123; for (size_t i = 0; i &lt; mTrex.size(); i++) &#123; Trex *t = &amp;mTrex.editItemAt(i); if (t-&gt;track_ID == (uint32_t) trackId) &#123; trex = t; break; &#125; &#125; &#125; else &#123; ...... &#125; const char *mime; ....... if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) &#123; uint32_t type; const void *data; size_t size; if (!track-&gt;meta-&gt;findData(kKeyAVCC, &amp;type, &amp;data, &amp;size)) &#123; return NULL; &#125; const uint8_t *ptr = (const uint8_t *)data; ...... &#125; else if (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) &#123; uint32_t type; const void *data; size_t size; if (!track-&gt;meta-&gt;findData(kKeyHVCC, &amp;type, &amp;data, &amp;size)) &#123; return NULL; &#125; const uint8_t *ptr = (const uint8_t *)data; ...... &#125; return new MPEG4Source(this, track-&gt;meta, mDataSource, track-&gt;timescale, track-&gt;sampleTable, mSidxEntries, trex, mMoofOffset);&#125; å¾—åˆ°ä¸åŒæ ¼å¼çš„ MP3Extractorã€MPEG4Source â€¦â€¦ è¿˜è®°çš„å‰é¢æå‡ºçš„ç¬¬ä¸€ç‚¹ç–‘é—®å—ï¼Œç°åœ¨æˆ‘ä»¬çŸ¥é“äº†å¦‚ä½•åˆ†ç¦»éŸ³è§†é¢‘äº†å¹¶ä¸”å¾—åˆ°äº†ç›¸åº”çš„æ–‡ä»¶Sourceäº†ã€‚å›¾ç¤ºï¼ˆçº¢çº¿éƒ¨åˆ†ï¼‰ï¼š ï¼ˆäºŒï¼‰ã€å¤šåª’ä½“æ–‡ä»¶ - éŸ³è§†é¢‘è§£ç ï¼ˆDecoderï¼‰éŸ³é¢‘è§£ç ã€è§†é¢‘è§£ç åœ¨ä½•å¤„ï¼Œç­”æ¡ˆå°±åœ¨mMediaPlayer.start()æµç¨‹å½“ä¸­ï¼Œå…ˆçœ‹çœ‹start()æ€»ä½“æ—¶åºå›¾ï¼Œç„¶åä¸€æ­¥æ­¥åˆ†æ ç”±äºä»Javaå±‚åˆ°JNIå‰é¢å·²å¤šæ¬¡åˆ†æï¼Œè¿™é‡Œç›´æ¥ä»NuPlayer::start()å¼€å§‹åˆ†æ 2.1ã€NuPlayer::start()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::start() &#123; (new AMessage(kWhatStart, this))-&gt;post();&#125; case kWhatStart: &#123; ALOGV(\"kWhatStart\"); if (mStarted) &#123; // do not resume yet if the source is still buffering if (!mPausedForBuffering) &#123; onResume(); &#125; &#125; else &#123; onStart(); &#125; mPausedByClient = false; break; &#125;void NuPlayer::onStart(int64_t startPositionUs) &#123; if (!mSourceStarted) &#123; mSourceStarted = true; mSource-&gt;start(); &#125; if (startPositionUs &gt; 0) &#123; performSeek(startPositionUs); if (mSource-&gt;getFormat(false /* audio */) == NULL) &#123; return; &#125; &#125; mOffloadAudio = false; mAudioEOS = false; mVideoEOS = false; mStarted = true; mPaused = false; uint32_t flags = 0; if (mSource-&gt;isRealTime()) &#123; flags |= Renderer::FLAG_REAL_TIME; &#125; sp&lt;MetaData&gt; audioMeta = mSource-&gt;getFormatMeta(true /* audio */); sp&lt;MetaData&gt; videoMeta = mSource-&gt;getFormatMeta(false /* audio */); ...... ALOGV_IF(audioMeta == NULL, \"no metadata for audio source\"); // video only stream audio_stream_type_t streamType = AUDIO_STREAM_MUSIC; if (mAudioSink != NULL) &#123; streamType = mAudioSink-&gt;getAudioStreamType(); &#125; sp&lt;AMessage&gt; videoFormat = mSource-&gt;getFormat(false /* audio */); mOffloadAudio = canOffloadStream(audioMeta, (videoFormat != NULL), mSource-&gt;isStreaming(), streamType) &amp;&amp; (mPlaybackSettings.mSpeed == 1.f &amp;&amp; mPlaybackSettings.mPitch == 1.f); if (mOffloadAudio) &#123; flags |= Renderer::FLAG_OFFLOAD_AUDIO; &#125; sp&lt;AMessage&gt; notify = new AMessage(kWhatRendererNotify, this); ++mRendererGeneration; notify-&gt;setInt32(\"generation\", mRendererGeneration); mRenderer = new Renderer(mAudioSink, notify, flags); mRendererLooper = new ALooper; mRendererLooper-&gt;setName(\"NuPlayerRenderer\"); mRendererLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO); mRendererLooper-&gt;registerHandler(mRenderer); status_t err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings); ...... float rate = getFrameRate(); if (rate &gt; 0) &#123; mRenderer-&gt;setVideoFrameRate(rate); &#125; if (mVideoDecoder != NULL) &#123; mVideoDecoder-&gt;setRenderer(mRenderer); &#125; if (mAudioDecoder != NULL) &#123; mAudioDecoder-&gt;setRenderer(mRenderer); &#125; postScanSources();&#125; è¿™é‡Œåˆ›å»ºäº†åä¸ºNuPlayerRendererçš„Rendererå¯¹è±¡ï¼Œç„¶åå¯åŠ¨å¾ªç¯ï¼Œçœ‹çœ‹åˆå§‹åŒ– 123456789101112131415161718192021222324[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]NuPlayer::Renderer::Renderer( const sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink, const sp&lt;AMessage&gt; &amp;notify, uint32_t flags) : mAudioSink(sink), mUseVirtualAudioSink(false), mNotify(notify), mFlags(flags), mNumFramesWritten(0), mDrainAudioQueuePending(false), mDrainVideoQueuePending(false), mAudioQueueGeneration(0), mVideoQueueGeneration(0), mAudioDrainGeneration(0), mVideoDrainGeneration(0), mAudioEOSGeneration(0), mPlaybackSettings(AUDIO_PLAYBACK_RATE_DEFAULT), ...... mWakeLock(new AWakeLock()) &#123; mMediaClock = new MediaClock; mPlaybackRate = mPlaybackSettings.mSpeed; mMediaClock-&gt;setPlaybackRate(mPlaybackRate);&#125; 2.2ã€postScanSources()1234567891011121314151617181920212223242526272829303132333435[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::postScanSources() &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatScanSources, this); msg-&gt;setInt32(\"generation\", mScanSourcesGeneration); msg-&gt;post(); mScanSourcesPending = true;&#125; case kWhatScanSources: &#123; int32_t generation; mScanSourcesPending = false; bool mHadAnySourcesBefore = (mAudioDecoder != NULL) || (mVideoDecoder != NULL); bool rescan = false; // initialize video before audio because successful initialization of // video may change deep buffer mode of audio. if (mSurface != NULL) &#123; if (instantiateDecoder(false, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123; rescan = true; &#125; &#125; // Don't try to re-open audio sink if there's an existing decoder. if (mAudioSink != NULL &amp;&amp; mAudioDecoder == NULL) &#123; if (instantiateDecoder(true, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123; rescan = true; &#125; &#125; ...... &#125; æ­¤å¤„è°ƒç”¨äº†instantiateDecoder()æ¥åˆå§‹åŒ–éŸ³è§†é¢‘è§£ç å™¨Decoder 2.3ã€instantiateDecoder()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]status_t NuPlayer::instantiateDecoder( bool audio, sp&lt;DecoderBase&gt; *decoder, bool checkAudioModeChange) &#123; ...... sp&lt;AMessage&gt; format = mSource-&gt;getFormat(audio); format-&gt;setInt32(\"priority\", 0 /* realtime */); ...... if (audio) &#123; sp&lt;AMessage&gt; notify = new AMessage(kWhatAudioNotify, this); ++mAudioDecoderGeneration; notify-&gt;setInt32(\"generation\", mAudioDecoderGeneration); if (checkAudioModeChange) &#123; determineAudioModeChange(format); &#125; if (mOffloadAudio) &#123; mSource-&gt;setOffloadAudio(true /* offload */); const bool hasVideo = (mSource-&gt;getFormat(false /*audio */) != NULL); format-&gt;setInt32(\"has-video\", hasVideo); *decoder = new DecoderPassThrough(notify, mSource, mRenderer); &#125; else &#123; mSource-&gt;setOffloadAudio(false /* offload */); *decoder = new Decoder(notify, mSource, mPID, mRenderer); &#125; &#125; else &#123; sp&lt;AMessage&gt; notify = new AMessage(kWhatVideoNotify, this); ++mVideoDecoderGeneration; notify-&gt;setInt32(\"generation\", mVideoDecoderGeneration); *decoder = new Decoder( notify, mSource, mPID, mRenderer, mSurface, mCCDecoder); // enable FRC if high-quality AV sync is requested, even if not // directly queuing to display, as this will even improve textureview // playback. &#123; char value[PROPERTY_VALUE_MAX]; if (property_get(\"persist.sys.media.avsync\", value, NULL) &amp;&amp; (!strcmp(\"1\", value) || !strcasecmp(\"true\", value))) &#123; format-&gt;setInt32(\"auto-frc\", 1); &#125; &#125; &#125; (*decoder)-&gt;init(); (*decoder)-&gt;configure(format); ...... return OK;&#125; 2.3.1ã€åˆ›å»ºéŸ³è§†é¢‘è§£ç å™¨new Decoder()123456789101112131415161718192021222324[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoder.cpp]NuPlayer::Decoder::Decoder( const sp&lt;AMessage&gt; &amp;notify, const sp&lt;Source&gt; &amp;source, pid_t pid, const sp&lt;Renderer&gt; &amp;renderer, const sp&lt;Surface&gt; &amp;surface, const sp&lt;CCDecoder&gt; &amp;ccDecoder) : DecoderBase(notify), mSurface(surface), mSource(source), mRenderer(renderer), mCCDecoder(ccDecoder), ...... mVideoWidth(0), mVideoHeight(0), mIsAudio(true), ...... mComponentName(\"decoder\") &#123; mCodecLooper = new ALooper; mCodecLooper-&gt;setName(\"NPDecoder-CL\"); mCodecLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO); mVideoTemporalLayerAggregateFps[0] = mFrameRateTotal;&#125; åˆ›å»ºéŸ³è§†é¢‘è§£ç å™¨ï¼ˆNuPlayer::Decoderï¼‰ï¼Œä¸ºå…¶åˆ›å»ºåä¸ºNPDecoder-CLçš„mCodecLooper ã€å…¶çˆ¶ç±»NuPlayer::DecoderBaseçš„æ„é€ ä¸­åˆ™ä¼šåˆ›å»ºNPDecoderã€‘ 12345678910111213[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoderBase.cpp]NuPlayer::DecoderBase::DecoderBase(const sp&lt;AMessage&gt; &amp;notify) : mNotify(notify), mBufferGeneration(0), mPaused(false), mStats(new AMessage), mRequestInputBuffersPending(false) &#123; // Every decoder has its own looper because MediaCodec operations // are blocking, but NuPlayer needs asynchronous operations. mDecoderLooper = new ALooper; mDecoderLooper-&gt;setName(\"NPDecoder\"); mDecoderLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO);&#125; 2.3.2ã€åˆå§‹åŒ–Decoder-&gt;init()å¯¹è¯¥è§£ç å™¨è¿›è¡Œinit()æ“ä½œï¼Œè°ƒç”¨NuPlayer::DecoderBase::init()ä¸ºmDecoderLooperæ³¨å†Œhandlerã€init()å’Œconfigure()éƒ½æ˜¯NuPlayerDecoderç»§æ‰¿è‡ªNuPlayer::DecoderBaseçš„æ–¹æ³•ã€‘ 123456789101112131415161718[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoderBase.cpp]void NuPlayer::DecoderBase::configure(const sp&lt;AMessage&gt; &amp;format) &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatConfigure, this); msg-&gt;setMessage(\"format\", format); msg-&gt;post();&#125;void NuPlayer::DecoderBase::init() &#123; mDecoderLooper-&gt;registerHandler(this);&#125; case kWhatConfigure: &#123; sp&lt;AMessage&gt; format; CHECK(msg-&gt;findMessage(\"format\", &amp;format)); onConfigure(format); break; &#125; å¯¹è¯¥è§£ç å™¨è¿›è¡Œconfigure(format)æ“ä½œï¼Œè°ƒç”¨NuPlayer::DecoderBase::configure(â€¦)äº§ç”Ÿä¸€ä¸ªkWhatConfigureæ¶ˆæ¯ï¼Œç„¶åæ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨NuPlayer::Decoder::onConfigure(â€¦) 2.3.3ã€é…ç½®Decoder-&gt;configure()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoder.cpp]void NuPlayer::Decoder::onConfigure(const sp&lt;AMessage&gt; &amp;format) &#123; mFormatChangePending = false; mTimeChangePending = false; ++mBufferGeneration; AString mime; mIsAudio = !strncasecmp(\"audio/\", mime.c_str(), 6); mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str()); mComponentName = mime; mComponentName.append(\" decoder\"); ALOGV(\"[%s] onConfigure (surface=%p)\", mComponentName.c_str(), mSurface.get()); mCodec = MediaCodec::CreateByType( mCodecLooper, mime.c_str(), false /* encoder */, NULL /* err */, mPid); int32_t secure = 0; if (format-&gt;findInt32(\"secure\", &amp;secure) &amp;&amp; secure != 0) &#123; if (mCodec != NULL) &#123; mCodec-&gt;getName(&amp;mComponentName); mComponentName.append(\".secure\"); mCodec-&gt;release(); ALOGI(\"[%s] creating\", mComponentName.c_str()); mCodec = MediaCodec::CreateByComponentName( mCodecLooper, mComponentName.c_str(), NULL /* err */, mPid); &#125; &#125; ...... mIsSecure = secure; mCodec-&gt;getName(&amp;mComponentName); status_t err; if (mSurface != NULL) &#123; // disconnect from surface as MediaCodec will reconnect err = native_window_api_disconnect( mSurface.get(), NATIVE_WINDOW_API_MEDIA); // We treat this as a warning, as this is a preparatory step. // Codec will try to connect to the surface, which is where // any error signaling will occur. ALOGW_IF(err != OK, \"failed to disconnect from surface: %d\", err); &#125; err = mCodec-&gt;configure( format, mSurface, NULL /* crypto */, 0 /* flags */); ...... rememberCodecSpecificData(format); mStats-&gt;setString(\"mime\", mime.c_str()); mStats-&gt;setString(\"component-name\", mComponentName.c_str()); if (!mIsAudio) &#123; int32_t width, height; if (mOutputFormat-&gt;findInt32(\"width\", &amp;width) &amp;&amp; mOutputFormat-&gt;findInt32(\"height\", &amp;height)) &#123; mStats-&gt;setInt32(\"width\", width); mStats-&gt;setInt32(\"height\", height); &#125; &#125; sp&lt;AMessage&gt; reply = new AMessage(kWhatCodecNotify, this); mCodec-&gt;setCallback(reply); err = mCodec-&gt;start(); releaseAndResetMediaBuffers(); mPaused = false; mResumePending = false;&#125; åœ¨onConfigureä¸­ï¼Œé¦–å…ˆä¼šè°ƒç”¨MediaCodec::CreateByType(â€¦)æˆ–è€…MediaCodec::CreateByComponentName(â€¦)æ ¹æ®æƒ…å†µåˆ›å»ºMediaCodecï¼Œæ¥ç€è°ƒç”¨MediaCodec::init(â€¦)ï¼Œéšåè°ƒç”¨MediaCodec::configure(â€¦)å¯¹MediaCodecè¿›è¡Œé…ç½®ä½¿å…¶è½¬å…¥ConfiguredçŠ¶æ€;ç„¶ååˆè°ƒç”¨MediaCodec::start()ä½¿MediaCodecè½¬å…¥ExecutingçŠ¶æ€ã€‚ 2.3.4ã€MediaCodec::init(â€¦)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodec.cpp]sp&lt;MediaCodec&gt; MediaCodec::CreateByType( const sp&lt;ALooper&gt; &amp;looper, const AString &amp;mime, bool encoder, status_t *err, pid_t pid) &#123; sp&lt;MediaCodec&gt; codec = new MediaCodec(looper, pid); const status_t ret = codec-&gt;init(mime, true /* nameIsType */, encoder); return ret == OK ? codec : NULL; // NULL deallocates codec.&#125;sp&lt;MediaCodec&gt; MediaCodec::CreateByComponentName( const sp&lt;ALooper&gt; &amp;looper, const AString &amp;name, status_t *err, pid_t pid) &#123; sp&lt;MediaCodec&gt; codec = new MediaCodec(looper, pid); const status_t ret = codec-&gt;init(name, false /* nameIsType */, false /* encoder */); return ret == OK ? codec : NULL; // NULL deallocates codec.&#125;sp&lt;MediaCodec&gt; MediaCodec::CreateByType( const sp&lt;ALooper&gt; &amp;looper, const AString &amp;mime, bool encoder, status_t *err, pid_t pid) &#123; sp&lt;MediaCodec&gt; codec = new MediaCodec(looper, pid); const status_t ret = codec-&gt;init(mime, true /* nameIsType */, encoder); if (err != NULL) &#123; *err = ret; &#125; return ret == OK ? codec : NULL; // NULL deallocates codec.&#125;status_t MediaCodec::init(const AString &amp;name, bool nameIsType, bool encoder) &#123; mResourceManagerService-&gt;init(); // save init parameters for reset mInitName = name; mInitNameIsType = nameIsType; mInitIsEncoder = encoder; // Current video decoders do not return from OMX_FillThisBuffer // quickly, violating the OpenMAX specs, until that is remedied // we need to invest in an extra looper to free the main event // queue. mCodec = GetCodecBase(name, nameIsType); ...... bool secureCodec = false; if (nameIsType &amp;&amp; !strncasecmp(name.c_str(), \"video/\", 6)) &#123; mIsVideo = true; &#125; else &#123; AString tmp = name; if (tmp.endsWith(\".secure\")) &#123; secureCodec = true; tmp.erase(tmp.size() - 7, 7); &#125; const sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance(); ...... ssize_t codecIdx = mcl-&gt;findCodecByName(tmp.c_str()); if (codecIdx &gt;= 0) &#123; const sp&lt;MediaCodecInfo&gt; info = mcl-&gt;getCodecInfo(codecIdx); Vector&lt;AString&gt; mimes; info-&gt;getSupportedMimes(&amp;mimes); for (size_t i = 0; i &lt; mimes.size(); i++) &#123; if (mimes[i].startsWith(\"video/\")) &#123; mIsVideo = true; break; &#125; &#125; &#125; &#125; if (mIsVideo) &#123; // video codec needs dedicated looper if (mCodecLooper == NULL) &#123; mCodecLooper = new ALooper; mCodecLooper-&gt;setName(\"CodecLooper\"); mCodecLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO); &#125; mCodecLooper-&gt;registerHandler(mCodec); &#125; else &#123; mLooper-&gt;registerHandler(mCodec); &#125; mLooper-&gt;registerHandler(this); mCodec-&gt;setNotificationMessage(new AMessage(kWhatCodecNotify, this)); sp&lt;AMessage&gt; msg = new AMessage(kWhatInit, this); msg-&gt;setString(\"name\", name); msg-&gt;setInt32(\"nameIsType\", nameIsType); if (nameIsType) &#123; msg-&gt;setInt32(\"encoder\", encoder); &#125; status_t err; Vector&lt;MediaResource&gt; resources; MediaResource::Type type = secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec; MediaResource::SubType subtype = mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec; resources.push_back(MediaResource(type, subtype, 1)); for (int i = 0; i &lt;= kMaxRetry; ++i) &#123; sp&lt;AMessage&gt; response; err = PostAndAwaitResponse(msg, &amp;response); &#125; return err;&#125; 2.3.4.1ã€GetCodecBaseå½“ç¼–è§£ç ä»¥â€omx.â€å¼€å¤´åˆ™åˆ›å»ºACodecå¯¹è±¡ã€‚1234567891011[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodec.cpp]sp&lt;CodecBase&gt; MediaCodec::GetCodecBase(const AString &amp;name, bool nameIsType) &#123; // at this time only ACodec specifies a mime type. if (nameIsType || name.startsWithIgnoreCase(\"omx.\")) &#123; return new ACodec; &#125; else if (name.startsWithIgnoreCase(\"android.filter.\")) &#123; return new MediaFilter; &#125; else &#123; return NULL; &#125;&#125; 2.3.4.2ã€MediaCodecList::getInstance()1234567891011121314[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodecList.cpp]sp&lt;IMediaCodecList&gt; MediaCodecList::getInstance() &#123; Mutex::Autolock _l(sRemoteInitMutex); if (sRemoteList == NULL) &#123; sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(\"media.player\")); sp&lt;IMediaPlayerService&gt; service = interface_cast&lt;IMediaPlayerService&gt;(binder); if (service.get() != NULL) &#123; sRemoteList = service-&gt;getCodecList(); &#125; &#125; return sRemoteList;&#125; é€šè¿‡Binderé€šä¿¡è·å–MediaCodecåˆ—è¡¨ã€‚getCodecList()å‡½æ•°å®ç°åœ¨ 1234[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\MediaPlayerService.cpp]sp&lt;IMediaCodecList&gt; MediaPlayerService::getCodecList() const &#123; return MediaCodecList::getLocalInstance();&#125; 1234567891011121314151617[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodecList.cpp]sp&lt;IMediaCodecList&gt; MediaCodecList::getLocalInstance() &#123; Mutex::Autolock autoLock(sInitMutex); if (sCodecList == NULL) &#123; MediaCodecList *codecList = new MediaCodecList; ...... &#125; return sCodecList;&#125;MediaCodecList::MediaCodecList() : mInitCheck(NO_INIT), mUpdate(false), mGlobalSettings(new AMessage()) &#123; parseTopLevelXMLFile(\"/etc/media_codecs.xml\"); parseTopLevelXMLFile(\"/etc/media_codecs_performance.xml\", true/* ignore_errors */); parseTopLevelXMLFile(kProfilingResults, true/* ignore_errors */);&#125; O(âˆ©_âˆ©)Oå“ˆå“ˆ~ï¼Œç»ˆäºåˆ†æåˆ°CodecsåŠ è½½çš„åœ°æ–¹äº†ã€‚è¿˜è®°å¾—ç¬¬ä¸€ç« èŠ‚åˆ†æçš„é™„å½•å—ï¼Œé«˜é€šçš„éŸ³è§†é¢‘ç¡¬è§£ç ï¼Œè¿™é‡Œå†è´´ä¸€ä¸‹ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)] &lt;Decoders&gt; &lt;!-- Video Hardware --&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.avc\" type=\"video/avc\" &gt; &lt;Quirk name=\"requires-allocate-on-input-ports\" /&gt; &lt;Quirk name=\"requires-allocate-on-output-ports\" /&gt; &lt;Limit name=\"size\" min=\"64x64\" max=\"4096x2160\" /&gt; &lt;Limit name=\"alignment\" value=\"2x2\" /&gt; &lt;Limit name=\"block-size\" value=\"16x16\" /&gt; &lt;Limit name=\"blocks-per-second\" min=\"1\" max=\"1958400\" /&gt; &lt;Limit name=\"bitrate\" range=\"1-100000000\" /&gt; &lt;Limit name=\"frame-rate\" range=\"1-240\" /&gt; &lt;Limit name=\"vt-version\" value=\"65537\" /&gt; &lt;Limit name=\"vt-low-latency\" value=\"1\" /&gt; &lt;Limit name=\"vt-max-macroblock-processing-rate\" value=\"972000\" /&gt; &lt;Limit name=\"vt-max-level\" value=\"52\" /&gt; &lt;Limit name=\"vt-max-instances\" value=\"16\" /&gt; &lt;Feature name=\"adaptive-playback\" /&gt; &lt;Limit name=\"concurrent-instances\" max=\"16\" /&gt; &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.avc.secure\" type=\"video/avc\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.mpeg4\" type=\"video/mp4v-es\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.h263\" type=\"video/3gpp\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vc1\" type=\"video/x-ms-wmv\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vc1.secure\" type=\"video/x-ms-wmv\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.divx\" type=\"video/divx\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.divx311\" type=\"video/divx311\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.divx4\" type=\"video/divx4\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vp8\" type=\"video/x-vnd.on2.vp8\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vp9\" type=\"video/x-vnd.on2.vp9\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vp9.secure\" type=\"video/x-vnd.on2.vp9\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.hevc\" type=\"video/hevc\" &gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.hevc.secure\" type=\"video/hevc\" &gt; &lt;!-- Audio Software --&gt; &lt;MediaCodec name=\"OMX.qti.audio.decoder.flac\" type=\"audio/flac\" /&gt; &lt;/Decoders&gt; &lt;Include href=\"media_codecs_google_video.xml\" /&gt; 2.3.5ã€MediaCodec-&gt;configure()äº§ç”ŸkWhatConfigureæ¶ˆæ¯ï¼Œåœ¨æ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨ACodec::initiateConfigureComponent(â€¦)åˆäº§ç”Ÿæ¶ˆæ¯kWhatConfigureComponentï¼Œç„¶åè¯¥æ¶ˆæ¯å¤„ç†ä¸­åˆè°ƒç”¨äº†ACodec::LoadedState::onConfigureComponent(â€¦)ã€‚ç„¶ååœ¨å…¶ä¸­åˆä¼šå…ˆè°ƒç”¨ACodec::configureCodec(â€¦)ï¼Œåœ¨configureCodecä¸­ä¼šå¯¹IOMXè¿›è¡Œä¸€ç³»åˆ—çš„è®¾ç½®ä»¥åŠé…ç½®æ“ä½œï¼Œé€šè¿‡Binderé€šä¿¡å°±å¯¹OMXNodeInstanceè¿›è¡Œç›¸åº”çš„è®¾ç½®å’Œé…ç½®æ“ä½œï¼Œæœ€ç»ˆå°±å¯¹OMXç»„ä»¶è¿›è¡Œäº†ç›¸åº”çš„è®¾ç½®å’Œé…ç½®ã€‚ç„¶åå‘MediaCodecå‘é€kWhatComponentConfiguredæ¶ˆæ¯ï¼Œåœ¨æ¶ˆæ¯å¤„ç†ä¸­å°†MediaCodecçŠ¶æ€è®¾ä¸ºCONFIGUREDï¼› 1234567891011121314151617181920212223242526272829[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodec.cpp]status_t MediaCodec::configure( const sp&lt;AMessage&gt; &amp;format, const sp&lt;Surface&gt; &amp;surface, const sp&lt;ICrypto&gt; &amp;crypto, uint32_t flags) &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatConfigure, this); case kWhatConfigure: &#123; sp&lt;AReplyToken&gt; replyID; ...... sp&lt;RefBase&gt; obj; sp&lt;AMessage&gt; format; ...... if (obj != NULL) &#123; format-&gt;setObject(\"native-window\", obj); status_t err = handleSetSurface(static_cast&lt;Surface *&gt;(obj.get())); &#125; else &#123; handleSetSurface(NULL); &#125; mReplyID = replyID; setState(CONFIGURING); ...... extractCSD(format); mCodec-&gt;initiateConfigureComponent(format); break; &#125; 1234567891011121314151617181920212223242526272829303132[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]void ACodec::initiateConfigureComponent(const sp&lt;AMessage&gt; &amp;msg) &#123; msg-&gt;setWhat(kWhatConfigureComponent); msg-&gt;setTarget(this); msg-&gt;post();&#125; case ACodec::kWhatConfigureComponent: &#123; onConfigureComponent(msg); handled = true; break; &#125;bool ACodec::LoadedState::onConfigureComponent( const sp&lt;AMessage&gt; &amp;msg) &#123; status_t err = OK; AString mime; if (!msg-&gt;findString(\"mime\", &amp;mime)) &#123; err = BAD_VALUE; &#125; else &#123; err = mCodec-&gt;configureCodec(mime.c_str(), msg); &#125; ...... &#123; sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup(); notify-&gt;setInt32(\"what\", CodecBase::kWhatComponentConfigured); notify-&gt;setMessage(\"input-format\", mCodec-&gt;mInputFormat); notify-&gt;setMessage(\"output-format\", mCodec-&gt;mOutputFormat); notify-&gt;post(); &#125; return true;&#125; 2.3.6ã€MediaCodec-&gt;start()äº§ç”ŸkWhatStartæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­å…ˆå°†MediaCodecçŠ¶æ€è®¾ä¸ºSTARTINGï¼Œç„¶åè°ƒç”¨ACodec::initiateStart()äº§ç”ŸkWhatStartæ¶ˆæ¯ï¼Œåœ¨å…¶æ¶ˆæ¯å¤„ç†ä¸­åˆè°ƒç”¨ACodec::LoadedState::onStart()ï¼Œç„¶ååœ¨å…¶ä¸­é¦–å…ˆå‘IOMXå‘é€çŠ¶æ€è½¬æ¢å‘½ä»¤ï¼Œç»è¿‡OMXNodeInstanceæœ€ç»ˆå¯¹å°†OMXç»„ä»¶çŠ¶æ€è½¬æ¢æˆIdleï¼ˆè½¬æ¢å®Œæˆæ—¶OMXä¼šå‘é€OMX_EventCmdCompleteäº‹ä»¶ï¼‰ï¼Œæ¥ç€å¯¹ACodecè¿›è¡ŒchangeStateè‡³LoadedToIdleStateã€‚è€Œåœ¨changeStateè¿‡ç¨‹ä¸­ä¼šè°ƒç”¨ACodec::LoadedToIdleState::stateEntered() =&gt; ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(â€¦)ï¼Œå…¶ä¸­ä¼šä¸ºOMXç»„ä»¶ç«¯å£åˆ†é…ç¼“å†²ï¼Œå¹¶å‘MediaCodecå‘é€æ¶ˆæ¯kWhatBuffersAllocatedï¼Œæ¶ˆæ¯å¤„ç†ä¸­å°†MediaCodecçŠ¶æ€è®¾ä¸ºSTARTEDè€Œè‹¥allocateBufferså¤±è´¥åˆ™ç”±IOMXç»OMXNodeInstanceå°†OMXç»„ä»¶è½¬æ¢å›LoadedçŠ¶æ€ï¼ŒåŒæ—¶æŠŠACodecçŠ¶æ€è½¬æ¢å›LoadedState 1234567891011121314[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodec.cpp]status_t MediaCodec::start() &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatStart, this);......&#125; case kWhatStart: &#123; sp&lt;AReplyToken&gt; replyID; ...... setState(STARTING); mCodec-&gt;initiateStart(); break; &#125; 1234567891011121314151617181920[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]void ACodec::initiateStart() &#123; (new AMessage(kWhatStart, this))-&gt;post();&#125; case ACodec::kWhatStart: &#123; onStart(); handled = true; break; &#125;void ACodec::LoadedState::onStart() &#123; status_t err = mCodec-&gt;mOMX-&gt;sendCommand(mCodec-&gt;mNode, OMX_CommandStateSet, OMX_StateIdle); if (err != OK) &#123; mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err)); &#125; else &#123; mCodec-&gt;changeState(mCodec-&gt;mLoadedToIdleState); &#125;&#125; ä¸€æ—¦ç¼“å†²åŒºæˆåŠŸåˆ†é…åˆ°è¾“å…¥å’Œè¾“å‡ºç«¯å£ï¼ŒOMXç»„ä»¶ï¼ˆç¼–è§£ç ï¼‰ä¼šä¸ºLoaded-to-IdleçŠ¶æ€ç”ŸæˆOMX_EventCmdCompleteäº‹ä»¶è½¬æ¢å¹¶ä½¿ç”¨EventHandlerCallbackå°†å…¶å‘é€ç»™å®¢æˆ·ç«¯ã€‚ ï¼ˆä¸‰ï¼‰ã€éŸ³è§†é¢‘è§£ç æ•°æ®å¤„ç†3.1ã€éŸ³è§†é¢‘è§£ç æ•°æ®å¤„ç†-emptyBufferè¿˜æ˜¯è€æ ·å­ï¼Œå…ˆçœ‹çœ‹æ—¶åºå›¾ï¼Œç„¶åä¸€æ­¥æ­¥åˆ†æ 1ã€ MediaCodec::start()ä¹‹åACodecæ˜¯åœ¨LoadedToIdleStateçŠ¶æ€ï¼Œæ­¤æ—¶è‹¥ACodec::LoadedToIdleState::onOMXEvent(â€¦)æ¥æ”¶åˆ°ç»„ä»¶è½¬æ¢è‡³IdleçŠ¶æ€åçš„OMX_EventCmdCompleteäº‹ä»¶ï¼Œä¼šå‘IOMXå‘é€çŠ¶æ€è½¬æ¢å‘½ä»¤ï¼Œç»è¿‡OMXNodeInstanceæœ€ç»ˆå¯¹å°†OMXç»„ä»¶çŠ¶æ€è½¬æ¢æˆExecutingçŠ¶æ€ï¼ˆè¿™é‡ŒOMXä¼šå‘é€OMX_EventCmdCompleteäº‹ä»¶ï¼‰ï¼Œç„¶åACodecè¿›è¡ŒchangeStateè‡³IdleToExecutingStateã€‚2ã€ æ­¤æ—¶ACodec::IdleToExecutingState::onOMXEvent(â€¦)æ£€æµ‹åˆ°ä¸Šé¢çš„OMX_EventCmdCompleteäº‹ä»¶åï¼Œä¼šé¦–å…ˆè°ƒç”¨å‡½æ•°ACodec::ExecutingState::resume()ï¼Œç„¶åå¯¹ACodecè¿›è¡ŒchangeStateè‡³ExecutingStateã€‚ 3.1.1ã€ACodec::ExecutingState::resume()123456789101112131415161718192021222324252627282930313233343536[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]void ACodec::ExecutingState::resume() &#123; submitOutputBuffers(); ...... for (size_t i = 0; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123; BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i); if (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123; postFillThisBuffer(info); &#125; &#125; mActive = true;&#125;void ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123; if (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123; return; &#125; CHECK_EQ((int)info-&gt;mStatus, (int)BufferInfo::OWNED_BY_US); sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup(); notify-&gt;setInt32(\"what\", CodecBase::kWhatFillThisBuffer); notify-&gt;setInt32(\"buffer-id\", info-&gt;mBufferID); info-&gt;mData-&gt;meta()-&gt;clear(); notify-&gt;setBuffer(\"buffer\", info-&gt;mData); sp&lt;AMessage&gt; reply = new AMessage(kWhatInputBufferFilled, mCodec); reply-&gt;setInt32(\"buffer-id\", info-&gt;mBufferID); notify-&gt;setMessage(\"reply\", reply); notify-&gt;post(); info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;&#125; åœ¨å‡½æ•°ACodec::ExecutingState::resume()ä¸­ä¼šè°ƒç”¨ACodec::BaseState::postFillThisBuffer(â€¦)ï¼Œç„¶åå…¶ä¸­ä¼šå…ˆå‘MediaCodecå‘é€kWhatFillThisBufferæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­åœ¨æ»¡è¶³ç›¸åº”çš„æ¡ä»¶ä¸‹å°±ä¼šå»è°ƒç”¨å‡½æ•°MediaCodec::onInputBufferAvailable()æ¥é€šçŸ¥NuPlayer::Decoderæœ‰å¯ç”¨çš„inputbufferï¼›ç„¶åå†ç”ŸæˆkWhatInputBufferFilledæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨ACodec::BaseState::onInputBufferFilled(â€¦)ã€‚ã€äº§ç”Ÿä¸¤ä¸ªæ¶ˆæ¯ï¼Œä¸€ä¸ªå‘ä¸Š(MediaCodec)å¤„ç†ï¼Œä¸€ä¸ªå‘ä¸‹(OMX)å¤„ç†ã€‘ 3.1.1.1ã€kWhatFillThisBufferæ¶ˆæ¯å¤„ç†12345678910111213141516171819202122232425262728293031[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodec.cpp] case CodecBase::kWhatFillThisBuffer: &#123; /* size_t index = */updateBuffers(kPortIndexInput, msg); ...... if (mFlags &amp; kFlagIsAsync) &#123; if (!mHaveInputSurface) &#123; if (mState == FLUSHED) &#123; mHavePendingInputBuffers = true; &#125; else &#123; onInputBufferAvailable(); &#125; &#125; &#125; else if (mFlags &amp; kFlagDequeueInputPending) &#123; ++mDequeueInputTimeoutGeneration; mFlags &amp;= ~kFlagDequeueInputPending; mDequeueInputReplyID = 0; &#125; else &#123; postActivityNotificationIfPossible(); &#125; break; &#125;void MediaCodec::onInputBufferAvailable() &#123; int32_t index; while ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= 0) &#123; sp&lt;AMessage&gt; msg = mCallback-&gt;dup(); msg-&gt;setInt32(\"callbackID\", CB_INPUT_AVAILABLE); msg-&gt;setInt32(\"index\", index); msg-&gt;post(); &#125;&#125; P.S. 1ï¼šMediaCodec::onInputBufferAvailable()çš„è°ƒç”¨ï¼šå…¶ä¸­ä¼šå…ˆè°ƒç”¨å‡½æ•°MediaCodec::dequeuePortBuffer(â€¦)è·å–bufferçš„ç´¢å¼•ï¼Œç„¶åå°†ä¸€ä¸ªæ–°æ¶ˆæ¯å‘é€ç»™NuPlayer::Decoderï¼Œå¹¶è®¾ç½®æ¶ˆæ¯çš„callbackIDä¸ºCB_INPUT_AVAILABLEï¼ŒåŒæ—¶è®¾ç½®indexï¼Œæ¥ç€NuPlayer::Decoderæ¥æ”¶åˆ°è¯¥CB_INPUT_AVAILABLEæ¶ˆæ¯ï¼Œåœ¨æ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨NuPlayer::Decoder::handleAnInputBuffer(â€¦)ï¼Œå…¶ä¼šï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoder.cpp]case MediaCodec::CB_INPUT_AVAILABLE:&#123; int32_t index; CHECK(msg-&gt;findInt32(\"index\", &amp;index)); handleAnInputBuffer(index); break;&#125;bool NuPlayer::Decoder::handleAnInputBuffer(size_t index) &#123; sp&lt;ABuffer&gt; buffer; mCodec-&gt;getInputBuffer(index, &amp;buffer); if (index &gt;= mInputBuffers.size()) &#123; for (size_t i = mInputBuffers.size(); i &lt;= index; ++i) &#123; mInputBuffers.add(); mMediaBuffers.add(); mInputBufferIsDequeued.add(); mMediaBuffers.editItemAt(i) = NULL; mInputBufferIsDequeued.editItemAt(i) = false; &#125; &#125; mInputBuffers.editItemAt(index) = buffer; if (mMediaBuffers[index] != NULL) &#123; mMediaBuffers[index]-&gt;release(); mMediaBuffers.editItemAt(index) = NULL; &#125; mInputBufferIsDequeued.editItemAt(index) = true; if (!mCSDsToSubmit.isEmpty()) &#123; sp&lt;AMessage&gt; msg = new AMessage(); msg-&gt;setSize(\"buffer-ix\", index); sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(0); msg-&gt;setBuffer(\"buffer\", buffer); mCSDsToSubmit.removeAt(0); return true; &#125; while (!mPendingInputMessages.empty()) &#123; sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin(); if (!onInputBufferFetched(msg)) &#123; break; &#125; mPendingInputMessages.erase(mPendingInputMessages.begin()); &#125; if (!mInputBufferIsDequeued.editItemAt(index)) &#123; return true; &#125; mDequeuedInputBuffers.push_back(index); onRequestInputBuffers(); return true;&#125; â—‹1ã€å…ˆé€šè¿‡MediaCodec::getInputBuffer(â€¦) -&gt; MediaCodec::getBufferAndFormat(â€¦)è·å–è¯¥buffer â—‹2ã€ç„¶åè°ƒç”¨NuPlayer::Decoder::onInputBufferFetched(â€¦)æ‰§è¡Œå†…å­˜æ‹·è´å°†bufferæ‹·è´åˆ°ç¼–è§£ç å™¨ï¼Œç„¶ååˆè°ƒç”¨äº†MediaCodec::queueInputBuffer(â€¦)å°†bufferæäº¤ç»™è§£ç å™¨ï¼Œå…¶ä¼šäº§ç”Ÿæ¶ˆæ¯kWhatQueueInputBufferï¼Œæ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨MediaCodec::onQueueInputBuffer(â€¦) â—‹3ã€ä¹‹åè°ƒç”¨å‡½æ•°NuPlayer::DecoderBase::onRequestInputBuffers()ï¼Œå¤„ç†æ˜¯å¦éœ€è¦æ›´å¤šçš„æ•°æ®ã€‚å…¶ä¸­ä¼šè°ƒç”¨NuPlayer::Decoder::doRequestBuffersï¼Œè‹¥è¿”å›trueåˆ™éœ€è¦æ›´å¤šçš„æ•°æ®ï¼Œåˆ™ä¼šäº§ç”Ÿæ–°æ¶ˆæ¯kWhatRequestInputBuffersï¼Œæ¶ˆæ¯å¤„ç†ä¸­åˆå°†è°ƒç”¨onRequestInputBuffersã€‚ï¼ˆå®é™…è·å–æ›´å¤šç¼“å†²çš„æ“ä½œåœ¨ä¸‹é¢ACodecéƒ¨åˆ†å®Œæˆï¼‰ 3.1.1.2ã€kWhatInputBufferFilledæ¶ˆæ¯å¤„ç†123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp] case kWhatInputBufferFilled: &#123; onInputBufferFilled(msg); break; &#125; void ACodec::BaseState::onInputBufferFilled(const sp&lt;AMessage&gt; &amp;msg) &#123; IOMX::buffer_id bufferID; CHECK(msg-&gt;findInt32(\"buffer-id\", (int32_t*)&amp;bufferID)); sp&lt;ABuffer&gt; buffer; int32_t err = OK; bool eos = false; PortMode mode = getPortMode(kPortIndexInput); int32_t tmp; BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexInput, bufferID); BufferInfo::Status status = BufferInfo::getSafeStatus(info); info-&gt;mStatus = BufferInfo::OWNED_BY_US; switch (mode) &#123; case KEEP_BUFFERS: &#123; if (eos) &#123; if (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123; mCodec-&gt;mPortEOS[kPortIndexInput] = true; mCodec-&gt;mInputEOSResult = err; &#125; &#125; break; &#125; case RESUBMIT_BUFFERS: &#123; if (buffer != NULL &amp;&amp; !mCodec-&gt;mPortEOS[kPortIndexInput]) &#123; int64_t timeUs; CHECK(buffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;timeUs)); OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME; MetadataBufferType metaType = mCodec-&gt;mInputMetadataType; int32_t isCSD = 0; if (buffer-&gt;meta()-&gt;findInt32(\"csd\", &amp;isCSD) &amp;&amp; isCSD != 0) &#123; if (mCodec-&gt;mIsLegacyVP9Decoder) &#123; postFillThisBuffer(info); break; &#125; flags |= OMX_BUFFERFLAG_CODECCONFIG; metaType = kMetadataBufferTypeInvalid; &#125; ...... if (buffer != info-&gt;mCodecData) &#123; sp&lt;DataConverter&gt; converter = mCodec-&gt;mConverter[kPortIndexInput]; status_t err = converter-&gt;convert(buffer, info-&gt;mCodecData); &#125; ...... info-&gt;checkReadFence(\"onInputBufferFilled\"); status_t err2 = OK; switch (metaType) &#123; case kMetadataBufferTypeInvalid: break;#ifndef OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS case kMetadataBufferTypeNativeHandleSource: if (info-&gt;mCodecData-&gt;size() &gt;= sizeof(VideoNativeHandleMetadata)) &#123; VideoNativeHandleMetadata *vnhmd = (VideoNativeHandleMetadata*)info-&gt;mCodecData-&gt;base(); err2 = mCodec-&gt;mOMX-&gt;updateNativeHandleInMeta( mCodec-&gt;mNode, kPortIndexInput, NativeHandle::create(vnhmd-&gt;pHandle, false /* ownsHandle */), bufferID); &#125; break; case kMetadataBufferTypeANWBuffer: if (info-&gt;mCodecData-&gt;size() &gt;= sizeof(VideoNativeMetadata)) &#123; VideoNativeMetadata *vnmd = (VideoNativeMetadata*)info-&gt;mCodecData-&gt;base(); err2 = mCodec-&gt;mOMX-&gt;updateGraphicBufferInMeta( mCodec-&gt;mNode, kPortIndexInput, new GraphicBuffer(vnmd-&gt;pBuffer, false /* keepOwnership */), bufferID); &#125; break;#endif default: err2 = ERROR_UNSUPPORTED; break; &#125; if (err2 == OK) &#123; err2 = mCodec-&gt;mOMX-&gt;emptyBuffer( mCodec-&gt;mNode, bufferID, 0, info-&gt;mCodecData-&gt;size(), flags, timeUs, info-&gt;mFenceFd); &#125; info-&gt;mFenceFd = -1; ...... info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT; if (!eos &amp;&amp; err == OK) &#123; getMoreInputDataIfPossible(); &#125; else &#123; ALOGV(\"[%s] Signalled EOS (%d) on the input port\", mCodec-&gt;mComponentName.c_str(), err); mCodec-&gt;mPortEOS[kPortIndexInput] = true; mCodec-&gt;mInputEOSResult = err; &#125; &#125; else if (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123; ...... info-&gt;checkReadFence(\"onInputBufferFilled\"); status_t err2 = mCodec-&gt;mOMX-&gt;emptyBuffer( mCodec-&gt;mNode, bufferID, 0, 0, OMX_BUFFERFLAG_EOS, 0, info-&gt;mFenceFd); info-&gt;mFenceFd = -1; ...... info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT; mCodec-&gt;mPortEOS[kPortIndexInput] = true; mCodec-&gt;mInputEOSResult = err; &#125; break; &#125; ...... &#125;&#125; P.S. 2ï¼šACodec::BaseState::onInputBufferFilled(â€¦)çš„è°ƒç”¨ï¼šå› ä¸ºå½“å‰ACodecåœ¨ExecutingStateï¼Œæ‰€ä»¥PortModeä¸ºRESUBMIT_BUFFERSï¼Œæ•…ä¼šè°ƒç”¨IOMXçš„emptyBuffer(â€¦)æ–¹æ³•ï¼Œç»è¿‡è¿›ç¨‹é—´é€šä¿¡è°ƒç”¨åˆ°OMX::emptyBuffer(â€¦)ï¼Œå¹¶æœ€ç»ˆè°ƒç”¨OMXNodeInstance::emptyBuffer(â€¦)ï¼Œå…¶ä¸­åˆä¼šè°ƒç”¨åˆ°å‡½æ•°OMXNodeInstance::emptyBuffer_l(â€¦)ï¼Œå…¶åˆ™ä¼šè°ƒç”¨OMX_EmptyThisBufferå®å¯¹OMXç»„ä»¶è¿›è¡Œç›¸å…³çš„æ“ä½œï¼ˆæ ¹æ®éœ€è¦é€‰æ‹©ç›¸åº”çš„è½¯è§£ç»„ä»¶æˆ–è€…ç¡¬è§£ç»„ä»¶ï¼‰ã€‚å¯¹äºè½¯è§£ç»„ä»¶SoftOMXComponent â—‹1ã€å…¶çš„æ„é€ å‡½æ•°çš„åˆå§‹åŒ–åˆ—è¡¨ä¸­æœ‰mComponent-&gt;EmptyThisBuffer = EmptyThisBufferWrapper;æ•…å®é™…ä¼šè°ƒç”¨å…¶EmptyThisBufferWrapper(â€¦)å‡½æ•°ï¼Œè€Œå…¶ä¸­è°ƒç”¨SoftOMXComponentçš„è™šå‡½æ•°emptyThisBufferã€‚ â—‹2ã€æ‰€ä»¥è°ƒç”¨å­ç±»çš„emptyThisBufferå³SimpleSoftOMXComponent::emptyThisBuffer(â€¦)äº§ç”ŸkWhatEmptyThisBufferæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­å®é™…çš„è§£ç å™¨å°±è¦è°ƒç”¨onQueueFilled(â€¦)å‡½æ•°ã€å®é™…ç»„ä»¶ç»§æ‰¿è‡ªSimpleSoftOMXComponentã€‘ â—‹3ã€æ¥ç€ä¼šè°ƒç”¨SoftOMXComponent::notifyEmptyBufferDone(â€¦)ä½¿ç”¨OMXçš„å›è°ƒæœºåˆ¶ï¼Œé—­ç¯å‘é€æ¶ˆæ¯åˆ°OMXå®¢æˆ·ç«¯ACodecã€‚ â—‹4ã€è°ƒç”¨åˆ°OMXNodeInstance::OnEmptyBufferDone(â€¦)ï¼Œå…¶åˆä¼šè°ƒç”¨OMX::OnEmptyBufferDone(â€¦)ï¼Œç„¶ååœ¨å…¶ä¸­ä¼šå‘é€omx_message::EMPTY_BUFFER_DONEæ¶ˆæ¯ï¼ŒACodecä¸­æ”¶åˆ°è¯¥æ¶ˆæ¯ã€CodecObserverä¸­å…ˆæ”¶åˆ°ï¼Œä½†åªè®¾ç½®æ¶ˆæ¯ã€‘è°ƒç”¨ACodec::BaseState::onOMXEmptyBufferDone(â€¦) â—‹5ã€åœ¨onOMXEmptyBufferDoneä¸­è·å–PortModeï¼Œä¸ºRESUBMIT_BUFFERSåˆ™ACodec::BaseState::postFillThisBuffer(â€¦)è¢«è°ƒç”¨ï¼Œä»è€Œåˆä»3ä¸­çš„postFillThisBufferå¼€å§‹å¾ªç¯æ‰§è¡Œç›¸å…³æ“ä½œä»¥å¤„ç†æ›´å¤šçš„è¾“å…¥ç¼“å†²ã€‚ 3.2ã€éŸ³è§†é¢‘è§£ç æ•°æ®å¤„ç†-fillBufferè¿˜æ˜¯è€æ ·å­ï¼Œå…ˆçœ‹çœ‹æ—¶åºå›¾ï¼Œç„¶åä¸€æ­¥æ­¥åˆ†æ 3.2.1ã€ACodec::ExecutingState::resume()12345678910111213141516171819202122232425262728293031323334353637[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]void ACodec::ExecutingState::resume() &#123; submitOutputBuffers(); for (size_t i = 0; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123; BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i); if (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123; postFillThisBuffer(info); &#125; &#125; mActive = true;&#125;void ACodec::ExecutingState::submitOutputBuffers() &#123; submitRegularOutputBuffers(); if (mCodec-&gt;storingMetadataInDecodedBuffers()) &#123; submitOutputMetaBuffers(); &#125;&#125;void ACodec::ExecutingState::submitRegularOutputBuffers() &#123; bool failed = false; for (size_t i = 0; i &lt; mCodec-&gt;mBuffers[kPortIndexOutput].size(); ++i) &#123; BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexOutput].editItemAt(i); if (mCodec-&gt;mNativeWindow != NULL) &#123; ...... &#125; else &#123; ...... &#125; ...... info-&gt;checkWriteFence(\"submitRegularOutputBuffers\"); status_t err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd); info-&gt;mFenceFd = -1; ...... info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT; &#125; ......&#125; 1ã€ACodec::ExecutingState::resume()å‡½æ•°ï¼Œåœ¨resume()ä¸­è°ƒç”¨ACodec::BaseState::postFillThisBuffer(â€¦)å‰ä¼šå…ˆè°ƒç”¨å‡½æ•°ACodec::ExecutingState::submitOutputBuffers()ï¼Œå³åœ¨è·å–è¾“å…¥æ•°æ®å‰ä¼šå…ˆæŠŠè¾“å‡ºç«¯çš„æ•°æ®æäº¤å‡ºå»ã€‚ 2ã€åœ¨submitOutputBuffers()ä¸­è°ƒç”¨ACodec::ExecutingState::submitRegularOutputBuffers()ï¼Œå…¶ä¸­åˆä¼šè°ƒç”¨åˆ°IOMXçš„fillBuffer (â€¦)æ–¹æ³•ï¼Œç»è¿‡è¿›ç¨‹é—´é€šä¿¡è°ƒç”¨åˆ°OMX:: fillBuffer (â€¦)ï¼Œå¹¶æœ€ç»ˆè°ƒç”¨OMXNodeInstance:: fillBuffer (â€¦)ï¼Œå…¶ä¸­åˆä¼šè°ƒç”¨åˆ°OMX_FillThisBufferå®å¯¹OMXç»„ä»¶è¿›è¡Œç›¸å…³çš„æ“ä½œï¼ˆåŒæ ·æ ¹æ®éœ€è¦é€‰æ‹©ç›¸åº”çš„è½¯è§£ç»„ä»¶æˆ–è€…ç¡¬è§£ç»„ä»¶ï¼‰ã€‚å¯¹äºè½¯è§£ç»„ä»¶SoftOMXComponentï¼šï¼ˆä¸‹é¢çš„æ“ä½œä¸emptyBufferæ—¶ç±»ä¼¼ï¼‰ â—‹1ã€åœ¨å…¶æ„é€ å‡½æ•°çš„åˆå§‹åŒ–åˆ—è¡¨ä¸­æœ‰mComponent-&gt;FillThisBuffer = FillThisBufferWrapper;æ‰€ä»¥å®é™…ä¼šè°ƒç”¨åˆ°å…¶FillThisBufferWrapper (â€¦)å‡½æ•°â—‹2ã€ç„¶åè°ƒç”¨SimpleSoftOMXComponent::fillThisBuffer(â€¦)äº§ç”ŸkWhatFillThisBufferæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­å®é™…çš„ç»„ä»¶å°±è¦è°ƒç”¨onQueueFilled(â€¦)å‡½æ•°ã€å®é™…ç»„ä»¶ç»§æ‰¿è‡ªSimpleSoftOMXComponentã€‘ â—‹3ã€æ¥ç€ä¼šè°ƒç”¨SoftOMXComponent::notifyFillBufferDone(â€¦)ä½¿ç”¨OMXçš„å›è°ƒæœºåˆ¶ï¼Œé—­ç¯å‘é€æ¶ˆæ¯åˆ°OMXå®¢æˆ·ç«¯ACodecã€‚â—‹4ä¹‹åè°ƒç”¨åˆ°OMXNodeInstance:: OnFillBufferDone (â€¦)å‡½æ•°ï¼Œå…¶åˆä¼šè°ƒç”¨OMX:: OnFillBufferDone (â€¦)ï¼Œç„¶ååœ¨å…¶ä¸­ä¼šå‘é€omx_message:: FILL_BUFFER_DONEæ¶ˆæ¯ï¼ŒACodecä¸­æ”¶åˆ°è¯¥æ¶ˆæ¯ã€CodecObserverä¸­å…ˆæ”¶åˆ°ï¼Œä½†åªè®¾ç½®æ¶ˆæ¯ã€‘è°ƒç”¨ACodec::BaseState:: onOMXFillBufferDone (â€¦)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]bool ACodec::BaseState::onOMXFillBufferDone( IOMX::buffer_id bufferID, size_t rangeOffset, size_t rangeLength, OMX_U32 flags, int64_t timeUs, int fenceFd) &#123; ALOGV(\"[%s] onOMXFillBufferDone %u time %\" PRId64 \" us, flags = 0x%08x\", mCodec-&gt;mComponentName.c_str(), bufferID, timeUs, flags); ssize_t index; status_t err= OK;#if TRACK_BUFFER_TIMING index = mCodec-&gt;mBufferStats.indexOfKey(timeUs); if (index &gt;= 0) &#123; ACodec::BufferStats *stats = &amp;mCodec-&gt;mBufferStats.editValueAt(index); stats-&gt;mFillBufferDoneTimeUs = ALooper::GetNowUs(); ALOGI(\"frame PTS %lld: %lld\", timeUs, stats-&gt;mFillBufferDoneTimeUs - stats-&gt;mEmptyBufferTimeUs); mCodec-&gt;mBufferStats.removeItemsAt(index); stats = NULL; &#125;#endif BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index); BufferInfo::Status status = BufferInfo::getSafeStatus(info); if (status != BufferInfo::OWNED_BY_COMPONENT) &#123; ALOGE(\"Wrong ownership in FBD: %s(%d) buffer #%u\", _asString(status), status, bufferID); mCodec-&gt;dumpBuffers(kPortIndexOutput); mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION); if (fenceFd &gt;= 0) &#123; ::close(fenceFd); &#125; return true; &#125; info-&gt;mDequeuedAt = ++mCodec-&gt;mDequeueCounter; info-&gt;mStatus = BufferInfo::OWNED_BY_US; if (info-&gt;mRenderInfo != NULL) &#123; // The fence for an emptied buffer must have signaled, but there still could be queued // or out-of-order dequeued buffers in the render queue prior to this buffer. Drop these, // as we will soon requeue this buffer to the surface. While in theory we could still keep // track of buffers that are requeued to the surface, it is better to add support to the // buffer-queue to notify us of released buffers and their fences (in the future). mCodec-&gt;notifyOfRenderedFrames(true /* dropIncomplete */); &#125; // byte buffers cannot take fences, so wait for any fence now if (mCodec-&gt;mNativeWindow == NULL) &#123; (void)mCodec-&gt;waitForFence(fenceFd, \"onOMXFillBufferDone\"); fenceFd = -1; &#125; info-&gt;setReadFence(fenceFd, \"onOMXFillBufferDone\"); PortMode mode = getPortMode(kPortIndexOutput); switch (mode) &#123; case KEEP_BUFFERS: break; case RESUBMIT_BUFFERS: &#123; if (rangeLength == 0 &amp;&amp; (!(flags &amp; OMX_BUFFERFLAG_EOS) || mCodec-&gt;mPortEOS[kPortIndexOutput])) &#123; ...... err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd); info-&gt;mFenceFd = -1; ...... info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT; break; &#125; sp&lt;AMessage&gt; reply = new AMessage(kWhatOutputBufferDrained, mCodec); if (mCodec-&gt;mOutputFormat != mCodec-&gt;mLastOutputFormat &amp;&amp; rangeLength &gt; 0) &#123; // pretend that output format has changed on the first frame (we used to do this) if (mCodec-&gt;mBaseOutputFormat == mCodec-&gt;mOutputFormat) &#123; mCodec-&gt;onOutputFormatChanged(mCodec-&gt;mOutputFormat); &#125; mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply); mCodec-&gt;sendFormatChange(); &#125; else if (rangeLength &gt; 0 &amp;&amp; mCodec-&gt;mNativeWindow != NULL) &#123; // If potentially rendering onto a surface, always save key format data (crop &amp; // data space) so that we can set it if and once the buffer is rendered. mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply); &#125; if (mCodec-&gt;usingMetadataOnEncoderOutput()) &#123; native_handle_t *handle = NULL; VideoNativeHandleMetadata &amp;nativeMeta = *(VideoNativeHandleMetadata *)info-&gt;mData-&gt;data(); if (info-&gt;mData-&gt;size() &gt;= sizeof(nativeMeta) &amp;&amp; nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) &#123;#ifdef OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS // handle is only valid on 32-bit/mediaserver process handle = NULL;#else handle = (native_handle_t *)nativeMeta.pHandle;#endif &#125; info-&gt;mData-&gt;meta()-&gt;setPointer(\"handle\", handle); info-&gt;mData-&gt;meta()-&gt;setInt32(\"rangeOffset\", rangeOffset); info-&gt;mData-&gt;meta()-&gt;setInt32(\"rangeLength\", rangeLength); &#125; else if (info-&gt;mData == info-&gt;mCodecData) &#123; info-&gt;mData-&gt;setRange(rangeOffset, rangeLength); &#125; else &#123; info-&gt;mCodecData-&gt;setRange(rangeOffset, rangeLength); // in this case we know that mConverter is not null status_t err = mCodec-&gt;mConverter[kPortIndexOutput]-&gt;convert( info-&gt;mCodecData, info-&gt;mData); if (err != OK) &#123; mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err)); return true; &#125; &#125; if (mCodec-&gt;mSkipCutBuffer != NULL) &#123; mCodec-&gt;mSkipCutBuffer-&gt;submit(info-&gt;mData); &#125; info-&gt;mData-&gt;meta()-&gt;setInt64(\"timeUs\", timeUs); sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup(); notify-&gt;setInt32(\"what\", CodecBase::kWhatDrainThisBuffer); notify-&gt;setInt32(\"buffer-id\", info-&gt;mBufferID); notify-&gt;setBuffer(\"buffer\", info-&gt;mData); notify-&gt;setInt32(\"flags\", flags); reply-&gt;setInt32(\"buffer-id\", info-&gt;mBufferID); notify-&gt;setMessage(\"reply\", reply); notify-&gt;post(); info-&gt;mStatus = BufferInfo::OWNED_BY_DOWNSTREAM; if (flags &amp; OMX_BUFFERFLAG_EOS) &#123; ALOGV(\"[%s] saw output EOS\", mCodec-&gt;mComponentName.c_str()); sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup(); notify-&gt;setInt32(\"what\", CodecBase::kWhatEOS); notify-&gt;setInt32(\"err\", mCodec-&gt;mInputEOSResult); notify-&gt;post(); mCodec-&gt;mPortEOS[kPortIndexOutput] = true; &#125; break; &#125; case FREE_BUFFERS: err = mCodec-&gt;freeBuffer(kPortIndexOutput, index); if (err != OK) &#123; mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err)); return true; &#125; break; default: ALOGE(\"Invalid port mode: %d\", mode); return false; &#125; return true;&#125; â—‹5ã€åœ¨onOMXFillBufferDoneä¸­è·å–PortModeï¼Œä¸ºRESUBMIT_BUFFERSåˆ™é¦–å…ˆå¦‚æœéœ€è¦ç»§ç»­è°ƒç”¨åˆ°IOMXçš„fillBuffer (â€¦)å¡«å……è¾“å‡ºç¼“å†²é‡å¤åšç›¸å…³æ“ä½œï¼Œæ¥ç€ACodecåˆä¼šç”Ÿæˆä¸€ä¸ªkWhatOutputBufferDrainedæ¶ˆæ¯å­˜åœ¨replyä¸­ï¼Œä½œä¸ºkWhatDrainThisBufferæ¶ˆæ¯çš„è¿”å›æ¶ˆæ¯ã€notify-&gt;setMessage(â€œreplyâ€, reply);ã€‘ï¼Œç„¶åå‘MediaCodecå‘é€æ¶ˆæ¯kWhatDrainThisBufferï¼Œæ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨å‡½æ•°MediaCodec::onOutputBufferAvailable()é€šçŸ¥NuPlayer::Decoderæœ‰å¯ç”¨çš„output bufferï¼Œå…¶ä¸­ä¼šè®¾ç½®æ¶ˆæ¯çš„callbackIDä¸ºCB_OUTPUT_AVAILABLEï¼ŒåŒæ—¶è®¾ç½®indexï¼Œæ¥ç€NuPlayer::Decoderæ¥æ”¶åˆ°è¯¥CB_OUTPUT_AVAILABLEæ¶ˆæ¯ï¼Œåœ¨æ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨NuPlayer::Decoder::handleAnOutputBuffer(â€¦)ï¼Œåœ¨å…¶ä¸­ä¼šè¿›è¡Œå¦‚ä¸‹å¤„ç†ï¼š 123456789101112131415161718192021222324252627282930313233343536[-&gt;\\frameworks\\av\\media\\libstagefright\\MediaCodec.cpp]void MediaCodec::onOutputBufferAvailable() &#123; int32_t index; while ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= 0) &#123; const sp&lt;ABuffer&gt; &amp;buffer = mPortBuffers[kPortIndexOutput].itemAt(index).mData; sp&lt;AMessage&gt; msg = mCallback-&gt;dup(); msg-&gt;setInt32(\"callbackID\", CB_OUTPUT_AVAILABLE); msg-&gt;setInt32(\"index\", index); msg-&gt;setSize(\"offset\", buffer-&gt;offset()); msg-&gt;setSize(\"size\", buffer-&gt;size()); int64_t timeUs; CHECK(buffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;timeUs)); msg-&gt;setInt64(\"timeUs\", timeUs); int32_t omxFlags; CHECK(buffer-&gt;meta()-&gt;findInt32(\"omxFlags\", &amp;omxFlags)); uint32_t flags = 0; if (omxFlags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123; flags |= BUFFER_FLAG_SYNCFRAME; &#125; if (omxFlags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123; flags |= BUFFER_FLAG_CODECCONFIG; &#125; if (omxFlags &amp; OMX_BUFFERFLAG_EOS) &#123; flags |= BUFFER_FLAG_EOS; &#125; msg-&gt;setInt32(\"flags\", flags); msg-&gt;post(); &#125;&#125; ï¼ˆå››ï¼‰ã€å¤šåª’ä½“æ–‡ä»¶ - éŸ³è§†é¢‘æ¸²æŸ“ï¼ˆRendererï¼‰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoder.cpp]bool NuPlayer::Decoder::handleAnOutputBuffer( size_t index, size_t offset, size_t size, int64_t timeUs, int32_t flags) &#123; sp&lt;ABuffer&gt; buffer; mCodec-&gt;getOutputBuffer(index, &amp;buffer); if (index &gt;= mOutputBuffers.size()) &#123; for (size_t i = mOutputBuffers.size(); i &lt;= index; ++i) &#123; mOutputBuffers.add(); &#125; &#125; mOutputBuffers.editItemAt(index) = buffer; buffer-&gt;setRange(offset, size); buffer-&gt;meta()-&gt;clear(); buffer-&gt;meta()-&gt;setInt64(\"timeUs\", timeUs); bool eos = flags &amp; MediaCodec::BUFFER_FLAG_EOS; // we do not expect CODECCONFIG or SYNCFRAME for decoder sp&lt;AMessage&gt; reply = new AMessage(kWhatRenderBuffer, this); reply-&gt;setSize(\"buffer-ix\", index); reply-&gt;setInt32(\"generation\", mBufferGeneration); if (eos) &#123; buffer-&gt;meta()-&gt;setInt32(\"eos\", true); reply-&gt;setInt32(\"eos\", true); &#125; else if (mSkipRenderingUntilMediaTimeUs &gt;= 0) &#123; if (timeUs &lt; mSkipRenderingUntilMediaTimeUs) &#123; reply-&gt;post(); return true; &#125; mSkipRenderingUntilMediaTimeUs = -1; &#125; mNumFramesTotal += !mIsAudio; // wait until 1st frame comes out to signal resume complete notifyResumeCompleteIfNecessary(); if (mRenderer != NULL) &#123; // send the buffer to renderer. mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply); if (eos &amp;&amp; !isDiscontinuityPending()) &#123; mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM); &#125; &#125; return true;&#125; a. åœ¨kWhatRenderBufferæ¶ˆæ¯å¤„ç†ä¸­ä¼šè°ƒç”¨NuPlayer::Decoder::onRenderBuffer(â€¦)ï¼Œåœ¨å…¶ä¸­æ ¹æ®æƒ…å†µè°ƒç”¨å‡½æ•°MediaCodec::renderOutputBufferAndRelease(..)æ¸²æŸ“å¹¶é‡Šæ”¾ï¼Œæˆ–è€…è°ƒç”¨MediaCodec::releaseOutputBuffer(â€¦)ä¸æ¸²æŸ“ç›´æ¥é‡Šæ”¾ï¼Œä¸¤ä¸­æƒ…å†µéƒ½ä¼šäº§ç”ŸkWhatReleaseOutputBufferæ¶ˆæ¯ï¼Œè¯¥æ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨å‡½æ•°MediaCodec::onReleaseOutputBuffer(â€¦)ï¼Œå…¶ä¸­åˆ¤æ–­è‹¥SoftRendereréç©ºåˆ™è¿›è¡Œè½¯ä»¶æ¸²æŸ“ï¼Œä¸ç„¶å°±ä¼šé€šè¿‡â—‹5ä¸­çš„replyè®©ACodecå»ç¡¬ä»¶æ¸²æŸ“ï¼Œåœ¨kWhatOutputBufferDrainedæ¶ˆæ¯å¤„ç†å°±ä¼šä¸­è°ƒç”¨åˆ°å‡½æ•°ACodec::BaseState::onOutputBufferDrained(â€¦)è¿›è¡ŒçœŸæ­£çš„ç¡¬ä»¶æ¸²æŸ“ã€‚ 12345678910111213141516171819202122232425262728[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerDecoder.cpp]void NuPlayer::Decoder::onRenderBuffer(const sp&lt;AMessage&gt; &amp;msg) &#123; status_t err; int32_t render; size_t bufferIx; int32_t eos; CHECK(msg-&gt;findSize(\"buffer-ix\", &amp;bufferIx)); if (!mIsAudio) &#123; int64_t timeUs; sp&lt;ABuffer&gt; buffer = mOutputBuffers[bufferIx]; buffer-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;timeUs); if (mCCDecoder != NULL &amp;&amp; mCCDecoder-&gt;isSelected()) &#123; mCCDecoder-&gt;display(timeUs); &#125; &#125; if (msg-&gt;findInt32(\"render\", &amp;render) &amp;&amp; render) &#123; int64_t timestampNs; CHECK(msg-&gt;findInt64(\"timestampNs\", &amp;timestampNs)); err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs); &#125; else &#123; mNumOutputFramesDropped += !mIsAudio; err = mCodec-&gt;releaseOutputBuffer(bufferIx); &#125; ......&#125; b. MediaCodec:: getOutputBuffer (â€¦) -&gt; MediaCodec::getBufferAndFormat(â€¦)è·å–è¯¥bufferçš„ä¿¡æ¯c. è‹¥Rendereréç©ºåˆ™ä¼šè°ƒç”¨NuPlayer::Renderer::queueBuffer(â€¦)è¿›è¡ŒRendererçš„ç›¸å…³å¤„ç†åŒæ—¶æ¶ˆè€—äº§ç”Ÿçš„kWhatRenderBufferæ¶ˆæ¯ã€‚queueBuffer()ä¼šäº§ç”ŸkWhatQueueBufferæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­ä¼šè°ƒç”¨å‡½æ•°NuPlayer::Renderer::onQueueBuffer(â€¦) â€“&gt; NuPlayer::Renderer::postDrainVideoQueue() ã€å¦å¤–æœ‰audioçš„ç›¸å…³å¤„ç†ã€‘ï¼Œå…¶ä¸­äº§ç”ŸkWhatDrainVideoQueueæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­è°ƒç”¨å…ˆNuPlayer::Renderer::onDrainVideoQueue()åœ¨VideoQueueä¸­å–ç›¸å…³æ•°æ®ï¼Œå†è°ƒç”¨NuPlayer::Renderer::postDrainVideoQueue()å¾ªç¯å–videoæ•°æ®ï¼Œæ¥ç€è¿˜ä¼šå‘é€kWhatRenderBufferæ¶ˆæ¯ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayerRenderer.cpp]void NuPlayer::Renderer::onQueueBuffer(const sp&lt;AMessage&gt; &amp;msg) &#123; int32_t audio; if (audio) &#123; mHasAudio = true; &#125; else &#123; mHasVideo = true; &#125; if (mHasVideo) &#123; if (mVideoScheduler == NULL) &#123; mVideoScheduler = new VideoFrameScheduler(); mVideoScheduler-&gt;init(); &#125; &#125; sp&lt;ABuffer&gt; buffer; CHECK(msg-&gt;findBuffer(\"buffer\", &amp;buffer)); sp&lt;AMessage&gt; notifyConsumed; CHECK(msg-&gt;findMessage(\"notifyConsumed\", &amp;notifyConsumed)); QueueEntry entry; entry.mBuffer = buffer; entry.mNotifyConsumed = notifyConsumed; entry.mOffset = 0; entry.mFinalResult = OK; entry.mBufferOrdinal = ++mTotalBuffersQueued; if (audio) &#123; Mutex::Autolock autoLock(mLock); mAudioQueue.push_back(entry); postDrainAudioQueue_l(); &#125; else &#123; mVideoQueue.push_back(entry); postDrainVideoQueue(); &#125; Mutex::Autolock autoLock(mLock); if (!mSyncQueues || mAudioQueue.empty() || mVideoQueue.empty()) &#123; return; &#125; sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer; sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer; if (firstAudioBuffer == NULL || firstVideoBuffer == NULL) &#123; syncQueuesDone_l(); return; &#125; int64_t firstAudioTimeUs; int64_t firstVideoTimeUs; int64_t diff = firstVideoTimeUs - firstAudioTimeUs; if (diff &gt; 100000ll) &#123; (*mAudioQueue.begin()).mNotifyConsumed-&gt;post(); mAudioQueue.erase(mAudioQueue.begin()); return; &#125; syncQueuesDone_l();&#125; ï¼ˆäº”ï¼‰ã€è§†é¢‘è§£ç è¾“å‡ºåˆ°SurfaceFlinger123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]void ACodec::BaseState::onOutputBufferDrained(const sp&lt;AMessage&gt; &amp;msg) &#123; IOMX::buffer_id bufferID; CHECK(msg-&gt;findInt32(\"buffer-id\", (int32_t*)&amp;bufferID)); ssize_t index; BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index); BufferInfo::Status status = BufferInfo::getSafeStatus(info); if (status != BufferInfo::OWNED_BY_DOWNSTREAM) &#123; ALOGE(\"Wrong ownership in OBD: %s(%d) buffer #%u\", _asString(status), status, bufferID); mCodec-&gt;dumpBuffers(kPortIndexOutput); mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION); return; &#125; android_native_rect_t crop; if (msg-&gt;findRect(\"crop\", &amp;crop.left, &amp;crop.top, &amp;crop.right, &amp;crop.bottom) &amp;&amp; memcmp(&amp;crop, &amp;mCodec-&gt;mLastNativeWindowCrop, sizeof(crop)) != 0) &#123; mCodec-&gt;mLastNativeWindowCrop = crop; status_t err = native_window_set_crop(mCodec-&gt;mNativeWindow.get(), &amp;crop); ALOGW_IF(err != NO_ERROR, \"failed to set crop: %d\", err); &#125; int32_t dataSpace; if (msg-&gt;findInt32(\"dataspace\", &amp;dataSpace) &amp;&amp; dataSpace != mCodec-&gt;mLastNativeWindowDataSpace) &#123; status_t err = native_window_set_buffers_data_space( mCodec-&gt;mNativeWindow.get(), (android_dataspace)dataSpace); mCodec-&gt;mLastNativeWindowDataSpace = dataSpace; ALOGW_IF(err != NO_ERROR, \"failed to set dataspace: %d\", err); &#125; int32_t render; if (mCodec-&gt;mNativeWindow != NULL &amp;&amp; msg-&gt;findInt32(\"render\", &amp;render) &amp;&amp; render != 0 &amp;&amp; info-&gt;mData != NULL &amp;&amp; info-&gt;mData-&gt;size() != 0) &#123; ATRACE_NAME(\"render\"); // The client wants this buffer to be rendered. // save buffers sent to the surface so we can get render time when they return int64_t mediaTimeUs = -1; info-&gt;mData-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;mediaTimeUs); if (mediaTimeUs &gt;= 0) &#123; mCodec-&gt;mRenderTracker.onFrameQueued( mediaTimeUs, info-&gt;mGraphicBuffer, new Fence(::dup(info-&gt;mFenceFd))); &#125; int64_t timestampNs = 0; if (!msg-&gt;findInt64(\"timestampNs\", &amp;timestampNs)) &#123; // use media timestamp if client did not request a specific render timestamp if (info-&gt;mData-&gt;meta()-&gt;findInt64(\"timeUs\", &amp;timestampNs)) &#123; ALOGV(\"using buffer PTS of %lld\", (long long)timestampNs); timestampNs *= 1000; &#125; &#125; status_t err; err = native_window_set_buffers_timestamp(mCodec-&gt;mNativeWindow.get(), timestampNs); ALOGW_IF(err != NO_ERROR, \"failed to set buffer timestamp: %d\", err); info-&gt;checkReadFence(\"onOutputBufferDrained before queueBuffer\"); err = mCodec-&gt;mNativeWindow-&gt;queueBuffer( mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd); info-&gt;mFenceFd = -1; if (err == OK) &#123; info-&gt;mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW; &#125; else &#123; ALOGE(\"queueBuffer failed in onOutputBufferDrained: %d\", err); mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err)); info-&gt;mStatus = BufferInfo::OWNED_BY_US; // keeping read fence as write fence to avoid clobbering info-&gt;mIsReadFence = false; &#125; &#125; else &#123; if (mCodec-&gt;mNativeWindow != NULL &amp;&amp; (info-&gt;mData == NULL || info-&gt;mData-&gt;size() != 0)) &#123; // move read fence into write fence to avoid clobbering info-&gt;mIsReadFence = false; ATRACE_NAME(\"frame-drop\"); &#125; info-&gt;mStatus = BufferInfo::OWNED_BY_US; &#125; ......&#125; 5.1ã€Surfaceflinger è§†é¢‘è§£ç ç¼“å­˜ç”³è¯·å‰é¢2.3.6ã€MediaCodec-&gt;start()åˆ†æè¿‡ï¼šäº§ç”ŸkWhatStartæ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†ä¸­å…ˆå°†MediaCodecçŠ¶æ€è®¾ä¸ºSTARTINGï¼Œç„¶åè°ƒç”¨ACodec::initiateStart()äº§ç”ŸkWhatStartæ¶ˆæ¯ï¼Œåœ¨å…¶æ¶ˆæ¯å¤„ç†ä¸­åˆè°ƒç”¨ACodec::LoadedState::onStart()ï¼Œç„¶ååœ¨å…¶ä¸­é¦–å…ˆå‘IOMXå‘é€çŠ¶æ€è½¬æ¢å‘½ä»¤ï¼Œç»è¿‡OMXNodeInstanceæœ€ç»ˆå¯¹å°†OMXç»„ä»¶çŠ¶æ€è½¬æ¢æˆIdleï¼ˆè½¬æ¢å®Œæˆæ—¶OMXä¼šå‘é€OMX_EventCmdCompleteäº‹ä»¶ï¼‰ï¼Œæ¥ç€å¯¹ACodecè¿›è¡ŒchangeStateè‡³LoadedToIdleStateã€‚è€Œåœ¨changeStateè¿‡ç¨‹ä¸­ä¼šè°ƒç”¨ACodec::LoadedToIdleState::stateEntered() =&gt; ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(â€¦)ï¼Œå…¶ä¸­ä¼šä¸ºOMXç»„ä»¶ç«¯å£åˆ†é…ç¼“å†²ï¼Œå¹¶å‘MediaCodecå‘é€æ¶ˆæ¯kWhatBuffersAllocatedï¼Œæ¶ˆæ¯å¤„ç†ä¸­å°†MediaCodecçŠ¶æ€è®¾ä¸ºSTARTEDè€Œè‹¥allocateBufferså¤±è´¥åˆ™ç”±IOMXç»OMXNodeInstanceå°†OMXç»„ä»¶è½¬æ¢å›LoadedçŠ¶æ€ï¼ŒåŒæ—¶æŠŠACodecçŠ¶æ€è½¬æ¢å›LoadedState12345678910111213141516171819202122232425[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]//ä½¿ç”¨surfaceæ¸²æŸ“ï¼Œä¸ºè¾“å‡ºåˆ†é…å›¾å½¢ç¼“å­˜GraphicBuffer status_t ACodec::LoadedToIdleState::allocateBuffers() &#123; status_t err = mCodec-&gt;allocateBuffersOnPort(kPortIndexInput); if (err != OK) &#123; return err; &#125; return mCodec-&gt;allocateBuffersOnPort(kPortIndexOutput);&#125;status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) &#123; CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput); CHECK(mDealer[portIndex] == NULL); CHECK(mBuffers[portIndex].isEmpty()); status_t err; if (mNativeWindow != NULL &amp;&amp; portIndex == kPortIndexOutput) &#123; if (storingMetadataInDecodedBuffers()) &#123; err = allocateOutputMetadataBuffers(); &#125; else &#123; err = allocateOutputBuffersFromNativeWindow(); &#125; &#125; ......&#125; 5.1.1ã€allocateOutputBuffersFromNativeWindow()çš„å®ç°12345678910111213141516171819202122232425262728293031323334353637383940414243[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]status_t ACodec::allocateOutputBuffersFromNativeWindow() &#123; OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers; status_t err = configureOutputBuffersFromNativeWindow( &amp;bufferCount, &amp;bufferSize, &amp;minUndequeuedBuffers, true /* preregister */); if (err != 0) return err; mNumUndequeuedBuffers = minUndequeuedBuffers; if (!storingMetadataInDecodedBuffers()) &#123; static_cast&lt;Surface*&gt;(mNativeWindow.get()) -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(true); &#125; ...... // Dequeue buffers and send them to OMX for (OMX_U32 i = 0; i &lt; bufferCount; i++) &#123; ANativeWindowBuffer *buf; int fenceFd; err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd); ...... sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer(buf, false)); BufferInfo info; info.mStatus = BufferInfo::OWNED_BY_US; info.mFenceFd = fenceFd; info.mIsReadFence = false; info.mRenderInfo = NULL; info.mData = new ABuffer(NULL /* data */, bufferSize /* capacity */); info.mCodecData = info.mData; info.mGraphicBuffer = graphicBuffer; mBuffers[kPortIndexOutput].push(info); IOMX::buffer_id bufferId; err = mOMX-&gt;useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer, &amp;bufferId); ...... mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId; ...... &#125; ...... return err;&#125; 5.1.1.1ã€é¦–å…ˆä¸ºè§†é¢‘ç¼–ç è¾“å‡ºå‡†å¤‡Surfaceæ­¤å¤„é€šè¿‡Binderé€šä¿¡ä½¿ç”¨IGraphicBufferProducerè¯·æ±‚åˆ†é…ä¸€ä¸ªNative Surface12static_cast&lt;Surface*&gt;(mNativeWindow.get()) -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(true); 5.1.1.2ã€Surface-&gt;dequeueBufferä¸ºSurfaceåˆ†é…Bufferï¼Œæä¾›ç»™è§†é¢‘è§£ç åæ•°æ®ä½¿ç”¨12345678[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]status_t ACodec::allocateOutputBuffersFromNativeWindow() &#123; for (OMX_U32 i = 0; i &lt; bufferCount; i++) &#123; ANativeWindowBuffer *buf; int fenceFd; err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd); ......&#125; 5.2ã€Surface-&gt;queueBuffer()å¾…è§†é¢‘è§£ç åï¼Œä½¿ç”¨queueBuffer()äº¤ç»™SurfaceFlingeræ¸²æŸ“ï¼Œå°±å¯ä»¥åœ¨å±å¹•ä¸Šçœ‹åˆ°è§†é¢‘ç”»é¢äº†ã€‚123456[-&gt;\\frameworks\\av\\media\\libstagefright\\ACodec.cpp]void ACodec::BaseState::onOutputBufferDrained(const sp&lt;AMessage&gt; &amp;msg) &#123; err = mCodec-&gt;mNativeWindow-&gt;queueBuffer( mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd); ...&#125; å…³äºSurfaceFlingerçš„çŸ¥è¯†è¯·å‚è€ƒï¼šã€Android 7.1.2 (Android N) Android Graphics ç³»ç»Ÿåˆ†æã€‘ ï¼ˆ Í¡Â° ÍœÊ– Í¡Â°ï¼‰ã€ï¼ˆà²¡Ï‰à²¡ï¼‰ç´¯~~~ï¼Œæœ‰æ—¶é—´å†ç»§ç»­Todoçš„åˆ†æå§ï¼Œ(à¹‘ä¹›â—¡ä¹›à¹‘) ï¼ï¼ï¼Todoï¼šAndroid OpenMaxæœºåˆ¶ å®ç°åˆ†æTodoï¼šAndroid éŸ³è§†é¢‘åŒæ­¥æœºåˆ¶ æºç åˆ†æTodoï¼šAndroid éŸ³è§†é¢‘å½•åˆ¶ï¼ˆRecoderï¼‰ã€ç¼–ç ï¼ˆEncodeï¼‰ã€æ··åˆï¼ˆMediaMuxerï¼‰æºç åˆ†æ ï¼ˆå…­ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroid NuPlayeræ’­æ”¾æ¡†æ¶ ä¸“æ ï¼šMultiMediaæ¡†æ¶æ€»ç»“(åŸºäº6.0æºç ) - CSDNåšå®¢Androidå¤šåª’ä½“å¼€å‘-å½’æ¡£ | April is your lieAndroid-7.0-Nuplayeræ¦‚è¿° - CSDNåšå®¢Android-7.0-MediaPlayerçŠ¶æ€æœº - CSDNåšå®¢Android-7.0-Nuplayer-å¯åŠ¨æµç¨‹ - CSDNåšå®¢YUV - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦Android Media Player æ¡†æ¶åˆ†æ-Nuplayerï¼ˆ1ï¼‰ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-AHandler AMessage ALooper - CSDNåšå®¢Android 4.2.2 stagefrightæ¶æ„ - CSDNåšå®¢android4.2.2çš„stagefrightæ¶æ„ä¸‹åŸºäºSurfaceFlingerçš„è§†é¢‘è§£ç è¾“å‡ºç¼“å­˜åˆ›å»ºæœºåˆ¶ - CSDNåšå®¢husanlim çš„ä¸“æ  å‚è€ƒ - CSDNåšå®¢android ACodec MediaCodec NuPlayer flow - CSDNåšå®¢android MediaCodec ACodec - CSDNåšå®¢ffmpegå¼€å‘ä¹‹æ—…(1)-(7)ï¼ˆæ€»å…±ä¸ƒç¯‡ï¼‰æ·±å…¥ç†è§£AndroidéŸ³è§†é¢‘åŒæ­¥æœºåˆ¶ï¼ˆæ€»å…±äº”ç¯‡ï¼‰Androidç¡¬ç¼–ç â€”â€”éŸ³é¢‘ç¼–ç ã€è§†é¢‘ç¼–ç åŠéŸ³è§†é¢‘æ··åˆ","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android Video Systemï¼ˆ1ï¼‰ï¼šVideo System(è§†é¢‘ç³»ç»Ÿ)æ¡†æ¶åˆ†æ","slug":"Android Video Systemï¼ˆ1ï¼‰ï¼šVideo System[è§†é¢‘ç³»ç»Ÿ]æ¡†æ¶åˆ†æ","date":"2018-05-31T16:00:00.000Z","updated":"2018-05-17T16:21:51.537Z","comments":true,"path":"2018/06/01/Android Video Systemï¼ˆ1ï¼‰ï¼šVideo System[è§†é¢‘ç³»ç»Ÿ]æ¡†æ¶åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/06/01/Android Video Systemï¼ˆ1ï¼‰ï¼šVideo System[è§†é¢‘ç³»ç»Ÿ]æ¡†æ¶åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Android NuPlayeræ’­æ”¾æ¡†æ¶ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - android ACodec MediaCodec NuPlayer flowã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆæ–‡ç« åŸºäº Kernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) â˜¯ V4l2 æ¡†æ¶ä»£ç â˜¯ kernel/drivers/media/v4l2-core/ï¼ˆæ–‡ä»¶å‰ç¼€ä¸º videobuf2ï¼‰ â˜¯ MSM è§†é¢‘é©±åŠ¨ç¨‹åºæ–‡ä»¶â˜¯ kernel/drivers/media/platform/msm/vidc/ â˜¯ è®¾å¤‡æ ‘â˜¯ /kernel/arch/arm/boot/dts/qcomï¼ˆVenus çš„å¯„å­˜å™¨åŸºå€ï¼Œæ—¶é’Ÿé¢‘ç‡ï¼‰ â˜¯ Stagefrightã€libmediaã€libmediaplayerserviceã€mediaserverâ˜¯ /frameworks/av/media/ â˜¯ OMXâ˜¯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/ â˜¯ OMX æ ¸å¿ƒâ˜¯ /hardware/qcom/media/mm-core â˜¯ è½¯ä»¶ç¼–è§£ç å™¨è·¯å¾„â˜¯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)â†’ è§£ç å™¨ä»£ç â˜¯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) â†’ ç¼–ç å™¨ä»£ç  (ä¸€)ã€Android Video OverviewåŸºäº OpenMAX çš„è§†é¢‘è§£ç  â€“ æ•°æ®æµ YUVï¼Œæ˜¯ä¸€ç§é¢œè‰²ç¼–ç æ–¹æ³•ã€‚å¸¸ä½¿ç”¨åœ¨å„ä¸ªè§†é¢‘å¤„ç†ç»„ä»¶ä¸­ã€‚ YUVåœ¨å¯¹ç…§ç‰‡æˆ–è§†é¢‘ç¼–ç æ—¶ï¼Œè€ƒè™‘åˆ°äººç±»çš„æ„ŸçŸ¥èƒ½åŠ›ï¼Œå…è®¸é™ä½è‰²åº¦çš„å¸¦å®½ã€‚YUVVPUï¼ŒVideo processing unit åŸºäº OpenMAX çš„è§†é¢‘ç¼–ç  â€“ æ•°æ®æµ è§†é¢‘æ¡†æ¶ï¼š ç»„ä»¶æè¿°ï¼š æ€»ç»“ï¼š ä»è§†é¢‘æ¡†æ¶å¯ä»¥äº†è§£åˆ°ã€‚è§†é¢‘æ–‡ä»¶å…ˆç»Stagefrightä¼ åˆ°OMX decoderè§£ç ï¼ˆè½¯è§£æˆ–ç¡¬è§£ï¼‰ã€OMX decoderå°†è§£ç åçš„YUVæ•°æ®å›ä¼ åˆ°Stagefrightï¼Œä¸æ–­å¾ªç¯æ’­æ”¾åŒæ—¶ç»ç”±SurfaceFlingeræ¸²æŸ“åˆ°LCDå±å¹•ä¸Šã€‚ (äºŒ)ã€Android MediaPlayer &amp; Nuplayer æ¡†æ¶åˆ†æ2.1ã€MediaPlayerAndroidåœ¨Javaå±‚ä¸­æä¾›äº†ä¸€ä¸ªMediaPlayerçš„ç±»æ¥ä½œä¸ºæ’­æ”¾åª’ä½“èµ„æºçš„æ¥å£ï¼Œåœ¨ä½¿ç”¨ä¸­æˆ‘ä»¬é€šå¸¸ä¼šç¼–å†™ä»¥ä¸‹çš„ä»£ç ï¼š 12345678910mMediaPlayer = new MediaPlayer();mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+\"/test_video.mp4\");mMediaPlayer.setDisplay(...);mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mMediaPlayer.prepareAsync();mMediaPlayer.start();mediaPlayer.pause(); mediaPlayer.stop();mediaPlayer.reset();mediaPlayer.release(); é€šå¸¸MediaPlayerçš„è°ƒç”¨é€»è¾‘æ˜¯ï¼Œæ„é€ å‡½æ•°-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; ææ„å‡½æ•°ï¼ŒæŒ‰ç…§å®é™…éœ€æ±‚è¿˜ä¼šè°ƒç”¨pauseã€isPlayingã€getDurationã€getCurrentPositionã€setLoopingã€seekToç­‰æ–¹æ³•ã€‚ 2.1.1ã€MediaPlayerçŠ¶æ€å›¾: â˜¯ IdleçŠ¶æ€è°ƒç”¨newæˆ–reset()æ–¹æ³•åˆ›å»ºMediaPlayeråè¿›å…¥ç©ºé—²â˜¯ EndçŠ¶æ€è°ƒç”¨release()åå°±ç»“æŸâ˜¯ ErrorçŠ¶æ€æ’­æ”¾æ§åˆ¶æ“ä½œå‡ºé”™æˆ–æ— æ•ˆçŠ¶æ€ä¸‹è°ƒç”¨æ’­æ”¾æ§åˆ¶æ“ä½œâ˜¯ InitializedçŠ¶æ€ è°ƒç”¨setDataSourceä¹‹åå®Œæˆåˆå§‹åŒ–â˜¯ PreparedçŠ¶æ€åŒæ­¥prepare()æˆ–å¼‚æ­¥prepareAsync()å®Œæˆå‡†å¤‡â˜¯ PreparingçŠ¶æ€æ˜¯ä¸€ç§ç¬æ—¶çŠ¶æ€ï¼Œè°ƒç”¨prepareAsync()æ—¶ä¼šå…ˆè¿›å…¥æ­¤çŠ¶æ€â˜¯ Started çŠ¶æ€è¦å¼€å§‹æ’­æ”¾å¿…é¡»è°ƒç”¨start()â˜¯ Paused çŠ¶æ€è°ƒç”¨pause()å¹¶æˆåŠŸè¿”å›åæ’­æ”¾å¯ä»¥è¢«æš‚åœâ˜¯ StoppedçŠ¶æ€è°ƒç”¨stop()ä¼šåœæ­¢æ’­æ”¾â˜¯ PlaybackCompletedçŠ¶æ€å½“æ’­æ”¾åˆ°è¾¾æµæœ«ç«¯æ—¶ï¼Œæ’­æ”¾å®Œæˆ 2.1.2ã€MediaPlayerå’ŒMediaPlayerServicemediaserver å¯åŠ¨åä¼šæŠŠmediaç›¸å…³ä¸€äº›æœåŠ¡æ·»åŠ åˆ°servicemanagerä¸­ï¼Œå…¶ä¸­å°±æœ‰mediaPlayerServiceã€‚è¿™æ ·åº”ç”¨å¯åŠ¨å‰ï¼Œç³»ç»Ÿå°±æœ‰äº†mediaPlayerServiceè¿™ä¸ªæœåŠ¡ç¨‹åºã€‚ 1[-&gt;\\frameworks\\av\\media\\mediaserver\\main_mediaserver.cpp] 2.1.3ã€åˆ›å»ºMediaPlayerâ˜¯ Javaåº”ç”¨ç¨‹åºä¸­åˆ›å»ºMediaPlayerå¯¹è±¡MediaPlayer mediaPlayer = new MediaPlayer();â˜¯ MediaPlayerçš„æ„é€ å‡½æ•°ä¸­æ¯”è¾ƒé‡è¦çš„å°±æ˜¯æœ¬åœ°çš„nativeå‡½æ•°ï¼šnative_setup()å…¶å¯¹åº”çš„JNIå‡½æ•°ä¸ºandroid_media_MediaPlayer_native_setup() 1[-&gt;\\frameworks\\base\\media\\jni\\android_media_MediaPlayer.cpp] æ„é€ Nativeå±‚çš„MediaPlayerå¯¹è±¡çš„æ—¶å€™ã€MediaPlayer.cppã€‘ï¼Œä¹Ÿä¼šæ„é€ å…¶çˆ¶ç±»çš„å¯¹è±¡ã€‚åœ¨MediaPlayerçš„çˆ¶ç±»IMediaDeathNotifierä¸­æœ‰ä¸ªå¾ˆé‡è¦çš„æ–¹æ³•getMediaPlayerService()æ¥è·å–MediaPlayerServiceï¼Œå…¶å…³ç³»åˆ°MediaPlayerå’ŒMediaPlayerServiceä¹‹é—´çš„é€šä¿¡ã€‚ 2.1.4ã€setDataSource()è®¾ç½®æ’­æ”¾èµ„æºåœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºçš„è¿›ç¨‹ä¸­ï¼ŒMediaplayer.cpp ä¸­ setDataSourceä¼šä»service managerä¸­è·å¾—mediaPlayerService æœåŠ¡ï¼Œç„¶åé€šè¿‡æœåŠ¡æ¥åˆ›å»ºplayerï¼Œè¿™ä¸ªplayerå°±æ˜¯æ’­æ”¾å™¨çš„çœŸå®å®ä¾‹ï¼ŒåŒæ—¶ä¹Ÿä½¿MediaPlayerå’ŒMediaPlayerServiceå»ºç«‹äº†è”ç³»ã€‚åœ¨javaå±‚MediaPlayer.javaä¸­çš„setDataSourceæœ€ç»ˆä¼šè°ƒç”¨_setDataSourceæ–¹æ³•ï¼Œå¯¹åº”nativeå±‚MediaPlayer.cppä¸­çš„setDataSourceæ–¹æ³•ã€‚ é€šè¿‡ getMediaPlayerService å¾—åˆ°çš„BpMediaPlayerServiceç±»å‹çš„serviceï¼Œå’ŒmediaPlayerServiceè¿›ç¨‹ä¸­çš„BnMediaPlayerService ç›¸å¯¹åº”è´Ÿè´£binderé€šè®¯ã€‚ åœ¨createå‡½æ•°ä¸­åˆ›å»ºäº†ä¸€ä¸ªMediaPlayerService::Clientçš„å®ä¾‹ï¼Œæ˜¯MediaPlayerServiceçš„å†…éƒ¨ç±»ï¼Œä¹Ÿå°±æ˜¯è¯´MediaPlayerServiceä¼šä¸ºæ¯ä¸ªclientåº”ç”¨è¿›ç¨‹åˆ›å»ºä¸€ä¸ªç›¸åº”çš„MediaPlayerService::Clientçš„å®ä¾‹ï¼Œæ¥å®ç°æ’­æ”¾ä»¥åŠæ’­æ”¾è¿‡ç¨‹çš„æ§åˆ¶ï¼Œå‘MediaPlayerå‘äº‹ä»¶é€šçŸ¥ã€‚åˆ°è¿™é‡Œï¼Œåœ¨Serverç«¯çš„å¯¹è±¡å°±åˆ›å»ºå®Œæˆäº†ã€‚ ç„¶ååœ¨MediaPlayer.cppä¸­å°±å¾—åˆ°äº†ä¸€ä¸ªseverç«¯çš„playerå®ä¾‹ï¼Œå®ƒå’Œæœ¬åœ°å…¶ä»–ç±»çš„å®ä¾‹æ²¡ä»€ä¹ˆç”¨æ³•ä¸Šçš„åŒºåˆ«ï¼Œè€Œå®é™…ä¸Šåˆ™æ˜¯é€šè¿‡binderæœºåˆ¶è¿è¡Œåœ¨å¦å¤–ä¸€ä¸ªè¿›ç¨‹ä¸­çš„ã€‚è·å¾—æ­¤å®ä¾‹åç»§ç»­player-&gt;setDataSourceæ“ä½œã€‚ å°ç»“ï¼šJavaåº”ç”¨ç¨‹åºä¸­ä½¿ç”¨MediaPlayer.javaçš„setDataSource()ä¼šä¼ é€’åˆ°Nativeå±‚ä¸­MediaPlayer.cppçš„setDataSource()å»æ‰§è¡Œï¼Œè€ŒMediaPlayer.cppåˆä¼šæŠŠè¿™ä¸ªæ–¹æ³•äº¤ç»™MediaPlayerserviceå»æ‰§è¡Œã€‚MediaPlayerServiceåˆ™æ˜¯ä½¿ç”¨NuPlayerå®ç°çš„ï¼Œæœ€åï¼Œ setDataSourceè¿˜æ˜¯äº¤ç»™äº†NuPlayerå»æ‰§è¡Œäº†ã€‚è¿™ä¸ªè¿‡ç¨‹æŠŠMediaPlayerå’ŒMediaPlayerServiceä¹‹é—´çš„è”ç³»å»ºç«‹èµ·æ¥ï¼ŒåŒæ—¶åˆæŠŠMediaPlayerServiceå’ŒNuPlayerçš„å…³ç³»å»ºç«‹äº†èµ·æ¥ã€‚ 2.1.5ã€setDisplay() ä¸‹ä¸€æ­¥å°±æ˜¯javaå±‚çš„setDisplayï¼Œä¾ç„¶æŸ¥çœ‹javaå±‚MediaPlayerï¼š 123456789101112[-&gt;\\frameworks\\base\\media\\java\\android\\media\\MediaPlayer.java] public void setDisplay(SurfaceHolder sh) &#123; mSurfaceHolder = sh; Surface surface; if (sh != null) &#123; surface = sh.getSurface(); &#125; else &#123; surface = null; &#125; _setVideoSurface(surface); updateSurfaceScreenOn(); &#125; æœ€åä¼šè°ƒç”¨æœ¬åœ°æ–¹æ³•_setVideoSurfaceï¼Œæˆ‘ä»¬ç»§ç»­æ‰¾åˆ°å®ƒçš„jniå®ç°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[-&gt;\\frameworks\\base\\media\\jni\\android_media_MediaPlayer.cpp]static void android_media_MediaPlayer_setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface)&#123; setVideoSurface(env, thiz, jsurface, true /* mediaPlayerMustBeAlive */);&#125;static void setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)&#123; sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);//è·å–C++çš„MediaPlayer if (mp == NULL) &#123; if (mediaPlayerMustBeAlive) &#123; jniThrowException(env, \"java/lang/IllegalStateException\", NULL); &#125; return; &#125; //å°†æ—§çš„IGraphicBufferProducerçš„å¼ºå¼•ç”¨å‡ä¸€ decVideoSurfaceRef(env, thiz); //IGraphicBufferProducerå›¾å±‚ç¼“å†²åŒºåˆæˆå™¨ sp&lt;IGraphicBufferProducer&gt; new_st; if (jsurface) &#123; //å¾—åˆ°javaå±‚çš„surface sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface)); if (surface != NULL) &#123; //è·å–IGraphicBufferProducer new_st = surface-&gt;getIGraphicBufferProducer(); if (new_st == NULL) &#123; jniThrowException(env, \"java/lang/IllegalArgumentException\", \"The surface does not have a binding SurfaceTexture!\"); return; &#125; //å¢åŠ IGraphicBufferProducerçš„å¼ºå¼•ç”¨+1 new_st-&gt;incStrong((void*)decVideoSurfaceRef); &#125; else &#123; jniThrowException(env, \"java/lang/IllegalArgumentException\", \"The surface has been released\"); return; &#125; &#125; //ä¸Šé¢æˆ‘ä»¬åœ¨native_initæ–¹æ³•ä¸­å°†javaå±‚mNativeSurfaceTextureæŸ¥æ‰¾ç»™äº†jniå±‚ï¼Œæ­£å¥½ï¼Œåœ¨è¿™é‡Œå°†IGraphicBufferProducerèµ‹ç»™å®ƒ env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get()); // This will fail if the media player has not been initialized yet. This // can be the case if setDisplay() on MediaPlayer.java has been called // before setDataSource(). The redundant call to setVideoSurfaceTexture() // in prepare/prepareAsync covers for this case. //å¦‚æœMediaPlayeræ²¡æœ‰åˆå§‹åŒ–ï¼Œè¿™ä¸€æ­¥ä¼šå¤±è´¥ã€‚åŸå› å¯èƒ½æ˜¯setDisplayåœ¨setDataSourceä¹‹å‰ã€‚å¦‚æœåœ¨prepare/prepareAsync æ—¶æƒ³è§„é¿è¿™ä¸ªé”™è¯¯è€Œå»è°ƒç”¨setVideoSurfaceTextureæ˜¯å¤šä½™çš„ã€‚ //æœ€ç»ˆä¼šè°ƒç”¨C++å±‚çš„setVideoSurfaceTextureæ–¹æ³•ï¼Œä¸‹ä¸€èŠ‚åœ¨åˆ†æ mp-&gt;setVideoSurfaceTexture(new_st);&#125;//å°†æ—§çš„IGraphicBufferProducerçš„å¼ºå¼•ç”¨å‡ä¸€static void decVideoSurfaceRef(JNIEnv *env, jobject thiz)&#123; sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz); if (mp == NULL) &#123; return; &#125; sp&lt;IGraphicBufferProducer&gt; old_st = getVideoSurfaceTexture(env, thiz); if (old_st != NULL) &#123; old_st-&gt;decStrong((void*)decVideoSurfaceRef); &#125;&#125; è¿™ä¸€æ­¥ä¸»è¦æ˜¯å¯¹å›¾åƒæ˜¾ç¤ºçš„surfaceçš„ä¿å­˜ï¼Œç„¶åå°†æ—§çš„IGraphicBufferProducerå¼ºå¼•ç”¨å‡ä¸€ï¼Œå†è·å¾—æ–°çš„IGraphicBufferProducerï¼Œæœ€åä¼šè°ƒç”¨C++çš„MediaPlayerçš„setVideoSurfaceTextureå°†å®ƒæŠ˜çº¸è¿›å»ã€‚ IGraphicBufferProduceræ˜¯SurfaceFlingerçš„å†…å®¹ï¼Œä¸€ä¸ªUIå®Œå…¨æ˜¾ç¤ºåˆ°diplayçš„è¿‡ç¨‹ï¼ŒSurfaceFlingeræ‰®æ¼”ç€é‡è¦çš„è§’è‰²ä½†æ˜¯å®ƒçš„èŒè´£æ˜¯â€œFlingerâ€ï¼Œå³æŠŠç³»ç»Ÿä¸­æ‰€æœ‰åº”ç”¨ç¨‹åºçš„æœ€ç»ˆçš„â€œç»˜å›¾ç»“æœâ€è¿›è¡Œâ€œæ··åˆâ€ï¼Œç„¶åç»Ÿä¸€æ˜¾ç¤ºåˆ°ç‰©ç†å±å¹•ä¸Šï¼Œè€Œå…¶ä»–æ–¹é¢æ¯”å¦‚å„ä¸ªç¨‹åºçš„ç»˜ç”»è¿‡ç¨‹ï¼Œå°±ç”±å…¶ä»–ä¸œè¥¿æ¥æ‹…ä»»äº†ã€‚è¿™ä¸ªå…‰è£çš„ä»»åŠ¡è‡ªç„¶è€Œç„¶åœ°è½åœ¨äº†BufferQueueçš„è‚©è†€ä¸Šï¼Œå®ƒæ˜¯æ¯ä¸ªåº”ç”¨ç¨‹åºâ€œä¸€å¯¹ä¸€â€çš„è¾…å¯¼è€å¸ˆï¼ŒæŒ‡å¯¼ç€UIç¨‹åºçš„â€œç”»æ¿ç”³è¯·â€ã€â€œä½œç”»æµç¨‹â€ç­‰ä¸€ç³»åˆ—ç»†èŠ‚ã€‚ä¸‹é¢çš„å›¾æè¿°äº†è¿™ä¸‰è€…çš„å…³ç³»ï¼š è™½è¯´æ˜¯ä¸‰è€…çš„å…³ç³»ï¼Œä½†æ˜¯ä»–ä»¬æ‰€å±çš„å±‚å´åªæœ‰ä¸¤ä¸ªï¼Œappå±äºJavaå±‚ï¼ŒBufferQueue/SurfaceFlingerå±äºnativeå±‚ã€‚ä¹Ÿå°±æ˜¯è¯´BufferQueueä¹Ÿæ˜¯éš¶å±SurfaceFlingerï¼Œæ‰€æœ‰å·¥ä½œå›´ç»•SurfaceFlingerå±•å¼€ã€‚ è¿™é‡ŒIGraphicBufferProducerå°±æ˜¯appå’ŒBufferQueueé‡è¦æ¡¥æ¢ï¼ŒGraphicBufferProduceræ‰¿æ‹…ç€å•ä¸ªåº”ç”¨è¿›ç¨‹ä¸­çš„UIæ˜¾ç¤ºéœ€æ±‚ï¼Œä¸BufferQueueæ‰“äº¤é“çš„å°±æ˜¯å®ƒã€‚ 2.1.6ã€æ’­æ”¾å™¨åŸºæœ¬æ¨¡å‹NuPlayerä¸ç®¡æœ‰å¤šä¹ˆç¥ç§˜ï¼Œè¯´åˆ°åº•è¿˜æ˜¯ä¸ªæ’­æ”¾å™¨ã€‚åœ¨æ’­æ”¾å™¨çš„åŸºæœ¬æ¨¡å‹ä¸Šï¼Œä»–ä¸VCLã€mplayerã€ffmpegç­‰å¼€æºçš„ç»“æ„æ˜¯ä¸€è‡´çš„ã€‚åªæ˜¯ç»„ç»‡å®ç°çš„æ–¹å¼ä¸åŒã€‚æ·±å…¥äº†è§£NuPlayerä¹‹å‰ï¼ŒæŠŠæ’­æ”¾å™¨çš„åŸºæœ¬æ¨¡å‹æ€»ç»“ä¸€ä¸‹ï¼Œç„¶åæŒ‰ç…§æ¨¡å‹çš„å„ä¸ªéƒ¨åˆ†æ¥æ·±å…¥ç ”ç©¶NuPlayerçš„å®ç°æ–¹å¼ã€‚ â˜¯ datasourceæ•°æ®æºï¼šæ•°æ®æºï¼Œæ•°æ®çš„æ¥æºä¸ä¸€å®šéƒ½æ˜¯æœ¬åœ°fileï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ç½‘è·¯ä¸Šçš„å„ç§åè®®ä¾‹å¦‚ï¼šhttpã€rtspã€HLSç­‰ã€‚sourceçš„ä»»åŠ¡å°±æ˜¯æŠŠæ•°æ®æºæŠ½è±¡å‡ºæ¥ï¼Œä¸ºä¸‹ä¸€ä¸ªdemuxæ¨¡å—æä¾›å®ƒéœ€è¦çš„ç¨³å®šçš„æ•°æ®æµã€‚demuxä¸ç”¨å…³ä¿¡æ•°æ®åˆ°åº•æ˜¯ä»ä»€ä¹ˆåœ°æ–¹æ¥çš„ã€‚ â˜¯ demuxerè§£å¤ç”¨ï¼šè§†é¢‘æ–‡ä»¶ä¸€èˆ¬æƒ…å†µä¸‹éƒ½æ˜¯æŠŠéŸ³è§†é¢‘çš„ESæµäº¤ç»‡çš„é€šè¿‡æŸç§è§„åˆ™æ”¾åœ¨ä¸€èµ·ã€‚è¿™ç§è§„åˆ™å°±æ˜¯å®¹å™¨è§„åˆ™ã€‚ç°åœ¨æœ‰å¾ˆå¤šä¸åŒçš„å®¹å™¨æ ¼å¼ã€‚å¦‚tsã€mp4ã€flvã€mkvã€aviã€rmvbç­‰ç­‰ã€‚demuxçš„åŠŸèƒ½å°±æ˜¯æŠŠéŸ³è§†é¢‘çš„ESæµä»å®¹å™¨ä¸­å‰¥ç¦»å‡ºæ¥ï¼Œç„¶ååˆ†åˆ«é€åˆ°ä¸åŒçš„è§£ç å™¨ä¸­ã€‚å…¶å®éŸ³é¢‘å’Œè§†é¢‘æœ¬èº«å°±æ˜¯2ä¸ªç‹¬ç«‹çš„ç³»ç»Ÿã€‚å®¹å™¨æŠŠå®ƒä»¬åŒ…åœ¨äº†ä¸€èµ·ã€‚ä½†æ˜¯ä»–ä»¬éƒ½æ˜¯ç‹¬ç«‹è§£ç çš„ï¼Œæ‰€ä»¥è§£ç ä¹‹å‰ï¼Œéœ€è¦æŠŠå®ƒåˆ†åˆ« ç‹¬ç«‹å‡ºæ¥ã€‚demuxå°±æ˜¯å¹²è¿™æ´»çš„ï¼Œä»–ä¸ºä¸‹ä¸€æ­¥decoderè§£ç æä¾›äº†æ•°æ®æµã€‚ â˜¯ decoderè§£ç ï¼šè§£ç å™¨â€”-æ’­æ”¾å™¨çš„æ ¸å¿ƒæ¨¡å—ã€‚åˆ†ä¸ºéŸ³é¢‘å’Œè§†é¢‘è§£ç å™¨ã€‚å½±åƒåœ¨å½•åˆ¶å, åŸå§‹çš„éŸ³è§†é¢‘éƒ½æ˜¯å ç”¨å¤§é‡ç©ºé—´, è€Œä¸”æ˜¯å†—ä½™åº¦è¾ƒé«˜çš„æ•°æ®. å› æ­¤, é€šå¸¸ä¼šåœ¨åˆ¶ä½œçš„æ—¶å€™å°±ä¼šè¿›è¡ŒæŸç§å‹ç¼© ( å‹ç¼©æŠ€æœ¯å°±æ˜¯å°†æ•°æ®ä¸­çš„å†—ä½™ä¿¡æ¯å»é™¤æ•°æ®ä¹‹é—´çš„ç›¸å…³æ€§ ). è¿™å°±æ˜¯æˆ‘ä»¬ç†ŸçŸ¥çš„éŸ³è§†é¢‘ç¼–ç æ ¼å¼, åŒ…æ‹¬MPEG1ï¼ˆVCDï¼‰\\ MPEG2ï¼ˆDVDï¼‰\\ MPEG4 \\ H.264 ç­‰ç­‰. éŸ³è§†é¢‘è§£ç å™¨çš„ä½œç”¨å°±æ˜¯æŠŠè¿™äº›å‹ç¼©äº†çš„æ•°æ®è¿˜åŸæˆåŸå§‹çš„éŸ³è§†é¢‘æ•°æ®. å½“ç„¶, ç¼–ç è§£ç è¿‡ç¨‹åŸºæœ¬ä¸Šéƒ½æ˜¯æœ‰æŸçš„ .è§£ç å™¨çš„ä½œç”¨å°±æ˜¯æŠŠç¼–ç åçš„æ•°æ®è¿˜åŸæˆåŸå§‹æ•°æ®ã€‚ â˜¯ outputè¾“å‡ºï¼šè¾“å‡ºéƒ¨åˆ†åˆ†ä¸ºéŸ³é¢‘å’Œè§†é¢‘è¾“å‡ºã€‚è§£ç åçš„éŸ³é¢‘ï¼ˆpcmï¼‰å’Œè§†é¢‘ï¼ˆyuvï¼‰çš„åŸå§‹æ•°æ®éœ€è¦å¾—åˆ°éŸ³è§†é¢‘çš„outputæ¨¡å—çš„æ”¯æŒæ‰èƒ½çœŸæ­£çš„è®©äººçš„æ„Ÿå®˜ç³»ç»Ÿï¼ˆçœ¼å’Œè€³ï¼‰è¾¨è¯†åˆ°ã€‚ æ‰€ä»¥ï¼Œæ’­æ”¾å™¨å¤§è‡´åˆ†æˆä¸Šè¿°4éƒ¨åˆ†ã€‚æ€ä¹ˆæŠ½è±¡çš„å®ç°è¿™4å¤§éƒ¨åˆ†ã€ä»¥åŠæ‰¾åˆ°ä¸€ç§åˆç†çš„æ–¹å¼å°†è¿™å‡ éƒ¨åˆ†ç»„ç»‡å¹¶è¿åŠ¨èµ·æ¥ã€‚æ˜¯æ¯ä¸ªæ’­æ”¾å™¨ä¸åŒçš„å®ç°æ–¹å¼è€Œå·²ã€‚æ¥ä¸‹æ¥å°±å›´ç»•è¿™4å¤§éƒ¨åˆ†åšæ·±å…¥å­¦ä¹ ï¼Œçœ‹çœ‹NuPlayerçš„å·¥ä½œåŸç†ã€‚ 2.2ã€NuPlayeråˆ†æ2.2.0ã€NuPlayerç®€ä»‹Android2.3æ—¶å¼•å…¥æµåª’ä½“æ¡†æ¶ï¼Œè€Œæµåª’ä½“æ¡†æ¶çš„æ ¸å¿ƒæ˜¯NuPlayerã€‚åœ¨ä¹‹å‰çš„ç‰ˆæœ¬ä¸­ä¸€èˆ¬è®¤ä¸ºLocal Playbackå°±ç”¨Stagefrightplayer+Awesomeplayerï¼Œæµåª’ä½“ç”¨NuPlayerã€‚Android4.0ä¹‹åHttpLiveå’ŒRTSPåè®®å¼€å§‹ä½¿ç”¨NuPlayeræ’­æ”¾å™¨ï¼ŒAndroid5.0ï¼ˆLç‰ˆæœ¬ï¼‰ä¹‹åæœ¬åœ°æ’­æ”¾ä¹Ÿå¼€å§‹ä½¿ç”¨NuPlayeræ’­æ”¾å™¨ã€‚ Android7.0(Nç‰ˆæœ¬)åˆ™å®Œå…¨å»æ‰äº†Awesomeplayerã€‚é€šä¿—ç‚¹è¯´ï¼ŒNuPlayeræ˜¯AOSPä¸­æä¾›çš„å¤šåª’ä½“æ’­æ”¾æ¡†æ¶ï¼Œèƒ½å¤Ÿæ”¯æŒæœ¬åœ°æ–‡ä»¶ã€HTTPï¼ˆHLSï¼‰ã€RTSPç­‰åè®®çš„æ’­æ”¾ï¼Œé€šå¸¸æ”¯æŒH.264ã€H.265/HEVCã€AACç¼–ç æ ¼å¼ï¼Œæ”¯æŒMP4ã€MPEG-TSå°è£…ã€‚åœ¨å®ç°ä¸ŠNuPlayerå’ŒAwesomeplayerä¸åŒï¼ŒNuPlayeråŸºäºStagefrightPlayerçš„åŸºç¡€ç±»æ„å»ºï¼Œåˆ©ç”¨äº†æ›´åº•å±‚çš„ALooper/AHandleræœºåˆ¶æ¥å¼‚æ­¥åœ°å¤„ç†è¯·æ±‚ï¼ŒALooperåˆ—é˜Ÿæ¶ˆæ¯è¯·æ±‚ï¼ŒAHandlerä¸­å»å¤„ç†ï¼Œæ‰€ä»¥æœ‰æ›´å°‘çš„Mutex/Lockåœ¨NuPlayerä¸­ã€‚Awesomeplayerä¸­åˆ©ç”¨äº†omxcodecè€ŒNuPlayerä¸­åˆ©ç”¨äº†Acodecã€‚ 2.2.1ã€NuPlayeræ•´ä½“ç±»å…³ç³»å›¾ NuPlayerç”±NuPlayerDriverå°è£…ï¼Œåˆ©ç”¨äº†åº•å±‚çš„ALooper/AHandleræœºåˆ¶æ¥å¼‚æ­¥åœ°å¤„ç†è¯·æ±‚ï¼ŒALooperä¿å­˜æ¶ˆæ¯è¯·æ±‚ï¼Œç„¶ååœ¨AHandlerä¸­å¤„ç†ã€‚å¦å¤–ï¼ŒNuPlayerä¸­åˆ©ç”¨åˆ°äº†Acodecã€‚ â˜¯ NuPlayer::Sourceè§£ææ¨¡å—ï¼ˆparserï¼ŒåŠŸèƒ½ç±»ä¼¼FFmpegçš„avformatï¼‰ã€‚å…¶æ¥å£ä¸MediaExtractorå’ŒMediaSourceç»„åˆçš„æ¥å£å·®ä¸å¤šï¼ŒåŒæ—¶æä¾›äº†ç”¨äºå¿«é€Ÿå®šä½çš„seekToæ¥å£ã€‚ â˜¯ NuPlayer::Decoderè§£ç æ¨¡å—ï¼ˆdecoderï¼ŒåŠŸèƒ½ç±»ä¼¼FFmpegçš„avcodecï¼‰ï¼Œå°è£…äº†ç”¨äºAVCã€AACè§£ç çš„æ¥å£ï¼Œé€šè¿‡ACodecå®ç°è§£ç ï¼ˆåŒ…å«OMXç¡¬è§£ç å’Œè½¯è§£ç ï¼‰ã€‚ â˜¯ NuPlayer::Renderæ¸²æŸ“æ¨¡å—ï¼ˆrenderï¼ŒåŠŸèƒ½ç±»ä¼¼å£°å¡é©±åŠ¨å’Œæ˜¾å¡é©±åŠ¨ï¼‰ï¼Œä¸»è¦ç”¨äºéŸ³è§†é¢‘æ¸²æŸ“å’ŒåŒæ­¥ï¼Œä¸NativeWindowæœ‰å…³ã€‚ â˜¯ NuPlayer æ˜¯æ’­æ”¾æ¡†æ¶ä¸­è¿æ¥Sourceã€Decoderã€Rendererçš„çº½å¸¦ â˜¯ NuPlayerDriverä½œä¸ºNuPlayerç±»çš„å°è£…ï¼Œç›´æ¥è°ƒç”¨NuPlayerã€‚ NuPlayeræ¡†æ¶ä¸­æœ€é¡¶å±‚çš„ç±»æ˜¯NuPlayerDriverï¼Œç»§æ‰¿è‡ªMediaPlayerInterfaceï¼Œä¸»è¦æä¾›ä¸€ä¸ªçŠ¶æ€è½¬æ¢æœºåˆ¶ï¼Œä½œä¸ºNuPlayerç±»çš„Wrapperã€‚NuPlayerDriverç±»ä¸­æœ€é‡è¦çš„æˆå‘˜æ˜¯ä»¥ä¸‹å‡ ä¸ªï¼š 123&gt; State mState æ’­æ”¾å™¨çŠ¶ä½“æ ‡å¿— &gt; sp &lt;ALooper&gt; mLooper å†…éƒ¨æ¶ˆæ¯é©±åŠ¨æœºåˆ¶ &gt; sp &lt;NuPlayer&gt; mPlayer çœŸæ­£å®Œæˆæ’­æ”¾å™¨çš„ç±» NuPlayerDriverä¸»è¦æ˜¯ æ„é€ å‡½æ•°-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; ææ„å‡½æ•°ï¼Œå®é™…éœ€æ±‚pauseã€isPlayingã€getDurationã€getCurrentPositionã€setLoopingã€seekToç­‰æ–¹æ³• 2.2.2ã€NuPlayeræ¡†æ¶éœ€è¦å…³æ³¨çŸ¥è¯†ç‚¹123456789101112NuPlayerçš„æ¡†æ¶ï¼Œå…¶å†…éƒ¨å®ç°é€»è¾‘ã€‚é‚£ä¹ˆæœ€ç»ˆå°±è½å®åˆ°å¦‚ä½•ä»ä¸€ä¸ªç±»ä¸­æå–å‡ºéœ€è¦çš„æ¡†æ¶åŠçŸ¥è¯†ç‚¹ã€‚é‚£ä¹ˆä¸€ä¸ªç±»çš„å¯¹å¤–æ¥å£éƒ¨åˆ†é€šå¸¸åŒ…æ‹¬ï¼š--- æ„é€ å‡½æ•°å’Œææ„å‡½æ•°--- å¿…é¡»è°ƒç”¨çš„æ¥å£--- å¯é€‰çš„è°ƒç”¨æ¥å£åœ¨å¤šåª’ä½“æ’­æ”¾ä¸­ï¼Œé€šè¿‡å…³æ³¨çš„ç‚¹æœ‰ï¼š--- å¦‚ä½•å®ç°è§£å¤ç”¨ï¼Œå¾—åˆ°éŸ³é¢‘ã€è§†é¢‘ã€å­—å¹•ç­‰æ•°æ®--- å¦‚ä½•å®ç°è§£ç --- å¦‚ä½•å®ç°éŸ³è§†é¢‘åŒæ­¥--- å¦‚ä½•æ¸²æŸ“è§†é¢‘--- å¦‚ä½•æ’­æ”¾éŸ³é¢‘--- å¦‚ä½•å®ç°å¿«é€Ÿå®šä½ (ä¸‰)ã€Android MediaPlayeræ¡†æ¶åˆ†æ - AHandler AMessage ALooperå‰æ–‡ä¸­æåˆ°è¿‡NuPlayeråŸºäºStagefrightPlayerçš„åŸºç¡€ç±»æ„å»ºï¼Œåˆ©ç”¨äº†æ›´åº•å±‚çš„ALooper/AHandleræœºåˆ¶æ¥å¼‚æ­¥åœ°å¤„ç†è¯·æ±‚ï¼ŒALooperä¿å­˜æ¶ˆæ¯è¯·æ±‚ï¼Œç„¶åè°ƒç”¨AHandleræ¥å£å»å¤„ç†ã€‚å®é™…ä¸Šåœ¨ä»£ç ä¸­NuPlayeræœ¬èº«ç»§æ‰¿è‡ªAHandlerç±»ï¼Œè€ŒALooperå¯¹è±¡ä¿å­˜åœ¨NuPlayerDriverä¸­ã€‚ALooper/AHandleræœºåˆ¶æ˜¯æ¨¡æ‹Ÿçš„æ¶ˆæ¯å¾ªç¯å¤„ç†æ–¹å¼ï¼Œé€šå¸¸æœ‰ä¸‰ä¸ªä¸»è¦éƒ¨åˆ†ï¼šæ¶ˆæ¯ï¼ˆmessageï¼Œé€šå¸¸åŒ…å«Handlerï¼‰ã€æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆqueueï¼‰ã€æ¶ˆæ¯å¤„ç†çº¿ç¨‹ï¼ˆlooper threadï¼‰ã€‚ å¯¹äºhandleræ¶ˆæ¯æœºåˆ¶ï¼Œæ„æˆå°±å¿…é¡»åŒ…æ‹¬ä¸€ä¸ªLoopï¼Œmessageã€‚é‚£ä¹ˆå¯¹åº”çš„AHandlerï¼Œä¹Ÿåº”è¯¥æœ‰å¯¹åº”çš„ALooperã€AMessageã€‚å› æ­¤æœ¬å°èŠ‚ä¸»è¦æ¶‰åŠåˆ°ä¸‰ä¸ªç±»ALooperã€AHandlerã€AMessageã€‚ 3.1ã€AHandleræ¥å£åˆ†æï¼ˆæ¶ˆæ¯å¤„ç†ç±»ï¼‰ä¸‹é¢ä»£ç æ˜¯AHandleræ¥å£: 1234567891011121314151617181920212223\"./frameworks/av/include/media/stagefright/AHandler.h\"struct AHandler : public RefBase &#123; AHandler(); ALooper::handler_id id() const; sp&lt;ALooper&gt; looper() const; wp&lt;ALooper&gt; getLooper() const; wp&lt;AHandler&gt; getHandler() const;protected: virtual void onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) = 0;private: friend struct AMessage; // deliverMessage() friend struct ALooperRoster; // setID() uint32_t mMessageCounter; KeyedVector&lt;uint32_t, uint32_t&gt; mMessages; void setID(ALooper::handler_id id, wp&lt;ALooper&gt; looper); void deliverMessage(const sp&lt;AMessage&gt; &amp;msg);&#125;; çœ‹ä¸Šé¢æ¥å£ï¼Œåˆæ­¥å°è±¡æ˜¯AHandleræ²¡æœ‰ç›´æ¥å¯¹å¤–çš„æ¥å£ï¼ˆåªæœ‰è·å–æˆå‘˜å˜é‡çš„æ¥å£ï¼‰ï¼ŒåŸºæœ¬ä¸Šåªæœ‰ä¸€ä¸ªonMessageReceivedç”¨äºå­ç±»ç»§æ‰¿ï¼ŒdeliverMessageç”¨äºç»™ç±»AMessageä½¿ç”¨ï¼ŒsetIDç”¨äºç»™å‹å…ƒç±»ALooperRosterä½¿ç”¨ã€‚ä»è¿™ç‚¹æ¥è¯´ï¼ŒçœŸæ­£ä»£ç åº”è¯¥åœ¨AMessageé‡Œè¾¹ã€‚ 3.2ã€AMessageæ¥å£åˆ†æï¼ˆæ¶ˆæ¯è½½ä½“ï¼‰ä¸‹é¢ä»£ç æ˜¯AMessageçš„å£°æ˜ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768\"./frameworks/av/include/media/stagefright/AMessage.h\"struct AMessage : public RefBase &#123; AMessage(); AMessage(uint32_t what, const sp&lt;const AHandler&gt; &amp;handler); // ä»£ç ä¸­å¸¸ç”¨çš„æ„é€ å‡½æ•° static sp&lt;AMessage&gt; FromParcel(const Parcel &amp;parcel, size_t maxNestingLevel = 255); // Write this AMessage to a parcel. // All items in the AMessage must have types that are recognized by // FromParcel(); otherwise, TRESPASS error will occur. void writeToParcel(Parcel *parcel) const; void setWhat(uint32_t what); uint32_t what() const; // æ³¨æ„è¿™æ˜¯ä¸€ä¸ªAHandlerï¼Œé€šè¿‡è¿™ä¸ªå¯ä»¥è·å¾—ALooperå¯¹è±¡å¼•ç”¨ void setTarget(const sp&lt;const AHandler&gt; &amp;handler); // æ¸…é™¤æ‰€æœ‰è®¾ç½®çš„æ¶ˆæ¯å±æ€§å‚æ•° void clear(); // ä¸€ç³»åˆ—è®¾ç½®/è·å– Message å±æ€§çš„å‡½æ•°ã€‚ã€‚ã€‚ void setInt32/setInt64/setSize/setFloat/setDouble/setPointer/setPointer/setString/setRect/setObject/setBuffer/setMessage(...); bool findInt32/findInt64/findSize/findFloat/findDouble/findPointer/findString/findObject/findBuffer/findMessage/findRect(...) const; // é€šè¿‡è¿™ä¸ªå‡½æ•°æ£€ç´¢ä¸‹æŒ‡å®šåç§°çš„æ¶ˆæ¯å±æ€§æ˜¯å¦å­˜åœ¨ bool contains(const char *name) const; // æŠ•é€’æ¶ˆæ¯çš„æ¥å£ï¼Œé¡¾åæ€ä¹‰ç›´æ¥æŠ•é€’ç»™æ„é€ å‡½æ•°çš„ALooperï¼Œæ³¨æ„æ”¯æŒå»¶æ—¶æ¶ˆæ¯ï¼Œä½†ä¸æ”¯æŒæå‰æ¶ˆæ¯ï¼ŒdelayUS &gt; 0 status_t post(int64_t delayUs = 0); // æŠ•é€’æ¶ˆæ¯å¹¶ç­‰å¾…æ‰§è¡Œç»“æŸåå‘é€responseæ¶ˆæ¯ status_t postAndAwaitResponse(sp&lt;AMessage&gt; *response); // If this returns true, the sender of this message is synchronously // awaiting a response and the reply token is consumed from the message // and stored into replyID. The reply token must be used to send the response // using \"postReply\" below. bool senderAwaitsResponse(sp&lt;AReplyToken&gt; *replyID); // Posts the message as a response to a reply token. A reply token can // only be used once. Returns OK if the response could be posted; otherwise, // an error. status_t postReply(const sp&lt;AReplyToken&gt; &amp;replyID); // æ·±æ‹·è´ sp&lt;AMessage&gt; dup() const; // æ¯”è¾ƒä¸¤ä¸ªæ¶ˆæ¯ï¼Œå¹¶è¿”å›å·®å¼‚ sp&lt;AMessage&gt; changesFrom(const sp&lt;const AMessage&gt; &amp;other, bool deep = false) const; // è·å–æ¶ˆæ¯å±æ€§å­˜å‚¨çš„ä¸ªæ•°åŠç‰¹å®šç´¢å¼•ä¸Šçš„æ¶ˆæ¯å±æ€§å‚æ•° size_t countEntries() const; const char *getEntryNameAt(size_t index, Type *type) const;protected: virtual ~AMessage();private: friend struct ALooper; // deliver() uint32_t mWhat; wp&lt;AHandler&gt; mHandler; wp&lt;ALooper&gt; mLooper; // ç”¨äºALooperè°ƒç”¨çš„ï¼Œå‘é€æ¶ˆæ¯çš„æ¥å£ void deliver();&#125;; ä»ä¸Šé¢çš„æ¥å£å¯ä»¥çœ‹å‡ºåœ¨ä½¿ç”¨AMessageæ˜¯åªéœ€è¦æŒ‡å®šæ¶ˆæ¯çš„idå’Œè¦å¤„ç†è¯¥æ¶ˆæ¯çš„AHandlerå³å¯ï¼Œå¯ä»¥é€šè¿‡æ„é€ å‡½æ•°ï¼Œä¹Ÿå¯ä»¥å•ç‹¬è°ƒç”¨setWhatå’ŒsetTargetæ¥å£ã€‚AMessageæ„é€ å®Œæˆä¹‹åï¼Œå¯ä»¥è°ƒç”¨setXXXè®¾ç½®å¯¹åº”çš„å‚æ•°ï¼Œé€šè¿‡findXXXè·å–ä¼ é€’çš„å‚æ•°ã€‚æœ€åé€šè¿‡postå³å¯å°†æ¶ˆæ¯æŠ•é€’åˆ°AHandlerçš„æ¶ˆæ¯é˜Ÿåˆ—ä¸­ã€‚ 3.3ã€ALooperæ¥å£åˆ†æï¼ˆæ¶ˆæ¯å¤„ç†å¾ªç¯åŠåå°çº¿ç¨‹ï¼‰å…¶ç®€åŒ–çš„å£°æ˜å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354\"./frameworks/av/include/media/stagefright/ALooper.h\"struct ALooper : public RefBase &#123; ALooper(); // Takes effect in a subsequent call to start(). void setName(const char *name); const char *getName() const; handler_id registerHandler(const sp&lt;AHandler&gt; &amp;handler); void unregisterHandler(handler_id handlerID); status_t start(bool runOnCallingThread = false, bool canCallJava = false, int32_t priority = PRIORITY_DEFAULT); status_t stop(); static int64_t GetNowUs(); protected: virtual ~ALooper();private: friend struct AMessage; // post() AString mName; struct Event &#123; int64_t mWhenUs; sp&lt;AMessage&gt; mMessage; &#125;; List&lt;Event&gt; mEventQueue; struct LooperThread; sp&lt;LooperThread&gt; mThread; bool mRunningLocally; // START --- methods used only by AMessage // posts a message on this looper with the given timeout void post(const sp&lt;AMessage&gt; &amp;msg, int64_t delayUs); // creates a reply token to be used with this looper sp&lt;AReplyToken&gt; createReplyToken(); // waits for a response for the reply token. If status is OK, the response // is stored into the supplied variable. Otherwise, it is unchanged. status_t awaitResponse(const sp&lt;AReplyToken&gt; &amp;replyToken, sp&lt;AMessage&gt; *response); // posts a reply for a reply token. If the reply could be successfully posted, // it returns OK. Otherwise, it returns an error value. status_t postReply(const sp&lt;AReplyToken&gt; &amp;replyToken, const sp&lt;AMessage&gt; &amp;msg); // END --- methods used only by AMessage bool loop();&#125;; ALooperå¯¹å¤–æ¥å£æ¯”è¾ƒç®€å•ï¼Œé€šå¸¸å°±æ˜¯NuPlayerDriveræ„é€ å‡½æ•°ä¸­çš„è°ƒç”¨é€»è¾‘ã€‚å…ˆåˆ›å»ºä¸€ä¸ªALooperå¯¹è±¡ï¼Œç„¶åè°ƒç”¨setNameå’Œstartæ¥å£ï¼Œä¹‹åè°ƒç”¨registerHandlerè®¾ç½®ä¸€ä¸ªAHandlerï¼Œè¿™æ ·å°±å®Œæˆäº†åˆå§‹åŒ–ã€‚åœ¨ææ„ä¹‹å‰éœ€è¦è°ƒç”¨stopæ¥å£ã€‚è¿™é‡Œéœ€è¦è¯´æ˜ä¸‹ï¼ŒALooper::startæ¥å£ä¼šå¯åŠ¨ä¸€ä¸ªçº¿ç¨‹ï¼Œå¹¶è°ƒç”¨ALooper::loopå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¸»è¦å®ç°æ¶ˆæ¯çš„å®é™…æ‰§è¡Œã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233bool ALooper::loop() &#123; Event event; &#123; Mutex::Autolock autoLock(mLock); if (mThread == NULL &amp;&amp; !mRunningLocally) &#123; return false; &#125; // ä»mEventQueueå–å‡ºæ¶ˆæ¯ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦æ‰§è¡Œï¼Œä¸éœ€è¦çš„è¯å°±ç­‰å¾… // éœ€è¦çš„è¯å°±è°ƒç”¨handleræ‰§è¡Œï¼Œå¹¶åˆ é™¤å¯¹åº”æ¶ˆæ¯ if (mEventQueue.empty()) &#123; mQueueChangedCondition.wait(mLock); return true; &#125; int64_t whenUs = (*mEventQueue.begin()).mWhenUs; int64_t nowUs = GetNowUs(); if (whenUs &gt; nowUs) &#123; int64_t delayUs = whenUs - nowUs; mQueueChangedCondition.waitRelative(mLock, delayUs * 1000ll); return true; &#125; event = *mEventQueue.begin(); mEventQueue.erase(mEventQueue.begin()); &#125; event.mMessage-&gt;deliver(); return true;&#125; é‚£ä¹ˆæ¶ˆæ¯æ˜¯é€šè¿‡é‚£ä¸ªå‡½æ•°æ·»åŠ è¿›æ¥çš„å‘¢ï¼Ÿ è¿™å°±æ˜¯å‹å…ƒç±»AMessageçš„ä½œç”¨ï¼Œé€šè¿‡è°ƒç”¨ALooper::postæ¥å£ï¼Œå°†AMessageæ·»åŠ åˆ°mEventQueueä¸­ã€‚ 3.4ã€ä¸€ä¸ªè°ƒç”¨å®ä¾‹ä»¥NuPlayer::setVideoSurfaceTextureAsyncä¸ºç¤ºä¾‹åˆ†æä¸‹ALooper/AHandleræœºåˆ¶ã€‚è¿™é‡Œä¸è§£é‡ŠALooperçš„åˆå§‹åŒ–è¿‡ç¨‹ï¼Œæœ‰å…´è¶£çš„å¯ä»¥å‚è€ƒèµ„æ–™Android Nativeå±‚å¼‚æ­¥æ¶ˆæ¯å¤„ç†æ¡†æ¶çš„å†…å®¹ã€‚ä¸‹é¢æ˜¯setVideoSurfaceTextureAsyncçš„ä»£ç ã€‚ 12345678910111213[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::setVideoSurfaceTextureAsync( const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatSetVideoSurface, this); if (bufferProducer == NULL) &#123; msg-&gt;setObject(\"surface\", NULL); &#125; else &#123; msg-&gt;setObject(\"surface\", new Surface(bufferProducer, true /* controlledByApp */)); &#125; msg-&gt;post();&#125; è¿™æ®µä»£ç åŠŸèƒ½å¾ˆç®€å•ï¼Œåˆ›å»ºä¸€ä¸ªAMessageå¯¹è±¡ï¼Œå¹¶è®¾ç½®ä¸‹å‚æ•°ï¼Œå‚æ•°ç±»å‹ä¸ºObjectï¼Œåç§°æ˜¯â€surfaceâ€ï¼Œç„¶åé€šè¿‡AMessage::postæ¥å£ï¼Œé—´æ¥è°ƒç”¨ALooper::postæ¥å£ï¼Œå°†æ¶ˆæ¯å‘é€ç»™ALooper-NuPlayerDriver::mLooperï¼›ALooperçš„æ¶ˆæ¯å¾ªç¯çº¿ç¨‹æ£€æµ‹åˆ°è¿™ä¸ªæ¶ˆæ¯ï¼Œåœ¨ALooper::loopå‡½æ•°ä¸­é€šè¿‡AMessageçš„deliveræ¥å£ï¼Œè°ƒç”¨AHandler::deliverMessageæ¥å£ï¼Œè¿™ä¸ªå‡½æ•°ä¼šè°ƒåŠ¨NuPlayer::onMessageReceivedï¼ˆé€šè¿‡ç»§æ‰¿æœºåˆ¶å®ç°ï¼‰æ¥å£ã€‚è¿™æ ·ç»•äº†ä¸€åœˆã€‚æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ALooper/AHandleræœºåˆ¶å¤„ç†æ¶ˆæ¯äº†ã€‚å…·ä½“å¤„ç†ä»£ç å¦‚ä¸‹ 123456789101112131415161718192021222324252627[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &amp;msg) &#123; switch (msg-&gt;what()) &#123; case kWhatSetVideoSurface: &#123; sp&lt;RefBase&gt; obj; CHECK(msg-&gt;findObject(\"surface\", &amp;obj)); sp&lt;Surface&gt; surface = static_cast&lt;Surface *&gt;(obj.get()); ALOGD(\"onSetVideoSurface(%p video decoder)\", surface.get()); // Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might // be in preparing state and it could take long time. // When mStarted is true, mSource must have been set. if (mSource == NULL || !mStarted || mSource-&gt;getFormat(false /* audio */) == NULL // NOTE: mVideoDecoder's mSurface is always non-null || (mVideoDecoder != NULL &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123; performSetSurface(surface); break; &#125; &#125; // ... çœç•¥å…¶ä»–éƒ¨åˆ†ä»£ç  &#125;&#125; (å››)ã€NuPlayeræºç åˆ†æè¿™æ¬¡æˆ‘ä»¬éœ€è¦æ·±å…¥åˆ†æçš„æ˜¯NuPlayerç±»ï¼Œç›¸æ¯”äºNuPlayerDriverçš„æ¥å£åŠŸèƒ½ï¼ŒNuPlayerç»§æ‰¿è‡ªAHandlerç±»ï¼Œæ˜¯AOSPæ’­æ”¾æ¡†æ¶ä¸­è¿æ¥Sourceã€Decoderã€Renderçš„çº½å¸¦ã€‚ 4.1ã€ä¸»è¦æ¥å£å’Œæ ¸å¿ƒçš„ç±»æˆå‘˜NuPlayerç±»è¢«NuPlayerDriverç›´æ¥è°ƒç”¨ï¼Œå…¶ä¸»è¦æ¥å£å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728293031// code from NuPlayer.h (~/frameworks/av/media/libmediaplayerservice/nuplayer/)struct NuPlayer : public AHandler &#123; NuPlayer(pid_t pid); void setUID(uid_t uid); void setDriver(const wp&lt;NuPlayerDriver&gt; &amp;driver); void setDataSourceAsync(...); void prepareAsync(); void setVideoSurfaceTextureAsync(const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer); void start(); void pause(); // Will notify the driver through \"notifyResetComplete\" once finished. void resetAsync(); // Will notify the driver through \"notifySeekComplete\" once finished // and needNotify is true. void seekToAsync(int64_t seekTimeUs, bool needNotify = false); status_t setVideoScalingMode(int32_t mode); status_t getTrackInfo(Parcel* reply) const; status_t getSelectedTrack(int32_t type, Parcel* reply) const; status_t selectTrack(size_t trackIndex, bool select, int64_t timeUs); status_t getCurrentPosition(int64_t *mediaUs); sp&lt;MetaData&gt; getFileMeta(); float getFrameRate();protected: virtual ~NuPlayer(); virtual void onMessageReceived(const sp&lt;AMessage&gt; &amp;msg);&#125; æ¥å£åˆ†ç±»ä¸‹ï¼Œæ— å¤–ä¹å‡ ä¸ªåˆ†ç±»ï¼š â˜¯ ç”¨äºåˆå§‹åŒ–çš„ï¼ˆæ¯”å¦‚æ„é€ å‡½æ•°ã€setDriver/setDataSourceAsync/prepareAsync/setVideoSurfaceTextureAsyncï¼‰â˜¯ ç”¨äºé”€æ¯çš„ï¼ˆæ¯”å¦‚ææ„å‡½æ•°ã€resetAsyncï¼‰â˜¯ ç”¨äºæ’­æ”¾æ§åˆ¶çš„ï¼ˆæ¯”å¦‚start/pause/seekToAsyncï¼‰â˜¯ ç”¨äºçŠ¶æ€è·å–çš„ï¼ˆæ¯”å¦‚getCurrentPosition/getFileMetaï¼‰ä¸‹é¢æ˜¯ä¸»è¦çš„ç±»æˆå‘˜éƒ¨åˆ† 123456789[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.h]wp&lt;NuPlayerDriver&gt; mDriver; // æ¥å£è°ƒç”¨æ–¹sp&lt;Source&gt; mSource; // ç›¸å½“äºFFmpegä¸­çš„demuxersp&lt;Surface&gt; mSurface; // æ˜¾ç¤ºç”¨çš„Surfacesp&lt;DecoderBase&gt; mVideoDecoder; // è§†é¢‘è§£ç å™¨sp&lt;DecoderBase&gt; mAudioDecoder; // éŸ³é¢‘è§£ç å™¨sp&lt;CCDecoder&gt; mCCDecoder; sp&lt;Renderer&gt; mRenderer; // æ¸²æŸ“å™¨sp&lt;ALooper&gt; mRendererLooper; 4.2ã€setDataSourceAsync()ç°åˆ†æè¿™ä¸ªå‡½æ•°æœ‰å¤šé‡ä¸åŒçš„é‡è½½å½¢å¼ï¼Œå¦‚ä¸‹ï¼š 123456[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.h]void setDataSourceAsync(const sp&lt;IStreamSource&gt; &amp;source);void setDataSourceAsync(const sp&lt;IMediaHTTPService&gt; &amp;httpService, const char *url, const KeyedVector&lt;String8, String8&gt; *headers);void setDataSourceAsync(int fd, int64_t offset, int64_t length);void setDataSourceAsync(const sp&lt;DataSource&gt; &amp;source); éœ€è¦æ ¹æ®å®é™…æƒ…å†µé€‰æ‹©ï¼Œè¿™é‡Œä»¥ç¬¬ä¸‰ä¸ªæ¥å£ä¸ºä¾‹ï¼Œè¯´æ˜ä¸‹å¤šæœ¬åœ°åª’ä½“æ–‡ä»¶æ˜¯å¦‚ä½•å¤„ç†çš„ã€‚ä¸‹é¢æ˜¯è¿™ä¸ªå‡½æ•°çš„å®ç°ä»£ç ï¼š 1234567891011121314[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::setDataSourceAsync(int fd, int64_t offset, int64_t length) &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatSetDataSource, this); sp&lt;AMessage&gt; notify = new AMessage(kWhatSourceNotify, this); // åˆ›å»ºå¯¹è±¡ç”¨äºè¯»å–æœ¬åœ°æ–‡ä»¶ sp&lt;GenericSource&gt; source = new GenericSource(notify, mUIDValid, mUID); // å®é™…å¹²æ´»çš„çš„ä»£ç  status_t err = source-&gt;setDataSource(fd, offset, length); msg-&gt;setObject(\"source\", source); msg-&gt;post();&#125; çœ‹å®ç°å¾ˆç®€å•ï¼Œåˆ›å»ºGenericSourceå¯¹è±¡ï¼Œå¹¶è°ƒç”¨å…¶setDataSourceæ¥å£ï¼Œç„¶åå‘é€kWhatSetDataSourceæ¶ˆæ¯ã€‚æˆ‘ä»¬çœ‹çœ‹å¦‚ä½•å¤„ç†ç„¶åå‘é€kWhatSetDataSourceæ¶ˆæ¯å‘¢ï¼Ÿä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]case kWhatSetDataSource:&#123; CHECK(mSource == NULL); status_t err = OK; sp&lt;RefBase&gt; obj; CHECK(msg-&gt;findObject(\"source\", &amp;obj)); if (obj != NULL) &#123; Mutex::Autolock autoLock(mSourceLock); mSource = static_cast&lt;Source *&gt;(obj.get()); &#125; else &#123; err = UNKNOWN_ERROR; &#125; // é€šçŸ¥Driverå‡½æ•°è°ƒç”¨å®Œæˆ CHECK(mDriver != NULL); sp&lt;NuPlayerDriver&gt; driver = mDriver.promote(); if (driver != NULL) &#123; driver-&gt;notifySetDataSourceCompleted(err); &#125; break;&#125; çœ‹åˆ°è¿™é‡Œå‘ç°ï¼Œå…¶å®æ²¡åšä»€ä¹ˆå°±æ˜¯ç›´æ¥é€šçŸ¥NuPlayerDriverã€‚æˆ‘ä»¬è¿˜æ³¨æ„åˆ°è¿™é‡Œæ„å»ºäº†ä¸€ä¸ªç‰¹æ®Šæ¶ˆæ¯ï¼ˆAMessageï¼‰notifyï¼Œè¿™ä¸ªæ¶ˆæ¯ç”¨äºåœ¨Sourceå’ŒNuPlayerç›´æ¥ä¼ é€’ã€‚ä¸‹é¢è¿™æ˜¯æ¶ˆæ¯å¾ªç¯ä¸­çš„å¤„ç†å‡½æ•°ï¼š 123456[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]case kWhatSourceNotify:&#123; onSourceNotify(msg); break;&#125; åœ¨åç»­è®¨è®ºSourceçš„æ—¶å€™è¯¦ç»†è¯´æ˜è¿™ä¸ªæ¶ˆæ¯é€šçŸ¥çš„æ„ä¹‰ã€‚ 4.3ã€prepareAsync()è¿™ä¸ªå‡½æ•°å®ç°çš„åŠŸèƒ½å¯¹åº”äºMediaPlayerBase::prepare/prepareAsyncæ¥å£ï¼Œå®ç°å¼‚æ­¥çš„prepareåŠŸèƒ½ï¼Œä¸€èˆ¬å°±æ˜¯åšä¸€äº›é¢å¤–çš„åˆå§‹åŒ–å·¥ä½œã€‚é‚£ä¹ˆç›´æ¥çœ‹ä¸€ä¸‹å®ç°ï¼š 1234[-&gt;\\frameworks\\av\\media\\libmediaplayerservice\\nuplayer\\NuPlayer.cpp]void NuPlayer::prepareAsync() &#123; (new AMessage(kWhatPrepare, this))-&gt;post();&#125; ä»£ç å°±æ˜¯å‘äº†ä¸€ä¸ªkWhatPrepareçš„æ¶ˆæ¯ã€‚æ¥ä¸‹æ¥æ˜¯å¦‚ä½•å¤„ç†è¿™ä¸ªæ¶ˆæ¯ã€‚ 12345case kWhatPrepare:&#123; mSource-&gt;prepareAsync(); break;&#125; æœ€ç»ˆè¿˜æ˜¯è°ƒç”¨äº†Source::prepareAsyncæ¥å£ã€‚åé¢ä¼šè§£é‡Šå…¶åŠŸèƒ½ã€‚ï¼ˆè¿™é‡Œé¢å¯èƒ½ä¼šè§£æä¸‹ç æµï¼Œè¯»å–éŸ³é¢‘ã€è§†é¢‘ã€å­—å¹•æµä¿¡æ¯ï¼Œè¯»å–æ—¶é•¿ã€å…ƒæ•°æ®ç­‰ï¼‰ã€‚ 4.4ã€setVideoSurfaceTextureAsync()è°ƒç”¨è¿™ä¸ªæ¥å£ä¸»è¦ä¸ºäº†è®¾ç½®è§†é¢‘æ¸²æŸ“çª—å£ã€‚å…¶å®ç°ç›¸å¯¹ç®€å•ï¼Œåˆ›å»ºä¸€ä¸ªSurfaceï¼Œç„¶åå‘é€å¼‚æ­¥çš„kWhatSetVideoSurfaceæ¶ˆæ¯ã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011void NuPlayer::setVideoSurfaceTextureAsync( const sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123; sp&lt;AMessage&gt; msg = new AMessage(kWhatSetVideoSurface, this); if (bufferProducer == NULL) &#123; msg-&gt;setObject(\"surface\", NULL); &#125; else &#123; msg-&gt;setObject(\"surface\", new Surface(bufferProducer, true /* controlledByApp */)); &#125; msg-&gt;post();&#125; é‚£ä¹ˆçœ‹çœ‹å¦‚ä½•å¤„ç†kWhatSetVideoSurfaceæ¶ˆæ¯å‘¢ï¼Ÿ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546case kWhatSetVideoSurface: &#123; sp&lt;RefBase&gt; obj; CHECK(msg-&gt;findObject(\"surface\", &amp;obj)); sp&lt;Surface&gt; surface = static_cast&lt;Surface *&gt;(obj.get()); // Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might // be in preparing state and it could take long time. // When mStarted is true, mSource must have been set. if (mSource == NULL || !mStarted || mSource-&gt;getFormat(false /* audio */) == NULL // NOTE: mVideoDecoder's mSurface is always non-null || (mVideoDecoder != NULL &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123; performSetSurface(surface); // é€šçŸ¥NuPlayerDriverè®¾ç½®å®Œæˆ break; &#125; // æ¸…ç©ºéŸ³é¢‘ã€è§†é¢‘ç¼“å†² mDeferredActions.push_back( new FlushDecoderAction(FLUSH_CMD_FLUSH /* audio */,FLUSH_CMD_SHUTDOWN /* video */)); // æœ€ç»ˆè°ƒç”¨NuPlayer::performSetSurfaceæ¥å£ mDeferredActions.push_back(new SetSurfaceAction(surface)); if (obj != NULL || mAudioDecoder != NULL) &#123; if (mStarted) &#123; // Issue a seek to refresh the video screen only if started otherwise // the extractor may not yet be started and will assert. // If the video decoder is not set (perhaps audio only in this case) // do not perform a seek as it is not needed. int64_t currentPositionUs = 0; if (getCurrentPosition(&amp;currentPositionUs) == OK) &#123; mDeferredActions.push_back( new SeekAction(currentPositionUs)); &#125; &#125; // å¯¹äºæ–°çš„surfaceè®¾ç½®ï¼Œé‡ç½®ä¸‹è§£ç å™¨ mDeferredActions.push_back(new SimpleAction(&amp;NuPlayer::performScanSources)); &#125; // After a flush without shutdown, decoder is paused. // Don't resume it until source seek is done, otherwise it could // start pulling stale data too soon. mDeferredActions.push_back( new ResumeDecoderAction(false /* needNotify */)); // æŠŠä¸Šé¢mDeferredActionsä¸­ç¼“å­˜çš„æ‰€æœ‰Actionå¤„ç†ä¸‹ï¼Œå¹¶æ¸…ç©º processDeferredActions(); break;&#125; è¿™é‡Œçš„ä»£ç ç›¸å¯¹å¤æ‚ç‚¹ï¼Œæ¶‰åŠåˆ°å¾ˆå¤šï¼Œå…¶å®ä¸»è¦æ˜¯ä¸ºäº†è®¾ç½®Surfaceä¹‹åï¼Œå¯ä»¥æ­£å¸¸è§£ç æ˜¾ç¤ºï¼Œå› ä¸ºæŸäº›æƒ…å†µä¸‹è§£ç å™¨åˆå§‹åŒ–éœ€è¦ä¾èµ–äºå…·ä½“çš„Surfaceã€‚å½“ç„¶ï¼Œé‡Œè¾¹è¿˜æ¶‰åŠåˆ°NuPlayerçŠ¶æ€åŠåˆå§‹åŒ–åˆ¤æ–­ã€‚ 4.5ã€start()/pause()startå‡½æ•°å®ç°å¾ˆç®€å•ï¼Œå®é™…å°±å‘é€äº†kWhatStartæ¶ˆæ¯ã€‚ 123void NuPlayer::start() &#123; (new AMessage(kWhatStart, this))-&gt;post();&#125; åœ¨æ¶ˆæ¯å¤„ç†å‡½æ•°ä¸­çš„å¤„ç†å¦‚ä¸‹ï¼š 12345678910111213case kWhatStart:&#123; if (mStarted) &#123; // do not resume yet if the source is still buffering if (!mPausedForBuffering) &#123; onResume(); &#125; &#125; else &#123; onStart(); &#125; mPausedByClient = false; break;&#125; ç›´æ¥è°ƒç”¨äº†OnStart/OnResumeå‡½æ•°ã€‚pauseå‡½æ•°å®ç°ç±»ä¼¼ï¼Œåªæ˜¯å‘é€çš„æ˜¯kWhatPauseæ¶ˆæ¯ã€‚åœ¨æ¶ˆæ¯å¤„ç†å‡½æ•°ä¸­çš„ä»£ç å¦‚ä¸‹ï¼š 123456case kWhatPause:&#123; onPause(); mPausedByClient = true; break;&#125; ç›´æ¥è°ƒç”¨çš„onPauseå‡½æ•°ã€‚ä¸‹é¢å•ç‹¬åˆ†æä¸‹è¿™ä¸‰ä¸ªå‡½æ•°ã€‚å…ˆä»ç®€å•çš„å‡½æ•°å¼€å§‹OnPause/onResume NuPlayer::onPauseè¿™ä¸ªå‡½æ•°å®ç°æš‚åœåŠŸèƒ½ï¼Œæ€»ä½“æ¥è¯´å°±æ˜¯æŠŠSourceå’ŒRenderæš‚åœå°±å¯ä»¥äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112void NuPlayer::onPause() &#123; if (mPaused) &#123; return; &#125; mPaused = true; if (mSource != NULL) &#123; mSource-&gt;pause(); &#125; if (mRenderer != NULL) &#123; mRenderer-&gt;pause(); &#125;&#125; NuPlayer::onResumeè¿™ä¸ªå‡½æ•°å®ç°æ¢å¤åŠŸèƒ½ï¼Œä»£ç é€»è¾‘è·ŸonPauseå·®ä¸å¤šï¼ŒæŠŠSourceå’ŒRenderæ¢å¤ï¼Œè¿˜å¯èƒ½æ¶‰åŠå…¶å®ƒæ“ä½œã€‚ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617void NuPlayer::onResume() &#123; if (!mPaused || mResetting) &#123; return; &#125; mPaused = false; if (mSource != NULL) &#123; mSource-&gt;resume(); &#125; // |mAudioDecoder| may have been released due to the pause timeout, so re-create it if // needed. if (audioDecoderStillNeeded() &amp;&amp; mAudioDecoder == NULL) &#123; instantiateDecoder(true /* audio */, &amp;mAudioDecoder); &#125; if (mRenderer != NULL) &#123; mRenderer-&gt;resume(); &#125;&#125; NuPlayer::onStartè¿™ä¸ªæ¥å£å®ç°å¯åŠ¨çš„æ“ä½œï¼Œç›¸å¯¹å¤æ‚ç‚¹ï¼Œéœ€è¦åˆå§‹åŒ–è§£ç å™¨ã€åˆå§‹åŒ–Renderã€è®¾ç½®SourceçŠ¶æ€ï¼Œå¹¶å°†ä¸‰è€…å…³è”èµ·æ¥ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233void NuPlayer::onStart(int64_t startPositionUs) &#123; if (!mSourceStarted) &#123; mSourceStarted = true; mSource-&gt;start(); // è®¾ç½®SourceçŠ¶æ€ &#125; // ... (çœç•¥éƒ¨åˆ†ä»£ç ) sp&lt;AMessage&gt; notify = new AMessage(kWhatRendererNotify, this); ++mRendererGeneration; // åˆ›å»ºRenderå’ŒRenderLooperï¼Œå±æ€§è®¾ç½®ã€ä¸è§£ç å™¨å…³è” notify-&gt;setInt32(\"generation\", mRendererGeneration); mRenderer = new Renderer(mAudioSink, notify, flags); mRendererLooper = new ALooper; mRendererLooper-&gt;setName(\"NuPlayerRenderer\"); mRendererLooper-&gt;start(false, false, ANDROID_PRIORITY_AUDIO); mRendererLooper-&gt;registerHandler(mRenderer); status_t err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings); float rate = getFrameRate(); if (rate &gt; 0) &#123; mRenderer-&gt;setVideoFrameRate(rate); &#125; if (mVideoDecoder != NULL) &#123; mVideoDecoder-&gt;setRenderer(mRenderer); &#125; if (mAudioDecoder != NULL) &#123; mAudioDecoder-&gt;setRenderer(mRenderer); &#125; postScanSources();&#125; ä¸Šé¢ä»£ç ä¸­æ²¡æœ‰è§£ç å™¨çš„åˆå§‹åŒ–ï¼Œé‚£åªèƒ½ç»§ç»­çœ‹çœ‹postScanSourcesä»£ç äº†ã€‚çœ‹å®ç°å‘ç°å°±æ˜¯å‘é€äº†kWhatScanSourcesæ¶ˆæ¯ã€‚é‚£ä¹ˆæ¶ˆæ¯å¾ªç¯é‡Œè¾¹æ˜¯æ€ä¹ˆå¤„ç†çš„å‘¢ï¼Ÿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657case kWhatScanSources:&#123; int32_t generation; CHECK(msg-&gt;findInt32(\"generation\", &amp;generation)); if (generation != mScanSourcesGeneration) &#123; // Drop obsolete msg. break; &#125; mScanSourcesPending = false; bool mHadAnySourcesBefore = (mAudioDecoder != NULL) || (mVideoDecoder != NULL); bool rescan = false; // initialize video before audio because successful initialization of // video may change deep buffer mode of audio. if (mSurface != NULL) &#123; // åˆå§‹åŒ–è§†é¢‘è§£ç å™¨ if (instantiateDecoder(false, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123; rescan = true; &#125; &#125; // Don't try to re-open audio sink if there's an existing decoder. if (mAudioSink != NULL &amp;&amp; mAudioDecoder == NULL) &#123; // åˆå§‹åŒ–éŸ³é¢‘è§£ç å™¨ if (instantiateDecoder(true, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123; rescan = true; &#125; &#125; if (!mHadAnySourcesBefore &amp;&amp; (mAudioDecoder != NULL || mVideoDecoder != NULL)) &#123; // This is the first time we've found anything playable. // è®¾ç½®å®šæœŸæŸ¥è¯¢æ—¶é•¿ if (mSourceFlags &amp; Source::FLAG_DYNAMIC_DURATION) &#123; schedulePollDuration(); &#125; &#125; status_t err; // ä¸€äº›å¼‚å¸¸å¤„ç†é€»è¾‘ if ((err = mSource-&gt;feedMoreTSData()) != OK) &#123; if (mAudioDecoder == NULL &amp;&amp; mVideoDecoder == NULL) &#123; // We're not currently decoding anything (no audio or // video tracks found) and we just ran out of input data. if (err == ERROR_END_OF_STREAM) &#123; notifyListener(MEDIA_PLAYBACK_COMPLETE, 0, 0); &#125; else &#123; notifyListener(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err); &#125; &#125; break; &#125; // å¦‚æœéœ€è¦çš„è¯ï¼Œé‡æ–°æ‰«æSource if (rescan) &#123; msg-&gt;post(100000ll); mScanSourcesPending = true; &#125; break;&#125; æ­¤å¤–è¿˜æœ‰seekToAsync()ã€resetAsync()ã€getCurrentPosition()ã€getFileMeta()ã€‚ç”±äºå®ç°ç±»ä¼¼ï¼Œå°±ä¸ä¸€ä¸€ä»‹ç»äº†ã€‚ 4.6ã€å°ç»“ç»“å’Œç–‘é—®åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å·²ç»æŠŠNuPlayerä¸»è¦çš„å‡½æ•°åˆ†æå®Œäº†ï¼Œä½†æ˜¯é—®é¢˜ä¾æ—§åœ¨ã€‚æ¯”å¦‚ä¸‹é¢å‡ ä¸ªï¼š ä¸åŒæ ¼å¼çš„å¤šåª’ä½“æ–‡ä»¶å¦‚ä½•æ¢æµ‹å¹¶è§£æçš„ï¼ŸéŸ³è§†é¢‘æ•°æ®ç¼“å†²åŒºåœ¨å“ªé‡Œï¼Ÿï¼ˆSourceï¼‰è§†é¢‘å¦‚ä½•æ˜¾ç¤ºçš„ï¼ŸéŸ³é¢‘å¦‚ä½•æ’­æ”¾çš„ï¼ŸéŸ³è§†é¢‘åŒæ­¥åœ¨å“ªé‡Œï¼Ÿï¼ˆRendererï¼‰éŸ³é¢‘è§£ç çº¿ç¨‹ã€è§†é¢‘è§£ç çº¿ç¨‹åœ¨å“ªé‡Œï¼Ÿ ï¼ˆDecoderBaseï¼‰ æˆ‘æƒ³æ¥ä¸‹æ¥çš„åˆ†æå°±æ˜¯è§£å†³è¿™äº›ç–‘é—®çš„ã€‚ 4.7ã€Codec Encoder ã€Decoderåˆ—è¡¨é™„å½•123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]&lt;!-- 8996 Decoder capabilities __________________________________________________________________ | Codec | W H fps Mbps MB/s | Secure-dec | |__________|_________________________________________|____________| | h264 | 3840 2160 60 100 1958400 | Y | | | (4096) (2160) (56) (100) | | | hevc | 3840 2160 60 100 1958400 | Y | | | (4096) (2160) (56) (100) | | | mpeg4 | 1920 1088 60 60 489600 | N | | vc1 | 1920 1088 60 60 489600 | Y | | vp8 | 3840 2160 30 100 979200 | N | | vp9 | 3840 2160 30 100 979200 | Y | | divx3 | 720 480 30 2 40500 | N | | div4/5/6 | 1920 1088 30 10 244800 | N | | h263 | 864 480 30 2 48600 | N | | mpeg2 | 1920 1088 30 40 244800 | Y | |__________|_________________________________________|____________| 8996 Encoder capabilities ______________________________________________________ | Codec | W H fps Mbps MB/s | |__________|_________________________________________| | h264 | 3840 2160 30 100 979200 | | hevc | 3840 2160 30 100 979200 | | mpeg4 | 1920 1088 60 60 489600 | | vp8 | 3840 2160 30 100 979200 | | h263 | 864 480 30 2 48600 | |__________|_________________________________________|--&gt;&lt;MediaCodecs&gt; &lt;Include href=\"media_codecs_google_audio.xml\" /&gt; &lt;Include href=\"media_codecs_google_telephony.xml\" /&gt; &lt;Settings&gt; &lt;Setting name=\"max-video-encoder-input-buffers\" value=\"11\" /&gt; &lt;/Settings&gt; &lt;Encoders&gt; &lt;!-- Audio Hardware --&gt; &lt;!-- Audio Software --&gt; &lt;!-- Video Hardware --&gt; &lt;MediaCodec name=\"OMX.qcom.video.encoder.avc\" type=\"video/avc\" &gt; &lt;Quirk name=\"requires-allocate-on-input-ports\" /&gt; &lt;Quirk name=\"requires-allocate-on-output-ports\" /&gt; &lt;Quirk name=\"requires-loaded-to-idle-after-allocation\" /&gt; &lt;Limit name=\"size\" min=\"96x64\" max=\"4096x2160\" /&gt; &lt;Limit name=\"alignment\" value=\"2x2\" /&gt; &lt;Limit name=\"block-size\" value=\"16x16\" /&gt; &lt;Limit name=\"blocks-per-second\" min=\"1\" max=\"979200\" /&gt; &lt;Limit name=\"bitrate\" range=\"1-100000000\" /&gt; &lt;Limit name=\"frame-rate\" range=\"1-240\" /&gt; &lt;Limit name=\"concurrent-instances\" max=\"16\" /&gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.encoder.mpeg4\" type=\"video/mp4v-es\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.encoder.h263\" type=\"video/3gpp\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.encoder.vp8\" type=\"video/x-vnd.on2.vp8\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.encoder.hevc\" type=\"video/hevc\" &gt; ...... &lt;/MediaCodec&gt; &lt;/Encoders&gt; &lt;Decoders&gt; &lt;!-- Video Hardware --&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.avc\" type=\"video/avc\" &gt; &lt;Quirk name=\"requires-allocate-on-input-ports\" /&gt; &lt;Quirk name=\"requires-allocate-on-output-ports\" /&gt; &lt;Limit name=\"size\" min=\"64x64\" max=\"4096x2160\" /&gt; &lt;Limit name=\"alignment\" value=\"2x2\" /&gt; &lt;Limit name=\"block-size\" value=\"16x16\" /&gt; &lt;Limit name=\"blocks-per-second\" min=\"1\" max=\"1958400\" /&gt; &lt;Limit name=\"bitrate\" range=\"1-100000000\" /&gt; &lt;Limit name=\"frame-rate\" range=\"1-240\" /&gt; &lt;Limit name=\"vt-version\" value=\"65537\" /&gt; &lt;Limit name=\"vt-low-latency\" value=\"1\" /&gt; &lt;Limit name=\"vt-max-macroblock-processing-rate\" value=\"972000\" /&gt; &lt;Limit name=\"vt-max-level\" value=\"52\" /&gt; &lt;Limit name=\"vt-max-instances\" value=\"16\" /&gt; &lt;Feature name=\"adaptive-playback\" /&gt; &lt;Limit name=\"concurrent-instances\" max=\"16\" /&gt; &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.avc.secure\" type=\"video/avc\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.mpeg4\" type=\"video/mp4v-es\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.mpeg2\" type=\"video/mpeg2\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.mpeg2.secure\" type=\"video/mpeg2\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.h263\" type=\"video/3gpp\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vc1\" type=\"video/x-ms-wmv\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vc1.secure\" type=\"video/x-ms-wmv\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.divx\" type=\"video/divx\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.divx311\" type=\"video/divx311\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.divx4\" type=\"video/divx4\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vp8\" type=\"video/x-vnd.on2.vp8\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vp9\" type=\"video/x-vnd.on2.vp9\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.vp9.secure\" type=\"video/x-vnd.on2.vp9\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.hevc\" type=\"video/hevc\" &gt; ...... &lt;/MediaCodec&gt; &lt;MediaCodec name=\"OMX.qcom.video.decoder.hevc.secure\" type=\"video/hevc\" &gt; ...... &lt;/MediaCodec&gt; &lt;!-- Audio Software --&gt; &lt;MediaCodec name=\"OMX.qti.audio.decoder.flac\" type=\"audio/flac\" /&gt; &lt;/Decoders&gt; &lt;Include href=\"media_codecs_google_video.xml\" /&gt;&lt;/MediaCodecs&gt; ï¼ˆäº”ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroid NuPlayeræ’­æ”¾æ¡†æ¶ ä¸“æ ï¼šMultiMediaæ¡†æ¶æ€»ç»“(åŸºäº6.0æºç ) - CSDNåšå®¢Androidå¤šåª’ä½“å¼€å‘-å½’æ¡£ | April is your lieAndroid-7.0-Nuplayeræ¦‚è¿° - CSDNåšå®¢Android-7.0-MediaPlayerçŠ¶æ€æœº - CSDNåšå®¢Android-7.0-Nuplayer-å¯åŠ¨æµç¨‹ - CSDNåšå®¢YUV - ç»´åŸºç™¾ç§‘ï¼Œè‡ªç”±çš„ç™¾ç§‘å…¨ä¹¦Android Media Player æ¡†æ¶åˆ†æ-Nuplayerï¼ˆ1ï¼‰ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-AHandler AMessage ALooper - CSDNåšå®¢Android 4.2.2 stagefrightæ¶æ„ - CSDNåšå®¢android4.2.2çš„stagefrightæ¶æ„ä¸‹åŸºäºSurfaceFlingerçš„è§†é¢‘è§£ç è¾“å‡ºç¼“å­˜åˆ›å»ºæœºåˆ¶ - CSDNåšå®¢husanlim çš„ä¸“æ  å‚è€ƒ - CSDNåšå®¢android ACodec MediaCodec NuPlayer flow - CSDNåšå®¢android MediaCodec ACodec - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Audio Systemï¼ˆ3ï¼‰ï¼šAndroid audio system(éŸ³é¢‘ç³»ç»Ÿ)åˆ†æ","slug":"Audio Systemï¼ˆ3ï¼‰ï¼šAndroid audio system[éŸ³é¢‘ç³»ç»Ÿ]åˆ†æ","date":"2018-05-24T16:00:00.000Z","updated":"2018-05-09T15:03:52.335Z","comments":true,"path":"2018/05/25/Audio Systemï¼ˆ3ï¼‰ï¼šAndroid audio system[éŸ³é¢‘ç³»ç»Ÿ]åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/05/25/Audio Systemï¼ˆ3ï¼‰ï¼šAndroid audio system[éŸ³é¢‘ç³»ç»Ÿ]åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - æ—å­¦æ£®çš„Androidä¸“æ ã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Yangwen123 - æ·±å…¥å‰–æAndroidéŸ³é¢‘ç³»ç»Ÿã€‘ã€ç‰¹åˆ«æ„Ÿè°¢ - Zyuanyun - Android éŸ³é¢‘ç³»ç»Ÿï¼šä» AudioTrack åˆ° AudioFlingerã€‘Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆKernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆæ–‡ç« åŸºäº Android 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) æºç ï¼ˆä¸»è¦æºç è·¯å¾„ï¼‰ï¼š User space audio code æºç ï¼š â€¢ /hardware/qcom/audio/hal/ â€“ (Audio é«˜é€šHAL æºç ) â€¢ /libhardware/modules/audio/ â€“ (Audio åŸç”ŸHAL æºç ) â€¢ /external/tinyalsa/ â€“ (tinymix, tinyplay, tinycap æºç ) â€¢ /vendor/qcom/proprietary/mm-audio/ â€“ (QTI OMX audio encoder and decoders æºç ï¼Œæœªå…¬å¼€) â€¢ /frameworks/av/media/audioserver/ â€“ (Audioserver æºç ) â€¢ /hardware/libhardware_legacy/audio â€“ (Audio legacy æºç ) â€¢ /frameworks/av/media/libstagefright/ â€“ (Google Stagefright å¤šåª’ä½“æ¡†æ¶æºç ) â€¢ /frameworks/av/services/audioflinger/ â€“ (Audioflinger ç›¸å…³æºç ) â€¢ /external/bluetooth/bluedroid/ â€“ (A2DP audio HAL ç›¸å…³æºç )/ â€¢ /hardware/libhardware/modules/usbaudio/ â€“ (USB HAL æºç )/ â€¢ /vendor/qcom/proprietary/wfd/mm/source/framework/src/ â€“ (Wi-Fi Display (WFD)ã€ WFDMMSourceAudioSource.cppï¼Œæœªå…¬å¼€) â€¢ /system/core/include/system/ â€“ (audio.h)/ (ä¸€)ã€æ·±å…¥å‰–æAndroidéŸ³é¢‘ä¹‹AudioFlinger1.0ã€æ€»ä½“æ¡†æ¶å›¾ ç³»ç»Ÿå¯åŠ¨æ—¶å°†æ‰§è¡Œ /system/etc/init/audioserver.rc ï¼Œè¿è¡Œ /system/bin/ ç›®å½•ä¸‹çš„ audioserver æœåŠ¡ã€‚audioserver.rc å†…å®¹å¦‚ä¸‹ï¼š 12345678[-&gt;\\frameworks\\av\\media\\audioserver\\audioserver.rc]service audioserver /system/bin/audioserver class main user audioserver # media gid needed for /dev/fm (radio ) and for /data/misc/media (tee) group audio radio camera drmpc inet media mediarm net_bt net_bt_admin net_bw_acct ioprio rt 4 writepid /dev/cpuset/forground/tasks /dev/stune/foreground/tasks audioserver æ˜¯ç”±åŒç›®å½•ä¸‹main_audioserverç¼–è¯‘ç”Ÿæˆçš„ã€‚ 1.1ã€AudioFlingerAudioFlingeræ˜¯æ•´ä¸ªéŸ³é¢‘ç³»ç»Ÿçš„æ ¸å¿ƒä¸éš¾ç‚¹ã€‚ä½œä¸ºAndroidç³»ç»Ÿä¸­çš„éŸ³é¢‘ä¸­æ¢ï¼Œå®ƒåŒæ—¶ä¹Ÿæ˜¯ä¸€ä¸ªç³»ç»ŸæœåŠ¡ï¼Œå¯åˆ°æ‰¿ä¸Š(ä¸ºä¸Šå±‚æä¾›è®¿é—®æ¥å£)å¯ä¸‹(é€šè¿‡HALæ¥ç®¡ç†éŸ³é¢‘è®¾å¤‡)çš„ä½œç”¨ã€‚åªæœ‰ç†è§£äº†AudioFlingerï¼Œæ‰èƒ½ä»¥æ­¤ä¸ºåŸºç¡€æ›´å¥½åœ°æ·±å…¥åˆ°å…¶å®ƒæ¨¡å—ï¼Œå¹¶ä¸”Audioserveræœ€å…ˆå¯åŠ¨çš„ä¹Ÿæ˜¯AudioFlingerï¼Œå› è€Œæˆ‘ä»¬æŠŠå®ƒæ”¾åœ¨å‰é¢è¿›è¡Œåˆ†æã€‚ 1234567891011121314151617181920212223[-&gt;\\frameworks\\av\\media\\audioserver\\main_audioserver.cpp]int main(int argc __unused, char **argv)&#123; ...... if (doLog &amp;&amp; (childPid = fork()) != 0) &#123; ...... &#125; else &#123; // all other services if (doLog) &#123; prctl(PR_SET_PDEATHSIG, SIGKILL); // if parent media.log dies before me, kill me also setpgid(0, 0); // but if I die first, don't kill my parent &#125; sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(\"ServiceManager: %p\", sm.get()); AudioFlinger::instantiate(); AudioPolicyService::instantiate(); RadioService::instantiate(); SoundTriggerHwService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); &#125;&#125; AudioFlingerç»§æ‰¿äº†æ¨¡æ¿ç±»BinderServiceï¼Œè¯¥ç±»ç”¨äºæ³¨å†Œnative serviceã€‚BinderServiceæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œè¯¥ç±»çš„publishå‡½æ•°å°±æ˜¯å®Œæˆå‘ServiceManageræ³¨å†ŒæœåŠ¡ã€‚AudioFlingeræ³¨å†Œåä¸ºâ€media.audio_flingerâ€çš„æœåŠ¡ã€‚1static const char* getServiceName() ANDROID_API &#123; return \"media.audio_flinger\"; &#125; 1.1.1 AudioFlingeræœåŠ¡çš„å¯åŠ¨å’Œè¿è¡ŒAudioFlingerçš„æ„é€ å‡½æ•°ï¼Œå‘ç°å®ƒåªæ˜¯ç®€å•åœ°ä¸ºå†…éƒ¨ä¸€äº›å˜é‡åšäº†åˆå§‹åŒ–ï¼Œé™¤æ­¤ä¹‹å¤–å°±æ²¡æœ‰ä»»ä½•ä»£ç äº†ï¼š 1234567891011121314151617181920212223[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]AudioFlinger::AudioFlinger() : BnAudioFlinger(), mPrimaryHardwareDev(NULL), mAudioHwDevs(NULL), mHardwareStatus(AUDIO_HW_IDLE), mMasterVolume(1.0f), mMasterMute(false), // mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX), mMode(AUDIO_MODE_INVALID), mBtNrecIsOff(false), mIsLowRamDevice(true), mIsDeviceTypeKnown(false), mGlobalEffectEnableTime(0), mSystemReady(false)&#123; // unsigned instead of audio_unique_id_use_t, because ++ operator is unavailable for enum for (unsigned use = AUDIO_UNIQUE_ID_USE_UNSPECIFIED; use &lt; AUDIO_UNIQUE_ID_USE_MAX; use++) &#123; // zero ID has a special meaning, so unavailable mNextUniqueIds[use] = AUDIO_UNIQUE_ID_USE_MAX; &#125; ......&#125; BnAudioFlingeræ˜¯ç”±RefBaseå±‚å±‚ç»§æ‰¿è€Œæ¥çš„ï¼Œå¹¶ä¸”IServiceManager::addServiceçš„ç¬¬äºŒä¸ªå‚æ•°å®é™…ä¸Šæ˜¯ä¸€ä¸ªå¼ºæŒ‡é’ˆå¼•ç”¨(constsp&amp;),å› è€ŒAudioFlingerå…·å¤‡äº†å¼ºæŒ‡é’ˆè¢«ç¬¬ä¸€æ¬¡å¼•ç”¨æ—¶è°ƒç”¨onFirstRefçš„ç¨‹åºé€»è¾‘ã€‚ 1234567891011121314151617181920212223[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]void AudioFlinger::onFirstRef()&#123; Mutex::Autolock _l(mLock); /* TODO: move all this work into an Init() function */ char val_str[PROPERTY_VALUE_MAX] = &#123; 0 &#125;; if (property_get(\"ro.audio.flinger_standbytime_ms\", val_str, NULL) &gt;= 0) &#123; uint32_t int_val; if (1 == sscanf(val_str, \"%u\", &amp;int_val)) &#123; mStandbyTimeInNsecs = milliseconds(int_val); ALOGI(\"Using %u mSec as standby time.\", int_val); &#125; else &#123; mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs; ALOGI(\"Using default %u mSec as standby time.\", (uint32_t)(mStandbyTimeInNsecs / 1000000)); &#125; &#125; mPatchPanel = new PatchPanel(this); mMode = AUDIO_MODE_NORMAL;&#125; ä»è¿™æ—¶å¼€å§‹ï¼ŒAudioFlingerå°±æ˜¯ä¸€ä¸ªâ€œæœ‰æ„ä¹‰â€çš„å®ä½“äº† 1.2ã€éŸ³é¢‘è®¾å¤‡çš„ç®¡ç†è™½ç„¶AudioFlingerå®ä½“å·²ç»æˆåŠŸåˆ›å»ºå¹¶åˆå§‹åŒ–ï¼Œä½†åˆ°ç›®å‰ä¸ºæ­¢å®ƒè¿˜æ˜¯ä¸€å—é™æ€çš„å†…å­˜ç©ºé—´ï¼Œæ²¡æœ‰æ¶‰åŠåˆ°å…·ä½“çš„å·¥ä½œã€‚ ä»èŒèƒ½åˆ†å¸ƒä¸Šæ¥è®²ï¼ŒAudioPolicyServiceæ˜¯ç­–ç•¥çš„åˆ¶å®šè€…ï¼Œæ¯”å¦‚ä»€ä¹ˆæ—¶å€™æ‰“å¼€éŸ³é¢‘æ¥å£è®¾å¤‡ã€æŸç§Streamç±»å‹çš„éŸ³é¢‘å¯¹åº”ä»€ä¹ˆè®¾å¤‡ç­‰ç­‰ã€‚è€ŒAudioFlingeråˆ™æ˜¯ç­–ç•¥çš„æ‰§è¡Œè€…ï¼Œä¾‹å¦‚å…·ä½“å¦‚ä½•ä¸éŸ³é¢‘è®¾å¤‡é€šä¿¡ï¼Œå¦‚ä½•ç»´æŠ¤ç°æœ‰ç³»ç»Ÿä¸­çš„éŸ³é¢‘è®¾å¤‡ï¼Œä»¥åŠå¤šä¸ªéŸ³é¢‘æµçš„æ··éŸ³å¦‚ä½•å¤„ç†ç­‰ç­‰éƒ½å¾—ç”±å®ƒæ¥å®Œæˆã€‚ ç›®å‰Audioç³»ç»Ÿä¸­æ”¯æŒçš„éŸ³é¢‘è®¾å¤‡æ¥å£(Audio Interface)åˆ†ä¸ºä¸‰å¤§ç±»ï¼Œå³ï¼š 123456[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]static const char * const audio_interfaces[] = &#123; AUDIO_HARDWARE_MODULE_ID_PRIMARY, AUDIO_HARDWARE_MODULE_ID_A2DP, AUDIO_HARDWARE_MODULE_ID_USB,&#125;; æ¯ç§éŸ³é¢‘è®¾å¤‡æ¥å£ç”±ä¸€ä¸ªå¯¹åº”çš„soåº“æä¾›æ”¯æŒã€‚é‚£ä¹ˆAudioFlingeræ€ä¹ˆä¼šçŸ¥é“å½“å‰è®¾å¤‡ä¸­æ”¯æŒä¸Šè¿°çš„å“ªäº›æ¥å£ï¼Œæ¯ç§æ¥å£åˆæ”¯æŒå“ªäº›å…·ä½“çš„éŸ³é¢‘è®¾å¤‡å‘¢ï¼Ÿè¿™æ˜¯AudioPolicyServiceçš„è´£ä»»ä¹‹ä¸€ï¼Œå³æ ¹æ®ç”¨æˆ·é…ç½®æ¥æŒ‡å¯¼AudioFlingeråŠ è½½è®¾å¤‡æ¥å£ã€‚ å½“AudioPolicyManagerBase(AudioPolicyServiceä¸­æŒæœ‰çš„Policyç®¡ç†è€…ï¼Œåé¢å°èŠ‚æœ‰è¯¦ç»†ä»‹ç»)æ„é€ æ—¶ï¼Œå®ƒä¼šè¯»å–å‚å•†å…³äºéŸ³é¢‘è®¾å¤‡çš„æè¿°æ–‡ä»¶(audio_policy.conf)ï¼Œç„¶åæ®æ­¤æ¥æ‰“å¼€ä»¥ä¸Šä¸‰ç±»éŸ³é¢‘æ¥å£(å¦‚æœå­˜åœ¨çš„è¯)ã€‚è¿™ä¸€è¿‡ç¨‹æœ€ç»ˆä¼šè°ƒç”¨loadHwModule@AudioFlingerï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 1.2.1ã€åŠ è½½è®¾å¤‡loadHwModule()12345678910111213[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]/*nameå°±æ˜¯å‰é¢audio_interfaces æ•°ç»„æˆå‘˜ä¸­çš„å­—ç¬¦ä¸²*/audio_module_handle_t AudioFlinger::loadHwModule(const char *name)&#123; if (name == NULL) &#123; return AUDIO_MODULE_HANDLE_NONE; &#125; if (!settingsAllowed()) &#123; return AUDIO_MODULE_HANDLE_NONE; &#125; Mutex::Autolock _l(mLock); return loadHwModule_l(name);&#125; è¿™ä¸ªå‡½æ•°æ²¡æœ‰åšå®è´¨æ€§çš„å·¥ä½œï¼Œåªæ˜¯æ‰§è¡Œäº†åŠ é”åŠ¨ä½œï¼Œç„¶åæ¥ç€è°ƒç”¨ä¸‹é¢çš„å‡½æ•°ï¼š 12345678910111213141516171819202122232425262728293031[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]// loadHwModule_l() must be called with AudioFlinger::mLock heldaudio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)&#123; /* Step 1. æ˜¯å¦å·²ç»æ·»åŠ äº†è¿™ä¸ªinterface ? */ for (size_t i = 0; i &lt; mAudioHwDevs.size(); i++) &#123; if (strncmp(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, strlen(name)) == 0) &#123; ALOGW(&quot;loadHwModule() module %s already loaded&quot;, name); return mAudioHwDevs.keyAt(i); &#125; &#125; audio_hw_device_t *dev; /* Step 2. åŠ è½½audio interface */ int rc = load_audio_interface(name, &amp;dev); ...... /* Step 3. åˆå§‹åŒ– */ mHardwareStatus = AUDIO_HW_INIT; rc = dev-&gt;init_check(dev); mHardwareStatus = AUDIO_HW_IDLE; ...... /* Step 4. æ·»åŠ åˆ°å…¨å±€å˜é‡ä¸­ */ audio_module_handle_t handle = (audio_module_handle_t) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE); mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags)); return handle;&#125; Step1@ loadHwModule_l. é¦–å…ˆæŸ¥æ‰¾mAudioHwDevsæ˜¯å¦å·²ç»æ·»åŠ äº†å˜é‡nameæ‰€æŒ‡ç¤ºçš„audio interfaceï¼Œå¦‚æœæ˜¯çš„è¯ç›´æ¥è¿”å›ã€‚ç¬¬ä¸€æ¬¡è¿›å…¥æ—¶mAudioHwDevsçš„sizeä¸º0ï¼Œæ‰€ä»¥è¿˜ä¼šç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚ Step2@ loadHwModule_l. åŠ è½½æŒ‡å®šçš„audiointerfaceï¼Œæ¯”å¦‚â€œprimaryâ€ã€â€œa2dpâ€æˆ–è€…â€œusbâ€ã€‚å‡½æ•°load_audio_interfaceç”¨æ¥åŠ è½½è®¾å¤‡æ‰€éœ€çš„åº“æ–‡ä»¶ï¼Œç„¶åæ‰“å¼€è®¾å¤‡å¹¶åˆ›å»ºä¸€ä¸ªaudio_hw_device_tå®ä¾‹ã€‚éŸ³é¢‘æ¥å£è®¾å¤‡æ‰€å¯¹åº”çš„åº“æ–‡ä»¶åç§°æ˜¯æœ‰ä¸€å®šæ ¼å¼çš„ï¼Œæ¯”å¦‚a2dpçš„æ¨¡å—åå¯èƒ½æ˜¯audio.a2dp.soæˆ–è€…audio.a2dp.default.soç­‰ç­‰ã€‚æŸ¥æ‰¾è·¯å¾„ä¸»è¦æœ‰ä¸¤ä¸ªï¼Œå³ï¼š 1234[-&gt;\\hardware\\libhardware\\hardware.c]#define HAL_LIBRARY_PATH1 \"/system/lib64/hw\"#define HAL_LIBRARY_PATH2 \"/vendor/lib64/hw\"#define HAL_LIBRARY_PATH3 \"/odm/lib64/hw\" å½“ç„¶ï¼Œå› ä¸ºAndroidæ˜¯å®Œå…¨å¼€æºçš„ï¼Œå„å¼€å‘å•†å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€è¦æ¥è¿›è¡Œç›¸åº”çš„ä¿®æ”¹ï¼Œæ¯”å¦‚ä¸‹é¢æ˜¯Google pixel è®¾å¤‡çš„éŸ³é¢‘åº“ï¼š 123456789adb shell &amp;&amp; cd system/lib64/hw &amp;&amp; ls -l-rw-r--r-- 1 root root 30440 2009-01-01 00:00 audio.a2dp.default.so-rw-r--r-- 1 root root 18156 2009-01-01 00:00 audio.primary.default.so-rw-r--r-- 1 root root 275612 2009-01-01 00:00 audio.primary.msm8996.so-rw-r--r-- 1 root root 34540 2009-01-01 00:00 audio.r_submix.default.so-rw-r--r-- 1 root root 22248 2009-01-01 00:00 audio.usb.default.so-rw-r--r-- 1 root root 96096 2009-01-01 00:00 audio_policy.default.so-rw-r--r-- 1 root root 1637208 2009-01-01 00:00 bluetooth.default.so...... Step3@ loadHwModule_lï¼Œè¿›è¡Œåˆå§‹åŒ–æ“ä½œã€‚å…¶ä¸­init_checkæ˜¯ä¸ºäº†ç¡®å®šè¿™ä¸ªaudio interfaceæ˜¯å¦å·²ç»æˆåŠŸåˆå§‹åŒ–ï¼Œ0æ˜¯æˆåŠŸï¼Œå…¶å®ƒå€¼è¡¨ç¤ºå¤±è´¥ã€‚æ¥ä¸‹æ¥å¦‚æœè¿™ä¸ªdeviceæ”¯æŒä¸»éŸ³é‡ï¼Œæˆ‘ä»¬è¿˜éœ€è¦é€šè¿‡set_master_volumeè¿›è¡Œè®¾ç½®ã€‚åœ¨æ¯æ¬¡æ“ä½œdeviceå‰ï¼Œéƒ½è¦å…ˆæ”¹å˜mHardwareStatusçš„çŠ¶æ€å€¼ï¼Œæ“ä½œç»“æŸåå°†å…¶å¤åŸä¸ºAUDIO_HW_IDLE(æ ¹æ®æºç ä¸­çš„æ³¨é‡Šï¼Œè¿™æ ·åšæ˜¯ä¸ºäº†æ–¹ä¾¿dumpæ—¶æ­£ç¡®è¾“å‡ºå†…éƒ¨çŠ¶æ€ï¼Œè¿™é‡Œæˆ‘ä»¬å°±ä¸å»æ·±ç©¶äº†)ã€‚ Step4@ loadHwModule_l. æŠŠåŠ è½½åçš„è®¾å¤‡æ·»åŠ å…¥mAudioHwDevsé”®å€¼å¯¹ä¸­ï¼Œå…¶ä¸­keyçš„å€¼æ˜¯ç”±nextUniqueIdç”Ÿæˆçš„ï¼Œè¿™æ ·åšä¿è¯äº†è¿™ä¸ªaudiointerfaceæ‹¥æœ‰å…¨å±€å”¯ä¸€çš„idå·ã€‚ å®Œæˆäº†audiointerfaceçš„æ¨¡å—åŠ è½½åªæ˜¯ä¸‡é‡Œé•¿å¾çš„ç¬¬ä¸€æ­¥ã€‚å› ä¸ºæ¯ä¸€ä¸ªinterfaceåŒ…å«çš„è®¾å¤‡é€šå¸¸ä¸æ­¢ä¸€ä¸ªï¼ŒAndroidç³»ç»Ÿç›®å‰æ”¯æŒçš„éŸ³é¢‘è®¾å¤‡å¦‚ä¸‹åˆ—è¡¨æ‰€ç¤ºï¼š Androidç³»ç»Ÿæ”¯æŒçš„éŸ³é¢‘è®¾å¤‡åˆ—è¡¨(è¾“å‡º) 1234567891011121314151617181920[-&gt;\\hardware\\libhardware_legacy\\audio\\audio_hw_hal.cpp]static uint32_t audio_device_conv_table[][HAL_API_REV_NUM] =&#123; /* output devices */ &#123; AudioSystem::DEVICE_OUT_EARPIECE, AUDIO_DEVICE_OUT_EARPIECE &#125;,// &#123; AudioSystem::DEVICE_OUT_SPEAKER, AUDIO_DEVICE_OUT_SPEAKER &#125;,//SPEAKER &#123; AudioSystem::DEVICE_OUT_WIRED_HEADSET, AUDIO_DEVICE_OUT_WIRED_HEADSET &#125;,//HEADSET &#123; AudioSystem::DEVICE_OUT_WIRED_HEADPHONE, AUDIO_DEVICE_OUT_WIRED_HEADPHONE &#125;,//HEADPHONE &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO, AUDIO_DEVICE_OUT_BLUETOOTH_SCO &#125;, &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET &#125;, &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT &#125;, &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP &#125;, &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES &#125;, &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER &#125;, &#123; AudioSystem::DEVICE_OUT_AUX_DIGITAL, AUDIO_DEVICE_OUT_AUX_DIGITAL &#125;, &#123; AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET, AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET &#125;, &#123; AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET, AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET &#125;, &#123; AudioSystem::DEVICE_OUT_DEFAULT, AUDIO_DEVICE_OUT_DEFAULT &#125;,//é»˜è®¤è®¾å¤‡ ......&#125; å¤§å®¶å¯èƒ½ä¼šæœ‰ç–‘é—®ï¼š Ã˜ è¿™ä¹ˆå¤šçš„è¾“å‡ºè®¾å¤‡ï¼Œé‚£ä¹ˆå½“æˆ‘ä»¬å›æ”¾éŸ³é¢‘æµ(å½•éŸ³ä¹Ÿæ˜¯ç±»ä¼¼çš„æƒ…å†µ)æ—¶ï¼Œè¯¥é€‰æ‹©å“ªä¸€ç§å‘¢ï¼Ÿ Ã˜ è€Œä¸”å½“å‰ç³»ç»Ÿä¸­audio interfaceä¹Ÿå¾ˆå¯èƒ½ä¸æ­¢ä¸€ä¸ªï¼Œåº”è¯¥å¦‚ä½•é€‰æ‹©ï¼Ÿ æ˜¾ç„¶è¿™äº›å†³ç­–å·¥ä½œå°†ç”±AudioPolicyServiceæ¥å®Œæˆï¼Œæˆ‘ä»¬ä¼šåœ¨ä¸‹ä¸€å°èŠ‚åšè¯¦ç»†é˜è¿°ã€‚è¿™é‡Œå…ˆç»™å¤§å®¶åˆ†æä¸‹ï¼ŒAudioFlingeræ˜¯å¦‚ä½•æ‰“å¼€ä¸€ä¸ªOutputé€šé“çš„(ä¸€ä¸ªaudiointerfaceå¯èƒ½åŒ…å«è‹¥å¹²ä¸ªoutput)ã€‚ 1.2.2ã€æ‰“å¼€éŸ³é¢‘è¾“å‡ºé€šé“openOutput()æ‰“å¼€éŸ³é¢‘è¾“å‡ºé€šé“(output)åœ¨AudioFlingerä¸­å¯¹åº”çš„æ¥å£æ˜¯openOutput()ï¼Œå³ï¼š 1234567891011121314151617181920212223242526272829303132333435[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]status_t AudioFlinger::openOutput(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t *devices, const String8&amp; address, uint32_t *latencyMs, audio_output_flags_t flags)&#123; ...... Mutex::Autolock _l(mLock); sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags); if (thread != 0) &#123; *latencyMs = thread-&gt;latency(); // notify client processes of the new output creation thread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED); // the first primary output opened designates the primary hw device if ((mPrimaryHardwareDev == NULL) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123; ALOGI(\"Using module %d has the primary audio interface\", module); mPrimaryHardwareDev = thread-&gt;getOutput()-&gt;audioHwDev; AutoMutex lock(mHardwareLock); mHardwareStatus = AUDIO_HW_SET_MODE; mPrimaryHardwareDev-&gt;hwDevice()-&gt;set_mode(mPrimaryHardwareDev-&gt;hwDevice(), mMode); mHardwareStatus = AUDIO_HW_IDLE; &#125; return NO_ERROR; &#125; return NO_INIT;&#125; ç»§ç»­è°ƒç”¨ openOutput_l()å‡½æ•°ä»å¤„ç†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t devices, const String8&amp; address, audio_output_flags_t flags)&#123; /*Step 1. æŸ¥æ‰¾ç›¸åº”çš„audio interface AudioHwDevice *outHwDev = findSuitableHwDev_l(module, devices); ...... mHardwareStatus = AUDIO_HW_OUTPUT_OPEN; ...... AudioStreamOut *outputStream = NULL; /*Step 2. ä¸ºè®¾å¤‡æ‰“å¼€ä¸€ä¸ªè¾“å‡ºæµ*/ status_t status = outHwDev-&gt;openOutputStream( &amp;outputStream, *output, devices, flags, config, address.string()); mHardwareStatus = AUDIO_HW_IDLE; /*Step 3.åˆ›å»ºPlaybackThread*/ if (status == NO_ERROR) &#123; PlaybackThread *thread; if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123; thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady); ALOGV(\"openOutput_l() created offload output: ID %d thread %p\", *output, thread); &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT) || !isValidPcmSinkFormat(config-&gt;format) || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123; thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady); ALOGV(\"openOutput_l() created direct output: ID %d thread %p\", *output, thread); &#125; else &#123; thread = new MixerThread(this, outputStream, *output, devices, mSystemReady); ALOGV(\"openOutput_l() created mixer output: ID %d thread %p\", *output, thread); &#125; mPlaybackThreads.add(*output, thread); return thread; &#125; return 0;&#125; ä¸Šé¢è¿™æ®µä»£ç ä¸­ï¼Œé¢œè‰²åŠ æ·±çš„éƒ¨åˆ†æ˜¯æˆ‘ä»¬æ¥ä¸‹æ¥åˆ†æçš„é‡ç‚¹ï¼Œä¸»è¦è¿˜æ˜¯å›´ç»•outHwDevè¿™ä¸ªå˜é‡æ‰€åšçš„ä¸€ç³»åˆ—æ“ä½œï¼Œå³ï¼š Â· æŸ¥æ‰¾åˆé€‚çš„éŸ³é¢‘æ¥å£è®¾å¤‡( findSuitableHwDev_l() ) Â· åˆ›å»ºéŸ³é¢‘è¾“å‡ºæµ( é€šè¿‡openOutputStream()åˆ›å»ºAudioStreamOut ) Â· åˆ›å»ºæ’­æ”¾çº¿ç¨‹( PlaybackThread ) outHwDevç”¨äºè®°å½•ä¸€ä¸ªæ‰“å¼€çš„éŸ³é¢‘æ¥å£è®¾å¤‡ï¼Œå®ƒçš„æ•°æ®ç±»å‹æ˜¯audio_hw_device_tï¼Œæ˜¯ç”±HALè§„å®šçš„ä¸€ä¸ªéŸ³é¢‘æ¥å£è®¾å¤‡æ‰€åº”å…·æœ‰çš„å±æ€§é›†åˆï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516171819202122[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioHwDevice.h]class AudioHwDevice &#123;...... audio_module_handle_t handle() const &#123; return mHandle; &#125; const char *moduleName() const &#123; return mModuleName; &#125; audio_hw_device_t *hwDevice() const &#123; return mHwDevice; &#125; uint32_t version() const &#123; return mHwDevice-&gt;common.version; &#125; status_t openOutputStream( AudioStreamOut **ppStreamOut, audio_io_handle_t handle, audio_devices_t devices, audio_output_flags_t flags, struct audio_config *config, const char *address);private: const audio_module_handle_t mHandle; const char * const mModuleName; audio_hw_device_t * const mHwDevice; const Flags mFlags;&#125;;&#125; å…¶ä¸­commonä»£è¡¨äº†HALå±‚æ‰€æœ‰è®¾å¤‡çš„å…±æœ‰å±æ€§;set_master_volumeã€set_modeã€open_output_streamåˆ†åˆ«ä¸ºæˆ‘ä»¬è®¾ç½®audio interfaceçš„ä¸»éŸ³é‡ã€è®¾ç½®éŸ³é¢‘æ¨¡å¼ç±»å‹(æ¯”å¦‚AUDIO_MODE_RINGTONEã€AUDIO_MODE_IN_CALLç­‰ç­‰)ã€æ‰“å¼€è¾“å‡ºæ•°æ®æµæä¾›äº†æ¥å£ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬åˆ†æ­¥æ¥é˜è¿°ã€‚ 1.2.2.1ã€æŸ¥æ‰¾åˆé€‚çš„éŸ³é¢‘æ¥å£è®¾å¤‡findSuitableHwDev_l()Step1@ AudioFlinger::openOutput. åœ¨openOutputä¸­ï¼Œè®¾å¤‡outHwDevæ˜¯é€šè¿‡æŸ¥æ‰¾å½“å‰ç³»ç»Ÿæ¥å¾—åˆ°çš„ï¼Œä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]AudioHwDevice* AudioFlinger::findSuitableHwDev_l( audio_module_handle_t module, audio_devices_t devices)&#123; // if module is 0, the request comes from an old policy manager and we should load // well known modules if (module == 0) &#123; ALOGW(\"findSuitableHwDev_l() loading well know audio hw modules\"); for (size_t i = 0; i &lt; ARRAY_SIZE(audio_interfaces); i++) &#123; loadHwModule_l(audio_interfaces[i]); &#125; // then try to find a module supporting the requested device. for (size_t i = 0; i &lt; mAudioHwDevs.size(); i++) &#123; AudioHwDevice *audioHwDevice = mAudioHwDevs.valueAt(i); audio_hw_device_t *dev = audioHwDevice-&gt;hwDevice(); if ((dev-&gt;get_supported_devices != NULL) &amp;&amp; (dev-&gt;get_supported_devices(dev) &amp; devices) == devices) return audioHwDevice; &#125; &#125; else &#123; // check a match for the requested module handle AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(module); if (audioHwDevice != NULL) &#123; return audioHwDevice; &#125; &#125; return NULL;&#125; å˜é‡moduleå€¼ä¸º0çš„æƒ…å†µï¼Œæ˜¯ä¸ºäº†å…¼å®¹ä¹‹å‰çš„Audio Policyè€Œç‰¹åˆ«åšçš„å¤„ç†ã€‚å½“moduleç­‰äº0æ—¶ï¼Œé¦–å…ˆåŠ è½½æ‰€æœ‰å·²çŸ¥çš„éŸ³é¢‘æ¥å£è®¾å¤‡ï¼Œç„¶åå†æ ¹æ®devicesæ¥ç¡®å®šå…¶ä¸­ç¬¦åˆè¦æ±‚çš„ã€‚å…¥å‚devicesçš„å€¼å®é™…ä¸Šæ¥æºäºâ€œ Androidç³»ç»Ÿæ”¯æŒçš„éŸ³é¢‘è®¾å¤‡åˆ—è¡¨(è¾“å‡º)â€æ‰€ç¤ºçš„è®¾å¤‡ã€‚å¯ä»¥çœ‹åˆ°ï¼Œenumä¸­æ¯ä¸ªè®¾å¤‡ç±»å‹éƒ½å¯¹åº”ä¸€ä¸ªç‰¹å®šçš„æ¯”ç‰¹ä½ï¼Œå› è€Œä¸Šè¿°ä»£ç æ®µä¸­å¯ä»¥é€šè¿‡â€œä¸è¿ç®—â€æ¥æ‰¾åˆ°åŒ¹é…çš„è®¾å¤‡ã€‚ å½“modulesä¸ºé0å€¼æ—¶ï¼Œè¯´æ˜Audio PolicyæŒ‡å®šäº†å…·ä½“çš„è®¾å¤‡idå·ï¼Œè¿™æ—¶å°±é€šè¿‡æŸ¥æ‰¾å…¨å±€çš„mAudioHwDevså˜é‡æ¥ç¡®è®¤æ˜¯å¦å­˜åœ¨ç¬¦åˆè¦æ±‚çš„è®¾å¤‡ã€‚ 12[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.h]DefaultKeyedVector&lt;audio_module_handle_t, AudioHwDevice*&gt; mAudioHwDevs; å˜é‡mAudioHwDevsæ˜¯ä¸€ä¸ªVectorï¼Œä»¥audio_module_handle_tä¸ºkeyï¼Œæ¯ä¸€ä¸ªhandleå€¼å”¯ä¸€ç¡®å®šäº†å·²ç»æ·»åŠ çš„éŸ³é¢‘è®¾å¤‡ã€‚é‚£ä¹ˆåœ¨ä»€ä¹ˆæ—¶å€™æ·»åŠ è®¾å¤‡å‘¢ï¼Ÿ ä¸€ç§æƒ…å†µå°±æ˜¯å‰é¢çœ‹åˆ°çš„modulesä¸º0æ—¶ï¼Œä¼šloadæ‰€æœ‰æ½œåœ¨è®¾å¤‡ï¼Œå¦ä¸€ç§æƒ…å†µå°±æ˜¯AudioPolicyManagerBaseåœ¨æ„é€ æ—¶ä¼šé¢„åŠ è½½æ‰€æœ‰audio_policy.confä¸­æ‰€æè¿°çš„outputã€‚ä¸ç®¡æ˜¯å“ªä¸€ç§æƒ…å†µï¼Œæœ€ç»ˆéƒ½ä¼šè°ƒç”¨loadHwModuleÃ loadHwModule_lï¼Œè¿™ä¸ªå‡½æ•°æˆ‘ä»¬å¼€å¤´å°±åˆ†æè¿‡äº†ã€‚ å¦‚æœmodulesä¸ºé0ï¼Œä¸”ä»mAudioHwDevsä¸­ä¹Ÿæ‰¾ä¸åˆ°ç¬¦åˆè¦æ±‚çš„è®¾å¤‡ï¼Œç¨‹åºå¹¶ä¸ä¼šå°±æ­¤ç»ˆç»“â€”â€”å®ƒä¼šé€€è€Œæ±‚å…¶æ¬¡ï¼Œéå†æ•°ç»„ä¸­çš„æ‰€æœ‰å…ƒç´ å¯»æ‰¾æ”¯æŒdevicesçš„ä»»ä½•ä¸€ä¸ªaudio interfaceã€‚ 1.2.2.2ã€åˆ›å»ºéŸ³é¢‘è¾“å‡ºæµopenOutputStream()Step2@ AudioFlinger::openOutputï¼Œè°ƒç”¨openOutputStream()å‡½æ•°æ‰“å¼€ä¸€ä¸ªAudioStreamOut ã€‚æºç å®ç°å¦‚ä¸‹ï¼š 12345678910111213141516171819[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioHwDevice.cpp]status_t AudioHwDevice::openOutputStream( AudioStreamOut **ppStreamOut, audio_io_handle_t handle, audio_devices_t devices, audio_output_flags_t flags, struct audio_config *config, const char *address)&#123; struct audio_config originalConfig = *config; AudioStreamOut *outputStream = new AudioStreamOut(this, flags); status_t status = outputStream-&gt;open(handle, devices, config, address); ...... *ppStreamOut = outputStream; return status;&#125; ç”ŸæˆAudioStreamOutå¯¹è±¡å¹¶èµ‹å€¼ç»™ppStreamOut ï¼Œè¿›ä¸€æ­¥è°ƒç”¨äº†AudioStreamOut-&gt;open()å‡½æ•°ã€‚ 1234567891011121314151617181920[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioStreamOut.cpp]status_t AudioStreamOut::open( audio_io_handle_t handle, audio_devices_t devices, struct audio_config *config, const char *address)&#123; audio_stream_out_t *outStream; ....... int status = hwDev()-&gt;open_output_stream( hwDev(), handle, devices, customFlags, config, &amp;outStream, address); ...... return status;&#125; å³ä¼šé€šè¿‡audio_hw_device_t-&gt;-&gt;open_output_stream()åˆ›å»ºéŸ³é¢‘è¾“å‡ºæµ 1.2.2.2.1ã€audio_hw_device_t-&gt;-&gt;open_output_stream()æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹HALå±‚ä»£ç  1234567891011121314151617181920212223242526272829303132[-&gt;\\hardware\\qcom\\audio\\hal\\audio_hw.c]static int adev_open(const hw_module_t *module, const char *name, hw_device_t **device)&#123; ...... adev = calloc(1, sizeof(struct audio_device)); pthread_mutex_init(&amp;adev-&gt;lock, (const pthread_mutexattr_t *) NULL); adev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; adev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0; adev-&gt;device.common.module = (struct hw_module_t *)module; adev-&gt;device.common.close = adev_close; adev-&gt;device.init_check = adev_init_check; adev-&gt;device.set_voice_volume = adev_set_voice_volume; adev-&gt;device.set_master_volume = adev_set_master_volume; adev-&gt;device.get_master_volume = adev_get_master_volume; adev-&gt;device.set_master_mute = adev_set_master_mute; adev-&gt;device.get_master_mute = adev_get_master_mute; adev-&gt;device.set_mode = adev_set_mode; adev-&gt;device.set_mic_mute = adev_set_mic_mute; adev-&gt;device.get_mic_mute = adev_get_mic_mute; adev-&gt;device.set_parameters = adev_set_parameters; adev-&gt;device.get_parameters = adev_get_parameters; adev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size; adev-&gt;device.open_output_stream = adev_open_output_stream; adev-&gt;device.close_output_stream = adev_close_output_stream; adev-&gt;device.open_input_stream = adev_open_input_stream; adev-&gt;device.close_input_stream = adev_close_input_stream; ......&#125; å¯ä»¥çœ‹åˆ°å½“è°ƒç”¨open_output_stream å°±ä¼šè°ƒç”¨adev_open_output_streamã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[-&gt;\\hardware\\qcom\\audio\\hal\\audio_hw.c]static int adev_open_output_stream(struct audio_hw_device *dev, audio_io_handle_t handle, audio_devices_t devices, audio_output_flags_t flags, struct audio_config *config, struct audio_stream_out **stream_out, const char *address __unused)&#123; struct audio_device *adev = (struct audio_device *)dev; struct stream_out *out; int i, ret; *stream_out = NULL; out = (struct stream_out *)calloc(1, sizeof(struct stream_out)); ...... out-&gt;stream.common.get_sample_rate = out_get_sample_rate; out-&gt;stream.common.set_sample_rate = out_set_sample_rate; out-&gt;stream.common.get_buffer_size = out_get_buffer_size; out-&gt;stream.common.get_channels = out_get_channels; out-&gt;stream.common.get_format = out_get_format; out-&gt;stream.common.set_format = out_set_format; out-&gt;stream.common.standby = out_standby; out-&gt;stream.common.dump = out_dump; out-&gt;stream.common.set_parameters = out_set_parameters; out-&gt;stream.common.get_parameters = out_get_parameters; out-&gt;stream.common.add_audio_effect = out_add_audio_effect; out-&gt;stream.common.remove_audio_effect = out_remove_audio_effect; out-&gt;stream.get_latency = out_get_latency; out-&gt;stream.set_volume = out_set_volume;#ifdef NO_AUDIO_OUT out-&gt;stream.write = out_write_for_no_output;#else out-&gt;stream.write = out_write;#endif out-&gt;stream.get_render_position = out_get_render_position; out-&gt;stream.get_next_write_timestamp = out_get_next_write_timestamp; out-&gt;stream.get_presentation_position = out_get_presentation_position; out-&gt;af_period_multiplier = out-&gt;realtime ? af_period_multiplier : 1; out-&gt;standby = 1; ...... *stream_out = &amp;out-&gt;stream; ALOGV(&quot;%s: exit&quot;, __func__); return 0;&#125; æ ¹æ®éŸ³é¢‘æµçš„ç†Ÿæ‚‰åšä¸€ç³»åˆ—åˆå§‹åŒ–æ“ä½œã€‚è½¬äº†ä¸€å¤§åœˆï¼Œç»§ç»­çœ‹çœ‹ 1.2.2.3ã€åˆ›å»ºæ’­æ”¾çº¿ç¨‹(PlaybackThread)Step3@ AudioFlinger::openOutput. æ—¢ç„¶é€šé“å·²ç»æ‰“å¼€ï¼Œé‚£ä¹ˆç”±è°æ¥å¾€é€šé“é‡Œæ”¾ä¸œè¥¿å‘¢ï¼Ÿè¿™å°±æ˜¯PlaybackThreadã€‚è¿™é‡Œåˆ†ä¸‰ç§ä¸åŒçš„æƒ…å†µï¼šÂ· OffloadThread Â· DirectOutput å¦‚æœä¸éœ€è¦æ··éŸ³ Â· Mixer éœ€è¦æ··éŸ³ è¿™ä¸‰ç§æƒ…å†µåˆ†åˆ«å¯¹åº”DirectOutputThreadã€OffloadThreadå’ŒMixerThreadä¸¤ç§çº¿ç¨‹ã€‚æˆ‘ä»¬ä»¥åè€…ä¸ºä¾‹æ¥åˆ†æä¸‹PlaybackThreadçš„å·¥ä½œæ¨¡å¼ï¼Œä¹Ÿä¼šåé¢å°èŠ‚æ‰“ä¸‹åŸºç¡€ã€‚å›æ”¾çº¿ç¨‹ï¼ˆPlaybackThread åŠå…¶æ´¾ç”Ÿçš„å­ç±»ï¼‰å’Œå½•åˆ¶çº¿ç¨‹ï¼ˆRecordThreadï¼‰è¿›è¡Œçš„ï¼Œå…ˆç®€å•çœ‹çœ‹å›æ”¾çº¿ç¨‹å’Œå½•åˆ¶çº¿ç¨‹ç±»å…³ç³»ï¼š Â· ThreadBaseï¼šPlaybackThread å’Œ RecordThread çš„åŸºç±»Â· RecordThreadï¼šå½•åˆ¶çº¿ç¨‹ç±»ï¼Œç”± ThreadBase æ´¾ç”ŸÂ· PlaybackThreadï¼šå›æ”¾çº¿ç¨‹åŸºç±»ï¼ŒåŒç”± ThreadBase æ´¾ç”ŸÂ· MixerThreadï¼šæ··éŸ³å›æ”¾çº¿ç¨‹ç±»ï¼Œç”± PlaybackThread æ´¾ç”Ÿï¼Œè´Ÿè´£å¤„ç†æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_PRIMARYã€AUDIO_OUTPUT_FLAG_FASTã€AUDIO_OUTPUT_FLAG_DEEP_BUFFER çš„éŸ³é¢‘æµï¼ŒMixerThread å¯ä»¥æŠŠå¤šä¸ªéŸ³è½¨çš„æ•°æ®æ··éŸ³åå†è¾“å‡ºÂ· DirectOutputThreadï¼šç›´è¾“å›æ”¾çº¿ç¨‹ç±»ï¼Œç”± PlaybackThread æ´¾ç”Ÿï¼Œè´Ÿè´£å¤„ç†æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_DIRECT çš„éŸ³é¢‘æµï¼Œè¿™ç§éŸ³é¢‘æµæ•°æ®ä¸éœ€è¦è½¯ä»¶æ··éŸ³ï¼Œç›´æ¥è¾“å‡ºåˆ°éŸ³é¢‘è®¾å¤‡å³å¯Â· DuplicatingThreadï¼šå¤åˆ¶å›æ”¾çº¿ç¨‹ç±»ï¼Œç”± MixerThread æ´¾ç”Ÿï¼Œè´Ÿè´£å¤åˆ¶éŸ³é¢‘æµæ•°æ®åˆ°å…¶ä»–è¾“å‡ºè®¾å¤‡ï¼Œä½¿ç”¨åœºæ™¯å¦‚ä¸»å£°å¡è®¾å¤‡ã€è“ç‰™è€³æœºè®¾å¤‡ã€USB å£°å¡è®¾å¤‡åŒæ—¶è¾“å‡ºÂ· OffloadThreadï¼šç¡¬è§£å›æ”¾çº¿ç¨‹ç±»ï¼Œç”± DirectOutputThread æ´¾ç”Ÿï¼Œè´Ÿè´£å¤„ç†æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD çš„éŸ³é¢‘æµï¼Œè¿™ç§éŸ³é¢‘æµæœªç»è½¯ä»¶è§£ç çš„ï¼ˆä¸€èˆ¬æ˜¯ MP3ã€AAC ç­‰æ ¼å¼çš„æ•°æ®ï¼‰ï¼Œéœ€è¦è¾“å‡ºåˆ°ç¡¬ä»¶è§£ç å™¨ï¼Œç”±ç¡¬ä»¶è§£ç å™¨è§£ç æˆ PCM æ•°æ® PlaybackThread ä¸­æœ‰ä¸ªæä¸ºé‡è¦çš„å‡½æ•° threadLoop()ï¼Œå½“ PlaybackThread è¢«å¼ºå¼•ç”¨æ—¶ï¼ŒthreadLoop() ä¼šçœŸæ­£è¿è¡Œèµ·æ¥è¿›å…¥å¾ªç¯ä¸»ä½“ï¼Œå¤„ç†éŸ³é¢‘æµæ•°æ®ç›¸å…³äº‹åŠ¡ï¼ŒthreadLoop() å¤§è‡´æµç¨‹å¦‚ä¸‹ï¼ˆä»¥ MixerThread ä¸ºä¾‹ï¼‰ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889[-&gt;\\frameworks\\av\\services\\audioflinger\\Threads.cpp]bool AudioFlinger::PlaybackThread::threadLoop()&#123; // ...... while (!exitPending()) &#123; // ...... &#123; // scope for mLock Mutex::Autolock _l(mLock); processConfigEvents_l(); // ...... if ((!mActiveTracks.size() &amp;&amp; systemTime() &gt; mStandbyTimeNs) || isSuspended()) &#123; // put audio hardware into standby after short delay if (shouldStandby_l()) &#123; threadLoop_standby(); mStandby = true; &#125; // ...... &#125; // mMixerStatusIgnoringFastTracks is also updated internally mMixerStatus = prepareTracks_l(&amp;tracksToRemove); // ...... &#125; // mLock scope ends // ...... if (mBytesRemaining == 0) &#123; mCurrentWriteLength = 0; if (mMixerStatus == MIXER_TRACKS_READY) &#123; // threadLoop_mix() sets mCurrentWriteLength threadLoop_mix(); &#125; // ...... &#125; // ...... if (!waitingAsyncCallback()) &#123; // mSleepTimeUs == 0 means we must write to audio hardware if (mSleepTimeUs == 0) &#123; // ...... if (mBytesRemaining) &#123; // FIXME rewrite to reduce number of system calls ret = threadLoop_write(); lastWriteFinished = systemTime(); delta = lastWriteFinished - mLastWriteTime; if (ret &lt; 0) &#123; mBytesRemaining = 0; &#125; else &#123; mBytesWritten += ret; mBytesRemaining -= ret; mFramesWritten += ret / mFrameSize; &#125; &#125; // ...... &#125; // ...... &#125; // Finally let go of removed track(s), without the lock held // since we can&apos;t guarantee the destructors won&apos;t acquire that // same lock. This will also mutate and push a new fast mixer state. threadLoop_removeTracks(tracksToRemove); tracksToRemove.clear(); // ...... &#125; threadLoop_exit(); if (!mStandby) &#123; threadLoop_standby(); mStandby = true; &#125; // ...... return false;&#125; threadLoop() å¾ªç¯çš„æ¡ä»¶æ˜¯ exitPending() è¿”å› falseï¼Œå¦‚æœæƒ³è¦ PlaybackThread ç»“æŸå¾ªç¯ï¼Œåˆ™å¯ä»¥è°ƒç”¨ requestExit() æ¥è¯·æ±‚é€€å‡ºï¼›processConfigEvents_l() ï¼šå¤„ç†é…ç½®äº‹ä»¶ï¼›å½“æœ‰é…ç½®æ”¹å˜çš„äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œéœ€è¦è°ƒç”¨ sendConfigEvent_l() æ¥é€šçŸ¥ PlaybackThreadï¼Œè¿™æ · PlaybackThread æ‰èƒ½åŠæ—¶å¤„ç†é…ç½®äº‹ä»¶ï¼›å¸¸è§çš„é…ç½®äº‹ä»¶æ˜¯åˆ‡æ¢éŸ³é¢‘é€šè·¯ï¼›æ£€æŸ¥æ­¤æ—¶æ­¤åˆ»æ˜¯å¦ç¬¦åˆ standby æ¡ä»¶ï¼Œæ¯”å¦‚å½“å‰å¹¶æ²¡æœ‰ ACTIVE çŠ¶æ€çš„ Trackï¼ˆmActiveTracks.size() = 0ï¼‰ï¼Œé‚£ä¹ˆè°ƒç”¨ threadLoop_standby() å…³é—­éŸ³é¢‘ç¡¬ä»¶è®¾å¤‡ä»¥èŠ‚çœèƒ½è€—ï¼›prepareTracks_l()ï¼š å‡†å¤‡éŸ³é¢‘æµå’Œæ··éŸ³å™¨ï¼Œè¯¥å‡½æ•°éå¸¸å¤æ‚ï¼Œè¿™é‡Œä¸è¯¦ç»†åˆ†æäº†ï¼Œä»…åˆ—ä¸€ä¸‹æµç¨‹è¦ç‚¹ï¼šéå† mActiveTracksï¼Œé€ä¸ªå¤„ç† mActiveTracks ä¸Šçš„ Trackï¼Œæ£€æŸ¥è¯¥ Track æ˜¯å¦ä¸º ACTIVE çŠ¶æ€ï¼›å¦‚æœ Track è®¾ç½®æ˜¯ ACTIVE çŠ¶æ€ï¼Œåˆ™å†æ£€æŸ¥è¯¥ Track çš„æ•°æ®æ˜¯å¦å‡†å¤‡å°±ç»ªäº†ï¼›æ ¹æ®éŸ³é¢‘æµçš„éŸ³é‡å€¼ã€æ ¼å¼ã€å£°é“æ•°ã€éŸ³è½¨çš„é‡‡æ ·ç‡ã€ç¡¬ä»¶è®¾å¤‡çš„é‡‡æ ·ç‡ï¼Œé…ç½®å¥½æ··éŸ³å™¨å‚æ•°ï¼›å¦‚æœ Track çš„çŠ¶æ€æ˜¯ PAUSED æˆ– STOPPEDï¼Œåˆ™æŠŠè¯¥ Track æ·»åŠ åˆ° tracksToRemove å‘é‡ä¸­ï¼›threadLoop_mix()ï¼šè¯»å–æ‰€æœ‰ç½®äº† ACTIVE çŠ¶æ€çš„éŸ³é¢‘æµæ•°æ®ï¼Œæ··éŸ³å™¨å¼€å§‹å¤„ç†è¿™äº›æ•°æ®ï¼›threadLoop_write()ï¼š æŠŠæ··éŸ³å™¨å¤„ç†åçš„æ•°æ®å†™åˆ°è¾“å‡ºæµè®¾å¤‡ï¼›threadLoop_removeTracks()ï¼š æŠŠ tracksToRemove ä¸Šçš„æ‰€æœ‰ Track ä» mActiveTracks ä¸­ç§»é™¤å‡ºæ¥ï¼›è¿™æ ·ä¸‹ä¸€æ¬¡å¾ªç¯æ—¶å°±ä¸ä¼šå¤„ç†è¿™äº› Track äº†ã€‚è¿™é‡Œè¯´è¯´ PlaybackThread ä¸è¾“å‡ºæµè®¾å¤‡çš„å…³ç³»ï¼šPlaybackThread å®ä¾‹ä¸è¾“å‡ºæµè®¾å¤‡æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œæ¯”æ–¹è¯´ OffloadThread åªä¼šå°†éŸ³é¢‘æ•°æ®è¾“å‡ºåˆ° compress_offload è®¾å¤‡ä¸­ï¼ŒMixerThread(with FastMixer) åªä¼šå°†éŸ³é¢‘æ•°æ®è¾“å‡ºåˆ° low_latency è®¾å¤‡ä¸­ã€‚ ä» Audio HAL ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸çœ‹åˆ°å¦‚ä¸‹ 4 ç§è¾“å‡ºæµè®¾å¤‡ï¼Œåˆ†åˆ«å¯¹åº”ç€ä¸åŒçš„æ’­æ”¾åœºæ™¯ï¼š primary_outï¼šä¸»è¾“å‡ºæµè®¾å¤‡ï¼Œç”¨äºé“ƒå£°ç±»å£°éŸ³è¾“å‡ºï¼Œå¯¹åº”ç€æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_PRIMARY çš„éŸ³é¢‘æµå’Œä¸€ä¸ª MixerThread å›æ”¾çº¿ç¨‹å®ä¾‹low_latencyï¼šä½å»¶è¿Ÿè¾“å‡ºæµè®¾å¤‡ï¼Œç”¨äºæŒ‰é”®éŸ³ã€æ¸¸æˆèƒŒæ™¯éŸ³ç­‰å¯¹æ—¶å»¶è¦æ±‚é«˜çš„å£°éŸ³è¾“å‡ºï¼Œå¯¹åº”ç€æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_FAST çš„éŸ³é¢‘æµå’Œä¸€ä¸ª MixerThread å›æ”¾çº¿ç¨‹å®ä¾‹deep_bufferï¼šéŸ³ä¹éŸ³è½¨è¾“å‡ºæµè®¾å¤‡ï¼Œç”¨äºéŸ³ä¹ç­‰å¯¹æ—¶å»¶è¦æ±‚ä¸é«˜çš„å£°éŸ³è¾“å‡ºï¼Œå¯¹åº”ç€æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_DEEP_BUFFER çš„éŸ³é¢‘æµå’Œä¸€ä¸ª MixerThread å›æ”¾çº¿ç¨‹å®ä¾‹compress_offloadï¼šç¡¬è§£è¾“å‡ºæµè®¾å¤‡ï¼Œç”¨äºéœ€è¦ç¡¬ä»¶è§£ç çš„æ•°æ®è¾“å‡ºï¼Œå¯¹åº”ç€æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD çš„éŸ³é¢‘æµå’Œä¸€ä¸ª OffloadThread å›æ”¾çº¿ç¨‹å®ä¾‹å…¶ä¸­ primary_out è®¾å¤‡æ˜¯å¿…é¡»å£°æ˜æ”¯æŒçš„ï¼Œè€Œä¸”ç³»ç»Ÿå¯åŠ¨æ—¶å°±å·²ç»æ‰“å¼€ primary_out è®¾å¤‡å¹¶åˆ›å»ºå¥½å¯¹åº”çš„ MixerThread å®ä¾‹ã€‚å…¶ä»–ç±»å‹çš„è¾“å‡ºæµè®¾å¤‡å¹¶éå¿…é¡»å£°æ˜æ”¯æŒçš„ï¼Œä¸»è¦æ˜¯çœ‹ç¡¬ä»¶ä¸Šæœ‰æ— è¿™ä¸ªèƒ½åŠ›ã€‚ å¯èƒ½æœ‰äººäº§ç”Ÿè¿™æ ·çš„ç–‘é—®ï¼šæ—¢ç„¶ primary_out è®¾å¤‡ä¸€ç›´ä¿æŒæ‰“å¼€ï¼Œé‚£ä¹ˆèƒ½è€—å²‚ä¸æ˜¯å¾ˆå¤§ï¼Ÿè¿™é‡Œé˜é‡Šä¸€ä¸ªæ¦‚å¿µï¼šè¾“å‡ºæµè®¾å¤‡å±äºé€»è¾‘è®¾å¤‡ï¼Œå¹¶ä¸æ˜¯ç¡¬ä»¶è®¾å¤‡ã€‚æ‰€ä»¥å³ä½¿è¾“å‡ºæµè®¾å¤‡ä¸€ç›´ä¿æŒæ‰“å¼€ï¼Œåªè¦ç¡¬ä»¶è®¾å¤‡ä¸å·¥ä½œï¼Œé‚£ä¹ˆå°±ä¸ä¼šå½±å“èƒ½è€—ã€‚é‚£ä¹ˆç¡¬ä»¶è®¾å¤‡ä»€ä¹ˆæ—¶å€™æ‰ä¼šæ‰“å¼€å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ PlaybackThread å°†éŸ³é¢‘æ•°æ®å†™å…¥åˆ°è¾“å‡ºæµè®¾å¤‡æ—¶ã€‚ ä¸‹å›¾ç®€å•æè¿° AudioTrackã€PlaybackThreadã€è¾“å‡ºæµè®¾å¤‡ä¸‰è€…çš„å¯¹åº”å…³ç³»ï¼š æˆ‘ä»¬å¯ä»¥è¿™ä¹ˆè¯´ï¼šè¾“å‡ºæµè®¾å¤‡å†³å®šäº†å®ƒå¯¹åº”çš„ PlaybackThread æ˜¯ä»€ä¹ˆç±»å‹ã€‚æ€ä¹ˆç†è§£å‘¢ï¼Ÿæ„æ€æ˜¯è¯´ï¼šåªæœ‰æ”¯æŒäº†è¯¥ç±»å‹çš„è¾“å‡ºæµè®¾å¤‡ï¼Œé‚£ä¹ˆè¯¥ç±»å‹çš„ PlaybackThread æ‰æœ‰å¯èƒ½è¢«åˆ›å»ºã€‚ä¸¾ä¸ªä¾‹å­ï¼šåªæœ‰ç¡¬ä»¶ä¸Šå…·å¤‡ç¡¬ä»¶è§£ç å™¨ï¼Œç³»ç»Ÿæ‰å»ºç«‹ compress_offload è®¾å¤‡ï¼Œç„¶åæ’­æ”¾ mp3 æ ¼å¼çš„éŸ³ä¹æ–‡ä»¶æ—¶ï¼Œæ‰ä¼šåˆ›å»º OffloadThread æŠŠæ•°æ®è¾“å‡ºåˆ° compress_offload è®¾å¤‡ä¸Šï¼›åä¹‹ï¼Œå¦‚æœç¡¬ä»¶ä¸Šå¹¶ä¸å…·å¤‡ç¡¬ä»¶è§£ç å™¨ï¼Œç³»ç»Ÿåˆ™ä¸åº”è¯¥å»ºç«‹ compress_offload è®¾å¤‡ï¼Œé‚£ä¹ˆæ’­æ”¾ mp3 æ ¼å¼çš„éŸ³ä¹æ–‡ä»¶æ—¶ï¼Œé€šè¿‡ MixerThread æŠŠæ•°æ®è¾“å‡ºåˆ°å…¶ä»–è¾“å‡ºæµè®¾å¤‡ä¸Šã€‚ é‚£ä¹ˆæœ‰æ— å¯èƒ½å‡ºç°è¿™ç§æƒ…å†µï¼šåº•å±‚å¹¶ä¸æ”¯æŒ compress_offload è®¾å¤‡ï¼Œä½†ååæœ‰ä¸ªæ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD çš„éŸ³é¢‘æµé€åˆ° AudioFlinger äº†å‘¢ï¼Ÿè¿™æ˜¯ä¸å¯èƒ½çš„ã€‚ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œä¼šæ£€æŸ¥å¹¶ä¿å­˜è¾“å…¥è¾“å‡ºæµè®¾å¤‡çš„æ”¯æŒä¿¡æ¯ï¼›æ’­æ”¾å™¨åœ¨æ’­æ”¾ mp3 æ–‡ä»¶æ—¶ï¼Œé¦–å…ˆçœ‹ compress_offload è®¾å¤‡æ˜¯å¦æ”¯æŒäº†ï¼Œå¦‚æœæ”¯æŒï¼Œé‚£ä¹ˆä¸è¿›è¡Œè½¯ä»¶è§£ç ï¼Œç›´æ¥æŠŠæ•°æ®æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOADï¼›å¦‚æœä¸æ”¯æŒï¼Œé‚£ä¹ˆå…ˆè¿›è¡Œè½¯ä»¶è§£ç ï¼Œç„¶åæŠŠè§£ç å¥½çš„æ•°æ®æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_DEEP_BUFFERï¼Œå‰ææ˜¯ deep_buffer è®¾å¤‡æ˜¯æ”¯æŒäº†çš„ï¼›å¦‚æœ deep_buffer è®¾å¤‡ä¹Ÿä¸æ”¯æŒï¼Œé‚£ä¹ˆæŠŠæ•°æ®æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_PRIMARYã€‚ ç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œå°±å·²ç»æ‰“å¼€ primary_outã€low_latencyã€deep_buffer è¿™ä¸‰ç§è¾“å‡ºæµè®¾å¤‡ï¼Œå¹¶åˆ›å»ºå¯¹åº”çš„ MixerThread äº†ï¼›è€Œæ­¤æ—¶ DirectOutputThread ä¸ OffloadThread ä¸ä¼šè¢«åˆ›å»ºï¼Œç›´åˆ°æ ‡è¯†ä¸º AUDIO_OUTPUT_FLAG_DIRECT/AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD çš„éŸ³é¢‘æµéœ€è¦è¾“å‡ºæ—¶ï¼Œæ‰å¼€å§‹åˆ›å»º DirectOutputThread/OffloadThread å’Œæ‰“å¼€ direct_out/compress_offload è®¾å¤‡ã€‚è¿™ä¸€ç‚¹è¯·å‚è€ƒå¦‚ä¸‹ä»£ç ï¼Œæ³¨é‡Šéå¸¸æ¸…æ™°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[-&gt;\\frameworks\\av\\services\\audiopolicy\\managerdefault\\AudioPolicyManager.cpp]AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface) // ......&#123; // ...... // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices // open all output streams needed to access attached devices // ...... for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123; // ...... // open all output streams needed to access attached devices // except for direct output streams that are only opened when they are actually // required by an app. // This also validates mAvailableOutputDevices list for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++) &#123; // ...... if ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != 0) &#123; continue; &#125; // ...... audio_io_handle_t output = AUDIO_IO_HANDLE_NONE; status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(), &amp;output, &amp;config, &amp;outputDesc-&gt;mDevice, address, &amp;outputDesc-&gt;mLatency, outputDesc-&gt;mFlags); // ...... &#125; // open input streams needed to access attached devices to validate // mAvailableInputDevices list for (size_t j = 0; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++) &#123; // ...... status_t status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(), &amp;input, &amp;config, &amp;inputDesc-&gt;mDevice, address, AUDIO_SOURCE_MIC, AUDIO_INPUT_FLAG_NONE); // ...... &#125; &#125; // ...... updateDevicesAndOutputs();&#125; å…¶ä¸­ mpClientInterface-&gt;openOutput() æœ€ç»ˆä¼šè°ƒç”¨åˆ° AudioFlinger::openOutput()ï¼šæ‰“å¼€è¾“å‡ºæµè®¾å¤‡ï¼Œå¹¶åˆ›å»º PlaybackThread å¯¹è±¡ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374status_t AudioFlinger::openOutput(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t *devices, const String8&amp; address, uint32_t *latencyMs, audio_output_flags_t flags)&#123; // ...... Mutex::Autolock _l(mLock); sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags); // ......&#125;sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t devices, const String8&amp; address, audio_output_flags_t flags)&#123; // ...... // åˆ†é…å…¨å±€å”¯ä¸€çš„ audio_io_handle_tï¼Œå¯ä»¥ç†è§£å®ƒæ˜¯å›æ”¾çº¿ç¨‹çš„ç´¢å¼•å· if (*output == AUDIO_IO_HANDLE_NONE) &#123; *output = nextUniqueId(); &#125; mHardwareStatus = AUDIO_HW_OUTPUT_OPEN; //...... // æ‰“å¼€éŸ³é¢‘è¾“å‡ºæµè®¾å¤‡ï¼ŒHAL å±‚æ ¹æ® flags é€‰æ‹©æ‰“å¼€ç›¸å…³ç±»å‹çš„è¾“å‡ºæµè®¾å¤‡ AudioStreamOut *outputStream = NULL; status_t status = outHwDev-&gt;openOutputStream( &amp;outputStream, *output, devices, flags, config, address.string()); mHardwareStatus = AUDIO_HW_IDLE; if (status == NO_ERROR) &#123; PlaybackThread *thread; if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123; // AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD éŸ³é¢‘æµï¼Œåˆ›å»º OffloadThread å®ä¾‹ thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady); ALOGV(&quot;openOutput_l() created offload output: ID %d thread %p&quot;, *output, thread); &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT) || !isValidPcmSinkFormat(config-&gt;format) || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123; // AUDIO_OUTPUT_FLAG_DIRECT éŸ³é¢‘æµï¼Œåˆ›å»º DirectOutputThread å®ä¾‹ thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady); ALOGV(&quot;openOutput_l() created direct output: ID %d thread %p&quot;, *output, thread); &#125; else &#123; // å…¶ä»–æ ‡è¯†çš„éŸ³é¢‘æµï¼Œåˆ›å»º MixerThread å®ä¾‹ thread = new MixerThread(this, outputStream, *output, devices, mSystemReady); ALOGV(&quot;openOutput_l() created mixer output: ID %d thread %p&quot;, *output, thread); &#125; // æŠŠ audio_io_handle_t å’Œ PlaybackThread æ·»åŠ åˆ°é”®å€¼å¯¹å‘é‡ mPlaybackThreads ä¸­ // é”®å€¼å¯¹å‘é‡ mPlaybackThreads ä¸­ï¼Œç”±äº audio_io_handle_t å’Œ PlaybackThread æ˜¯ä¸€ // ä¸€å¯¹åº”çš„å…³ç³»ï¼Œæ‰€ä»¥æ‹¿åˆ°ä¸€ä¸ª audio_io_handle_tï¼Œå°±èƒ½æ‰¾åˆ°å®ƒå¯¹åº”çš„ PlaybackThread // æ‰€ä»¥å¯ä»¥ç†è§£ audio_io_handle_t ä¸º PlaybackThread çš„ç´¢å¼•å· mPlaybackThreads.add(*output, thread); return thread; &#125; return 0;&#125; 1.2.3ã€AudioFlinger éŸ³é¢‘æµç®¡ç†AudioFlinger éŸ³é¢‘æµç®¡ç†ç”± AudioFlinger::PlaybackThread::Track å®ç°ï¼ŒTrack ä¸ AudioTrack æ˜¯ä¸€å¯¹ä¸€çš„å…³ç³»ï¼Œä¸€ä¸ª AudioTrack åˆ›å»ºåï¼Œé‚£ä¹ˆ AudioFlinger ä¼šåˆ›å»ºä¸€ä¸ª Track ä¸ä¹‹å¯¹åº”ï¼›PlaybackThread ä¸ AudioTrack/Track æ˜¯ä¸€å¯¹å¤šçš„å…³ç³»ï¼Œä¸€ä¸ª PlaybackThread å¯ä»¥æŒ‚ç€å¤šä¸ª Trackã€‚ å…·ä½“æ¥è¯´ï¼šAudioTrack åˆ›å»ºåï¼ŒAudioPolicyManager æ ¹æ® AudioTrack çš„è¾“å‡ºæ ‡è¯†å’Œæµç±»å‹ï¼Œæ‰¾åˆ°å¯¹åº”çš„è¾“å‡ºæµè®¾å¤‡å’Œ PlaybackThreadï¼ˆå¦‚æœæ²¡æœ‰æ‰¾åˆ°çš„è¯ï¼Œåˆ™ç³»ç»Ÿä¼šæ‰“å¼€å¯¹åº”çš„è¾“å‡ºæµè®¾å¤‡å¹¶æ–°å»ºä¸€ä¸ª PlaybackThreadï¼‰ï¼Œç„¶ååˆ›å»ºä¸€ä¸ª Track å¹¶æŒ‚åˆ°è¿™ä¸ª PlaybackThread ä¸‹é¢ã€‚ PlaybackThread æœ‰ä¸¤ä¸ªç§æœ‰æˆå‘˜å‘é‡ä¸æ­¤å¼ºç›¸å…³ï¼š Â· mTracksï¼šè¯¥ PlaybackThread åˆ›å»ºçš„æ‰€æœ‰ Track å‡æ·»åŠ ä¿å­˜åˆ°è¿™ä¸ªå‘é‡ä¸­Â· mActiveTracksï¼šåªæœ‰éœ€è¦æ’­æ”¾ï¼ˆè®¾ç½®äº† ACTIVE çŠ¶æ€ï¼‰çš„ Track ä¼šæ·»åŠ åˆ°è¿™ä¸ªå‘é‡ä¸­ï¼›PlaybackThread ä¼šä»è¯¥å‘é‡ä¸Šæ‰¾åˆ°æ‰€æœ‰è®¾ç½®äº† ACTIVE çŠ¶æ€çš„ Trackï¼ŒæŠŠè¿™äº› Track æ•°æ®æ··éŸ³åå†™åˆ°è¾“å‡ºæµè®¾å¤‡éŸ³é¢‘æµæ§åˆ¶æœ€å¸¸ç”¨çš„ä¸‰ä¸ªæ¥å£ï¼š AudioFlinger::PlaybackThread::Track::startï¼šå¼€å§‹æ’­æ”¾ï¼šæŠŠè¯¥ Track ç½® ACTIVE çŠ¶æ€ï¼Œç„¶åæ·»åŠ åˆ° mActiveTracks å‘é‡ä¸­ï¼Œæœ€åè°ƒç”¨ AudioFlinger::PlaybackThread::broadcast_l() å‘ŠçŸ¥ PlaybackThread æƒ…å†µæœ‰å˜Â· AudioFlinger::PlaybackThread::Track::stopï¼šåœæ­¢æ’­æ”¾ï¼šæŠŠè¯¥ Track ç½® STOPPED çŠ¶æ€ï¼Œæœ€åè°ƒç”¨ AudioFlinger::PlaybackThread::broadcast_l() å‘ŠçŸ¥ PlaybackThread æƒ…å†µæœ‰å˜Â· AudioFlinger::PlaybackThread::Track::pauseï¼šæš‚åœæ’­æ”¾ï¼šæŠŠè¯¥ Track ç½® PAUSING çŠ¶æ€ï¼Œæœ€åè°ƒç”¨ AudioFlinger::PlaybackThread::broadcast_l() å‘ŠçŸ¥ PlaybackThread æƒ…å†µæœ‰å˜Â· AudioFlinger::PlaybackThread::threadLoop() å¾—æ‚‰æƒ…å†µæœ‰å˜åï¼Œè°ƒç”¨ prepareTracks_l() é‡æ–°å‡†å¤‡éŸ³é¢‘æµå’Œæ··éŸ³å™¨ï¼šACTIVE çŠ¶æ€çš„ Track ä¼šæ·»åŠ åˆ° mActiveTracksï¼Œæ­¤å¤–çš„ Track ä¼šä» mActiveTracks ä¸Šç§»é™¤å‡ºæ¥ï¼Œç„¶åé‡æ–°å‡†å¤‡ AudioMixerã€‚ å¯è§è¿™ä¸‰ä¸ªéŸ³é¢‘æµæ§åˆ¶æ¥å£æ˜¯éå¸¸ç®€å•çš„ï¼Œä¸»è¦æ˜¯è®¾ç½®ä¸€ä¸‹ Track çš„çŠ¶æ€ï¼Œç„¶åå‘ä¸ªäº‹ä»¶é€šçŸ¥ PlaybackThread å°±è¡Œï¼Œå¤æ‚çš„å¤„ç†éƒ½åœ¨ AudioFlinger::PlaybackThread::threadLoop() ä¸­äº†ã€‚ (äºŒ)ã€æ·±å…¥å‰–æAndroidéŸ³é¢‘ä¹‹AudioPolicyServiceAudioPolicyServiceæ˜¯ç­–ç•¥çš„åˆ¶å®šè€…ï¼Œæ¯”å¦‚ä»€ä¹ˆæ—¶å€™æ‰“å¼€éŸ³é¢‘æ¥å£è®¾å¤‡ã€æŸç§Streamç±»å‹çš„éŸ³é¢‘å¯¹åº”ä»€ä¹ˆè®¾å¤‡ç­‰ç­‰ã€‚è€ŒAudioFlingeråˆ™æ˜¯ç­–ç•¥çš„æ‰§è¡Œè€…ï¼Œä¾‹å¦‚å…·ä½“å¦‚ä½•ä¸éŸ³é¢‘è®¾å¤‡é€šä¿¡ï¼Œå¦‚ä½•ç»´æŠ¤ç°æœ‰ç³»ç»Ÿä¸­çš„éŸ³é¢‘è®¾å¤‡ï¼Œä»¥åŠå¤šä¸ªéŸ³é¢‘æµçš„æ··éŸ³å¦‚ä½•å¤„ç†ç­‰ç­‰éƒ½å¾—ç”±å®ƒæ¥å®Œæˆã€‚AudioPolicyServiceæ ¹æ®ç”¨æˆ·é…ç½®æ¥æŒ‡å¯¼AudioFlingeråŠ è½½è®¾å¤‡æ¥å£ï¼Œèµ·åˆ°è·¯ç”±åŠŸèƒ½ 1234567891011121314151617181920212223[-&gt;\\frameworks\\av\\media\\audioserver\\main_audioserver.cpp]int main(int argc __unused, char **argv)&#123; ...... if (doLog &amp;&amp; (childPid = fork()) != 0) &#123; ...... &#125; else &#123; // all other services if (doLog) &#123; prctl(PR_SET_PDEATHSIG, SIGKILL); // if parent media.log dies before me, kill me also setpgid(0, 0); // but if I die first, don't kill my parent &#125; sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI(\"ServiceManager: %p\", sm.get()); AudioFlinger::instantiate(); AudioPolicyService::instantiate(); RadioService::instantiate(); SoundTriggerHwService::instantiate(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); &#125;&#125; AudioPolicyServiceç»§æ‰¿äº†æ¨¡æ¿ç±»BinderServiceï¼Œè¯¥ç±»ç”¨äºæ³¨å†Œnative serviceã€‚BinderServiceæ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œè¯¥ç±»çš„publishå‡½æ•°å°±æ˜¯å®Œæˆå‘ServiceManageræ³¨å†ŒæœåŠ¡ã€‚ 12[-&gt;\\frameworks\\av\\services\\audiopolicy\\service\\AudioPolicyService.h]static const char *getServiceName() ANDROID_API &#123; return \"media.audio_policy\"; &#125; AudioPolicyServiceæ³¨å†Œåä¸ºâ€media.audio_policyâ€çš„æœåŠ¡ã€‚é¦–å…ˆçœ‹çœ‹AudioPolicyServiceçš„onFirstRef()å‡½æ•° 1234567891011121314151617181920212223242526272829303132333435363738[-&gt;\\frameworks\\av\\services\\audiopolicy\\service\\AudioPolicyService.cpp]AudioPolicyService::AudioPolicyService() : BnAudioPolicyService(), mpAudioPolicyDev(NULL), mpAudioPolicy(NULL), mAudioPolicyManager(NULL), mAudioPolicyClient(NULL), mPhoneState(AUDIO_MODE_INVALID)&#123;&#125;void AudioPolicyService::onFirstRef()&#123; &#123; Mutex::Autolock _l(mLock); /* Step 1:åˆ›å»ºAudioCommandThreadçº¿ç¨‹ */ // start tone playback thread mTonePlaybackThread = new AudioCommandThread(String8(\"ApmTone\"), this); // start audio commands thread mAudioCommandThread = new AudioCommandThread(String8(\"ApmAudio\"), this); // start output activity command thread mOutputCommandThread = new AudioCommandThread(String8(\"ApmOutput\"), this);#ifdef USE_LEGACY_AUDIO_POLICY // ä½¿ç”¨è€ç‰ˆæœ¬çš„ audio policy åˆå§‹åŒ–æ–¹å¼ ....#else // ä½¿ç”¨æœ€æ–°çš„ audio policy åˆå§‹åŒ–æ–¹å¼ ALOGI(\"AudioPolicyService CSTOR in new mode\"); /* Step 2:åˆ›å»ºAudioPolicyClientã€ AudioPolicyManager */ mAudioPolicyClient = new AudioPolicyClient(this); mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);#endif &#125; // load audio processing modules sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = new AudioPolicyEffects(); &#123; Mutex::Autolock _l(mLock); mAudioPolicyEffects = audioPolicyEffects; &#125;&#125; å…ˆçœ‹çœ‹æ€»ä½“æ—¶åºå›¾ï¼š 2.1ã€Step 1:åˆ›å»ºAudioCommandThreadçº¿ç¨‹åœ¨AudioPolicyServiceå¯¹è±¡æ„é€ è¿‡ç¨‹ä¸­ï¼Œåˆ†åˆ«åˆ›å»ºäº†ApmToneã€ApmAudioã€ApmOutputä¸‰ä¸ªAudioCommandThreadçº¿ç¨‹ï¼š 1ã€ ApmToneç”¨äºæ’­æ”¾toneéŸ³ï¼› 2ã€ ApmAudioç”¨äºæ‰§è¡Œaudioå‘½ä»¤ï¼› 3ã€ApmOutputç”¨äºæ‰§è¡Œè¾“å‡ºå‘½ä»¤ï¼› åœ¨ç¬¬ä¸€æ¬¡å¼ºå¼•ç”¨AudioCommandThreadçº¿ç¨‹å¯¹è±¡æ—¶ï¼ŒAudioCommandThreadçš„onFirstRefå‡½æ•°è¢«å›è°ƒï¼Œåœ¨æ­¤å¯åŠ¨çº¿ç¨‹ 12345[-&gt;\\frameworks\\av\\services\\audiopolicy\\service\\AudioPolicyService.cpp]void AudioPolicyService::AudioCommandThread::onFirstRef()&#123; run(mName.string(), ANDROID_PRIORITY_AUDIO);&#125; è¿™é‡Œé‡‡ç”¨å¼‚æ­¥æ–¹å¼æ¥æ‰§è¡Œaudio commandï¼Œå½“éœ€è¦æ‰§è¡Œä¸Šè¡¨ä¸­çš„å‘½ä»¤æ—¶ï¼Œé¦–å…ˆå°†å‘½ä»¤æŠ•é€’åˆ°AudioCommandThreadçš„mAudioCommandså‘½ä»¤å‘é‡è¡¨ä¸­ï¼Œç„¶åé€šè¿‡mWaitWorkCV.signal()å”¤é†’AudioCommandThreadçº¿ç¨‹ï¼Œè¢«å”¤é†’çš„AudioCommandThreadçº¿ç¨‹æ‰§è¡Œå®Œcommandåï¼Œåˆé€šè¿‡mWaitWorkCV.waitRelative(mLock, waitTime)ç¡çœ ç­‰å¾…å‘½ä»¤åˆ°æ¥ã€‚ 2.2ã€Step 2: åˆ›å»ºAudioPolicyClientã€ AudioPolicyManageré¦–å…ˆåˆ›å»ºAudioPolicyClient 123456789101112131415161718192021222324252627282930[-&gt;\\frameworks\\av\\services\\audiopolicy\\service\\AudioPolicyService.h] class AudioPolicyClient : public AudioPolicyClientInterface &#123; public: AudioPolicyClient(AudioPolicyService *service) : mAudioPolicyService(service) &#123;&#125; virtual ~AudioPolicyClient() &#123;&#125; // loads a HW module. virtual audio_module_handle_t loadHwModule(const char *name); ...... virtual status_t openOutput(audio_module_handle_t module, audio_io_handle_t *output, audio_config_t *config, audio_devices_t *devices, const String8&amp; address, uint32_t *latencyMs, audio_output_flags_t flags); ...... // opens an audio input virtual audio_io_handle_t openInput(audio_module_handle_t module, audio_io_handle_t *input, audio_config_t *config, audio_devices_t *devices, const String8&amp; address, audio_source_t source, audio_input_flags_t flags); ...... private: AudioPolicyService *mAudioPolicyService; &#125;; createAudioPolicyManager() å‡½æ•°çš„å®ç°ä½äº frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cppæ–‡ä»¶ä¸­ã€‚æŸ¥çœ‹æºç åæˆ‘ä»¬ä¼šå‘ç°å®ƒå®é™…ä¸Šæ˜¯ç›´æ¥è°ƒç”¨äº† AudioPolicyManager çš„æ„é€ å‡½æ•°ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456[-&gt;\\frameworks\\av\\services\\audiopolicy\\manager\\AudioPolicyFactory.cpp]extern \"C\" AudioPolicyInterface* createAudioPolicyManager( AudioPolicyClientInterface *clientInterface)&#123; return new AudioPolicyManager(clientInterface);&#125; 2.3ã€åˆ›å»ºAudioPolicyManager()æ€»ä½“æµç¨‹å›¾ï¼š AudioPolicyManager çš„æ„é€ å‡½æ•°å°†è§£æéŸ³é¢‘ç­–ç•¥é…ç½®æ–‡ä»¶ï¼Œä»è€Œè·å–åˆ°è®¾å¤‡æ‰€æ”¯æŒçš„éŸ³é¢‘è®¾å¤‡ä¿¡æ¯ï¼ˆåŒ…æ‹¬è®¾å¤‡æ˜¯å¦æ”¯æŒ Offloadã€Direct æ¨¡å¼è¾“å‡ºï¼Œå„è¾“å…¥è¾“å‡º profile æ‰€æ”¯æŒçš„é‡‡æ ·ç‡ã€é€šé“æ•°ã€æ•°æ®æ ¼å¼ç­‰ï¼‰ï¼ŒåŠ è½½å…¨éƒ¨ HwModuleï¼Œä¸ºä¹‹åˆ›å»ºæ‰€æœ‰é direct è¾“å‡ºç±»å‹çš„ outputStream å’Œæ‰€æœ‰ inputStreamï¼Œå¹¶åˆ›å»ºç›¸åº”çš„ playbackThread æˆ– recordThread çº¿ç¨‹ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒAndroid 7.0ä¸Šçš„éŸ³é¢‘ç­–ç•¥é…ç½®æ–‡ä»¶å¼€å§‹ä½¿ç”¨ XML æ ¼å¼ï¼Œå…¶æ–‡ä»¶åä¸º audio_policy_configuration.xmlï¼Œ è€Œåœ¨ä¹‹å‰çš„ç‰ˆæœ¬ä¸ŠéŸ³é¢‘ç­–ç•¥é…ç½®æ–‡ä»¶ä¸º audio_policy.confã€‚frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp ä¸­ AudioPolicyManager æ„é€ å‡½æ•°çš„å…³é”®ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138[-&gt;\\frameworks\\av\\services\\audiopolicy\\managerdefault\\AudioPolicyManager.cpp]AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface) :#ifdef AUDIO_POLICY_TEST Thread(false),#endif //AUDIO_POLICY_TEST mLimitRingtoneVolume(false), mLastVoiceVolume(-1.0f), mA2dpSuspended(false), mAudioPortGeneration(1), mBeaconMuteRefCount(0), mBeaconPlayingRefCount(0), mBeaconMuted(false), mTtsOutputAvailable(false), mMasterMono(false)&#123; ....#ifdef USE_XML_AUDIO_POLICY_CONF // è®¾å¤‡ä½¿ç”¨çš„é…ç½®æ–‡ä»¶ä¸º audio_policy_configuration.xml mVolumeCurves = new VolumeCurvesCollection(); AudioPolicyConfig config(mHwModules, mAvailableOutputDevices, mAvailableInputDevices, mDefaultOutputDevice, speakerDrcEnabled, static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves)); PolicySerializer serializer; // è§£æ xml é…ç½®æ–‡ä»¶ï¼Œå°†è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘è¾“å‡ºè®¾å¤‡ä¿å­˜åœ¨ mAvailableOutputDevices å˜é‡ä¸­ï¼Œ // å°†è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘è¾“å…¥è®¾å¤‡ä¿å­˜åœ¨ mAvailableInputDevices å˜é‡ä¸­ï¼Œå°†è®¾å¤‡çš„é»˜è®¤éŸ³é¢‘è¾“å‡º // è®¾å¤‡ä¿å­˜åœ¨ mDefaultOutputDevice å˜é‡ä¸­ã€‚ if (serializer.deserialize(AUDIO_POLICY_XML_CONFIG_FILE, config) != NO_ERROR) &#123;#else // è®¾å¤‡ä½¿ç”¨çš„é…ç½®æ–‡ä»¶ä¸º audio_policy.conf mVolumeCurves = new StreamDescriptorCollection(); AudioPolicyConfig config(mHwModules, mAvailableOutputDevices, mAvailableInputDevices, mDefaultOutputDevice, speakerDrcEnabled); // ä¼˜å…ˆè§£æ vendor ç›®å½•ä¸‹çš„ conf é…ç½®æ–‡ä»¶ï¼Œç„¶åè§£æ device ç›®å½•ä¸‹çš„ conf é…ç½®æ–‡ä»¶ã€‚ // å°†è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘è¾“å‡ºè®¾å¤‡ä¿å­˜åœ¨ mAvailableOutputDevices å˜é‡ä¸­ï¼Œ // å°†è®¾å¤‡æ”¯æŒçš„éŸ³é¢‘è¾“å…¥è®¾å¤‡ä¿å­˜åœ¨ mAvailableInputDevices å˜é‡ä¸­ï¼Œå°†è®¾å¤‡çš„é»˜è®¤éŸ³é¢‘è¾“å‡º // è®¾å¤‡ä¿å­˜åœ¨ mDefaultOutputDevice å˜é‡ä¸­ã€‚ if ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp; (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;#endif ALOGE(\"could not load audio policy configuration file, setting defaults\"); config.setDefault(); &#125; // must be done after reading the policy (since conditionned by Speaker Drc Enabling) mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled); // è®¾ç½®éŸ³é‡è°ƒèŠ‚æ›²çº¿ .... // ä¾æ¬¡åŠ è½½ HwModule å¹¶æ‰“å¼€å…¶æ‰€å« profile çš„ outputStream åŠ inputStream for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123; mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName()); if (mHwModules[i]-&gt;mHandle == 0) &#123; ALOGW(\"could not open HW module %s\", mHwModules[i]-&gt;getName()); continue; &#125; // open all output streams needed to access attached devices // except for direct output streams that are only opened when they are actually // required by an app. // This also validates mAvailableOutputDevices list // æ‰“å¼€å½“å‰ module ä¸‹æ‰€æœ‰é direct ç±»å‹ profile çš„ outputStream for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++) &#123; const sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j]; .... // å¦‚æœå½“å‰æ“ä½œçš„ module.profile æ˜¯ direct ç±»å‹ï¼Œåˆ™ä¸ä¸ºå…¶æ‰“å¼€ outputStream if ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != 0) &#123; continue; &#125; .... // è·å–é‡‡æ ·ç‡ã€é€šé“æ•°ã€æ•°æ®æ ¼å¼ç­‰å„éŸ³é¢‘å‚æ•° sp&lt;SwAudioOutputDescriptor&gt; outputDesc = new SwAudioOutputDescriptor(outProfile, mpClientInterface); const DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices(); const DeviceVector &amp;devicesForType = supportedDevices.getDevicesFromType(profileType); String8 address = devicesForType.size() &gt; 0 ? devicesForType.itemAt(0)-&gt;mAddress : String8(\"\"); outputDesc-&gt;mDevice = profileType; audio_config_t config = AUDIO_CONFIG_INITIALIZER; config.sample_rate = outputDesc-&gt;mSamplingRate; config.channel_mask = outputDesc-&gt;mChannelMask; config.format = outputDesc-&gt;mFormat; audio_io_handle_t output = AUDIO_IO_HANDLE_NONE; // ä¸ºå½“å‰ module.profile æ‰“å¼€å¯¹åº”çš„ outputStream å¹¶åˆ›å»º playbackThread çº¿ç¨‹ status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(), &amp;output, &amp;config, &amp;outputDesc-&gt;mDevice, address, &amp;outputDesc-&gt;mLatency, outputDesc-&gt;mFlags); .... &#125; // open input streams needed to access attached devices to validate // mAvailableInputDevices list // æ‰“å¼€å½“å‰ module ä¸‹æ‰€æœ‰ profile çš„ inputStream for (size_t j = 0; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++) &#123; const sp&lt;IOProfile&gt; inProfile = mHwModules[i]-&gt;mInputProfiles[j]; .... sp&lt;AudioInputDescriptor&gt; inputDesc = new AudioInputDescriptor(inProfile); inputDesc-&gt;mDevice = profileType; // è·å–é‡‡æ ·ç‡ã€é€šé“æ•°ã€æ•°æ®æ ¼å¼ç­‰å„éŸ³é¢‘å‚æ•° // find the address DeviceVector inputDevices = mAvailableInputDevices.getDevicesFromType(profileType); // the inputs vector must be of size 1, but we don't want to crash here String8 address = inputDevices.size() &gt; 0 ? inputDevices.itemAt(0)-&gt;mAddress : String8(\"\"); ALOGV(\" for input device 0x%x using address %s\", profileType, address.string()); ALOGE_IF(inputDevices.size() == 0, \"Input device list is empty!\"); audio_config_t config = AUDIO_CONFIG_INITIALIZER; config.sample_rate = inputDesc-&gt;mSamplingRate; config.channel_mask = inputDesc-&gt;mChannelMask; config.format = inputDesc-&gt;mFormat; audio_io_handle_t input = AUDIO_IO_HANDLE_NONE; // ä¸ºå½“å‰ module.profile æ‰“å¼€å¯¹åº”çš„ inputStream å¹¶åˆ›å»º recordThread çº¿ç¨‹ status_t status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(), &amp;input, &amp;config, &amp;inputDesc-&gt;mDevice, address, AUDIO_SOURCE_MIC, AUDIO_INPUT_FLAG_NONE); .... &#125; &#125; .... updateDevicesAndOutputs(); // æ›´æ–°ç³»ç»Ÿç¼“å­˜çš„éŸ³é¢‘è¾“å‡ºè®¾å¤‡ä¿¡æ¯ ....&#125; AudioPolicyManagerå¯¹è±¡æ„é€ è¿‡ç¨‹ä¸­ä¸»è¦å®Œæˆä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š 1ã€ åŠ è½½audio_policy_configuration.xmlæˆ–è€…audio_policy.confé…ç½®æ–‡ä»¶ 2ã€ åˆå§‹åŒ–éŸ³é‡è°ƒèŠ‚ç‚¹initializeVolumeCurves(speakerDrcEnabled) 3ã€ åŠ è½½audio policyç¡¬ä»¶æŠ½è±¡åº“ï¼šmpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;mName) 4ã€ æ‰“å¼€å¯¹åº”çš„outputStreamå’ŒinputStream ï¼š mpClientInterface-&gt;openOutput()ã€mpClientInterface-&gt;openInput 5ã€ æ›´æ–°ç³»ç»Ÿç¼“å­˜çš„éŸ³é¢‘è¾“å‡ºè®¾å¤‡ä¿¡æ¯updateDevicesAndOutputs() 2.3.1ã€åŠ è½½audio_policy_configuration.xmlæˆ–è€…audio_policy.confé…ç½®æ–‡ä»¶audio_policy_configuration.xmlaudio_policy.confåŒæ—¶å®šä¹‰äº†å¤šä¸ªaudio æ¥å£ï¼Œæ¯ä¸€ä¸ªaudio æ¥å£åŒ…å«è‹¥å¹²outputå’Œinputï¼Œè€Œæ¯ä¸ªoutputå’ŒinputåˆåŒæ—¶æ”¯æŒå¤šç§è¾“å…¥è¾“å‡ºæ¨¡å¼ï¼Œæ¯ç§è¾“å…¥è¾“å‡ºæ¨¡å¼åˆæ”¯æŒè‹¥å¹²ç§è®¾å¤‡ã€‚ 2.3.2ã€åˆå§‹åŒ–éŸ³é‡è°ƒèŠ‚ç‚¹initializeVolumeCurves(speakerDrcEnabled)åœ¨AudioPolicyManagerBaseä¸­å®šä¹‰äº†éŸ³é‡è°ƒèŠ‚å¯¹åº”çš„éŸ³é¢‘æµæè¿°ç¬¦æ•°ç»„ï¼š 12345678910111213141516//audio_policy_volumes.xmlconst AudioPolicyManagerBase::VolumeCurvePoint *AudioPolicyManagerBase::sVolumeProfiles[AudioSystem::NUM_STREAM_TYPES] [AudioPolicyManagerBase::DEVICE_CATEGORY_CNT] = &#123; &#123; // AUDIO_STREAM_VOICE_CALL sDefaultVoiceVolumeCurve, // DEVICE_CATEGORY_HEADSET sSpeakerVoiceVolumeCurve, // DEVICE_CATEGORY_SPEAKER sDefaultVoiceVolumeCurve // DEVICE_CATEGORY_EARPIECE &#125;, &#123; // AUDIO_STREAM_SYSTEM sHeadsetSystemVolumeCurve, // DEVICE_CATEGORY_HEADSET sDefaultSystemVolumeCurve, // DEVICE_CATEGORY_SPEAKER sDefaultSystemVolumeCurve // DEVICE_CATEGORY_EARPIECE &#125;, ...... &#125; initializeVolumeCurves()å‡½æ•°å°±æ˜¯åˆå§‹åŒ–è¯¥æ•°ç»„å…ƒç´ ï¼š 12345678910111213141516171819202122[-&gt;]void AudioPolicyManagerBase::initializeVolumeCurves()&#123; for (int i = 0; i &lt; AudioSystem::NUM_STREAM_TYPES; i++) &#123; for (int j = 0; j &lt; DEVICE_CATEGORY_CNT; j++) &#123; mStreams[i].mVolumeCurve[j] = sVolumeProfiles[i][j]; &#125; &#125; // Check availability of DRC on speaker path: if available, override some of the speaker curves if (mSpeakerDrcEnabled) &#123; mStreams[AUDIO_STREAM_SYSTEM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] = sDefaultSystemVolumeCurveDrc; mStreams[AUDIO_STREAM_RING].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] = sSpeakerSonificationVolumeCurveDrc; mStreams[AUDIO_STREAM_ALARM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] = sSpeakerSonificationVolumeCurveDrc; mStreams[AUDIO_STREAM_NOTIFICATION].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] = sSpeakerSonificationVolumeCurveDrc; &#125;&#125; 2.3.3ã€åŠ è½½audio policyç¡¬ä»¶æŠ½è±¡åº“loadHwModule()æˆ‘ä»¬ç›´æ¥åˆ†æAudioFlinger::loadHwModule_l()ä¸­çš„load_audio_interface()å‡½æ•°12345678910111213141516static int load_audio_interface(const char *if_name, audio_hw_device_t **dev)&#123; const hw_module_t *mod; int rc; //æ ¹æ®åå­—åŠ è½½audio_moduleæ¨¡å— rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod); ALOGE_IF(rc, &quot;%s couldn&apos;t load audio hw module %s.%s (%s)&quot;, __func__, AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc)); //æ‰“å¼€audio_deviceè®¾å¤‡ rc = audio_hw_device_open(mod, dev); ALOGE_IF(rc, &quot;%s couldn&apos;t open audio hw device in %s.%s (%s)&quot;, __func__, AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc)); return 0;&#125; [-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp] 123456static inline int audio_hw_device_open(const struct hw_module_t* module, struct audio_hw_device** device)&#123; return module-&gt;methods-&gt;open(module, AUDIO_HARDWARE_INTERFACE, (struct hw_device_t**)device);&#125; [-&gt;\\hardware\\libhardware_legacy\\audio\\audio_hw_hal.cpp] 1234567891011121314151617181920212223242526272829303132333435static int legacy_adev_open(const hw_module_t* module, const char* name, hw_device_t** device)&#123; struct legacy_audio_device *ladev; int ret; ladev = (struct legacy_audio_device *)calloc(1, sizeof(*ladev)); ladev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; ladev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0; ladev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); ladev-&gt;device.common.close = legacy_adev_close; ladev-&gt;device.init_check = adev_init_check; ladev-&gt;device.set_voice_volume = adev_set_voice_volume; ladev-&gt;device.set_master_volume = adev_set_master_volume; ladev-&gt;device.get_master_volume = adev_get_master_volume; ladev-&gt;device.set_mode = adev_set_mode; ladev-&gt;device.set_mic_mute = adev_set_mic_mute; ladev-&gt;device.get_mic_mute = adev_get_mic_mute; ladev-&gt;device.set_parameters = adev_set_parameters; ladev-&gt;device.get_parameters = adev_get_parameters; ladev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size; ladev-&gt;device.open_output_stream = adev_open_output_stream; ladev-&gt;device.close_output_stream = adev_close_output_stream; ladev-&gt;device.open_input_stream = adev_open_input_stream; ladev-&gt;device.close_input_stream = adev_close_input_stream; ladev-&gt;device.dump = adev_dump; ladev-&gt;hwif = createAudioHardware(); *device = &amp;ladev-&gt;device.common; return 0;&#125; åˆ°æ­¤å°±åŠ è½½å®Œç³»ç»Ÿå®šä¹‰çš„æ‰€æœ‰éŸ³é¢‘æ¥å£ï¼Œå¹¶ç”Ÿæˆç›¸åº”çš„æ•°æ®å¯¹è±¡ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼šâ€™ 2.3.4ã€æ‰“å¼€å¯¹åº”çš„outputStreamå’ŒinputStreamå‰é¢ä¸€å°èŠ‚å·²ç»åˆ†æè¿‡outputStreamï¼Œè¿™é‡Œä¸å†åˆ†æäº† æ‰“å¼€éŸ³é¢‘è¾“å‡ºåï¼Œåœ¨AudioFlingerä¸AudioPolicyServiceä¸­çš„è¡¨ç°å½¢å¼å¦‚ä¸‹ï¼š æ‰“å¼€éŸ³é¢‘è¾“å…¥:æ‰“å¼€éŸ³é¢‘è¾“å…¥åï¼Œåœ¨AudioFlingerä¸AudioPolicyServiceä¸­çš„è¡¨ç°å½¢å¼å¦‚ä¸‹ï¼š 2.3.5ã€ æ›´æ–°ç³»ç»Ÿç¼“å­˜çš„éŸ³é¢‘è¾“å‡ºè®¾å¤‡ä¿¡æ¯updateDevicesAndOutputs()12345678[-&gt;\\frameworks\\av\\services\\audiopolicy\\managerdefault\\AudioPolicyManager.cpp]void AudioPolicyManager::updateDevicesAndOutputs()&#123; for (int i = 0; i &lt; NUM_STRATEGIES; i++) &#123; mDeviceForStrategy[i] = getDeviceForStrategy((routing_strategy)i, false /*fromCache*/); &#125; mPreviousOutputs = mOutputs;&#125; 2.4ã€æ€»ç»“-&gt;æ‰“å¼€éŸ³é¢‘è¾“å‡ºæ—¶åˆ›å»ºä¸€ä¸ªaudio_stream_outé€šé“ï¼Œå¹¶åˆ›å»ºAudioStreamOutå¯¹è±¡ä»¥åŠæ–°å»ºPlaybackThreadæ’­æ”¾çº¿ç¨‹ã€‚ -&gt; æ‰“å¼€éŸ³é¢‘è¾“å…¥æ—¶åˆ›å»ºä¸€ä¸ªaudio_stream_iné€šé“ï¼Œå¹¶åˆ›å»ºAudioStreamInå¯¹è±¡ä»¥åŠåˆ›å»ºRecordThreadå½•éŸ³çº¿ç¨‹ã€‚ (ä¸‰)ã€æ·±å…¥å‰–æAndroidéŸ³é¢‘ä¹‹AudioTrackç°åœ¨æˆ‘ä»¬å¼€å§‹åˆ†æ AudioTrack çš„åˆ›å»ºè¿‡ç¨‹ï¼Œç‰¹åˆ«ç•™æ„ AudioTrack ä¸ AudioFlinger å¦‚ä½•å»ºç«‹è”ç³»ã€ç”¨äº AudioTrack ä¸ AudioFlinger äº¤æ¢æ•°æ®çš„åŒ¿åå…±äº«å†…å­˜å¦‚ä½•åˆ†é…ã€‚ 3.1. AudioTrack &amp; AudioFlinger ç›¸å…³ç±»æ—¶åºå›¾ï¼š é¦–å…ˆçœ‹ä¸€ä¸‹ AudioTrack &amp; AudioFlinger çš„ç±»å›¾ï¼Œç†ä¸€ä¸‹ AudioFlinger çš„ä¸»è¦ç±»åŠå…¶å…³ç³»ã€AudioTrack ä¸ AudioFlinger ä¹‹é—´çš„è”ç³»ï¼Œåé¢å°†ä»¥è¯¥å›¾ä¸ºè„‰ç»œå±•å¼€åˆ†æã€‚ â˜¯ AudioFlinger::PlaybackThreadï¼šå›æ”¾çº¿ç¨‹åŸºç±»ï¼Œä¸åŒè¾“å‡ºæ ‡è¯†çš„éŸ³é¢‘æµå¯¹åº”ä¸åŒç±»å‹çš„ PlaybackThread å®ä¾‹ï¼ˆåˆ†ä¸ºå››ç§ï¼šMixerThreadã€DirectOutputThreadã€DuplicatingThreadã€OffloadThreadï¼‰ï¼Œå…·ä½“è§ 3.4. AudioFlinger å›æ”¾å½•åˆ¶çº¿ç¨‹ å°èŠ‚ï¼Œæ‰€æœ‰çš„ PlaybackThread å®ä¾‹éƒ½ä¼šæ·»åŠ åˆ° AudioFlinger.mPlaybackThreads å‘é‡ä¸­ï¼›è¿™ä¸ªå‘é‡çš„å®šä¹‰ï¼š DefaultKeyedVector&lt; audio_io_handle_t, sp &gt; mPlaybackThreads;ï¼Œå¯è§ audio_io_handle_t æ˜¯ä¸ PlaybackThread æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œç”±å·²çŸ¥çš„ audio_io_handle_t å°±èƒ½æ‰¾åˆ°å¯¹åº”çš„ PlaybackThreadï¼›audio_io_handle_t åœ¨åˆ›å»º PlaybackThread æ—¶ç”±ç³»ç»Ÿåˆ†é…ï¼Œè¿™ä¸ªå€¼æ˜¯å…¨å±€å”¯ä¸€çš„â˜¯ AudioFlinger::PlaybackThread::Trackï¼šéŸ³é¢‘æµç®¡ç†ç±»ï¼Œåˆ›å»ºä¸€å—åŒ¿åå…±äº«å†…å­˜ç”¨äº AudioTrack ä¸ AudioFlinger ä¹‹é—´çš„æ•°æ®äº¤æ¢ï¼ˆæ–¹ä¾¿èµ·è§ï¼Œè¿™å—åŒ¿åå…±äº«å†…å­˜ï¼Œä»¥åå‡ç®€å•ç§°ä¸º FIFOï¼‰ï¼ŒåŒæ—¶å®ç° start()ã€stop()ã€pause() ç­‰éŸ³é¢‘æµå¸¸ç”¨æ§åˆ¶æ‰‹æ®µï¼›æ³¨æ„ï¼Œå¤šä¸ª Track å¯¹è±¡å¯èƒ½éƒ½æ³¨å†Œåˆ°åŒä¸€ä¸ª PlaybackThread ä¸­ï¼ˆå°¤å…¶å¯¹äº MixerThread è€Œè¨€ï¼Œä¸€ä¸ª MixerThread å¾€å¾€æŒ‚ç€å¤šä¸ª Track å¯¹è±¡ï¼‰ï¼Œè¿™å¤šä¸ª Track å¯¹è±¡éƒ½ä¼šæ·»åŠ åˆ° PlaybackThread.mTracks å‘é‡ä¸­ç»Ÿä¸€ç®¡ç†â˜¯ AudioFlinger::TrackHandleï¼šTrack å¯¹è±¡åªè´Ÿè´£éŸ³é¢‘æµç®¡ç†ä¸šåŠ¡ï¼Œå¯¹å¤–å¹¶æ²¡æœ‰æä¾›è·¨è¿›ç¨‹çš„ Binder è°ƒç”¨æ¥å£ï¼Œè€Œåº”ç”¨è¿›ç¨‹åˆéœ€è¦å¯¹éŸ³é¢‘æµè¿›è¡Œæ§åˆ¶ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªå¯¹è±¡æ¥ä»£ç† Track çš„è·¨è¿›ç¨‹é€šè®¯ï¼Œè¿™ä¸ªè§’è‰²å°±æ˜¯ TrackHandleï¼ŒAudioTrack é€šè¿‡å®ƒä¸ Track äº¤äº’â˜¯ AudioTrackï¼šAndroid éŸ³é¢‘ç³»ç»Ÿå¯¹å¤–æä¾›çš„ä¸€ä¸ª API ç±»ï¼Œè´Ÿè´£éŸ³é¢‘æµæ•°æ®è¾“å‡ºï¼›æ¯ä¸ªéŸ³é¢‘æµå¯¹åº”ç€ä¸€ä¸ª AudioTrack å®ä¾‹ï¼Œä¸åŒè¾“å‡ºæ ‡è¯†çš„ AudioTrack ä¼šåŒ¹é…åˆ°ä¸åŒçš„ AudioFlinger::PlaybackThreadï¼›AudioTrack ä¸ AudioFlinger::PlaybackThread ä¹‹é—´é€šè¿‡ FIFO æ¥äº¤æ¢éŸ³é¢‘æ•°æ®ï¼ŒAudioTrack æ˜¯ FIFO ç”Ÿäº§è€…ï¼ŒAudioFlinger::PlaybackThread æ˜¯ FIFO æ¶ˆè´¹è€…â˜¯ AudioTrack::AudioTrackThreadï¼šæ•°æ®ä¼ è¾“æ¨¡å¼ä¸º TRANSFER_CALLBACK æ—¶ï¼Œéœ€è¦åˆ›å»ºè¯¥çº¿ç¨‹ï¼Œå®ƒé€šè¿‡è°ƒç”¨ audioCallback å›è°ƒå‡½æ•°ä¸»åŠ¨ä»ç”¨æˆ·è¿›ç¨‹å¤„ç´¢å–æ•°æ®å¹¶å¡«å……åˆ° FIFO ä¸Šï¼›æ•°æ®ä¼ è¾“æ¨¡å¼ä¸º TRANSFER_SYNC æ—¶ï¼Œåˆ™ä¸éœ€è¦åˆ›å»ºè¿™ä¸ªçº¿ç¨‹ï¼Œå› ä¸ºç”¨æˆ·è¿›ç¨‹ä¼šæŒç»­è°ƒç”¨ AudioTrack.write() å¡«å……æ•°æ®åˆ° FIFOï¼›æ•°æ®ä¼ è¾“æ¨¡å¼ä¸º TRANSFER_SHARED æ—¶ï¼Œä¹Ÿä¸éœ€è¦åˆ›å»ºè¿™ä¸ªçº¿ç¨‹ï¼Œå› ä¸ºç”¨æˆ·è¿›ç¨‹ä¼šåˆ›å»ºä¸€å—åŒ¿åå…±äº«å†…å­˜ï¼Œå¹¶æŠŠè¦æ’­æ”¾çš„éŸ³é¢‘æ•°æ®ä¸€æ¬¡æ€§æ‹·è´åˆ°è¿™å—åŒ¿åå…±äº«å†…å­˜ä¸Šäº†â˜¯ IAudioTrackï¼šIAudioTrack æ˜¯é“¾ç»“ AudioTrack ä¸ AudioFlinger çš„æ¡¥æ¢ï¼›å®ƒåœ¨ AudioTrack ç«¯çš„å¯¹è±¡æ˜¯ BpAudioTrackï¼Œåœ¨ AudioFlinger ç«¯çš„å¯¹è±¡æ˜¯ BnAudioTrackï¼Œä»å›¾ä¸­ä¸éš¾çœ‹å‡ºï¼ŒAudioFlinger::TrackHandle ç»§æ‰¿è‡ª BnAudioTrackï¼Œè€Œ AudioFlinger::TrackHandle æ°æ°æ˜¯AudioFlinger::PlaybackThread::Track çš„ä»£ç†å¯¹è±¡ï¼Œæ‰€ä»¥ AudioTrack å¾—åˆ° IAudioTrack å®ä¾‹åï¼Œå°±å¯ä»¥è°ƒç”¨ IAudioTrack çš„æ¥å£ä¸ AudioFlinger::PlaybackThread::Track äº¤äº’ audio_io_handle_tï¼š è¿™é‡Œå†è¯¦ç»†è¯´æ˜ä¸€ä¸‹ audio_io_handle_tï¼Œå®ƒæ˜¯ AudioTrack/AudioRecord/AudioSystemã€AudioFlingerã€AudioPolicyManager ä¹‹é—´ä¸€ä¸ªé‡è¦çš„é“¾ç»“ç‚¹ã€‚3.4. AudioFlinger å›æ”¾å½•åˆ¶çº¿ç¨‹ å°èŠ‚åœ¨ AudioFlinger::openOutput_l() æ³¨é‡Šä¸­å¤§è‡´è¯´æ˜äº†å®ƒçš„æ¥å†åŠå…¶ä½œç”¨ï¼Œç°åœ¨å›é¡¾ä¸‹ï¼šå½“æ‰“å¼€è¾“å‡ºæµè®¾å¤‡åŠåˆ›å»º PlaybackThread æ—¶ï¼Œç³»ç»Ÿä¼šåˆ†é…ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„å€¼ä½œä¸º audio_io_handle_tï¼Œå¹¶æŠŠ audio_io_handle_t å’Œ PlaybackThread æ·»åŠ åˆ°é”®å€¼å¯¹å‘é‡ mPlaybackThreads ä¸­ï¼Œç”±äº audio_io_handle_t å’Œ PlaybackThread æ˜¯ä¸€ä¸€å¯¹åº”çš„å…³ç³»ï¼Œå› æ­¤æ‹¿åˆ°ä¸€ä¸ª audio_io_handle_tï¼Œå°±èƒ½éå†é”®å€¼å¯¹å‘é‡ mPlaybackThreads æ‰¾åˆ°å®ƒå¯¹åº”çš„ PlaybackThreadï¼Œå¯ä»¥ç®€å•ç†è§£ audio_io_handle_t ä¸º PlaybackThread çš„ç´¢å¼•å·æˆ–çº¿ç¨‹ idã€‚ç”±äº audio_io_handle_t å…·æœ‰ PlaybackThread ç´¢å¼•ç‰¹æ€§ï¼Œæ‰€ä»¥åº”ç”¨è¿›ç¨‹æƒ³è·å– PlaybackThread æŸäº›ä¿¡æ¯çš„è¯ï¼Œåªéœ€è¦ä¼ å…¥å¯¹åº”çš„ audio_io_handle_t å³å¯ã€‚ä¾‹å¦‚ AudioFlinger::format(audio_io_handle_t output)ï¼Œè¿™æ˜¯ AudioFlinger çš„ä¸€ä¸ªæœåŠ¡æ¥å£ï¼Œç”¨æˆ·è¿›ç¨‹å¯ä»¥é€šè¿‡è¯¥æ¥å£è·å–æŸä¸ª PlaybackThread é…ç½®çš„éŸ³é¢‘æ ¼å¼ï¼š 123456789101112131415161718[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]audio_format_t AudioFlinger::format(audio_io_handle_t output) const&#123; Mutex::Autolock _l(mLock); // checkPlaybackThread_l() æ ¹æ®ä¼ å…¥çš„ audio_io_handle_tï¼Œä»é”®å€¼å¯¹å‘é‡ // mPlaybackThreads ä¸­æ‰¾åˆ°å®ƒå¯¹åº”çš„ PlaybackThread PlaybackThread *thread = checkPlaybackThread_l(output); if (thread == NULL) &#123; ALOGW(\"format() unknown thread %d\", output); return AUDIO_FORMAT_INVALID; &#125; return thread-&gt;format();&#125;AudioFlinger::PlaybackThread *AudioFlinger::checkPlaybackThread_l(audio_io_handle_t output) const&#123; return mPlaybackThreads.valueFor(output).get();&#125; 3.2. AudioTrack æ„é€ è¿‡ç¨‹å½“æˆ‘ä»¬æ„é€ ä¸€ä¸ª AudioTrack å®ä¾‹æ—¶ï¼ˆä»¥ MODE_STREAM/TRANSFER_SYNC æ¨¡å¼ä¸ºä¾‹ï¼Œè¿™ä¹Ÿæ˜¯æœ€å¸¸ç”¨çš„æ¨¡å¼äº†ï¼Œæ­¤æ—¶ sharedBuffer ä¸ºç©ºï¼‰ï¼Œç³»ç»Ÿéƒ½å‘ç”Ÿäº†ä»€ä¹ˆäº‹ï¼Ÿé˜è¿°ä¸‹å¤§è‡´æµç¨‹ï¼š å¦‚æœ cbfï¼ˆaudioCallback å›è°ƒå‡½æ•°ï¼‰éç©ºï¼Œé‚£ä¹ˆåˆ›å»º AudioTrackThread çº¿ç¨‹å¤„ç† audioCallback å›è°ƒå‡½æ•°ï¼ˆMODE_STREAM æ¨¡å¼æ—¶ï¼Œcbf ä¸ºç©ºï¼‰ï¼›æ ¹æ® streamTypeï¼ˆæµç±»å‹ï¼‰ã€flagsï¼ˆè¾“å‡ºæ ‡è¯†ï¼‰ç­‰å‚æ•°è°ƒç”¨ AudioSystem::getOutputForAttr()ï¼›ç»è¿‡ä¸€ç³»åˆ—çš„è°ƒç”¨ï¼Œè¿›å…¥ AudioPolicyManager::getOutputForDevice()ï¼šå¦‚æœè¾“å‡ºæ ‡è¯†ç½®äº† AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD æˆ– AUDIO_OUTPUT_FLAG_DIRECTï¼Œé‚£ä¹ˆæœ€ç»ˆè°ƒç”¨ AudioFlinger::openOutput() æ‰“å¼€è¾“å‡ºæ ‡è¯†å¯¹åº”çš„è¾“å‡ºæµè®¾å¤‡å¹¶åˆ›å»ºç›¸åº”çš„ PlaybackThreadï¼Œä¿å­˜è¯¥ PlaybackThread å¯¹åº”çš„ audio_io_handle_t ç»™ AudioTrackï¼›å¦‚æœè¾“å‡ºæ ‡è¯†æ˜¯å…¶ä»–ç±»å‹ï¼Œé‚£ä¹ˆæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸€ä¸ªè¾“å‡ºæµè®¾å¤‡å’Œ PlaybackThreadï¼Œå¹¶ä¿å­˜è¯¥ PlaybackThread å¯¹åº”çš„ audio_io_handle_t ç»™ AudioTrackï¼›åˆ«å¿˜äº†åœ¨ 3.4. AudioFlinger å›æ”¾å½•åˆ¶çº¿ç¨‹ å°èŠ‚ä¸­æåˆ°ï¼šç³»ç»Ÿå¯åŠ¨æ—¶ï¼Œå°±å·²ç»æ‰“å¼€ primary_outã€low_latencyã€deep_buffer è¿™ä¸‰ç§è¾“å‡ºæµè®¾å¤‡ï¼Œå¹¶åˆ›å»ºå¯¹åº”çš„ PlaybackThread äº†ï¼›é€šè¿‡ Binder æœºåˆ¶è°ƒç”¨ AudioFlinger::createTrack()ï¼ˆæ³¨æ„ step2 ä¸­ AudioTrack å·²ç»æ‹¿åˆ°ä¸€ä¸ª audio_io_handle_t äº†ï¼Œæ­¤æ—¶æŠŠè¿™ä¸ª audio_io_handle_t ä¼ å…¥ç»™ createTrack()ï¼‰ï¼šæ ¹æ®ä¼ å…¥çš„ audio_io_handle_t æ‰¾åˆ°å®ƒå¯¹åº”çš„ PlaybackThreadï¼›PlaybackThread æ–°å»ºä¸€ä¸ªéŸ³é¢‘æµç®¡ç†å¯¹è±¡ Trackï¼›Track æ„é€ æ—¶ä¼šåˆ†é…ä¸€å—åŒ¿åå…±äº«å†…å­˜ç”¨äº AudioFlinger ä¸ AudioTrack çš„æ•°æ®äº¤æ¢ç¼“å†²åŒºï¼ˆFIFOï¼‰åŠå…¶æ§åˆ¶å—ï¼ˆaudio_track_cblk_tï¼‰ï¼Œå¹¶åˆ›å»ºä¸€ä¸ª AudioTrackServerProxy å¯¹è±¡ï¼ˆPlaybackThread å°†ä½¿ç”¨å®ƒä» FIFO ä¸Šå–å¾—å¯è¯»æ•°æ®çš„ä½ç½®ï¼‰ï¼›æœ€åæ–°å»ºä¸€ä¸ª Track çš„é€šè®¯ä»£ç† TrackHandleï¼Œå¹¶ä»¥ IAudioTrack ä½œä¸ºè¿”å›å€¼ç»™ AudioTrackï¼ˆTrackHandleã€BnAudioTrackã€BpAudioTrackã€IAudioTrack çš„å…³ç³»è§ä¸Šä¸€ä¸ªå°èŠ‚ï¼‰ï¼›é€šè¿‡ IAudioTrack æ¥å£ï¼Œå–å¾— AudioFlinger ä¸­çš„ FIFO æ§åˆ¶å—ï¼ˆaudio_track_cblk_tï¼‰ï¼Œç”±æ­¤å†è®¡ç®—å¾—åˆ° FIFO çš„é¦–åœ°å€ï¼›åˆ›å»ºä¸€ä¸ª AudioTrackClientProxy å¯¹è±¡ï¼ˆAudioTrack å°†ä½¿ç”¨å®ƒä» FIFO ä¸Šå–å¾—å¯ç”¨ç©ºé—´çš„ä½ç½®ï¼‰ï¼›AudioTrack ç”±æ­¤å»ºç«‹äº†å’Œ AudioFlinger çš„å…¨éƒ¨è”ç³»å·¥ä½œï¼š é€šè¿‡ IAudioTrack æ¥å£å¯ä»¥æ§åˆ¶è¯¥éŸ³è½¨çš„çŠ¶æ€ï¼Œä¾‹å¦‚ startã€stopã€pauseæŒç»­å†™å…¥æ•°æ®åˆ° FIFO ä¸Šï¼Œå®ç°éŸ³é¢‘è¿ç»­æ’­æ”¾é€šè¿‡ audio_io_handle_tï¼Œå¯ä»¥æ‰¾åˆ°å®ƒå¯¹åº”çš„ PlaybackThreadï¼Œä»è€ŒæŸ¥è¯¢è¯¥ PlaybackThread çš„ç›¸å…³ä¿¡æ¯ï¼Œå¦‚æ‰€è®¾ç½®çš„é‡‡æ ·ç‡ã€æ ¼å¼ç­‰ç­‰æ„é€  1 ä¸ª AudioTrack å®ä¾‹æ—¶ï¼ŒAudioFlinger ä¼šæœ‰ 1 ä¸ª PlaybackThread å®ä¾‹ã€1 ä¸ª Track å®ä¾‹ã€1 ä¸ª TrackHandle å®ä¾‹ã€1 ä¸ª AudioTrackServerProxy å®ä¾‹ã€1 å— FIFO ä¸ä¹‹å¯¹åº”ã€‚ å½“åŒæ—¶æ„é€  1 ä¸ª AudioTrack with AUDIO_OUTPUT_FLAG_PRIMARYã€1 ä¸ª AudioTrack with AUDIO_OUTPUT_FLAG_FASTã€3 ä¸ª AudioTrack with AUDIO_OUTPUT_FLAG_DEEP_BUFFERã€1 ä¸ª AudioTrack with AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOADã€1 ä¸ª AudioTrack with AUDIO_OUTPUT_FLAG_DIRECT æ—¶ï¼ˆäº‹å®ä¸Šï¼ŒAndroid éŸ³é¢‘ç­–ç•¥ä¸å…è®¸å‡ºç°è¿™ç§æƒ…å½¢çš„ï¼‰ï¼ŒAudioFlinger æ‹¥æœ‰çš„ PlaybackThreadã€Trackã€TrackHandle å®ä¾‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æœ€åé™„ä¸Šç›¸å…³ä»£ç çš„æµç¨‹åˆ†æï¼Œæˆ‘æœ¬æ„æ˜¯ä¸å¤šè´´ä»£ç çš„ï¼Œä½†ä¸ä¸Šä»£ç æ€»è§‰å¾—ç¼ºç‚¹ä»€ä¹ˆï¼Œè¿™é‡Œæˆ‘å°½é‡æŠŠä»£ç ç²¾ç®€ï¼Œæå–ä¸»å¹²ï¼Œå¿½ç•¥ç»†èŠ‚ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140[-&gt;\\frameworks\\av\\media\\libmedia\\AudioTrack.cpp]AudioTrack::AudioTrack( audio_stream_type_t streamType, // éŸ³é¢‘æµç±»å‹ï¼šå¦‚ Musicã€Voice-Callã€DTMFã€Alarm ç­‰ç­‰ uint32_t sampleRate, // é‡‡æ ·ç‡ï¼šå¦‚ 16KHzã€44.1KHzã€48KHz ç­‰ç­‰ audio_format_t format, // éŸ³é¢‘æ ¼å¼ï¼šå¦‚ PCMã€MP3ã€AAC ç­‰ç­‰ audio_channel_mask_t channelMask, // å£°é“æ•°ï¼šå¦‚ Monoï¼ˆå•å£°é“ï¼‰ã€Stereoï¼ˆåŒå£°é“ï¼‰ const sp&lt;IMemory&gt;&amp; sharedBuffer, // å…±äº«å†…å­˜ç¼“å†²åŒºï¼šæ•°æ®æ¨¡å¼æ˜¯ MODE_STATIC æ—¶ä½¿ç”¨ï¼Œæ•°æ®æ¨¡å¼æ˜¯ MODE_STREAM æ—¶ä¸ºç©º audio_output_flags_t flags, // è¾“å‡ºæ ‡è¯†ä½ï¼Œè¯¦è§ AUDIO_OUTPUT_FLAG æè¿° callback_t cbf, // å›è°ƒå‡½æ•° void* user, // å›è°ƒå‡½æ•°çš„å‚æ•° uint32_t notificationFrames, int sessionId, transfer_type transferType, // æ•°æ®ä¼ è¾“ç±»å‹ const audio_offload_info_t *offloadInfo, int uid, pid_t pid, const audio_attributes_t* pAttributes, bool doNotReconnect) : mStatus(NO_INIT), mIsTimed(false), mPreviousPriority(ANDROID_PRIORITY_NORMAL), mPreviousSchedulingGroup(SP_DEFAULT), mPausedPosition(0), mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)&#123; mStatus = set(streamType, sampleRate, format, channelMask, 0 /*frameCount*/, flags, cbf, user, notificationFrames, sharedBuffer, false /*threadCanCallJava*/, sessionId, transferType, offloadInfo, uid, pid, pAttributes, doNotReconnect);&#125;status_t AudioTrack::set( audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t frameCount, audio_output_flags_t flags, callback_t cbf, void* user, uint32_t notificationFrames, const sp&lt;IMemory&gt;&amp; sharedBuffer, bool threadCanCallJava, int sessionId, transfer_type transferType, const audio_offload_info_t *offloadInfo, int uid, pid_t pid, const audio_attributes_t* pAttributes, bool doNotReconnect)&#123; // å‚æ•°æ ¼å¼åˆæ³•æ€§æ£€æŸ¥ã€éŸ³è½¨éŸ³é‡åˆå§‹åŒ– // å¦‚æœ cbf éç©ºï¼Œé‚£ä¹ˆåˆ›å»º AudioTrackThread çº¿ç¨‹å¤„ç† audioCallback å›è°ƒå‡½æ•° if (cbf != NULL) &#123; mAudioTrackThread = new AudioTrackThread(*this, threadCanCallJava); mAudioTrackThread-&gt;run(\"AudioTrack\", ANDROID_PRIORITY_AUDIO, 0 /*stack*/); // thread begins in paused state, and will not reference us until start() &#125; // create the IAudioTrack status_t status = createTrack_l(); //......&#125;status_t AudioTrack::createTrack_l()&#123; // è·å– IAudioFlingerï¼Œé€šè¿‡ binder è¯·æ±‚ AudioFlinger æœåŠ¡ const sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger(); if (audioFlinger == 0) &#123; ALOGE(\"Could not get audioflinger\"); return NO_INIT; &#125; //...... // AudioSystem::getOutputForAttr() ç»è¿‡ä¸€ç³»åˆ—çš„è°ƒç”¨ï¼Œè¿›å…¥ AudioPolicyManager::getOutputForDevice() // å¦‚æœè¾“å‡ºæ ‡è¯†ç½®äº† AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD æˆ– AUDIO_OUTPUT_FLAG_DIRECTï¼Œ // é‚£ä¹ˆæœ€ç»ˆè°ƒç”¨ AudioFlinger::openOutput() æ‰“å¼€è¾“å‡ºæ ‡è¯†å¯¹åº”çš„è¾“å‡ºæµè®¾å¤‡å¹¶åˆ›å»ºç›¸å…³çš„ // PlaybackThreadï¼Œä¿å­˜è¯¥ PlaybackThread å¯¹åº”çš„ audio_io_handle_t ç»™ AudioTrackï¼› // å¦‚æœè¾“å‡ºæ ‡è¯†æ˜¯å…¶ä»–ç±»å‹ï¼Œé‚£ä¹ˆæ ¹æ®ç­–ç•¥é€‰æ‹©ä¸€ä¸ªè¾“å‡ºæµè®¾å¤‡å’Œ PlaybackThreadï¼Œå¹¶ä¿å­˜è¯¥ // PlaybackThread å¯¹åº”çš„ audio_io_handle_t ç»™ AudioTrack audio_io_handle_t output; status = AudioSystem::getOutputForAttr(attr, &amp;output, (audio_session_t)mSessionId, &amp;streamType, mClientUid, mSampleRate, mFormat, mChannelMask, mFlags, mSelectedDeviceId, mOffloadInfo); //...... // å‘ AudioFlinger å‘å‡º createTrack è¯·æ±‚ sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType, mSampleRate, mFormat, mChannelMask, &amp;temp, &amp;trackFlags, mSharedBuffer, output, tid, &amp;mSessionId, mClientUid, &amp;status); //...... // AudioFlinger åˆ›å»º Track å¯¹è±¡æ—¶ä¼šåˆ†é…ä¸€ä¸ª FIFOï¼Œè¿™é‡Œè·å– FIFO çš„æ§åˆ¶å— sp&lt;IMemory&gt; iMem = track-&gt;getCblk(); if (iMem == 0) &#123; ALOGE(\"Could not get control block\"); return NO_INIT; &#125; // åŒ¿åå…±äº«å†…å­˜é¦–åœ°å€ void *iMemPointer = iMem-&gt;pointer(); if (iMemPointer == NULL) &#123; ALOGE(\"Could not get control block pointer\"); return NO_INIT; &#125; mAudioTrack = track; // ä¿å­˜ AudioFlinger::PlaybackThread::Track çš„ä»£ç†å¯¹è±¡ IAudioTrack mCblkMemory = iMem; // ä¿å­˜åŒ¿åå…±äº«å†…å­˜é¦–åœ°å€ // æ§åˆ¶å—ä½äº AudioFlinger åˆ†é…çš„åŒ¿åå…±äº«å†…å­˜çš„é¦–éƒ¨ audio_track_cblk_t* cblk = static_cast&lt;audio_track_cblk_t*&gt;(iMemPointer); mCblk = cblk; mOutput = output; // ä¿å­˜è¿”å›çš„ audio_io_handle_tï¼Œç”¨å®ƒå¯ä»¥æ‰¾åˆ°å¯¹åº”çš„ PlaybackThread //...... // update proxy if (mSharedBuffer == 0) &#123; // å½“ mSharedBuffer ä¸ºç©ºï¼Œæ„å‘³ç€éŸ³è½¨æ•°æ®æ¨¡å¼ä¸º MODE_STREAMï¼Œé‚£ä¹ˆåˆ›å»º AudioTrackClientProxy å¯¹è±¡ mStaticProxy.clear(); mProxy = new AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize); &#125; else &#123; // å½“ mSharedBuffer éç©ºï¼Œæ„å‘³ç€éŸ³è½¨æ•°æ®æ¨¡å¼ä¸º MODE_STATICï¼Œé‚£ä¹ˆåˆ›å»º StaticAudioTrackClientProxy å¯¹è±¡ mStaticProxy = new StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize); mProxy = mStaticProxy; &#125; //......&#125; AudioFlinger::createTrack()ï¼Œé¡¾åæ€ä¹‰ï¼Œåˆ›å»ºä¸€ä¸ª Track å¯¹è±¡ï¼Œå°†ç”¨äºéŸ³é¢‘æµçš„æ§åˆ¶ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]sp&lt;IAudioTrack&gt; AudioFlinger::createTrack( audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t *frameCount, IAudioFlinger::track_flags_t *flags, const sp&lt;IMemory&gt;&amp; sharedBuffer, audio_io_handle_t output, pid_t tid, int *sessionId, int clientUid, status_t *status)&#123; sp&lt;PlaybackThread::Track&gt; track; sp&lt;TrackHandle&gt; trackHandle; sp&lt;Client&gt; client; status_t lStatus; int lSessionId; //...... &#123; Mutex::Autolock _l(mLock); // æ ¹æ®ä¼ å…¥æ¥çš„ audio_io_handle_tï¼Œæ‰¾åˆ°å¯¹åº”çš„ PlaybackThread PlaybackThread *thread = checkPlaybackThread_l(output); if (thread == NULL) &#123; ALOGE(&quot;no playback thread found for output handle %d&quot;, output); lStatus = BAD_VALUE; goto Exit; &#125; //...... // åœ¨ PlaybackThread ä¸Šåˆ›å»ºä¸€ä¸ªéŸ³é¢‘æµç®¡ç†å¯¹è±¡ Track track = thread-&gt;createTrack_l(client, streamType, sampleRate, format, channelMask, frameCount, sharedBuffer, lSessionId, flags, tid, clientUid, &amp;lStatus); //...... setAudioHwSyncForSession_l(thread, (audio_session_t)lSessionId); &#125; //...... // åˆ›å»º Track çš„é€šè®¯ä»£ç† TrackHandle å¹¶è¿”å›å®ƒ trackHandle = new TrackHandle(track);Exit: *status = lStatus; return trackHandle;&#125;sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l( const sp&lt;AudioFlinger::Client&gt;&amp; client, audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t *pFrameCount, const sp&lt;IMemory&gt;&amp; sharedBuffer, int sessionId, IAudioFlinger::track_flags_t *flags, pid_t tid, int uid, status_t *status)&#123; size_t frameCount = *pFrameCount; sp&lt;Track&gt; track; status_t lStatus; bool isTimed = (*flags &amp; IAudioFlinger::TRACK_TIMED) != 0; // ...... &#123; // scope for mLock Mutex::Autolock _l(mLock); // ...... if (!isTimed) &#123; // åˆ›å»º Trackï¼Œç­‰ä¼šå†çœ‹çœ‹ Track æ„é€ å‡½æ•°å¹²äº›å•¥ track = new Track(this, client, streamType, sampleRate, format, channelMask, frameCount, NULL, sharedBuffer, sessionId, uid, *flags, TrackBase::TYPE_DEFAULT); &#125; else &#123; // åˆ›å»º TimedTrackï¼Œå¸¦æ—¶é—´æˆ³çš„ Trackï¼Ÿè¿™é‡Œä¸æ·±ç©¶ track = TimedTrack::create(this, client, streamType, sampleRate, format, channelMask, frameCount, sharedBuffer, sessionId, uid); &#125; // ...... // æŠŠåˆ›å»ºçš„ Track æ·»åŠ åˆ° mTracks å‘é‡ä¸­ï¼Œæ–¹ä¾¿ PlaybackThread ç»Ÿä¸€ç®¡ç† mTracks.add(track); // ...... &#125; lStatus = NO_ERROR;Exit: *status = lStatus; return track;&#125;// ----------------------------------------------------------------------------// å¦‚ä¸‹æ˜¯ TrackHandle çš„ç›¸å…³ä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ï¼ŒTrackHandle å…¶å®å°±æ˜¯ä¸€ä¸ªå£³å­ï¼Œæ˜¯ Track çš„åŒ…è£…ç±»// æ‰€æœ‰ TrackHandle æ¥å£éƒ½æ˜¯è°ƒå‘ Track çš„// Google ä¸ºä»€ä¹ˆè¦æè¿™ä¹ˆä¸€åˆ™ï¼ŸTrack æ˜¯ PlaybackThread å†…éƒ¨ä½¿ç”¨çš„ï¼Œä¸é€‚å®œå¯¹å¤–æš´éœ²ï¼Œä½†åº”ç”¨è¿›ç¨‹// åˆç¡®å®éœ€è¦æ§åˆ¶éŸ³é¢‘æµçš„çŠ¶æ€ï¼ˆstartã€stopã€pauseï¼‰ï¼Œæ‰€ä»¥å°±é‡‡å–è¿™ä¹ˆä¸€ç§æ–¹å¼å®ç°AudioFlinger::TrackHandle::TrackHandle(const sp&lt;AudioFlinger::PlaybackThread::Track&gt;&amp; track) : BnAudioTrack(), mTrack(track)&#123;&#125;AudioFlinger::TrackHandle::~TrackHandle() &#123; // just stop the track on deletion, associated resources // will be freed from the main thread once all pending buffers have // been played. Unless it&apos;s not in the active track list, in which // case we free everything now... mTrack-&gt;destroy();&#125;sp&lt;IMemory&gt; AudioFlinger::TrackHandle::getCblk() const &#123; return mTrack-&gt;getCblk();&#125;status_t AudioFlinger::TrackHandle::start() &#123; return mTrack-&gt;start();&#125;void AudioFlinger::TrackHandle::stop() &#123; mTrack-&gt;stop();&#125;void AudioFlinger::TrackHandle::flush() &#123; mTrack-&gt;flush();&#125;void AudioFlinger::TrackHandle::pause() &#123; mTrack-&gt;pause();&#125;// ---------------------------------------------------------------------------- æœ€åï¼Œæˆ‘ä»¬çœ‹çœ‹ Track çš„æ„é€ è¿‡ç¨‹ï¼Œä¸»è¦åˆ†ææ•°æ® FIFO åŠå®ƒçš„æ§åˆ¶å—æ˜¯å¦‚ä½•åˆ†é…çš„ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]AudioFlinger::PlaybackThread::Track::Track( PlaybackThread *thread, const sp&lt;Client&gt;&amp; client, audio_stream_type_t streamType, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t frameCount, void *buffer, const sp&lt;IMemory&gt;&amp; sharedBuffer, int sessionId, int uid, IAudioFlinger::track_flags_t flags, track_type type) : TrackBase(thread, client, sampleRate, format, channelMask, frameCount, (sharedBuffer != 0) ? sharedBuffer-&gt;pointer() : buffer, sessionId, uid, flags, true /*isOut*/, (type == TYPE_PATCH) ? ( buffer == NULL ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK, type), mFillingUpStatus(FS_INVALID), // mRetryCount initialized later when needed mSharedBuffer(sharedBuffer), mStreamType(streamType), mName(-1), // see note below mMainBuffer(thread-&gt;mixBuffer()), mAuxBuffer(NULL), mAuxEffectId(0), mHasVolumeController(false), mPresentationCompleteFrames(0), mFastIndex(-1), mCachedVolume(1.0), mIsInvalid(false), mAudioTrackServerProxy(NULL), mResumeToStopping(false), mFlushHwPending(false)&#123; // client == 0 implies sharedBuffer == 0 ALOG_ASSERT(!(client == 0 &amp;&amp; sharedBuffer != 0)); ALOGV_IF(sharedBuffer != 0, \"sharedBuffer: %p, size: %d\", sharedBuffer-&gt;pointer(), sharedBuffer-&gt;size()); // æ£€æŸ¥ FIFO æ§åˆ¶å—ï¼ˆaudio_track_cblk_tï¼‰æ˜¯å¦åˆ†é…å¥½äº†ï¼Œä¸Šé¢ä»£ç å¹¶æœªåˆ†é… audio_track_cblk_t // å› æ­¤åªå¯èƒ½æ˜¯æ„é€  TrackBase æ—¶åˆ†é…çš„ï¼Œç­‰ä¸‹å†çœ‹çœ‹ TrackBase çš„æ„é€ å‡½æ•° if (mCblk == NULL) &#123; return; &#125; if (sharedBuffer == 0) &#123; // æ•°æ®ä¼ è¾“æ¨¡å¼ä¸º MODE_STREAM æ¨¡å¼ï¼Œåˆ›å»ºä¸€ä¸ª AudioTrackServerProxy å¯¹è±¡ // PlaybackThread å°†æŒç»­ä½¿ç”¨å®ƒä» FIFO ä¸Šå–å¾—å¯è¯»æ•°æ®çš„ä½ç½® mAudioTrackServerProxy = new AudioTrackServerProxy(mCblk, mBuffer, frameCount, mFrameSize, !isExternalTrack(), sampleRate); &#125; else &#123; // æ•°æ®ä¼ è¾“æ¨¡å¼ä¸º MODE_STATIC æ¨¡å¼ï¼Œåˆ›å»ºä¸€ä¸ª StaticAudioTrackServerProxy å¯¹è±¡ mAudioTrackServerProxy = new StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount, mFrameSize); &#125; mServerProxy = mAudioTrackServerProxy; // ä¸º Track åˆ†é…ä¸€ä¸ªåç§°ï¼ŒAudioMixer ä¼šæ ¹æ® TrackName æ‰¾åˆ°å¯¹åº”çš„ Track mName = thread-&gt;getTrackName_l(channelMask, format, sessionId); if (mName &lt; 0) &#123; ALOGE(\"no more track names available\"); return; &#125; // ......&#125;AudioFlinger::ThreadBase::TrackBase::TrackBase( ThreadBase *thread, const sp&lt;Client&gt;&amp; client, uint32_t sampleRate, audio_format_t format, audio_channel_mask_t channelMask, size_t frameCount, void *buffer, int sessionId, int clientUid, IAudioFlinger::track_flags_t flags, bool isOut, alloc_type alloc, track_type type) : RefBase(), mThread(thread), mClient(client), mCblk(NULL), // mBuffer mState(IDLE), mSampleRate(sampleRate), mFormat(format), mChannelMask(channelMask), mChannelCount(isOut ? audio_channel_count_from_out_mask(channelMask) : audio_channel_count_from_in_mask(channelMask)), mFrameSize(audio_is_linear_pcm(format) ? mChannelCount * audio_bytes_per_sample(format) : sizeof(int8_t)), mFrameCount(frameCount), mSessionId(sessionId), mFlags(flags), mIsOut(isOut), mServerProxy(NULL), mId(android_atomic_inc(&amp;nextTrackId)), mTerminated(false), mType(type), mThreadIoHandle(thread-&gt;id())&#123; // ...... // ALOGD(\"Creating track with %d buffers @ %d bytes\", bufferCount, bufferSize); size_t size = sizeof(audio_track_cblk_t); size_t bufferSize = (buffer == NULL ? roundup(frameCount) : frameCount) * mFrameSize; if (buffer == NULL &amp;&amp; alloc == ALLOC_CBLK) &#123; // è¿™ä¸ª size å°†æ˜¯åˆ†é…çš„åŒ¿åå…±äº«å†…å­˜çš„å¤§å° // ç­‰äºæ§åˆ¶å—çš„å¤§å°ï¼ˆsizeof(audio_track_cblk_t)åŠ ä¸Šæ•°æ® FIFOçš„å¤§å°ï¼ˆbufferSizeï¼‰ // å¾…ä¼šçœ‹åˆ°è¿™å—å†…å­˜çš„ç»“æ„ï¼Œå°±æ˜ç™½è¿™æ ·åˆ†é…çš„æ„ä¹‰äº† size += bufferSize; &#125; if (client != 0) &#123; // åˆ†é…ä¸€å—åŒ¿åå…±äº«å†…å­˜ mCblkMemory = client-&gt;heap()-&gt;allocate(size); if (mCblkMemory == 0 || (mCblk = static_cast&lt;audio_track_cblk_t *&gt;(mCblkMemory-&gt;pointer())) == NULL) &#123; ALOGE(\"not enough memory for AudioTrack size=%u\", size); client-&gt;heap()-&gt;dump(\"AudioTrack\"); mCblkMemory.clear(); return; &#125; &#125; else &#123; // this syntax avoids calling the audio_track_cblk_t constructor twice mCblk = (audio_track_cblk_t *) new uint8_t[size]; // assume mCblk != NULL &#125; // construct the shared structure in-place. if (mCblk != NULL) &#123; // è¿™æ˜¯ C++ çš„ placement newï¼ˆå®šä½åˆ›å»ºå¯¹è±¡ï¼‰è¯­æ³•ï¼šnew(@BUFFER) @CLASS(); // å¯ä»¥åœ¨ç‰¹å®šå†…å­˜ä½ç½®ä¸Šæ„é€ ä¸€ä¸ªå¯¹è±¡ // è¿™é‡Œï¼Œåœ¨åŒ¿åå…±äº«å†…å­˜é¦–åœ°å€ä¸Šæ„é€ äº†ä¸€ä¸ª audio_track_cblk_t å¯¹è±¡ // è¿™æ · AudioTrack ä¸ AudioFlinger éƒ½èƒ½è®¿é—®è¿™ä¸ª audio_track_cblk_t å¯¹è±¡äº† new(mCblk) audio_track_cblk_t(); // å¦‚ä¸‹åˆ†é…æ•°æ® FIFOï¼Œå°†ç”¨äº AudioTrack ä¸ AudioFlinger çš„æ•°æ®äº¤æ¢ switch (alloc) &#123; // ...... case ALLOC_CBLK: // clear all buffers if (buffer == NULL) &#123; // æ•°æ®ä¼ è¾“æ¨¡å¼ä¸º MODE_STREAM/TRANSFER_SYNC æ—¶ï¼Œæ•°æ® FIFO çš„åˆ†é… // æ•°æ® FIFO çš„é¦–åœ°å€ç´§é æ§åˆ¶å—ï¼ˆaudio_track_cblk_tï¼‰ä¹‹å // | | // | -------------------&gt; mCblkMemory &lt;--------------------- | // | | // +--------------------+------------------------------------+ // | audio_track_cblk_t | Buffer | // +--------------------+------------------------------------+ // ^ ^ // | | // mCblk mBuffer mBuffer = (char*)mCblk + sizeof(audio_track_cblk_t); memset(mBuffer, 0, bufferSize); &#125; else &#123; // æ•°æ®ä¼ è¾“æ¨¡å¼ä¸º MODE_STATIC/TRANSFER_SHARED æ—¶ï¼Œç›´æ¥æŒ‡å‘ sharedBuffer // sharedBuffer æ˜¯åº”ç”¨è¿›ç¨‹åˆ†é…çš„åŒ¿åå…±äº«å†…å­˜ï¼Œåº”ç”¨è¿›ç¨‹å·²ç»ä¸€æ¬¡æ€§æŠŠæ•°æ® // å†™åˆ° sharedBuffer æ¥äº†ï¼ŒAudioFlinger å¯ä»¥ç›´æ¥ä»è¿™é‡Œè¯»å– // +--------------------+ +-----------------------------------+ // | audio_track_cblk_t | | sharedBuffer | // +--------------------+ +-----------------------------------+ // ^ ^ // | | // mCblk mBuffer mBuffer = buffer; &#125; break; // ...... &#125; // ...... &#125;&#125; 3.3. AudioTrack æ•°æ®å†™å…¥AudioTrack å®ä¾‹æ„é€ åï¼Œåº”ç”¨ç¨‹åºæ¥ç€å¯ä»¥å†™å…¥éŸ³é¢‘æ•°æ®äº†ã€‚å¦‚ä¹‹å‰æ‰€æè¿°ï¼šAudioTrack ä¸ AudioFlinger æ˜¯ ç”Ÿäº§è€…-æ¶ˆè´¹è€… çš„å…³ç³»ï¼š â˜¯ AudioTrackï¼šAudioTrack åœ¨ FIFO ä¸­æ‰¾åˆ°ä¸€å—å¯ç”¨ç©ºé—´ï¼ŒæŠŠç”¨æˆ·ä¼ å…¥çš„éŸ³é¢‘æ•°æ®å†™å…¥åˆ°è¿™å—å¯ç”¨ç©ºé—´ä¸Šï¼Œç„¶åæ›´æ–°å†™ä½ç½®ï¼ˆå¯¹äº AudioFinger æ¥è¯´ï¼Œæ„å‘³ FIFO ä¸Šæœ‰æ›´å¤šçš„å¯è¯»æ•°æ®äº†ï¼‰ï¼›å¦‚æœç”¨æˆ·ä¼ å…¥çš„æ•°æ®é‡æ¯”å¯ç”¨ç©ºé—´è¦å¤§ï¼Œé‚£ä¹ˆè¦æŠŠç”¨æˆ·ä¼ å…¥çš„æ•°æ®æ‹†åˆ†å¤šæ¬¡å†™å…¥åˆ° FIFO ä¸­ï¼ˆAudioTrack å’Œ AudioFlinger æ˜¯ä¸åŒçš„è¿›ç¨‹ï¼ŒAudioFlinger åŒæ—¶ä¹Ÿåœ¨ä¸åœåœ°è¯»å–æ•°æ®ï¼Œæ‰€ä»¥ FIFO å¯ç”¨ç©ºé—´æ˜¯åœ¨ä¸åœå˜åŒ–çš„ï¼‰â˜¯ AudioFlingerï¼šAudioFlinger åœ¨ FIFO ä¸­æ‰¾åˆ°ä¸€å—å¯è¯»æ•°æ®å—ï¼ŒæŠŠå¯è¯»æ•°æ®æ‹·è´åˆ°ç›®çš„ç¼“å†²åŒºä¸Šï¼Œç„¶åæ›´æ–°è¯»ä½ç½®ï¼ˆå¯¹äº AudioTrack æ¥è¯´ï¼Œæ„å‘³ç€ FIFO ä¸Šæœ‰æ›´å¤šçš„å¯ç”¨ç©ºé—´äº†ï¼‰ï¼›å¦‚æœFIFO ä¸Šå¯è¯»æ•°æ®é‡æ¯”é¢„æœŸçš„è¦å°ï¼Œé‚£ä¹ˆè¦è¿›è¡Œå¤šæ¬¡çš„è¯»å–ï¼Œæ‰èƒ½ç§¯ç´¯åˆ°é¢„æœŸçš„æ•°æ®é‡ï¼ˆAudioTrack å’Œ AudioFlinger æ˜¯ä¸åŒçš„è¿›ç¨‹ï¼ŒAudioTrack åŒæ—¶ä¹Ÿåœ¨ä¸åœåœ°å†™å…¥æ•°æ®ï¼Œæ‰€ä»¥ FIFO å¯è¯»çš„æ•°æ®é‡æ˜¯åœ¨ä¸åœå˜åŒ–çš„ï¼‰ä¸Šé¢çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœ AudioTrack æ€»èƒ½åŠæ—¶ç”Ÿäº§æ•°æ®ï¼Œå¹¶ä¸” AudioFlinger æ€»èƒ½åŠæ—¶æ¶ˆè€—æ‰è¿™äº›æ•°æ®ï¼Œé‚£ä¹ˆæ•´ä¸ªè¿‡ç¨‹å°†æ˜¯éå¸¸å’Œè°çš„ï¼›ä½†ç³»ç»Ÿå¯èƒ½ä¼šå‘ç”Ÿå¼‚å¸¸ï¼Œå‡ºç°å¦‚ä¸‹çš„çŠ¶æ€ï¼š â˜¯ Blockï¼šAudioFlinger é•¿æ—¶é—´ä¸è¯»å– FIFO ä¸Šçš„å¯è¯»æ•°æ®ï¼Œä½¿å¾— AudioTrack é•¿æ—¶é—´è·å–ä¸åˆ°å¯ç”¨ç©ºé—´ï¼Œæ— æ³•å†™å…¥æ•°æ®ï¼›è¿™ç§æƒ…å†µçš„æ ¹æœ¬åŸå› å¤§å¤šæ˜¯åº•å±‚é©±åŠ¨å‘ç”Ÿé˜»å¡å¼‚å¸¸ï¼Œå¯¼è‡´ AudioFlinger æ— æ³•ç»§ç»­å†™æ•°æ®åˆ°ç¡¬ä»¶è®¾å¤‡ä¸­ï¼ŒAudioFlinger æœ¬èº«å¹¶æ²¡æœ‰é”™â˜¯ Underrunï¼šAudioTrack å†™å…¥æ•°æ®çš„é€Ÿåº¦è·Ÿä¸ä¸Š AudioFlinger è¯»å–æ•°æ®çš„é€Ÿåº¦ï¼Œä½¿å¾— AudioFlinger ä¸èƒ½åŠæ—¶è·å–åˆ°é¢„æœŸçš„æ•°æ®é‡ï¼Œåæ˜ åˆ°ç°å®çš„åæœå°±æ˜¯å£°éŸ³æ–­ç»­ï¼›è¿™ç§æƒ…å†µçš„æ ¹æœ¬åŸå› å¤§å¤šæ˜¯åº”ç”¨ç¨‹åºä¸èƒ½åŠæ—¶å†™å…¥æ•°æ®æˆ–è€…ç¼“å†²åŒºåˆ†é…è¿‡å°ï¼ŒAudioTrack æœ¬èº«å¹¶æ²¡æœ‰é”™ï¼›AudioFlinger é’ˆå¯¹è¿™ç‚¹åšäº†å®¹é”™å¤„ç†ï¼šå½“å‘ç° underrun æ—¶ï¼Œå…ˆé™·å…¥çŸ­æ—¶é—´çš„ç¡çœ ï¼Œä¸æ€¥ç€è¯»å–æ•°æ®ï¼Œè®©åº”ç”¨ç¨‹åºå‡†å¤‡æ›´å¤šçš„æ•°æ®ï¼ˆå¦‚æœæŸä¸€å¤©åšåº”ç”¨çš„å“¥ä»¬æ„è¯†åˆ°è‡ªå·±çš„é”™è¯¯åŸæ¥ç”±åº•å±‚çš„å…„å¼Ÿé»˜é»˜åŸ‹å•äº†ï¼Œä¼šä¸ä¼šæ„ŸåŠ¨å¾—å“­äº†^_^ï¼‰ 3.3. 1. AudioTrack å†™æ•°æ®æµç¨‹æˆ‘ä»¬çœ‹ä¸€ä¸‹ AudioTrack å†™æ•°æ®çš„ä»£ç ï¼Œæµç¨‹å¾ˆç®€å•ï¼šobtainBuffer() åœ¨ FIFO ä¸­æ‰¾åˆ°ä¸€å—å¯ç”¨åŒºé—´ï¼Œmemcpy() æŠŠç”¨æˆ·ä¼ å…¥çš„éŸ³é¢‘æ•°æ®æ‹·è´åˆ°è¿™ä¸ªå¯ç”¨åŒºé—´ä¸Šï¼ŒreleaseBuffer() æ›´æ–°å†™ä½ç½®ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[-&gt;\\frameworks\\av\\media\\libmedia\\AudioTrack.cpp]ssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)&#123; if (mTransfer != TRANSFER_SYNC) &#123; return INVALID_OPERATION; &#125; if (isDirect()) &#123; AutoMutex lock(mLock); int32_t flags = android_atomic_and( ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END), &amp;mCblk-&gt;mFlags); if (flags &amp; CBLK_INVALID) &#123; return DEAD_OBJECT; &#125; &#125; if (ssize_t(userSize) &lt; 0 || (buffer == NULL &amp;&amp; userSize != 0)) &#123; // Sanity-check: user is most-likely passing an error code, and it would // make the return value ambiguous (actualSize vs error). ALOGE(&quot;AudioTrack::write(buffer=%p, size=%zu (%zd)&quot;, buffer, userSize, userSize); return BAD_VALUE; &#125; size_t written = 0; Buffer audioBuffer; while (userSize &gt;= mFrameSize) &#123; // å•å¸§æ•°æ®é‡ frameSize = channelCount * bytesPerSample // å¯¹äºåŒå£°é“ï¼Œ16ä½é‡‡æ ·çš„éŸ³é¢‘æ•°æ®æ¥è¯´ï¼ŒframeSize = 2 * 2 = 4(bytes) // ç”¨æˆ·ä¼ å…¥çš„æ•°æ®å¸§æ•° frameCount = userSize / frameSize audioBuffer.frameCount = userSize / mFrameSize; // obtainBuffer() ä» FIFO ä¸Šå¾—åˆ°ä¸€å—å¯ç”¨åŒºé—´ status_t err = obtainBuffer(&amp;audioBuffer, blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking); if (err &lt; 0) &#123; if (written &gt; 0) &#123; break; &#125; if (err == TIMED_OUT || err == -EINTR) &#123; err = WOULD_BLOCK; &#125; return ssize_t(err); &#125; // toWrite æ˜¯ FIFO å¯ç”¨åŒºé—´çš„å¤§å°ï¼Œå¯èƒ½æ¯” userSizeï¼ˆç”¨æˆ·ä¼ å…¥æ•°æ®çš„å¤§å°ï¼‰è¦å° // å› æ­¤ç”¨æˆ·ä¼ å…¥çš„æ•°æ®å¯èƒ½è¦æ‹†åˆ†å¤šæ¬¡æ‹·è´åˆ° FIFO ä¸Š // æ³¨æ„ï¼šAudioTrack å’Œ AudioFlinger æ˜¯ä¸åŒçš„è¿›ç¨‹ï¼ŒAudioFlinger åŒæ—¶ä¹Ÿåœ¨ä¸åœåœ° // æ¶ˆè€—æ•°æ®ï¼Œæ‰€ä»¥ FIFO å¯ç”¨åŒºé—´æ˜¯åœ¨ä¸åœå˜åŒ–çš„ size_t toWrite = audioBuffer.size; memcpy(audioBuffer.i8, buffer, toWrite); // æŠŠç”¨æˆ·æ•°æ®æ‹·è´åˆ° FIFO å¯ç”¨åŒºé—´ buffer = ((const char *) buffer) + toWrite; // æœªæ‹·è´æ•°æ®çš„ä½ç½® userSize -= toWrite; // æœªæ‹·è´æ•°æ®çš„å¤§å° written += toWrite; // å·²æ‹·è´æ•°æ®çš„å¤§å° // releaseBuffer() æ›´æ–° FIFO å†™ä½ç½® // å¯¹äº AudioFinger æ¥è¯´ï¼Œæ„å‘³ FIFO ä¸Šæœ‰æ›´å¤šçš„å¯è¯»æ•°æ® releaseBuffer(&amp;audioBuffer); &#125; if (written &gt; 0) &#123; mFramesWritten += written / mFrameSize; &#125; return written;&#125; 3.3. 2. AudioFlinger è¯»æ•°æ®æµç¨‹AudioFlinger æ¶ˆè´¹æ•°æ®çš„æµç¨‹ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œ3.4. AudioFlinger å›æ”¾å½•åˆ¶çº¿ç¨‹ å°èŠ‚ä¸­æè¿°äº† AudioFlinger::PlaybackThread::threadLoop() å·¥ä½œæµç¨‹ï¼Œè¿™é‡Œä¸ç´¯è¿°äº†ï¼Œæˆ‘ä»¬æŠŠç„¦ç‚¹æ”¾åœ¨â€œå¦‚ä½•ä» FIFO è¯»å–æ•°æ®â€èŠ‚ç‚¹ä¸Šã€‚ æˆ‘ä»¬ä»¥ DirectOutputThread/OffloadThread ä¸ºä¾‹è¯´æ˜ï¼ˆMixerThread è¯»æ•°æ®ä¹Ÿæ˜¯ç±»ä¼¼çš„è¿‡ç¨‹ï¼Œåªä¸è¿‡æ˜¯åœ¨ AudioMixer ä¸­è¿›è¡Œçš„ï¼‰ã€‚ 1234567891011121314151617181920212223242526272829303132333435[-&gt;\\frameworks\\av\\services\\audioflinger\\AudioFlinger.cpp]void AudioFlinger::DirectOutputThread::threadLoop_mix()&#123; // mFrameCount æ˜¯ç¡¬ä»¶è®¾å¤‡ï¼ˆPCM è®¾å¤‡ï¼‰å¤„ç†å•ä¸ªæ•°æ®å—çš„å¸§æ•°ï¼ˆå‘¨æœŸå¤§å°ï¼‰ // ä¸Šå±‚å¿…é¡»ç§¯ç´¯äº†è¶³å¤Ÿå¤šï¼ˆmFrameCountï¼‰çš„æ•°æ®ï¼Œæ‰å†™å…¥åˆ° PCM è®¾å¤‡ // æ‰€ä»¥ mFrameCount ä¹Ÿå°±æ˜¯ AudioFlinger é¢„æœŸçš„æ•°æ®é‡ size_t frameCount = mFrameCount; // mSinkBuffer ç›®çš„ç¼“å†²åŒºï¼ŒthreadLoop_write() ä¼šæŠŠ mSinkBuffer ä¸Šçš„æ•°æ®å†™åˆ° PCM è®¾å¤‡ int8_t *curBuf = (int8_t *)mSinkBuffer; // output audio to hardware // FIFO ä¸Šå¯è¯»çš„æ•°æ®é‡å¯èƒ½è¦æ¯”é¢„æœŸçš„è¦å°ï¼Œå› æ­¤å¯èƒ½éœ€è¦å¤šæ¬¡è¯»å–æ‰èƒ½ç§¯ç´¯è¶³å¤Ÿçš„æ•°æ®é‡ // æ³¨æ„ï¼šAudioTrack å’Œ AudioFlinger æ˜¯ä¸åŒçš„è¿›ç¨‹ï¼ŒAudioTrack åŒæ—¶ä¹Ÿåœ¨ä¸åœåœ°ç”Ÿäº§æ•°æ® // æ‰€ä»¥ FIFO å¯è¯»çš„æ•°æ®é‡æ˜¯åœ¨ä¸åœå˜åŒ–çš„ while (frameCount) &#123; AudioBufferProvider::Buffer buffer; buffer.frameCount = frameCount; // getNextBuffer() ä» FIFO ä¸Šè·å–å¯è¯»æ•°æ®å— status_t status = mActiveTrack-&gt;getNextBuffer(&amp;buffer); if (status != NO_ERROR || buffer.raw == NULL) &#123; memset(curBuf, 0, frameCount * mFrameSize); break; &#125; // memcpy() æŠŠ FIFO å¯è¯»æ•°æ®æ‹·è´åˆ° mSinkBuffer ç›®çš„ç¼“å†²åŒº memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize); frameCount -= buffer.frameCount; curBuf += buffer.frameCount * mFrameSize; // releaseBuffer() æ›´æ–° FIFO è¯»ä½ç½® // å¯¹äº AudioTrack æ¥è¯´ï¼Œæ„å‘³ç€ FIFO ä¸Šæœ‰æ›´å¤šçš„å¯ç”¨ç©ºé—´ mActiveTrack-&gt;releaseBuffer(&amp;buffer); &#125; mCurrentWriteLength = curBuf - (int8_t *)mSinkBuffer; mSleepTimeUs = 0; mStandbyTimeNs = systemTime() + mStandbyDelayNs; mActiveTrack.clear();&#125; 3.3. 3. ç¯å½¢ FIFO ç®¡ç†åœ¨ä¸Šè¿°è¿‡ç¨‹ä¸­ï¼Œä¸çŸ¥å¤§å®¶æœ‰æ— æ„è¯†åˆ°ï¼šæ•´ä¸ªè¿‡ç¨‹ä¸­ï¼Œæœ€éš¾çš„æ˜¯å¦‚ä½•åè°ƒç”Ÿäº§è€…ä¸æ¶ˆè´¹è€…ä¹‹é—´çš„æ­¥è°ƒã€‚ä¸Šæ–‡æ‰€è¯´çš„ FIFO æ˜¯ç¯å½¢ FIFOï¼ŒAudioTrack å†™æŒ‡é’ˆã€AudioFlinger è¯»æŒ‡é’ˆéƒ½æ˜¯åŸºäº FIFO å½“å‰çš„è¯»å†™ä½ç½®æ¥è®¡ç®—çš„ã€‚ â˜¯AudioTrack ä¸ AudioFlinger ä¸åœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸Šï¼Œæ€ä¹ˆä¿è¯è¯»å†™æŒ‡é’ˆçš„çº¿ç¨‹å®‰å…¨â˜¯è¯»å†™æŒ‡é’ˆè¶Šè¿‡ FIFO åï¼Œæ€ä¹ˆå¤„ç†â˜¯AudioTrack å†™æ•°æ®å®Œæˆåï¼Œéœ€è¦åŒæ­¥çŠ¶æ€ç»™ AudioFlingerï¼Œè®© AudioFlinger çŸ¥é“å½“å‰æœ‰å¯è¯»æ•°æ®äº†ï¼Œè€Œ AudioFlinger è¯»æ•°æ®å®Œæˆåï¼Œä¹Ÿéœ€è¦åŒæ­¥çŠ¶æ€ç»™ AudioTrackï¼Œè®© AudioTrack çŸ¥é“å½“å‰æœ‰å¯ç”¨ç©ºé—´äº†ï¼›è¿™é‡Œé‡‡å–ä»€ä¹ˆåŒæ­¥æœºåˆ¶æˆ‘ä»¬å›é¡¾ä¸‹åˆ›å»º AudioTrack å¯¹è±¡æ—¶ï¼ŒFIFO åŠå…¶æ§åˆ¶å—çš„ç»“æ„å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314MODE_STREAM æ¨¡å¼ä¸‹çš„åŒ¿åå…±äº«å†…å­˜ç»“æ„ï¼š | | | -------------------&gt; mCblkMemory &lt;--------------------- | | | +--------------------+------------------------------------+ | audio_track_cblk_t | FIFO | +--------------------+------------------------------------+ ^ ^ | |mCblk mBuffermCblk = static_cast&lt;audio_track_cblk_t *&gt;(mCblkMemory-&gt;pointer());new(mCblk) audio_track_cblk_t();mBuffer = (char*)mCblk + sizeof(audio_track_cblk_t); â˜¯MODE_STATIC æ¨¡å¼ä¸‹çš„åŒ¿åå…±äº«å†…å­˜ç»“æ„ï¼š 12345678910 +--------------------+ +-----------------------------------+ | audio_track_cblk_t | | FIFO (sharedBuffer) | +--------------------+ +-----------------------------------+ ^ ^ | |mCblk mBuffermCblk = (audio_track_cblk_t *) new uint8_t[size];new(mCblk) audio_track_cblk_t();mBuffer = sharedBuffer-&gt;pointer() FIFO ç®¡ç†ç›¸å…³çš„ç±»å›¾ï¼š â˜¯AudioTrackClientProxyï¼šMODE_STREAM æ¨¡å¼ä¸‹ï¼Œç”Ÿäº§è€… AudioTrack ä½¿ç”¨å®ƒåœ¨ FIFO ä¸­æ‰¾åˆ°å¯ç”¨ç©ºé—´çš„ä½ç½®â˜¯AudioTrackServerProxyï¼šMODE_STREAM æ¨¡å¼ä¸‹ï¼Œæ¶ˆè´¹è€… AudioFlinger::PlaybackThread ä½¿ç”¨å®ƒåœ¨ FIFO ä¸­æ‰¾åˆ°å¯è¯»æ•°æ®çš„ä½ç½®â˜¯StaticAudioTrackClientProxyï¼šMODE_STATIC æ¨¡å¼ä¸‹ï¼Œç”Ÿäº§è€… AudioTrack ä½¿ç”¨å®ƒåœ¨ FIFO ä¸­æ‰¾åˆ°å¯ç”¨ç©ºé—´çš„ä½ç½®â˜¯StaticAudioTrackServerProxyï¼šMODE_STATIC æ¨¡å¼ä¸‹ï¼Œæ¶ˆè´¹è€… AudioFlinger::PlaybackThread ä½¿ç”¨å®ƒåœ¨ FIFO ä¸­æ‰¾åˆ°å¯è¯»æ•°æ®çš„ä½ç½®â˜¯AudioRecordClientProxyï¼šæ¶ˆè´¹è€… AudioRecord ä½¿ç”¨å®ƒåœ¨ FIFO ä¸­æ‰¾åˆ°å¯è¯»æ•°æ®çš„ä½ç½®â˜¯AudioTrackServerProxyï¼šç”Ÿäº§è€… AudioFlinger::RecordThread ä½¿ç”¨å®ƒåœ¨ FIFO ä¸­æ‰¾åˆ°å¯ç”¨ç©ºé—´çš„ä½ç½®åˆ°è¿™é‡Œï¼Œæˆ‘å†³å®šç»“æŸæœ¬æ–‡äº†ã€‚ç¯å½¢ FIFO ç®¡ç†æ˜¯ Android éŸ³é¢‘ç³»ç»Ÿçš„ç²¾é«“ï¼Œä¸€ä¸ªå°èŠ‚å¹¶ä¸è¶³ä»¥æè¿°å…¶åŸç†åŠå®ç°ç»†èŠ‚ï¼›Android ç¯å½¢ FIFO çš„å®ç°å¯è¯´å¾—ä¸Šç²¾å¦™ç»ä¼¦ï¼Œå…¶ä»–é¡¹ç›®å¦‚æœè¦ç”¨åˆ°ç¯å½¢ FIFOï¼Œä¸å¦¨å¤šå€Ÿé‰´å®ƒã€‚ (å››)ã€æ·±å…¥å‰–æMediaPlayeræ’­æ”¾éŸ³é¢‘æµç¨‹æ—¶åºå›¾ï¼š ï¼ˆäº”ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroidéŸ³é¢‘æ¨¡å—å¯åŠ¨æµç¨‹åˆ†æJhusterçš„ä¸“æ â€‹ AndroidéŸ³é¢‘å¼€å‘é«˜é€šaudio offloadå­¦ä¹  | ThinkingDroidPhoneçš„ä¸“æ  - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„1-CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„2-ASoc - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„3-Pcm - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„4-å£°å¡æ§åˆ¶ - CSDNåšå®¢Linux ALSA éŸ³é¢‘ç³»ç»Ÿï¼šé€»è¾‘è®¾å¤‡ç¯‡ - CSDNåšå®¢Linux ALSA éŸ³é¢‘ç³»ç»Ÿï¼šç‰©ç†é“¾è·¯ç¯‡ - CSDNåšå®¢ä¸“æ ï¼šMultiMediaæ¡†æ¶æ€»ç»“(åŸºäº6.0æºç ) - CSDNåšå®¢Android éŸ³é¢‘ç³»ç»Ÿï¼šä» AudioTrack åˆ° AudioFlinger - CSDNåšå®¢AZURE - CSDNåšå®¢ - ALSA-Android AudioAZURE - CSDNåšå®¢ - ANDROIDéŸ³é¢‘ç³»ç»ŸAudioé©±åŠ¨æ€»ç»“â€“ALSA | Winddoingâ€™s Blogaudio HAL - ç‰§ å¤© - åšå®¢å›­æ—å­¦æ£®çš„Androidä¸“æ  - CSDNåšå®¢æ·±å…¥å‰–æAndroidéŸ³é¢‘ - CSDNåšå®¢Yangwen123æ’­æ”¾æ¡†æ¶ - æ ‡ç­¾ - Tocy - åšå®¢å›­Android-7.0-Nuplayeræ¦‚è¿° - CSDNåšå®¢Android-7.0-Nuplayer-å¯åŠ¨æµç¨‹ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-Nuplayerï¼ˆ1ï¼‰ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-AHandler AMessage ALooper - CSDNåšå®¢Android N Audioæ’­æ”¾ startçœŸé¢ç›®- (å…­ç¯‡) CSDNåšå®¢æ·±å…¥ç†è§£AndroidéŸ³è§†é¢‘åŒæ­¥æœºåˆ¶ï¼ˆäº”ç¯‡ï¼‰NuPlayerçš„avsyncé€»è¾‘ - CSDNåšå®¢wangyfçš„ä¸“æ  - CSDNåšå®¢-MT6737 Android N å¹³å° Audioç³»ç»Ÿå­¦ä¹ Android 7.0 Audio: Mediaplayer - CSDNåšå®¢Android 7.0 Audio-ç›¸å…³ç±»æµ…æ- CSDNåšå®¢Android N Audioæ’­æ”¾å…­ï¼šå¦‚ä½•è¯»å–buffer - CSDNåšå®¢Fuchsia OSä¸­çš„RPCæœºåˆ¶-FIDL - CSDNåšå®¢é«˜é€šAudioä¸­ASOCçš„codecé©±åŠ¨ - yooooooo - åšå®¢å›­","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Audio Systemï¼ˆ2ï¼‰ï¼šLinux ALSAéŸ³é¢‘ç³»ç»Ÿåˆ†æ","slug":"Audio Systemï¼ˆ2ï¼‰ï¼šLinux ALSAéŸ³é¢‘ç³»ç»Ÿåˆ†æ","date":"2018-05-14T16:00:00.000Z","updated":"2018-05-09T15:03:49.790Z","comments":true,"path":"2018/05/15/Audio Systemï¼ˆ2ï¼‰ï¼šLinux ALSAéŸ³é¢‘ç³»ç»Ÿåˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/05/15/Audio Systemï¼ˆ2ï¼‰ï¼šLinux ALSAéŸ³é¢‘ç³»ç»Ÿåˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ ã€ç‰¹åˆ«æ„Ÿè°¢ - é›²å’Œå±±çš„å½¼ç«¯ - éŸ³é¢‘ç³»ç»Ÿåˆ†æã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆKernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆAndroid 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) æºç ï¼ˆä¸»è¦æºç è·¯å¾„ï¼‰ï¼š User space audio code æºç ï¼š â€¢ /hardware/qcom/audio/hal/ â€“ (Audio HAL æºç ) â€¢ /external/tinyalsa/ â€“ (tinymix, tinyplay, tinycap æºç ) â€¢ /vendor/qcom/proprietary/mm-audio/ â€“ (QTI OMX audio encoder and decoders æºç ï¼Œæœªå…¬å¼€) â€¢ /frameworks/av/media/audioserver/ â€“ (Audioserver æºç ) â€¢ /frameworks/av/media/libstagefright/ â€“ (Google Stagefright å¤šåª’ä½“æ¡†æ¶æºç ) â€¢ /frameworks/av/services/audioflinger/ â€“ (Audioflinger ç›¸å…³æºç ) â€¢ /external/bluetooth/bluedroid/ â€“ (A2DP audio HAL ç›¸å…³æºç )/ â€¢ /hardware/libhardware/modules/usbaudio/ â€“ (USB HAL æºç )/ â€¢ /vendor/qcom/proprietary/wfd/mm/source/framework/src/ â€“ (Wi-Fi Display (WFD)ã€ WFDMMSourceAudioSource.cppï¼Œæœªå…¬å¼€) â€¢ /system/core/include/system/ â€“ (audio.h)/ Kernel space audio code æºç ï¼š â€¢ /kernel/sound/soc/msm/ â€“ msm8996.c machine driver æºç  â€¢ /kernel/sound/soc/msm/qdsp6v2 â€“ platform drivers, front end (FE), and back-end (BE) DAI driver, Hexagon DSP drivers for AFE, ADM, and ASM, voice driver ç›¸å…³æºç  â€¢ kernel/sound/soc/soc-.c â€“ All the SoC-.c ALSA SoCs framework æºç  â€¢ kernel/drivers/slimbus/ â€“ SLIMbus driver æºç  â€¢ kernel/arch/arm/mach-msm/ â€“ åŒ…å«æ¯”å¦‚ acpuclock-8996.c, board-8996-gpiomux.c, board-8996.c, and clock-8996.c related to the GPIO, clock, and board-specific information on the MSM8996 ç›¸å…³æºç  â€¢ /kernel/arch/arm/mach-msm/qdsp6v2/ â€“ Contains the drivers for DSP-based encoders and decoders, code for the aDSP loader, APR driver, Ion memory driver, and other utility files â€¢ /kernel/arch/arm/boot/dts â€“ Contains MSM8996-.its and MSM8996-.Dtsi files that contain MSM8996-specific information; audio-related customization is available in files such as MSM8996.dtsi, msm8996-mtp.dtsi, and msm8996-cdp.dtsi â€¢ /kernel/sound/soc/codecs/ â€“ Contains the source code for the codec driver for WCD9335; codec driver-related source files are wcd9335.c, wcd9xxx-mbhc.c, wcd9xxx-resmgr.c, wcd9xxx-common.c, and so on. â€¢ /kernel/drivers/mfd/ â€“ Contains the source code for the codec driver; wcd9xxx-core.c, wcd9xxx-slimslave.c, and wcd9xxx-irq.c are the codec driverrelated files ï¼ˆä¸€ï¼‰ Overviewç¡¬ä»¶å¹³å°åŠè½¯ä»¶ç‰ˆæœ¬ï¼šâ˜ Kernel - 3.18â˜ SoC - Qualcomm snapdragonâ˜ CODEC - WCD9335â˜ Machine - msm8996â˜ Userspace - tinyalsa Linux ALSA éŸ³é¢‘ç³»ç»Ÿæ¶æ„å¤§è‡´å¦‚ä¸‹ï¼š â€¢ Native ALSA Applicationï¼štinyplay/tinycap/tinymixï¼Œè¿™äº›ç”¨æˆ·ç¨‹åºç›´æ¥è°ƒç”¨ alsa ç”¨æˆ·åº“æ¥å£æ¥å®ç°æ”¾éŸ³ã€å½•éŸ³ã€æ§åˆ¶â€¢ ALSA Library APIï¼šalsa ç”¨æˆ·åº“æ¥å£ï¼Œå¸¸è§æœ‰ tinyalsaã€alsa-libâ€¢ ALSA COREï¼šalsa æ ¸å¿ƒå±‚ï¼Œå‘ä¸Šæä¾›é€»è¾‘è®¾å¤‡ï¼ˆPCM/CTL/MIDI/TIMER/â€¦ï¼‰ç³»ç»Ÿè°ƒç”¨ï¼Œå‘ä¸‹é©±åŠ¨ç¡¬ä»¶è®¾å¤‡ï¼ˆMachine/I2S/DMA/CODECï¼‰â€¢ ASoC COREï¼šasoc æ˜¯å»ºç«‹åœ¨æ ‡å‡† alsa core åŸºç¡€ä¸Šï¼Œä¸ºäº†æ›´å¥½æ”¯æŒåµŒå…¥å¼ç³»ç»Ÿå’Œåº”ç”¨äºç§»åŠ¨è®¾å¤‡çš„éŸ³é¢‘ codec çš„ä¸€å¥—è½¯ä»¶ä½“ç³»â€¢ Hardware Driverï¼šéŸ³é¢‘ç¡¬ä»¶è®¾å¤‡é©±åŠ¨ï¼Œç”±ä¸‰å¤§éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯ Machineã€Platformã€Codec Platformï¼šæŒ‡æŸæ¬¾ SoC å¹³å°çš„éŸ³é¢‘æ¨¡å—ï¼Œå¦‚ exynosã€omapã€qcom ç­‰ç­‰ã€‚Platform åˆå¯ç»†åˆ†ä¸¤éƒ¨åˆ†ï¼š â€¢ cpu daiï¼šåœ¨åµŒå…¥å¼ç³»ç»Ÿé‡Œé¢é€šå¸¸æŒ‡ SoC çš„ I2Sã€PCM æ€»çº¿æ§åˆ¶å™¨ï¼Œè´Ÿè´£æŠŠéŸ³é¢‘æ•°æ®ä» I2S tx FIFO æ¬è¿åˆ° CODECï¼ˆè¿™æ˜¯å›æ”¾çš„æƒ…å½¢ï¼Œå½•åˆ¶åˆ™æ–¹å‘ç›¸åï¼‰ã€‚cpu_dai é€šè¿‡ snd_soc_register_dai() æ¥æ³¨å†Œã€‚æ³¨ï¼šDAI æ˜¯ Digital Audio Interface çš„ç®€ç§°ï¼Œåˆ†ä¸º cpu_dai å’Œ codec_daiï¼Œè¿™ä¸¤è€…é€šè¿‡ I2S/PCM æ€»çº¿è¿æ¥ï¼›AIF æ˜¯ Audio Interface çš„ç®€ç§°ï¼ŒåµŒå…¥å¼ç³»ç»Ÿä¸­ä¸€èˆ¬æ˜¯ I2S å’Œ PCM æ¥å£ã€‚ â€¢ pcm dmaï¼šè´Ÿè´£æŠŠ dma buffer ä¸­çš„éŸ³é¢‘æ•°æ®æ¬è¿åˆ° I2S tx FIFOã€‚å€¼å¾—ç•™æ„çš„æ˜¯ï¼šæŸäº›æƒ…å½¢ä¸‹æ˜¯ä¸éœ€è¦ dma æ“ä½œçš„ï¼Œæ¯”å¦‚ Modem å’Œ CODEC ç›´è¿ï¼Œå› ä¸º Modem æœ¬èº«å·²ç»æŠŠæ•°æ®é€åˆ° FIFO äº†ï¼Œè¿™æ—¶åªéœ€å¯åŠ¨ codec_dai æ¥æ”¶æ•°æ®å³å¯ï¼›è¯¥æƒ…å½¢ä¸‹ï¼ŒMachine é©±åŠ¨ dai_link ä¸­éœ€è¦è®¾å®š .platform_name = â€œmsm-pcm-xxxâ€ã€‚ Codecï¼šå¯¹äºå›æ”¾æ¥è¯´ï¼Œuserspace é€è¿‡æ¥çš„éŸ³é¢‘æ•°æ®æ˜¯ç»è¿‡é‡‡æ ·é‡åŒ–çš„æ•°å­—ä¿¡å·ï¼Œåœ¨ codec ç»è¿‡ DAC è½¬æ¢æˆæ¨¡æ‹Ÿä¿¡å·ç„¶åè¾“å‡ºåˆ°å¤–æ”¾æˆ–è€³æœºï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¬åˆ°å£°éŸ³äº†ã€‚Codec å­—é¢æ„æ€æ˜¯ç¼–è§£ç å™¨ï¼Œä½†èŠ¯ç‰‡é‡Œé¢çš„åŠŸèƒ½éƒ¨ä»¶å¾ˆå¤šï¼Œå¸¸è§çš„æœ‰ AIFã€DACã€ADCã€Mixerã€PGAã€Line-inã€Line-outï¼Œæœ‰äº›é«˜ç«¯çš„ codec èŠ¯ç‰‡è¿˜æœ‰ EQã€DSPã€SRCã€DRCã€AGCã€Echo-Cancellerã€Noise-Suppression ç­‰éƒ¨ä»¶ã€‚ Machineï¼šæŒ‡æŸæ¬¾æœºå™¨ï¼Œé€šè¿‡é…ç½® dai_link æŠŠ cpu_daiã€codec_daiã€modem_dai å„ä¸ªéŸ³é¢‘æ¥å£ç»™é“¾ç»“æˆä¸€æ¡æ¡éŸ³é¢‘é“¾è·¯ï¼Œç„¶åæ³¨å†Œ snd_soc_cardã€‚å’Œä¸Šé¢ä¸¤ä¸ªä¸ä¸€æ ·ï¼ŒPlatform å’Œ CODEC é©±åŠ¨ä¸€èˆ¬æ˜¯å¯ä»¥é‡ç”¨çš„ï¼Œè€Œ Machine æœ‰å®ƒç‰¹å®šçš„ç¡¬ä»¶ç‰¹æ€§ï¼Œå‡ ä¹æ˜¯ä¸å¯é‡ç”¨çš„ã€‚æ‰€è°“çš„ç¡¬ä»¶ç‰¹æ€§æŒ‡ï¼šSoC Platform ä¸ Codec çš„å·®å¼‚ï¼›DAIs ä¹‹é—´çš„é“¾ç»“æ–¹å¼ï¼›é€šè¿‡æŸä¸ª GPIO æ‰“å¼€ Amplifierï¼›é€šè¿‡æŸä¸ª GPIO æ£€æµ‹è€³æœºæ’æ‹”ï¼›ä½¿ç”¨æŸä¸ªæ—¶é’Ÿå¦‚ MCLK/External-OSC ä½œä¸º I2Sã€CODEC çš„æ—¶é’Ÿæºç­‰ç­‰ã€‚ ä»ä¸Šé¢çš„æè¿°æ¥çœ‹ï¼Œå¯¹äºå›æ”¾çš„æƒ…å½¢ï¼ŒPCM æ•°æ®æµå‘å¤§è‡´æ˜¯ï¼š 12345 copy_from_user DMA I2S DAC ^ ^ ^ ^+---------+ | +----------+ | +-----------+ | +-----+ | +------+|userspace+--------&gt;DMA Buffer+-------&gt;I2S TX FIFO+-------&gt;CODEC+-------&gt;SPK/HP|+---------+ +----------+ +-----------+ +-----+ +------+ å‡ ä¸ªéŸ³é¢‘ç‰©ç†é“¾è·¯çš„æ¦‚å¿µï¼š dai_linkï¼šmachine é©±åŠ¨ä¸­å®šä¹‰çš„éŸ³é¢‘æ•°æ®é“¾è·¯ï¼Œå®ƒæŒ‡å®šé“¾è·¯ç”¨åˆ°çš„ codecã€codec_daiã€cpu_daiã€platformã€‚æ¯”å¦‚å¯¹äº WCD9335 å¹³å°çš„ media é“¾è·¯ï¼š.codec_dai_name = â€œsnd-soc-dummy-daiâ€, .codec_name = â€œsnd-soc-dummyâ€, .cpu_dai_name = â€œMultiMediaXâ€, .platform_name = â€œmsm-pcm-dsp.0â€ï¼Œè¿™å››è€…å°±æ„æˆäº†ä¸€æ¡éŸ³é¢‘æ•°æ®é“¾è·¯ç”¨äºå¤šåª’ä½“å£°éŸ³çš„å›æ”¾å’Œå½•åˆ¶ã€‚ä¸€ä¸ªç³»ç»Ÿå¯èƒ½æœ‰å¤šä¸ªéŸ³é¢‘æ•°æ®é“¾è·¯ï¼Œæ¯”å¦‚ media å’Œ voiceï¼Œå› æ­¤å¯ä»¥å®šä¹‰å¤šä¸ª dai_link ã€‚ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324[-&gt;/sound/soc/msm/msm8996.c]/* Digital audio interface glue - connects codec &lt;---&gt; CPU */static struct snd_soc_dai_link msm8996_common_dai_links[] = &#123; /* FrontEnd DAI Links */ &#123; .name = \"MSM8996 Media1\", .stream_name = \"MultiMedia1\", .cpu_dai_name = \"MultiMedia1\", .platform_name = \"msm-pcm-dsp.0\", .dynamic = 1, .async_ops = ASYNC_DPCM_SND_SOC_PREPARE, .dpcm_playback = 1, .dpcm_capture = 1, .trigger = &#123;SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST&#125;, .codec_dai_name = \"snd-soc-dummy-dai\", .codec_name = \"snd-soc-dummy\", .ignore_suspend = 1, /* this dainlink has playback support */ .ignore_pmdown_time = 1, .be_id = MSM_FRONTEND_DAI_MULTIMEDIA1 &#125;, ......&#125; é«˜é€šå¹³å°å› DSPè€Œå­˜åœ¨ç‰¹æ®Šæ€§ï¼Œå¦‚ä¸Šå›¾ï¼ŒFrontend é“¾æ¥ â€œPlatformâ€ï¼Œç»ç”± â€œPlatformâ€-&gt;Backendé“¾æ¥åˆ°Codecã€‚Front-end DAIï¼š 1234567891011121314151617181920212223242526272829303132333435[-&gt;/sound/soc/msm/msm-dai-fe.c]static struct snd_soc_dai_driver msm_fe_dais[] = &#123; &#123; .playback = &#123; .stream_name = \"MultiMedia1 Playback\", .aif_name = \"MM_DL1\", .rates = (SNDRV_PCM_RATE_8000_192000| SNDRV_PCM_RATE_KNOT), .formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_3LE), .channels_min = 1, .channels_max = 8, .rate_min = 8000, .rate_max = 192000, &#125;, .capture = &#123; .stream_name = \"MultiMedia1 Capture\", .aif_name = \"MM_UL1\", .rates = (SNDRV_PCM_RATE_8000_192000| SNDRV_PCM_RATE_KNOT), .formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE| SNDRV_PCM_FMTBIT_S24_3LE), .channels_min = 1, .channels_max = 4, .rate_min = 8000, .rate_max = 48000, &#125;, .ops = &amp;msm_fe_Multimedia_dai_ops, .name = \"MultiMedia1\", .probe = fe_dai_probe, &#125;, ......&#125; Back-end DAIï¼š 1234567891011121314151617181920212223242526272829303132333435363738[-&gt;sound/soc/msm/msm8996.c]static struct snd_soc_dai_link msm8996_tasha_be_dai_links[] = &#123; /* Backend DAI Links */ &#123; .name = LPASS_BE_SLIMBUS_0_RX, .stream_name = \"Slimbus Playback\", .cpu_dai_name = \"msm-dai-q6-dev.16384\", .platform_name = \"msm-pcm-routing\", .codec_name = \"tasha_codec\", .codec_dai_name = \"tasha_mix_rx1\", .no_pcm = 1, .dpcm_playback = 1, .be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX, .init = &amp;msm_audrx_init, .be_hw_params_fixup = msm_slim_0_rx_be_hw_params_fixup, /* this dainlink has playback support */ .ignore_pmdown_time = 1, .ignore_suspend = 1, .ops = &amp;msm8996_be_ops, &#125;, ......&#125;static struct snd_soc_dai_link msm8996_tasha_fe_dai_links[] = &#123; &#123; .name = LPASS_BE_SLIMBUS_4_TX, .stream_name = \"Slimbus4 Capture\", .cpu_dai_name = \"msm-dai-q6-dev.16393\", .platform_name = \"msm-pcm-hostless\", .codec_name = \"tasha_codec\", .codec_dai_name = \"tasha_vifeedback\", .be_id = MSM_BACKEND_DAI_SLIMBUS_4_TX, .be_hw_params_fixup = msm_slim_4_tx_be_hw_params_fixup, .ops = &amp;msm8996_be_ops, .no_host_mode = SND_SOC_DAI_LINK_NO_HOST, .ignore_suspend = 1, &#125;, ......&#125; hw constraintsï¼šæŒ‡å¹³å°æœ¬èº«çš„ç¡¬ä»¶é™åˆ¶ï¼Œå¦‚æ‰€èƒ½æ”¯æŒçš„é€šé“æ•°/é‡‡æ ·ç‡/æ•°æ®æ ¼å¼ã€DMA æ”¯æŒçš„æ•°æ®å‘¨æœŸå¤§å°ï¼ˆperiod sizeï¼‰ã€å‘¨æœŸæ¬¡æ•°ï¼ˆperiod countï¼‰ç­‰ï¼Œé€šè¿‡ snd_pcm_hardware ç»“æ„ä½“æè¿°ï¼š1234567891011121314151617181920212223[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]static struct snd_pcm_hardware msm_pcm_hardware_capture = &#123; .info = (SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_BLOCK_TRANSFER | SNDRV_PCM_INFO_MMAP_VALID | SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME), .formats = (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S24_3LE), .rates = SNDRV_PCM_RATE_8000_48000, .rate_min = 8000, .rate_max = 48000, .channels_min = 1, .channels_max = 4, .buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE, .period_bytes_min = CAPTURE_MIN_PERIOD_SIZE, .period_bytes_max = CAPTURE_MAX_PERIOD_SIZE, .periods_min = CAPTURE_MIN_NUM_PERIODS, .periods_max = CAPTURE_MAX_NUM_PERIODS, .fifo_size = 0,&#125;; hw paramsï¼šç”¨æˆ·å±‚è®¾ç½®çš„ç¡¬ä»¶å‚æ•°ï¼Œå¦‚ channelsã€sample rateã€pcm formatã€period sizeã€period countï¼›è¿™äº›å‚æ•°å— hw constraints çº¦æŸã€‚ sw paramsï¼šç”¨æˆ·å±‚è®¾ç½®çš„è½¯ä»¶å‚æ•°ï¼Œå¦‚ start thresholdã€stop thresholdã€silence thresholdã€‚ ï¼ˆäºŒï¼‰ASoC CoreASoCï¼šALSA System on Chipï¼Œæ˜¯å»ºç«‹åœ¨æ ‡å‡† ALSA é©±åŠ¨ä¹‹ä¸Šï¼Œä¸ºäº†æ›´å¥½æ”¯æŒåµŒå…¥å¼ç³»ç»Ÿå’Œåº”ç”¨äºç§»åŠ¨è®¾å¤‡çš„éŸ³é¢‘ codec çš„ä¸€å¥—è½¯ä»¶ä½“ç³»ï¼Œå®ƒä¾èµ–äºæ ‡å‡† ALSA é©±åŠ¨æ¡†æ¶ã€‚å†…æ ¸æ–‡æ¡£ Documentation/alsa/soc/overview.txt ä¸­è¯¦ç»†ä»‹ç»äº† ASoC çš„è®¾è®¡åˆè¡·ï¼Œè¿™é‡Œä¸ä¸€ä¸€å¼•ç”¨ï¼Œç®€å•é™ˆè¿°å¦‚ä¸‹ï¼š â€¢ ç‹¬ç«‹çš„ codec é©±åŠ¨ï¼Œæ ‡å‡†çš„ ALSA é©±åŠ¨æ¡†æ¶é‡Œé¢ codec é©±åŠ¨å¾€å¾€ä¸ SoC/CPU è€¦åˆè¿‡äºç´§å¯†ï¼Œä¸åˆ©äºåœ¨å¤šæ ·åŒ–çš„å¹³å°/æœºå™¨ä¸Šç§»æ¤å¤ç”¨â€¢ æ–¹ä¾¿ codec ä¸ SoC é€šè¿‡ PCM/I2S æ€»çº¿å»ºç«‹é“¾æ¥â€¢ åŠ¨æ€éŸ³é¢‘ç”µæºç®¡ç† DAPMï¼Œä½¿å¾— codec ä»»ä½•æ—¶å€™éƒ½å·¥ä½œåœ¨æœ€ä½åŠŸè€—çŠ¶æ€ï¼ŒåŒæ—¶è´Ÿè´£éŸ³é¢‘è·¯ç”±çš„åˆ›å»ºâ€¢ POPs å’Œ click éŸ³æŠ‘åˆ¶å¼±åŒ–å¤„ç†ï¼Œåœ¨ ASoC ä¸­é€šè¿‡æ­£ç¡®çš„éŸ³é¢‘éƒ¨ä»¶ä¸Šä¸‹ç”µæ¬¡åºæ¥å®ç°â€¢ Machine é©±åŠ¨çš„ç‰¹å®šæ§åˆ¶ï¼Œæ¯”å¦‚è€³æœºã€éº¦å…‹é£çš„æ’æ‹”æ£€æµ‹ï¼Œå¤–æ”¾åŠŸæ”¾çš„å¼€å…³åœ¨æ¦‚è¿°ä¸­å·²ç»ä»‹ç»äº† ASoC ç¡¬ä»¶è®¾å¤‡é©±åŠ¨çš„ä¸‰å¤§æ„æˆï¼šCodecã€Platform å’Œ Machineï¼Œä¸‹é¢åˆ—ä¸¾å„é©±åŠ¨çš„åŠŸèƒ½æ„æˆï¼š ASoC Codec Driverï¼š â€¢ Codec DAI å’Œ PCM çš„é…ç½®ä¿¡æ¯â€¢ Codec çš„æ§åˆ¶æ¥å£ï¼Œå¦‚ I2C/SPIâ€¢ Mixer å’Œå…¶ä»–éŸ³é¢‘æ§ä»¶â€¢ Codec çš„éŸ³é¢‘æ¥å£å‡½æ•°ï¼Œè§ snd_soc_dai_ops ç»“æ„ä½“å®šä¹‰â€¢ DAPM æè¿°ä¿¡æ¯â€¢ DAPM äº‹ä»¶å¤„ç†å¥æŸ„â€¢ DAC æ•°å­—é™éŸ³æ§åˆ¶ ASoC Platform Driverï¼š åŒ…æ‹¬ dma å’Œ cpu_dai ä¸¤éƒ¨åˆ†ï¼š â€¢ dma é©±åŠ¨å®ç°éŸ³é¢‘ dma æ“ä½œï¼Œå…·ä½“è§ snd_pcm_ops ç»“æ„ä½“å®šä¹‰â€¢ cpu_dai é©±åŠ¨å®ç°éŸ³é¢‘æ•°å­—æ¥å£æ§åˆ¶å™¨çš„æè¿°å’Œé…ç½®â€¢ ASoC Machine Driverï¼š ä½œä¸ºé“¾ç»“ Platform å’Œ Codec çš„è½½ä½“ï¼Œå®ƒå¿…é¡»é…ç½® dai_link ä¸ºéŸ³é¢‘æ•°æ®é“¾è·¯æŒ‡å®š Platform å’Œ Codecå¤„ç†æœºå™¨ç‰¹æœ‰çš„éŸ³é¢‘æ§ä»¶å’ŒéŸ³é¢‘äº‹ä»¶ï¼Œä¾‹å¦‚å›æ”¾æ—¶æ‰“å¼€å¤–æ”¾åŠŸæ”¾ç¡¬ä»¶è®¾å¤‡é©±åŠ¨ç›¸å…³ç»“æ„ä½“ï¼š â€¢ snd_soc_codec_driverï¼šéŸ³é¢‘ç¼–è§£ç èŠ¯ç‰‡æè¿°åŠæ“ä½œå‡½æ•°ï¼Œå¦‚æ§ä»¶/å¾®ä»¶/éŸ³é¢‘è·¯ç”±çš„æè¿°ä¿¡æ¯ã€æ—¶é’Ÿé…ç½®ã€IO æ§åˆ¶ç­‰â€¢ snd_soc_dai_driverï¼šéŸ³é¢‘æ•°æ®æ¥å£æè¿°åŠæ“ä½œå‡½æ•°ï¼Œæ ¹æ® codec ç«¯å’Œ soc ç«¯ï¼Œåˆ†ä¸º codec_dai å’Œ cpu_daiâ€¢ snd_soc_platform_driverï¼šéŸ³é¢‘ dma è®¾å¤‡æè¿°åŠæ“ä½œå‡½æ•°â€¢ snd_soc_dai_linkï¼šéŸ³é¢‘é“¾è·¯æè¿°åŠæ¿çº§æ“ä½œå‡½æ•° ï¼ˆä¸‰ï¼‰Codec DriveråŸºæœ¬æ˜¯ä»¥å†…æ ¸æ–‡æ¡£ Documentation/sound/alsa/soc/codec.txt ä¸­çš„å†…å®¹ä¸ºè„‰ç»œæ¥åˆ†æçš„ã€‚Codec çš„ä½œç”¨ï¼Œä¹‹å‰å·²æœ‰æè¿°ï¼Œæœ¬ç« ä¸»è¦ç½—åˆ—ä¸‹ Codec driver ä¸­é‡è¦çš„æ•°æ®ç»“æ„åŠæ³¨å†Œæµç¨‹ã€‚å…¶ä¸­æœ‰ç€å„ç§åŠŸèƒ½éƒ¨ä»¶ï¼ŒåŒ…æ‹¬ä½†ä¸é™äº ï¼š ADC æŠŠéº¦å…‹é£æ‹¾å–çš„æ¨¡æ‹Ÿä¿¡å·è½¬æ¢æˆæ•°å­—ä¿¡å·DAC æŠŠéŸ³é¢‘æ¥å£è¿‡æ¥çš„æ•°å­—ä¿¡å·è½¬æ¢æˆæ¨¡æ‹Ÿä¿¡å·MIXER æ··éŸ³å™¨ï¼ŒæŠŠå¤šè·¯è¾“å…¥ä¿¡å·æ··åˆæˆå•è·¯è¾“å‡º 3.1. Codec DAI and PCM configurationcodec_dai å’Œ pcm é…ç½®ä¿¡æ¯é€šè¿‡ç»“æ„ä½“ snd_soc_dai_driver æè¿°ï¼ŒåŒ…æ‹¬ dai çš„èƒ½åŠ›æè¿°å’Œæ“ä½œæ¥å£ï¼Œsnd_soc_dai_driver æœ€ç»ˆä¼šè¢«æ³¨å†Œåˆ° soc-core ä¸­ã€‚ 12345678910111213141516171819202122232425262728293031323334[-&gt;include/sound/soc-dai.h]/* * Digital Audio Interface Driver. * * Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97 * operations and capabilities. Codec and platform drivers will register this * structure for every DAI they have. * This structure covers the clocking, formating and ALSA operations for each * interface. */struct snd_soc_dai_driver &#123; /* DAI description */ const char *name; unsigned int id; int ac97_control; /* DAI driver callbacks */ int (*probe)(struct snd_soc_dai *dai); int (*remove)(struct snd_soc_dai *dai); int (*suspend)(struct snd_soc_dai *dai); int (*resume)(struct snd_soc_dai *dai); /* ops */ const struct snd_soc_dai_ops *ops; /* DAI capabilities */ struct snd_soc_pcm_stream capture; struct snd_soc_pcm_stream playback; unsigned int symmetric_rates:1; /* probe ordering - for components with runtime dependencies */ int probe_order; int remove_order;&#125;; nameï¼šcodec_dai çš„åç§°æ ‡è¯†ï¼Œdai_link é€šè¿‡é…ç½® codec_dai_name æ¥æ‰¾åˆ°å¯¹åº”çš„ codec_daiï¼›probeï¼šcodec_dai çš„åˆå§‹åŒ–å‡½æ•°ï¼Œæ³¨å†Œå£°å¡æ—¶å›è°ƒï¼›playbackï¼šå›æ”¾èƒ½åŠ›æè¿°ï¼Œå¦‚å›æ”¾è®¾å¤‡æ‰€æ”¯æŒçš„å£°é“æ•°ã€é‡‡æ ·ç‡ã€éŸ³é¢‘æ ¼å¼ï¼›captureï¼šå½•åˆ¶èƒ½åŠ›æè¿°ï¼Œå¦‚å½•åˆ¶è®¾å¤‡æ‰€æ”¯æŒå£°é“æ•°ã€é‡‡æ ·ç‡ã€éŸ³é¢‘æ ¼å¼ï¼›opsï¼šcodec_dai çš„æ“ä½œå‡½æ•°é›†ï¼Œè¿™äº›å‡½æ•°é›†éå¸¸é‡è¦ï¼Œç”¨äº dai çš„æ—¶é’Ÿé…ç½®ã€æ ¼å¼é…ç½®ã€ç¡¬ä»¶å‚æ•°é…ç½®ã€‚ codec_daiï¼š1234567891011121314151617181920212223242526272829303132[-&gt;sound/soc/codecs/wcd9335.c]static struct snd_soc_dai_driver tasha_i2s_dai[] = &#123; &#123; .name = \"tasha_i2s_rx1\", .id = AIF1_PB, .playback = &#123; .stream_name = \"AIF1 Playback\", .rates = WCD9335_RATES_MASK, .formats = TASHA_FORMATS_S16_S24_LE, .rate_max = 192000, .rate_min = 8000, .channels_min = 1, .channels_max = 2, &#125;, .ops = &amp;tasha_dai_ops, &#125;, &#123; .name = \"tasha_i2s_tx1\", .id = AIF1_CAP, .capture = &#123; .stream_name = \"AIF1 Capture\", .rates = WCD9335_RATES_MASK, .formats = TASHA_FORMATS, .rate_max = 192000, .rate_min = 8000, .channels_min = 1, .channels_max = 4, &#125;, .ops = &amp;tasha_dai_ops, &#125;, ......&#125; 3.2. Codec control IOç§»åŠ¨è®¾å¤‡çš„éŸ³é¢‘ Codecï¼Œå…¶æ§åˆ¶æ¥å£ä¸€èˆ¬æ˜¯ I2C æˆ– SPIï¼Œæ§åˆ¶æ¥å£ç”¨äºè¯»å†™ codec çš„å¯„å­˜å™¨ã€‚åœ¨ snd_soc_codec_driver ç»“æ„ä½“ä¸­ï¼Œæœ‰å¦‚ä¸‹å­—æ®µæè¿° Codec çš„æ§åˆ¶æ¥å£ï¼š 12345678910111213141516171819202122[-&gt;include/sound/soc.h]/* codec driver */struct snd_soc_codec_driver &#123; ...... /* codec IO */ struct regmap *(*get_regmap)(struct device *); unsigned int (*read)(struct snd_soc_codec *, unsigned int); int (*write)(struct snd_soc_codec *, unsigned int, unsigned int); int (*display_register)(struct snd_soc_codec *, char *, size_t, unsigned int); int (*volatile_register)(struct snd_soc_codec *, unsigned int); int (*readable_register)(struct snd_soc_codec *, unsigned int); int (*writable_register)(struct snd_soc_codec *, unsigned int); unsigned int reg_cache_size; short reg_cache_step; short reg_word_size; const void *reg_cache_default; ......&#125;; â€¢ readï¼šè¯»å¯„å­˜å™¨ï¼›â€¢ writeï¼šå†™å¯„å­˜å™¨ï¼›â€¢ volatile_registerï¼šåˆ¤æ–­æŒ‡å®šçš„å¯„å­˜å™¨æ˜¯å¦æ˜¯ volatile å±æ€§ï¼›å‡å¦‚æ˜¯ï¼Œåˆ™è¯»å–å¯„å­˜å™¨æ—¶ä¸æ˜¯è¯» cacheï¼Œè€Œç›´æ¥è®¿é—®ç¡¬ä»¶ï¼›â€¢ readable_registerï¼šåˆ¤æ–­æŒ‡å®šçš„å¯„å­˜å™¨æ˜¯å¦å¯è¯»ï¼›â€¢ reg_cache_defaultï¼šå¯„å­˜å™¨çš„ç¼ºçœå€¼ï¼›â€¢ reg_cache_sizeï¼šç¼ºçœçš„å¯„å­˜å™¨å€¼æ•°ç»„å¤§å°ï¼›â€¢ reg_word_sizeï¼šå¯„å­˜å™¨å®½åº¦ã€‚åœ¨ Linux-3.4.5 ä¸­ï¼Œå¾ˆå¤š codec çš„æ§åˆ¶æ¥å£éƒ½æ”¹ç”¨ regmap äº†ã€‚soc-core ä¸­åˆ¤æ–­æ˜¯å¦ç”¨çš„æ˜¯ regmapï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è°ƒç”¨ regmap æ¥å£ã€‚ 3.3. Mixers and audio controlséŸ³é¢‘æ§ä»¶å¤šç”¨äºéƒ¨ä»¶å¼€å…³å’ŒéŸ³é‡çš„è®¾å®šï¼ŒéŸ³é¢‘æ§ä»¶å¯é€šè¿‡ soc.h ä¸­çš„å®æ¥å®šä¹‰ï¼Œä¾‹å¦‚å•ä¸€å‹æ§ä»¶ï¼š 123456[-&gt;include/sound/soc.h]#define SOC_SINGLE(xname, reg, shift, max, invert) \\&#123; .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\ .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\ .put = snd_soc_put_volsw, \\ .private_value = SOC_SINGLE_VALUE(reg, shift, max, invert) &#125; è¿™ç§æ§ä»¶åªæœ‰ä¸€ä¸ªè®¾ç½®é‡ï¼Œä¸€èˆ¬ç”¨äºéƒ¨ä»¶å¼€å…³ã€‚å®å®šä¹‰çš„å‚æ•°è¯´æ˜ï¼š â€¢ xnameï¼šæ§ä»¶çš„åç§°æ ‡è¯†ï¼›â€¢ regï¼šæ§ä»¶å¯¹åº”çš„å¯„å­˜å™¨åœ°å€ï¼›â€¢ shiftï¼šæ§ä»¶æ§åˆ¶ä½åœ¨å¯„å­˜å™¨ä¸­çš„åç§»ï¼›â€¢ maxï¼šæ§ä»¶è®¾ç½®å€¼èŒƒå›´ï¼›â€¢ invertï¼šè®¾å®šå€¼æ˜¯å¦å–åã€‚å…¶ä»–ç±»å‹æ§ä»¶ç±»ä¼¼ï¼Œä¸ä¸€ä¸€ä»‹ç»äº†ã€‚ ä¸Šè¿°åªæ˜¯å®å®šä¹‰ï¼ŒéŸ³é¢‘æ§ä»¶çœŸæ­£çš„ç»“æ„æ˜¯ snd_kcontrol_newï¼š 123456789101112131415161718[-&gt;/include/sound/control.h]struct snd_kcontrol_new &#123; snd_ctl_elem_iface_t iface; /* interface identifier */ unsigned int device; /* device/client number */ unsigned int subdevice; /* subdevice (substream) number */ const unsigned char *name; /* ASCII name of item */ unsigned int index; /* index of item */ unsigned int access; /* access rights */ unsigned int count; /* count of same elements */ snd_kcontrol_info_t *info; snd_kcontrol_get_t *get; snd_kcontrol_put_t *put; union &#123; snd_kcontrol_tlv_rw_t *c; const unsigned int *p; &#125; tlv; unsigned long private_value;&#125;; Codec åˆå§‹åŒ–æ—¶ï¼Œé€šè¿‡ snd_soc_add_codec_controls() æŠŠæ‰€æœ‰å®šä¹‰å¥½çš„éŸ³é¢‘æ§ä»¶æ³¨å†Œåˆ° alsa-core ï¼Œä¸Šå±‚å¯ä»¥é€šè¿‡ tinymixã€alsa_amixer ç­‰å·¥å…·æŸ¥çœ‹ä¿®æ”¹è¿™äº›æ§ä»¶çš„è®¾å®šã€‚ 3.6. Codec audio operationsCodec éŸ³é¢‘æ“ä½œæ¥å£é€šè¿‡ç»“æ„ä½“ snd_soc_dai_ops æè¿°ï¼š 123456789101112131415161718192021222324252627282930313233[-&gt;include/sound/soc-dai.h]struct snd_soc_dai_ops &#123; /* * DAI clocking configuration, all optional. * Called by soc_card drivers, normally in their hw_params. */ int (*set_sysclk)(struct snd_soc_dai *dai, int clk_id, unsigned int freq, int dir); int (*set_pll)(struct snd_soc_dai *dai, int pll_id, int source, unsigned int freq_in, unsigned int freq_out); int (*set_clkdiv)(struct snd_soc_dai *dai, int div_id, int div); int (*set_bclk_ratio)(struct snd_soc_dai *dai, unsigned int ratio); /* * DAI format configuration * Called by soc_card drivers, normally in their hw_params. */ int (*set_fmt)(struct snd_soc_dai *dai, unsigned int fmt); int (*xlate_tdm_slot_mask)(unsigned int slots, unsigned int *tx_mask, unsigned int *rx_mask); int (*set_tdm_slot)(struct snd_soc_dai *dai, unsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width); int (*set_channel_map)(struct snd_soc_dai *dai, unsigned int tx_num, unsigned int *tx_slot, unsigned int rx_num, unsigned int *rx_slot); int (*set_tristate)(struct snd_soc_dai *dai, int tristate); int (*get_channel_map)(struct snd_soc_dai *dai, unsigned int *tx_num, unsigned int *tx_slot, unsigned int *rx_num, unsigned int *rx_slot); ......&#125;; æ³¨é‡Šæ¯”è¾ƒè¯¦ç»†çš„äº†ï¼ŒCodec éŸ³é¢‘æ“ä½œæ¥å£åˆ†ä¸º 5 å¤§éƒ¨åˆ†ï¼šæ—¶é’Ÿé…ç½®ã€æ ¼å¼é…ç½®ã€æ•°å­—é™éŸ³ã€PCM éŸ³é¢‘æ¥å£ã€FIFO å»¶è¿Ÿã€‚ç€é‡è¯´ä¸‹æ—¶é’Ÿé…ç½®åŠæ ¼å¼é…ç½®æ¥å£ï¼š â€¢ set_sysclkï¼šcodec_dai ç³»ç»Ÿæ—¶é’Ÿè®¾ç½®ï¼Œå½“ä¸Šå±‚æ‰“å¼€ pcm è®¾å¤‡æ—¶ï¼Œéœ€è¦å›è°ƒè¯¥æ¥å£è®¾ç½® Codec çš„ç³»ç»Ÿæ—¶é’Ÿï¼ŒCodec æ‰èƒ½æ­£å¸¸å·¥ä½œï¼›â€¢ set_pllï¼šCodec FLL è®¾ç½®ï¼ŒCodec ä¸€èˆ¬æ¥äº†ä¸€ä¸ª MCLK è¾“å…¥æ—¶é’Ÿï¼Œå›è°ƒè¯¥æ¥å£åŸºäº MCLK æ¥äº§ç”Ÿ Codec FLL æ—¶é’Ÿï¼Œæ¥ç€ codec_dai çš„ sysclkã€bclkã€lrclk å‡å¯ä» FLL åˆ†é¢‘å‡ºæ¥ï¼ˆå‡è®¾ Codec ä½œä¸º masterï¼‰ï¼›â€¢ set_fmtï¼šcodec_dai æ ¼å¼è®¾ç½®ï¼Œå…·ä½“è§ soc-dai.hï¼› â€¢ SND_SOC_DAIFMT_I2Sï¼šéŸ³é¢‘æ•°æ®æ˜¯ I2S æ ¼å¼ï¼Œå¸¸ç”¨äºå¤šåª’ä½“éŸ³é¢‘ï¼› â€¢ SND_SOC_DAIFMT_DSP_Aï¼šéŸ³é¢‘æ•°æ®æ˜¯ PCM æ ¼å¼ï¼Œå¸¸ç”¨äºé€šè¯è¯­éŸ³ï¼› â€¢ SND_SOC_DAIFMT_CBM_CFMï¼šCodec ä½œä¸º masterï¼ŒBCLK å’Œ LRCLK ç”± Codec æä¾›ï¼› â€¢ SND_SOC_DAIFMT_CBS_CFSï¼šCodec ä½œä¸º slaveï¼ŒBCLK å’Œ LRCLK ç”± SoC/CPU æä¾›ï¼›â€¢ hw_paramsï¼šcodec_dai ç¡¬ä»¶å‚æ•°è®¾ç½®ï¼Œæ ¹æ®ä¸Šå±‚è®¾å®šçš„å£°é“æ•°ã€é‡‡æ ·ç‡ã€æ•°æ®æ ¼å¼ï¼Œæ¥é…ç½® codec_dai ç›¸å…³å¯„å­˜å™¨ã€‚ WCD9335çš„snd_soc_dai_ops ï¼š1234567891011[-&gt;/sound/soc/codecs/wcd9335.c]static struct snd_soc_dai_ops tasha_dai_ops = &#123; .startup = tasha_startup, .shutdown = tasha_shutdown, .hw_params = tasha_hw_params, .prepare = tasha_prepare, .set_sysclk = tasha_set_dai_sysclk, .set_fmt = tasha_set_dai_fmt, .set_channel_map = tasha_set_channel_map, .get_channel_map = tasha_get_channel_map,&#125;; 3.6. Codec registerå½“ platform_driverï¼š 123456789101112[-&gt;/sound/soc/codecs/wcd9335.c]static struct platform_driver tasha_codec_driver = &#123; .probe = tasha_probe, .remove = tasha_remove, .driver = &#123; .name = \"tasha_codec\", .owner = THIS_MODULE,#ifdef CONFIG_PM .pm = &amp;tasha_pm_ops,#endif &#125;,&#125;; ä¸.name = â€œtasha_codecâ€ çš„ platform_deviceï¼ˆè¯¥ platform_device åœ¨ drivers/mfd/wcd9xxx-core.c ä¸­æ³¨å†Œwcd9xxx_device_init-&gt;wcd9xxx_check_codec_type-&gt;tasha_devsï¼‰åŒ¹é…åï¼Œ 123456[-&gt;drivers/mfd/wcd9xxx-core.c]static struct mfd_cell tasha_devs[] = &#123; &#123; .name = \"tasha_codec\", &#125;,&#125;; ç«‹å³å›è°ƒ tasha_probe() æ³¨å†Œ Codecï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243[-&gt;/sound/soc/codecs/wcd9335.c]static int tasha_probe(struct platform_device *pdev)&#123; int ret = 0; struct tasha_priv *tasha; struct clk *wcd_ext_clk, *wcd_native_clk; struct wcd9xxx_resmgr_v2 *resmgr; struct wcd9xxx_power_region *cdc_pwr; ...... tasha = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct tasha_priv), GFP_KERNEL); ...... tasha-&gt;resmgr = resmgr; tasha-&gt;swr_plat_data.handle = (void *) tasha; tasha-&gt;swr_plat_data.read = tasha_swrm_read; tasha-&gt;swr_plat_data.write = tasha_swrm_write; tasha-&gt;swr_plat_data.bulk_write = tasha_swrm_bulk_write; tasha-&gt;swr_plat_data.clk = tasha_swrm_clock; tasha-&gt;swr_plat_data.handle_irq = tasha_swrm_handle_irq; /* Register for Clock */ wcd_ext_clk = clk_get(tasha-&gt;wcd9xxx-&gt;dev, \"wcd_clk\"); if (IS_ERR(wcd_ext_clk)) &#123; dev_err(tasha-&gt;wcd9xxx-&gt;dev, \"%s: clk get %s failed\\n\", __func__, \"wcd_ext_clk\"); goto err_clk; &#125; tasha-&gt;wcd_ext_clk = wcd_ext_clk; tasha-&gt;sido_voltage = SIDO_VOLTAGE_NOMINAL_MV; set_bit(AUDIO_NOMINAL, &amp;tasha-&gt;status_mask); tasha-&gt;sido_ccl_cnt = 0; ...... if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS) ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha, tasha_dai, ARRAY_SIZE(tasha_dai)); else if (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C) ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha, tasha_i2s_dai, ARRAY_SIZE(tasha_i2s_dai)); else ret = -EINVAL; ......&#125; snd_soc_register_codecï¼šå°† codec_driver å’Œ codec_dai_driver æ³¨å†Œåˆ° soc-coreã€‚ 12345678910[-&gt;]/** * snd_soc_register_codec - Register a codec with the ASoC core * * @codec: codec to register */int snd_soc_register_codec(struct device *dev, const struct snd_soc_codec_driver *codec_drv, struct snd_soc_dai_driver *dai_drv, int num_dai) åˆ›å»ºä¸€ä¸ª snd_soc_codec å®ä¾‹ï¼ŒåŒ…å« codec_drvï¼ˆsnd_soc_dai_driverï¼‰ç›¸å…³ä¿¡æ¯ï¼Œå°è£…ç»™ soc-core ä½¿ç”¨ï¼Œç›¸å…³ä»£ç æ®µå¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132[sound/soc/soc-core.c: snd_soc_register_codec] struct snd_soc_codec *codec; dev_dbg(dev, \"codec register %s\\n\", dev_name(dev)); codec = kzalloc(sizeof(struct snd_soc_codec), GFP_KERNEL); if (codec == NULL) return -ENOMEM; /* create CODEC component name */ codec-&gt;name = fmt_single_name(dev, &amp;codec-&gt;id); if (codec-&gt;name == NULL) &#123; kfree(codec); return -ENOMEM; &#125; // åˆå§‹åŒ– Codec çš„å¯„å­˜å™¨ç¼“å­˜é…ç½®åŠè¯»å†™æ¥å£ codec-&gt;write = codec_drv-&gt;write; codec-&gt;read = codec_drv-&gt;read; codec-&gt;volatile_register = codec_drv-&gt;volatile_register; codec-&gt;readable_register = codec_drv-&gt;readable_register; codec-&gt;writable_register = codec_drv-&gt;writable_register; codec-&gt;ignore_pmdown_time = codec_drv-&gt;ignore_pmdown_time; codec-&gt;dapm.bias_level = SND_SOC_BIAS_OFF; codec-&gt;dapm.dev = dev; codec-&gt;dapm.codec = codec; codec-&gt;dapm.seq_notifier = codec_drv-&gt;seq_notifier; codec-&gt;dapm.stream_event = codec_drv-&gt;stream_event; codec-&gt;dev = dev; codec-&gt;driver = codec_drv; codec-&gt;num_dai = num_dai; mutex_init(&amp;codec-&gt;mutex); æŠŠä»¥ä¸Š codec å®ä¾‹æ’å…¥åˆ° codec_listé“¾è¡¨ä¸­ï¼ˆå£°å¡æ³¨å†Œæ—¶ä¼šéå†è¯¥é“¾è¡¨ï¼Œæ‰¾åˆ° dai_link å£°æ˜çš„ codec å¹¶ç»‘å®šï¼‰ï¼š 12[sound/soc/soc-core.c: snd_soc_register_codec]list_add(&amp;codec-&gt;list, &amp;codec_list); æŠŠ codec_drv ä¸­çš„ snd_soc_dai_driverï¼ˆtasha_dai æˆ–è€…tasha_i2s_dai ï¼‰æ³¨å†Œåˆ° soc-coreï¼š 12[sound/soc/soc-core.c: snd_soc_register_codec]snd_soc_register_dais(&amp;codec-&gt;component, dai_drv, num_dai, false); snd_soc_register_dais() ä¼šæŠŠ dai æ’å…¥åˆ° dai_list é“¾è¡¨ä¸­ï¼ˆå£°å¡æ³¨å†Œæ—¶ä¼šéå†è¯¥é“¾è¡¨ï¼Œæ‰¾åˆ° dai_link å£°æ˜çš„ codec_dai å¹¶ç»‘å®šï¼‰ï¼š 12[sound/soc/soc-core.c: snd_soc_register_codec]list_add(&amp;dai-&gt;list, &amp;dai_list); æœ€åé¡ºä¾¿æä¸‹ codec å’Œ codec_dai çš„åŒºåˆ«ï¼šcodec æŒ‡éŸ³é¢‘èŠ¯ç‰‡å…±æœ‰çš„éƒ¨åˆ†ï¼ŒåŒ…æ‹¬ codec åˆå§‹åŒ–å‡½æ•°ã€æ§åˆ¶æ¥å£ã€å¯„å­˜å™¨ç¼“å­˜ã€æ§ä»¶ã€dapm éƒ¨ä»¶ã€éŸ³é¢‘è·¯ç”±ã€åç½®ç”µå‹è®¾ç½®å‡½æ•°ç­‰æè¿°ä¿¡æ¯ï¼›è€Œ codec_dai æŒ‡ codec ä¸Šçš„éŸ³é¢‘æ¥å£é©±åŠ¨æè¿°ï¼ŒåŒ…æ‹¬æ—¶é’Ÿé…ç½®ã€æ ¼å¼é…ç½®ã€èƒ½åŠ›æè¿°ç­‰ç­‰ï¼Œå„ä¸ªæ¥å£çš„æè¿°ä¿¡æ¯ä¸ä¸€å®šéƒ½æ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥æ¯ä¸ªéŸ³é¢‘æ¥å£éƒ½æœ‰ç€å„è‡ªçš„é©±åŠ¨æè¿°ã€‚ ï¼ˆå››ï¼‰Platform Driveræ¦‚è¿°ä¸­æåˆ°éŸ³é¢‘ Platform é©±åŠ¨ä¸»è¦ç”¨äºéŸ³é¢‘æ•°æ®ä¼ è¾“ï¼Œè¿™é‡Œåˆç»†åˆ†ä¸ºä¸¤æ­¥ï¼š å¯åŠ¨ dma è®¾å¤‡ï¼ŒæŠŠéŸ³é¢‘æ•°æ®ä» dma buffer æ¬è¿åˆ° cpu_dai FIFOï¼Œè¿™éƒ¨åˆ†é©±åŠ¨ç”¨ snd_soc_platform_driver æè¿°ï¼Œåé¢åˆ†æç”¨ pcm_dma æŒ‡ä»£å®ƒã€‚å¯åŠ¨æ•°å­—éŸ³é¢‘æ¥å£æ§åˆ¶å™¨ï¼ˆI2S/PCM/AC97ï¼‰ï¼ŒæŠŠéŸ³é¢‘æ•°æ®ä» cpu_dai FIFO ä¼ é€åˆ° codec_daiï¼ˆé«˜é€šå¹³å°ä¼šå°†æ•°æ®ä¼ é€åˆ°ADSPï¼‰è¿™éƒ¨åˆ†é©±åŠ¨ç”¨ snd_soc_dai_driver æè¿°ï¼Œåé¢åˆ†æç”¨ cpu_dai æŒ‡ä»£å®ƒã€‚ MSM8996 åŒ…å«ä¸‰ä¸ª Hexagon DSP ï¼šapplication, modem, and sensorã€‚Application DSPï¼šä¸ä»…å¯ä»¥å¤„ç†è¯­éŸ³å’ŒéŸ³é¢‘ï¼Œè¿˜å¯ä»¥å¤„ç†è®¡ç®—æœº è§†è§‰ã€è§†é¢‘ã€å›¾åƒå’ŒCameraã€‚ Sensor DSPï¼šä¹Ÿå«åšSLPIï¼Œæ‰€æœ‰çš„sensoréƒ½é“¾æ¥åˆ°SLPIä¸Šé¢ï¼Œå®ƒç®¡ç†æ‰€æœ‰çš„SensoråŠç›¸å…³ç®—æ³•ã€‚ å¯¹äº cpu_dai é©±åŠ¨ï¼Œä»ä¸Šé¢çš„ç±»å›¾æˆ‘ä»¬å¯çŸ¥ï¼Œä¸»è¦å·¥ä½œæœ‰ï¼š å®ç° dai æ“ä½œå‡½æ•°ï¼Œè§ snd_soc_dai_ops å®šä¹‰ï¼Œç”¨äºé…ç½®å’Œæ“ä½œéŸ³é¢‘æ•°å­—æ¥å£æ§åˆ¶å™¨ï¼Œå¦‚æ—¶é’Ÿé…ç½® set_sysclk()ã€æ ¼å¼é…ç½® set_fmt()ã€ç¡¬ä»¶å‚æ•°é…ç½® hw_params()ã€å¯åŠ¨/åœæ­¢æ•°æ®ä¼ è¾“ trigger() ç­‰ï¼›å®ç° probe å‡½æ•°ï¼ˆåˆå§‹åŒ–ï¼‰ã€remove å‡½æ•°ï¼ˆå¸è½½ï¼‰ã€suspend/resume å‡½æ•°ï¼ˆç”µæºç®¡ç†ï¼‰ï¼›åˆå§‹åŒ– snd_soc_dai_driver å®ä¾‹ï¼ŒåŒ…æ‹¬å›æ”¾å’Œå½•åˆ¶çš„èƒ½åŠ›æè¿°ã€dai æ“ä½œå‡½æ•°é›†ã€probe/remove å›è°ƒã€ç”µæºç®¡ç†ç›¸å…³çš„ suspend/resume å›è°ƒï¼›é€šè¿‡ snd_soc_register_dai() æŠŠåˆå§‹åŒ–å®Œæˆçš„ snd_soc_dai_driver æ³¨å†Œåˆ° soc-coreï¼šé¦–å…ˆåˆ›å»ºä¸€ä¸ª snd_soc_dai å®ä¾‹ï¼Œç„¶åæŠŠè¯¥ snd_soc_dai å®ä¾‹æ’å…¥åˆ° dai_list é“¾è¡¨ï¼ˆå£°å¡æ³¨å†Œæ—¶ä¼šéå†è¯¥é“¾è¡¨ï¼Œæ‰¾åˆ° dai_link å£°æ˜çš„ cpu_dai å¹¶ç»‘å®šï¼‰ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142[sound/soc/soc-core.c]static int snd_soc_register_dais(struct snd_soc_component *component, struct snd_soc_dai_driver *dai_drv, size_t count, bool legacy_dai_naming)&#123; struct device *dev = component-&gt;dev; struct snd_soc_dai *dai; unsigned int i; int ret; dev_dbg(dev, \"ASoC: dai register %s #%Zu\\n\", dev_name(dev), count); component-&gt;dai_drv = dai_drv; component-&gt;num_dai = count; for (i = 0; i &lt; count; i++) &#123; dai = kzalloc(sizeof(struct snd_soc_dai), GFP_KERNEL); ...... if (count == 1 &amp;&amp; legacy_dai_naming) &#123; dai-&gt;name = fmt_single_name(dev, &amp;dai-&gt;id); &#125; else &#123; dai-&gt;name = fmt_multiple_name(dev, &amp;dai_drv[i]); if (dai_drv[i].id) dai-&gt;id = dai_drv[i].id; else dai-&gt;id = i; &#125; ...... dai-&gt;component = component; dai-&gt;dev = dev; dai-&gt;driver = &amp;dai_drv[i]; if (!dai-&gt;driver-&gt;ops) dai-&gt;driver-&gt;ops = &amp;null_dai_ops; list_add(&amp;dai-&gt;list, &amp;component-&gt;dai_list); &#125; return 0; return ret;&#125; dai æ“ä½œå‡½æ•°çš„å®ç°æ˜¯ cpu_dai é©±åŠ¨çš„ä¸»ä½“ï¼Œéœ€è¦é…ç½®å¥½ç›¸å…³å¯„å­˜å™¨è®© I2S/PCM æ€»çº¿æ§åˆ¶å™¨æ­£å¸¸è¿è½¬ï¼Œsnd_soc_dai_ops å­—æ®µçš„è¯¦ç»†è¯´æ˜è§ 3.6. Codec audio operations ç« èŠ‚ã€‚ cpu_dai é©±åŠ¨åº”è¯¥ç®—æ˜¯è¿™ä¸ªç³»åˆ—ä¸­æœ€ç®€å•çš„ä¸€ç¯ï¼Œå› æ­¤ä¸å¤šèŠ±è´¹ç¬”å¢¨åœ¨è¿™é‡Œäº†ã€‚å€’æ˜¯æŸäº›å¹³å°ä¸Šï¼Œdma è®¾å¤‡ä¿¡æ¯ï¼ˆæ€»çº¿åœ°å€ã€é€šé“å·ã€ä¼ è¾“å•å…ƒå¤§å°ï¼‰æ˜¯åœ¨è¿™é‡Œåˆå§‹åŒ–çš„ï¼Œè¿™ç‚¹è¦ç•™æ„ï¼Œè¿™äº› dma è®¾å¤‡ä¿¡æ¯åœ¨ pcm_dma é©±åŠ¨ä¸­ç”¨åˆ°ã€‚ 4.1. pcm operationsæ“ä½œå‡½æ•°çš„å®ç°æ˜¯æœ¬æ¨¡å—çš„ä¸»ä½“ï¼Œè§ snd_pcm_ops ç»“æ„ä½“æè¿°ï¼š 12345678910111213141516171819202122232425262728[-&gt;include/sound/pcm.h]struct snd_pcm_ops &#123; int (*open)(struct snd_pcm_substream *substream); int (*close)(struct snd_pcm_substream *substream); int (*ioctl)(struct snd_pcm_substream * substream, unsigned int cmd, void *arg); int (*compat_ioctl)(struct snd_pcm_substream *substream, unsigned int cmd, void *arg); int (*hw_params)(struct snd_pcm_substream *substream, struct snd_pcm_hw_params *params); int (*hw_free)(struct snd_pcm_substream *substream); int (*prepare)(struct snd_pcm_substream *substream); int (*trigger)(struct snd_pcm_substream *substream, int cmd); snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *substream); int (*delay_blk)(struct snd_pcm_substream *substream); int (*wall_clock)(struct snd_pcm_substream *substream, struct timespec *audio_ts); int (*copy)(struct snd_pcm_substream *substream, int channel, snd_pcm_uframes_t pos, void __user *buf, snd_pcm_uframes_t count); int (*silence)(struct snd_pcm_substream *substream, int channel, snd_pcm_uframes_t pos, snd_pcm_uframes_t count); struct page *(*page)(struct snd_pcm_substream *substream, unsigned long offset); int (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma); int (*ack)(struct snd_pcm_substream *substream); int (*restart)(struct snd_pcm_substream *substream);&#125;; 4.1. platform_driver æ³¨å†Œå½“ platform_driverï¼š 12345678910[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]static struct platform_driver msm_pcm_driver = &#123; .driver = &#123; .name = \"msm-pcm-dsp\", .owner = THIS_MODULE, .of_match_table = msm_pcm_dt_match, &#125;, .probe = msm_pcm_probe, .remove = msm_pcm_remove,&#125;; ä¸ .name = â€œmsm-pcm-dspâ€ çš„ platform_device æ³¨å†Œ åŒ¹é…åï¼Œç³»ç»Ÿä¼šå›è°ƒ msm_pcm_probe() æ³¨å†Œ platformï¼š1234567891011121314151617181920212223242526272829303132333435[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]static int msm_pcm_probe(struct platform_device *pdev)&#123; int rc; int id; struct msm_plat_data *pdata; const char *latency_level; rc = of_property_read_u32(pdev-&gt;dev.of_node, \"qcom,msm-pcm-dsp-id\", &amp;id); ...... pdata = kzalloc(sizeof(struct msm_plat_data), GFP_KERNEL); ...... if (of_property_read_bool(pdev-&gt;dev.of_node, \"qcom,msm-pcm-low-latency\")) &#123; pdata-&gt;perf_mode = LOW_LATENCY_PCM_MODE; rc = of_property_read_string(pdev-&gt;dev.of_node, \"qcom,latency-level\", &amp;latency_level); if (!rc) &#123; if (!strcmp(latency_level, \"ultra\")) pdata-&gt;perf_mode = ULTRA_LOW_LATENCY_PCM_MODE; else if (!strcmp(latency_level, \"ull-pp\")) pdata-&gt;perf_mode = ULL_POST_PROCESSING_PCM_MODE; &#125; &#125; else pdata-&gt;perf_mode = LEGACY_PCM_MODE; dev_set_drvdata(&amp;pdev-&gt;dev, pdata); return snd_soc_register_platform(&amp;pdev-&gt;dev, &amp;msm_soc_platform);&#125; snd_soc_register_platformï¼šå°† platform_drv æ³¨å†Œåˆ° soc-coreã€‚åˆ›å»ºä¸€ä¸ª snd_soc_platform å®ä¾‹ï¼ŒåŒ…å« platform_drvï¼ˆsnd_soc_platform_driverï¼‰çš„ç›¸å…³ä¿¡æ¯ï¼Œå°è£…ç»™ soc-core ä½¿ç”¨ï¼›æŠŠä»¥ä¸Šåˆ›å»ºçš„ platform å®ä¾‹æ’å…¥åˆ° platform_list é“¾è¡¨ä¸Šï¼ˆå£°å¡æ³¨å†Œæ—¶ä¼šéå†è¯¥é“¾è¡¨ï¼Œæ‰¾åˆ° dai_link å£°æ˜çš„ platform å¹¶ç»‘å®šï¼‰ã€‚ä»£ç å®ç°ï¼š 123456789101112int snd_soc_register_platform(struct device *dev, const struct snd_soc_platform_driver *platform_drv)&#123; struct snd_soc_platform *platform; int ret; platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL); ret = snd_soc_add_platform(dev, platform, platform_drv); return ret;&#125; è‡³æ­¤ï¼Œå®Œæˆäº† Platform é©±åŠ¨çš„å®ç°ã€‚å›æ”¾æƒ…å½¢ä¸‹ï¼Œpcm_dma è®¾å¤‡è´Ÿè´£æŠŠ dma buffer ä¸­çš„æ•°æ®æ¬è¿åˆ° I2S tx FIFOï¼ŒI2S æ€»çº¿æ§åˆ¶å™¨è´Ÿè´£æŠŠ I2S tx FIFO ä¸­çš„æ•°æ®ä¼ é€DSPï¼ŒDSPç»å¤„ç†åä¼ é€åˆ°åˆ° Codecã€‚ ï¼ˆäº”ï¼‰ Machine Driverç« èŠ‚ 3. Codec å’Œ 4. Platform ä»‹ç»äº† Codecã€Platform é©±åŠ¨ï¼Œä½†ä»…æœ‰ Codecã€Platform é©±åŠ¨æ˜¯ä¸èƒ½å·¥ä½œçš„ï¼Œéœ€è¦ä¸€ä¸ªè§’è‰²æŠŠ codecã€codec_daiã€cpu_daiã€platform ç»™é“¾ç»“èµ·æ¥æ‰èƒ½æ„æˆä¸€ä¸ªå®Œæ•´çš„éŸ³é¢‘é“¾è·¯ï¼Œè¿™ä¸ªè§’è‰²å°±ç”± machine_drv æ‰¿æ‹…äº†ã€‚ snd_soc_dai_link ç»“æ„ä½“ï¼š 12345678910111213141516171819202122232425262728293031323334353637[-&gt;/include/sound/soc.h]struct snd_soc_dai_link &#123; const char *name; /* Codec name */ const char *stream_name; /* Stream name */ const char *cpu_name; struct device_node *cpu_of_node; const char *cpu_dai_name; const char *codec_name; struct device_node *codec_of_node; const char *codec_dai_name; struct snd_soc_dai_link_component *codecs; unsigned int num_codecs; const char *platform_name; struct device_node *platform_of_node; int be_id; /* optional ID for machine driver BE identification */ const struct snd_soc_pcm_stream *params; unsigned int dai_fmt; /* format to set on init */ enum snd_soc_dpcm_trigger trigger[2]; /* trigger type for DPCM */ unsigned int ignore_suspend:1; unsigned int symmetric_rates:1; unsigned int symmetric_channels:1; unsigned int symmetric_samplebits:1; unsigned int no_pcm:1; unsigned int dynamic:1; unsigned int no_host_mode:2; unsigned int dpcm_capture:1; unsigned int dpcm_playback:1; unsigned int ignore_pmdown_time:1; int (*init)(struct snd_soc_pcm_runtime *rtd); int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd, struct snd_pcm_hw_params *params); const struct snd_soc_ops *ops; const struct snd_soc_compr_ops *compr_ops; bool playback_only; bool capture_only; enum snd_soc_async_ops async_ops;&#125; é‡ç‚¹ä»‹ç»å¦‚ä¸‹å‡ ä¸ªå­—æ®µï¼š â€¢ codec_nameï¼šéŸ³é¢‘é“¾è·¯éœ€è¦ç»‘å®šçš„ codec åç§°ï¼Œå£°å¡æ³¨å†Œæ—¶ä¼šéå† codec_listï¼Œæ‰¾åˆ°åŒåçš„ codec å¹¶ç»‘å®šï¼›â€¢ platform_nameï¼šéŸ³é¢‘é“¾è·¯éœ€è¦ç»‘å®šçš„ platform åç§°ï¼Œå£°å¡æ³¨å†Œæ—¶ä¼šéå† platform_listï¼Œæ‰¾åˆ°åŒåçš„ platform å¹¶ç»‘å®šï¼›â€¢ cpu_dai_nameï¼šéŸ³é¢‘é“¾è·¯éœ€è¦ç»‘å®šçš„ cpu_dai åç§°ï¼Œå£°å¡æ³¨å†Œæ—¶ä¼šéå† dai_listï¼Œæ‰¾åˆ°åŒåçš„ dai å¹¶ç»‘å®šï¼›â€¢ codec_dai_nameï¼šéŸ³é¢‘é“¾è·¯éœ€è¦ç»‘å®šçš„ codec_dai åç§°ï¼Œå£°å¡æ³¨å†Œæ—¶ä¼šéå† dai_listï¼Œæ‰¾åˆ°åŒåçš„ dai å¹¶ç»‘å®šï¼›opsï¼šé‡ç‚¹ç•™æ„ hw_params() å›è°ƒï¼Œä¸€èˆ¬æ¥è¯´è¿™ä¸ªå›è°ƒæ˜¯è¦å®ç°çš„ï¼Œç”¨äºé…ç½® codecã€codec_daiã€cpu_dai çš„æ•°æ®æ ¼å¼å’Œç³»ç»Ÿæ—¶é’Ÿã€‚åœ¨ 3.6. Codec audio operations å°èŠ‚ä¸­æœ‰æè¿°ã€‚/sound/soc/msm/msm8996.c ä¸­çš„ dai_link å®šä¹‰ï¼Œä¸¤ä¸ªéŸ³é¢‘é“¾è·¯åˆ†åˆ«ç”¨äº Mediaå’Œ Voiceï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;/sound/soc/msm/msm8996.c]/* Digital audio interface glue - connects codec &lt;---&gt; CPU */static struct snd_soc_dai_link msm8996_common_dai_links[] = &#123; /* FrontEnd DAI Links */ &#123; .name = \"MSM8996 Media1\", .stream_name = \"MultiMedia1\", .cpu_dai_name = \"MultiMedia1\", .platform_name = \"msm-pcm-dsp.0\", .dynamic = 1, .async_ops = ASYNC_DPCM_SND_SOC_PREPARE, .dpcm_playback = 1, .dpcm_capture = 1, .trigger = &#123;SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST&#125;, .codec_dai_name = \"snd-soc-dummy-dai\", .codec_name = \"snd-soc-dummy\", .ignore_suspend = 1, /* this dainlink has playback support */ .ignore_pmdown_time = 1, .be_id = MSM_FRONTEND_DAI_MULTIMEDIA1 &#125;, ...... &#123; .name = \"VoiceMMode1\", .stream_name = \"VoiceMMode1\", .cpu_dai_name = \"VoiceMMode1\", .platform_name = \"msm-pcm-voice\", .dynamic = 1, .dpcm_playback = 1, .dpcm_capture = 1, .trigger = &#123;SND_SOC_DPCM_TRIGGER_POST, SND_SOC_DPCM_TRIGGER_POST&#125;, .no_host_mode = SND_SOC_DAI_LINK_NO_HOST, .ignore_suspend = 1, .ignore_pmdown_time = 1, .codec_dai_name = \"snd-soc-dummy-dai\", .codec_name = \"snd-soc-dummy\", .be_id = MSM_FRONTEND_DAI_VOICEMMODE1, &#125;, &#125; é™¤äº† dai_linkï¼Œæœºå™¨ä¸­ä¸€äº›ç‰¹å®šçš„éŸ³é¢‘æ§ä»¶å’ŒéŸ³é¢‘äº‹ä»¶ä¹Ÿå¯ä»¥åœ¨ machine_drv å®šä¹‰ï¼Œå¦‚è€³æœºæ’æ‹”æ£€æµ‹ã€å¤–éƒ¨åŠŸæ”¾æ‰“å¼€å…³é—­ç­‰ã€‚ æˆ‘ä»¬å†åˆ†æ machine_drv åˆå§‹åŒ–è¿‡ç¨‹ï¼š 1234567891011[-&gt;/sound/soc/msm/msm8996.c]static struct platform_driver msm8996_asoc_machine_driver = &#123; .driver = &#123; .name = DRV_NAME, .owner = THIS_MODULE, .pm = &amp;snd_soc_pm_ops, .of_match_table = msm8996_asoc_machine_of_match, &#125;, .probe = msm8996_asoc_machine_probe, .remove = msm8996_asoc_machine_remove,&#125;; 1234567891011121314151617181920212223[-&gt;/sound/soc/msm/msm8996.c]static int msm8996_asoc_machine_probe(struct platform_device *pdev)&#123; struct snd_soc_card *card; struct msm8996_asoc_mach_data *pdata; const char *mbhc_audio_jack_type = NULL; char *mclk_freq_prop_name; const struct of_device_id *match; int ret; ...... pdata = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct msm8996_asoc_mach_data), GFP_KERNEL); card = populate_snd_card_dailinks(&amp;pdev-&gt;dev); ...... match = of_match_node(msm8996_asoc_machine_of_match, pdev-&gt;dev.of_node); ret = msm8996_populate_dai_link_component_of_node(card); ...... ret = snd_soc_register_card(card); &#125; è®¾ç½®dailinksåï¼Œç»§è€Œè°ƒç”¨ snd_soc_register_card() æ³¨å†Œå£°å¡ã€‚ç”±äºè¯¥è¿‡ç¨‹å¾ˆå†—é•¿ï¼Œè¿™é‡Œä¸ä¸€ä¸€è´´ä»£ç åˆ†æäº†ï¼Œä½†æ•´ä¸ªæµç¨‹æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œæµç¨‹å›¾å¦‚ä¸‹ï¼š â€¢ å–å‡º platform_device çš„ç§æœ‰æ•°æ®ï¼Œè¯¥ç§æœ‰æ•°æ®å°±æ˜¯ snd_soc_card ï¼›â€¢ snd_soc_register_card() ä¸ºæ¯ä¸ª dai_link åˆ†é…ä¸€ä¸ª snd_soc_pcm_runtime å®ä¾‹ï¼Œåˆ«å¿˜äº†ä¹‹å‰æè¿‡ snd_soc_pcm_runtime æ˜¯ ASoC çš„æ¡¥æ¢ï¼Œä¿å­˜ç€ codecã€codec_daiã€cpu_daiã€platform ç­‰ç¡¬ä»¶è®¾å¤‡å®ä¾‹ã€‚â€¢ éšåçš„å·¥ä½œéƒ½åœ¨ snd_soc_instantiate_card() è¿›è¡Œï¼šâ€¢ éå† dai_listã€codec_listã€platform_list é“¾è¡¨ï¼Œä¸ºæ¯ä¸ªéŸ³é¢‘é“¾è·¯æ‰¾åˆ°å¯¹åº”çš„ cpu_daiã€codec_daiã€codecã€platformï¼›æ‰¾åˆ°çš„ cpu_daiã€codec_daiã€codecã€platform ä¿å­˜åˆ° snd_soc_pcm_runtime ï¼Œå®ŒæˆéŸ³é¢‘é“¾è·¯çš„è®¾å¤‡ç»‘å®šï¼›â€¢ è°ƒç”¨ snd_card_create() åˆ›å»ºå£°å¡ï¼›â€¢ soc_probe_dai_link() ä¾æ¬¡å›è°ƒ cpu_daiã€codecã€platformã€codec_dai çš„ probe() å‡½æ•°ï¼Œå®Œæˆå„éŸ³é¢‘è®¾å¤‡çš„åˆå§‹åŒ–ï¼Œéšåè°ƒç”¨â€¢ soc_new_pcm() åˆ›å»º pcm é€»è¾‘è®¾å¤‡ï¼ˆå› ä¸ºæ¶‰åŠåˆ°æœ¬ç³»åˆ—çš„é‡ç‚¹å†…å®¹ï¼Œåé¢å…·ä½“åˆ†æè¿™ä¸ªå‡½æ•°ï¼‰ï¼›æœ€åè°ƒç”¨ snd_card_register() æ³¨å†Œå£°å¡ã€‚ [-&gt;sound/soc/soc-core.c] soc_new_pcm æºç åˆ†æï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151[-&gt;/sound/soc/soc-pcm.c]/* create a new pcm */int soc_new_pcm(struct snd_soc_pcm_runtime *rtd, int num)&#123; struct snd_soc_platform *platform = rtd-&gt;platform; struct snd_soc_dai *codec_dai; struct snd_soc_dai *cpu_dai = rtd-&gt;cpu_dai; struct snd_pcm *pcm; char new_name[64]; int ret = 0, playback = 0, capture = 0; int i; if (rtd-&gt;dai_link-&gt;dynamic || rtd-&gt;dai_link-&gt;no_pcm) &#123; playback = rtd-&gt;dai_link-&gt;dpcm_playback; capture = rtd-&gt;dai_link-&gt;dpcm_capture; &#125; else &#123; for (i = 0; i &lt; rtd-&gt;num_codecs; i++) &#123; codec_dai = rtd-&gt;codec_dais[i]; if (codec_dai-&gt;driver-&gt;playback.channels_min) playback = 1; if (codec_dai-&gt;driver-&gt;capture.channels_min) capture = 1; &#125; capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min; playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min; &#125; if (rtd-&gt;dai_link-&gt;playback_only) &#123; playback = 1; capture = 0; &#125; if (rtd-&gt;dai_link-&gt;capture_only) &#123; playback = 0; capture = 1; &#125; /* create the PCM */ if (rtd-&gt;dai_link-&gt;no_pcm) &#123; snprintf(new_name, sizeof(new_name), \"(%s)\", rtd-&gt;dai_link-&gt;stream_name); ret = snd_pcm_new_internal(rtd-&gt;card-&gt;snd_card, new_name, num, playback, capture, &amp;pcm); &#125; else &#123; if (rtd-&gt;dai_link-&gt;dynamic) snprintf(new_name, sizeof(new_name), \"%s (*)\", rtd-&gt;dai_link-&gt;stream_name); else snprintf(new_name, sizeof(new_name), \"%s %s-%d\", rtd-&gt;dai_link-&gt;stream_name, (rtd-&gt;num_codecs &gt; 1) ? \"multicodec\" : rtd-&gt;codec_dai-&gt;name, num); ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback, capture, &amp;pcm); &#125; if (ret &lt; 0) &#123; dev_err(rtd-&gt;card-&gt;dev, \"ASoC: can't create pcm for %s\\n\", rtd-&gt;dai_link-&gt;name); return ret; &#125; dev_dbg(rtd-&gt;card-&gt;dev, \"ASoC: registered pcm #%d %s\\n\",num, new_name); /* DAPM dai link stream work */ INIT_DELAYED_WORK(&amp;rtd-&gt;delayed_work, close_delayed_work); rtd-&gt;pcm = pcm; pcm-&gt;private_data = rtd; if (rtd-&gt;dai_link-&gt;no_pcm) &#123; if (playback) pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;private_data = rtd; if (capture) pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;private_data = rtd; if (platform-&gt;driver-&gt;pcm_new) rtd-&gt;platform-&gt;driver-&gt;pcm_new(rtd); goto out; &#125; /* setup any hostless PCMs - i.e. no host IO is performed */ if (rtd-&gt;dai_link-&gt;no_host_mode) &#123; if (pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream) &#123; pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;hw_no_buffer = 1; snd_soc_set_runtime_hwparams( pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream, &amp;no_host_hardware); &#125; if (pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream) &#123; pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;hw_no_buffer = 1; snd_soc_set_runtime_hwparams( pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream, &amp;no_host_hardware); &#125; &#125; /* ASoC PCM operations */ if (rtd-&gt;dai_link-&gt;dynamic) &#123; rtd-&gt;ops.open = dpcm_fe_dai_open; rtd-&gt;ops.hw_params = dpcm_fe_dai_hw_params; rtd-&gt;ops.prepare = dpcm_fe_dai_prepare; rtd-&gt;ops.trigger = dpcm_fe_dai_trigger; rtd-&gt;ops.hw_free = dpcm_fe_dai_hw_free; rtd-&gt;ops.close = dpcm_fe_dai_close; rtd-&gt;ops.pointer = soc_pcm_pointer; rtd-&gt;ops.delay_blk = soc_pcm_delay_blk; rtd-&gt;ops.ioctl = soc_pcm_ioctl; rtd-&gt;ops.compat_ioctl = soc_pcm_compat_ioctl; &#125; else &#123; rtd-&gt;ops.open = soc_pcm_open; rtd-&gt;ops.hw_params = soc_pcm_hw_params; rtd-&gt;ops.prepare = soc_pcm_prepare; rtd-&gt;ops.trigger = soc_pcm_trigger; rtd-&gt;ops.hw_free = soc_pcm_hw_free; rtd-&gt;ops.close = soc_pcm_close; rtd-&gt;ops.pointer = soc_pcm_pointer; rtd-&gt;ops.delay_blk = soc_pcm_delay_blk; rtd-&gt;ops.ioctl = soc_pcm_ioctl; rtd-&gt;ops.compat_ioctl = soc_pcm_compat_ioctl; &#125; if (platform-&gt;driver-&gt;ops) &#123; rtd-&gt;ops.ack = platform-&gt;driver-&gt;ops-&gt;ack; rtd-&gt;ops.copy = platform-&gt;driver-&gt;ops-&gt;copy; rtd-&gt;ops.silence = platform-&gt;driver-&gt;ops-&gt;silence; rtd-&gt;ops.page = platform-&gt;driver-&gt;ops-&gt;page; rtd-&gt;ops.mmap = platform-&gt;driver-&gt;ops-&gt;mmap; rtd-&gt;ops.restart = platform-&gt;driver-&gt;ops-&gt;restart; &#125; if (playback) snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops); if (capture) snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops); if (platform-&gt;driver-&gt;pcm_new) &#123; ret = platform-&gt;driver-&gt;pcm_new(rtd); if (ret &lt; 0) &#123; dev_err(platform-&gt;dev, \"ASoC: pcm constructor failed: %d\\n\", ret); return ret; &#125; &#125; pcm-&gt;private_free = platform-&gt;driver-&gt;pcm_free; return ret;&#125; å¯è§ soc_new_pcm() æœ€ä¸»è¦çš„å·¥ä½œæ˜¯åˆ›å»º pcm é€»è¾‘è®¾å¤‡ï¼Œåˆ›å»ºå›æ”¾å­æµå’Œå½•åˆ¶å­æµå®ä¾‹ï¼Œå¹¶åˆå§‹åŒ–å›æ”¾å­æµå’Œå½•åˆ¶å­æµçš„ pcm æ“ä½œå‡½æ•°ï¼ˆæ•°æ®æ¬è¿æ—¶ï¼Œéœ€è¦è°ƒç”¨è¿™äº›å‡½æ•°æ¥é©±åŠ¨ codecã€codec_daiã€cpu_daiã€dma è®¾å¤‡å·¥ä½œï¼‰ã€‚ ï¼ˆå…­ï¼‰ã€å£°å¡å’Œ PCM è®¾å¤‡çš„å»ºç«‹è¿‡ç¨‹å‰é¢å‡ ç« åˆ†æäº† Codecã€Platformã€Machine é©±åŠ¨çš„ç»„æˆéƒ¨åˆ†åŠå…¶æ³¨å†Œè¿‡ç¨‹ï¼Œè¿™ä¸‰è€…éƒ½æ˜¯ç‰©ç†è®¾å¤‡ç›¸å…³çš„ï¼Œå¤§å®¶åº”è¯¥å¯¹éŸ³é¢‘ç‰©ç†é“¾è·¯æœ‰äº†ä¸€å®šçš„è®¤çŸ¥ã€‚æ¥ç€åˆ†æéŸ³é¢‘é©±åŠ¨çš„ä¸­é—´å±‚ï¼Œç”±äºè¿™äº›å¹¶ä¸æ˜¯çœŸæ­£çš„ç‰©ç†è®¾å¤‡ï¼Œæ•…æˆ‘ä»¬ç§°ä¹‹ä¸ºé€»è¾‘è®¾å¤‡ã€‚ PCM é€»è¾‘è®¾å¤‡ï¼Œæˆ‘ä»¬åˆä¹ æƒ¯ç§°ä¹‹ä¸º PCM ä¸­é—´å±‚æˆ– pcm nativeï¼Œèµ·ç€æ‰¿ä¸Šå¯ä¸‹çš„ä½œç”¨ï¼šå¾€ä¸Šæ˜¯ä¸ç”¨æˆ·æ€æ¥å£çš„äº¤äº’ï¼Œå®ç°éŸ³é¢‘æ•°æ®åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´çš„æ‹·è´ï¼›å¾€ä¸‹æ˜¯è§¦å‘ codecã€platformã€machine çš„æ“ä½œå‡½æ•°ï¼Œå®ç°éŸ³é¢‘æ•°æ®åœ¨ dma_buffer &lt;-&gt; cpu_dai &lt;-&gt; codec ä¹‹é—´çš„ä¼ è¾“ã€‚åé¢ç« èŠ‚å°†ä¼šè¯¦ç»†åˆ†æè¿™ä¸ªè¿‡ç¨‹ï¼Œè¿™é‡Œè¿˜æ˜¯å…ˆä»å£°å¡çš„æ³¨å†Œè°ˆèµ·ã€‚å£°å¡é©±åŠ¨ä¸­ï¼Œä¸€èˆ¬æŒ‚è½½ç€å¤šä¸ªé€»è¾‘è®¾å¤‡ï¼Œçœ‹çœ‹æˆ‘ä»¬è®¡ç®—æœºçš„å£°å¡é©±åŠ¨æœ‰å‡ ä¸ªé€»è¾‘è®¾å¤‡ï¼š 123456789101112adb shell cat /proc/asound/devices 2: [ 0] : control 3: [ 0- 0]: digital audio playback 4: [ 0- 0]: digital audio capture 5: [ 0- 1]: digital audio playback 6: [ 0- 1]: digital audio capture ...... 27: [ 0-16]: digital audio playback 28: [ 0-16]: digital audio capture 29: [ 0-17]: digital audio playback 30: [ 0-17]: digital audio capture 33: : timer digital audio playback ç”¨äºå›æ”¾çš„ PCM è®¾å¤‡digital audio capture ç”¨äºå½•åˆ¶çš„ PCM è®¾å¤‡control ç”¨äºå£°å¡æ§åˆ¶çš„ CTL è®¾å¤‡ï¼Œå¦‚é€šè·¯æ§åˆ¶ã€éŸ³é‡è°ƒæ•´ç­‰timer å®šæ—¶å™¨è®¾å¤‡æ‰‹æœºç³»ç»Ÿä¸­ï¼Œé€šå¸¸æˆ‘ä»¬æ›´å…³å¿ƒ PCM å’Œ CTL è¿™ä¸¤ç§è®¾å¤‡ã€‚ è®¾å¤‡èŠ‚ç‚¹å¦‚ä¸‹ï¼š 123456789101112131415adb shell ls -l /dev/sndcrw-rw---- 1 system audio 116, 51 1970-06-19 02:07 comprC0D24crw-rw---- 1 system audio 116, 52 1970-06-19 02:07 comprC0D27crw-rw---- 1 system audio 116, 53 1970-06-19 02:07 comprC0D28......crw-rw---- 1 system audio 116, 2 1970-06-19 02:07 controlC0crw-rw---- 1 system audio 116, 59 1970-06-19 02:07 hwC0D1000crw-rw---- 1 system audio 116, 66 1970-06-19 02:07 hwC0D11crw-rw---- 1 system audio 116, 67 1970-06-19 02:07 hwC0D12crw-rw---- 1 system audio 116, 76 1970-06-19 02:07 hwC0D13......crw-rw---- 1 system audio 116, 13 1970-06-19 02:07 pcmC0D6ccrw-rw---- 1 system audio 116, 14 1970-06-19 02:07 pcmC0D7pcrw-rw---- 1 system audio 116, 15 1970-06-19 02:07 pcmC0D8ccrw-rw---- 1 system audio 116, 33 1970-06-19 02:07 timer å¯ä»¥çœ‹åˆ°è¿™äº›è®¾å¤‡èŠ‚ç‚¹çš„ Major=116ï¼ŒMinor åˆ™ä¸ /proc/asound/devices æ‰€åˆ—çš„å¯¹åº”èµ·æ¥ï¼Œéƒ½æ˜¯å­—ç¬¦è®¾å¤‡ã€‚ä¸Šå±‚å¯ä»¥é€šè¿‡ open/close/read/write/ioctl ç­‰ç³»ç»Ÿè°ƒç”¨æ¥æ“ä½œå£°å¡è®¾å¤‡ï¼Œè¿™å’Œå…¶ä»–å­—ç¬¦è®¾å¤‡ç±»ä¼¼ï¼Œä½†ä¸€èˆ¬æƒ…å†µä¸‹æˆ‘ä»¬ä¼šä½¿ç”¨å·²å°è£…å¥½çš„ç”¨æˆ·æ¥å£åº“å¦‚ tinyalsaã€alsa-libã€‚ 6.1. å£°å¡ç»“æ„æ¦‚è¿°å›é¡¾ä¸‹ ASoC æ˜¯å¦‚ä½•æ³¨å†Œå£°å¡çš„ï¼Œè¯¦ç»†è¯·å‚è€ƒç« èŠ‚ 5. ASoC machine driverï¼Œè¿™é‡Œä»…ç®€å•é™ˆè¿°ä¸‹ï¼š â€¢ Machine é©±åŠ¨åˆå§‹åŒ–æ—¶ï¼Œ.name = â€œsoc-audioâ€ çš„ platform_device ä¸ platform_driver åŒ¹é…æˆåŠŸï¼Œè§¦å‘ soc_probe() è°ƒç”¨ï¼›â€¢ ç»§è€Œè°ƒç”¨ snd_soc_register_card()ï¼š ï¹‹â€¢ ä¸ºæ¯ä¸ªéŸ³é¢‘ç‰©ç†é“¾è·¯æ‰¾åˆ°å¯¹åº”çš„ codecã€codec_daiã€cpu_daiã€platform è®¾å¤‡å®ä¾‹ï¼Œå®Œæˆ dai_link çš„ç»‘å®šï¼› ï¹‹ â€¢ è°ƒç”¨ snd_card_create() åˆ›å»ºå£°å¡ï¼› ï¹‹ â€¢ ä¾æ¬¡å›è°ƒ cpu_daiã€codecã€platform çš„ probe() å‡½æ•°ï¼Œå®Œæˆç‰©ç†è®¾å¤‡çš„åˆå§‹åŒ–ï¼›â€¢ éšåè°ƒç”¨ soc_new_pcm()ï¼š ï¹‹ â€¢ è®¾ç½® pcm native ä¸­è¦ä½¿ç”¨çš„ pcm æ“ä½œå‡½æ•°ï¼Œè¿™äº›å‡½æ•°ç”¨äºé©±åŠ¨éŸ³é¢‘ç‰©ç†è®¾å¤‡ï¼ŒåŒ…æ‹¬ machineã€codec_daiã€cpu_daiã€platformï¼› ï¹‹ â€¢ è°ƒç”¨ snd_pcm_new() åˆ›å»º pcm é€»è¾‘è®¾å¤‡ï¼Œå›æ”¾å­æµå’Œå½•åˆ¶å­æµéƒ½åœ¨è¿™é‡Œåˆ›å»ºï¼› ï¹‹ â€¢ å›è°ƒ platform é©±åŠ¨çš„ pcm_new()ï¼Œå®ŒæˆéŸ³é¢‘ dma è®¾å¤‡åˆå§‹åŒ–å’Œ dma buffer å†…å­˜åˆ†é…ï¼›â€¢ æœ€åè°ƒç”¨ snd_card_register() æ³¨å†Œå£°å¡ã€‚å…³äºéŸ³é¢‘ç‰©ç†è®¾å¤‡éƒ¨åˆ†ï¼ˆCodec/Platform/Machineï¼‰ä¸å†ç´¯è¿°ï¼Œä¸‹é¢è¯¦ç»†åˆ†æå£°å¡å’Œ PCM é€»è¾‘è®¾å¤‡çš„æ³¨å†Œè¿‡ç¨‹ã€‚ ä¸Šé¢æåˆ°å£°å¡é©±åŠ¨ä¸ŠæŒ‚ç€å¤šä¸ªé€»è¾‘å­è®¾å¤‡ï¼Œæœ‰ pcm éŸ³é¢‘æ•°æ®æµã€control æ··éŸ³å™¨ã€midi è¿·ç¬›ã€timer å®šæ—¶å™¨ç­‰ã€‚ 123456789 +-----------+ | snd_card | +-----------+ | | | +-----------+ | +------------+ | | |+-----------+ +-----------+ +-----------+ | snd_pcm | |snd_control| | snd_timer | ... +-----------+ +-----------+ +-----------+ è¿™äº›ä¸å£°éŸ³ç›¸å…³çš„é€»è¾‘è®¾å¤‡éƒ½åœ¨ç»“æ„ä½“ snd_card ç®¡ç†ä¹‹ä¸‹ï¼Œå¯ä»¥è¯´ snd_card æ˜¯ alsa ä¸­æœ€é¡¶å±‚çš„ç»“æ„ã€‚æˆ‘ä»¬å†çœ‹çœ‹ alsa å£°å¡é©±åŠ¨çš„å¤§è‡´ç»“æ„å›¾ï¼ˆä¸æ˜¯ä¸¥æ ¼çš„ UML ç±»å›¾ï¼Œæœ‰ç»“æ„ä½“å®šä¹‰ã€æ¨¡å—å…³ç³»ã€å‡½æ•°è°ƒç”¨ï¼Œæ–¹ä¾¿æ ‡ç¤ºç»“æ„æ¨¡å—çš„å±‚æ¬¡åŠå…³ç³»ï¼‰ï¼š snd_cardsï¼šè®°å½•ç€æ‰€æ³¨å†Œçš„å£°å¡å®ä¾‹ï¼Œæ¯ä¸ªå£°å¡å®ä¾‹æœ‰ç€å„è‡ªçš„é€»è¾‘è®¾å¤‡ï¼Œå¦‚ PCM è®¾å¤‡ã€CTL è®¾å¤‡ã€MIDI è®¾å¤‡ç­‰ï¼Œå¹¶ä¸€ä¸€è®°å½•åˆ° snd_card çš„ devices é“¾è¡¨ä¸Šsnd_minorsï¼šè®°å½•ç€æ‰€æœ‰é€»è¾‘è®¾å¤‡çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œå®ƒæ˜¯å£°å¡é€»è¾‘è®¾å¤‡ä¸ç³»ç»Ÿè°ƒç”¨ API ä¹‹é—´çš„æ¡¥æ¢ï¼›æ¯ä¸ª snd_minor åœ¨é€»è¾‘è®¾å¤‡æ³¨å†Œæ—¶è¢«å¡«å……ï¼Œåœ¨é€»è¾‘è®¾å¤‡ä½¿ç”¨æ—¶å°±å¯ä»¥ä»è¯¥ç»“æ„ä½“ä¸­å¾—åˆ°ç›¸åº”çš„ä¿¡æ¯ï¼ˆä¸»è¦æ˜¯ç³»ç»Ÿè°ƒç”¨å‡½æ•°é›† file_operationsï¼‰ 6.2. å£°å¡çš„åˆ›å»ºsnd_card_create()123456789101112131415161718192021[-&gt;sound/core/init.c]/** * snd_card_new - create and initialize a soundcard structure * @parent: the parent device object * @idx: card index (address) [0 ... (SNDRV_CARDS-1)] * @xid: card identification (ASCII string) * @module: top level module for locking * @extra_size: allocate this extra size after the main soundcard structure * @card_ret: the pointer to store the created card instance * * Creates and initializes a soundcard structure. * * The function allocates snd_card instance via kzalloc with the given * space for the driver to use freely. The allocated struct is stored * in the given card_ret pointer. * * Return: Zero if successful or a negative error code. */int snd_card_new(struct device *parent, int idx, const char *xid, struct module *module, int extra_size, struct snd_card **card_ret) æ³¨é‡Šéå¸¸è¯¦ç»†ï¼Œç®€å•è¯´ä¸‹ï¼šidxï¼šå£°å¡çš„ç¼–å·ï¼Œå¦‚ä¸º -1ï¼Œåˆ™ç”±ç³»ç»Ÿè‡ªåŠ¨åˆ†é…xidï¼šå£°å¡æ ‡è¯†ç¬¦ï¼Œå¦‚ä¸º NULLï¼Œåˆ™ä»¥ snd_card çš„ shortname æˆ– longname ä»£æ›¿card_retï¼šè¿”å›æ‰€åˆ›å»ºçš„å£°å¡å®ä¾‹çš„æŒ‡é’ˆå¦‚ä¸‹æ˜¯Google Pixelæ‰‹æœºçš„å£°å¡ä¿¡æ¯ï¼š1234adb shellsailfish:/ $ cat /proc/asound/cards 0 [msm8996tashamar]: msm8996-tasha-m - msm8996-tasha-marlin-snd-card msm8996-tasha-marlin-snd-card 6.3. é€»è¾‘è®¾å¤‡çš„åˆ›å»ºå½“å£°å¡å®ä¾‹å»ºç«‹åï¼Œæ¥ç€å¯ä»¥åˆ›å»ºå£°å¡ä¸‹é¢çš„å„ä¸ªé€»è¾‘è®¾å¤‡äº†ã€‚æ¯ä¸ªé€»è¾‘è®¾å¤‡åˆ›å»ºæ—¶ï¼Œéƒ½ä¼šè°ƒç”¨ snd_device_new() ç”Ÿæˆä¸€ä¸ª snd_device å®ä¾‹ï¼Œå¹¶æŠŠè¯¥å®ä¾‹æŒ‚åˆ°å£°å¡ snd_card çš„ devices é“¾è¡¨ä¸Šã€‚alsa é©±åŠ¨ä¸ºå„ç§é€»è¾‘è®¾å¤‡æä¾›äº†åˆ›å»ºæ¥å£ï¼Œå¦‚ä¸‹ï¼š PCM snd_pcm_new()CONTROL snd_ctl_create()MIDI snd_rawmidi_new()TIMER snd_timer_new()SEQUENCER snd_seq_device_new()JACK snd_jack_new() è¿™äº›æ¥å£çš„ä¸€èˆ¬è¿‡ç¨‹å¦‚ä¸‹ï¼š 1234567891011121314int snd_xxx_new()&#123; // è¿™äº›æ¥å£ä¾›é€»è¾‘è®¾å¤‡æ³¨å†Œæ—¶å›è°ƒ static struct snd_device_ops ops = &#123; .dev_free = snd_xxx_dev_free, .dev_register = snd_xxx_dev_register, .dev_disconnect = snd_xxx_dev_disconnect, &#125;; // é€»è¾‘è®¾å¤‡å®ä¾‹åˆå§‹åŒ– // æ–°å»ºä¸€ä¸ªè®¾å¤‡å®ä¾‹ snd_deviceï¼ŒæŒ‚åˆ° snd_card çš„ devices é“¾è¡¨ä¸Šï¼ŒæŠŠè¯¥é€»è¾‘è®¾å¤‡çº³å…¥å£°å¡çš„ç®¡ç†å½“ä¸­ï¼ŒSNDRV_DEV_xxx æ˜¯é€»è¾‘è®¾å¤‡çš„ç±»å‹ return snd_device_new(card, SNDRV_DEV_xxx, card, &amp;ops);&#125; å…¶ä¸­ snd_device_ops æ˜¯å£°å¡é€»è¾‘è®¾å¤‡çš„æ³¨å†Œå‡½æ•°é›†ï¼Œdev_register() å›è°ƒå°¤å…¶é‡è¦ï¼Œå®ƒåœ¨å£°å¡æ³¨å†Œæ—¶è¢«è°ƒç”¨ï¼Œç”¨äºå»ºç«‹ç³»ç»Ÿçš„è®¾å¤‡èŠ‚ç‚¹ï¼Œ/dev/snd/ ç›®å½•çš„è®¾å¤‡èŠ‚ç‚¹éƒ½æ˜¯åœ¨è¿™é‡Œåˆ›å»ºçš„ï¼Œé€šè¿‡è¿™äº›è®¾å¤‡èŠ‚ç‚¹å¯ç³»ç»Ÿè°ƒç”¨ open/release/read/write/ioctlâ€¦ è®¿é—®æ“ä½œè¯¥é€»è¾‘è®¾å¤‡ã€‚ ä¾‹å¦‚ snd_ctl_dev_register()ï¼š 123456789101112131415161718192021222324252627282930313233[-&gt;/sound/core/control.c]static const struct file_operations snd_ctl_f_ops =&#123; .owner = THIS_MODULE, .read = snd_ctl_read, .open = snd_ctl_open, .release = snd_ctl_release, .llseek = no_llseek, .poll = snd_ctl_poll, .unlocked_ioctl = snd_ctl_ioctl, .compat_ioctl = snd_ctl_ioctl_compat, .fasync = snd_ctl_fasync,&#125;;/* * registration of the control device */static int snd_ctl_dev_register(struct snd_device *device)&#123; struct snd_card *card = device-&gt;device_data; int err, cardnum; char name[16]; if (snd_BUG_ON(!card)) return -ENXIO; cardnum = card-&gt;number; if (snd_BUG_ON(cardnum &lt; 0 || cardnum &gt;= SNDRV_CARDS)) return -ENXIO; sprintf(name, \"controlC%i\", cardnum); if ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, -1, &amp;snd_ctl_f_ops, card, name)) &lt; 0) return err; return 0;&#125; äº‹å®æ˜¯è°ƒç”¨ snd_register_device_for_dev ()ï¼š 12345678910111213141516171819202122232425262728293031[-&gt;/sound/core/sound.c]int snd_register_device_for_dev(int type, struct snd_card *card, int dev, const struct file_operations *f_ops, void *private_data, const char *name, struct device *device)&#123; int minor; struct snd_minor *preg; preg = kmalloc(sizeof *preg, GFP_KERNEL); preg-&gt;type = type; preg-&gt;card = card ? card-&gt;number : -1; preg-&gt;device = dev; preg-&gt;f_ops = f_ops; preg-&gt;private_data = private_data; preg-&gt;card_ptr = card; mutex_lock(&amp;sound_mutex);#ifdef CONFIG_SND_DYNAMIC_MINORS minor = snd_find_free_minor(type);#else minor = snd_kernel_minor(type, card, dev);#endif ...... snd_minors[minor] = preg; preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor), private_data, \"%s\", name); ...... mutex_unlock(&amp;sound_mutex); return 0;&#125; åˆ†é…å¹¶åˆå§‹åŒ–ä¸€ä¸ª snd_minor å®ä¾‹ï¼›ä¿å­˜è¯¥ snd_minor å®ä¾‹åˆ° snd_minors æ•°ç»„ä¸­ï¼›è°ƒç”¨ device_create() ç”Ÿæˆè®¾å¤‡æ–‡ä»¶èŠ‚ç‚¹ã€‚ ä¸Šé¢è¿‡ç¨‹æ˜¯å£°å¡æ³¨å†Œæ—¶æ‰è¢«å›è°ƒçš„ã€‚ 6.4. å£°å¡çš„æ³¨å†Œå½“å£°å¡ä¸‹çš„æ‰€æœ‰é€»è¾‘è®¾å¤‡éƒ½å·²ç»å‡†å¤‡å°±ç»ªåï¼Œå°±å¯ä»¥è°ƒç”¨ snd_card_register() æ³¨å†Œå£°å¡äº†ï¼š â€¢ åˆ›å»ºå£°å¡çš„ sysfs è®¾å¤‡ï¼›â€¢ è°ƒç”¨ snd_device_register_all() æ³¨å†Œæ‰€æœ‰æŒ‚åœ¨è¯¥å£°å¡ä¸‹çš„é€»è¾‘è®¾å¤‡ï¼›â€¢ å»ºç«‹ proc ä¿¡æ¯æ–‡ä»¶å’Œ sysfs å±æ€§æ–‡ä»¶ã€‚ ï¼ˆä¸ƒï¼‰ã€DAPMåˆ†æ7.1ã€DAPMç®€ä»‹ DAPMæ˜¯Dynamic Audio Power Managementçš„ç¼©å†™ï¼Œç›´è¯‘è¿‡æ¥å°±æ˜¯åŠ¨æ€éŸ³é¢‘ç”µæºç®¡ç†çš„æ„æ€ï¼ŒDAPMæ˜¯ä¸ºäº†ä½¿åŸºäºlinuxçš„ç§»åŠ¨è®¾å¤‡ä¸Šçš„éŸ³é¢‘å­ç³»ç»Ÿï¼Œåœ¨ä»»ä½•æ—¶å€™éƒ½å·¥ä½œåœ¨æœ€å°åŠŸè€—çŠ¶æ€ä¸‹ã€‚DAPMå¯¹ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºæ¥è¯´æ˜¯é€æ˜çš„ï¼Œæ‰€æœ‰ä¸ç”µæºç›¸å…³çš„å¼€å…³éƒ½åœ¨ASoc coreä¸­å®Œæˆã€‚ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºæ— éœ€å¯¹ä»£ç åšå‡ºä¿®æ”¹ï¼Œä¹Ÿæ— éœ€é‡æ–°ç¼–è¯‘ï¼ŒDAPMæ ¹æ®å½“å‰æ¿€æ´»çš„éŸ³é¢‘æµï¼ˆplayback/captureï¼‰å’Œå£°å¡ä¸­çš„mixerç­‰çš„é…ç½®æ¥å†³å®šé‚£äº›éŸ³é¢‘æ§ä»¶çš„ç”µæºå¼€å…³è¢«æ‰“å¼€æˆ–å…³é—­ã€‚ DAPMæ˜¯åŸºäºkcontrolæ”¹è¿›è¿‡åçš„ç›¸åº”æ¡†æ¶ï¼Œå¢åŠ äº†ç›¸åº”çš„ç”µæºç®¡ç†æœºåˆ¶ï¼Œå…¶ç”µæºç®¡ç†æœºåˆ¶å…¶å®å°±æ˜¯æŒ‰ç…§ç›¸åº”çš„éŸ³é¢‘è·¯å¾„ï¼Œå®Œç¾çš„å¯¹å„ç§éƒ¨ä»¶çš„ç”µæºè¿›è¡Œæ§åˆ¶ï¼Œè€Œä¸”æŒ‰ç…§æŸç§é¡ºåºè¿›è¡Œã€‚ 7.1ã€kcontrolé€šå¸¸ï¼Œä¸€ä¸ªkcontrolä»£è¡¨ç€ä¸€ä¸ªmixerï¼ˆæ··éŸ³å™¨ï¼‰ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªmuxï¼ˆå¤šè·¯å¼€å…³ï¼‰ï¼Œåˆæˆ–è€…æ˜¯ä¸€ä¸ªéŸ³é‡æ§åˆ¶å™¨ç­‰ç­‰ã€‚ ä»ä¸Šè¿°æ–‡ç« ä¸­æˆ‘ä»¬çŸ¥é“ï¼Œå®šä¹‰ä¸€ä¸ªkcontrolä¸»è¦å°±æ˜¯å®šä¹‰ä¸€ä¸ªsnd_kcontrol_new ç»“æ„ï¼Œ 123456789101112131415161718[-&gt;/include/sound/control.h]struct snd_kcontrol_new &#123; snd_ctl_elem_iface_t iface; /* interface identifier */ unsigned int device; /* device/client number */ unsigned int subdevice; /* subdevice (substream) number */ const unsigned char *name; /* ASCII name of item */ unsigned int index; /* index of item */ unsigned int access; /* access rights */ unsigned int count; /* count of same elements */ snd_kcontrol_info_t *info; snd_kcontrol_get_t *get; snd_kcontrol_put_t *put; union &#123; snd_kcontrol_tlv_rw_t *c; const unsigned int *p; &#125; tlv; unsigned long private_value;&#125;; å¯¹äºæ¯ä¸ªæ§ä»¶ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªå’Œä»–å¯¹åº”çš„snd_kcontrol_newç»“æ„ï¼Œè¿™äº›snd_kcontrol_newç»“æ„ä¼šåœ¨å£°å¡çš„åˆå§‹åŒ–é˜¶æ®µï¼Œé€šè¿‡snd_soc_dapm_new_controls()å‡½æ•°æ³¨å†Œåˆ°ç³»ç»Ÿä¸­ï¼Œç”¨æˆ·ç©ºé—´å°±å¯ä»¥é€šè¿‡tinymixæŸ¥çœ‹å’Œè®¾å®šè¿™äº›æ§ä»¶çš„çŠ¶æ€ã€‚ç¼–è¯‘/external/tinyalsa/å¾—åˆ°tinymix, tinyplay, tinycapï¼ŒPushåˆ°æ‰‹æœºæ‰§è¡Œtinymixå¯å¾—åˆ°å¦‚ä¸‹ç±»ä¼¼ä¿¡æ¯ã€‚ 123456789101112131415......990 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia10 Off991 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia11 Off992 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia12 Off993 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia13 Off994 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia14 Off995 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia15 Off996 BOOL 1 QUAT_MI2S_RX Audio Mixer MultiMedia16 Off997 BOOL 1 MI2S_RX Audio Mixer MultiMedia1 Off998 BOOL 1 MI2S_RX Audio Mixer MultiMedia2 Off999 BOOL 1 MI2S_RX Audio Mixer MultiMedia3 Off1000 BOOL 1 MI2S_RX Audio Mixer MultiMedia4 Off1001 BOOL 1 MI2S_RX Audio Mixer MultiMedia5 Off1002 BOOL 1 MI2S_RX Audio Mixer MultiMedia6 Off...... snd_kcontrol_newç»“æ„ä¸­ï¼Œå‡ ä¸ªä¸»è¦çš„å­—æ®µæ˜¯getï¼Œputï¼Œprivate_valueï¼Œgetå›è°ƒå‡½æ•°ç”¨äºè·å–è¯¥æ§ä»¶å½“å‰çš„çŠ¶æ€å€¼ï¼Œè€Œputå›è°ƒå‡½æ•°åˆ™ç”¨äºè®¾ç½®æ§ä»¶çš„çŠ¶æ€å€¼ï¼Œè€Œprivate_valueå­—æ®µåˆ™æ ¹æ®ä¸åŒçš„æ§ä»¶ç±»å‹æœ‰ä¸åŒçš„æ„ä¹‰ï¼Œæ¯”å¦‚å¯¹äºæ™®é€šçš„æ§ä»¶ï¼Œprivate_valueå­—æ®µå¯ä»¥ç”¨æ¥å®šä¹‰è¯¥æ§ä»¶æ‰€å¯¹åº”çš„å¯„å­˜å™¨çš„åœ°å€ä»¥åŠå¯¹åº”çš„æ§åˆ¶ä½åœ¨å¯„å­˜å™¨ä¸­çš„ä½ç½®ä¿¡æ¯ã€‚å€¼å¾—åº†å¹¸çš„æ˜¯ï¼ŒASocç³»ç»Ÿå·²ç»ä¸ºæˆ‘ä»¬å‡†å¤‡äº†å¤§é‡çš„å®å®šä¹‰ï¼Œç”¨äºå®šä¹‰å¸¸ç”¨çš„æ§ä»¶ï¼Œè¿™äº›å®å®šä¹‰ä½äºinclude/sound/soc.hä¸­ã€‚ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«è®¨è®ºä¸€ä¸‹å¦‚ä½•ç”¨è¿™äº›é¢„è®¾çš„å®å®šä¹‰æ¥å®šä¹‰ä¸€äº›å¸¸ç”¨çš„æ§ä»¶ã€‚ 7.1.1ã€ç®€å•å‹çš„æ§ä»¶SOC_SINGLE SOC_SINGLEåº”è¯¥ç®—æ˜¯æœ€ç®€å•çš„æ§ä»¶äº†ï¼Œè¿™ç§æ§ä»¶åªæœ‰ä¸€ä¸ªæ§åˆ¶é‡ï¼Œæ¯”å¦‚ä¸€ä¸ªå¼€å…³ï¼Œæˆ–è€…æ˜¯ä¸€ä¸ªæ•°å€¼å˜é‡ï¼ˆæ¯”å¦‚Codecä¸­æŸä¸ªé¢‘ç‡ï¼ŒFIFOå¤§å°ç­‰ç­‰ï¼‰ã€‚æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªå®æ˜¯å¦‚ä½•å®šä¹‰çš„ï¼š123456[-&gt;/include/sound/soc.h]#define SOC_SINGLE(xname, reg, shift, max, invert) \\&#123; .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\ .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\ .put = snd_soc_put_volsw, \\ .private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) &#125; å®å®šä¹‰çš„å‚æ•°åˆ†åˆ«æ˜¯ï¼šxnameï¼ˆè¯¥æ§ä»¶çš„åå­—ï¼‰ï¼Œregï¼ˆè¯¥æ§ä»¶å¯¹åº”çš„å¯„å­˜å™¨çš„åœ°å€ï¼‰ï¼Œshiftï¼ˆæ§åˆ¶ä½åœ¨å¯„å­˜å™¨ä¸­çš„ä½ç§»ï¼‰ï¼Œmaxï¼ˆæ§ä»¶å¯è®¾ç½®çš„æœ€å¤§å€¼ï¼‰ï¼Œinvertï¼ˆè®¾å®šå€¼æ˜¯å¦é€»è¾‘å–åï¼‰ã€‚è¿™é‡Œåˆä½¿ç”¨äº†ä¸€ä¸ªå®æ¥å®šä¹‰private_valueå­—æ®µï¼šSOC_SINGLE_VALUEï¼Œæˆ‘ä»¬çœ‹çœ‹å®ƒçš„å®šä¹‰ï¼š 12345678[-&gt;/include/sound/soc.h]#define SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \\ ((unsigned long)&amp;(struct soc_mixer_control) \\ &#123;.reg = xreg, .rreg = xreg, .shift = shift_left, \\ .rshift = shift_right, .max = xmax, .platform_max = xmax, \\ .invert = xinvert, .autodisable = xautodisable&#125;)#define SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \\ SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable) è¿™é‡Œå®é™…ä¸Šæ˜¯å®šä¹‰äº†ä¸€ä¸ªsoc_mixer_controlç»“æ„ï¼Œç„¶åæŠŠè¯¥ç»“æ„çš„åœ°å€èµ‹å€¼ç»™äº†private_valueå­—æ®µï¼Œsoc_mixer_controlç»“æ„æ˜¯è¿™æ ·çš„ï¼š 12345678910[-&gt;/include/sound/soc.h]/* mixer control */struct soc_mixer_control &#123; int min, max, platform_max; int reg, rreg; unsigned int shift, rshift; unsigned int sign_bit; unsigned int invert:1; unsigned int autodisable:1;&#125;; çœ‹æ¥soc_mixer_controlæ˜¯æ§ä»¶ç‰¹å¾çš„çœŸæ­£æè¿°è€…ï¼Œå®ƒç¡®å®šäº†è¯¥æ§ä»¶å¯¹åº”å¯„å­˜å™¨çš„åœ°å€ï¼Œä½ç§»å€¼ï¼Œæœ€å¤§å€¼å’Œæ˜¯å¦é€»è¾‘å–åç­‰ç‰¹æ€§ï¼Œæ§ä»¶çš„putå›è°ƒå‡½æ•°å’Œgetå›è°ƒå‡½æ•°éœ€è¦å€ŸåŠ©è¯¥ç»“æ„æ¥è®¿é—®å®é™…çš„å¯„å­˜å™¨ã€‚SOC_SINGLE_TLV SOC_SINGLE_TLVæ˜¯SOC_SINGLEçš„ä¸€ç§æ‰©å±•ï¼Œä¸»è¦ç”¨äºå®šä¹‰é‚£äº›æœ‰å¢ç›Šæ§åˆ¶çš„æ§ä»¶ï¼Œä¾‹å¦‚éŸ³é‡æ§åˆ¶å™¨ï¼ŒEQå‡è¡¡å™¨ç­‰ç­‰ã€‚ 123456789[-&gt;/include/sound/soc.h]#define SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \\&#123; .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \\ .access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\\ SNDRV_CTL_ELEM_ACCESS_READWRITE,\\ .tlv.p = (tlv_array), \\ .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\\ .put = snd_soc_put_volsw, \\ .private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) &#125; ä»ä»–çš„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œç”¨äºè®¾å®šå¯„å­˜å™¨ä¿¡æ¯çš„private_valueå­—æ®µçš„å®šä¹‰å’ŒSOC_SINGLEæ˜¯ä¸€æ ·çš„ï¼Œç”šè‡³putã€getå›è°ƒå‡½æ•°ä¹Ÿæ˜¯ä½¿ç”¨åŒä¸€å¥—ï¼Œå”¯ä¸€ä¸åŒçš„æ˜¯å¢åŠ äº†ä¸€ä¸ªtlv_arrayå‚æ•°ï¼Œå¹¶æŠŠå®ƒèµ‹å€¼ç»™äº†tlv.på­—æ®µã€‚ç”¨æˆ·ç©ºé—´å¯ä»¥é€šè¿‡å¯¹å£°å¡çš„controlè®¾å¤‡å‘èµ·ä»¥ä¸‹ä¸¤ç§ioctlæ¥è®¿é—®tlvå­—æ®µæ‰€æŒ‡å‘çš„æ•°ç»„ï¼š â€¢ SNDRV_CTL_IOCTL_TLV_READ â€¢ SNDRV_CTL_IOCTL_TLV_WRITE â€¢ SNDRV_CTL_IOCTL_TLV_COMMAND SOC_DOUBLE ä¸SOC_SINGLEç›¸å¯¹åº”ï¼ŒåŒºåˆ«æ˜¯SOC_SINGLEåªæ§åˆ¶ä¸€ä¸ªå˜é‡ï¼Œè€ŒSOC_DOUBLEåˆ™å¯ä»¥åŒæ—¶åœ¨ä¸€ä¸ªå¯„å­˜å™¨ä¸­æ§åˆ¶ä¸¤ä¸ªç›¸ä¼¼çš„å˜é‡ï¼Œæœ€å¸¸ç”¨çš„å°±æ˜¯ç”¨äºä¸€äº›ç«‹ä½“å£°çš„æ§ä»¶ï¼Œæˆ‘ä»¬éœ€è¦åŒæ—¶å¯¹å·¦å³å£°é“è¿›è¡Œæ§åˆ¶ï¼Œå› ä¸ºå¤šäº†ä¸€ä¸ªå£°é“ï¼Œå‚æ•°ä¹Ÿå°±ç›¸åº”åœ°å¤šäº†ä¸€ä¸ªshiftä½ç§»å€¼ SOC_DOUBLE_R ä¸SOC_DOUBLEç±»ä¼¼ï¼Œå¯¹äºå·¦å³å£°é“çš„æ§åˆ¶å¯„å­˜å™¨ä¸ä¸€æ ·çš„æƒ…å†µï¼Œä½¿ç”¨SOC_DOUBLE_Ræ¥å®šä¹‰ï¼Œå‚æ•°ä¸­éœ€è¦æŒ‡å®šä¸¤ä¸ªå¯„å­˜å™¨åœ°å€ã€‚SOC_DOUBLE_TLV ä¸SOC_SINGLE_TLVå¯¹åº”çš„ç«‹ä½“å£°ç‰ˆæœ¬ï¼Œé€šå¸¸ç”¨äºç«‹ä½“å£°éŸ³é‡æ§ä»¶çš„å®šä¹‰ã€‚ SOC_DOUBLE_R_TLV å·¦å³å£°é“æœ‰ç‹¬ç«‹å¯„å­˜å™¨æ§åˆ¶çš„SOC_DOUBLE_TLVç‰ˆæœ¬ 7.1.2ã€Mixeræ§ä»¶Mixeræ§ä»¶ç”¨äºéŸ³é¢‘é€šé“çš„è·¯ç”±æ§åˆ¶ï¼Œç”±å¤šä¸ªè¾“å…¥å’Œä¸€ä¸ªè¾“å‡ºç»„æˆï¼Œå¤šä¸ªè¾“å…¥å¯ä»¥è‡ªç”±åœ°æ··åˆåœ¨ä¸€èµ·ï¼Œå½¢æˆæ··åˆåçš„è¾“å‡ºï¼š å¯¹äºMixeræ§ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºæ˜¯å¤šä¸ªç®€å•æ§ä»¶çš„ç»„åˆï¼Œé€šå¸¸ï¼Œæˆ‘ä»¬ä¼šä¸ºmixerçš„æ¯ä¸ªè¾“å…¥ç«¯éƒ½å•ç‹¬å®šä¹‰ä¸€ä¸ªç®€å•æ§ä»¶æ¥æ§åˆ¶è¯¥è·¯è¾“å…¥çš„å¼€å¯å’Œå…³é—­ï¼Œååº”åœ¨ä»£ç ä¸Šï¼Œå°±æ˜¯å®šä¹‰ä¸€ä¸ªsoc_kcontrol_newæ•°ç»„ï¼š 1234567[-&gt;/sound/soc/codecs/wcd9335.c]static const struct snd_kcontrol_new aif4_vi_mixer[] = &#123; SOC_SINGLE_EXT(\"SPKR_VI_1\", SND_SOC_NOPM, TASHA_TX14, 1, 0, tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put), SOC_SINGLE_EXT(\"SPKR_VI_2\", SND_SOC_NOPM, TASHA_TX15, 1, 0, tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),&#125;; 7.1.3ã€Muxæ§ä»¶muxæ§ä»¶ä¸mixeræ§ä»¶ç±»ä¼¼ï¼Œä¹Ÿæ˜¯å¤šä¸ªè¾“å…¥ç«¯å’Œä¸€ä¸ªè¾“å‡ºç«¯çš„ç»„åˆæ§ä»¶ï¼Œä¸mixeræ§ä»¶ä¸åŒçš„æ˜¯ï¼Œmuxæ§ä»¶çš„å¤šä¸ªè¾“å…¥ç«¯åŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªè¢«é€‰ä¸­ã€‚å› æ­¤ï¼Œmuxæ§ä»¶æ‰€å¯¹åº”çš„å¯„å­˜å™¨ï¼Œé€šå¸¸å¯ä»¥è®¾å®šä¸€æ®µè¿ç»­çš„æ•°å€¼ï¼Œæ¯ä¸ªä¸åŒçš„æ•°å€¼å¯¹åº”ä¸åŒçš„è¾“å…¥ç«¯è¢«æ‰“å¼€ï¼Œä¸ä¸Šè¿°çš„mixeræ§ä»¶ä¸åŒï¼ŒASocç”¨soc_enumç»“æ„æ¥æè¿°muxæ§ä»¶çš„å¯„å­˜å™¨ä¿¡æ¯ï¼š 1234567891011[-&gt;/include/sound/soc.h]/* enumerated kcontrol */struct soc_enum &#123; int reg; unsigned char shift_l; unsigned char shift_r; unsigned int items; unsigned int mask; const char * const *texts; const unsigned int *values;&#125;; ä¸¤ä¸ªå¯„å­˜å™¨åœ°å€å’Œä½ç§»å­—æ®µï¼šregï¼Œreg2ï¼Œshift_lï¼Œshift_rï¼Œç”¨äºæè¿°å·¦å³å£°é“çš„æ§åˆ¶å¯„å­˜å™¨ä¿¡æ¯ã€‚å­—ç¬¦ä¸²æ•°ç»„æŒ‡é’ˆç”¨äºæè¿°æ¯ä¸ªè¾“å…¥ç«¯å¯¹åº”çš„åå­—ï¼Œvalueå­—æ®µåˆ™æŒ‡å‘ä¸€ä¸ªæ•°ç»„ï¼Œè¯¥æ•°ç»„å®šä¹‰äº†å¯„å­˜å™¨å¯ä»¥é€‰æ‹©çš„å€¼ï¼Œæ¯ä¸ªå€¼å¯¹åº”ä¸€ä¸ªè¾“å…¥ç«¯ï¼Œå¦‚æœvalueæ˜¯ä¸€ç»„è¿ç»­çš„å€¼ï¼Œé€šå¸¸æˆ‘ä»¬å¯ä»¥å¿½ç•¥valueså‚æ•°ã€‚ 7.2ã€widgetã€pathã€routeå‰é¢ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä»‹ç»äº†éŸ³é¢‘é©±åŠ¨ä¸­å¯¹åŸºæœ¬æ§åˆ¶å•å…ƒçš„å°è£…ï¼škcontrolã€‚åˆ©ç”¨kcontrolï¼Œæˆ‘ä»¬å¯ä»¥å®Œæˆå¯¹éŸ³é¢‘ç³»ç»Ÿä¸­çš„mixerï¼Œmuxï¼ŒéŸ³é‡æ§åˆ¶ï¼ŒéŸ³æ•ˆæ§åˆ¶ï¼Œä»¥åŠå„ç§å¼€å…³é‡çš„æ§åˆ¶ï¼Œé€šè¿‡å¯¹å„ç§kcontrolçš„æ§åˆ¶ï¼Œä½¿å¾—éŸ³é¢‘ç¡¬ä»¶èƒ½å¤ŸæŒ‰ç…§æˆ‘ä»¬é¢„æƒ³çš„ç»“æœè¿›è¡Œå·¥ä½œã€‚åŒæ—¶æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œkcontrolè¿˜æ˜¯æœ‰ä»¥ä¸‹å‡ ç‚¹ä¸è¶³ï¼šåªèƒ½æè¿°è‡ªèº«ï¼Œæ— æ³•æè¿°å„ä¸ªkcontrolä¹‹é—´çš„è¿æ¥å…³ç³»ï¼›æ²¡æœ‰ç›¸åº”çš„ç”µæºç®¡ç†æœºåˆ¶ï¼›æ²¡æœ‰ç›¸åº”çš„æ—¶é—´å¤„ç†æœºåˆ¶æ¥å“åº”æ’­æ”¾ã€åœæ­¢ã€ä¸Šç”µã€ä¸‹ç”µç­‰éŸ³é¢‘äº‹ä»¶ï¼›ä¸ºäº†é˜²æ­¢pop-popå£°ï¼Œéœ€è¦ç”¨æˆ·ç¨‹åºå…³æ³¨å„ä¸ªkcontrolä¸Šç”µå’Œä¸‹ç”µçš„é¡ºåºï¼›å½“ä¸€ä¸ªéŸ³é¢‘è·¯å¾„ä¸å†æœ‰æ•ˆæ—¶ï¼Œä¸èƒ½è‡ªåŠ¨å…³é—­è¯¥è·¯å¾„ä¸Šçš„æ‰€æœ‰çš„kcontrolï¼›ä¸ºæ­¤ï¼ŒDAPMæ¡†æ¶æ­£æ˜¯ä¸ºäº†è¦è§£å†³ä»¥ä¸Šè¿™äº›é—®é¢˜è€Œè¯ç”Ÿçš„ï¼ŒDAPMç›®å‰å·²ç»æ˜¯ASocä¸­çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œè®©æˆ‘ä»¬å…ˆä»DAPMçš„æ•°æ®ç»“æ„å¼€å§‹ï¼Œäº†è§£å®ƒçš„è®¾è®¡æ€æƒ³å’Œå·¥ä½œåŸç†ã€‚ 7.2.1ã€DAPMçš„åŸºæœ¬å•å…ƒï¼šwidgetæ–‡ç« çš„å¼€å¤´ï¼Œæˆ‘ä»¬è¯´æ˜äº†ä¸€ä¸‹ç›®å‰kcontrolçš„ä¸€äº›ä¸è¶³ï¼Œè€ŒDAPMæ¡†æ¶ä¸ºäº†è§£å†³è¿™äº›é—®é¢˜ï¼Œå¼•å…¥äº†widgetè¿™ä¸€æ¦‚å¿µï¼Œæ‰€è°“widgetï¼Œå…¶å®å¯ä»¥ç†è§£ä¸ºæ˜¯kcontrolçš„è¿›ä¸€æ­¥å‡çº§å’Œå°è£…ï¼Œå¥¹åŒæ ·æ˜¯æŒ‡éŸ³é¢‘ç³»ç»Ÿä¸­çš„æŸä¸ªéƒ¨ä»¶ï¼Œæ¯”å¦‚mixerï¼Œmuxï¼Œè¾“å…¥è¾“å‡ºå¼•è„šï¼Œç”µæºä¾›åº”å™¨ç­‰ç­‰ï¼Œç”šè‡³ï¼Œæˆ‘ä»¬å¯ä»¥å®šä¹‰è™šæ‹Ÿçš„widgetï¼Œä¾‹å¦‚playback stream widgetã€‚widgetæŠŠkcontrolå’ŒåŠ¨æ€ç”µæºç®¡ç†è¿›è¡Œäº†æœ‰æœºçš„ç»“åˆï¼ŒåŒæ—¶è¿˜å…·å¤‡éŸ³é¢‘è·¯å¾„çš„è¿ç»“åŠŸèƒ½ï¼Œä¸€ä¸ªwidgetå¯ä»¥ä¸å®ƒç›¸é‚»çš„widgetæœ‰æŸç§åŠ¨æ€çš„è¿ç»“å…³ç³»ã€‚åœ¨DAPMæ¡†æ¶ä¸­ï¼Œwidgetç”¨ç»“æ„ä½“snd_soc_dapm_widgetæ¥æè¿°ï¼š 123456789101112131415161718192021222324252627282930313233343536[-&gt;/include/sound/soc-dapm.h]/* dapm widget */struct snd_soc_dapm_widget &#123; enum snd_soc_dapm_type id; const char *name; /* widget name */ const char *sname; /* stream name */ struct snd_soc_codec *codec; struct list_head list; struct snd_soc_dapm_context *dapm; void *priv; /* widget specific data */ struct regulator *regulator; /* attached regulator */ const struct snd_soc_pcm_stream *params; /* params for dai links */ /* dapm control */ int reg; /* negative reg = no direct dapm */ unsigned char shift; /* bits to shift */ unsigned int mask; /* non-shifted mask */ unsigned int on_val; /* on state value */ unsigned int off_val; /* off state value */ unsigned char power:1; /* block power status */ unsigned char active:1; /* active stream on DAC, ADC's */ unsigned char connected:1; /* connected codec pin */ unsigned char new:1; /* cnew complete */ unsigned char ext:1; /* has external widgets */ unsigned char force:1; /* force state */ unsigned char ignore_suspend:1; /* kept enabled over suspend */ unsigned char new_power:1; /* power from this run */ unsigned char power_checked:1; /* power checked this run */ int subseq; /* sort within widget type */ ...... /* widget input and outputs */ struct list_head sources; struct list_head sinks; ......&#125;; snd_soc_dapm_widgetç»“æ„æ¯”è¾ƒå¤§ï¼Œä¸ºäº†ç®€æ´ä¸€äº›ï¼Œè¿™é‡Œæˆ‘æ²¡æœ‰åˆ—å‡ºè¯¥ç»“æ„ä½“çš„å®Œæ•´å­—æ®µï¼Œä¸è¿‡ä¸ç”¨æ‹…å¿ƒï¼Œä¸‹é¢æˆ‘ä¼šè¯´æ˜æ¯ä¸ªå­—æ®µçš„æ„ä¹‰ï¼šid è¯¥widgetçš„ç±»å‹å€¼ï¼Œæ¯”å¦‚snd_soc_dapm_outputï¼Œsnd_soc_dapm_mixerç­‰ç­‰ã€‚ *name è¯¥widgetçš„åå­— *sname ä»£è¡¨è¯¥widgetæ‰€åœ¨streamçš„åå­—ï¼Œæ¯”å¦‚å¯¹äºsnd_soc_dapm_dai_inç±»å‹çš„widgetï¼Œä¼šä½¿ç”¨è¯¥å­—æ®µã€‚ codec platform æŒ‡å‘è¯¥widgetæ‰€å±çš„codecå’Œplatformã€‚ list æ‰€æœ‰æ³¨å†Œåˆ°ç³»ç»Ÿä¸­çš„widgetéƒ½ä¼šé€šè¿‡è¯¥listï¼Œé“¾æ¥åˆ°ä»£è¡¨å£°å¡çš„snd_soc_cardç»“æ„çš„widgetsé“¾è¡¨å¤´å­—æ®µä¸­ã€‚ *dapm snd_soc_dapm_contextç»“æ„æŒ‡é’ˆï¼ŒASocæŠŠç³»ç»Ÿåˆ’åˆ†ä¸ºå¤šä¸ªdapmåŸŸï¼Œæ¯ä¸ªwidgetå±äºæŸä¸ªdapmåŸŸï¼ŒåŒä¸€ä¸ªåŸŸä»£è¡¨ç€åŒæ ·çš„åç½®ç”µå‹ä¾›ç”µç­–ç•¥ï¼Œæ¯”å¦‚ï¼ŒåŒä¸€ä¸ªcodecä¸­çš„widgeté€šå¸¸ä½äºåŒä¸€ä¸ªdapmåŸŸï¼Œè€Œå¹³å°ä¸Šçš„widgetå¯èƒ½åˆä¼šä½äºå¦å¤–ä¸€ä¸ªplatformåŸŸä¸­ã€‚ *priv æœ‰äº›widgetå¯èƒ½éœ€è¦ä¸€äº›ä¸“æœ‰çš„æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨è¯¥å­—æ®µæ¥ä¿å­˜ï¼Œåƒsnd_soc_dapm_dai_inç±»å‹çš„widgetï¼Œä¼šä½¿ç”¨è¯¥å­—æ®µæ¥è®°ä½ä¸ä¹‹ç›¸å…³è”çš„snd_soc_daiç»“æ„æŒ‡é’ˆã€‚ *regulator å¯¹äºsnd_soc_dapm_regulator_supplyç±»å‹çš„widgetï¼Œè¯¥å­—æ®µæŒ‡å‘ä¸ä¹‹ç›¸å…³çš„regulatorç»“æ„æŒ‡é’ˆã€‚ *params ç›®å‰å¯¹äºsnd_soc_dapm_dai_linkç±»å‹çš„widgetï¼ŒæŒ‡å‘è¯¥daiçš„é…ç½®ä¿¡æ¯çš„snd_soc_pcm_streamç»“æ„ã€‚ reg shift mask è¿™3ä¸ªå­—æ®µç”¨æ¥æ§åˆ¶è¯¥widgetçš„ç”µæºçŠ¶æ€ï¼Œåˆ†åˆ«å¯¹åº”æ§åˆ¶ä¿¡æ¯æ‰€åœ¨çš„å¯„å­˜å™¨åœ°å€ï¼Œä½ç§»å€¼å’Œå±è”½å€¼ã€‚ value on_val off_val ç”µæºçŠ¶æ€çš„å½“å‰åªï¼Œå¼€å¯æ—¶å’Œå…³é—­æ—¶æ‰€å¯¹åº”çš„å€¼ã€‚ power invert ç”¨äºæŒ‡ç¤ºè¯¥widgetå½“å‰æ˜¯å¦å¤„äºä¸Šç”µçŠ¶æ€ï¼Œinvertåˆ™ç”¨äºè¡¨æ˜powerå­—æ®µæ˜¯å¦éœ€è¦é€»è¾‘åè½¬ã€‚ active connected åˆ†åˆ«è¡¨ç¤ºè¯¥widgetæ˜¯å¦å¤„äºæ¿€æ´»çŠ¶æ€å’Œè¿æ¥çŠ¶æ€ï¼Œå½“å’Œç›¸é‚»çš„widgetæœ‰è¿æ¥å…³ç³»æ—¶ï¼Œconnectedä½ä¼šè¢«ç½®1ï¼Œå¦åˆ™ç½®0ã€‚ new æˆ‘ä»¬å®šä¹‰å¥½çš„widgetï¼ˆsnd_soc_dapm_widgetç»“æ„ï¼‰ï¼Œåœ¨æ³¨å†Œåˆ°å£°å¡ä¸­æ—¶éœ€è¦è¿›è¡Œå®ä¾‹åŒ–ï¼Œè¯¥å­—æ®µç”¨æ¥è¡¨ç¤ºè¯¥widgetæ˜¯å¦å·²ç»è¢«å®ä¾‹åŒ–ã€‚ ext è¡¨ç¤ºè¯¥widgetå½“å‰æ˜¯å¦æœ‰å¤–éƒ¨è¿æ¥ï¼Œæ¯”å¦‚è¿æ¥micï¼Œè€³æœºï¼Œå–‡å­ç­‰ç­‰ã€‚ force è¯¥ä½è¢«è®¾ç½®åï¼Œå°†ä¼šä¸ç®¡widgetå½“å‰çš„çŠ¶æ€ï¼Œå¼ºåˆ¶æ›´æ–°è‡³æ–°çš„ç”µæºçŠ¶æ€ã€‚ ignore_suspend new_power power_checked è¿™äº›ç”µæºç®¡ç†ç›¸å…³çš„å­—æ®µã€‚ subseq è¯¥widgetç›®å‰åœ¨ä¸Šç”µæˆ–ä¸‹ç”µé˜Ÿåˆ—ä¸­çš„æ’åºç¼–å·ï¼Œä¸ºäº†é˜²æ­¢åœ¨ä¸Šä¸‹ç”µçš„è¿‡ç¨‹ä¸­å‡ºç°pop-popå£°ï¼ŒDAPMä¼šç»™æ¯ä¸ªwidgetåˆ†é…åˆç†çš„ä¸Šä¸‹ç”µé¡ºåºã€‚ *power_check ç”¨äºæ£€æŸ¥è¯¥widgetæ˜¯å¦åº”è¯¥ä¸Šç”µæˆ–ä¸‹ç”µçš„å›è°ƒå‡½æ•°æŒ‡é’ˆã€‚event_flags è¯¥å­—æ®µæ˜¯ä¸€ä¸ªä½æˆ–å­—æ®µï¼Œæ¯ä¸ªä½ä»£è¡¨è¯¥widgetä¼šå…³æ³¨æŸä¸ªDAPMäº‹ä»¶é€šçŸ¥ã€‚åªæœ‰è¢«å…³æ³¨çš„é€šçŸ¥äº‹ä»¶ä¼šè¢«å‘é€åˆ°widgetçš„äº‹ä»¶å¤„ç†å›è°ƒå‡½æ•°ä¸­ã€‚ *event DAPMäº‹ä»¶å¤„ç†å›è°ƒå‡½æ•°æŒ‡é’ˆã€‚ num_kcontrols kcontrol_news *kcontrols è¿™3ä¸ªå­—æ®µç”¨æ¥æè¿°ä¸è¯¥widgetæ‰€åŒ…å«çš„kcontrolæ§ä»¶ï¼Œä¾‹å¦‚ä¸€ä¸ªmixeræ§ä»¶æˆ–è€…æ˜¯ä¸€ä¸ªmuxæ§ä»¶ã€‚ sources sinks ä¸¤ä¸ªé“¾è¡¨å­—æ®µï¼Œä¸¤ä¸ªwidgetå¦‚æœæœ‰è¿æ¥å…³ç³»ï¼Œä¼šé€šè¿‡ä¸€ä¸ªsnd_soc_dapm_pathç»“æ„è¿›è¡Œè¿æ¥ï¼Œsourcesé“¾è¡¨ç”¨äºé“¾æ¥æ‰€æœ‰çš„è¾“å…¥pathï¼Œsinksé“¾è¡¨ç”¨äºé“¾æ¥æ‰€æœ‰çš„è¾“å‡ºpathã€‚ power_list æ¯æ¬¡æ›´æ–°æ•´ä¸ªdapmçš„ç”µæºçŠ¶æ€æ—¶ï¼Œä¼šæ ¹æ®ä¸€å®šçš„ç®—æ³•æ‰«ææ‰€æœ‰çš„widgetï¼Œç„¶åæŠŠéœ€è¦å˜æ›´ç”µæºçŠ¶æ€çš„widgetåˆ©ç”¨è¯¥å­—æ®µé“¾æ¥åˆ°ä¸€ä¸ªä¸Šç”µæˆ–ä¸‹ç”µçš„é“¾è¡¨ä¸­ï¼Œæ‰«æå®Œæ¯•åï¼Œdapmç³»ç»Ÿä¼šéå†è¿™ä¸¤ä¸ªé“¾è¡¨æ‰§è¡Œç›¸åº”çš„ä¸Šç”µæˆ–ä¸‹ç”µæ“ä½œã€‚ dirty é“¾è¡¨å­—æ®µï¼Œwidgetçš„çŠ¶æ€å˜æ›´åï¼Œdapmç³»ç»Ÿä¼šåˆ©ç”¨è¯¥å­—æ®µï¼ŒæŠŠè¯¥widgetåŠ å…¥åˆ°ä¸€ä¸ªdirtyé“¾è¡¨ä¸­ï¼Œç¨åä¼šå¯¹dirtyé“¾è¡¨è¿›è¡Œæ‰«æï¼Œä»¥æ‰§è¡Œæ•´ä¸ªè·¯å¾„çš„æ›´æ–°ã€‚ inputs è¯¥widgetçš„æ‰€æœ‰æœ‰æ•ˆè·¯å¾„ä¸­ï¼Œè¿æ¥åˆ°è¾“å…¥ç«¯çš„è·¯å¾„æ•°é‡ã€‚ outputs è¯¥widgetçš„æ‰€æœ‰æœ‰æ•ˆè·¯å¾„ä¸­ï¼Œè¿æ¥åˆ°è¾“å‡ºç«¯çš„è·¯å¾„æ•°é‡ã€‚ *clk å¯¹äºsnd_soc_dapm_clock_supplyç±»å‹çš„widgetï¼ŒæŒ‡å‘ç›¸å…³è”çš„clkç»“æ„æŒ‡é’ˆã€‚ ä»¥ä¸Šæˆ‘ä»¬å¯¹snd_soc_dapm_widgetç»“æ„çš„å„ä¸ªå­—æ®µæ‰€ä»£è¡¨çš„æ„ä¹‰ä¸€ä¸€åšå‡ºäº†è¯´æ˜ï¼Œè¿™é‡Œåªæ˜¯è®©å¤§å®¶ç°æœ‰ä¸ªæ¦‚å¿µ 7.2.2ã€widgetçš„ç§ç±»åœ¨DAPMæ¡†æ¶ä¸­ï¼ŒæŠŠå„ç§ä¸åŒçš„widgetåˆ’åˆ†ä¸ºä¸åŒçš„ç§ç±»ï¼Œsnd_soc_dapm_widgetç»“æ„ä¸­çš„idå­—æ®µç”¨æ¥è¡¨ç¤ºè¯¥widgetçš„ç§ç±»ï¼Œå¯é€‰çš„ç§ç±»éƒ½å®šä¹‰åœ¨ä¸€ä¸ªæšä¸¾ä¸­ï¼š 123456[-&gt;/include/sound/soc-dapm.h]/* dapm widget types */enum snd_soc_dapm_type &#123; snd_soc_dapm_input = 0, /* input pin */ snd_soc_dapm_output, /* output pin */ ...... ä¸‹é¢æˆ‘ä»¬é€ä¸ªè§£é‡Šä¸€ä¸‹è¿™äº›widgetçš„ç§ç±»ï¼šsnd_soc_dapm_input è¯¥widgetå¯¹åº”ä¸€ä¸ªè¾“å…¥å¼•è„šã€‚snd_soc_dapm_output è¯¥widgetå¯¹åº”ä¸€ä¸ªè¾“å‡ºå¼•è„šã€‚snd_soc_dapm_mux è¯¥widgetå¯¹åº”ä¸€ä¸ªmuxæ§ä»¶ã€‚snd_soc_dapm_virt_mux è¯¥widgetå¯¹åº”ä¸€ä¸ªè™šæ‹Ÿçš„muxæ§ä»¶ã€‚snd_soc_dapm_value_mux è¯¥widgetå¯¹åº”ä¸€ä¸ªvalueç±»å‹çš„muxæ§ä»¶ã€‚snd_soc_dapm_mixer è¯¥widgetå¯¹åº”ä¸€ä¸ªmixeræ§ä»¶ã€‚snd_soc_dapm_mixer_named_ctl è¯¥widgetå¯¹åº”ä¸€ä¸ªmixeræ§ä»¶ï¼Œä½†æ˜¯å¯¹åº”çš„kcontrolçš„åå­—ä¸ä¼šåŠ å…¥widgetçš„åå­—ä½œä¸ºå‰ç¼€ã€‚snd_soc_dapm_pga è¯¥widgetå¯¹åº”ä¸€ä¸ªpgaæ§ä»¶ï¼ˆå¯ç¼–ç¨‹å¢ç›Šæ§ä»¶ï¼‰ã€‚snd_soc_dapm_out_drv è¯¥widgetå¯¹åº”ä¸€ä¸ªè¾“å‡ºé©±åŠ¨æ§ä»¶snd_soc_dapm_adc è¯¥widgetå¯¹åº”ä¸€ä¸ªADCsnd_soc_dapm_dac è¯¥widgetå¯¹åº”ä¸€ä¸ªDACsnd_soc_dapm_micbias è¯¥widgetå¯¹åº”ä¸€ä¸ªéº¦å…‹é£åç½®ç”µå‹æ§ä»¶snd_soc_dapm_mic è¯¥widgetå¯¹åº”ä¸€ä¸ªéº¦å…‹é£ã€‚snd_soc_dapm_hp è¯¥widgetå¯¹åº”ä¸€ä¸ªè€³æœºã€‚snd_soc_dapm_spk è¯¥widgetå¯¹åº”ä¸€ä¸ªæ‰¬å£°å™¨ã€‚snd_soc_dapm_line è¯¥widgetå¯¹åº”ä¸€ä¸ªçº¿è·¯è¾“å…¥ã€‚snd_soc_dapm_switch è¯¥widgetå¯¹åº”ä¸€ä¸ªæ¨¡æ‹Ÿå¼€å…³ã€‚snd_soc_dapm_vmid è¯¥widgetå¯¹åº”ä¸€ä¸ªcodecçš„vmidåç½®ç”µå‹ã€‚snd_soc_dapm_pre machineçº§åˆ«çš„ä¸“ç”¨widgetï¼Œä¼šå…ˆäºå…¶å®ƒwidgetæ‰§è¡Œæ£€æŸ¥æ“ä½œã€‚snd_soc_dapm_post machineçº§åˆ«çš„ä¸“ç”¨widgetï¼Œä¼šåäºå…¶å®ƒwidgetæ‰§è¡Œæ£€æŸ¥æ“ä½œã€‚snd_soc_dapm_supply å¯¹åº”ä¸€ä¸ªç”µæºæˆ–æ˜¯æ—¶é’Ÿæºã€‚snd_soc_dapm_regulator_supply å¯¹åº”ä¸€ä¸ªå¤–éƒ¨regulatorç¨³å‹å™¨ã€‚snd_soc_dapm_clock_supply å¯¹åº”ä¸€ä¸ªå¤–éƒ¨æ—¶é’Ÿæºã€‚snd_soc_dapm_aif_in å¯¹åº”ä¸€ä¸ªæ•°å­—éŸ³é¢‘è¾“å…¥æ¥å£ï¼Œæ¯”å¦‚I2Sæ¥å£çš„è¾“å…¥ç«¯ã€‚snd_soc_dapm_aif_out å¯¹åº”ä¸€ä¸ªæ•°å­—éŸ³é¢‘è¾“å‡ºæ¥å£ï¼Œæ¯”å¦‚I2Sæ¥å£çš„è¾“å‡ºç«¯ã€‚snd_soc_dapm_siggen å¯¹åº”ä¸€ä¸ªä¿¡å·å‘ç”Ÿå™¨ã€‚snd_soc_dapm_dai_in å¯¹åº”ä¸€ä¸ªplatformæˆ–codecåŸŸçš„è¾“å…¥DAIç»“æ„ã€‚snd_soc_dapm_dai_out å¯¹åº”ä¸€ä¸ªplatformæˆ–codecåŸŸçš„è¾“å‡ºDAIç»“æ„ã€‚snd_soc_dapm_dai_link ç”¨äºé“¾æ¥ä¸€å¯¹è¾“å…¥/è¾“å‡ºDAIç»“æ„ã€‚ 7.2.3ã€widgetä¹‹é—´çš„è¿æ¥å™¨ï¼špathä¹‹å‰å·²ç»æåˆ°ï¼Œä¸€ä¸ªwidgetæ˜¯æœ‰è¾“å…¥å’Œè¾“å‡ºçš„ï¼Œè€Œä¸”widgetä¹‹é—´æ˜¯å¯ä»¥åŠ¨æ€åœ°è¿›è¡Œè¿æ¥çš„ï¼Œé‚£å®ƒä»¬æ˜¯ç”¨ä»€ä¹ˆæ¥è¿æ¥ä¸¤ä¸ªwidgetçš„å‘¢ï¼ŸDAPMä¸ºæˆ‘ä»¬æå‡ºäº†pathè¿™ä¸€æ¦‚å¿µï¼Œpathç›¸å½“äºç”µè·¯ä¸­çš„ä¸€æ ¹è·³çº¿ï¼Œå®ƒæŠŠä¸€ä¸ªwidgetçš„è¾“å‡ºç«¯å’Œå¦ä¸€ä¸ªwidgetçš„è¾“å…¥ç«¯è¿æ¥åœ¨ä¸€èµ·ï¼Œpathç”¨snd_soc_dapm_pathç»“æ„æ¥æè¿°ï¼š 1234567891011121314151617181920212223[-&gt;/include/sound/soc-dapm.h]/* dapm audio path between two widgets */struct snd_soc_dapm_path &#123; const char *name; /* source (input) and sink (output) widgets */ struct snd_soc_dapm_widget *source; struct snd_soc_dapm_widget *sink; /* status */ u32 connect:1; /* source and sink widgets are connected */ u32 walked:1; /* path has been walked */ u32 walking:1; /* path is in the process of being walked */ u32 weak:1; /* path ignored for power management */ int (*connected)(struct snd_soc_dapm_widget *source, struct snd_soc_dapm_widget *sink); struct list_head list_source; struct list_head list_sink; struct list_head list_kcontrol; struct list_head list;&#125;; å½“widgetä¹‹é—´å‘ç”Ÿè¿æ¥å…³ç³»æ—¶ï¼Œsnd_soc_dapm_pathä½œä¸ºè¿æ¥è€…ï¼Œå®ƒçš„sourceå­—æ®µä¼šæŒ‡å‘è¯¥è¿æ¥çš„èµ·å§‹ç«¯widgetï¼Œè€Œå®ƒçš„sinkå­—æ®µä¼šæŒ‡å‘è¯¥è¿æ¥çš„åˆ°è¾¾ç«¯widgetï¼Œè¿˜è®°å¾—å‰é¢snd_soc_dapm_widgetç»“æ„ä¸­çš„ä¸¤ä¸ªé“¾è¡¨å¤´å­—æ®µï¼šsourceså’Œsinksä¹ˆï¼Ÿwidgetçš„è¾“å…¥ç«¯å’Œè¾“å‡ºç«¯å¯èƒ½è¿æ¥ç€å¤šä¸ªpathï¼Œæ‰€æœ‰è¾“å…¥ç«¯çš„snd_soc_dapm_pathç»“æ„é€šè¿‡list_sinkå­—æ®µæŒ‚åœ¨widgetçš„soucesé“¾è¡¨ä¸­ï¼ŒåŒæ ·ï¼Œæ‰€æœ‰è¾“å‡ºç«¯çš„snd_soc_dapm_pathç»“æ„é€šè¿‡list_sourceå­—æ®µæŒ‚åœ¨widgetçš„sinksé“¾è¡¨ä¸­ã€‚è¿™é‡Œå¯èƒ½å¤§å®¶ä¼šè¢«æå¾—æ™•å‘¼å‘¼çš„ï¼Œä¸€ä¼šsourceï¼Œä¸€ä¼šsinkï¼Œä¸è¦ç´§ï¼Œåªè¦è®°ä½ï¼Œè¿æ¥çš„è·¯å¾„æ˜¯è¿™æ ·çš„ï¼šèµ·å§‹ç«¯widgetçš„è¾“å‡ºâ€“&gt;pathçš„è¾“å…¥â€“&gt;pathçš„è¾“å‡ºâ€“&gt;åˆ°è¾¾ç«¯widgetè¾“å…¥ã€‚å¦å¤–ï¼Œsnd_soc_dapm_pathç»“æ„çš„listå­—æ®µç”¨äºæŠŠæ‰€æœ‰çš„pathæ³¨å†Œåˆ°å£°å¡ä¸­ï¼Œå…¶å®å°±æ˜¯æŒ‚åœ¨snd_soc_cardç»“æ„çš„pathsé“¾è¡¨å¤´å­—æ®µä¸­ã€‚å¦‚æœä½ è¦è‡ªå·±å®šä¹‰æ–¹æ³•æ¥æ£€æŸ¥pathçš„å½“å‰è¿æ¥çŠ¶æ€ï¼Œä½ å¯ä»¥æä¾›è‡ªå·±çš„connectedå›è°ƒå‡½æ•°æŒ‡é’ˆã€‚ connectï¼Œwalkedï¼Œwalkingï¼Œweakæ˜¯å‡ ä¸ªè¾…åŠ©å­—æ®µï¼Œç”¨äºå¸®åŠ©æ‰€æœ‰pathçš„éå†ã€‚ 7.2.4ã€widgetçš„è¿æ¥å…³ç³»ï¼šrouteé€šè¿‡ä¸Šä¸€èŠ‚çš„å†…å®¹ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªè·¯å¾„çš„è¿æ¥è‡³å°‘åŒ…å«ä»¥ä¸‹å‡ ä¸ªå…ƒç´ ï¼šèµ·å§‹ç«¯widgetï¼Œè·³çº¿pathï¼Œåˆ°è¾¾ç«¯widgetï¼Œåœ¨DAPMä¸­ï¼Œç”¨snd_soc_dapm_routeç»“æ„æ¥æè¿°è¿™æ ·ä¸€ä¸ªè¿æ¥å…³ç³»ï¼š 12345678910[-&gt;/include/sound/soc-dapm.h]struct snd_soc_dapm_route &#123; const char *sink; const char *control; const char *source; /* Note: currently only supported for links where source is a supply */ int (*connected)(struct snd_soc_dapm_widget *source, struct snd_soc_dapm_widget *sink);&#125;; sinkæŒ‡å‘åˆ°è¾¾ç«¯widgetçš„åå­—å­—ç¬¦ä¸²ï¼ŒsourceæŒ‡å‘èµ·å§‹ç«¯widgetçš„åå­—å­—ç¬¦ä¸²ï¼ŒcontrolæŒ‡å‘è´Ÿè´£æ§åˆ¶è¯¥è¿æ¥æ‰€å¯¹åº”çš„kcontrolåå­—å­—ç¬¦ä¸²ï¼Œconnectedå›è°ƒåˆ™å®šä¹‰äº†ä¸Šä¸€èŠ‚æ‰€æåˆ°çš„è‡ªå®šä¹‰è¿æ¥æ£€æŸ¥å›è°ƒå‡½æ•°ã€‚è¯¥ç»“æ„çš„æ„ä¹‰å¾ˆæ˜æ˜¾å°±æ˜¯ï¼šsourceé€šè¿‡ä¸€ä¸ªkcontrolï¼Œå’Œsinkè¿æ¥åœ¨ä¸€èµ·ï¼Œç°åœ¨æ˜¯å¦å¤„äºè¿æ¥çŠ¶æ€ï¼Œè¯·è°ƒç”¨connectedå›è°ƒå‡½æ•°æ£€æŸ¥ã€‚è¿™é‡Œç›´æ¥ä½¿ç”¨åå­—å­—ç¬¦ä¸²æ¥æè¿°è¿æ¥å…³ç³»ï¼Œæ‰€æœ‰å®šä¹‰å¥½çš„routeï¼Œæœ€åéƒ½è¦æ³¨å†Œåˆ°dapmç³»ç»Ÿä¸­ï¼Œdapmä¼šæ ¹æ®è¿™äº›åå­—æ‰¾å‡ºç›¸åº”çš„widgetï¼Œå¹¶åŠ¨æ€åœ°ç”Ÿæˆæ‰€éœ€è¦çš„snd_soc_dapm_pathç»“æ„ï¼Œæ­£ç¡®åœ°å¤„ç†å„ä¸ªé“¾è¡¨å’ŒæŒ‡é’ˆçš„å…³ç³»ï¼Œå®ç°ä¸¤ä¸ªwidgetä¹‹é—´çš„è¿æ¥ 7.3ã€å»ºç«‹widgetä¹‹é—´çš„è¿æ¥å…³ç³»å‰é¢æˆ‘ä»¬ä¸»è¦ç€é‡äºcodecã€platformã€machineé©±åŠ¨ç¨‹åºä¸­å¦‚ä½•ä½¿ç”¨å’Œå»ºç«‹dapmæ‰€éœ€è¦çš„widgetï¼Œrouteï¼Œè¿™äº›æ˜¯éŸ³é¢‘é©±åŠ¨å¼€å‘äººå‘˜å¿…é¡»è¦äº†è§£çš„å†…å®¹ï¼Œç»è¿‡å‰å‡ ç« çš„ä»‹ç»ï¼Œæˆ‘ä»¬åº”è¯¥çŸ¥é“å¦‚ä½•åœ¨alsaéŸ³é¢‘é©±åŠ¨çš„3å¤§éƒ¨åˆ†ï¼ˆcodecã€platformã€machineï¼‰ä¸­ï¼ŒæŒ‰ç…§æ‰€ä½¿ç”¨çš„éŸ³é¢‘ç¡¬ä»¶ç»“æ„ï¼Œå®šä¹‰å‡ºç›¸åº”çš„widgetï¼Œkcontrolï¼Œä»¥åŠå¿…è¦çš„éŸ³é¢‘è·¯å¾„ï¼Œè€Œåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†ä¼šæ·±å…¥dapmçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œçœ‹çœ‹å„ä¸ªwidgetä¹‹é—´æ˜¯å¦‚ä½•å»ºç«‹è¿æ¥å…³ç³»ï¼Œå½¢æˆä¸€æ¡å®Œæ•´çš„éŸ³é¢‘è·¯å¾„ã€‚ å‰é¢æˆ‘ä»¬å·²ç»ç®€å•åœ°ä»‹ç»è¿‡ï¼Œé©±åŠ¨ç¨‹åºéœ€è¦ä½¿ç”¨ä»¥ä¸‹apiå‡½æ•°åˆ›å»ºwidgetï¼š â€¢ snd_soc_dapm_new_controls()å®é™…ä¸Šï¼Œè¿™ä¸ªå‡½æ•°åªæ˜¯åˆ›å»ºwidgetçš„ç¬¬ä¸€æ­¥ï¼Œå®ƒä¸ºæ¯ä¸ªwidgetåˆ†é…å†…å­˜ï¼Œåˆå§‹åŒ–å¿…è¦çš„å­—æ®µï¼Œç„¶åæŠŠè¿™äº›widgetæŒ‚åœ¨ä»£è¡¨å£°å¡çš„snd_soc_cardçš„widgetsé“¾è¡¨å­—æ®µä¸­ã€‚è¦ä½¿widgetä¹‹é—´å…·å¤‡è¿æ¥èƒ½åŠ›ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ç¬¬äºŒä¸ªå‡½æ•°ï¼šâ€¢ snd_soc_dapm_new_widgets()è¿™ä¸ªå‡½æ•°ä¼šæ ¹æ®widgetçš„ä¿¡æ¯ï¼Œåˆ›å»ºwidgetæ‰€éœ€è¦çš„dapm kcontrolï¼Œè¿™äº›dapm kcontolçš„çŠ¶æ€å˜åŒ–ï¼Œä»£è¡¨ç€éŸ³é¢‘è·¯å¾„çš„å˜åŒ–ï¼Œä»è€Œå½±å“ç€å„ä¸ªwidgetçš„ç”µæºçŠ¶æ€ã€‚çœ‹åˆ°å‡½æ•°çš„åç§°å¯èƒ½ä¼šè¿·æƒ‘ä¸€ä¸‹ï¼Œå®é™…ä¸Šï¼Œsnd_soc_dapm_new_controlsçš„ä½œç”¨æ›´å¤šåœ°æ˜¯åˆ›å»ºwidgetï¼Œè€Œsnd_soc_dapm_new_widgetçš„ä½œç”¨åˆ™æ›´å¤šåœ°æ˜¯åˆ›å»ºwidgetæ‰€åŒ…å«çš„kcontrolï¼Œæ‰€ä»¥åœ¨æˆ‘çœ‹æ¥ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°åç§°åº”è¯¥æ¢è¿‡æ¥å«æ›´å¥½ï¼ä¸‹é¢æˆ‘ä»¬åˆ†åˆ«ä»‹ç»ä¸€ä¸‹è¿™ä¸¤ä¸ªå‡½æ•°æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ 7.3.1ã€åˆ›å»ºwidgetsnd_soc_dapm_new_controls()å‡½æ•°å®Œæˆwidgetçš„åˆ›å»ºå·¥ä½œï¼Œå¹¶æŠŠè¿™äº›åˆ›å»ºå¥½çš„widgetæ³¨å†Œåœ¨å£°å¡çš„widgetsé“¾è¡¨ä¸­ï¼Œæˆ‘ä»¬çœ‹çœ‹ä»–çš„å®šä¹‰ï¼š 123456789101112131415161718192021222324[-&gt;/sound/soc/soc-dapm.c]int snd_soc_dapm_new_controls(struct snd_soc_dapm_context *dapm, const struct snd_soc_dapm_widget *widget, int num)&#123; struct snd_soc_dapm_widget *w; int i; int ret = 0; mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT); for (i = 0; i &lt; num; i++) &#123; w = snd_soc_dapm_new_control(dapm, widget); if (!w) &#123; dev_err(dapm-&gt;dev, \"ASoC: Failed to create DAPM control %s\\n\", widget-&gt;name); ret = -ENOMEM; break; &#125; widget++; &#125; mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex); return ret;&#125; è¯¥å‡½æ•°åªæ˜¯ç®€å•çš„ä¸€ä¸ªå¾ªç¯ï¼Œä¸ºä¼ å…¥çš„widgetæ¨¡æ¿æ•°ç»„ä¾æ¬¡è°ƒç”¨snd_soc_dapm_new_controlå‡½æ•°ï¼Œå®é™…çš„å·¥ä½œç”±snd_soc_dapm_new_controlå®Œæˆï¼Œç»§ç»­è¿›å…¥è¯¥å‡½æ•°ï¼Œçœ‹çœ‹å®ƒåšäº†é‚£äº›å·¥ä½œã€‚æˆ‘ä»¬ä¹‹å‰å·²ç»è¯´è¿‡ï¼Œé©±åŠ¨ä¸­å®šä¹‰çš„snd_soc_dapm_widgetæ•°ç»„ï¼Œåªæ˜¯ä½œä¸ºä¸€ä¸ªæ¨¡æ¿ï¼Œæ‰€ä»¥ï¼Œsnd_soc_dapm_new_controlæ‰€åšçš„ç¬¬ä¸€ä»¶äº‹ï¼Œå°±æ˜¯ä¸ºè¯¥widgeté‡æ–°åˆ†é…å†…å­˜ï¼Œå¹¶æŠŠæ¨¡æ¿çš„å†…å®¹æ‹·è´è¿‡æ¥ï¼š 1234567891011121314151617181920212223242526272829[-&gt;/sound/soc/soc-dapm.c]static struct snd_soc_dapm_widget *snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm, const struct snd_soc_dapm_widget *widget)&#123; struct snd_soc_dapm_widget *w; const char *prefix; int ret; if ((w = dapm_cnew_widget(widget)) == NULL) return NULL; //ç”±dapm_cnew_widgetå®Œæˆå†…å­˜ç”³è¯·å’Œæ‹·è´æ¨¡æ¿çš„åŠ¨ä½œã€‚æ¥ä¸‹æ¥ï¼Œæ ¹æ®widgetçš„ç±»å‹åšä¸åŒçš„å¤„ç†ï¼š switch (w-&gt;id) &#123; case snd_soc_dapm_regulator_supply: ...... &#125; prefix = soc_dapm_prefix(dapm); //å¯¹äºsnd_soc_dapm_regulator_supplyç±»å‹çš„widgetï¼Œæ ¹æ®widgetçš„åç§°è·å–å¯¹åº”çš„regulatorç»“æ„ï¼Œå¯¹äºsnd_soc_dapm_clock_supplyç±»å‹çš„widgetï¼Œæ ¹æ®widgetçš„åç§°ï¼Œè·å–å¯¹åº”çš„clockç»“æ„ã€‚æ¥ä¸‹æ¥ï¼Œæ ¹æ®éœ€è¦ï¼Œåœ¨widgetçš„åç§°å‰åŠ å…¥å¿…è¦çš„å‰ç¼€ï¼š if (prefix) &#123; w-&gt;name = kasprintf(GFP_KERNEL, \"%s %s\", prefix, widget-&gt;name); if (widget-&gt;sname) w-&gt;sname = kasprintf(GFP_KERNEL, \"%s %s\", prefix, widget-&gt;sname); &#125; else &#123; w-&gt;name = kasprintf(GFP_KERNEL, \"%s\", widget-&gt;name); if (widget-&gt;sname) w-&gt;sname = kasprintf(GFP_KERNEL, \"%s\", widget-&gt;sname); &#125; ...... å½“éŸ³é¢‘è·¯å¾„å‘ç”Ÿå˜åŒ–æ—¶ï¼Œpower_checkå›è°ƒä¼šè¢«è°ƒç”¨ï¼Œç”¨äºæ£€æŸ¥è¯¥widgetçš„ç”µæºçŠ¶æ€æ˜¯å¦éœ€è¦æ›´æ–°ã€‚power_checkè®¾ç½®å®Œæˆåï¼Œéœ€è¦è®¾ç½®widgetæ‰€å±çš„codecã€platformå’Œdapm contextï¼Œå‡ ä¸ªç”¨äºéŸ³é¢‘è·¯å¾„çš„é“¾è¡¨ä¹Ÿéœ€è¦åˆå§‹åŒ–ï¼Œç„¶åï¼ŒæŠŠè¯¥widgetåŠ å…¥åˆ°å£°å¡çš„widgetsé“¾è¡¨ä¸­ï¼š 123456789[-&gt;/sound/soc/soc-dapm.cï¼šsnd_soc_dapm_new_control()w-&gt;dapm = dapm; w-&gt;codec = dapm-&gt;codec; w-&gt;platform = dapm-&gt;platform; INIT_LIST_HEAD(&amp;w-&gt;sources); INIT_LIST_HEAD(&amp;w-&gt;sinks); INIT_LIST_HEAD(&amp;w-&gt;list); INIT_LIST_HEAD(&amp;w-&gt;dirty); list_add(&amp;w-&gt;list, &amp;dapm-&gt;card-&gt;widgets); å‡ ä¸ªé“¾è¡¨çš„ä½œç”¨å¦‚ä¸‹ï¼šsources ç”¨äºé“¾æ¥æ‰€æœ‰è¿æ¥åˆ°è¯¥widgetè¾“å…¥ç«¯çš„snd_soc_pathç»“æ„sinks ç”¨äºé“¾æ¥æ‰€æœ‰è¿æ¥åˆ°è¯¥widgetè¾“å‡ºç«¯çš„snd_soc_pathç»“æ„list ç”¨äºé“¾æ¥åˆ°å£°å¡çš„widgetsé“¾è¡¨dirty ç”¨äºé“¾æ¥åˆ°å£°å¡çš„dapm_dirtyé“¾è¡¨æœ€åï¼ŒæŠŠwidgetè®¾ç½®ä¸ºconnectçŠ¶æ€ï¼š 1234[-&gt;/sound/soc/soc-dapm.cï¼šsnd_soc_dapm_new_control()/* machine layer set ups unconnected pins and insertions */ w-&gt;connected = 1; return w; connectedå­—æ®µä»£è¡¨ç€å¼•è„šçš„è¿æ¥çŠ¶æ€ï¼Œç›®å‰ï¼Œåªæœ‰ä»¥ä¸‹è¿™äº›widgetä½¿ç”¨connectedå­—æ®µï¼šsnd_soc_dapm_outputsnd_soc_dapm_inputsnd_soc_dapm_hpsnd_soc_dapm_spksnd_soc_dapm_linesnd_soc_dapm_vmidsnd_soc_dapm_micsnd_soc_dapm_siggené©±åŠ¨ç¨‹åºå¯ä»¥ä½¿ç”¨ä»¥ä¸‹è¿™äº›apiæ¥è®¾ç½®å¼•è„šçš„è¿æ¥çŠ¶æ€ï¼šsnd_soc_dapm_enable_pinsnd_soc_dapm_force_enable_pinsnd_soc_dapm_disable_pinsnd_soc_dapm_nc_pinåˆ°æ­¤ï¼Œwidgetå·²ç»è¢«æ­£ç¡®åœ°åˆ›å»ºå¹¶åˆå§‹åŒ–ï¼Œè€Œä¸”è¢«æŒ‚åœ¨å£°å¡çš„widgetsé“¾è¡¨ä¸­ï¼Œä»¥åæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡å£°å¡çš„widgetsé“¾è¡¨æ¥éå†æ‰€æœ‰çš„widgetï¼Œå†æ¬¡å¼ºè°ƒä¸€ä¸‹snd_soc_dapm_new_controlså‡½æ•°æ‰€å®Œæˆçš„ä¸»è¦åŠŸèƒ½ï¼šä¸ºwidgetåˆ†é…å†…å­˜ï¼Œå¹¶æ‹·è´å‚æ•°ä¸­ä¼ å…¥çš„åœ¨é©±åŠ¨ä¸­å®šä¹‰å¥½çš„æ¨¡æ¿è®¾ç½®power_checkå›è°ƒå‡½æ•°æŠŠwidgetæŒ‚åœ¨å£°å¡çš„widgetsé“¾è¡¨ä¸­ 7.3.2ã€ä¸ºwidgetå»ºç«‹dapm kcontrolå®šä¹‰ä¸€ä¸ªwidgetï¼Œæˆ‘ä»¬éœ€è¦æŒ‡å®šä¸¤ä¸ªå¾ˆé‡è¦çš„å†…å®¹ï¼šä¸€ä¸ªæ˜¯ç”¨äºæ§åˆ¶widgetçš„ç”µæºçŠ¶æ€çš„reg/shiftç­‰å¯„å­˜å™¨ä¿¡æ¯ï¼Œå¦ä¸€ä¸ªæ˜¯ç”¨äºæ§åˆ¶éŸ³é¢‘è·¯å¾„åˆ‡æ¢çš„dapm kcontrolä¿¡æ¯ï¼Œè¿™äº›dapm kcontrolæœ‰å®ƒä»¬è‡ªå·±çš„reg/shiftå¯„å­˜å™¨ä¿¡æ¯ç”¨äºåˆ‡æ¢widgetçš„è·¯å¾„è¿æ¥æ–¹å¼ã€‚å‰ä¸€èŠ‚çš„å†…å®¹ä¸­ï¼Œæˆ‘ä»¬åªæ˜¯åˆ›å»ºäº†widgetçš„å®ä¾‹ï¼Œå¹¶æŠŠå®ƒä»¬æ³¨å†Œåˆ°å£°å¡çš„widgtsé“¾è¡¨ä¸­ï¼Œä½†æ˜¯åˆ°ç›®å‰ä¸ºæ­¢ï¼ŒåŒ…å«åœ¨widgetä¸­çš„dapm kcontrolå¹¶æ²¡æœ‰å»ºç«‹èµ·æ¥ï¼Œdapmæ¡†æ¶åœ¨å£°å¡çš„åˆå§‹åŒ–é˜¶æ®µï¼Œç­‰æ‰€æœ‰çš„widgetï¼ˆåŒ…æ‹¬machineã€platformã€codecï¼‰éƒ½åˆ›å»ºå¥½ä¹‹åï¼Œé€šè¿‡snd_soc_dapm_new_widgetså‡½æ•°ï¼Œåˆ›å»ºwidgetå†…åŒ…å«çš„dapm kcontrolï¼Œå¹¶åˆå§‹åŒ–widgetçš„åˆå§‹ç”µæºçŠ¶æ€å’ŒéŸ³é¢‘è·¯å¾„çš„åˆå§‹è¿æ¥çŠ¶æ€ã€‚æˆ‘ä»¬çœ‹çœ‹å£°å¡çš„åˆå§‹åŒ–å‡½æ•°ï¼Œéƒ½æœ‰é‚£äº›åˆå§‹åŒ–ä¸dapmæœ‰å…³ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041[-&gt;/sound/soc/soc-dapm.c]static int snd_soc_instantiate_card(struct snd_soc_card *card) &#123; ...... /* card bind complete so register a sound card */ ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1, card-&gt;owner, 0, &amp;card-&gt;snd_card); ...... card-&gt;dapm.bias_level = SND_SOC_BIAS_OFF; card-&gt;dapm.dev = card-&gt;dev; card-&gt;dapm.card = card; list_add(&amp;card-&gt;dapm.list, &amp;card-&gt;dapm_list); ...... if (card-&gt;dapm_widgets) /* åˆ›å»ºmachineçº§åˆ«çš„widget */ snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets, card-&gt;num_dapm_widgets); ...... snd_soc_dapm_link_dai_widgets(card); /* è¿æ¥dai widget */ if (card-&gt;controls) /* å»ºç«‹machineçº§åˆ«çš„æ™®é€škcontrolæ§ä»¶ */ snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls); if (card-&gt;dapm_routes) /* æ³¨å†Œmachineçº§åˆ«çš„è·¯å¾„è¿æ¥ä¿¡æ¯ */ snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes, card-&gt;num_dapm_routes); ...... if (card-&gt;fully_routed) /* å¦‚æœè¯¥æ ‡å¿—è¢«ç½®ä½ï¼Œè‡ªåŠ¨æŠŠcodecä¸­æ²¡æœ‰è·¯å¾„è¿æ¥ä¿¡æ¯çš„å¼•è„šè®¾ç½®ä¸ºæ— ç”¨widget */ list_for_each_entry(codec, &amp;card-&gt;codec_dev_list, card_list) snd_soc_dapm_auto_nc_codec_pins(codec); snd_soc_dapm_new_widgets(card); /*åˆå§‹åŒ–widgetåŒ…å«çš„dapm kcontrolã€ç”µæºçŠ¶æ€å’Œè¿æ¥çŠ¶æ€*/ ret = snd_card_register(card-&gt;snd_card); ...... card-&gt;instantiated = 1; snd_soc_dapm_sync(&amp;card-&gt;dapm); ...... return 0; &#125; æ­£å¦‚æˆ‘æ·»åŠ çš„æ³¨é‡Šä¸­æ‰€ç¤ºï¼Œåœ¨å®Œæˆmachineçº§åˆ«çš„widgetå’Œrouteå¤„ç†ä¹‹åï¼Œè°ƒç”¨çš„snd_soc_dapm_new_widgetså‡½æ•°ï¼Œæ¥ä¸ºæ‰€æœ‰å·²ç»æ³¨å†Œçš„widgetåˆå§‹åŒ–ä»–ä»¬æ‰€åŒ…å«çš„dapm kcontrolï¼Œå¹¶åˆå§‹åŒ–widgetçš„ç”µæºçŠ¶æ€å’Œè·¯å¾„è¿æ¥çŠ¶æ€ã€‚ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹snd_soc_dapm_new_widgetså‡½æ•°çš„å·¥ä½œè¿‡ç¨‹ã€‚ 7.3.2.1ã€snd_soc_dapm_new_widgetså‡½æ•°è¯¥å‡½æ•°é€šè¿‡å£°å¡çš„widgetsé“¾è¡¨ï¼Œéå†æ‰€æœ‰å·²ç»æ³¨å†Œäº†çš„widgetï¼Œå…¶ä¸­çš„newå­—æ®µç”¨äºåˆ¤æ–­è¯¥widgetæ˜¯å¦å·²ç»æ‰§è¡Œè¿‡snd_soc_dapm_new_widgetså‡½æ•°ï¼Œå¦‚æœnum_kcontrolså­—æ®µæœ‰æ•°å€¼ï¼Œè¡¨æ˜è¯¥widgetåŒ…å«æœ‰è‹¥å¹²ä¸ªdapm kcontrolï¼Œé‚£ä¹ˆå°±éœ€è¦ä¸ºè¿™äº›kcontrolåˆ†é…ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œå¹¶æŠŠæ•°ç»„çš„é¦–åœ°å€èµ‹å€¼ç»™widgetçš„kcontrolså­—æ®µï¼Œè¯¥æ•°ç»„å­˜æ”¾ç€æŒ‡å‘è¿™äº›kcontrolçš„æŒ‡é’ˆï¼Œå½“ç„¶ç°åœ¨è¿™äº›éƒ½æ˜¯ç©ºæŒ‡é’ˆï¼Œå› ä¸ºå®é™…çš„kcontrolç°åœ¨è¿˜æ²¡æœ‰è¢«åˆ›å»ºï¼š 1234567891011121314[-&gt;/sound/soc/soc-dapm.c]int snd_soc_dapm_new_widgets(struct snd_soc_card *card) &#123; ...... list_for_each_entry(w, &amp;card-&gt;widgets, list) &#123; if (w-&gt;new) continue; if (w-&gt;num_kcontrols) &#123; w-&gt;kcontrols = kzalloc(w-&gt;num_kcontrols * sizeof(struct snd_kcontrol *), GFP_KERNEL); ...... &#125; æ¥ç€ï¼Œå¯¹å‡ ç§èƒ½å½±å“éŸ³é¢‘è·¯å¾„çš„widgetï¼Œåˆ›å»ºå¹¶åˆå§‹åŒ–å®ƒä»¬æ‰€åŒ…å«çš„dapm kcontrolï¼š 12345678910111213141516171819[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]switch(w-&gt;id) &#123; case snd_soc_dapm_switch: case snd_soc_dapm_mixer: case snd_soc_dapm_mixer_named_ctl: dapm_new_mixer(w); break; case snd_soc_dapm_mux: case snd_soc_dapm_virt_mux: case snd_soc_dapm_value_mux: dapm_new_mux(w); break; case snd_soc_dapm_pga: case snd_soc_dapm_out_drv: dapm_new_pga(w); break; default: break; &#125; éœ€è¦ç”¨åˆ°çš„åˆ›å»ºå‡½æ•°åˆ†åˆ«æ˜¯ï¼šdapm_new_mixer() å¯¹äºmixerç±»å‹ï¼Œç”¨è¯¥å‡½æ•°åˆ›å»ºdapm kcontrolï¼›dapm_new_mux() å¯¹äºmuxç±»å‹ï¼Œç”¨è¯¥å‡½æ•°åˆ›å»ºdapm kcontrolï¼›dapm_new_pga() å¯¹äºpgaç±»å‹ï¼Œç”¨è¯¥å‡½æ•°åˆ›å»ºdapm kcontrolï¼›ç„¶åï¼Œæ ¹æ®widgetå¯„å­˜å™¨çš„å½“å‰å€¼ï¼Œåˆå§‹åŒ–widgetçš„ç”µæºçŠ¶æ€ï¼Œå¹¶è®¾ç½®åˆ°powerå­—æ®µä¸­ï¼š 12345678[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]/* Read the initial power state from the device */ if (w-&gt;reg &gt;= 0) &#123; val = soc_widget_read(w, w-&gt;reg) &gt;&gt; w-&gt;shift; val &amp;= w-&gt;mask; if (val == w-&gt;on_val) w-&gt;power = 1; &#125; æ¥ç€ï¼Œè®¾ç½®newå­—æ®µï¼Œè¡¨æ˜è¯¥widgetå·²ç»åˆå§‹åŒ–å®Œæˆï¼Œæˆ‘ä»¬è¿˜è¦å§è¯¥widgetåŠ å…¥åˆ°å£°å¡çš„dapm_dirtyé“¾è¡¨ä¸­ï¼Œè¡¨æ˜è¯¥widgetçš„çŠ¶æ€å‘ç”Ÿäº†å˜åŒ–ï¼Œç¨ååœ¨åˆé€‚çš„æ—¶åˆ»ï¼Œdapmæ¡†æ¶ä¼šæ‰«ædapm_dirtyé“¾è¡¨ï¼Œç»Ÿä¸€å¤„ç†æ‰€æœ‰å·²ç»å˜åŒ–çš„widgetã€‚ä¸ºä»€ä¹ˆè¦ç»Ÿä¸€å¤„ç†ï¼Ÿå› ä¸ºdapmè¦æ§åˆ¶å„ç§widgetçš„ä¸Šä¸‹ç”µé¡ºåºï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä¸ºäº†å‡å°‘å¯„å­˜å™¨çš„è¯»å†™æ¬¡æ•°ï¼ˆå¤šä¸ªwidgetå¯èƒ½ä½¿ç”¨åŒä¸€ä¸ªå¯„å­˜å™¨ï¼‰ï¼š 12345[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]w-&gt;new = 1; dapm_mark_dirty(w, \"new widget\"); dapm_debugfs_add_widget(w); æœ€åï¼Œé€šè¿‡dapm_power_widgetså‡½æ•°ï¼Œç»Ÿä¸€å¤„ç†æ‰€æœ‰ä½äºdapm_dirtyé“¾è¡¨ä¸Šçš„widgetçš„çŠ¶æ€æ”¹å˜ï¼š 1234[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP); ...... return 0; 7.3.2.2ã€dapm mixer kcontrolä¸Šä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬æåˆ°ï¼Œå¯¹äºmixerç±»å‹çš„dapm kcontrolï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨dapm_new_mixeræ¥å®Œæˆå…·ä½“çš„åˆ›å»ºå·¥ä½œï¼Œå…ˆçœ‹ä»£ç ååˆ†æï¼š 1234567891011121314151617181920212223242526272829[-&gt;/sound/soc/soc-dapm.c]static int dapm_new_mixer(struct snd_soc_dapm_widget *w) &#123; int i, ret; struct snd_soc_dapm_path *path; /* add kcontrol */ ï¼ˆ1ï¼‰ for (i = 0; i &lt; w-&gt;num_kcontrols; i++) &#123; /* match name */ ï¼ˆ2ï¼‰ list_for_each_entry(path, &amp;w-&gt;sources, list_sink) &#123; /* mixer/mux paths name must match control name */ ï¼ˆ3ï¼‰ if (path-&gt;name != (char *)w-&gt;kcontrol_news[i].name) continue; ï¼ˆ4ï¼‰ if (w-&gt;kcontrols[i]) &#123; dapm_kcontrol_add_path(w-&gt;kcontrols[i], path); continue; &#125; ï¼ˆ5ï¼‰ ret = dapm_create_or_share_mixmux_kcontrol(w, i); if (ret &lt; 0) return ret; ï¼ˆ6ï¼‰ dapm_kcontrol_add_path(w-&gt;kcontrols[i], path); &#125; &#125; return 0; &#125; ï¼ˆ1ï¼‰ å› ä¸ºä¸€ä¸ªmixeræ˜¯ç”±å¤šä¸ªkcontrolç»„æˆçš„ï¼Œæ¯ä¸ªkcontrolæ§åˆ¶ç€mixerçš„ä¸€ä¸ªè¾“å…¥ç«¯çš„å¼€å¯å’Œå…³é—­ï¼Œæ‰€ä»¥ï¼Œè¯¥å‡½æ•°ä¼šæ ¹æ®kcontrolçš„æ•°é‡åšå¾ªç¯ï¼Œé€ä¸ªå»ºç«‹å¯¹åº”çš„kcontrolã€‚ï¼ˆ2ï¼‰ï¼ˆ3ï¼‰ ä¹‹å‰å¤šæ¬¡æåˆ°ï¼Œwidgetä¹‹é—´ä½¿ç”¨snd_soc_pathè¿›è¡Œè¿æ¥ï¼Œwidgetçš„sourcesé“¾è¡¨ä¿å­˜ç€æ‰€æœ‰å’Œè¾“å…¥ç«¯è¿æ¥çš„snd_soc_pathç»“æ„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨kcontrolæ¨¡æ¿ä¸­æŒ‡å®šçš„åå­—æ¥åŒ¹é…å¯¹åº”çš„snd_soc_pathç»“æ„ã€‚ï¼ˆ4ï¼‰ å› ä¸ºä¸€ä¸ªè¾“å…¥è„šå¯èƒ½ä¼šè¿æ¥å¤šä¸ªè¾“å…¥æºï¼Œæ‰€ä»¥å¯èƒ½åœ¨ä¸Šä¸€ä¸ªè¾“å…¥æºçš„pathå…³è”æ—¶å·²ç»åˆ›å»ºäº†è¿™ä¸ªkcontrolï¼Œæ‰€ä»¥è¿™é‡Œåˆ¤æ–­kcontrolsæŒ‡é’ˆæ•°ç»„ä¸­å¯¹åº”ç´¢å¼•ä¸­çš„æŒ‡é’ˆå€¼ï¼Œå¦‚æœå·²ç»èµ‹å€¼ï¼Œè¯´æ˜kcontrolå·²ç»åœ¨ä¹‹å‰åˆ›å»ºå¥½äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬åªè¦ç®€å•åœ°æŠŠè¿æ¥è¯¥è¾“å…¥ç«¯çš„pathåŠ å…¥åˆ°kcontrolçš„path_listé“¾è¡¨ä¸­ï¼Œå¹¶ä¸”å¢åŠ ä¸€ä¸ªè™šæ‹Ÿçš„å½±å­widgetï¼Œè¯¥å½±å­widgetè¿æ¥å’Œè¾“å…¥ç«¯å¯¹åº”çš„æºwidgetï¼Œå› ä¸ºä½¿ç”¨äº†kcontrolæœ¬èº«çš„reg/shiftç­‰å¯„å­˜å™¨ä¿¡æ¯ï¼Œæ‰€ä»¥å®é™…ä¸Šæ§åˆ¶çš„æ˜¯è¯¥kcontrolçš„å¼€å’Œå…³ï¼Œè¿™ä¸ªå½±å­widgetåªæœ‰åœ¨kcontrolçš„autodisableå­—æ®µè¢«è®¾ç½®çš„æƒ…å†µä¸‹æ‰ä¼šè¢«åˆ›å»ºï¼Œè¯¥ç‰¹æ€§ä½¿å¾—sourceçš„å…³é—­æ—¶ï¼Œä¸ä¹‹è¿æ¥çš„mixerçš„è¾“å…¥ç«¯ä¹Ÿå¯ä»¥è‡ªåŠ¨å…³é—­ï¼Œè¿™ä¸ªç‰¹æ€§é€šè¿‡dapm_kcontrol_add_pathæ¥å®ç°è¿™ä¸€ç‚¹ï¼š 1234567891011121314[-&gt;/sound/soc/soc-dapm.c]static void dapm_kcontrol_add_path(const struct snd_kcontrol *kcontrol, struct snd_soc_dapm_path *path) &#123; struct dapm_kcontrol_data *data = snd_kcontrol_chip(kcontrol); /* æŠŠkcontrolè¿æ¥çš„pathåŠ å…¥åˆ°pathsé“¾è¡¨ä¸­ */ /* pathsé“¾è¡¨æ‰€åœ¨çš„dapm_kcontrol_dataç»“æ„ä¼šä¿å­˜åœ¨kcontrolçš„private_dataå­—æ®µä¸­ */ list_add_tail(&amp;path-&gt;list_kcontrol, &amp;data-&gt;paths); if (data-&gt;widget) &#123; snd_soc_dapm_add_path(data-&gt;widget-&gt;dapm, data-&gt;widget, path-&gt;source, NULL, NULL); &#125; &#125; ï¼ˆ5ï¼‰ å¦‚æœkcontrolä¹‹å‰æ²¡æœ‰è¢«åˆ›å»ºï¼Œåˆ™é€šè¿‡dapm_create_or_share_mixmux_kcontrolåˆ›å»ºè¿™ä¸ªè¾“å…¥ç«¯çš„kcontrolï¼ŒåŒç†ï¼Œkcontrolå¯¹åº”çš„å½±å­widgetä¹Ÿä¼šé€šè¿‡dapm_kcontrol_add_pathåˆ¤æ–­æ˜¯å¦éœ€è¦åˆ›å»ºã€‚ 7.3.2.3ã€dapm mux kcontrolå› ä¸ºä¸€ä¸ªwidgetæœ€å¤šåªä¼šåŒ…å«ä¸€ä¸ªmuxç±»å‹çš„damp kcontrolï¼Œæ‰€ä»¥ä»–çš„åˆ›å»ºæ–¹æ³•ç¨æœ‰ä¸åŒï¼Œdapmæ¡†æ¶ä½¿ç”¨dapm_new_muxå‡½æ•°æ¥åˆ›å»ºmuxç±»å‹çš„dapm kcontrolï¼š 1234567891011121314151617181920212223242526[-&gt;/sound/soc/soc-dapm.c]static int dapm_new_mux(struct snd_soc_dapm_widget *w) &#123; struct snd_soc_dapm_context *dapm = w-&gt;dapm; struct snd_soc_dapm_path *path; int ret; (1) if (w-&gt;num_kcontrols != 1) &#123; dev_err(dapm-&gt;dev, \"ASoC: mux %s has incorrect number of controls\\n\", w-&gt;name); return -EINVAL; &#125; if (list_empty(&amp;w-&gt;sources)) &#123; dev_err(dapm-&gt;dev, \"ASoC: mux %s has no paths\\n\", w-&gt;name); return -EINVAL; &#125; (2) ret = dapm_create_or_share_mixmux_kcontrol(w, 0); if (ret &lt; 0) return ret; (3) list_for_each_entry(path, &amp;w-&gt;sources, list_sink) dapm_kcontrol_add_path(w-&gt;kcontrols[0], path); return 0; &#125; ï¼ˆ1ï¼‰ å¯¹äºmuxç±»å‹çš„widgetï¼Œå› ä¸ºåªä¼šæœ‰ä¸€ä¸ªkcontrolï¼Œæ‰€ä»¥åœ¨è¿™é‡Œåšä¸€ä¸‹åˆ¤æ–­ã€‚ï¼ˆ2ï¼‰ åŒæ ·åœ°ï¼Œå’Œmixerç±»å‹ä¸€æ ·ï¼Œä¹Ÿä½¿ç”¨dapm_create_or_share_mixmux_kcontrolæ¥åˆ›å»ºè¿™ä¸ªkcontrolã€‚ï¼ˆ3ï¼‰ å¯¹æ¯ä¸ªè¾“å…¥ç«¯æ‰€è¿æ¥çš„pathéƒ½åŠ å…¥dapm_kcontrol_dataç»“æ„çš„pathsé“¾è¡¨ä¸­ï¼Œå¹¶ä¸”åˆ›å»ºä¸€ä¸ªå½±å­widgetï¼Œç”¨äºæ”¯æŒautodisableç‰¹æ€§ã€‚ 7.3.2.4ã€dapm pga kcontrolç›®å‰å¯¹äºpgaç±»å‹çš„widgetï¼Œkcontrolçš„åˆ›å»ºå‡½æ•°æ˜¯ä¸ªç©ºå‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸ç”¨å¤ªå…³æ³¨å®ƒï¼š 123456789[-&gt;/sound/soc/soc-dapm.c]static int dapm_new_pga(struct snd_soc_dapm_widget *w)&#123; if (w-&gt;num_kcontrols) dev_err(w-&gt;dapm-&gt;dev, \"ASoC: PGA controls not supported: '%s'\\n\", w-&gt;name); return 0;&#125; dapm_create_or_share_mixmux_kcontrolå‡½æ•°ä¸Šé¢æ‰€è¯´çš„mixerç±»å‹å’Œmuxç±»å‹çš„widgetï¼Œåœ¨åˆ›å»ºä»–ä»¬æ‰€åŒ…å«çš„dapm kcontrolæ—¶ï¼Œæœ€åå…¶å®éƒ½æ˜¯ä½¿ç”¨äº†dapm_create_or_share_mixmux_kcontrolå‡½æ•°æ¥å®Œæˆåˆ›å»ºå·¥ä½œçš„ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œæˆ‘ä»¬æœ‰å¿…è¦åˆ†æä¸€ä¸‹è¿™ä¸ªå‡½æ•°çš„å·¥ä½œåŸç†ã€‚è¿™ä¸ªå‡½æ•°ä¸­æœ‰å¾ˆå¤§ä¸€éƒ¨åˆ†ä»£ç å®åœ¨å¤„ç†kcontrolçš„åå­—æ˜¯å¦è¦åŠ å…¥codecçš„å‰ç¼€ï¼Œæˆ‘ä»¬ä¼šå¿½ç•¥è¿™éƒ¨åˆ†çš„ä»£ç ï¼Œæ„Ÿå…´è¶£çš„è¯»è€…å¯ä»¥è‡ªå·±æŸ¥çœ‹å†…æ ¸çš„ä»£ç ï¼Œè·¯å¾„åœ¨ï¼šsound/soc/soc-dapm.cä¸­ï¼Œç®€åŒ–åçš„ä»£ç å¦‚ä¸‹ï¼š 12345678910111213141516171819202122[-&gt;/sound/soc/soc-dapm.c]static int dapm_create_or_share_mixmux_kcontrol(struct snd_soc_dapm_widget *w, int kci) &#123; ...... (1) shared = dapm_is_shared_kcontrol(dapm, w, &amp;w-&gt;kcontrol_news[kci], &amp;kcontrol); (2) if (!kcontrol) &#123; (3) kcontrol = snd_soc_cnew(&amp;w-&gt;kcontrol_news[kci], NULL, name,prefixï¼‰; ...... kcontrol-&gt;private_free = dapm_kcontrol_free; (4) ret = dapm_kcontrol_data_alloc(w, kcontrol); ...... (5) ret = snd_ctl_add(card, kcontrol); ...... &#125; (6) ret = dapm_kcontrol_add_widget(kcontrol, w); ...... (7) w-&gt;kcontrols[kci] = kcontrol; return 0; &#125; ï¼ˆ1ï¼‰ ä¸ºäº†èŠ‚çœå†…å­˜ï¼Œé€šè¿‡kcontrolåå­—çš„åŒ¹é…æŸ¥æ‰¾ï¼Œå¦‚æœè¿™ä¸ªkcontrolå·²ç»åœ¨å…¶ä»–widgetä¸­å·²ç»åˆ›å»ºå¥½äº†ï¼Œé‚£æˆ‘ä»¬ä¸å†åˆ›å»ºï¼Œdapm_is_shared_kcontrolçš„å‚æ•°kcontrolä¼šè¿”å›å·²ç»åˆ›å»ºå¥½çš„kcontrolçš„æŒ‡é’ˆã€‚ï¼ˆ2ï¼‰ å¦‚æœkcontrolæŒ‡é’ˆè¢«èµ‹å€¼ï¼Œè¯´æ˜åœ¨ï¼ˆ1ï¼‰ä¸­æŸ¥æ‰¾åˆ°äº†å…¶ä»–widgetä¸­åŒåçš„kcontrolï¼Œæˆ‘ä»¬ä¸ç”¨å†æ¬¡åˆ›å»ºï¼Œåªè¦å…±äº«è¯¥kcontrolå³å¯ã€‚ï¼ˆ3ï¼‰ æ ‡å‡†çš„kcontrolåˆ›å»ºå‡½æ•°ï¼Œï¼ˆ4ï¼‰ å¦‚æœwidgetæ”¯æŒautodisableç‰¹æ€§ï¼Œåˆ›å»ºä¸è¯¥kcontrolæ‰€å¯¹åº”çš„å½±å­widgetï¼Œè¯¥å½±å­widgetçš„ç±»å‹æ˜¯ï¼šsnd_soc_dapm_kcontrolã€‚ï¼ˆ5ï¼‰ æ ‡å‡†çš„kcontrolåˆ›å»ºå‡½æ•°ï¼Œï¼ˆ6ï¼‰ æŠŠæ‰€æœ‰å…±äº«è¯¥kcontrolçš„å½±å­widgetï¼ˆsnd_soc_dapm_kcontrolï¼‰ï¼ŒåŠ å…¥åˆ°kcontrolçš„private_dataå­—æ®µæ‰€æŒ‡å‘çš„dapm_kcontrol_dataç»“æ„ä¸­ã€‚ï¼ˆ7ï¼‰ æŠŠåˆ›å»ºå¥½çš„kcontrolæŒ‡é’ˆèµ‹å€¼åˆ°widgetçš„kcontrolsæ•°ç»„ä¸­ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœkcontolæ”¯æŒautodisableç‰¹æ€§ï¼Œä¸€æ—¦kcontrolç”±äºsourceçš„å…³é—­è€Œè¢«è‡ªåŠ¨å…³é—­ï¼Œåˆ™ç”¨æˆ·ç©ºé—´åªèƒ½æ“ä½œè¯¥kcontrolçš„cacheå€¼ï¼Œåªæœ‰è¯¥kcontrolå†æ¬¡æ‰“å¼€æ—¶ï¼Œè¯¥cacheå€¼æ‰ä¼šè¢«çœŸæ­£åœ°æ›´æ–°åˆ°å¯„å­˜å™¨ä¸­ã€‚ç°åœ¨ã€‚æˆ‘ä»¬æ€»ç»“ä¸€ä¸‹ï¼Œåˆ›å»ºä¸€ä¸ªwidgetæ‰€åŒ…å«çš„kcontrolæ‰€åšçš„å·¥ä½œï¼šâ€¢ å¾ªç¯æ¯ä¸€ä¸ªè¾“å…¥ç«¯ï¼Œä¸ºæ¯ä¸ªè¾“å…¥ç«¯ä¾æ¬¡æ‰§è¡Œä¸‹é¢çš„ä¸€ç³»åˆ—æ“ä½œâ€¢ ä¸ºæ¯ä¸ªè¾“å…¥ç«¯åˆ›å»ºä¸€ä¸ªkcontrolï¼Œèƒ½å…±äº«çš„åˆ™ç›´æ¥ä½¿ç”¨åˆ›å»ºå¥½çš„kcontrolâ€¢ kcontrolçš„private_dataå­—æ®µä¿å­˜ç€è¿™äº›å…±äº«widgetçš„ä¿¡æ¯â€¢ å¦‚æœæ”¯æŒautodisableç‰¹æ€§ï¼Œæ¯ä¸ªè¾“å…¥ç«¯è¿˜è¦é¢å¤–åœ°åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿçš„snd_soc_dapm_kcontrolç±»å‹çš„å½±å­widgetï¼Œè¯¥å½±å­widgetä¹Ÿè®°å½•åœ¨private_dataå­—æ®µä¸­â€¢ åˆ›å»ºå¥½çš„kcontrolä¼šä¾æ¬¡å­˜æ”¾åœ¨widgetçš„kcontrolsæ•°ç»„ä¸­ï¼Œä¾›è·¯å¾„çš„æ§åˆ¶å’ŒåŒ¹é…ä¹‹ç”¨ã€‚ 7.3.2.5ã€ä¸ºwidgetå»ºç«‹è¿æ¥å…³ç³»å¦‚æœwidgetä¹‹é—´æ²¡æœ‰è¿æ¥å…³ç³»ï¼Œdapmå°±æ— æ³•å®ç°åŠ¨æ€çš„ç”µæºç®¡ç†å·¥ä½œï¼Œæ­£æ˜¯widgetä¹‹é—´æœ‰äº†è¿ç»“å…³ç³»ï¼Œè¿™äº›è¿æ¥å…³ç³»å½¢æˆäº†ä¸€æ¡æ‰€è°“çš„å®Œæˆçš„éŸ³é¢‘è·¯å¾„ï¼Œdapmå¯ä»¥é¡ºç€è¿™æ¡è·¯å¾„ï¼Œç»Ÿä¸€æ§åˆ¶è·¯å¾„ä¸Šæ‰€æœ‰widgetçš„ç”µæºçŠ¶æ€ï¼Œå‰é¢æˆ‘ä»¬å·²ç»çŸ¥é“ï¼Œwidgetä¹‹é—´æ˜¯ä½¿ç”¨snd_soc_pathç»“æ„è¿›è¡Œè¿æ¥çš„ï¼Œé©±åŠ¨è¦åšçš„æ˜¯å®šä¹‰ä¸€ä¸ªsnd_soc_routeç»“æ„æ•°ç»„ï¼Œè¯¥æ•°ç»„çš„æ¯ä¸ªæ¡ç›®æè¿°äº†ç›®çš„widgetçš„å’Œæºwidgetçš„åç§°ï¼Œä»¥åŠæ§åˆ¶è¿™ä¸ªè¿æ¥çš„kcontrolçš„åç§°ï¼Œæœ€ç»ˆï¼Œé©±åŠ¨ç¨‹åºä½¿ç”¨apiå‡½æ•°snd_soc_dapm_add_routesæ¥æ³¨å†Œè¿™äº›è¿æ¥ä¿¡æ¯ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±æ˜¯è¦åˆ†æè¯¥å‡½æ•°çš„å…·ä½“å®ç°æ–¹å¼ï¼š 12345678910111213141516[-&gt;/sound/soc/soc-dapm.c]int snd_soc_dapm_add_routes(struct snd_soc_dapm_context *dapm, const struct snd_soc_dapm_route *route, int num) &#123; int i, r, ret = 0; mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT); for (i = 0; i &lt; num; i++) &#123; r = snd_soc_dapm_add_route(dapm, route); ...... route++; &#125; mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex); return ret; &#125; è¯¥å‡½æ•°åªæ˜¯ä¸€ä¸ªå¾ªç¯ï¼Œä¾æ¬¡å¯¹å‚æ•°ä¼ å…¥çš„æ•°ç»„è°ƒç”¨snd_soc_dapm_add_routeï¼Œä¸»è¦çš„å·¥ä½œç”±snd_soc_dapm_add_routeå®Œæˆã€‚æˆ‘ä»¬è¿›å…¥snd_soc_dapm_add_routeå‡½æ•°çœ‹çœ‹ï¼š 12345678910111213141516171819202122[-&gt;/sound/soc/soc-dapm.c]static int snd_soc_dapm_add_route(struct snd_soc_dapm_context *dapm, const struct snd_soc_dapm_route *route) &#123; struct snd_soc_dapm_widget *wsource = NULL, *wsink = NULL, *w; struct snd_soc_dapm_widget *wtsource = NULL, *wtsink = NULL; const char *sink; const char *source; ...... list_for_each_entry(w, &amp;dapm-&gt;card-&gt;widgets, list) &#123; if (!wsink &amp;&amp; !(strcmp(w-&gt;name, sink))) &#123; wtsink = w; if (w-&gt;dapm == dapm) wsink = w; continue; &#125; if (!wsource &amp;&amp; !(strcmp(w-&gt;name, source))) &#123; wtsource = w; if (w-&gt;dapm == dapm) wsource = w; &#125; &#125; ä¸Šé¢çš„ä»£ç æˆ‘å†æ¬¡çœç•¥äº†å…³äºåç§°å‰ç¼€çš„å¤„ç†éƒ¨åˆ†ã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œç”¨widgetçš„åå­—æ¥æ¯”è¾ƒï¼Œéå†å£°å¡çš„widgetsé“¾è¡¨ï¼Œæ‰¾å‡ºæºwidgetå’Œç›®çš„widgetçš„æŒ‡é’ˆï¼Œè¿™æ®µä»£ç è™½ç„¶æ­£ç¡®ï¼Œä½†æˆ‘æ€»æ„Ÿè§‰å°‘äº†ä¸€ä¸ªåˆ¤æ–­é€€å‡ºå¾ªç¯çš„æ¡ä»¶ï¼Œå¦‚æœé“¾è¡¨çš„å¼€å¤´å°±æ‰¾åˆ°äº†ä¸¤ä¸ªwidgetï¼Œè¿˜æ˜¯è¦éå†æ•´ä¸ªé“¾è¡¨æ‰ç»“æŸå¾ªç¯ï¼Œå¥½æµªè´¹æ—¶é—´ã€‚ä¸‹é¢ï¼Œå¦‚æœåœ¨æœ¬dapm contextä¸­æ²¡æœ‰æ‰¾åˆ°ï¼Œåˆ™ä½¿ç”¨åˆ«çš„dapm contextä¸­æ‰¾åˆ°çš„widgetï¼š 12345[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]if (!wsink) wsink = wtsink; if (!wsource) wsource = wtsource; æœ€åï¼Œä½¿ç”¨æ¥å¢åŠ ä¸€æ¡è¿æ¥ä¿¡æ¯ï¼š 1234567[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()] ret = snd_soc_dapm_add_path(dapm, wsource, wsink, route-&gt;control, route-&gt;connected); ...... return 0; &#125; snd_soc_dapm_add_pathå‡½æ•°æ˜¯æ•´ä¸ªè°ƒç”¨é“¾æ¡ä¸­çš„å…³é”®ï¼Œæˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹ï¼š 123456789101112131415161718192021[-&gt;/sound/soc/soc-dapm.c]static int snd_soc_dapm_add_path(struct snd_soc_dapm_context *dapm, struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink, const char *control, int (*connected)(struct snd_soc_dapm_widget *source, struct snd_soc_dapm_widget *sink)) &#123; struct snd_soc_dapm_path *path; int ret; path = kzalloc(sizeof(struct snd_soc_dapm_path), GFP_KERNEL); if (!path) return -ENOMEM; path-&gt;source = wsource; path-&gt;sink = wsink; path-&gt;connected = connected; INIT_LIST_HEAD(&amp;path-&gt;list); INIT_LIST_HEAD(&amp;path-&gt;list_kcontrol); INIT_LIST_HEAD(&amp;path-&gt;list_source); INIT_LIST_HEAD(&amp;path-&gt;list_sink); å‡½æ•°çš„ä¸€å¼€å§‹ï¼Œé¦–å…ˆä¸ºè¿™ä¸ªè¿æ¥åˆ†é…äº†ä¸€ä¸ªsnd_soc_pathç»“æ„ï¼Œpathçš„sourceå’Œsinkå­—æ®µåˆ†åˆ«æŒ‡å‘æºwidgetå’Œç›®çš„widgetï¼Œconnectedå­—æ®µä¿å­˜connectedå›è°ƒå‡½æ•°ï¼Œåˆå§‹åŒ–å‡ ä¸ªsnd_soc_pathç»“æ„ä¸­çš„å‡ ä¸ªé“¾è¡¨ã€‚ 12345678910111213141516[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]/* check for external widgets */ if (wsink-&gt;id == snd_soc_dapm_input) &#123; if (wsource-&gt;id == snd_soc_dapm_micbias || wsource-&gt;id == snd_soc_dapm_mic || wsource-&gt;id == snd_soc_dapm_line || wsource-&gt;id == snd_soc_dapm_output) wsink-&gt;ext = 1; &#125; if (wsource-&gt;id == snd_soc_dapm_output) &#123; if (wsink-&gt;id == snd_soc_dapm_spk || wsink-&gt;id == snd_soc_dapm_hp || wsink-&gt;id == snd_soc_dapm_line || wsink-&gt;id == snd_soc_dapm_input) wsource-&gt;ext = 1; &#125; è¿™æ®µä»£ç ç”¨äºåˆ¤æ–­æ˜¯å¦æœ‰å¤–éƒ¨è¿æ¥å…³ç³»ï¼Œå¦‚æœæœ‰ï¼Œç½®ä½widgetçš„extå­—æ®µã€‚åˆ¤æ–­æ–¹æ³•ä»ä»£ç ä¸­å¯ä»¥æ–¹ä¾¿åœ°çœ‹å‡ºï¼šç›®çš„widgetæ˜¯ä¸€ä¸ªè¾“å…¥è„šï¼Œå¦‚æœæºwidgetæ˜¯micã€lineã€micbiasæˆ–outputï¼Œåˆ™è®¤ä¸ºç›®çš„widgetå…·æœ‰å¤–éƒ¨è¿æ¥å…³ç³»ã€‚æºwidgetæ˜¯ä¸€ä¸ªè¾“å‡ºè„šï¼Œå¦‚æœç›®çš„widgetæ˜¯spkã€hpã€lineæˆ–inputï¼Œåˆ™è®¤ä¸ºæºwidgetå…·æœ‰å¤–éƒ¨è¿æ¥å…³ç³»ã€‚ 123456789101112[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]dapm_mark_dirty(wsource, \"Route added\"); dapm_mark_dirty(wsink, \"Route added\"); /* connect static paths */ if (control == NULL) &#123; list_add(&amp;path-&gt;list, &amp;dapm-&gt;card-&gt;paths); list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources); list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks); path-&gt;connect = 1; return 0; &#125; å› ä¸ºå¢åŠ äº†è¿ç»“å…³ç³»ï¼Œæ‰€ä»¥æŠŠæºwidgetå’Œç›®çš„widgetåŠ å…¥åˆ°dapm_dirtyé“¾è¡¨ä¸­ã€‚å¦‚æœæ²¡æœ‰kcontrolæ¥æ§åˆ¶è¯¥è¿æ¥å…³ç³»ï¼Œåˆ™è¿™æ˜¯ä¸€ä¸ªé™æ€è¿æ¥ï¼Œç›´æ¥ç”¨pathæŠŠå®ƒä»¬è¿æ¥åœ¨ä¸€èµ·ã€‚åœ¨æ¥ç€å¾€ä¸‹çœ‹ï¼š 12345678910111213141516171819202122232425262728[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]/* connect dynamic paths */ switch (wsink-&gt;id) &#123; case snd_soc_dapm_adc: case snd_soc_dapm_dac: case snd_soc_dapm_pga: case snd_soc_dapm_out_drv: case snd_soc_dapm_input: case snd_soc_dapm_output: case snd_soc_dapm_siggen: case snd_soc_dapm_micbias: case snd_soc_dapm_vmid: case snd_soc_dapm_pre: case snd_soc_dapm_post: case snd_soc_dapm_supply: case snd_soc_dapm_regulator_supply: case snd_soc_dapm_clock_supply: case snd_soc_dapm_aif_in: case snd_soc_dapm_aif_out: case snd_soc_dapm_dai_in: case snd_soc_dapm_dai_out: case snd_soc_dapm_dai_link: case snd_soc_dapm_kcontrol: list_add(&amp;path-&gt;list, &amp;dapm-&gt;card-&gt;paths); list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources); list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks); path-&gt;connect = 1; return 0; æŒ‰ç…§ç›®çš„widgetæ¥åˆ¤æ–­ï¼Œå¦‚æœå±äºä»¥ä¸Šè¿™äº›ç±»å‹ï¼Œç›´æ¥æŠŠå®ƒä»¬è¿æ¥åœ¨ä¸€èµ·å³å¯ï¼Œè¿™æ®µæ„Ÿè§‰æœ‰ç‚¹å¤šä½™ï¼Œå› ä¸ºé€šå¸¸ä»¥ä¸Šè¿™äº›ç±»å‹çš„widgetæœ¬æ¥ä¹Ÿæ²¡æœ‰kcontrolï¼Œç›´æ¥ç”¨ä¸Šä¸€æ®µä»£ç å°±å¯ä»¥äº†ï¼Œä¹Ÿè®¸æ˜¯dapmçš„ä½œè€…ä»¬æƒ³ç€ä»¥åå¯èƒ½ä¼šæœ‰æ‰€æ‰©å±•å§ã€‚ 12345678910111213141516[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]case snd_soc_dapm_mux: case snd_soc_dapm_virt_mux: case snd_soc_dapm_value_mux: ret = dapm_connect_mux(dapm, wsource, wsink, path, control, &amp;wsink-&gt;kcontrol_news[0]); if (ret != 0) goto err; break; case snd_soc_dapm_switch: case snd_soc_dapm_mixer: case snd_soc_dapm_mixer_named_ctl: ret = dapm_connect_mixer(dapm, wsource, wsink, path, control); if (ret != 0) goto err; break; ç›®çš„widgetå¦‚æœæ˜¯mixerå’Œmuxç±»å‹ï¼Œåˆ†åˆ«ç”¨dapm_connect_mixerå’Œdapm_connect_muxå‡½æ•°å®Œæˆè¿æ¥å·¥ä½œï¼Œè¿™ä¸¤ä¸ªå‡½æ•°æˆ‘ä»¬åé¢å†è®²ã€‚ 1234567891011121314151617[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()] case snd_soc_dapm_hp: case snd_soc_dapm_mic: case snd_soc_dapm_line: case snd_soc_dapm_spk: list_add(&amp;path-&gt;list, &amp;dapm-&gt;card-&gt;paths); list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources); list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks); path-&gt;connect = 0; return 0; &#125; return 0; err: kfree(path); return ret; &#125; hpã€micã€lineå’Œspkè¿™å‡ ç§widgetå±äºå¤–éƒ¨å™¨ä»¶ï¼Œä¹Ÿåªæ˜¯ç®€å•åœ°è¿æ¥åœ¨ä¸€èµ·ï¼Œä¸è¿‡connectå­—æ®µé»˜è®¤ä¸ºæ˜¯æœªè¿æ¥çŠ¶æ€ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å›è¿‡å¤´æ¥çœ‹çœ‹ç›®çš„widgetæ˜¯mixerå’Œmuxè¿™ä¸¤ç§ç±»å‹æ—¶çš„è¿æ¥æ–¹å¼ï¼šdapm_connect_mixer ç”¨è¯¥å‡½æ•°è¿æ¥ä¸€ä¸ªç›®çš„widgetä¸ºmixerç±»å‹çš„æ‰€æœ‰è¾“å…¥ç«¯ï¼š 1234567891011121314151617181920[-&gt;/sound/soc/soc-dapm.c]static int dapm_connect_mixer(struct snd_soc_dapm_context *dapm, struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest, struct snd_soc_dapm_path *path, const char *control_name) &#123; int i; /* search for mixer kcontrol */ for (i = 0; i &lt; dest-&gt;num_kcontrols; i++) &#123; if (!strcmp(control_name, dest-&gt;kcontrol_news[i].name)) &#123; list_add(&amp;path-&gt;list, &amp;dapm-&gt;card-&gt;paths); list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources); list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks); path-&gt;name = dest-&gt;kcontrol_news[i].name; dapm_set_path_status(dest, path, i); return 0; &#125; &#125; return -ENODEV; &#125; ç”¨éœ€è¦ç”¨æ¥è¿æ¥çš„kcontrolçš„åå­—ï¼Œå’Œç›®çš„widgetä¸­çš„kcontrolæ¨¡æ¿æ•°ç»„ä¸­çš„åå­—ç›¸æ¯”è¾ƒï¼Œæ‰¾å‡ºè¯¥kcontrolåœ¨widgetä¸­çš„ç¼–å·ï¼Œpathçš„åå­—è®¾ç½®ä¸ºè¯¥kcontrolçš„åå­—ï¼Œç„¶åç”¨dapm_set_path_statuså‡½æ•°æ¥åˆå§‹åŒ–è¯¥è¾“å…¥ç«¯çš„è¿æ¥çŠ¶æ€ã€‚è¿æ¥ä¸¤ä¸ªwidgetçš„é“¾è¡¨æ“ä½œå’Œå…¶ä»–widgetæ˜¯ä¸€æ ·çš„ã€‚ dapm_connect_mux ç”¨è¯¥å‡½æ•°è¿æ¥ä¸€ä¸ªç›®çš„widgetæ˜¯muxç±»å‹çš„æ‰€æœ‰è¾“å…¥ç«¯ï¼š 12345678910111213141516171819202122[-&gt;/sound/soc/soc-dapm.c]static int dapm_connect_mux(struct snd_soc_dapm_context *dapm, struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest, struct snd_soc_dapm_path *path, const char *control_name, const struct snd_kcontrol_new *kcontrol) &#123; struct soc_enum *e = (struct soc_enum *)kcontrol-&gt;private_value; int i; for (i = 0; i &lt; e-&gt;max; i++) &#123; if (!(strcmp(control_name, e-&gt;texts[i]))) &#123; list_add(&amp;path-&gt;list, &amp;dapm-&gt;card-&gt;paths); list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources); list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks); path-&gt;name = (char*)e-&gt;texts[i]; dapm_set_path_status(dest, path, 0); return 0; &#125; &#125; return -ENODEV; &#125; å’Œmixerç±»å‹ä¸€æ ·ç”¨åå­—è¿›è¡ŒåŒ¹é…ï¼Œåªä¸è¿‡muxç±»å‹çš„kcontrolåªéœ€ä¸€ä¸ªï¼Œæ‰€ä»¥è¦é€šè¿‡private_valueå­—æ®µæ‰€æŒ‡å‘çš„soc_enumç»“æ„æ‰¾å‡ºåŒ¹é…çš„è¾“å…¥è„šç¼–å·ï¼Œæœ€åä¹Ÿæ˜¯é€šè¿‡dapm_set_path_statuså‡½æ•°æ¥åˆå§‹åŒ–è¯¥è¾“å…¥ç«¯çš„è¿æ¥çŠ¶æ€ï¼Œå› ä¸ºåªæœ‰ä¸€ä¸ªkcontrolï¼Œæ‰€ä»¥ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯0ã€‚è¿æ¥ä¸¤ä¸ªwidgetçš„é“¾è¡¨æ“ä½œå’Œå…¶ä»–widgetä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚dapm_set_path_status è¯¥å‡½æ•°æ ¹æ®ä¼ å…¥widgetä¸­çš„kcontrolç¼–å·ï¼Œè¯»å–å®é™…å¯„å­˜å™¨çš„å€¼ï¼Œæ ¹æ®å¯„å­˜å™¨çš„å€¼æ¥åˆå§‹åŒ–è¿™ä¸ªpathæ˜¯å¦å¤„äºè¿æ¥çŠ¶æ€ï¼Œè¯¦ç»†çš„ä»£ç è¿™é‡Œå°±ä¸è´´äº†ã€‚å½“widgetä¹‹é—´é€šè¿‡pathè¿›è¡Œè¿æ¥ä¹‹åï¼Œä»–ä»¬ä¹‹é—´çš„å…³ç³»å°±å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åˆ°è¿™é‡Œä¸ºæ­¢ï¼Œæˆ‘ä»¬ä¸ºå£°å¡åˆ›å»ºå¹¶åˆå§‹åŒ–å¥½äº†æ‰€éœ€çš„widgetï¼Œå„ä¸ªwidgetä¹Ÿé€šè¿‡pathè¿æ¥åœ¨äº†ä¸€èµ·ï¼Œæ¥ä¸‹æ¥ï¼Œdapmç­‰å¾…ç”¨æˆ·çš„æŒ‡ä»¤ï¼Œä¸€æ—¦æŸä¸ªdapm kcontrolè¢«ç”¨æˆ·ç©ºé—´æ”¹å˜ï¼Œåˆ©ç”¨è¿™äº›è¿æ¥å…³ç³»ï¼Œdapmä¼šé‡æ–°åˆ›å»ºéŸ³é¢‘è·¯å¾„ï¼Œè„±ç¦»éŸ³é¢‘è·¯å¾„çš„widgetä¼šè¢«ä¸‹ç”µï¼ŒåŠ å…¥éŸ³é¢‘è·¯å¾„çš„widgetä¼šè¢«ä¸Šç”µï¼Œæ‰€æœ‰çš„ä¸Šä¸‹ç”µåŠ¨ä½œéƒ½ä¼šè‡ªåŠ¨å®Œæˆï¼Œç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºæ— éœ€å…³æ³¨è¿™äº›å˜åŒ–ï¼Œå®ƒåªç®¡æŒ‰éœ€è¦æ”¹å˜æŸä¸ªdapm kcontrolå³å¯ã€‚ ï¼ˆå…«ï¼‰ã€tinyplay playbackã€capture8.1ã€tinyplay playback æœ‰æ—¶åºå›¾å¯çŸ¥ï¼šä¸»è¦æ¶‰åŠpcm_open()ã€pcm_write()ã€pcm_prepare()ã€pcm_start()ã€‚ 8.1.1ã€ä½¿ç”¨è€³æœºæ’­æ”¾ å¯åŠ¨éŸ³é¢‘æ’­æ”¾ å¯ç”¨ Rx codec è·¯å¾„tinymix â€˜RX1 MIX1 INP1â€™ â€˜RX1â€™tinymix â€˜RX2 MIX1 INP1â€™ â€˜RX2â€™tinymix â€˜RDAC2 MUXâ€™ â€˜RX2â€™tinymix â€˜HPHLâ€™ â€˜Switchâ€™tinymix â€˜HPHRâ€™ â€˜Switchâ€™tinymix â€˜MI2S_RX Channelsâ€™ â€˜Two å¯ç”¨ç”¨äºé€šè¿‡ MI2S æ¥å£è¿›è¡Œæ’­æ”¾çš„ DSP AFEtinymix â€˜PRI_MI2S_RX Audio Mixer MultiMedia1â€™ 1 æ’­æ”¾ PCM éŸ³é¢‘tinyplay åœæ­¢éŸ³é¢‘æ’­æ”¾ ç¦ç”¨æ¥æ”¶ Rx codec è·¯å¾„tinymix â€˜RX1 MIX1 INP1â€™ â€˜ZEROâ€™tinymix â€˜RX2 MIX1 INP1â€™ â€˜ZEROâ€™tinymix â€˜RDAC2 MUXâ€™ â€˜ZEROâ€™tinymix â€˜HPHLâ€™ â€˜ZEROâ€™tinymix â€˜HPHRâ€™ â€˜ZEROâ€™tinymix â€˜MI2S_RX Channelsâ€™ â€˜Oneâ€™ ç¦ç”¨ç”¨äºé€šè¿‡ I2S æ¥å£è¿›è¡ŒéŸ³é¢‘æ’­æ”¾çš„ DSP AFEtinymix â€˜PRI_MI2S_RX Audio Mixer MultiMedia1â€™ 0 8.2ã€tinyplay capture æœ‰æ—¶åºå›¾å¯çŸ¥ï¼šä¸»è¦æ¶‰åŠpcm_open()ã€pcm_read()ã€pcm_start()ã€‚ 8.2.1ã€ä½¿ç”¨éŸ³é¢‘å½•åˆ¶ è¾“å…¥ä»¥ä¸‹å‘½ä»¤ï¼š//Enable DSP AFE for Audio Recording over I2Stinymix â€˜MultiMedia1 Mixer TERT_MI2S_TXâ€™ 1//Enable Codec TX Pathtinymix â€˜DEC1 MUXâ€™ â€˜ADC2â€™tinymix â€˜ADC2 MUXâ€™ â€˜INP2â€™ å¯åŠ¨å½•éŸ³åŠŸèƒ½ï¼štinycap /data/rec.wav ç¦ç”¨ HeadsetX è®¾å¤‡ (AMIC2)ï¼štinymix â€˜MultiMedia1 Mixer TERT_MI2S_TXâ€™ 0tinymix â€˜DEC1 MUXâ€™ â€˜ZEROâ€™tinymix â€˜ADC2 MUXâ€™ â€˜ZEROâ€™ ï¼ˆä¹ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroidéŸ³é¢‘æ¨¡å—å¯åŠ¨æµç¨‹åˆ†æJhusterçš„ä¸“æ â€‹ AndroidéŸ³é¢‘å¼€å‘é«˜é€šaudio offloadå­¦ä¹  | ThinkingDroidPhoneçš„ä¸“æ  - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„1-CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„2-ASoc - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„3-Pcm - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„4-å£°å¡æ§åˆ¶ - CSDNåšå®¢Linux ALSA éŸ³é¢‘ç³»ç»Ÿï¼šé€»è¾‘è®¾å¤‡ç¯‡ - CSDNåšå®¢Linux ALSA éŸ³é¢‘ç³»ç»Ÿï¼šç‰©ç†é“¾è·¯ç¯‡ - CSDNåšå®¢ä¸“æ ï¼šMultiMediaæ¡†æ¶æ€»ç»“(åŸºäº6.0æºç ) - CSDNåšå®¢Android éŸ³é¢‘ç³»ç»Ÿï¼šä» AudioTrack åˆ° AudioFlinger - CSDNåšå®¢AZURE - CSDNåšå®¢ - ALSA-Android AudioAZURE - CSDNåšå®¢ - ANDROIDéŸ³é¢‘ç³»ç»ŸAudioé©±åŠ¨æ€»ç»“â€“ALSA | Winddoingâ€™s Blogaudio HAL - ç‰§ å¤© - åšå®¢å›­æ—å­¦æ£®çš„Androidä¸“æ  - CSDNåšå®¢æ·±å…¥å‰–æAndroidéŸ³é¢‘ - CSDNåšå®¢Yangwen123æ’­æ”¾æ¡†æ¶ - æ ‡ç­¾ - Tocy - åšå®¢å›­Android-7.0-Nuplayeræ¦‚è¿° - CSDNåšå®¢Android-7.0-Nuplayer-å¯åŠ¨æµç¨‹ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-Nuplayerï¼ˆ1ï¼‰ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-AHandler AMessage ALooper - CSDNåšå®¢Android N Audioæ’­æ”¾ startçœŸé¢ç›®- (å…­ç¯‡) CSDNåšå®¢æ·±å…¥ç†è§£AndroidéŸ³è§†é¢‘åŒæ­¥æœºåˆ¶ï¼ˆäº”ç¯‡ï¼‰NuPlayerçš„avsyncé€»è¾‘ - CSDNåšå®¢wangyfçš„ä¸“æ  - CSDNåšå®¢-MT6737 Android N å¹³å° Audioç³»ç»Ÿå­¦ä¹ Android 7.0 Audio: Mediaplayer - CSDNåšå®¢Android 7.0 Audio-ç›¸å…³ç±»æµ…æ- CSDNåšå®¢Android N Audioæ’­æ”¾å…­ï¼šå¦‚ä½•è¯»å–buffer - CSDNåšå®¢Fuchsia OSä¸­çš„RPCæœºåˆ¶-FIDL - CSDNåšå®¢é«˜é€šAudioä¸­ASOCçš„codecé©±åŠ¨ - yooooooo - åšå®¢å›­","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Audio Systemï¼ˆ1ï¼‰ï¼šLinux && Android Audio ç³»ç»Ÿæ¡†æ¶åˆ†æ","slug":"Audio Systemï¼ˆ1ï¼‰ï¼šLinux && Android Audio ç³»ç»Ÿæ¡†æ¶åˆ†æ","date":"2018-04-30T16:00:00.000Z","updated":"2018-05-09T15:03:51.779Z","comments":true,"path":"2018/05/01/Audio Systemï¼ˆ1ï¼‰ï¼šLinux && Android Audio ç³»ç»Ÿæ¡†æ¶åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/05/01/Audio Systemï¼ˆ1ï¼‰ï¼šLinux && Android Audio ç³»ç»Ÿæ¡†æ¶åˆ†æ/","excerpt":"","text":"æ³¨ï¼šæ–‡ç« éƒ½æ˜¯é€šè¿‡é˜…è¯»å„ä½å‰è¾ˆæ€»ç»“çš„èµ„æ–™ã€Android 7.1.2 &amp;&amp; Linuxï¼ˆkernel 3.18ï¼‰Qualcommå¹³å°æºç ã€åŠ ä¸Šè‡ªå·±çš„æ€è€ƒåˆ†ææ€»ç»“å‡ºæ¥çš„ï¼Œå…¶ä¸­éš¾å…æœ‰ç†è§£ä¸å¯¹çš„åœ°æ–¹ï¼Œæ¬¢è¿å¤§å®¶æ‰¹è¯„æŒ‡æ­£ã€‚æ–‡ç« ä¸ºä¸ªäººå­¦ä¹ ã€ç ”ç©¶ã€æ¬£èµä¹‹ç”¨ï¼Œå›¾æ–‡å†…å®¹æ•´ç†è‡ªäº’è”ç½‘ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»åˆ é™¤ï¼Œç¦æ­¢è½¬è½½ï¼ˆÂ©Qualcomm Technologies, Inc. ç‰ˆæƒæ‰€æœ‰ï¼‰ï¼Œè°¢è°¢ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆKernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - GitHub AOSP æºç ï¼ˆAndroid 7.1.2ï¼‰ï¼š Android ç³»ç»Ÿå…¨å¥—æºä»£ç åˆ†äº« (æ›´æ–°åˆ° 8.1.0_r1) ï¼ˆä¸€ï¼‰ã€éŸ³é¢‘åŸºç¡€çŸ¥è¯†ç†è§£éŸ³é¢‘çš„ä¸€äº›åŸºç¡€çŸ¥è¯†ï¼Œå¯¹äºæˆ‘ä»¬åˆ†ææ•´ä¸ªéŸ³é¢‘ç³»ç»Ÿæ˜¯å¤§æœ‰è£¨ç›Šçš„ã€‚å®ƒå¯ä»¥è®©æˆ‘ä»¬ä»å®ç°çš„å±‚é¢å»æ€è€ƒï¼ŒéŸ³é¢‘ç³»ç»Ÿçš„ç›®çš„æ˜¯ä»€ä¹ˆï¼Œç„¶åæ‰æ˜¯æ€ä¹ˆæ ·å»å®Œæˆè¿™ä¸ªç›®çš„ #####ï¼ˆ1ï¼‰å£°éŸ³æœ‰å“ªäº›é‡è¦å±æ€§å‘¢ï¼Ÿ 1.1ã€å“åº¦(Loudness)å“åº¦å°±æ˜¯äººç±»å¯ä»¥æ„ŸçŸ¥åˆ°çš„å„ç§å£°éŸ³çš„å¤§å°ï¼Œä¹Ÿå°±æ˜¯éŸ³ï¥¾ã€‚å“åº¦ä¸å£°æ³¢çš„æŒ¯å¹…æœ‰ç›´æ¥å…³ç³»ã€‚ 1.2ã€éŸ³è°ƒ(Pitch)éŸ³è°ƒä¸å£°éŸ³çš„é¢‘ç‡æœ‰å…³ç³»ï¼Œå½“å£°éŸ³çš„é¢‘ç‡è¶Šå¤§æ—¶ï¼Œäººè€³æ‰€æ„ŸçŸ¥åˆ°çš„éŸ³è°ƒå°±è¶Šé«˜ï¼Œå¦åˆ™å°±è¶Šä½ã€‚ 1.3ã€éŸ³è‰²(Quality)åŒä¸€ç§ä¹å™¨ï¼Œä½¿ç”¨ï¥§åŒçš„æè´¨æ¥åˆ¶ä½œï¼Œæ‰€è¡¨ç°å‡ºæ¥çš„éŸ³è‰²æ•ˆæœæ˜¯ï¥§ä¸€æ ·çš„ï¼Œè¿™æ˜¯ç”±ç‰©ä½“æœ¬èº«çš„ç»“æ„ç‰¹æ€§æ‰€å†³å®šçš„ã€‚ å¦‚ä½•å°†å„ç§åª’ä½“æºæ•°å­—åŒ–å‘¢ï¼Ÿ å°†å£°æ³¢æ³¢å½¢ä¿¡å·é€šè¿‡ADCè½¬æ¢æˆè®¡ç®—æœºæ”¯æŒçš„äºŒè¿›åˆ¶çš„è¿‡ç¨‹å«åšéŸ³é¢‘é‡‡æ ·(Audio Sampling)ã€‚é‡‡æ ·(Sampling)çš„æ ¸å¿ƒæ˜¯æŠŠè¿ç»­çš„æ¨¡æ‹Ÿä¿¡å·è½¬æ¢æˆç¦»æ•£çš„æ•°å­—ä¿¡å·ã€‚ 1.4ã€æ ·æœ¬(Sample)è¿™æ˜¯æˆ‘ä»¬è¿›è¡Œé‡‡æ ·çš„åˆå§‹èµ„æ–™ï¼Œæ¯”å¦‚ä¸€æ®µè¿ç»­çš„å£°éŸ³æ³¢å½¢ã€‚ 1.5ã€é‡‡æ ·å™¨(Sampler)é‡‡æ ·å™¨æ˜¯å°†æ ·æœ¬è½¬æ¢æˆç»ˆæ€ä¿¡å·çš„å…³é”®ã€‚å®ƒå¯ä»¥æ˜¯ä¸€ä¸ªå­ç³»ç»Ÿï¼Œä¹Ÿå¯ä»¥æŒ‡ä¸€ä¸ªæ“ä½œè¿‡ç¨‹ï¼Œç”šè‡³æ˜¯ä¸€ä¸ªç®—æ³•ï¼Œå–å†³äºä¸åŒçš„ä¿¡å·å¤„ç†åœºæ™¯ã€‚ç†æƒ³çš„é‡‡æ ·å™¨è¦æ±‚å°½å¯èƒ½ä¸äº§ç”Ÿä¿¡å·å¤±çœŸã€‚ 1.6ã€é‡åŒ–(Quantization)é‡‡æ ·åçš„å€¼è¿˜éœ€è¦é€šè¿‡é‡åŒ–ï¼Œä¹Ÿå°±æ˜¯å°†è¿ç»­å€¼è¿‘ä¼¼ä¸ºæŸä¸ªèŒƒå›´å†…æœ‰é™å¤šä¸ªç¦»æ•£å€¼çš„å¤„ç†è¿‡ç¨‹ã€‚å› ä¸ºåŸå§‹æ•°æ®æ˜¯æ¨¡æ‹Ÿçš„è¿ç»­ä¿¡å·ï¼Œè€Œæ•°å­—ä¿¡å·åˆ™æ˜¯ç¦»æ•£çš„ï¼Œå®ƒçš„è¡¨è¾¾èŒƒå›´æ˜¯æœ‰é™çš„ï¼Œæ‰€ä»¥é‡åŒ–æ˜¯å¿…ä¸å¯å°‘çš„ä¸€ä¸ªæ­¥éª¤ã€‚ 1.7ã€ç¼–ç (Coding)è®¡ç®—æœºçš„ä¸–ç•Œé‡Œï¼Œæ‰€æœ‰æ•°å€¼éƒ½æ˜¯ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºçš„ï¼Œå› è€Œæˆ‘ä»¬è¿˜éœ€è¦æŠŠé‡åŒ–å€¼è¿›è¡ŒäºŒè¿›åˆ¶ç¼–ç ã€‚è¿™ä¸€æ­¥é€šå¸¸ä¸é‡åŒ–åŒæ—¶è¿›è¡Œã€‚ 1.8ã€é‡‡æ ·ç‡ï¼ˆsamplerateï¼‰é‡‡æ ·å°±æ˜¯æŠŠæ¨¡æ‹Ÿä¿¡å·æ•°å­—åŒ–çš„è¿‡ç¨‹ï¼Œä¸ä»…ä»…æ˜¯éŸ³é¢‘éœ€è¦é‡‡æ ·ï¼Œæ‰€æœ‰çš„æ¨¡æ‹Ÿä¿¡å·éƒ½éœ€è¦é€šè¿‡é‡‡æ ·è½¬æ¢ä¸ºå¯ä»¥ç”¨0101æ¥è¡¨ç¤ºçš„æ•°å­—ä¿¡å·ï¼Œç¤ºæ„å›¾å¦‚ä¸‹æ‰€ç¤ºï¼š è“è‰²ä»£è¡¨æ¨¡æ‹ŸéŸ³é¢‘ä¿¡å·ï¼Œçº¢è‰²çš„ç‚¹ä»£è¡¨é‡‡æ ·å¾—åˆ°çš„é‡åŒ–æ•°å€¼ã€‚ é‡‡æ ·é¢‘ç‡è¶Šé«˜ï¼Œçº¢è‰²çš„é—´éš”å°±è¶Šå¯†é›†ï¼Œè®°å½•è¿™ä¸€æ®µéŸ³é¢‘ä¿¡å·æ‰€ç”¨çš„æ•°æ®é‡å°±è¶Šå¤§ï¼ŒåŒæ—¶éŸ³é¢‘è´¨é‡ä¹Ÿå°±è¶Šé«˜ã€‚ æ ¹æ®å¥ˆå¥æ–¯ç‰¹ç†è®ºï¼Œé‡‡æ ·é¢‘ç‡åªè¦ä¸ä½äºéŸ³é¢‘ä¿¡å·æœ€é«˜é¢‘ç‡çš„ä¸¤å€ï¼Œå°±å¯ä»¥æ— æŸå¤±åœ°è¿˜åŸåŸå§‹çš„å£°éŸ³ã€‚ é€šå¸¸äººè€³èƒ½å¬åˆ°é¢‘ç‡èŒƒå›´å¤§çº¦åœ¨20Hzï½20kHzä¹‹é—´çš„å£°éŸ³ï¼Œä¸ºäº†ä¿è¯å£°éŸ³ä¸å¤±çœŸï¼Œé‡‡æ ·é¢‘ç‡åº”åœ¨40kHzä»¥ä¸Šã€‚å¸¸ç”¨çš„éŸ³é¢‘é‡‡æ ·é¢‘ç‡æœ‰ï¼š8kHzã€11.025kHzã€22.05kHzã€16kHzã€37.8kHzã€44.1kHzã€48kHzã€96kHzã€192kHzç­‰ã€‚ 1.9ã€é‡åŒ–ç²¾åº¦ï¼ˆä½å®½ï¼‰ä¸Šå›¾ï¼ˆ1.8ï¼‰ä¸­ï¼Œæ¯ä¸€ä¸ªçº¢è‰²çš„é‡‡æ ·ç‚¹ï¼Œéƒ½éœ€è¦ç”¨ä¸€ä¸ªæ•°å€¼æ¥è¡¨ç¤ºå¤§å°ï¼Œè¿™ä¸ªæ•°å€¼çš„æ•°æ®ç±»å‹å¤§å°å¯ä»¥æ˜¯ï¼š4bitã€8bitã€16bitã€32bitç­‰ç­‰ï¼Œä½æ•°è¶Šå¤šï¼Œè¡¨ç¤ºå¾—å°±è¶Šç²¾ç»†ï¼Œå£°éŸ³è´¨é‡è‡ªç„¶å°±è¶Šå¥½ï¼Œå½“ç„¶ï¼Œæ•°æ®é‡ä¹Ÿä¼šæˆå€å¢å¤§ã€‚ å¸¸è§çš„ä½å®½æ˜¯ï¼š8bit æˆ–è€… 16bit 1.10ã€ å£°é“æ•°ï¼ˆchannelsï¼‰ç”±äºéŸ³é¢‘çš„é‡‡é›†å’Œæ’­æ”¾æ˜¯å¯ä»¥å åŠ çš„ï¼Œå› æ­¤ï¼Œå¯ä»¥åŒæ—¶ä»å¤šä¸ªéŸ³é¢‘æºé‡‡é›†å£°éŸ³ï¼Œå¹¶åˆ†åˆ«è¾“å‡ºåˆ°ä¸åŒçš„æ‰¬å£°å™¨ï¼Œæ•…å£°é“æ•°ä¸€èˆ¬è¡¨ç¤ºå£°éŸ³å½•åˆ¶æ—¶çš„éŸ³æºæ•°é‡æˆ–å›æ”¾æ—¶ç›¸åº”çš„æ‰¬å£°å™¨æ•°é‡ã€‚ å•å£°é“ï¼ˆMonoï¼‰å’ŒåŒå£°é“ï¼ˆStereoï¼‰æ¯”è¾ƒå¸¸è§ï¼Œé¡¾åæ€ä¹‰ï¼Œå‰è€…çš„å£°é“æ•°ä¸º1ï¼Œåè€…ä¸º2 1.11ã€éŸ³é¢‘å¸§ï¼ˆframeï¼‰è¿™ä¸ªæ¦‚å¿µåœ¨åº”ç”¨å¼€å‘ä¸­éå¸¸é‡è¦ï¼Œç½‘ä¸Šå¾ˆå¤šæ–‡ç« éƒ½æ²¡æœ‰ä¸“é—¨ä»‹ç»è¿™ä¸ªæ¦‚å¿µã€‚ éŸ³é¢‘è·Ÿè§†é¢‘å¾ˆä¸ä¸€æ ·ï¼Œè§†é¢‘æ¯ä¸€å¸§å°±æ˜¯ä¸€å¼ å›¾åƒï¼Œè€Œä»ä¸Šé¢çš„æ­£ç„æ³¢å¯ä»¥çœ‹å‡ºï¼ŒéŸ³é¢‘æ•°æ®æ˜¯æµå¼çš„ï¼Œæœ¬èº«æ²¡æœ‰æ˜ç¡®çš„ä¸€å¸§å¸§çš„æ¦‚å¿µï¼Œåœ¨å®é™…çš„åº”ç”¨ä¸­ï¼Œä¸ºäº†éŸ³é¢‘ç®—æ³•å¤„ç†/ä¼ è¾“çš„æ–¹ä¾¿ï¼Œä¸€èˆ¬çº¦å®šä¿—æˆå–2.5ms~60msä¸ºå•ä½çš„æ•°æ®é‡ä¸ºä¸€å¸§éŸ³é¢‘ã€‚ è¿™ä¸ªæ—¶é—´è¢«ç§°ä¹‹ä¸ºâ€œé‡‡æ ·æ—¶é—´â€ï¼Œå…¶é•¿åº¦æ²¡æœ‰ç‰¹åˆ«çš„æ ‡å‡†ï¼Œå®ƒæ˜¯æ ¹æ®ç¼–è§£ç å™¨å’Œå…·ä½“åº”ç”¨çš„éœ€æ±‚æ¥å†³å®šçš„ï¼Œæˆ‘ä»¬å¯ä»¥è®¡ç®—ä¸€ä¸‹ä¸€å¸§éŸ³é¢‘å¸§çš„å¤§å°ï¼š å‡è®¾æŸéŸ³é¢‘ä¿¡å·æ˜¯é‡‡æ ·ç‡ä¸º8kHzã€åŒé€šé“ã€ä½å®½ä¸º16bitï¼Œ20msä¸€å¸§ï¼Œåˆ™ä¸€å¸§éŸ³é¢‘æ•°æ®çš„å¤§å°ä¸ºï¼š int size = 8000 x 2 x 16bit x 0.02s = 5120 bit = 640 byte 1.12ã€å¸¸è§çš„éŸ³é¢‘ç¼–ç æ–¹å¼æœ‰å“ªäº›ï¼Ÿä¸Šé¢æåˆ°è¿‡ï¼Œæ¨¡æ‹Ÿçš„éŸ³é¢‘ä¿¡å·è½¬æ¢ä¸ºæ•°å­—ä¿¡å·éœ€è¦ç»è¿‡é‡‡æ ·å’Œé‡åŒ–ï¼Œé‡åŒ–çš„è¿‡ç¨‹è¢«ç§°ä¹‹ä¸ºç¼–ç ï¼Œæ ¹æ®ä¸åŒçš„é‡åŒ–ç­–ç•¥ï¼Œäº§ç”Ÿäº†è®¸å¤šä¸åŒçš„ç¼–ç æ–¹å¼ï¼Œå¸¸è§çš„ç¼–ç æ–¹å¼æœ‰ï¼šPCM å’Œ ADPCMï¼Œè¿™äº›æ•°æ®ä»£è¡¨ç€æ— æŸçš„åŸå§‹æ•°å­—éŸ³é¢‘ä¿¡å·ï¼Œæ·»åŠ ä¸€äº›æ–‡ä»¶å¤´ä¿¡æ¯ï¼Œå°±å¯ä»¥å­˜å‚¨ä¸ºWAVæ–‡ä»¶äº†ï¼Œå®ƒæ˜¯ä¸€ç§ç”±å¾®è½¯å’ŒIBMè”åˆå¼€å‘çš„ç”¨äºéŸ³é¢‘æ•°å­—å­˜å‚¨çš„æ ‡å‡†ï¼Œå¯ä»¥å¾ˆå®¹æ˜“åœ°è¢«è§£æå’Œæ’­æ”¾ã€‚ æˆ‘ä»¬åœ¨éŸ³é¢‘å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä¼šç»å¸¸æ¶‰åŠåˆ°WAVæ–‡ä»¶çš„è¯»å†™ï¼Œä»¥éªŒè¯é‡‡é›†ã€ä¼ è¾“ã€æ¥æ”¶çš„éŸ³é¢‘æ•°æ®çš„æ­£ç¡®æ€§ã€‚ 1.13ã€å¸¸è§çš„éŸ³é¢‘å‹ç¼©æ ¼å¼æœ‰å“ªäº›ï¼Ÿé¦–å…ˆç®€å•ä»‹ç»ä¸€ä¸‹éŸ³é¢‘æ•°æ®å‹ç¼©çš„æœ€åŸºæœ¬çš„åŸç†ï¼šå› ä¸ºæœ‰å†—ä½™ä¿¡æ¯ï¼Œæ‰€ä»¥å¯ä»¥å‹ç¼©ã€‚ ï¼ˆ1ï¼‰ é¢‘è°±æ©è”½æ•ˆåº”ï¼š äººè€³æ‰€èƒ½å¯Ÿè§‰çš„å£°éŸ³ä¿¡å·çš„é¢‘ç‡èŒƒå›´ä¸º20Hzï½20KHzï¼Œåœ¨è¿™ä¸ªé¢‘ç‡èŒƒå›´ä»¥å¤–çš„éŸ³é¢‘ä¿¡å·å±äºå†—ä½™ä¿¡å·ã€‚ ï¼ˆ2ï¼‰ æ—¶åŸŸæ©è”½æ•ˆåº”ï¼š å½“å¼ºéŸ³ä¿¡å·å’Œå¼±éŸ³ä¿¡å·åŒæ—¶å‡ºç°æ—¶ï¼Œå¼±ä¿¡å·ä¼šå¬ä¸åˆ°ï¼Œå› æ­¤ï¼Œå¼±éŸ³ä¿¡å·ä¹Ÿå±äºå†—ä½™ä¿¡å·ã€‚ ä¸‹é¢ç®€å•åˆ—å‡ºå¸¸è§çš„éŸ³é¢‘å‹ç¼©æ ¼å¼ï¼š MP3ï¼ŒAACï¼ŒOGGï¼ŒWMAï¼ŒOpusï¼ŒFLACï¼ŒAPEï¼ŒM4Aï¼ŒAMRï¼Œç­‰ç­‰ 1.14ã€å¥ˆå¥æ–¯ç‰¹é‡‡æ ·ç†è®ºâ€œå½“å¯¹è¢«é‡‡æ ·çš„æ¨¡æ‹Ÿä¿¡å·è¿›è¡Œè¿˜åŸæ—¶ï¼Œå…¶æœ€é«˜é¢‘ç‡åªæœ‰é‡‡æ ·é¢‘ç‡çš„ä¸€åŠâ€ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœæˆ‘ä»¬è¦å®Œæ•´é‡æ„åŸå§‹çš„æ¨¡æ‹Ÿä¿¡å·ï¼Œåˆ™é‡‡æ ·é¢‘ç‡å°±å¿…é¡»æ˜¯å®ƒçš„ä¸¤å€ä»¥ä¸Šã€‚æ¯”å¦‚äººçš„å£°éŸ³èŒƒå›´æ˜¯2~ 20kHZ,é‚£ä¹ˆé€‰æ‹©çš„é‡‡æ ·é¢‘ç‡å°±åº”è¯¥åœ¨40kHZå·¦å³ï¼Œæ•°å€¼å¤ªå°åˆ™å£°éŸ³å°†äº§ç”Ÿå¤±çœŸç°è±¡ï¼Œè€Œæ•°å€¼å¤ªå¤§ä¹Ÿæ— æ³•æ˜æ˜¾æå‡äººè€³æ‰€èƒ½æ„ŸçŸ¥çš„éŸ³è´¨ã€‚ 1.15ã€æ€»ç»“ï¼ˆéŸ³é¢‘å¤„ç†å’Œæ’­æ”¾è¿‡ç¨‹ï¼‰ï¼š ï¼ˆäºŒï¼‰ã€Audio ç³»ç»Ÿæ¡†æ¶æ€»ä½“Audioæ¡†æ¶å›¾ 2.1ã€APPéŸ³ä¹æ’­æ”¾å™¨è½¯ä»¶ç­‰ç­‰ã€‚ 2.2ã€FrameworkAndroidä¹Ÿæä¾›äº†å¦ä¸¤ä¸ªç›¸ä¼¼åŠŸèƒ½çš„ç±»ï¼Œå³AudioTrackå’ŒAudioRecorderï¼ŒMediaPlayerServiceå†…éƒ¨çš„å®ç°å°±æ˜¯é€šè¿‡å®ƒä»¬æ¥å®Œæˆçš„,åªä¸è¿‡MediaPlayer/MediaRecorderæä¾›äº†æ›´å¼ºå¤§çš„æ§åˆ¶åŠŸèƒ½ï¼Œç›¸æ¯”å‰è€…ä¹Ÿæ›´æ˜“äºä½¿ç”¨ã€‚é™¤æ­¤ä»¥å¤–ï¼ŒAndroidç³»ç»Ÿè¿˜ä¸ºæˆ‘ä»¬æ§åˆ¶éŸ³é¢‘ç³»ç»Ÿæä¾›äº†AudioManagerã€AudioServiceåŠAudioSystemç±»ã€‚è¿™äº›éƒ½æ˜¯frameworkä¸ºä¾¿åˆ©ä¸Šå±‚åº”ç”¨å¼€å‘æ‰€è®¾è®¡çš„ã€‚ 2.3ã€Librariesframeworkåªæ˜¯å‘åº”ç”¨ç¨‹åºæä¾›è®¿é—®Androidåº“çš„æ¡¥æ¢ï¼Œå…·ä½“åŠŸèƒ½å®ç°æ”¾åœ¨åº“ä¸­å®Œæˆã€‚æ¯”å¦‚ä¸Šé¢çš„AudioTrackã€AudioRecorderã€MediaPlayerå’ŒMediaRecorderç­‰ç­‰åœ¨åº“ä¸­éƒ½èƒ½æ‰¾åˆ°ç›¸å¯¹åº”çš„ç±»ã€‚ 1ã€frameworks/av/media/libmediaã€libmedia.soã€‘2ã€frameworks/av/services/audioflingerã€libaudioflinger.soã€‘3ã€frameworks/av/media/libmediaplayerserviceã€libmediaplayerservice.soã€‘ 2.4ã€HALä»è®¾è®¡ä¸Šæ¥çœ‹ï¼Œç¡¬ä»¶æŠ½è±¡å±‚æ˜¯AudioFlingerç›´æ¥è®¿é—®çš„å¯¹è±¡ã€‚è¿™è¯´æ˜äº†ä¸¤ä¸ªé—®é¢˜ï¼Œä¸€æ–¹é¢AudioFlingerå¹¶ä¸ç›´æ¥è°ƒç”¨åº•å±‚çš„é©±åŠ¨ç¨‹åº;å¦ä¸€æ–¹é¢ï¼ŒAudioFlingerä¸Šå±‚æ¨¡å—åªéœ€è¦ä¸å®ƒè¿›è¡Œäº¤äº’å°±å¯ä»¥å®ç°éŸ³é¢‘ç›¸å…³çš„åŠŸèƒ½äº†ã€‚å› è€Œæˆ‘ä»¬å¯ä»¥è®¤ä¸ºAudioFlingeræ˜¯AndroidéŸ³é¢‘ç³»ç»Ÿä¸­çœŸæ­£çš„â€œéš”ç¦»æ¿â€ï¼Œæ— è®ºä¸‹é¢å¦‚ä½•å˜åŒ–ï¼Œä¸Šå±‚çš„å®ç°éƒ½å¯ä»¥ä¿æŒå…¼å®¹ã€‚ éŸ³é¢‘æ–¹é¢çš„ç¡¬ä»¶æŠ½è±¡å±‚ä¸»è¦åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå³AudioFlingerå’ŒAudioPolicyServiceã€‚å®é™…ä¸Šåè€…å¹¶ä¸æ˜¯ä¸€ä¸ªçœŸå®çš„è®¾å¤‡ï¼Œåªæ˜¯é‡‡ç”¨è™šæ‹Ÿè®¾å¤‡çš„æ–¹å¼æ¥è®©å‚å•†å¯ä»¥æ–¹ä¾¿åœ°å®šåˆ¶å‡ºè‡ªå·±çš„ç­–ç•¥ã€‚æŠ½è±¡å±‚çš„ä»»åŠ¡æ˜¯å°†AudioFlinger/AudioPolicyServiceçœŸæ­£åœ°ä¸ç¡¬ä»¶è®¾å¤‡å…³è”èµ·æ¥ï¼Œä½†åˆå¿…é¡»æä¾›çµæ´»çš„ç»“æ„æ¥åº”å¯¹å˜åŒ–â€”â€”ç‰¹åˆ«æ˜¯å¯¹äºAndroidè¿™ä¸ªæ›´æ–°ç›¸å½“é¢‘ç¹çš„ç³»ç»Ÿã€‚æ¯”å¦‚ä»¥å‰Androidç³»ç»Ÿä¸­çš„Audioç³»ç»Ÿä¾èµ–äºALSA-libï¼Œä½†åæœŸå°±å˜ä¸ºäº†tinyalsaï¼Œè¿™æ ·çš„è½¬å˜ä¸åº”è¯¥å¯¹ä¸Šå±‚é€ æˆç ´åã€‚å› è€ŒAudio HALæä¾›äº†ç»Ÿä¸€çš„æ¥å£æ¥å®šä¹‰å®ƒä¸AudioFlinger/AudioPolicyServiceä¹‹é—´çš„é€šä¿¡æ–¹å¼ï¼Œè¿™å°±æ˜¯audio_hw_deviceã€audio_stream_inåŠaudio_stream_outç­‰ç­‰å­˜åœ¨çš„ç›®çš„ï¼Œè¿™äº›Structæ•°æ®ç±»å‹å†…éƒ¨å¤§å¤šåªæ˜¯å‡½æ•°æŒ‡é’ˆçš„å®šä¹‰ï¼Œæ˜¯ä¸€äº›â€œå£³â€ã€‚å½“AudioFlinger/AudioPolicyServiceåˆå§‹åŒ–æ—¶ï¼Œå®ƒä»¬ä¼šå»å¯»æ‰¾ç³»ç»Ÿä¸­æœ€åŒ¹é…çš„å®ç°(è¿™äº›å®ç°é©»ç•™åœ¨ä»¥audio.primary.,audio.a2dp.ä¸ºåçš„å„ç§åº“ä¸­)æ¥å¡«å……è¿™äº›â€œå£³â€ã€‚æ ¹æ®äº§å“çš„ä¸åŒï¼ŒéŸ³é¢‘è®¾å¤‡å­˜åœ¨å¾ˆå¤§å·®å¼‚ï¼Œåœ¨Androidçš„éŸ³é¢‘æ¶æ„ä¸­ï¼Œè¿™äº›é—®é¢˜éƒ½æ˜¯ç”±HALå±‚çš„audio.primaryç­‰ç­‰åº“æ¥è§£å†³çš„ï¼Œè€Œä¸éœ€è¦å¤§è§„æ¨¡åœ°ä¿®æ”¹ä¸Šå±‚å®ç°ã€‚æ¢å¥è¯è¯´ï¼Œå‚å•†åœ¨å®šåˆ¶æ—¶çš„é‡ç‚¹å°±æ˜¯å¦‚ä½•æä¾›è¿™éƒ¨åˆ†åº“çš„é«˜æ•ˆå®ç°äº†ã€‚ 2.5ã€Tinyalsaæºç åœ¨external/tinyalsaç›®å½•ä¸‹Tinyalsaï¼štinyplay/tinycap/tinymixï¼Œè¿™äº›ç”¨æˆ·ç¨‹åºç›´æ¥è°ƒç”¨ alsa ç”¨æˆ·åº“æ¥å£æ¥å®ç°æ”¾éŸ³ã€å½•éŸ³ã€æ§åˆ¶ 2.6ã€Kerneléƒ¨åˆ†2.6.1ã€ALSA å’Œ ASoCNative ALSA Applicationï¼štinyplay/tinycap/tinymixï¼Œè¿™äº›ç”¨æˆ·ç¨‹åºç›´æ¥è°ƒç”¨ alsa ç”¨æˆ·åº“æ¥å£æ¥å®ç°æ”¾éŸ³ã€å½•éŸ³ã€æ§åˆ¶ALSA Library APIï¼šalsa ç”¨æˆ·åº“æ¥å£ï¼Œå¸¸è§æœ‰ tinyalsaã€alsa-libALSA COREï¼šalsa æ ¸å¿ƒå±‚ï¼Œå‘ä¸Šæä¾›é€»è¾‘è®¾å¤‡ï¼ˆPCM/CTL/MIDI/TIMER/â€¦ï¼‰ç³»ç»Ÿè°ƒç”¨ï¼Œå‘ä¸‹é©±åŠ¨ç¡¬ä»¶è®¾å¤‡ï¼ˆMachine/I2S/DMA/CODECï¼‰ASoC COREï¼šasoc æ˜¯å»ºç«‹åœ¨æ ‡å‡† alsa core åŸºç¡€ä¸Šï¼Œä¸ºäº†æ›´å¥½æ”¯æŒåµŒå…¥å¼ç³»ç»Ÿå’Œåº”ç”¨äºç§»åŠ¨è®¾å¤‡çš„éŸ³é¢‘ codec çš„ä¸€å¥—è½¯ä»¶ä½“ç³»Hardware Driverï¼šéŸ³é¢‘ç¡¬ä»¶è®¾å¤‡é©±åŠ¨ï¼Œç”±ä¸‰å¤§éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯ Machineã€Platformã€Codec 2.6.2ã€ASoCASoCè¢«åˆ†ä¸ºMachineã€Platformå’ŒCodecä¸‰å¤§éƒ¨åˆ†ã€‚å…¶ä¸­çš„Machineé©±åŠ¨è´Ÿè´£Platformå’ŒCodecä¹‹é—´çš„è€¦åˆå’Œè®¾å¤‡æˆ–æ¿å­ç‰¹å®šçš„ä»£ç ã€‚Platformé©±åŠ¨çš„ä¸»è¦ä½œç”¨æ˜¯å®ŒæˆéŸ³é¢‘æ•°æ®çš„ç®¡ç†ï¼Œæœ€ç»ˆé€šè¿‡CPUçš„æ•°å­—éŸ³é¢‘æ¥å£ï¼ˆDAIï¼‰æŠŠéŸ³é¢‘æ•°æ®ä¼ é€ç»™Codecè¿›è¡Œå¤„ç†ï¼Œæœ€ç»ˆç”±Codecè¾“å‡ºé©±åŠ¨è€³æœºæˆ–è€…æ˜¯å–‡å­çš„éŸ³ä¿¡ä¿¡å·ã€‚ 2.6.2.1ã€Machineç”¨äºæè¿°è®¾å¤‡ç»„ä»¶ä¿¡æ¯å’Œç‰¹å®šçš„æ§åˆ¶å¦‚è€³æœº/å¤–æ”¾ç­‰ã€‚ æ˜¯æŒ‡æŸä¸€æ¬¾æœºå™¨ï¼Œå¯ä»¥æ˜¯æŸæ¬¾è®¾å¤‡ï¼ŒæŸæ¬¾å¼€å‘æ¿ï¼Œåˆæˆ–è€…æ˜¯æŸæ¬¾æ™ºèƒ½æ‰‹æœºï¼Œç”±æ­¤å¯ä»¥çœ‹å‡ºMachineå‡ ä¹æ˜¯ä¸å¯é‡ç”¨çš„ï¼Œæ¯ä¸ªMachineä¸Šçš„ç¡¬ä»¶å®ç°å¯èƒ½éƒ½ä¸ä¸€æ ·ï¼ŒCPUä¸ä¸€æ ·ï¼ŒCodecä¸ä¸€æ ·ï¼ŒéŸ³é¢‘çš„è¾“å…¥ã€è¾“å‡ºè®¾å¤‡ä¹Ÿä¸ä¸€æ ·ï¼ŒMachineä¸ºCPUã€Codecã€è¾“å…¥è¾“å‡ºè®¾å¤‡æä¾›äº†ä¸€ä¸ªè½½ä½“ã€‚ è¿™ä¸€éƒ¨åˆ†å°†å¹³å°é©±åŠ¨å’ŒCodecé©±åŠ¨ç»‘å®šåœ¨ä¸€èµ·ï¼Œæè¿°äº†æ¿çº§çš„ç¡¬ä»¶ç‰¹å¾ã€‚ä¸»è¦è´Ÿè´£Platformå’ŒCodecä¹‹é—´çš„è€¦åˆä»¥åŠéƒ¨åˆ†å’Œè®¾å¤‡æˆ–æ¿å­ç‰¹å®šçš„ä»£ç ã€‚Machineé©±åŠ¨è´Ÿè´£å¤„ç†æœºå™¨ç‰¹æœ‰çš„ä¸€äº›æ§ä»¶å’ŒéŸ³é¢‘äº‹ä»¶ï¼ˆä¾‹å¦‚ï¼Œå½“æ’­æ”¾éŸ³é¢‘æ—¶ï¼Œéœ€è¦å…ˆè¡Œæ‰“å¼€ä¸€ä¸ªæ”¾å¤§å™¨ï¼‰ï¼›å•ç‹¬çš„Platformå’ŒCodecé©±åŠ¨æ˜¯ä¸èƒ½å·¥ä½œçš„ï¼Œå®ƒå¿…é¡»ç”±Machineé©±åŠ¨æŠŠå®ƒä»¬ç»“åˆåœ¨ä¸€èµ·æ‰èƒ½å®Œæˆæ•´ä¸ªè®¾å¤‡çš„éŸ³é¢‘å¤„ç†å·¥ä½œã€‚ASoCçš„ä¸€åˆ‡éƒ½ä»Machineé©±åŠ¨å¼€å§‹ï¼ŒåŒ…æ‹¬å£°å¡çš„æ³¨å†Œï¼Œç»‘å®šPlatformå’ŒCodecé©±åŠ¨ç­‰ç­‰ 2.6.2.2ã€Platformç”¨äºå®ç°å¹³å°ç›¸å…³çš„DMAé©±åŠ¨å’ŒéŸ³é¢‘æ¥å£ç­‰ã€‚ ä¸€èˆ¬æ˜¯æŒ‡æŸä¸€ä¸ªSoCå¹³å°ï¼Œæ¯”å¦‚pxaxxx,s3cxxxx,omapxxxç­‰ç­‰ï¼Œä¸éŸ³é¢‘ç›¸å…³çš„é€šå¸¸åŒ…å«è¯¥SoCä¸­çš„æ—¶é’Ÿã€DMAã€I2Sã€PCMç­‰ç­‰ï¼Œåªè¦æŒ‡å®šäº†SoCï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è®¤ä¸ºå®ƒä¼šæœ‰ä¸€ä¸ªå¯¹åº”çš„Platformï¼Œå®ƒåªä¸SoCç›¸å…³ï¼Œä¸Machineæ— å…³ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥æŠŠPlatformæŠ½è±¡å‡ºæ¥ï¼Œä½¿å¾—åŒä¸€æ¬¾SoCä¸ç”¨åšä»»ä½•çš„æ”¹åŠ¨ï¼Œå°±å¯ä»¥ç”¨åœ¨ä¸åŒçš„Machineä¸­ã€‚å®é™…ä¸Šï¼ŒæŠŠPlatformè®¤ä¸ºæ˜¯æŸä¸ªSoCæ›´å¥½ç†è§£ã€‚ è¿™ä¸€éƒ¨åˆ†åªå…³å¿ƒCPUæœ¬èº«ï¼Œä¸å…³å¿ƒCodecã€‚ä¸»è¦å¤„ç†ä¸¤ä¸ªé—®é¢˜ï¼šDMAå¼•æ“å’ŒSoCé›†æˆçš„PCMã€I2Sæˆ–AC â€˜97æ•°å­—æ¥å£æ§åˆ¶ã€‚ä¸»è¦ä½œç”¨æ˜¯å®ŒæˆéŸ³é¢‘æ•°æ®çš„ç®¡ç†ï¼Œæœ€ç»ˆé€šè¿‡CPUçš„æ•°å­—éŸ³é¢‘æ¥å£ï¼ˆDAIï¼‰æŠŠéŸ³é¢‘æ•°æ®ä¼ é€ç»™Codecè¿›è¡Œå¤„ç†ï¼Œæœ€ç»ˆç”±Codecè¾“å‡ºé©±åŠ¨è€³æœºæˆ–è€…æ˜¯å–‡å­çš„éŸ³ä¿¡ä¿¡å·ã€‚åœ¨å…·ä½“å®ç°ä¸Šï¼ŒASoCæœ‰æŠŠPlatformé©±åŠ¨åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼šsnd_soc_platform_driverå’Œsnd_soc_dai_driverã€‚å…¶ä¸­ï¼Œplatform_driverè´Ÿè´£ç®¡ç†éŸ³é¢‘æ•°æ®ï¼ŒæŠŠéŸ³é¢‘æ•°æ®é€šè¿‡dmaæˆ–å…¶ä»–æ“ä½œä¼ é€è‡³cpu daiä¸­ï¼Œdai_driveråˆ™ä¸»è¦å®Œæˆcpuä¸€ä¾§çš„daiçš„å‚æ•°é…ç½®ï¼ŒåŒæ—¶ä¹Ÿä¼šé€šè¿‡ä¸€å®šçš„é€”å¾„æŠŠå¿…è¦çš„dmaç­‰å‚æ•°ä¸snd_soc_platform_driverè¿›è¡Œäº¤äº’ã€‚ 2.6.2.3ã€Codecç”¨äºå®ç°å¹³å°æ— å…³çš„åŠŸèƒ½ï¼Œå¦‚å¯„å­˜å™¨è¯»å†™æ¥å£ï¼ŒéŸ³é¢‘æ¥å£ï¼Œå„widgetsçš„æ§åˆ¶æ¥å£å’ŒDAPMçš„å®ç°ç­‰ å­—é¢ä¸Šçš„æ„æ€å°±æ˜¯ç¼–è§£ç å™¨ï¼ŒCodecé‡Œé¢åŒ…å«äº†I2Sæ¥å£ã€D/Aã€A/Dã€Mixerã€PAï¼ˆåŠŸæ”¾ï¼‰ï¼Œé€šå¸¸åŒ…å«å¤šç§è¾“å…¥ï¼ˆMicã€Line-inã€I2Sã€PCMï¼‰å’Œå¤šä¸ªè¾“å‡ºï¼ˆè€³æœºã€å–‡å­ã€å¬ç­’ï¼ŒLine-outï¼‰ï¼ŒCodecå’ŒPlatformä¸€æ ·ï¼Œæ˜¯å¯é‡ç”¨çš„éƒ¨ä»¶ï¼ŒåŒä¸€ä¸ªCodecå¯ä»¥è¢«ä¸åŒçš„Machineä½¿ç”¨ã€‚åµŒå…¥å¼Codecé€šå¸¸é€šè¿‡I2Cå¯¹å†…éƒ¨çš„å¯„å­˜å™¨è¿›è¡Œæ§åˆ¶ã€‚ è¿™ä¸€éƒ¨åˆ†åªå…³å¿ƒCodecæœ¬èº«ï¼Œä¸CPUå¹³å°ç›¸å…³çš„ç‰¹æ€§ä¸ç”±æ­¤éƒ¨åˆ†æ“ä½œã€‚åœ¨ç§»åŠ¨è®¾å¤‡ä¸­ï¼ŒCodecçš„ä½œç”¨å¯ä»¥å½’ç»“ä¸º4ç§ï¼Œåˆ†åˆ«æ˜¯ï¼š 1ã€å¯¹PCMç­‰ä¿¡å·è¿›è¡ŒD/Aè½¬æ¢ï¼ŒæŠŠæ•°å­—çš„éŸ³é¢‘ä¿¡å·è½¬æ¢ä¸ºæ¨¡æ‹Ÿä¿¡å·ã€‚2ã€å¯¹Micã€Lineinæˆ–è€…å…¶ä»–è¾“å…¥æºçš„æ¨¡æ‹Ÿä¿¡å·è¿›è¡ŒA/Dè½¬æ¢ï¼ŒæŠŠæ¨¡æ‹Ÿçš„å£°éŸ³ä¿¡å·è½¬å˜CPUèƒ½å¤Ÿå¤„ç†çš„æ•°å­—ä¿¡å·ã€‚3ã€å¯¹éŸ³é¢‘é€šè·¯è¿›è¡Œæ§åˆ¶ï¼Œæ¯”å¦‚æ’­æ”¾éŸ³ä¹ï¼Œæ”¶å¬è°ƒé¢‘æ”¶éŸ³æœºï¼Œåˆæˆ–è€…æ¥å¬ç”µè¯æ—¶ï¼ŒéŸ³é¢‘ä¿¡å·åœ¨codecå†…çš„æµé€šè·¯çº¿æ˜¯ä¸ä¸€æ ·çš„ã€‚4ã€å¯¹éŸ³é¢‘ä¿¡å·åšå‡ºç›¸åº”çš„å¤„ç†ï¼Œä¾‹å¦‚éŸ³é‡æ§åˆ¶ï¼ŒåŠŸç‡æ”¾å¤§ï¼ŒEQæ§åˆ¶ç­‰ç­‰ã€‚ ASoCå¯¹Codecçš„è¿™äº›åŠŸèƒ½éƒ½å®šä¹‰å¥½äº†ä¸€äº›åˆ—ç›¸åº”çš„æ¥å£ï¼Œä»¥æ–¹ä¾¿åœ°å¯¹Codecè¿›è¡Œæ§åˆ¶ã€‚ASoCå¯¹Codecé©±åŠ¨çš„ä¸€ä¸ªåŸºæœ¬è¦æ±‚æ˜¯ï¼šé©±åŠ¨ç¨‹åºçš„ä»£ç å¿…é¡»è¦åšåˆ°å¹³å°æ— å…³æ€§ï¼Œä»¥æ–¹ä¾¿åŒä¸€ä¸ªCodecçš„ä»£ç ä¸ç»ä¿®æ”¹å³å¯ç”¨åœ¨ä¸åŒçš„å¹³å°ä¸Šã€‚ ASoCå¯¹äºAlsaæ¥è¯´ï¼Œå°±æ˜¯åˆ†åˆ«æ³¨å†ŒPCM/CONTROLç±»å‹çš„snd_deviceè®¾å¤‡ï¼Œå¹¶å®ç°ç›¸åº”çš„æ“ä½œæ–¹æ³•é›†ã€‚å›¾ä¸­DAIæ˜¯æ•°å­—éŸ³é¢‘æ¥å£ï¼Œç”¨äºé…ç½®éŸ³é¢‘æ•°æ®æ ¼å¼ç­‰ã€‚ â˜ Codecé©±åŠ¨å‘ASoCæ³¨å†Œsnd_soc_codecå’Œsnd_soc_daiè®¾å¤‡ã€‚â˜ Platformé©±åŠ¨å‘ASoCæ³¨å†Œsnd_soc_platformå’Œsnd_soc_daiè®¾å¤‡ã€‚â˜ Machineé©±åŠ¨é€šè¿‡snd_soc_dai_linkç»‘å®šcodec/dai/platformã€‚ Widgetæ˜¯å„ä¸ªç»„ä»¶å†…éƒ¨çš„å°å•å…ƒã€‚å¤„åœ¨æ´»åŠ¨é€šè·¯ä¸Šç”µï¼Œä¸åœ¨æ´»åŠ¨é€šè·¯ä¸‹ç”µã€‚ASoCçš„DAPMæ­£æ˜¯é€šè¿‡æ§åˆ¶è¿™äº›Widgetçš„ä¸Šä¸‹ç”µè¾¾åˆ°åŠ¨æ€ç”µæºç®¡ç†çš„æ•ˆæœã€‚ â˜ pathæè¿°ä¸å…¶å®ƒwidgetçš„è¿æ¥å…³ç³»ã€‚â˜ eventç”¨äºé€šçŸ¥è¯¥widgetçš„ä¸Šä¸‹ç”µçŠ¶æ€ã€‚â˜ poweræŒ‡ç¤ºå½“å‰çš„ä¸Šç”µçŠ¶æ€ã€‚â˜ controlå®ç°ç©ºé—´ç”¨æˆ·æ¥å£ç”¨äºæ§åˆ¶widgetçš„éŸ³é‡/é€šè·¯åˆ‡æ¢ç­‰ã€‚ å¯¹é©±åŠ¨å¼€è€…æ¥è¯´ï¼Œå°±å¯ä»¥å¾ˆå¥½çš„è§£è€¦äº†ï¼š â˜ codecé©±åŠ¨çš„å¼€å‘è€…ï¼Œå®ç°codecçš„IOè¯»å†™æ–¹æ³•ï¼Œæè¿°DAIæ”¯æŒçš„æ•°æ®æ ¼å¼/æ“ä½œæ–¹æ³•å’ŒWidgetçš„è¿æ¥å…³ç³»å°±å¯ä»¥äº†;â˜ socèŠ¯ç‰‡çš„é©±åŠ¨å¼€å‘è€…ï¼ŒPlatformå®ç°snd_pcmçš„æ“ä½œæ–¹æ³•é›†å’ŒDAIçš„é…ç½®å¦‚æ“ä½œ DMAï¼ŒI2S/AC97/PCMçš„è®¾å®šç­‰;â˜ æ¿çº§çš„å¼€å‘è€…ï¼Œæè¿°Machineä¸Šcodecä¸platformä¹‹é—´çš„æ€»çº¿è¿æ¥ï¼Œ earphone/Speakerçš„å¸ƒçº¿æƒ…å†µå°±å¯ä»¥äº†ã€‚ 2.6.3ã€DAPM DAPMæ˜¯Dynamic Audio Power Managementçš„ç¼©å†™ï¼Œç›´è¯‘è¿‡æ¥å°±æ˜¯åŠ¨æ€éŸ³é¢‘ç”µæºç®¡ç†çš„æ„æ€ï¼ŒDAPMæ˜¯ä¸ºäº†ä½¿åŸºäºlinuxçš„ç§»åŠ¨è®¾å¤‡ä¸Šçš„éŸ³é¢‘å­ç³»ç»Ÿï¼Œåœ¨ä»»ä½•æ—¶å€™éƒ½å·¥ä½œåœ¨æœ€å°åŠŸè€—çŠ¶æ€ä¸‹ã€‚DAPMå¯¹ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºæ¥è¯´æ˜¯é€æ˜çš„ï¼Œæ‰€æœ‰ä¸ç”µæºç›¸å…³çš„å¼€å…³éƒ½åœ¨ASoc coreä¸­å®Œæˆã€‚ç”¨æˆ·ç©ºé—´çš„åº”ç”¨ç¨‹åºæ— éœ€å¯¹ä»£ç åšå‡ºä¿®æ”¹ï¼Œä¹Ÿæ— éœ€é‡æ–°ç¼–è¯‘ï¼ŒDAPMæ ¹æ®å½“å‰æ¿€æ´»çš„éŸ³é¢‘æµï¼ˆplayback/captureï¼‰å’Œå£°å¡ä¸­çš„mixerç­‰çš„é…ç½®æ¥å†³å®šé‚£äº›éŸ³é¢‘æ§ä»¶çš„ç”µæºå¼€å…³è¢«æ‰“å¼€æˆ–å…³é—­ã€‚ 2.6.4ã€DPCMDynamic PCM 2.7ã€Audio deviceså…·ä½“çš„Audioç¡¬ä»¶è®¾å¤‡ã€‚ ï¼ˆä¸‰ï¼‰ã€Qualcommå¹³å° - Audioç³»ç»Ÿæ¡†æ¶ç”±äºæ¥ä¸‹æ¥çš„ä¸€ç³»åˆ—Android &amp;&amp; kernel æºç åˆ†æéƒ½æ˜¯åŸºäºQualcomm å¹³å°çš„ï¼Œååˆ†æœ‰å¿…è¦ä»‹ç»Qualcomm å¹³å°çš„Audio ç³»ç»Ÿæ¡†æ¶ã€‚ç¡¬ä»¶å¹³å°åŠè½¯ä»¶ç‰ˆæœ¬ï¼šâ˜ Kernel - 3.18â˜ SoC - Qualcomm snapdragonâ˜ CODEC - WCD9335â˜ Machine - msm8996â˜ Userspace - tinyalsa 3.1ã€Qualcomm Audioç³»ç»Ÿæ€»ä½“æ¡†æ¶å›¾ 3.2ã€ASoC driverALSA ç‰‡ä¸Šç³»ç»Ÿ (ASoC) é©±åŠ¨ç¨‹åºå°†éŸ³é¢‘ç³»ç»Ÿåˆ†ä¸ºå››ä¸ªç»„æˆéƒ¨åˆ†Machine driverã€Platform driverã€CPU driverã€Codec driverã€‚ 3.2.1ã€Machine driverå°†å¹³å°ã€CPU å’Œç¼–è§£ç é©±åŠ¨ç¨‹åºæ•´åˆåœ¨ä¸€èµ·kernel/sound/soc/msm/.cå®šä¹‰Frontend (FE) and Backend (BE), Digital Audio Interface (DAI) links 3.2.2ã€Platform driveråŒ…å«ç”¨äºæµæ•°æ®ä¼ è¾“ä¸è·¯ç”±çš„å¹³å°ç‰¹å®šçš„æ§ä»¶ï¼ˆcontrolï¼‰ï¼Œ ç»†åˆ†ä¸º FE å’Œ BE å¹³å°é©±åŠ¨ç¨‹åºFEï‚§ Audio â€“ å®ä¾‹åŒ– PCM æ’­æ”¾å’Œå½•åˆ¶ä¼šè¯ï¼›å€ŸåŠ© ASM æ¥å£ï¼Œå°† PCM æ•°æ®ä»ç”¨æˆ·ç©ºé—´ä¼ è¾“åˆ° DSP è¿›è¡Œæ’­æ”¾ä»¥åŠä» DSP ä¼ è¾“åˆ°ç”¨æˆ·ç©ºé—´è¿›è¡Œå½•åˆ¶ â€“ åœ¨ kernel/sound/soc/msm-pcm-q6-v2.c ä¸­å®ç°ï‚§ Voice â€“ åˆå§‹åŒ–/å–æ¶ˆåˆå§‹åŒ–è¯­éŸ³å‘¼å«è®¾ç½® â€“ åœ¨ kernel/sound/soc/msm-pcm-voice-v2.c ä¸­å®ç°ï‚§ VoIP â€“ åˆå§‹åŒ–/å–æ¶ˆåˆå§‹åŒ– MVS æ¥å£ä»¥ä¼ è¾“è‡ª/è‡³ DSP çš„ PCM æ•°æ® â€“ åœ¨kernel/sound/soc/msm-pcmvoip-v2.cä¸­å®ç°ï‚§ Compressed offload â€“ æ”¯æŒå°†å‹ç¼©æ•°æ®å‘é€åˆ° DSP è¿›è¡Œå‹ç¼©åˆ†æµæ’­æ”¾ â€“ åœ¨ kernel/sound/soc/msm-compress-q6-v2.c ä¸­å®ç°BEï‚§ è·¯ç”± â€“ æ‰§è¡ŒéŸ³é¢‘è·¯ç”±ä»»åŠ¡ â€“ åœ¨ /kernel/sound/soc/msm-pcm-routing-v2.c ä¸­å®ç° 3.2.3ã€CPU driverFEï‚§ å‘ ASoC æ¡†æ¶æä¾›å…³äº FE PCM è®¾å¤‡çš„ä¿¡æ¯ï‚§ ASoC æ¡†æ¶ä¸å¹³å°é©±åŠ¨ç¨‹åºæä¾›çš„è·¯ç”±è¡¨å…±åŒå°† PCM æ’­æ”¾/æ•è·ä» FE ä¼ é€’è‡³ BEï‚§ æ²¡æœ‰é’ˆå¯¹æ’­æ”¾å’Œå½•åˆ¶çš„å†…ç½®é€»è¾‘ï‚§ å®šä¹‰ FE CPU DAI â€“ åœ¨ kernel/sound/soc/msm/msm-dai-fe.c ä¸­å®ç°BEï‚§ è¦åœ¨åˆå§‹åŒ– PCM æ’­æ”¾/æ•è·æ—¶æ¿€æ´»æ‰€éœ€éŸ³é¢‘ç¡¬ä»¶ç«¯å£ï¼Œåˆ™é…ç½® DSP AFE æ¨¡å—ï‚§ å®šä¹‰ BE CPU DAI â€“ åœ¨ kernel/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c ä¸­å®ç° 3.2.4ã€Codec driverä¸å¹³å°æ— å…³ï¼Œå…¶ä¸­åŒ…å«éŸ³é¢‘æ§åˆ¶ã€éŸ³é¢‘æ¥å£åŠŸèƒ½ã€ç¼–è§£ç å™¨ DAPM å®šä¹‰ä»¥åŠç¼–è§£ç å™¨è¾“å…¥è¾“å‡ºåŠŸèƒ½ï‚§ æ­¤å¤–ï¼Œå®ç° MBHC çŠ¶æ€æœºï¼Œç”¨äºæ£€æµ‹æœ‰çº¿è€³æœºæ’å…¥/æ‹”å‡ºã€é™„ä»¶ç±»å‹ã€è¿æ¥å™¨ç±»å‹å’Œå¤šæŒ‰é’®æ£€æµ‹ 3.3ã€DSP driver ASMï¼ˆAudio Stream Managerï¼‰ï‚§ ç”¨äºä¸ DSP ASM æ¨¡å—é€šä¿¡çš„æ¥å£ï‚§ æä¾›å°† PCM æ•°æ®è·¯ç”±è‡³ DSP çš„æœºåˆ¶ï¼Œæ”¯æŒæŒ‰æ•°æ®æµè¿›è¡ŒåæœŸå¤„ç†/é¢„å¤„ç†ADMï¼ˆAudio Device Managerï¼‰ï‚§ å…è®¸åœ¨ DSP ä¸­ä½¿ç”¨ ADM æœåŠ¡ï‚§ é…ç½® COPP å’Œè·¯ç”±çŸ©é˜µï‚§ ä¸éŸ³é¢‘æ ¡å‡†æ•°æ®åº“ (ACDB) è¿›è¡Œé€šä¿¡ï¼Œä½¿ç”¨æ­£ç¡®çš„æ ¡å‡†æ•°æ®é…ç½® COPPï‚§ å°† ASM ä¼šè¯ ID è·¯ç”±è‡³ ADM ä¼šè¯AFEï¼ˆAudio Front-Endï¼‰ï‚§ å…è®¸åœ¨ DSP ä¸­ä½¿ç”¨ AFE æœåŠ¡ï‚§ æ¿€æ´»/ç¦ç”¨éŸ³é¢‘ç¡¬ä»¶ç«¯å£ï‚§ å­ç³»ç»Ÿç®¡ç†å™¨ â€“ å‘ç”Ÿ MDSP å¤ä½äº‹ä»¶æ—¶ï¼Œé€šçŸ¥éŸ³é¢‘å’Œè¯­éŸ³é©±åŠ¨ç¨‹åºå…³é—­å¾…å¤„ç†ä¼šè¯ã€æ‰§è¡Œæ¸…ç†æ“ä½œå¹¶ç­‰å¾…ä¸€ä¸ªæŒ‡ç¤º MDSP å·²å¯åŠ¨çš„äº‹ä»¶APRï¼ˆAsynchronous Packet Routerï¼‰ï‚§ ä¸ºå¤„ç†å™¨é—´é€šä¿¡æä¾›å¼‚æ­¥æ¡†æ¶ï‚§ ç”¨äºä¸ Hexagon å’Œè°ƒåˆ¶è§£è°ƒå™¨å¤„ç†å™¨è¿›è¡Œé€šä¿¡ï‚§ Image loader PIL â€“ è½½å…¥ MDSP å›¾åƒ 3.4ã€User Spaceï‚§ Audio Hardware Abstraction Layer (AHAL) â€“ é€šè¿‡ tinyALSA å°† AudioFlinger è°ƒç”¨æ˜ å°„è‡³ASoC é©±åŠ¨ç¨‹åºçš„ç¡¬ä»¶æŠ½è±¡å±‚ã€‚ï‚§ ACDB loader â€“ æ£€ç´¢ç‰¹å®šè®¾å¤‡çš„æ ¡å‡†ä¿¡æ¯ï¼Œå¹¶å†™å…¥ PMEMã€‚ACDB é©±åŠ¨ç¨‹åºåœ¨å¯åŠ¨è¿‡ç¨‹ä¸­åˆ†é…è¯¥ PMEMã€‚åœ¨è®¾å¤‡åˆ‡æ¢æ—¶ï¼Œæ­¤æ ¡å‡†å°†è¢«å‘é€åˆ° DSPã€‚ï‚§ tinyALSA â€“ è¿æ¥è‡³å†…æ ¸ ASoC é©±åŠ¨ç¨‹åºçš„æ¥å£ï¼Œä¾›éŸ³é¢‘ HAL ä½¿ç”¨ã€‚æä¾›ç”¨äºéŸ³é¢‘æµå’Œè®¾å¤‡ç®¡ç†çš„åŸºæœ¬ PCM å’Œæ··éŸ³æ§ä»¶ APIã€‚ï‚§ Audio route â€“ æ­¤æ¨¡å—ä¼šä»ä¸€ä¸ª .xml æ–‡ä»¶è¯»å– ALSA æ··éŸ³æ§ä»¶ï¼Œå¹¶æ ¹æ®éŸ³é¢‘HAL æ‰€é€‰çš„è®¾å¤‡è®¾ç½®æ··éŸ³æ§ä»¶ã€‚ï‚§ Concurrency Manager - åœ¨MSM8x10ä¸­ï¼Œè§†é¢‘è§£ç å’Œç¼–ç åœ¨DSPä¸­å®Œæˆ; å› æ­¤ï¼Œæœ‰å¯¹å¯æ”¯æŒçš„å¹¶å‘æ€§æœ‰ä¸€äº›é™åˆ¶ã€‚MSM8x10ä¸­å¼•å…¥çš„å¹¶å‘ç®¡ç†å™¨ç®¡ç†å¹¶å‘æ€§å¯ä»¥æ”¯æŒæ¶‰åŠè¯­éŸ³å’ŒéŸ³é¢‘çš„ä¸åŒç”¨ä¾‹ Multimedia framework â€“ Stagefrightï‚§ æ”¯æŒæ ‡å‡†éŸ³é¢‘æ ¼å¼çš„æ’­æ”¾/å½•åˆ¶ï‚§ ä¸è§£ç å™¨/ç¼–ç å™¨åº“ä»¥åŠ OpenMAX IL ç»„ä»¶é€šä¿¡ï¼Œä»¥ä¾¿è¿›è¡Œè§£ç å’Œç¼–ç  Audio serviceï‚§ ç”±ç³»ç»ŸæœåŠ¡å™¨å¯åŠ¨å¹¶ç”±æœåŠ¡ç®¡ç†å™¨ç®¡ç†çš„è¿è¡Œæ—¶æœåŠ¡ä¹‹ä¸€ï‚§ æ„å›¾æ³¨å†Œï¼›å½“ä»å„ç§åº”ç”¨ç¨‹åºï¼ˆHDMIã€è“ç‰™ç­‰ï¼‰æ¥æ”¶åˆ°è¿™äº›æ„å›¾æ—¶ï¼Œé€šçŸ¥éŸ³é¢‘ç³»ç»Ÿ AudioFlingerï‚§ é€šè¿‡ libaudio æ¥å£ã€è“ç‰™ A2DP æ¥å£ç®¡ç†æ‰€æœ‰éŸ³é¢‘è¾“å‡º/è¾“å…¥è®¾å¤‡ï‚§ å°†å¤šä¸ªéŸ³é¢‘æµå¤„ç†ä¸ºå•ä¸€çš„ PCM éŸ³é¢‘ï¼›æ··åˆåçš„è¾“å‡ºè¢«ä¼ é€åˆ°è¾“å‡ºè®¾å¤‡ï‚§ æ’­æ”¾éŸ³ä¹æµæ—¶çš„éŸ³é‡ Audio Policy Manager (APM)ï‚§ å®šä¹‰å¤šä¸ªéŸ³é¢‘ç”¨ä¾‹ä¹‹é—´çš„å¹¶å‘è§„åˆ™ï‚§ ç”¨ä¾‹ç¤ºä¾‹ â€“ ç”µè¯é€šè¯ã€éŸ³ä¹æ’­æ”¾ã€ç³»ç»Ÿå£°éŸ³å’Œé€šçŸ¥ï‚§ å®šä¹‰æ’­æ”¾çš„éŸ³é¢‘ï¼ˆä¾‹å¦‚ï¼šè¯­éŸ³ã€æ’­æ”¾ã€é“ƒå£°ï¼‰ä»¥åŠæ’­æ”¾çš„è®¾å¤‡ï¼ˆè“ç‰™ã€æ‰¬å£°å™¨å’Œè€³æœºï¼‰APM ç”¨é€”ï¼šï‚§ ç®¡ç†å„ç§è¾“å…¥è¾“å‡ºè®¾å¤‡æ¥å£ï‚§ ç®¡ç†å„ç§è¾“å…¥è¾“å‡ºè®¾å¤‡ï¼Œä¾‹å¦‚ï¼šéº¦å…‹é£ã€æ‰¬å£°å™¨ã€è€³æœºã€å¬ç­’ã€A2DPã€è“ç‰™ SCOï‚§ åŸºäºéŸ³é¢‘æµã€æ¨¡å¼å’Œæ–¹æ³•é€‰æ‹©å’Œå®šä¹‰é€‚å½“çš„è·¯ç”±ç­–ç•¥ï‚§ ç®¡ç†æ¯ä¸ªéŸ³é¢‘æµçš„éŸ³é‡/é™éŸ³è®¾ç½®ï¼ˆåœ¨å®ƒä»¬æ¿€æ´»æˆ–ç¦ç”¨æ—¶ï¼‰ ï¼ˆå››ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroidéŸ³é¢‘æ¨¡å—å¯åŠ¨æµç¨‹åˆ†æJhusterçš„ä¸“æ â€‹ AndroidéŸ³é¢‘å¼€å‘é«˜é€šaudio offloadå­¦ä¹  | ThinkingDroidPhoneçš„ä¸“æ  - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„1-CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„2-ASoc - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„3-Pcm - CSDNåšå®¢alsaéŸ³é¢‘æ¶æ„4-å£°å¡æ§åˆ¶ - CSDNåšå®¢Linux ALSA éŸ³é¢‘ç³»ç»Ÿï¼šé€»è¾‘è®¾å¤‡ç¯‡ - CSDNåšå®¢Linux ALSA éŸ³é¢‘ç³»ç»Ÿï¼šç‰©ç†é“¾è·¯ç¯‡ - CSDNåšå®¢ä¸“æ ï¼šMultiMediaæ¡†æ¶æ€»ç»“(åŸºäº6.0æºç ) - CSDNåšå®¢Android éŸ³é¢‘ç³»ç»Ÿï¼šä» AudioTrack åˆ° AudioFlinger - CSDNåšå®¢AZURE - CSDNåšå®¢ - ALSA-Android AudioAZURE - CSDNåšå®¢ - ANDROIDéŸ³é¢‘ç³»ç»ŸAudioé©±åŠ¨æ€»ç»“â€“ALSA | Winddoingâ€™s Blogaudio HAL - ç‰§ å¤© - åšå®¢å›­æ—å­¦æ£®çš„Androidä¸“æ  - CSDNåšå®¢æ·±å…¥å‰–æAndroidéŸ³é¢‘ - CSDNåšå®¢Yangwen123æ’­æ”¾æ¡†æ¶ - æ ‡ç­¾ - Tocy - åšå®¢å›­Android-7.0-Nuplayeræ¦‚è¿° - CSDNåšå®¢Android-7.0-Nuplayer-å¯åŠ¨æµç¨‹ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-Nuplayerï¼ˆ1ï¼‰ - CSDNåšå®¢Android Media Player æ¡†æ¶åˆ†æ-AHandler AMessage ALooper - CSDNåšå®¢Android N Audioæ’­æ”¾ startçœŸé¢ç›®- (å…­ç¯‡) CSDNåšå®¢æ·±å…¥ç†è§£AndroidéŸ³è§†é¢‘åŒæ­¥æœºåˆ¶ï¼ˆäº”ç¯‡ï¼‰NuPlayerçš„avsyncé€»è¾‘ - CSDNåšå®¢wangyfçš„ä¸“æ  - CSDNåšå®¢-MT6737 Android N å¹³å° Audioç³»ç»Ÿå­¦ä¹ Android 7.0 Audio: Mediaplayer - CSDNåšå®¢Android 7.0 Audio-ç›¸å…³ç±»æµ…æ- CSDNåšå®¢Android N Audioæ’­æ”¾å…­ï¼šå¦‚ä½•è¯»å–buffer - CSDNåšå®¢Fuchsia OSä¸­çš„RPCæœºåˆ¶-FIDL - CSDNåšå®¢é«˜é€šAudioä¸­ASOCçš„codecé©±åŠ¨ - yooooooo - åšå®¢å›­","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Google Pixel Oreo 8.1 OPM2.171019.029 Root äº²æµ‹æˆåŠŸ [i.wonder~]","slug":"Google Pixel Oreo 8.1 OPM2.171019.029 Root äº²æµ‹æˆåŠŸ","date":"2018-04-19T16:00:00.000Z","updated":"2018-04-21T06:06:04.591Z","comments":true,"path":"2018/04/20/Google Pixel Oreo 8.1 OPM2.171019.029 Root äº²æµ‹æˆåŠŸ/","link":"","permalink":"http://zhoujinjian.cc/2018/04/20/Google Pixel Oreo 8.1 OPM2.171019.029 Root äº²æµ‹æˆåŠŸ/","excerpt":"","text":"Rootæ•™ç¨‹åŸæ–‡ Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP æ³¨æ„ï¼šâœ¢ ç”µæ± ç”µé‡é«˜äº80ï¼…ã€‚âœ¢ æ•°æ®ä¼šå®Œå…¨ä¸¢å¤±ä¸å¯æ¢å¤ï¼Œè¯·æå‰å¤‡ä»½æ‚¨çš„æ•°æ®ã€‚âœ¢ è§£é”ä½ çš„Bootloaderã€‚âœ¢ ä»…é™Google Pixel Oreo 8.1ã€‚âœ¢ ä»…é™å¥¥åˆ©å¥¥ç‰ˆæœ¬ã€‚âœ¢ ç¬”è€…æ‰‹æœºå¦‚å›¾ï¼š ä¸€ã€è§£é”Bootloaderåœ¨Google Pixel Oreo 8.1 OPM2.171019.029ä¸­è§£é”å¼•å¯¼åŠ è½½ç¨‹åºbootloader 1.1ã€OEMè§£é”è§£é”BootLoaderæ•™ç¨‹ Unlocking Bootloader in Google Pixel and Pixel XLâœ¢ ä¸‹è½½ï¼ˆWindowsï¼‰/ä¸‹è½½ï¼ˆMacï¼‰ç›¸åº”çš„ADBã€Fastbootã€é©±åŠ¨ç¨‹åºå¹¶å°†å…¶å®‰è£…åˆ°æ‚¨çš„ç³»ç»Ÿä¸­ã€‚âœ¢ è¿›å…¥ è®¾ç½®-&gt;å…³äºæ‰‹æœº è¿ç»­ç‚¹å‡»5æ¬¡ç‰ˆæœ¬å·ï¼Œç›´åˆ°æç¤ºâ€ä½ å·²å¤„äºå¼€å‘è€…æ¨¡å¼ï¼Œæ— éœ€è¿›è¡Œæ­¤æ“ä½œâ€âœ¢ ç‚¹å‡»è¿”å›è¿›å…¥ â€œå¼€å‘è€…æ¨¡å¼â€ æ‰“å¼€ â€œOEMè§£é”â€ å’Œ â€œUSBè°ƒè¯•â€âœ¢ è¿æ¥æ‰‹æœºï¼Œè‹¥å¼¹å‡ºæç¤ºæ¡†è¯·é€‰æ‹©æ˜¯/å…è®¸ï¼Œå‘½ä»¤è¡Œæ‰§è¡Œï¼šadb devicesï¼ŒæˆåŠŸä¼šæœ‰ä»¥ä¸‹ç±»ä¼¼æç¤º 1234List of devices attached* daemon not running; starting now at tcp:5037* daemon started successfullyFA7240301112 device âœ¢ å‘½ä»¤è¡Œæ‰§è¡Œï¼šadb reboot bootloaderâœ¢ æ‰§è¡Œï¼šfastboot oem unlockâœ¢ æ‚¨éœ€è¦é€šè¿‡å¢å¤§éŸ³é‡æŒ‰é’®æ¥ç¡®è®¤æ‰‹æœºä¸­çš„æ“ä½œã€‚æ‚¨å°†æˆåŠŸè§£é™¤æˆåŠŸæ¶ˆæ¯ã€‚å½“æ‚¨æ”¶åˆ°æ­¤æ¶ˆæ¯æ—¶ï¼Œè¯·æŒ‰éŸ³é‡é”®å¹¶å¯¼èˆªå¼€å§‹ï¼Œç„¶åæŒ‰ç”µæºæŒ‰é’®ã€‚æ‰‹æœºå°†é‡æ–°å¯åŠ¨ã€‚å¯åŠ¨ç¬¬ä¸€æ¬¡å¯åŠ¨éœ€è¦ä¸€äº›æ—¶é—´ã€‚âœ¢ è§£é”æˆåŠŸåœ¨å¼€æœºç•Œé¢ä¼šæœ‰ä¸€ä¸ªæ‰“å¼€çš„å°é”å›¾æ ‡ 1.2ã€å°†ç³»ç»Ÿå‡çº§åˆ°Oreo 8.1 OPM2.171019.029ç¨³å®šç‰ˆRoot Google Pixel Oreo 8.1 OPM2.171019.029ç¨³å®šçš„ç‰ˆæœ¬äº2018å¹´4æœˆå‘å¸ƒã€‚1ã€Sailfish-OPM2.171019.029ä¸‹è½½åœ°å€2ã€è§£å‹è¿è¡Œupdate-all.batï¼ˆWindowsï¼‰/ update-all.batï¼ˆMacï¼‰ 1.3ã€Root Pixel Oreo 8.1 OPM2.171019.029æœ‰å››ä¸ªæ­¥éª¤âœ¢ Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029âœ¢ Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0âœ¢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0âœ¢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0 äºŒã€Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029æ­¥éª¤ï¼š1ã€ç¡®ä¿ ç³»ç»ŸOEMè§£é”æˆåŠŸã€æ‰‹æœºç‰ˆæœ¬ä¸ºOreo 8.1 OPM2.171019.029ï¼Œç„¶åæ‰§è¡Œæ¥ä¸‹æ¥çš„æ“ä½œ2ã€ä¸‹è½½ twrp-3.2.1-2-sailfish.img Google Pixel Oreo 8.1 OPM2.171019.029çš„TWRPæ¢å¤é•œåƒ3ã€é€šè¿‡USBè¿æ¥æ‚¨çš„æ‰‹æœºï¼Œæ‰§è¡Œï¼šadb reboot bootloaderè¿›å…¥BootLoaderæ¨¡å¼ï¼ˆæˆ–è€…å…³æœºçŠ¶æ€ Poweré”®+éŸ³é‡ä¸‹é”®è¿›å…¥ï¼‰4ã€ç¡®ä¿æ‚¨çš„æ‰‹æœºå·²è¢«ç³»ç»Ÿæ£€æµ‹åˆ°ï¼Œæ‰§è¡Œï¼šfastboot devices ä¼šçœ‹åˆ°è®¾å¤‡å·5ã€fastboot boot twrp-3.2.1-2-sailfish.img6ã€é‡å¯è¿›å…¥ä¸‹ä¸€æ­¥æ“ä½œ ä¸‰ã€Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0æ­¥éª¤ï¼š1ã€ä¸‹è½½ twrp-pixel-installer-sailfish-3.1.1-0.zipï¼Œå°†æ‰‹æœºUSBä½¿ç”¨æ–¹å¼åˆ‡æ¢ä¸ºä¼ è¾“æ–‡ä»¶æ¨¡å¼ï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°æ‰‹æœºå­˜å‚¨æ ¹ç›®å½•2ã€å…³æ‰ä½ çš„æ‰‹æœº3ã€Poweré”®+éŸ³é‡ä¸‹é”®è¿›å…¥BootLoaderæ¨¡å¼æ¨¡å¼ ï¼Œç„¶åéŸ³é‡é”®é€‰æ‹© recovery modeï¼ŒæŒ‰poweré”®è¿›å…¥Recoveryæ¨¡å¼4ã€Select Wipe-&gt;Advance Wipe-&gt;Select Data5ã€è¿”å›åˆ°TWRPä¸»ç•Œé¢ï¼šselect Install6ã€Select twrp-pixel-installer-sailfish-3.1.1-0.zipå®‰è£…åé‡æ–°å¯åŠ¨æ‚¨çš„æ‰‹æœºã€‚ å››ã€Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0æ­¥éª¤ï¼š1ã€ä¸‹è½½ SR5-SuperSU-v2.82-SR5-20171001224502.zip å°†æ‰‹æœºUSBä½¿ç”¨æ–¹å¼åˆ‡æ¢ä¸ºä¼ è¾“æ–‡ä»¶æ¨¡å¼ï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°æ‰‹æœºå­˜å‚¨æ ¹ç›®å½•2ã€å…³æ‰ä½ çš„æ‰‹æœº3ã€Poweré”®+éŸ³é‡ä¸‹é”®è¿›å…¥BootLoaderæ¨¡å¼æ¨¡å¼ ï¼Œç„¶åéŸ³é‡é”®é€‰æ‹© recovery modeï¼ŒæŒ‰poweré”®è¿›å…¥Recoveryæ¨¡å¼4ã€Select Wipe-&gt;Advance Wipe-&gt;Select Data5ã€è¿”å›åˆ°TWRPä¸»ç•Œé¢ï¼šselect Install6ã€Select SR5-SuperSU-v2.82-SR5-20171001224502.zipå®‰è£…åé‡æ–°å¯åŠ¨æ‚¨çš„æ‰‹æœºã€‚ äº”ã€Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0æ­¥éª¤ï¼š1ã€ä¸‹è½½ Magisk-v16.1(1610).zip å°†æ‰‹æœºUSBä½¿ç”¨æ–¹å¼åˆ‡æ¢ä¸ºä¼ è¾“æ–‡ä»¶æ¨¡å¼ï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°æ‰‹æœºå­˜å‚¨æ ¹ç›®å½•2ã€å…³æ‰ä½ çš„æ‰‹æœº3ã€Poweré”®+éŸ³é‡ä¸‹é”®è¿›å…¥BootLoaderæ¨¡å¼æ¨¡å¼ ï¼Œç„¶åéŸ³é‡é”®é€‰æ‹© recovery modeï¼ŒæŒ‰poweré”®è¿›å…¥Recoveryæ¨¡å¼4ã€Select Wipe-&gt;Advance Wipe-&gt;Select Data5ã€è¿”å›åˆ°TWRPä¸»ç•Œé¢ï¼šselect Install6ã€Select Magisk-v16.1(1610).zipå®‰è£…åé‡æ–°å¯åŠ¨æ‚¨çš„æ‰‹æœºã€‚ å…­ã€å‡ºç°çš„é—®é¢˜ï¼ˆä¸€ï¼‰é—®é¢˜ï¼šadb å‡ºç° device offlineï¼Œæ›´æ–°adbç‰ˆæœ¬åˆ°1.0.39ï¼ˆäºŒï¼‰é—®é¢˜ï¼šç¬”è€…Pixelæ‰‹æœºæ‰§è¡Œä¸Šè¿°æ­¥éª¤åï¼Œæ— æ³•å¼€æœºï¼Œæ‰§è¡Œä»¥ä¸‹æ­¥éª¤å°±å¯ä»¥å¼€æœºäº†ï¼š1ã€å…³æ‰ä½ çš„æ‰‹æœº2ã€Poweré”®+éŸ³é‡ä¸‹é”®è¿›å…¥BootLoaderæ¨¡å¼æ¨¡å¼ï¼Œç„¶åéŸ³é‡é”®é€‰æ‹© recovery modeï¼ŒæŒ‰poweré”®è¿›å…¥Recoveryæ¨¡å¼3ã€Select Wipe-&gt;Advance Wipe-&gt;Select Data4ã€æ»‘åŠ¨æ¸…é™¤Data RootæˆåŠŸï¼Œ(oã‚œâ–½ã‚œ)oâ˜†[BINGO!] ä¸ƒã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„è¾›è‹¦å¥‰çŒ®)ï¼šè§£é”BootLoaderæ•™ç¨‹ Unlocking Bootloader in Google Pixel and Pixel XLRootæ•™ç¨‹åŸæ–‡ Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"ä¸ªäººç½‘ç«™(åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„çš„Loading gif) [i.wonder~]","slug":"ä¸ªäººç½‘ç«™(åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„çš„Loading gif)","date":"2018-04-02T16:00:00.000Z","updated":"2018-04-19T14:30:15.322Z","comments":true,"path":"2018/04/03/ä¸ªäººç½‘ç«™(åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„çš„Loading gif)/","link":"","permalink":"http://zhoujinjian.cc/2018/04/03/ä¸ªäººç½‘ç«™(åˆ†äº«ä¸€ä¸ªæœ‰è¶£çš„çš„Loading gif)/","excerpt":"","text":"ï¼ˆä¸€ï¼‰ã€ Loading gifï¼šèŒ¶ä¸æ€é¥­ä¸æƒ³ã€ä¸çœ ä¸å¤œæŠ˜è…¾è¿‘ä¸¤å‘¨ï¼Œæ€»ç®—æŠŠä¸ªäººç½‘ç«™æ­å»ºå¥½äº†(à¹‘ä¹›â—¡ä¹›à¹‘)ã€‚ ï¼ˆäºŒï¼‰ã€ä¸ªäººç½‘ç«™ï¼ˆzhoujinjian.ccï¼‰é—·éªšçš„ä¸»é¢˜ï¼Œæˆ‘æƒ³åŸºæœ¬ä¹Ÿä¸ä¼šæœ‰äººæ¥æµè§ˆæˆ‘çš„ä¸ªäººç½‘ç«™ï¼Œé—·éªšå°±é—·éªšç‚¹å§(à¹‘ä¹›â—¡ä¹›à¹‘)ï¼š ï¼ˆä¸‰ï¼‰ã€æ€»ç»“ä¸ªäººç½‘ç«™å…ˆæš‚æ—¶å‘Šä¸€æ®µè½äº†ï¼Œæ¥ä¸‹æ¥è¿˜æ˜¯ç»§ç»­è€æœ¬è¡Œåˆ†æAndroid æºä»£ç ï¼Œä¹‹å‰åˆ†æè™½å·²å¤§è‡´æ‰“é€š Appå±‚ -&gt; Frameworkå±‚ -&gt; Nativeå±‚ -&gt; Kernelå±‚ï¼Œå†’ä¼¼æœ‰ä¸€å®šç»éªŒäº†ç„¶å¹¶åµï¼Œè·¯æ¼«æ¼«å…¶ä¿®è¿œå…®ï¼Œç”Ÿå‘½ä¸æ¯ï¼Œå­¦æ— æ­¢å¢ƒï¼ˆå…¶å®å˜›å°±æ˜¯ -&gt; äººä¸‘å°±è¦å¤šè¯»ä¹¦à¹‘ä¹›â—¡ä¹›à¹‘ï¼‰ã€‚å¥½æƒ³è¯»è¯»ä¹¦å»çœ‹çœ‹å¤–é¢çš„ä¸–ç•Œå•Šã€‚ where you want to go-&gt;(Castelluccio di Norciaå¡æ–¯ç‰¹é²å¥‡å¥¥å…¬å›­,æ„å¤§åˆ©): Or-&gt;(Lofoten, Reinebringen(é›·è¨¥),æŒªå¨): PSï¼šå“‡å“¦ï¼Œå¥½ç¾ï¼Œç®—äº†æˆ‘å°±æƒ³æƒ³ï¼ˆà²¡Ï‰à²¡ï¼‰ã€‚ ï¼ˆå››ï¼‰ã€å‚è€ƒèµ„æ–™(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„è¾›è‹¦å¥‰çŒ®)ï¼šBing å£çº¸ APIApi-bing-wallpaperMrminfive - Hexo-theme-skappMolunerfinn - Hexo-theme-melodyStkevintan - canoe-blog(404) The page you were looking for doesnâ€™t exist","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoujinjian.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoujinjian.cc/tags/Hexo/"}]},{"title":"Linuxå†…æ ¸ï¼ˆKernel-3.18ï¼‰ - Linux Input å­ç³»ç»Ÿåˆ†æ [i.wonder~]","slug":"Linuxå†…æ ¸ï¼ˆKernel-3-18ï¼‰-Input-å­ç³»ç»Ÿåˆ†æ-i-wonder","date":"2018-03-31T16:00:00.000Z","updated":"2018-04-19T14:30:10.486Z","comments":true,"path":"2018/04/01/Linuxå†…æ ¸ï¼ˆKernel-3-18ï¼‰-Input-å­ç³»ç»Ÿåˆ†æ-i-wonder/","link":"","permalink":"http://zhoujinjian.cc/2018/04/01/Linuxå†…æ ¸ï¼ˆKernel-3-18ï¼‰-Input-å­ç³»ç»Ÿåˆ†æ-i-wonder/","excerpt":"","text":"ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ æºç ï¼ˆéƒ¨åˆ†ï¼‰ï¼š kernel/msm-3.18/include/linux Input.h evdev.h kernel/msm-3.18/drivers/input Input.c evdev.c gpio_keys.c kernel/msm-3.18/drivers/input/touchscreen/synaptics_dsx_htc_2.6 Makefile Kconfig synaptics_dsx_core.c ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ Google Pixelã€Pixel XL å†…æ ¸ä»£ç ï¼ˆKernel-3.18ï¼‰ï¼š Kernel source for Pixel and Pixel XL - Google Kernel source for Pixel and Pixel XL - GitHub ï¼ˆä¸€ï¼‰ã€Linux Input å­ç³»ç»Ÿæ¡†æ¶è¾“å…¥(Input)å­ç³»ç»Ÿæ˜¯åˆ†å±‚æ¶æ„çš„ï¼Œæ€»å…±åˆ†ä¸º5 å±‚ï¼Œä»ä¸Šåˆ°ä¸‹åˆ†åˆ«æ˜¯ï¼šç”¨æˆ·ç©ºé—´å±‚ï¼ˆUser Spaceï¼‰äº‹ä»¶å¤„ç†å±‚(Event Handler)ã€è¾“å…¥å­ç³»ç»Ÿæ ¸å¿ƒå±‚(Input Core)ã€ç¡¬ä»¶é©±åŠ¨å±‚(Input Driver) ã€ç¡¬ä»¶è®¾å¤‡å±‚ï¼ˆHardwareï¼‰ã€‚ é©±åŠ¨æ ¹æ®COREæä¾›çš„æ¥å£ï¼Œå‘ä¸ŠæŠ¥å‘Šå‘ç”Ÿçš„æŒ‰é”®åŠ¨ä½œã€‚ç„¶åCOREæ ¹æ®é©±åŠ¨çš„ç±»å‹ï¼Œåˆ†æ´¾è¿™ä¸ªæŠ¥å‘Šç»™å¯¹åº”çš„äº‹ä»¶å¤„ç†å±‚è¿›è¡Œå¤„ç†ã€‚äº‹ä»¶å¤„ç†å±‚æŠŠæ•°æ®å˜åŒ–ååº”åˆ°è®¾å¤‡æ¨¡å‹çš„æ–‡ä»¶ä¸­ï¼ˆäº‹ä»¶ç¼“å†²åŒºï¼‰ã€‚å¹¶é€šçŸ¥åœ¨è¿™äº›è®¾å¤‡æ¨¡å‹æ–‡ä»¶ä¸Šç­‰å¾…çš„è¿›ç¨‹ã€‚ inputå­ç³»ç»Ÿæ¡†æ¶ï¼š (1) â€œç¡¬ä»¶é©±åŠ¨å±‚â€è´Ÿè´£æ“ä½œå…·ä½“çš„ç¡¬ä»¶è®¾å¤‡ï¼Œè¿™å±‚çš„ä»£ç æ˜¯é’ˆå¯¹å…·ä½“çš„é©±åŠ¨ç¨‹åºçš„ï¼Œæ¯”å¦‚ä½ çš„è®¾å¤‡æ˜¯è§¦æ‘¸è¾“å…¥è®¾å¤‡ï¼Œè¿˜æ˜¯é¼ æ ‡è¾“å…¥è®¾å¤‡ï¼Œè¿˜æ˜¯é”®ç›˜è¾“å…¥è®¾å¤‡ï¼Œè¿™äº›ä¸åŒçš„è®¾å¤‡ï¼Œè‡ªç„¶æœ‰ä¸åŒçš„ç¡¬ä»¶æ“ä½œï¼Œé©±åŠ¨å·¥ç¨‹å¸ˆå¾€å¾€åªéœ€è¦å®Œæˆè¿™å±‚çš„ä»£ç ç¼–å†™ã€‚ (2) â€œè¾“å…¥å­ç³»ç»Ÿæ ¸å¿ƒå±‚â€æ˜¯é“¾æ¥å…¶ä»–ä¸¤å±‚ä¹‹é—´çš„çº½å¸¦ä¸æ¡¥æ¢ï¼Œå‘ä¸‹æä¾›ç¡¬ä»¶é©±åŠ¨å±‚çš„æ¥å£ï¼Œå‘ä¸Šæä¾›äº‹ä»¶å¤„ç†å±‚çš„æ¥å£ã€‚ (3) â€œäº‹ä»¶å¤„ç†å±‚â€ è´Ÿè´£ä¸ç”¨æˆ·ç¨‹åºæ‰“äº¤é“ï¼Œå°†ç¡¬ä»¶é©±åŠ¨å±‚ä¼ æ¥çš„äº‹ä»¶æŠ¥å‘Šç»™ç”¨æˆ·ç¨‹åºã€‚ å„å±‚ä¹‹é—´é€šä¿¡çš„åŸºæœ¬å•ä½å°±æ˜¯äº‹ä»¶ï¼Œä»»ä½•ä¸€ä¸ªè¾“å…¥è®¾å¤‡çš„åŠ¨ä½œéƒ½å¯ä»¥æŠ½è±¡æˆä¸€ç§äº‹ä»¶ï¼Œå¦‚é”®ç›˜çš„æŒ‰ä¸‹ï¼Œè§¦æ‘¸å±çš„æŒ‰ä¸‹ï¼Œé¼ æ ‡çš„ç§»åŠ¨ç­‰ã€‚äº‹ä»¶æœ‰ä¸‰ç§å±æ€§ï¼šç±»å‹ï¼ˆtypeï¼‰ï¼Œç¼–ç (code)ï¼Œå€¼(value)ï¼Œ Input å­ç³»ç»Ÿæ”¯æŒçš„æ‰€æœ‰äº‹ä»¶éƒ½å®šä¹‰åœ¨ input.hä¸­ï¼ŒåŒ…æ‹¬æ‰€æœ‰æ”¯æŒçš„ç±»å‹ï¼Œæ‰€å±ç±»å‹æ”¯æŒçš„ç¼–ç ç­‰ã€‚äº‹ä»¶ä¼ é€çš„æ–¹å‘æ˜¯ ç¡¬ä»¶é©±åŠ¨å±‚â€“&gt;å­ç³»ç»Ÿæ ¸å¿ƒâ€“&gt;äº‹ä»¶å¤„ç†å±‚â€“&gt;ç”¨æˆ·ç©ºé—´ã€‚ ï¼ˆäºŒï¼‰ã€Input ä¸»è¦é€šç”¨æ•°æ®ç»“æ„2.1ã€input_devè¾“å…¥è®¾å¤‡ input_devï¼Œè¿™æ˜¯inputè®¾å¤‡åŸºæœ¬çš„è®¾å¤‡ç»“æ„ï¼Œæ¯ä¸ªinputé©±åŠ¨ç¨‹åºä¸­éƒ½å¿…é¡»åˆ†é…åˆå§‹åŒ–è¿™æ ·ä¸€ä¸ªç»“æ„ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071[-&gt;input.h]struct input_dev &#123; const char *name; //è¾“å…¥è®¾å¤‡çš„åç§° const char *phys; //è¾“å…¥è®¾å¤‡èŠ‚ç‚¹åç§° const char *uniq; //æŒ‡å®šå”¯ä¸€çš„IDå·ï¼Œå°±åƒMACåœ°å€ä¸€æ · struct input_id id; //è¾“å…¥è®¾å¤‡æ ‡è¯†IDï¼Œç”¨äºå’Œäº‹ä»¶å¤„ç†å±‚è¿›è¡ŒåŒ¹é… unsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; unsigned long evbit[BITS_TO_LONGS(EV_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„äº‹ä»¶ç±»å‹ unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„æŒ‰é”®ç±»å‹ unsigned long relbit[BITS_TO_LONGS(REL_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„ç›¸å¯¹åæ ‡ unsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„ç»å¯¹åæ ‡ unsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„å…¶ä»–åŠŸèƒ½ unsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„æŒ‡ç¤ºç¯ unsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„å£°éŸ³æˆ–è­¦æŠ¥ unsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„ä½œç”¨åŠ›åŠŸèƒ½ unsigned long swbit[BITS_TO_LONGS(SW_CNT)]; //ä½å›¾ï¼Œè®°å½•è®¾å¤‡æ”¯æŒçš„å¼€å…³åŠŸèƒ½ unsigned int hint_events_per_packet; unsigned int keycodemax; //è®¾å¤‡æ”¯æŒçš„æœ€å¤§æŒ‰é”®å€¼ä¸ªæ•° unsigned int keycodesize; //æ¯ä¸ªæŒ‰é”®çš„å­—èŠ‚å¤§å° void *keycode; //æŒ‡å‘æŒ‰é”®æ± ï¼Œå³æŒ‡å‘æŒ‰é”®å€¼æ•°ç»„é¦–åœ°å€ int (*setkeycode)(struct input_dev *dev, const struct input_keymap_entry *ke, unsigned int *old_keycode); //ä¿®æ”¹æŒ‰é”®å€¼ int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke); //è·å–æŒ‰é”®å€¼ struct ff_device *ff; //ç”¨äºå¼ºåˆ¶æ›´æ–°è¾“å…¥è®¾å¤‡çš„éƒ¨åˆ†å†…å®¹ unsigned int repeat_key; //é‡å¤æŒ‰é”®çš„é”®å€¼ struct timer_list timer; //è®¾ç½®å½“æœ‰è¿å‡»æ—¶çš„å»¶æ—¶å®šæ—¶å™¨ int rep[REP_CNT]; struct input_mt *mt; struct input_absinfo *absinfo; unsigned long key[BITS_TO_LONGS(KEY_CNT)]; //ä½å›¾ï¼ŒæŒ‰é”®çš„çŠ¶æ€ unsigned long led[BITS_TO_LONGS(LED_CNT)]; //ä½å›¾ï¼Œledçš„çŠ¶æ€ unsigned long snd[BITS_TO_LONGS(SND_CNT)]; //ä½å›¾ï¼Œå£°éŸ³çš„çŠ¶æ€ unsigned long sw[BITS_TO_LONGS(SW_CNT)]; //ä½å›¾ï¼Œå¼€å…³çš„çŠ¶æ€ int (*open)(struct input_dev *dev); void (*close)(struct input_dev *dev); int (*flush)(struct input_dev *dev, struct file *file); int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); struct input_handle __rcu *grab; //ç±»ä¼¼ç§æœ‰æŒ‡é’ˆï¼Œå¯ä»¥ç›´æ¥è®¿é—®åˆ°äº‹ä»¶å¤„ç†æ¥å£event spinlock_t event_lock; struct mutex mutex; unsigned int users; bool going_away; struct device dev; struct list_head h_list; //è¯¥é“¾è¡¨å¤´ç”¨äºé“¾æ¥æ­¤è®¾å¤‡æ‰€å…³è”çš„input_handle struct list_head node; //ç”¨äºå°†æ­¤è®¾å¤‡é“¾æ¥åˆ°input_dev_list(é“¾æ¥äº†æ‰€æœ‰æ³¨å†Œåˆ°å†…æ ¸çš„äº‹ä»¶å¤„ç†å™¨) unsigned int num_vals; unsigned int max_vals; struct input_value *vals; bool devres_managed;&#125;; 2.1ã€input_handlerinput_handler è¿™æ˜¯äº‹ä»¶å¤„ç†å™¨çš„æ•°æ®ç»“æ„ï¼Œä»£è¡¨ä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨ 12345678910111213141516171819202122232425262728293031[-&gt;input.h]struct input_handler &#123; void *private; /* å½“äº‹ä»¶å¤„ç†å™¨æ¥æ”¶åˆ°æ¥è‡ªInputè®¾å¤‡ä¼ æ¥çš„äº‹ä»¶æ—¶è°ƒç”¨çš„å¤„ç†å‡½æ•°, eventã€eventsç”¨äºå¤„ç†äº‹ä»¶ */ void (*event)(struct input_handle *handle, unsigned int type, unsigned int code, int value); void (*events)(struct input_handle *handle, const struct input_value *vals, unsigned int count); bool (*filter)(struct input_handle *handle, unsigned int type, unsigned int code, int value); /* æ¯”è¾ƒ device's id with handler's id_table ï¼ŒåŒ¹é…device and handler*/ bool (*match)(struct input_handler *handler, struct input_dev *dev); /* connectç”¨äºå»ºç«‹intput_handlerå’Œinput_devçš„è”ç³», å½“ä¸€ä¸ªInputè®¾å¤‡æ³¨å†Œåˆ°å†…æ ¸çš„æ—¶å€™è¢«è°ƒç”¨,å°†è¾“å…¥è®¾å¤‡ä¸äº‹ä»¶å¤„ç†å™¨è”ç»“èµ·æ¥ */ int (*connect)(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id); /* disconnectç”¨äºè§£é™¤handlerå’Œdeviceçš„è”ç³» */ void (*disconnect)(struct input_handle *handle); void (*start)(struct input_handle *handle); bool legacy_minors; int minor; //æ¬¡è®¾å¤‡å· const char *name; //æ¬¡è®¾å¤‡å· const struct input_device_id *id_table; //ç”¨äºå’ŒdeviceåŒ¹é… ,è¿™ä¸ªæ˜¯äº‹ä»¶å¤„ç†å™¨æ‰€æ”¯æŒçš„inputè®¾å¤‡ //è¿™ä¸ªé“¾è¡¨ç”¨æ¥é“¾æ¥ä»–æ‰€æ”¯æŒçš„input_handleç»“æ„,input_devä¸input_handleré…å¯¹ä¹‹åå°±ä¼šç”Ÿæˆä¸€ä¸ªinput_handleç»“æ„ struct list_head h_list; //é“¾æ¥åˆ°input_handler_listï¼Œè¿™ä¸ªé“¾è¡¨é“¾æ¥äº†æ‰€æœ‰æ³¨å†Œåˆ°å†…æ ¸çš„äº‹ä»¶å¤„ç†å™¨ struct list_head node;&#125;; 2.3ã€input_handle123456789101112131415161718192021222324[-&gt;input.h]struct input_handle &#123; /* æ¯ä¸ªé…å¯¹çš„äº‹ä»¶å¤„ç†å™¨éƒ½ä¼šåˆ†é…ä¸€ä¸ªå¯¹åº”çš„è®¾å¤‡ç»“æ„ï¼Œå¦‚evdeväº‹ä»¶å¤„ç†å™¨çš„evdevç»“æ„ï¼Œ æ³¨æ„è¿™ä¸ªç»“æ„ä¸è®¾å¤‡é©±åŠ¨å±‚çš„input_devä¸åŒï¼Œåˆå§‹åŒ–handleæ—¶ï¼Œä¿å­˜åˆ°è¿™é‡Œã€‚ */ void *private; /* æ‰“å¼€æ ‡å¿—ï¼Œæ¯ä¸ªinput_handle æ‰“å¼€åæ‰èƒ½æ“ä½œï¼Œ è¿™ä¸ªä¸€èˆ¬é€šè¿‡äº‹ä»¶å¤„ç†å™¨çš„openæ–¹æ³•é—´æ¥è®¾ç½® */ int open; const char *name; /* æŒ‡å‘Input_devç»“æ„å®ä½“ */ struct input_dev *dev; /* æŒ‡å‘Input_Handerç»“æ„å®ä½“ */ struct input_handler *handler; /* input_handleé€šè¿‡d_nodeè¿æ¥åˆ°äº†input_devä¸Šçš„h_listé“¾è¡¨ä¸Š */ struct list_head d_node; /* input_handleé€šè¿‡h_nodeè¿æ¥åˆ°äº†input_handlerçš„h_listé“¾è¡¨ä¸Š */ struct list_head h_node;&#125;; 2.4ã€ä¸‰ä¸ªæ•°æ®ç»“æ„ä¹‹é—´çš„å…³ç³» input_dev: æ˜¯ç¡¬ä»¶é©±åŠ¨å±‚ï¼Œä»£è¡¨ä¸€ä¸ªinputè®¾å¤‡ã€‚ input_handler: æ˜¯äº‹ä»¶å¤„ç†å±‚ï¼Œä»£è¡¨ä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨ã€‚ input_handle: å±äºæ ¸å¿ƒå±‚ï¼Œä»£è¡¨ä¸€ä¸ªé…å¯¹çš„input_devä¸input_handler input_dev é€šè¿‡å…¨å±€çš„input_dev_listé“¾æ¥åœ¨ä¸€èµ·ã€‚è®¾å¤‡æ³¨å†Œçš„æ—¶å€™å®ç°è¿™ä¸ªæ“ä½œã€‚æ³¨ï¼šï¼ˆç¨åè¯¦ç»†åˆ†æï¼‰ 1234567891011121314151617181920[-&gt;input.c]static LIST_HEAD(input_dev_list);static LIST_HEAD(input_handler_list);int input_register_device(struct input_dev *dev)&#123; struct input_devres *devres = NULL; struct input_handler *handler; unsigned int packet_size; const char *path; int error; ...... list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); list_for_each_entry(handler, &amp;input_handler_list, node) input_attach_handler(dev, handler); ......&#125; input_handler é€šè¿‡å…¨å±€çš„input_handler_listé“¾æ¥åœ¨ä¸€èµ·ã€‚äº‹ä»¶å¤„ç†å™¨æ³¨å†Œçš„æ—¶å€™å®ç°è¿™ä¸ªæ“ä½œï¼ˆäº‹ä»¶å¤„ç†å™¨ä¸€èˆ¬å†…æ ¸è‡ªå¸¦ï¼Œä¸€èˆ¬ä¸éœ€è¦æˆ‘ä»¬æ¥å†™ï¼‰æ³¨ï¼šï¼ˆç¨åè¯¦ç»†åˆ†æï¼‰ 12345678910111213141516[-&gt;input.c]static LIST_HEAD(input_dev_list);static LIST_HEAD(input_handler_list);int input_register_handler(struct input_handler *handler)&#123; struct input_dev *dev; int error; ...... list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); list_for_each_entry(dev, &amp;input_dev_list, node) input_attach_handler(dev, handler); ...... return 0;&#125; input_hande æ²¡æœ‰ä¸€ä¸ªå…¨å±€çš„é“¾è¡¨ï¼Œå®ƒæ³¨å†Œçš„æ—¶å€™å°†è‡ªå·±åˆ†åˆ«æŒ‚åœ¨äº†input_dev å’Œ input_handler çš„h_listä¸Šäº†ã€‚é€šè¿‡input_dev å’Œinput_handlerå°±å¯ä»¥æ‰¾åˆ°input_handleåœ¨è®¾å¤‡æ³¨å†Œå’Œäº‹ä»¶å¤„ç†å™¨ï¼Œæ³¨å†Œçš„æ—¶å€™éƒ½è¦è¿›è¡Œé…å¯¹å·¥ä½œ(input_match_device)ï¼Œé…å¯¹åå°±ä¼šå®ç°é“¾æ¥(handler-&gt;connect)é€šè¿‡input_handleä¹Ÿå¯ä»¥æ‰¾åˆ°input_devå’Œinput_handlerã€‚æ³¨ï¼šï¼ˆç¨åè¯¦ç»†åˆ†æï¼‰ 123456789101112[-&gt;input.c]static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)&#123; const struct input_device_id *id; int error; id = input_match_device(handler, dev); ...... error = handler-&gt;connect(handler, dev, id); ...... return error;&#125; æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œinput_deviceå’Œinput_handlerä¸­éƒ½æœ‰ä¸€ä¸ªh_list,è€Œinput_handleæ‹¥æœ‰æŒ‡å‘input_devå’Œinput_handlerçš„æŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯è¯´input_handleæ˜¯ç”¨æ¥å…³è”input_devå’Œinput_handlerçš„ã€‚ é‚£ä¹ˆä¸ºä»€ä¹ˆä¸€ä¸ªinput_deviceå’Œinput_handlerä¸­æ‹¥æœ‰çš„æ˜¯h_listè€Œä¸æ˜¯ä¸€ä¸ªhandleå‘¢ï¼Ÿå› ä¸ºä¸€ä¸ªdeviceå¯èƒ½å¯¹åº”å¤šä¸ªhandler,è€Œä¸€ä¸ªhandlerä¹Ÿä¸èƒ½åªå¤„ç†ä¸€ä¸ªdevice,æ¯”å¦‚è¯´ä¸€ä¸ªé¼ æ ‡ï¼Œå®ƒå¯ä»¥å¯¹åº”even handlerï¼Œä¹Ÿå¯ä»¥å¯¹åº”mouse handler,å› æ­¤å½“å…¶æ³¨å†Œæ—¶ä¸ç³»ç»Ÿä¸­çš„handlerè¿›è¡ŒåŒ¹é…ï¼Œå°±æœ‰å¯èƒ½äº§ç”Ÿä¸¤ä¸ªå®ä¾‹ï¼Œä¸€ä¸ªæ˜¯evdev,å¦ä¸€ä¸ªæ˜¯mousedev,è€Œä»»ä½•ä¸€ä¸ªå®ä¾‹ä¸­éƒ½åªæœ‰ä¸€ä¸ªhandleã€‚è‡³äºä»¥ä½•ç§æ–¹å¼æ¥ä¼ é€’äº‹ä»¶ï¼Œå°±ç”±ç”¨æˆ·ç¨‹åºæ‰“å¼€å“ªä¸ªå®ä¾‹æ¥å†³å®šã€‚åé¢ä¸€ä¸ªæƒ…å†µå¾ˆå®¹æ˜“ç†è§£ï¼Œä¸€ä¸ªäº‹ä»¶é©±åŠ¨ä¸èƒ½åªä¸ºä¸€ä¸ªç”šè‡³ä¸€ç§è®¾å¤‡æœåŠ¡ï¼Œç³»ç»Ÿä¸­å¯èƒ½æœ‰å¤šç§è®¾å¤‡éƒ½èƒ½ä½¿ç”¨è¿™ç±»handler,æ¯”å¦‚event handlerå°±å¯ä»¥åŒ¹é…æ‰€æœ‰çš„è®¾å¤‡ã€‚åœ¨inputå­ç³»ç»Ÿä¸­ï¼Œæœ‰8ç§äº‹ä»¶é©±åŠ¨ï¼Œæ¯ç§äº‹ä»¶é©±åŠ¨æœ€å¤šå¯ä»¥å¯¹åº”32ä¸ªè®¾å¤‡ï¼Œå› æ­¤devå®ä¾‹æ€»æ•°æœ€å¤šå¯ä»¥è¾¾åˆ°256ä¸ªã€‚ ï¼ˆä¸‰ï¼‰ã€Input æ ¸å¿ƒå±‚ï¼ˆInput.cï¼‰è¿™ä¸€èŠ‚ä¸»è¦ä»‹ç»æ ¸å¿ƒå±‚çš„åˆå§‹åŒ–ï¼Œinput_deviceã€input_handleã€input_handlerä¹‹é—´çš„å…³ç³»(ç¨åå›å¤´çœ‹æ›´ä½³)ã€‚ æ€»ä½“æ¦‚è§ˆå›¾ï¼š 3.1ã€è¾“å…¥æ ¸å¿ƒå±‚ï¼šåˆå§‹åŒ–é¦–å…ˆä»é©±åŠ¨â€å…¥å£å‡½æ•°â€å¼€å§‹æŸ¥çœ‹ 1234567891011121314151617[-&gt;input.c]static int __init input_init(void)&#123; int err; //æ³¨å†Œinputç±»ï¼Œå¯åœ¨/sys/classä¸‹çœ‹åˆ°å¯¹åº”èŠ‚ç‚¹æ–‡ä»¶ err = class_register(&amp;input_class); ...... err = input_proc_init();/*åˆ›å»º/procä¸­çš„é¡¹ï¼ŒæŸ¥çœ‹/proc/bus/input */ ...... /*æ³¨å†Œè®¾å¤‡/dev/inputï¼Œä¸»è®¾å¤‡å·ä¸ºINPUT_MAJORï¼Œå°±æ˜¯13ï¼Œåé¢æ³¨å†Œçš„è¾“å…¥è®¾å¤‡éƒ½ä½¿ç”¨è¯¥ä¸»è®¾å¤‡å·*/ err = register_chrdev_region(MKDEV(INPUT_MAJOR, 0), INPUT_MAX_CHAR_DEVICES, \"input\"); ...... return 0; ...... return err;&#125; åœ¨å…¥å£å‡½æ•°é‡Œé¢åˆ›å»ºäº†ä¸€ä¸ªinput_classç±»ï¼Œå…¶å®å°±åœ¨/sys/classä¸‹åˆ›å»ºäº†ä¸€ä¸ªç›®å½•input.å½“ç„¶å¯¹äºä¸€ä¸ªæ–°è®¾å¤‡ï¼Œå¯ä»¥æ³¨å†Œè¿›ä¸€ä¸ªclassä¹Ÿå¯ä»¥ä¸æ³¨å†Œè¿›å»ï¼Œå¦‚æœå­˜åœ¨å¯¹åº”classçš„è¯æ³¨å†Œè¿›å»æ›´å¥½ï¼Œå¦å¤–åœ¨/procåˆ›å»ºäº†å…¥å£é¡¹,è¿™æ ·å°±å¯ä»¥/procç›®å½•çœ‹åˆ°inputçš„ä¿¡æ¯ï¼Œç„¶åå°±æ³¨å†Œè®¾å¤‡ï¼Œå¯ä»¥çœ‹å‡ºè¾“å…¥å­ç³»ç»Ÿçš„ä¸»è®¾å¤‡å·æ˜¯13ï¼Œåœ¨è¿™é‡Œå¹¶æ²¡æœ‰ç”Ÿæˆè®¾å¤‡æ–‡ä»¶ã€‚åªæ˜¯åœ¨/dev/ç›®å½•ä¸‹åˆ›å»ºäº†inputç›®å½•ï¼Œä»¥åæ‰€æœ‰æ³¨å†Œè¿›ç³»ç»Ÿçš„è¾“å…¥è®¾å¤‡æ–‡ä»¶éƒ½æ”¾åœ¨è¿™ä¸ªç›®å½•ä¸‹ã€‚ ç›¸åº”çš„å¯¹åº”å…³ç³»å¯ä»¥ä½¿ç”¨adb å‘½ä»¤è¿›å…¥æ–‡ä»¶ç³»ç»Ÿä¹‹åï¼Œcat /proc/bus/input/devices ï¼ŒæŸ¥çœ‹å„ä¸ªè®¾å¤‡å¯¹åº”çš„eventå¤šå°‘ï¼Œæ¯”å¦‚Google Pixel æ‰‹æœºï¼š 12345678910I: Bus=0000 Vendor=0000 Product=0003 Version=2066N: Name=\"synaptics_dsxv26\"P: Phys=synaptics_dsx/touch_inputS: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3U: Uniq=H: Handlers=mdss_fb kgsl event3B: PROP=2B: EV=bB: KEY=8000 0 0B: ABS=663800000000000 event3 å°±æ˜¯äº‹ä»¶åºå·ï¼Œ æˆ‘ä»¬åœ¨è°ƒè¯•çš„æ—¶å€™ç›´æ¥ adb shell getevent /dev/input/event3ï¼Œæ¥å®æ—¶æ•æ‰ event3 ä¸­å‚¨å­˜çš„æ•°æ®ã€‚ é‚£ä¹ˆæ¥ä¸‹æ¥çœ‹çœ‹æ€ä¹ˆæ³¨å†Œinputè®¾å¤‡çš„.æˆ‘ä»¬éœ€è¦åœ¨è®¾å¤‡é©±åŠ¨å±‚ä¸­å®Œæˆè¾“å…¥è®¾å¤‡çš„æ³¨å†Œï¼Œé€šè¿‡è°ƒç”¨input_register_device()å‡½æ•°æ¥å®Œæˆï¼Œè¯¥å‡½æ•°çš„ä¸€ä¸ªé‡è¦ä»»åŠ¡å°±æ˜¯å®Œæˆè®¾å¤‡ä¸äº‹ä»¶é©±åŠ¨çš„åŒ¹é… 3.2ã€è¾“å…¥æ ¸å¿ƒå±‚ï¼šæ³¨å†Œè®¾å¤‡input_dev123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384[-&gt;input.c]int input_register_device(struct input_dev *dev)&#123; struct input_devres *devres = NULL; struct input_handler *handler; unsigned int packet_size; const char *path; int error; if (dev-&gt;devres_managed) &#123; devres = devres_alloc(devm_input_device_unregister, sizeof(struct input_devres), GFP_KERNEL); ...... devres-&gt;input = dev; &#125; //EN_SYNè¿™ä¸ªæ˜¯è®¾å¤‡éƒ½è¦æ”¯æŒçš„äº‹ä»¶ç±»å‹ï¼Œæ‰€ä»¥è¦è®¾ç½® /* Every input device generates EV_SYN/SYN_REPORT events. */ __set_bit(EV_SYN, dev-&gt;evbit); /* KEY_RESERVED is not supposed to be transmitted to userspace. */ __clear_bit(KEY_RESERVED, dev-&gt;keybit); /* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */ input_cleanse_bitmasks(dev); packet_size = input_estimate_events_per_packet(dev); if (dev-&gt;hint_events_per_packet &lt; packet_size) dev-&gt;hint_events_per_packet = packet_size; dev-&gt;max_vals = dev-&gt;hint_events_per_packet + 2; dev-&gt;vals = kcalloc(dev-&gt;max_vals, sizeof(*dev-&gt;vals), GFP_KERNEL); ...... /* * If delay and period are pre-set by the driver, then autorepeating * is handled by the driver itself and we don't do it in input.c. */ // è¿™ä¸ªå®šæ—¶å™¨æ˜¯ä¸ºäº†é‡å¤æŒ‰é”®è€Œè®¾ç½®çš„ if (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123; dev-&gt;timer.data = (long) dev; dev-&gt;timer.function = input_repeat_key; dev-&gt;rep[REP_DELAY] = 250; dev-&gt;rep[REP_PERIOD] = 33; &#125; /* å¦‚æœè®¾å¤‡é©±åŠ¨æ²¡æœ‰è®¾ç½®è‡ªå·±çš„è·å–é”®å€¼çš„å‡½æ•°ï¼Œç³»ç»Ÿé»˜è®¤ */ if (!dev-&gt;getkeycode) dev-&gt;getkeycode = input_default_getkeycode; /* å¦‚æœè®¾å¤‡é©±åŠ¨æ²¡æœ‰æŒ‡å®šæŒ‰é”®é‡ç½®å‡½æ•°ï¼Œç³»ç»Ÿé»˜è®¤ */ if (!dev-&gt;setkeycode) dev-&gt;setkeycode = input_default_setkeycode; error = device_add(&amp;dev-&gt;dev); ...... path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL); pr_info(\"%s as %s\\n\", dev-&gt;name ? dev-&gt;name : \"Unspecified device\", path ? path : \"N/A\"); kfree(path); error = mutex_lock_interruptible(&amp;input_mutex); ...... // å°†æ–°åˆ†é…çš„inputè®¾å¤‡è¿æ¥åˆ°input_dev_listé“¾è¡¨ä¸Š list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list); /* æ ¸å¿ƒé‡ç‚¹ï¼Œinputè®¾å¤‡åœ¨å¢åŠ åˆ°input_dev_listé“¾è¡¨ä¸Šä¹‹åï¼Œä¼šæŸ¥æ‰¾ * input_handler_listäº‹ä»¶å¤„ç†é“¾è¡¨ä¸Šçš„handlerè¿›è¡ŒåŒ¹é…ï¼Œè¿™é‡Œçš„åŒ¹é… * æ–¹å¼ä¸è®¾å¤‡æ¨¡å‹çš„deviceå’ŒdriveråŒ¹é…è¿‡ç¨‹å¾ˆç›¸ä¼¼ï¼Œæ‰€æœ‰çš„input * éƒ½æŒ‚åœ¨input_dev_listä¸Šï¼Œæ‰€æœ‰ç±»å‹çš„äº‹ä»¶éƒ½æŒ‚åœ¨input_handler_list * ä¸Šï¼Œè¿›è¡Œâ€œåŒ¹é…ç›¸äº²â€ï¼Œlist_for_each_entryå°±æ˜¯ä¸ªforå¾ªç¯ï¼Œè·³å‡ºæ¡ä»¶éå†äº†ä¸€éï¼Œåˆå›åˆ°é“¾è¡¨å¤´ */ list_for_each_entry(handler, &amp;input_handler_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); if (dev-&gt;devres_managed) &#123; dev_dbg(dev-&gt;dev.parent, \"%s: registering %s with devres.\\n\", __func__, dev_name(&amp;dev-&gt;dev)); devres_add(dev-&gt;dev.parent, devres); &#125; return 0;......&#125; ä¸Šé¢çš„ä»£ç ä¸»è¦çš„åŠŸèƒ½æœ‰ä»¥ä¸‹å‡ ä¸ªåŠŸèƒ½ï¼Œä¹Ÿæ˜¯è®¾å¤‡é©±åŠ¨æ³¨å†Œä¸ºè¾“å…¥è®¾å¤‡å§”æ‰˜å†…æ ¸åšçš„äº‹æƒ…ï¼š 1ã€è¿›ä¸€æ­¥åˆå§‹åŒ–è¾“å…¥è®¾å¤‡ï¼Œä¾‹å¦‚è¿å‡»äº‹ä»¶ 2ã€æ³¨å†Œè¾“å…¥è®¾å¤‡åˆ°inputç±»ä¸­ï¼ŒæŠŠè¾“å…¥è®¾å¤‡æŒ‚åˆ°è¾“å…¥è®¾å¤‡é“¾è¡¨input_dev_listä¸­ 3ã€æŸ¥æ‰¾å¹¶åŒ¹é…è¾“å…¥è®¾å¤‡å¯¹åº”çš„äº‹ä»¶å¤„ç†å±‚ï¼Œé€šè¿‡input_handler_listé“¾è¡¨ æˆ‘ä»¬éœ€è¦å†åˆ†æä¸‹è¿™ä¸ªåŒ¹é…çš„è¿‡ç¨‹ï¼Œinput_attach_handler()åŒ¹é…è¿‡ç¨‹å¦‚ä¸‹ï¼š 12345678910111213[-&gt;input.c]static int input_attach_handler(struct input_dev *dev, struct input_handler *handler)&#123; const struct input_device_id *id; int error; /* input_dev å’Œ input_handler è¿›è¡ŒåŒ¹é…,è¿”å›åŒ¹é…çš„idï¼Œç±»å‹æ˜¯struct input_device_id */ id = input_match_device(handler, dev); ...... /* åŒ¹é…æˆåŠŸï¼Œè°ƒç”¨handleré‡Œé¢çš„connectå‡½æ•°,è¿™ä¸ªå‡½æ•°åœ¨äº‹ä»¶å¤„ç†å™¨ä¸­å®šä¹‰ï¼Œä¸»è¦ç”Ÿæˆä¸€ä¸ªinput_handleç»“æ„ï¼Œå¹¶åˆå§‹åŒ–ï¼Œè¿˜ç”Ÿæˆä¸€ä¸ªäº‹ä»¶å¤„ç†å™¨ç›¸å…³çš„è®¾å¤‡ç»“æ„ */ error = handler-&gt;connect(handler, dev, id); ...... return error;&#125; æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹input_match_deviceï¼ˆï¼‰å‡½æ•°ï¼Œçœ‹ä¸€ä¸‹è¿™ä¸ªåŒ¹é…çš„æ¡ä»¶æ˜¯ä»€ä¹ˆï¼Œå¦‚ä½•åŒ¹é…çš„è¿‡ç¨‹æ˜¯æ€æ ·çš„ï¼ŒåŒ¹é…çš„ç»“æœä¼šæ˜¯ä»€ä¹ˆ 12345678910111213141516171819202122232425262728293031323334353637[-&gt;input.c]static const struct input_device_id *input_match_device(struct input_handler *handler, struct input_dev *dev)&#123; const struct input_device_id *id; for (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS) if (id-&gt;bustype != dev-&gt;id.bustype) //åŒ¹é…æ€»çº¿id continue; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR) if (id-&gt;vendor != dev-&gt;id.vendor) //åŒ¹é…ç”Ÿäº§å•†id continue; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT) if (id-&gt;product != dev-&gt;id.product) //åŒ¹é…äº§å“id continue; if (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION) if (id-&gt;version != dev-&gt;id.version) //åŒ¹é…ç‰ˆæœ¬ continue; //åŒ¹é…idçš„evbitå’Œinput_devä¸­evbitçš„å„ä¸ªä½ï¼Œå¦‚æœä¸åŒ¹é…åˆ™continueï¼Œæ•°ç»„ä¸­ä¸‹ä¸€ä¸ªè®¾å¤‡ if (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX)) continue; ...... if (!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX)) continue; if (!handler-&gt;match || handler-&gt;match(handler, dev)) return id;//åŒ¹é…æˆåŠŸ,è¿”å›id &#125; return NULL;&#125; input_match_device() åˆ°æœ€åˆé€‚çš„äº‹ä»¶å¤„ç†å±‚é©±åŠ¨æ—¶ï¼Œä¾¿æ‰§è¡Œhandler-&gt;connect() å‡½æ•°è¿›è¡Œè¿æ¥äº†ï¼Œçœ‹ä¸‹é¢è¿™éƒ¨åˆ†ä»£ç ï¼ˆä»¥evdevç±»å‹é©±åŠ¨ä¸ºä¾‹ï¼Œåœ¨input/evdev.cä¸­ï¼‰ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253[-&gt;evdev.c]static int evdev_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)&#123; struct evdev *evdev; int minor; int dev_no; int error; /* EVDEV_MINORSä¸º32ï¼Œä»£è¡¨å…±èƒ½å®¹çº³32ä¸ªevdeväº‹ä»¶å±‚è®¾å¤‡ï¼Œä¸‹é¢ä»£ç åœ¨æ‰¾åˆ°ç©ºçš„åœ°æ–¹ï¼Œç”¨äºä¿å­˜evdeväº‹ä»¶å±‚çš„æ•°æ®ï¼Œå³ä¸Šé¢å®šä¹‰çš„evdev */ minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, true); ...... /* å¼€å§‹ç»™evdeväº‹ä»¶å±‚é©±åŠ¨åˆ†é…ç©ºé—´äº† */ evdev = kzalloc(sizeof(struct evdev), GFP_KERNEL); ...... /* åˆå§‹åŒ–client_liståˆ—è¡¨å’Œevdev_waité˜Ÿåˆ—ï¼Œåé¢ä»‹ç» */ INIT_LIST_HEAD(&amp;evdev-&gt;client_list); spin_lock_init(&amp;evdev-&gt;client_lock); mutex_init(&amp;evdev-&gt;mutex); init_waitqueue_head(&amp;evdev-&gt;wait); evdev-&gt;exist = true; /* åˆå§‹åŒ–evdevç»“æ„ä½“ï¼Œå…¶ä¸­handleä¸ºè¾“å…¥è®¾å¤‡å’Œäº‹ä»¶å¤„ç†çš„å…³è”æ¥å£ */ dev_no = minor; /* Normalize device number if it falls into legacy range */ if (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS) dev_no -= EVDEV_MINOR_BASE; dev_set_name(&amp;evdev-&gt;dev, \"event%d\", dev_no); /*è¿™é‡Œå°±å°†handleçš„devæŒ‡é’ˆæŒ‡å‘äº†input_dev*/ evdev-&gt;handle.dev = input_get_device(dev); evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev); evdev-&gt;handle.handler = handler;/*è¿™é‡Œå°†handleçš„handleræŒ‡å‘äº†å½“å‰çš„input_handler.æ³¨æ„æœ¬å‡½æ•°evdev_connect,å¯èƒ½æ˜¯åœ¨åœ¨è¾“å…¥è®¾å¤‡æ³¨å†Œçš„æ—¶å€™38 åœ¨input_register_deviceå‡½æ•°ä¸­è°ƒç”¨input_attach_handlerçš„æ—¶å€™è°ƒç”¨;ä¹Ÿå¯èƒ½æ˜¯åœ¨è¾“å…¥è®¾å¤‡çš„å¤„ç†æ–¹æ³•input_handleræ—¶åœ¨input_register_handler39 å‡½æ•°ä¸­ä¹Ÿä¼šç”¨åˆ°input_attach_handlerå‡½æ•°,å°±ä¼šè°ƒç”¨æœ¬å‡½æ•°.è¿™é‡Œå°±å¾ˆæ˜æ˜¾äº†,æœ¬å‡½æ•°å°±å°†input_handlerå’Œinput_devéƒ½æ”¾åœ¨input_handleä¸­ç»Ÿä¸€ç®¡ç†*/ evdev-&gt;handle.private = evdev; /*åˆå§‹åŒ–evdevä¸­çš„å†…åµŒdevice*/ evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor); evdev-&gt;dev.class = &amp;input_class; evdev-&gt;dev.parent = &amp;dev-&gt;dev; evdev-&gt;dev.release = evdev_free; device_initialize(&amp;evdev-&gt;dev); /* input_devè®¾å¤‡é©±åŠ¨å±‚å’Œinput_handleräº‹ä»¶å¤„ç†å±‚çš„å…³è”ï¼Œç”±input_handleå®Œæˆ(ä¸è¦å’Œhandlerææ··æ·†äº†ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæ¦‚å¿µï½) */ error = input_register_handle(&amp;evdev-&gt;handle); ...... cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops); evdev-&gt;cdev.kobj.parent = &amp;evdev-&gt;dev.kobj; error = cdev_add(&amp;evdev-&gt;cdev, evdev-&gt;dev.devt, 1); ...... error = device_add(&amp;evdev-&gt;dev); ...... return 0; ......&#125; 3.3ã€è¾“å…¥æ ¸å¿ƒå±‚ï¼šæ³¨å†Œinput_handlerä¸ºäº†é€»è¾‘æ›´æ¸…æ–°ï¼Œæˆ‘ä»¬ç¨åå†æ¥çœ‹input_register_handle() ç¨‹ï¼Œå…ˆæ¥äº†è§£input_handlerçš„æ³¨å†Œè¿‡ç¨‹ã€‚ è¦äº†è§£input_handlerçš„æ³¨å†Œè¿‡ç¨‹ï¼Œåˆéœ€è¦å…ˆäº†è§£evdevåˆå§‹åŒ–è¿‡ç¨‹ï¼ˆä»¥evdevä¸ºä¾‹ï¼‰ï¼š /kernel/drivers/inputä¸‹ä¼—å¤šäº‹ä»¶å¤„ç†å™¨handlerå…¶ä¸­çš„ä¸€ä¸ªï¼Œå¯ä»¥çœ‹ä¸‹æºç /kernel/drivers/input/evdev.cä¸­çš„æ¨¡å—init 12345[-&gt;edev.c]static int __init evdev_init(void)&#123; return input_register_handler(&amp;evdev_handler);&#125; è¿™ä¸ªåˆå§‹åŒ–å°±æ˜¯å¾€inputæ ¸å¿ƒä¸­æ³¨å†Œä¸€ä¸ªinput_handlerç±»å‹çš„evdev_handlerï¼Œè°ƒç”¨çš„æ˜¯input.cæä¾›çš„æ¥å£ï¼Œinput_handlerç»“æ„å‰é¢æœ‰ä»‹ç»ï¼Œçœ‹ä¸‹evdev_handlerçš„èµ‹å€¼ï¼š 1234567891011[-&gt;edev.c]static struct input_handler evdev_handler = &#123; .event = evdev_event, .events = evdev_events, .connect = evdev_connect, .disconnect = evdev_disconnect, .legacy_minors = true, .minor = EVDEV_MINOR_BASE, .name = \"evdev\", .id_table = evdev_ids,&#125;; å¯ä»¥æ³¨æ„çš„æ˜¯evdevæ˜¯åŒ¹é…æ‰€æœ‰è®¾å¤‡çš„ï¼Œå› ä¸ºï¼š 12345[-&gt;edev.c]static const struct input_device_id evdev_ids[] = &#123; &#123; .driver_info = 1 &#125;, /* Matches all devices */ &#123; &#125;, /* Terminating zero entry */&#125;; 123456789101112131415161718192021[-&gt;input.c]int input_register_handler(struct input_handler *handler)&#123; struct input_dev *dev; int error; error = mutex_lock_interruptible(&amp;input_mutex); ...... INIT_LIST_HEAD(&amp;handler-&gt;h_list); //æ·»åŠ è¿›input_handler_listå…¨å±€é“¾è¡¨ list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list); //åŒæ ·éå†input_devè¿™ä¸ªé“¾è¡¨ï¼Œä¾æ¬¡è°ƒç”¨ä¸‹é¢çš„input_attach_handlerå»åŒ¹é…input_dev,è¿™ä¸ªè·Ÿinput_devæ³¨å†Œçš„æ—¶å€™çš„æƒ…å½¢ç±»ä¼¼ list_for_each_entry(dev, &amp;input_dev_list, node) input_attach_handler(dev, handler); input_wakeup_procfs_readers(); mutex_unlock(&amp;input_mutex); return 0;&#125; 3.4ã€è¾“å…¥æ ¸å¿ƒå±‚ï¼šæ³¨å†Œinput_handleï¼ˆä¸è¦å’Œhandlerææ··æ·†äº†å“¦ï¼Œè¿™ä¸æ˜¯ä¸€ä¸ªæ¦‚å¿µï½ï¼‰input_handleå…³è”åŒ¹é…input_devå’Œinput_handler ç»§ç»­åˆ†æinput_devå’Œinput_handler æ˜¯å¦‚ä½•å…³è”ä¸Šçš„ 123456789101112131415161718192021222324252627282930313233[-&gt;input.c]int input_register_handle(struct input_handle *handle)&#123; struct input_handler *handler = handle-&gt;handler; struct input_dev *dev = handle-&gt;dev; int error; ...... error = mutex_lock_interruptible(&amp;dev-&gt;mutex); ...... /* å°†d_nodeé“¾æ¥åˆ°è¾“å…¥è®¾å¤‡çš„h_listï¼Œh_nodeé“¾æ¥åˆ°äº‹ä»¶å±‚çš„h_listé“¾è¡¨ä¸Š * å› æ­¤ï¼Œåœ¨handleä¸­æ˜¯è¾“å…¥è®¾å¤‡å’Œäº‹ä»¶å±‚çš„å…³è”ç»“æ„ä½“ï¼Œé€šè¿‡è¾“å…¥è®¾å¤‡å¯ä»¥ * æ‰¾åˆ°å¯¹åº”çš„äº‹ä»¶å¤„ç†å±‚æ¥å£ï¼Œé€šè¿‡äº‹ä»¶å¤„ç†å±‚ä¹Ÿå¯æ‰¾åˆ°åŒ¹é…çš„è¾“å…¥è®¾å¤‡ */ //æŠŠè¿™ä¸ªhandleçš„d_node åŠ åˆ°å¯¹åº”input_devçš„h_listé“¾è¡¨é‡Œé¢ if (handler-&gt;filter) list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list); else list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list); mutex_unlock(&amp;dev-&gt;mutex); ...... //æŠŠè¿™ä¸ªhandleçš„h_node åŠ åˆ°å¯¹åº”input_handlerçš„h_listé“¾è¡¨é‡Œé¢ list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list); if (handler-&gt;start) handler-&gt;start(handle); return 0;&#125; è¿™ä¸ªæ³¨å†Œæ˜¯æŠŠhandle æœ¬èº«çš„é“¾è¡¨åŠ å…¥åˆ°å®ƒè‡ªå·±çš„input_dev ä»¥åŠ input_handlerçš„h_listé“¾è¡¨ä¸­ï¼Œè¿™æ ·ä»¥åå°±å¯ä»¥é€šè¿‡h_listéå†åˆ°è¿™ä¸ªhandleï¼Œè¿™æ ·å°±å®ç°äº†ä¸‰è€…çš„ç»‘å®šè”ç³»ã€‚ ä»¥ä¸Šæ˜¯è¾“å…¥è®¾å¤‡é©±åŠ¨æ³¨å†Œçš„å…¨è¿‡ç¨‹ï¼Œçºµè§‚æ•´ä¸ªè¿‡ç¨‹ï¼Œè¾“å…¥è®¾å¤‡é©±åŠ¨æœ€ç»ˆçš„ç›®çš„å°±æ˜¯èƒ½å¤Ÿä¸äº‹ä»¶å¤„ç†å±‚çš„äº‹ä»¶é©±åŠ¨ç›¸äº’åŒ¹é…ï¼Œä½†æ˜¯åœ¨drivers/inputç›®å½•ä¸‹æœ‰evdev.cäº‹ä»¶é©±åŠ¨ã€mousedev.cäº‹ä»¶é©±åŠ¨ã€joydev.cäº‹ä»¶é©±åŠ¨ç­‰ç­‰ï¼Œæˆ‘ä»¬çš„è¾“å…¥è®¾å¤‡äº§ç”Ÿçš„äº‹ä»¶åº”è¯¥æœ€ç»ˆä¸ŠæŠ¥ç»™è°ï¼Œç„¶åè®©äº‹ä»¶è¢«è°å»å¤„ç†å‘¢ï¼ŸçŸ¥é“äº†è¿™ä¹ˆä¸ªåŸå› å†çœ‹ä¸Šé¢ä»£ç å°±ä¼šæ˜ç™½ï¼Œå…¶å®evdev.cã€mousedev.cç­‰æ ¹æ®ç¡¬ä»¶è¾“å…¥è®¾å¤‡çš„å¤„ç†æ–¹å¼çš„ä¸åŒæŠ½è±¡å‡ºäº†ä¸åŒçš„äº‹ä»¶å¤„ç†æ¥å£å¸®åŠ©ä¸Šå±‚å»è°ƒç”¨ï¼Œè€Œæˆ‘ä»¬å†™çš„è®¾å¤‡é©±åŠ¨ç¨‹åºåªä¸è¿‡æ˜¯å®Œæˆäº†ç¡¬ä»¶å¯„å­˜å™¨ä¸­æ•°æ®çš„è¯»å†™ï¼Œä½†æäº¤ç»™ç”¨æˆ·çš„äº‹ä»¶å¿…é¡»æ˜¯ç»è¿‡äº‹ä»¶å¤„ç†å±‚çš„å°è£…å’ŒåŒæ­¥æ‰èƒ½å¤Ÿå®Œæˆçš„ï¼Œäº‹ä»¶å¤„ç†å±‚æä¾›ç»™ç”¨æˆ·ä¸€ä¸ªç»Ÿä¸€çš„ç•Œé¢æ¥æ“ä½œã€‚ æ•´ä¸ªå…³è”æ³¨å†Œçš„è¿‡ç¨‹ï¼š ï¼ˆå››ï¼‰ã€Input äº‹ä»¶å¤„ç†å±‚ Event handler ï¼ˆä»¥evdeväº‹ä»¶å¤„ç†å™¨ä¸ºä¾‹ï¼‰ 4.1ã€ä¸»è¦æ•°æ®ç»“æ„ï¼ˆ1ï¼‰ evdevè®¾å¤‡ç»“æ„ 12345678910111213[evdev.h]struct evdev &#123; int exist; int open; //æ‰“å¼€æ ‡å¿— int minor; //æ¬¡è®¾å¤‡å· struct input_handle handle; //å…³è”çš„input_handle wait_queue_head_t wait; //ç­‰å¾…é˜Ÿåˆ—ï¼Œå½“è¿›ç¨‹è¯»å–è®¾å¤‡ï¼Œè€Œæ²¡æœ‰äº‹ä»¶äº§ç”Ÿçš„æ—¶å€™ï¼Œè¿›ç¨‹å°±ä¼šç¡åœ¨å…¶ä¸Šé¢ struct evdev_client *grab; //å¼ºåˆ¶ç»‘å®šçš„evdev_clientç»“æ„ï¼Œè¿™ä¸ªç»“æ„åé¢å†åˆ†æ struct list_head client_list; //evdev_client é“¾è¡¨ï¼Œè¿™è¯´æ˜ä¸€ä¸ªevdevè®¾å¤‡å¯ä»¥å¤„ç†å¤šä¸ªevdev_clientï¼Œå¯ä»¥æœ‰å¤šä¸ªè¿›ç¨‹è®¿é—®evdevè®¾å¤‡ spinlock_t client_lock; /* protects client_list */ struct mutex mutex; struct device dev; //deviceç»“æ„ï¼Œè¯´æ˜è¿™æ˜¯ä¸€ä¸ªè®¾å¤‡ç»“æ„ &#125;; evdevç»“æ„ä½“åœ¨é…å¯¹æˆåŠŸçš„æ—¶å€™ç”Ÿæˆï¼Œç”±handler-&gt;connectç”Ÿæˆï¼Œå¯¹åº”è®¾å¤‡æ–‡ä»¶ä¸º/class/input/event(n)ï¼Œå¦‚è§¦æ‘¸å±é©±åŠ¨çš„event3ï¼Œè¿™ä¸ªè®¾å¤‡æ˜¯ç”¨æˆ·ç©ºé—´è¦è®¿é—®çš„è®¾å¤‡ï¼Œå¯ä»¥ç†è§£å®ƒæ˜¯ä¸€ä¸ªè™šæ‹Ÿè®¾å¤‡ï¼Œå› ä¸ºæ²¡æœ‰å¯¹åº”çš„ç¡¬ä»¶ï¼Œä½†æ˜¯é€šè¿‡handle-&gt;dev å°±å¯ä»¥æ‰¾åˆ°input_devç»“æ„ï¼Œè€Œå®ƒå¯¹åº”ç€è§¦æ‘¸å±ï¼Œè®¾å¤‡æ–‡ä»¶ä¸º/class/input/input3ã€‚è¿™ä¸ªè®¾å¤‡ç»“æ„ç”Ÿæˆä¹‹åä¿å­˜åœ¨evdev_tableä¸­ï¼Œç´¢å¼•å€¼æ˜¯minorã€‚ ï¼ˆ2ï¼‰evdevç”¨æˆ·ç«¯ç»“æ„ 123456789101112131415[evdev.h]struct evdev_client &#123; unsigned int head; //bufferæ•°ç»„çš„ç´¢å¼•å¤´ unsigned int tail; //bufferæ•°ç»„çš„ç´¢å¼•å°¾ unsigned int packet_head; /* [future] position of the first element of next packet */ spinlock_t buffer_lock; /* protects access to buffer, head and tail */ struct wake_lock wake_lock; bool use_wake_lock; char name[28]; struct fasync_struct *fasync; //å¼‚æ­¥é€šçŸ¥å‡½æ•° struct evdev *evdev; //åŒ…å«ä¸€ä¸ªevdevå˜é‡ struct list_head node; //é“¾è¡¨ unsigned int bufsize; struct input_event buffer[]; //input_eventæ•°æ®ç»“æ„çš„æ•°ç»„ï¼Œinput_eventä»£è¡¨ä¸€ä¸ªäº‹ä»¶ï¼ŒåŸºæœ¬æˆå‘˜ï¼šç±»å‹ï¼ˆtypeï¼‰ï¼Œç¼–ç ï¼ˆcodeï¼‰ï¼Œå€¼ï¼ˆvalueï¼‰ &#125;; è¿™ä¸ªç»“æ„åœ¨è¿›ç¨‹æ‰“å¼€event3è®¾å¤‡çš„æ—¶å€™è°ƒç”¨evdevçš„openæ–¹æ³•ï¼Œåœ¨openä¸­åˆ›å»ºè¿™ä¸ªç»“æ„ï¼Œå¹¶åˆå§‹åŒ–ã€‚åœ¨å…³é—­è®¾å¤‡æ–‡ä»¶çš„æ—¶å€™é‡Šæ”¾è¿™ä¸ªç»“æ„ã€‚ ï¼ˆ3ï¼‰input_eventç»“æ„ 1234567[input.h]struct input_event &#123; struct timeval time; //äº‹ä»¶å‘ç”Ÿçš„æ—¶é—´ __u16 type; //äº‹ä»¶ç±»å‹ __u16 code; //å­äº‹ä»¶ __s32 value; //äº‹ä»¶çš„value &#125;; 4.2ã€äº‹ä»¶å¤„ç†å±‚evdeväº‹ä»¶å¤„ç†å±‚ä¸ç”¨æˆ·ç¨‹åºå’Œè¾“å…¥å­ç³»ç»Ÿæ ¸å¿ƒæ‰“äº¤é“ï¼Œæ˜¯ä»–ä»¬ä¸¤å±‚çš„æ¡¥æ¢ã€‚ä¸€èˆ¬å†…æ ¸æœ‰å¥½å‡ ä¸ªäº‹ä»¶å¤„ç†å™¨ï¼Œåƒevdev mousedev jotdevã€‚evdeväº‹ä»¶å¤„ç†å™¨å¯ä»¥å¤„ç†æ‰€æœ‰çš„äº‹ä»¶ï¼Œè§¦æ‘¸å±é©±åŠ¨å°±æ˜¯ç”¨çš„è¿™ä¸ªï¼Œæ‰€ä»¥ä¸‹é¢åˆ†æè¿™ä¸ªäº‹ä»¶å¤„ç†å™¨çš„å®ç°ã€‚å®ƒä¹Ÿæ˜¯ä½œä¸ºæ¨¡å—æ³¨å†Œåˆ°å†…æ ¸ä¸­çš„,å‰é¢å·²ç»åˆ†æè¿‡å®ƒçš„æ¨¡å—åˆå§‹åŒ–å‡½æ•° 12345678910111213141516[-&gt;evdev.c]static const struct file_operations evdev_fops = &#123; .owner = THIS_MODULE, .read = evdev_read, .write = evdev_write, .poll = evdev_poll, .open = evdev_open, .release = evdev_release, .unlocked_ioctl = evdev_ioctl,#ifdef CONFIG_COMPAT .compat_ioctl = evdev_ioctl_compat,#endif .fasync = evdev_fasync, .flush = evdev_flush, .llseek = no_llseek,&#125;; å¦‚æœåŒ¹é…ä¸Šäº†å°±ä¼šåˆ›å»ºä¸€ä¸ªevdevï¼Œå®ƒé‡Œè¾¹å°è£…äº†ä¸€ä¸ªhandleï¼Œä¼šæŠŠinput_devå’Œinput_handlerå…³è”åˆ°ä¸€èµ·ã€‚å…³ç³»å¦‚ä¸‹ï¼š 4.3ã€evdevè®¾å¤‡ç»“ç‚¹çš„open()æ“ä½œæˆ‘ä»¬çŸ¥é“.å¯¹ä¸»è®¾å¤‡å·ä¸ºINPUT_MAJORçš„è®¾å¤‡èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼Œä¼šå°†æ“ä½œé›†è½¬æ¢æˆhandlerçš„æ“ä½œé›†ã€‚åœ¨evdevä¸­ï¼Œè¿™ä¸ªæ“ä½œé›†å°±æ˜¯evdev_fopsã€‚å¯¹åº”çš„openå‡½æ•°å¦‚ä¸‹ç¤ºï¼š é¦–å…ˆæ¥çœ‹æ‰“å¼€event(x)è®¾å¤‡æ–‡ä»¶ï¼Œevdev_openå‡½æ•°. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677[-&gt;evdev.c]static int evdev_open(struct inode *inode, struct file *file)&#123; struct evdev *evdev = container_of(inode-&gt;i_cdev, struct evdev, cdev); //evdev_clientçš„bufferå¤§å° unsigned int bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev); unsigned int size = sizeof(struct evdev_client) + bufsize * sizeof(struct input_event); struct evdev_client *client; int error; //æ‰“å¼€çš„æ—¶å€™åˆ›å»ºä¸€ä¸ªevdev_client client = kzalloc(size, GFP_KERNEL | __GFP_NOWARN); ...... client-&gt;bufsize = bufsize; spin_lock_init(&amp;client-&gt;buffer_lock); snprintf(client-&gt;name, sizeof(client-&gt;name), \"%s-%d\", dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current)); client-&gt;evdev = evdev; evdev_attach_client(evdev, client); //è°ƒç”¨æ‰“å¼€çœŸæ­£çš„åº•å±‚è®¾å¤‡å‡½æ•° error = evdev_open_device(evdev); ...... file-&gt;private_data = client; nonseekable_open(inode, file); return 0; ......&#125;static int evdev_open_device(struct evdev *evdev)&#123; int retval; retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex); if (retval)/*å¦‚æœè®¾å¤‡ä¸å­˜åœ¨ï¼Œè¿”å›é”™è¯¯*/ return retval; if (!evdev-&gt;exist) retval = -ENODEV; else if (!evdev-&gt;open++) &#123;//é€’å¢æ‰“å¼€è®¡æ•° retval = input_open_device(&amp;evdev-&gt;handle);//å¦‚æœæ˜¯è¢«ç¬¬ä¸€æ¬¡æ‰“å¼€ï¼Œåˆ™è°ƒç”¨input_open_device if (retval) evdev-&gt;open--; &#125; mutex_unlock(&amp;evdev-&gt;mutex); return retval;&#125;int input_open_device(struct input_handle *handle)&#123; struct input_dev *dev = handle-&gt;dev;//æ ¹æ®input_handleæ‰¾åˆ°å¯¹åº”çš„input_devè®¾å¤‡ int retval; retval = mutex_lock_interruptible(&amp;dev-&gt;mutex); ...... handle-&gt;open++;//é€’å¢handleçš„æ‰“å¼€è®¡æ•° if (!dev-&gt;users++ &amp;&amp; dev-&gt;open) retval = dev-&gt;open(dev);//å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ‰“å¼€.åˆ™è°ƒç”¨input deviceçš„open()å‡½æ•° if (retval) &#123; dev-&gt;users--; if (!--handle-&gt;open) &#123; synchronize_rcu(); &#125; &#125; out: mutex_unlock(&amp;dev-&gt;mutex); return retval;&#125; 4.4ã€ç”¨æˆ·è¿›ç¨‹è¯»å–eventçš„åº•å±‚å®ç°è‡³äºå…·ä½“çš„å¦‚ä½•åˆå§‹åŒ–input_devï¼Œè¿™ä¸ªæ˜¯å…·ä½“çš„è¾“å…¥è®¾å¤‡å»å®ç°çš„ï¼Œç¨åå…·ä½“å®ä¾‹å†åˆ†æï¼Œç°åœ¨æ¥çœ‹çœ‹ï¼Œå¯¹äºä¸€ä¸ªevent(x)è®¾å¤‡æ–‡ä»¶çš„ï¼Œåº”ç”¨ç¨‹åºæ¥è¯»ï¼Œæœ€ç»ˆä¼šå¯¼è‡´â€handlerâ€é‡Œé¢çš„çš„â€è¯»å‡½æ•°â€è¢«è°ƒç”¨ã€‚ evdev_fops ç»“ æ„ ä½“ æ˜¯ ä¸€ ä¸ª file_operations çš„ ç±» å‹ ã€‚ å½“ ç”¨ æˆ· å±‚ è°ƒ ç”¨ ç±» ä¼¼ ä»£ ç open(â€œ/dev/input/event3â€ , O_RDONLY) å‡½ æ•° æ‰“ å¼€ è®¾ å¤‡ ç»“ ç‚¹ æ—¶ , ä¼š è°ƒ ç”¨ evdev_fops ä¸­ çš„evdev_read()å‡½æ•°,è¯¥å‡½æ•°çš„ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586[-&gt;evdev.c]static ssize_t evdev_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)&#123; struct evdev_client *client = file-&gt;private_data;//å°±æ˜¯åˆšæ‰åœ¨openå‡½æ•°ä¸­ä¿å­˜çš„evdev_client struct evdev *evdev = client-&gt;evdev; struct input_event event; size_t read = 0; int error; for (;;) &#123; ...... //å¦‚æœè·å¾—äº†æ•°æ®åˆ™å–å‡ºæ¥ï¼Œè°ƒç”¨evdev_fetch_next_event while (read + input_event_size() &lt;= count &amp;&amp; evdev_fetch_next_event(client, &amp;event)) &#123; //input_event_to_userè°ƒç”¨copy_to_userä¼ å…¥ç”¨æˆ·ç¨‹åºä¸­ï¼Œè¿™æ ·è¯»å–å®Œæˆ if (input_event_to_user(buffer + read, &amp;event)) return -EFAULT; read += input_event_size(); &#125; ...... /*å¦‚æœæ˜¯å¯é˜»å¡çŠ¶æ€çš„è¯,åˆ™ç­‰å¾…åœ¨waité˜Ÿåˆ—ä¸Š.ç›´åˆ°æœ‰æ•°æ®è¦è¢«å¤„ç†,å½“å‰è¿›ç¨‹æ‰è¢«å”¤é†’.è¿™å¾ˆå¥½ç†è§£,æ—¢ç„¶æ˜¯ è¾“å…¥è®¾å¤‡,è¯»çš„è¯æ¯”å¦‚è¯»æŒ‰é”®,é‚£ä¹ˆå¿…é¡»è¦æœ‰ç¡¬ä»¶è®¾å¤‡æœ‰æŒ‰é”®æŒ‰ä¸‹æ‰ä¼šè¿”å›æŒ‰é”®å€¼,è¿™é‡Œè¿˜æ˜¯å¤„äºäº‹ä»¶å¤„ç†å±‚,åº”ç”¨ç¨‹åºåœ¨è¿™é‡Œä¼‘çœ ,é‚£ä¹ˆè°æ¥å”¤é†’? å½“ç„¶æ˜¯æœ‰æŒ‰é”®æŒ‰ä¸‹æ‰å»å”¤é†’,å› æ­¤è¿™ä¸ªå·¥ä½œå°±äº¤ç»™äº†è®¾å¤‡é©±åŠ¨å±‚,é‚£ä¹ˆæ‰¾åˆ°è¿™ä¸ªå”¤é†’å‘¢,ç›´æ¥å»æ‰¾ä¸å¥½æ‰¾,é‚£ä¹ˆå¯ä»¥ç›´æ¥æœç´¢evdev-&gt;wait,æœç´¢ç»“æœ å¯çŸ¥evdev-&gt;waitåœ¨evdev_event()å‡½æ•°ä¸­è¢«å”¤é†’*/ if (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123; error = wait_event_interruptible(evdev-&gt;wait, client-&gt;packet_head != client-&gt;tail || !evdev-&gt;exist || client-&gt;revoked); if (error) return error; &#125; &#125; return read;&#125;static int evdev_fetch_next_event(struct evdev_client *client, struct input_event *event)&#123; int have_event; spin_lock_irq(&amp;client-&gt;buffer_lock); /*å…ˆåˆ¤æ–­ä¸€ä¸‹æ˜¯å¦æœ‰æ•°æ®*/ have_event = client-&gt;packet_head != client-&gt;tail; /*å¦‚æœæœ‰å°±ä»ç¯å½¢ç¼“å†²åŒºçš„å–å‡ºæ¥ï¼Œè®°å¾—æ˜¯ä»headå­˜å‚¨ï¼Œtailå–å‡º*/ if (have_event) &#123; *event = client-&gt;buffer[client-&gt;tail++]; client-&gt;tail &amp;= client-&gt;bufsize - 1; if (client-&gt;use_wake_lock &amp;&amp; client-&gt;packet_head == client-&gt;tail) wake_unlock(&amp;client-&gt;wake_lock); &#125; spin_unlock_irq(&amp;client-&gt;buffer_lock); return have_event;&#125;int input_event_to_user(char __user *buffer, const struct input_event *event)&#123; /*å¦‚æœè®¾ç½®äº†æ ‡å¿—INPUT_COMPAT_TESTå°±å°†äº‹ä»¶eventåŒ…è£…æˆç»“æ„ä½“compat_event*/ if (INPUT_COMPAT_TEST &amp;&amp; !COMPAT_USE_64BIT_TIME) &#123; struct input_event_compat compat_event; compat_event.time.tv_sec = event-&gt;time.tv_sec; compat_event.time.tv_usec = event-&gt;time.tv_usec; compat_event.type = event-&gt;type; compat_event.code = event-&gt;code; compat_event.value = event-&gt;value; /*å°†åŒ…è£…æˆçš„compat_eventæ‹·è´åˆ°ç”¨æˆ·ç©ºé—´*/ if (copy_to_user(buffer, &amp;compat_event, sizeof(struct input_event_compat))) return -EFAULT; &#125; else &#123; /*å¦åˆ™ï¼Œå°†eventæ‹·è´åˆ°ç”¨æˆ·ç©ºé—´*/ if (copy_to_user(buffer, event, sizeof(struct input_event))) return -EFAULT; &#125; return 0;&#125; å¦‚æœæ˜¯å¯é˜»å¡çŠ¶æ€çš„è¯ï¼Œåˆ™ç­‰å¾…åœ¨waité˜Ÿåˆ—ä¸Šã€‚ç›´åˆ°æœ‰æ•°æ®è¦è¢«å¤„ç†ï¼Œå½“å‰è¿›ç¨‹æ‰è¢«å”¤é†’ã€‚è¿™å¾ˆå¥½ç†è§£ï¼Œæ—¢ç„¶æ˜¯è¾“å…¥è®¾å¤‡ï¼Œè¯»çš„è¯æ¯”å¦‚è¯»æŒ‰é”®ï¼Œé‚£ä¹ˆå¿…é¡»è¦æœ‰ç¡¬ä»¶è®¾å¤‡æœ‰æŒ‰é”®æŒ‰ä¸‹æ‰ä¼šè¿”å›æŒ‰é”®å€¼ï¼Œè¿™é‡Œè¿˜æ˜¯å¤„äºäº‹ä»¶å¤„ç†å±‚ï¼Œåº”ç”¨ç¨‹åºåœ¨è¿™é‡Œä¼‘çœ ï¼Œé‚£ä¹ˆè°æ¥å”¤é†’? å½“ç„¶æ˜¯æœ‰æŒ‰é”®æŒ‰ä¸‹æ‰å»å”¤é†’ï¼Œå› æ­¤è¿™ä¸ªå·¥ä½œå°±äº¤ç»™äº†è®¾å¤‡é©±åŠ¨å±‚ã€‚é‚£ä¹ˆæ‰¾åˆ°è¿™ä¸ªå”¤é†’å‘¢ï¼Œç›´æ¥å»æ‰¾ä¸å¥½æ‰¾ã€‚é‚£ä¹ˆå¯ä»¥ç›´æ¥æœç´¢evdev-&gt;waitï¼Œæœç´¢ç»“æœå¯çŸ¥evdev-&gt;waitåœ¨evdev_event()å‡½æ•°ä¸­è¢«å”¤é†’ æ³¨é‡Šä¸­è¯´çš„å¾ˆæ¸…æ¥šï¼Œevdev_event()ä¼šå”¤é†’æ­¤å¤„çš„è¯»æŒ‰é”®è¿›ç¨‹ã€‚é‚£ä¹ˆevdev_event()åˆæ˜¯è¢«è°è°ƒç”¨?æ˜¾ç„¶æ˜¯è®¾å¤‡é©±åŠ¨å±‚ï¼Œç°åœ¨çœ‹ä¸€ä¸ªè®¾å¤‡å±‚ä¾‹å­ï¼Œå†…æ ¸ä¸­æœ‰ä¸ªæŒ‰é”®çš„ä¾‹å­ï¼Œgpiokey.cï¼Œè¿™åªæ˜¯ä¸ªä¾‹å­ä¸é’ˆå¯¹ä»»ä½•è®¾å¤‡ï¼Œåœ¨gpio_keys.cç»ˆç«¯å¤„ç†å‡½æ•°é‡Œé¢ 1234567891011121314[-&gt;gpio_keys.c]static irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)&#123; ...... if (!bdata-&gt;key_pressed) &#123; ...... input_event(input, EV_KEY, button-&gt;code, 1); input_sync(input); ...... &#125; ......&#125; å¦‚æ­¤å¯ä»¥çœ‹å‡º åœ¨è®¾å¤‡çš„ä¸­æ–­æœåŠ¡ç¨‹åºé‡Œé¢ï¼Œç¡®å®šäº‹ä»¶æ˜¯ä»€ä¹ˆï¼Œç„¶åè°ƒç”¨ç›¸åº”çš„input_handlerçš„eventå¤„ç†å‡½æ•° å®é™…ä¸Šè¿™å°±æ˜¯æˆ‘ä»¬çš„æ ¸å¿ƒ input_event()æ˜¯ç”¨æ¥ä¸ŠæŠ¥äº‹ä»¶çš„ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263[-&gt;input.c]void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; unsigned long flags; if (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123; spin_lock_irqsave(&amp;dev-&gt;event_lock, flags); input_handle_event(dev, type, code, value); spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags); &#125;&#125;static void input_handle_event(struct input_dev *dev, unsigned int type, unsigned int code, int value)&#123; ...... if (disposition &amp; INPUT_FLUSH) &#123; if (dev-&gt;num_vals &gt;= 2) input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals); dev-&gt;num_vals = 0; &#125; else if (dev-&gt;num_vals &gt;= dev-&gt;max_vals - 2) &#123; dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync; input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals); dev-&gt;num_vals = 0; &#125;&#125;static void input_pass_values(struct input_dev *dev, struct input_value *vals, unsigned int count)&#123; struct input_handle *handle; struct input_value *v; ...... handle = rcu_dereference(dev-&gt;grab); if (handle) &#123; count = input_to_handler(handle, vals, count); &#125; else &#123; list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node) if (handle-&gt;open) count = input_to_handler(handle, vals, count); &#125; ......&#125;static unsigned int input_to_handler(struct input_handle *handle, struct input_value *vals, unsigned int count)&#123; struct input_handler *handler = handle-&gt;handler; struct input_value *end = vals; struct input_value *v; ...... if (handler-&gt;events) handler-&gt;events(handle, vals, count); else if (handler-&gt;event) for (v = vals; v != end; v++) handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value); return count;&#125; å¯ä»¥çœ‹åˆ°æœ€ç»ˆè°ƒç”¨handler-&gt;event()æ¥å¤„ç†ï¼Œæ­¤å¤„handlerå³å¯¹åº”evdevã€‚ 12[-&gt;input.c]handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) æ‰€ä»¥ä¼šè°ƒç”¨evdev_event()å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[-&gt;evdev.c]static void evdev_pass_values(struct evdev_client *client, const struct input_value *vals, unsigned int count, ktime_t mono, ktime_t real)&#123; struct evdev *evdev = client-&gt;evdev; const struct input_value *v; struct input_event event; bool wakeup = false; if (client-&gt;revoked) return; event.time = ktime_to_timeval(client-&gt;clkid == CLOCK_MONOTONIC ? mono : real); /* Interrupts are disabled, just acquire the lock. */ spin_lock(&amp;client-&gt;buffer_lock); for (v = vals; v != vals + count; v++) &#123; event.type = v-&gt;type; event.code = v-&gt;code; event.value = v-&gt;value; __pass_event(client, &amp;event); if (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT) wakeup = true; &#125; spin_unlock(&amp;client-&gt;buffer_lock); if (wakeup) wake_up_interruptible(&amp;evdev-&gt;wait);&#125;static void evdev_events(struct input_handle *handle, const struct input_value *vals, unsigned int count)&#123; struct evdev *evdev = handle-&gt;private; struct evdev_client *client; ...... if (client) evdev_pass_values(client, vals, count, time_mono, time_real); else list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node) evdev_pass_values(client, vals, count, time_mono, time_real); rcu_read_unlock();&#125;static void evdev_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)&#123; struct input_value vals[] = &#123; &#123; type, code, value &#125; &#125;; evdev_events(handle, vals, 1);&#125; æœ€ç»ˆå”¤é†’evdev_read()å°†æ•°æ®æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ã€‚ ï¼ˆäº”ï¼‰ã€Input äº‹ä»¶ä¸ŠæŠ¥è¿‡ç¨‹5.1ã€Input äº‹ä»¶äº§ç”Ÿå½“æŒ‰ä¸‹è§¦æ‘¸å±æ—¶ï¼Œè¿›å…¥è§¦æ‘¸å±æŒ‰ä¸‹ä¸­æ–­ï¼Œå¼€å§‹adè½¬æ¢ï¼Œadè½¬æ¢å®Œæˆè¿›å…¥adå®Œæˆä¸­æ–­ï¼Œåœ¨è¿™ä¸ªç»ˆç«¯ä¸­å°†äº‹ä»¶å‘é€å‡ºå»ï¼Œä¼šè°ƒç”¨ä»¥ä¸‹å‡½æ•°ä¸ŠæŠ¥äº‹ä»¶: 12345678910 input_report_key(input_dev, BTN_TOUCH, 1); input_report_abs(input_dev, ABS_POSITION_X, x); input_report_abs(input_dev, ABS_POSITION_Y, y);input_sync(input_dev); è¿™ä¸¤ä¸ªå‡½æ•°è°ƒç”¨äº† input_event(dev, EV_ABS, code, value) æ‰€æœ‰çš„äº‹ä»¶æŠ¥å‘Šå‡½æ•°éƒ½è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚ 123456789101112131415[-&gt;input.h]static inline void input_report_key(struct input_dev *dev, unsigned int code, int value)&#123; input_event(dev, EV_KEY, code, !!value);&#125;static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value)&#123; input_event(dev, EV_ABS, code, value);&#125;static inline void input_sync(struct input_dev *dev)&#123; input_event(dev, EV_SYN, SYN_REPORT, 0);&#125; 5.2ã€Input äº‹ä»¶æŠ¥å‘Šinput_event å‡½æ•°å‰é¢å·²ç»åˆ†æè¿‡ï¼Œè¿™é‡Œä¸å†åˆ†æã€‚ 123[-&gt;input.c:input_pass_values]for (v = vals; v != end; v++) handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value); æœ€ç»ˆä¼šè°ƒç”¨handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) æ¥å°†æ•°æ® ä¼ é€’ç»™ç”¨æˆ·ç©ºé—´ç­‰å¾…è¯»å–æ•°æ®çš„è¿›ç¨‹ 1copy_to_user(buffer, event, sizeof(struct input_event)) ï¼ˆå…­ï¼‰ã€Android Inputå­ç³»ç»Ÿè¾“å…¥å­ç³»ç»Ÿçš„ç³»ç»Ÿæ¶æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š è¯¦ç»†åˆ†æè¯·å‚è€ƒï¼šAndroid 7.1.2 (Android N) Android è¾“å…¥å­ç³»ç»Ÿ-Input System åˆ†æ ï¼ˆä¸ƒï¼‰ã€Input è®¾å¤‡é©±åŠ¨å±‚å®ä¾‹ï¼ˆSynapticsï¼‰è§¦æ‘¸å±ä¹Ÿæ˜¯ç”¨ä¸Šé¢è¿™ä¸€å¥—æ¡†æ¶æ¥æ“ä½œçš„ã€‚å³è¾¹éœ€è¦ä¸€ä¸ªâ€evdev.câ€æ–‡ä»¶ã€‚å·¦è¾¹è¦åˆ†é…ä¸€ä¸ªâ€input_devâ€ç»“æ„ã€‚æ¥ç€å°±çœ‹ä¸Šå›¾çš„ç¡¬ä»¶è®¾å¤‡å·¦è¾¹çš„è¿‡ç¨‹ï¼šåˆ†é…ä¸€ä¸ªâ€input_devâ€ç»“æ„ä½“ â€“&gt; è®¾ç½®è¿™ä¸ªâ€input_devâ€ç»“æ„ä½“ â€“&gt; æ³¨å†Œè¿™ä¸ªâ€input_devâ€ç»“æ„ä½“ â€“&gt; ç¡¬ä»¶ç›¸å…³çš„æ“ä½œã€‚ ç¼–å†™Inputé©±åŠ¨ä¸€èˆ¬æ¡†æ¶: Google Pixelã€Pixel XL è§¦æ§é©±åŠ¨æ¨¡å—å‹å·ä¸ºSynapticsï¼ˆClearPad S3708ï¼‰ï¼Œæºç ï¼šSynaptics è§¦æ‘¸å±é©±åŠ¨æºç  Makefileï¼š 123456789101112[-&gt;drivers/input/touchscreen/synaptics_dsx_htc_2.6/Makefile]## Makefile for the Synaptics DSX touchscreen driver.## Each configuration option enables a list of files.obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C_HTC_v26) += synaptics_dsx_i2c.oobj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_SPI_HTC_v26) += synaptics_dsx_spi.oobj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_HTC_v26) += synaptics_dsx_core.oobj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_HTC_v26) += synaptics_dsx_rmi_dev.o...... æŠ“å–kernel logï¼šå¯çŸ¥input é©±åŠ¨åä¸ºsynaptics_dsxv26ï¼Œå…¨å±€æœç´¢å¯çŸ¥synaptics_rmi4_f12_initåœ¨[-&gt;synaptics_dsx_core.c]ä¸­ã€‚ 123456[ 1.362728] c3 1 [TP]:synaptics_rmi4_f12_init: Function 12 max x = 1079 max y = 1919 Rx: 16 Tx: 28[ 1.363344] c3 1 [TP]synaptics_rmi4_f12_init:Wakeup Gesture range (0,0) -&gt; (1079,1919)[ 1.363623] c3 1 [TP]:synaptics_rmi4_f12_init report data init done[ 1.371945] c3 1 [TP]:synaptics_rmi4_query_device: chip_id:3708, firmware_id:2433782[ 1.372865] c3 1 [TP]:synaptics_rmi4_query_device: config_version: 5331763200190000000000000000000000000000000000000000000000000000[ 1.373249] c3 1 input: synaptics_dsxv26 as /devices/soc/7577000.i2c/i2c-3/3-0020/input/input3 æŸ¥çœ‹inputè®¾å¤‡ï¼šadb shell cat /proc/bus/input/devices 123456789101112I: Bus=0000 Vendor=0000 Product=0003 Version=2066N: Name=&quot;synaptics_dsxv26&quot;P: Phys=synaptics_dsx/touch_inputS: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3U: Uniq=H: Handlers=mdss_fb kgsl event3B: PROP=2B: EV=bB: KEY=8000 0 0B: ABS=663800000000000å¯¹åº”ï¼š/dev/input/event3 7.1ã€åˆ†é…Input_devç»“æ„ä½“7.1.1ã€synaptics_rmi4_f12_init()é¦–å…ˆçœ‹ä¸€ä¸‹åˆå§‹åŒ–è¿‡ç¨‹ï¼š 123456789101112131415161718192021222324[-&gt;synaptics_dsx_core.c]static struct platform_driver synaptics_rmi4_driver = &#123; .driver = &#123; .name = PLATFORM_DRIVER_NAME, .owner = THIS_MODULE,#ifdef CONFIG_PM .pm = &amp;synaptics_rmi4_dev_pm_ops,#endif &#125;, .probe = synaptics_rmi4_probe, .remove = synaptics_rmi4_remove,&#125;;static int __init synaptics_rmi4_init(void)&#123; int retval; retval = synaptics_rmi4_bus_init(); if (retval) return retval; return platform_driver_register(&amp;synaptics_rmi4_driver);&#125;module_init(synaptics_rmi4_init); é¦–å…ˆæ³¨å†Œå¹³å°é©±åŠ¨ï¼Œå½“é©±åŠ¨å’Œè®¾å¤‡åŒ¹é…æˆåŠŸï¼Œç»§ç»­çœ‹ä¸€ä¸‹synaptics_rmi4_probe()å‡½æ•° 7.1.2ã€synaptics_rmi4_probe()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_probe(struct platform_device *pdev)&#123; int retval, len; unsigned char attr_count; struct synaptics_rmi4_data *rmi4_data; const struct synaptics_dsx_hw_interface *hw_if; const struct synaptics_dsx_board_data *bdata; struct dentry *temp; //åˆå§‹åŒ–platform_dataã€board_dataã€rmi4_data hw_if = pdev-&gt;dev.platform_data; bdata = hw_if-&gt;board_data; rmi4_data = kzalloc(sizeof(*rmi4_data), GFP_KERNEL); rmi4_data-&gt;pdev = pdev; rmi4_data-&gt;current_page = MASK_8BIT; rmi4_data-&gt;hw_if = hw_if; rmi4_data-&gt;touch_stopped = false; rmi4_data-&gt;sensor_sleep = false; rmi4_data-&gt;irq_enabled = false; rmi4_data-&gt;fw_updating = false; rmi4_data-&gt;fingers_on_2d = false; rmi4_data-&gt;update_coords = true; rmi4_data-&gt;write_buf = devm_kzalloc(&amp;pdev-&gt;dev, I2C_WRITE_BUF_MAX_LEN, GFP_KERNEL); rmi4_data-&gt;write_buf_len = I2C_WRITE_BUF_MAX_LEN; rmi4_data-&gt;irq_enable = synaptics_rmi4_irq_enable; rmi4_data-&gt;reset_device = synaptics_rmi4_reset_device; mutex_init(&amp;(rmi4_data-&gt;rmi4_io_ctrl_mutex)); mutex_init(&amp;(rmi4_data-&gt;rmi4_reset_mutex)); retval = synaptics_dsx_regulator_configure(rmi4_data); retval = synaptics_dsx_regulator_enable(rmi4_data, true); platform_set_drvdata(pdev, rmi4_data); if (bdata-&gt;gpio_config) &#123; retval = synaptics_rmi4_set_gpio(rmi4_data); &#125; else &#123; retval = synaptics_dsx_pinctrl_init(rmi4_data); if (!retval &amp;&amp; rmi4_data-&gt;ts_pinctrl) &#123; retval = pinctrl_select_state(rmi4_data-&gt;ts_pinctrl, rmi4_data-&gt;pinctrl_state_active); &#125; retval = synaptics_dsx_gpio_configure(rmi4_data, true); &#125; if (bdata-&gt;fw_name) &#123; len = strlen(bdata-&gt;fw_name); strlcpy(rmi4_data-&gt;fw_name, bdata-&gt;fw_name, len + 1); &#125; //åˆ†é…Input_devç»“æ„ä½“ï¼Œè®¾ç½®ï¼Œæ³¨å†Œ retval = synaptics_rmi4_set_input_dev(rmi4_data); ...... rmi4_data-&gt;irq = gpio_to_irq(bdata-&gt;irq_gpio); //è¯·æ±‚ä¸­æ–­ï¼Œå¹¶è®¾ç½®ä¸­æ–­å¤„ç†å‡½æ•°synaptics_rmi4_irq retval = synaptics_rmi4_irq_enable(rmi4_data, true); if (!exp_data.initialized) &#123; mutex_init(&amp;exp_data.mutex); INIT_LIST_HEAD(&amp;exp_data.list); exp_data.initialized = true; &#125; exp_data.workqueue = create_singlethread_workqueue(\"dsx_exp_workqueue\"); INIT_DELAYED_WORK(&amp;exp_data.work, synaptics_rmi4_exp_fn_work); exp_data.rmi4_data = rmi4_data; exp_data.queue_work = true; queue_delayed_work(exp_data.workqueue, &amp;exp_data.work, msecs_to_jiffies(EXP_FN_WORK_DELAY_MS)); rmi4_data-&gt;dir = debugfs_create_dir(DEBUGFS_DIR_NAME, NULL); ...... for (attr_count = 0; attr_count &lt; ARRAY_SIZE(attrs); attr_count++) &#123; retval = sysfs_create_file(&amp;rmi4_data-&gt;input_dev-&gt;dev.kobj, &amp;attrs[attr_count].attr); ...... &#125; synaptics_secure_touch_init(rmi4_data); synaptics_secure_touch_stop(rmi4_data, 1); return retval; .......&#125; 7.1.3ã€åˆ†é…Input_devç»“æ„ä½“12345678910[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)&#123; int retval; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; rmi4_data-&gt;input_dev = input_allocate_device(); ......&#125; 7.2ã€è®¾ç½®æ”¯æŒäº‹ä»¶ç±»å‹ set_bit(EV_SYN, evbit)ã€set_bit(EV_KEY, evbit)ã€set_bit(EV_ABS,evbit) â€¦â€¦1234567891011121314151617181920212223242526272829[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)&#123; int retval; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; rmi4_data-&gt;input_dev = input_allocate_device(); ...... retval = synaptics_rmi4_query_device(rmi4_data); .... //#define PLATFORM_DRIVER_NAME \"synaptics_dsxv26\"(synaptics_dsx_v2_6.h) rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME; rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME; rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT; rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION; rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent; input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data); set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit); set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit); synaptics_rmi4_set_params(rmi4_data); ......&#125; 7.3ã€æ³¨å†Œè®¾å¤‡input_register_device()æ­¤å¤„å³ä¸å‰é¢kernel logå‘¼åº”ï¼šæ³¨å†Œåä¸º synaptics_dsxv26 çš„è¾“å…¥è®¾å¤‡ 123456789101112131415161718192021222324252627282930[-&gt;synaptics_dsx_core.c]static int synaptics_rmi4_set_input_dev(struct synaptics_rmi4_data *rmi4_data)&#123; int retval; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; rmi4_data-&gt;input_dev = input_allocate_device(); ...... retval = synaptics_rmi4_query_device(rmi4_data); .... //#define PLATFORM_DRIVER_NAME \"synaptics_dsxv26\"(synaptics_dsx_v2_6.h) rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME; rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME; rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT; rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION; rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent; input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data); set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit); set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit); set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit); synaptics_rmi4_set_params(rmi4_data); ...... retval = input_register_device(rmi4_data-&gt;input_dev);&#125; 7.4ã€ç¡¬ä»¶ç›¸å…³æ“ä½œå½“è§¦æ‘¸å±æŒ‰ä¸‹ï¼Œä¼šäº§ç”Ÿä¸­æ–­ï¼Œè¿›è€Œè°ƒç”¨ä¸­æ–­å¤„ç†å‡½æ•°synaptics_rmi4_irq(): 123456789101112131415161718[-&gt;synaptics_dsx_core.c]static irqreturn_t synaptics_rmi4_irq(int irq, void *data)&#123; struct synaptics_rmi4_data *rmi4_data = data; const struct synaptics_dsx_board_data *bdata = rmi4_data-&gt;hw_if-&gt;board_data; if (IRQ_HANDLED == synaptics_filter_interrupt(data)) return IRQ_HANDLED; if (gpio_get_value(bdata-&gt;irq_gpio) != bdata-&gt;irq_on_state) goto exit; synaptics_rmi4_sensor_report(rmi4_data, true);exit: return IRQ_HANDLED;&#125; è¿›ä¸€æ­¥è°ƒç”¨synaptics_rmi4_sensor_report(rmi4_data, true)å¤„ç†æ•°æ®ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[-&gt;synaptics_dsx_core.c]static void synaptics_rmi4_sensor_report(struct synaptics_rmi4_data *rmi4_data, bool report)&#123; int retval; unsigned char data[MAX_INTR_REGISTERS + 1]; unsigned char *intr = &amp;data[1]; bool was_in_bl_mode; struct synaptics_rmi4_f01_device_status status; struct synaptics_rmi4_fn *fhandler; struct synaptics_rmi4_exp_fhandler *exp_fhandler; struct synaptics_rmi4_device_info *rmi; rmi = &amp;(rmi4_data-&gt;rmi4_mod_info); .... retval = synaptics_rmi4_reg_read(rmi4_data, rmi4_data-&gt;f01_data_base_addr, data, rmi4_data-&gt;num_of_intr_regs + 1); ...... //è¯»å–å¯„å­˜å™¨æ•°æ® status.data[0] = data[0]; if (status.status_code == STATUS_CRC_IN_PROGRESS) &#123; retval = synaptics_rmi4_check_status(rmi4_data, &amp;was_in_bl_mode); .... retval = synaptics_rmi4_reg_read(rmi4_data, rmi4_data-&gt;f01_data_base_addr, status.data, sizeof(status.data)); ...... &#125; if (status.unconfigured &amp;&amp; !status.flash_prog) &#123; pr_notice(\"%s: spontaneous reset detected\\n\", __func__); &#125; //synaptics_rmi4_report_touch()ä¸ŠæŠ¥æ•°æ® if (!list_empty(&amp;rmi-&gt;support_fn_list)) &#123; list_for_each_entry(fhandler, &amp;rmi-&gt;support_fn_list, link) &#123; if (fhandler-&gt;num_of_data_sources) &#123; if (fhandler-&gt;intr_mask &amp; intr[fhandler-&gt;intr_reg_num]) &#123; synaptics_rmi4_report_touch(rmi4_data, fhandler); &#125; &#125; &#125; &#125; mutex_lock(&amp;exp_data.mutex); if (!list_empty(&amp;exp_data.list)) &#123; list_for_each_entry(exp_fhandler, &amp;exp_data.list, link) &#123; if (!exp_fhandler-&gt;insert &amp;&amp; !exp_fhandler-&gt;remove &amp;&amp; (exp_fhandler-&gt;exp_fn-&gt;attn != NULL)) exp_fhandler-&gt;exp_fn-&gt;attn(rmi4_data, intr[0]); &#125; &#125; mutex_unlock(&amp;exp_data.mutex); return;&#125; 7.4.1ã€Inputæ•°æ®ä¸ŠæŠ¥ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112[-&gt;synaptics_dsx_core.c]static void synaptics_rmi4_report_touch(struct synaptics_rmi4_data *rmi4_data, struct synaptics_rmi4_fn *fhandler)&#123; ...... switch (fhandler-&gt;fn_number) &#123; ...... case SYNAPTICS_RMI4_F12: touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data, fhandler); if (touch_count_2d) rmi4_data-&gt;fingers_on_2d = true; else rmi4_data-&gt;fingers_on_2d = false; break; ...... default: break; &#125; return;&#125;static int synaptics_rmi4_f12_abs_report(struct synaptics_rmi4_data *rmi4_data, struct synaptics_rmi4_fn *fhandler)&#123; int retval; unsigned char touch_count = 0; /* number of touch points */ unsigned char index; unsigned char finger; unsigned char fingers_to_process; unsigned char finger_status; unsigned char size_of_2d_data; unsigned char gesture_type; unsigned short data_addr; int x; int y; int wx; int wy; int temp; struct synaptics_rmi4_f12_extra_data *extra_data; struct synaptics_rmi4_f12_finger_data *data; struct synaptics_rmi4_f12_finger_data *finger_data; static unsigned char finger_presence; static unsigned char stylus_presence; fingers_to_process = fhandler-&gt;num_of_data_points; data_addr = fhandler-&gt;full_addr.data_base; extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler-&gt;extra; size_of_2d_data = sizeof(struct synaptics_rmi4_f12_finger_data); ...... retval = synaptics_rmi4_reg_read(rmi4_data, data_addr + extra_data-&gt;data1_offset, (unsigned char *)fhandler-&gt;data, fingers_to_process * size_of_2d_data); if (retval &lt; 0) return 0; data = (struct synaptics_rmi4_f12_finger_data *)fhandler-&gt;data; mutex_lock(&amp;(rmi4_data-&gt;rmi4_report_mutex)); //æ ¹æ®è§¦æ‘¸ç‚¹æ•°é‡å¾ªç¯ä¸ŠæŠ¥inputæ•°æ® for (finger = 0; finger &lt; fingers_to_process; finger++) &#123; finger_data = data + finger; finger_status = finger_data-&gt;object_type_and_status; x = (finger_data-&gt;x_msb &lt;&lt; 8) | (finger_data-&gt;x_lsb); y = (finger_data-&gt;y_msb &lt;&lt; 8) | (finger_data-&gt;y_lsb); if (rmi4_data-&gt;hw_if-&gt;board_data-&gt;swap_axes) &#123; temp = x; x = y; y = temp; temp = wx; wx = wy; wy = temp; &#125; if (rmi4_data-&gt;hw_if-&gt;board_data-&gt;x_flip) x = rmi4_data-&gt;sensor_max_x - x; if (rmi4_data-&gt;hw_if-&gt;board_data-&gt;y_flip) y = rmi4_data-&gt;sensor_max_y - y; switch (finger_status) &#123; case F12_FINGER_STATUS: case F12_GLOVED_FINGER_STATUS: input_report_key(rmi4_data-&gt;input_dev, BTN_TOUCH, 1); input_report_key(rmi4_data-&gt;input_dev, BTN_TOOL_FINGER, 1); input_report_abs(rmi4_data-&gt;input_dev, ABS_MT_POSITION_X, x); input_report_abs(rmi4_data-&gt;input_dev, ABS_MT_POSITION_Y, y); ...... &#125; ...... input_sync(rmi4_data-&gt;input_dev); mutex_unlock(&amp;(rmi4_data-&gt;rmi4_report_mutex)); return touch_count;&#125; è°ƒç”¨input_report_key()ã€input_report_abs()ã€input_sync() ä¸ŠæŠ¥ã€åŒæ­¥æ•°æ®ã€‚ ï¼ˆå…«ï¼‰ã€å‚è€ƒæ–‡æ¡£(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šLinux/Androidâ€”-Inputç³»ç»ŸAndroid Inputå­ç³»ç»Ÿæµ…è°ˆAndroid(Linux) è¾“å…¥å­ç³»ç»Ÿè§£æinputå­ç³»ç»Ÿåˆ†æä¹‹ä¸‰:é©±åŠ¨æ¨¡å—Linuxé©±åŠ¨æ¡†æ¶ä¹‹â€”-Inputå­ç³»ç»Ÿinputå­ç³»ç»Ÿäº‹ä»¶å¤„ç†å±‚(evdev)çš„ç¯å½¢ç¼“å†²åŒºlinux inputè¾“å…¥å­ç³»ç»Ÿåˆ†æã€Šå››ã€‹ï¼šinputå­ç³»ç»Ÿæ•´ä½“æµç¨‹å…¨é¢åˆ†æLinux inputå­ç³»ç»Ÿåˆ†æä¹‹äºŒï¼šæ·±å…¥å‰–æinput_handlerã€input_coreã€input_device","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android WindowManagerService çª—å£ç®¡ç†æœåŠ¡ åˆ†æ [i.wonder~]","slug":"Android-7-1-2-Android-N-Android-WindowManagerService-çª—å£ç®¡ç†æœåŠ¡åˆ†æ-i-wonder","date":"2018-02-28T16:00:00.000Z","updated":"2018-04-19T14:30:05.646Z","comments":true,"path":"2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-çª—å£ç®¡ç†æœåŠ¡åˆ†æ-i-wonder/","link":"","permalink":"http://zhoujinjian.cc/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-çª—å£ç®¡ç†æœåŠ¡åˆ†æ-i-wonder/","excerpt":"çª—å£ç®¡ç†ç³»ç»ŸWMSæ˜¯Androidä¸­çš„ä¸»è¦å­ç³»ç»Ÿä¹‹ä¸€ï¼Œå®ƒæ¶‰åŠåˆ°Appä¸­ç»„ä»¶çš„ç®¡ç†ï¼Œç³»ç»Ÿå’Œåº”ç”¨çª—å£çš„ç®¡ç†å’Œç»˜åˆ¶ç­‰å·¥ä½œã€‚ç”±äºå…¶æ¶‰åŠæ¨¡å—ä¼—å¤šï¼Œä¸”ä¸ç”¨æˆ·ä½“éªŒå¯†åˆ‡ç›¸å…³ï¼Œæ‰€ä»¥å®ƒä¹Ÿæ˜¯Androidå½“ä¸­æœ€ä¸ºå¤æ‚çš„å­ç³»ç»Ÿä¹‹ä¸€ã€‚ä¸€ä¸ªAppä»å¯åŠ¨åˆ°ä¸»çª—å£æ˜¾ç¤ºå‡ºæ¥ï¼Œéœ€è¦Appï¼ŒActivityManagerServiceï¼ˆAMSï¼‰ï¼ŒWindowManagerServiceï¼ˆWMSï¼‰ï¼ŒSurfaceFlingerï¼ˆSFï¼‰ç­‰å‡ ä¸ªæ¨¡å—ç›¸äº’åˆä½œã€‚Appè´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼Œç»˜åˆ¶è‡ªå·±çš„è§†å›¾ï¼›AMSç®¡ç†ç»„ä»¶ã€è¿›ç¨‹ä¿¡æ¯å’ŒActivityçš„å †æ ˆåŠçŠ¶æ€ç­‰ç­‰ï¼›WMSç®¡ç†Activityå¯¹åº”çš„çª—å£åŠå­çª—å£ï¼Œè¿˜æœ‰ç³»ç»Ÿçª—å£ç­‰ï¼›SFç”¨äºç®¡ç†å›¾å½¢ç¼“å†²åŒºï¼Œå°†Appç»˜åˆ¶çš„ä¸œè¥¿åˆæˆæ¸²æŸ“åœ¨å±å¹•ä¸Šã€‚","text":"çª—å£ç®¡ç†ç³»ç»ŸWMSæ˜¯Androidä¸­çš„ä¸»è¦å­ç³»ç»Ÿä¹‹ä¸€ï¼Œå®ƒæ¶‰åŠåˆ°Appä¸­ç»„ä»¶çš„ç®¡ç†ï¼Œç³»ç»Ÿå’Œåº”ç”¨çª—å£çš„ç®¡ç†å’Œç»˜åˆ¶ç­‰å·¥ä½œã€‚ç”±äºå…¶æ¶‰åŠæ¨¡å—ä¼—å¤šï¼Œä¸”ä¸ç”¨æˆ·ä½“éªŒå¯†åˆ‡ç›¸å…³ï¼Œæ‰€ä»¥å®ƒä¹Ÿæ˜¯Androidå½“ä¸­æœ€ä¸ºå¤æ‚çš„å­ç³»ç»Ÿä¹‹ä¸€ã€‚ä¸€ä¸ªAppä»å¯åŠ¨åˆ°ä¸»çª—å£æ˜¾ç¤ºå‡ºæ¥ï¼Œéœ€è¦Appï¼ŒActivityManagerServiceï¼ˆAMSï¼‰ï¼ŒWindowManagerServiceï¼ˆWMSï¼‰ï¼ŒSurfaceFlingerï¼ˆSFï¼‰ç­‰å‡ ä¸ªæ¨¡å—ç›¸äº’åˆä½œã€‚Appè´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼Œç»˜åˆ¶è‡ªå·±çš„è§†å›¾ï¼›AMSç®¡ç†ç»„ä»¶ã€è¿›ç¨‹ä¿¡æ¯å’ŒActivityçš„å †æ ˆåŠçŠ¶æ€ç­‰ç­‰ï¼›WMSç®¡ç†Activityå¯¹åº”çš„çª—å£åŠå­çª—å£ï¼Œè¿˜æœ‰ç³»ç»Ÿçª—å£ç­‰ï¼›SFç”¨äºç®¡ç†å›¾å½¢ç¼“å†²åŒºï¼Œå°†Appç»˜åˆ¶çš„ä¸œè¥¿åˆæˆæ¸²æŸ“åœ¨å±å¹•ä¸Šã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘æºç ï¼ˆéƒ¨åˆ†ï¼‰ï¼š/frameworks/base/services/core/java/com/android/server/am/ ActivityStack.java ActivityManagerService.java ActivityStackSupervisor.java ActivityStarter.java ActivityRecord.java /frameworks/base/core/java/android/view/ WindowManagerImpl.java ViewManager.java WindowManagerGlobal.java ViewRootImpl.java Choreographer.java IWindowSession.aidl DisplayEventReceiver.java SurfaceControl.java Surface.java SurfaceSession.java /frameworks/base/services/core/java/com/android/server/wm/ WindowManagerService.java AppWindowAnimator.java AppTransition.java AppWindowToken.java Session.java WindowState.java WindowAnimator.java WindowStateAnimator.java WindowSurfacePlacer.java WindowSurfaceController.java ã€åšå®¢åŸå›¾é“¾æ¥ã€‘æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹çª—å£å¯åŠ¨ã€é€€å‡ºè¿‡ç¨‹åŠ¨æ€å›¾ï¼Œä¹‹åå†è¯¦ç»†åˆ†æï¼š ï¼ˆä¸€ï¼‰ã€Window ç»„ç»‡æ–¹å¼ActivityManagerServiceï¼ˆAMSï¼‰ï¼ŒWindowManagerServiceï¼ˆWMSï¼‰ï¼ŒSurfaceFlingerï¼ˆSFï¼‰ç­‰å‡ ä¸ªæ¨¡å—ç›¸äº’åˆä½œã€‚Appè´Ÿè´£ä¸šåŠ¡é€»è¾‘ï¼Œç»˜åˆ¶è‡ªå·±çš„è§†å›¾ï¼›AMSç®¡ç†ç»„ä»¶ã€è¿›ç¨‹ä¿¡æ¯å’ŒActivityçš„å †æ ˆåŠçŠ¶æ€ç­‰ç­‰ï¼›WMSç®¡ç†Activityå¯¹åº”çš„çª—å£åŠå­çª—å£ï¼Œè¿˜æœ‰ç³»ç»Ÿçª—å£ç­‰ï¼›SFç”¨äºç®¡ç†å›¾å½¢ç¼“å†²åŒºï¼Œå°†Appç»˜åˆ¶çš„ä¸œè¥¿åˆæˆæ¸²æŸ“åœ¨å±å¹•ä¸Šã€‚ çª—å£ç®¡ç†ç³»ç»Ÿä¸»è¦æ¡†æ¶ï¼š ä¸»è¦å¯¹è±¡åŠŸèƒ½ä»‹ç»ï¼š WindowManagerServiceè´Ÿè´£å®Œæˆçª—å£çš„ç®¡ç†å·¥ä½œ WindowStateå’Œåº”ç”¨ç«¯çª—å£ä¸€ä¸€å¯¹åº”ï¼Œåº”ç”¨è°ƒç”¨WMSæ·»åŠ çª—å£æ—¶ï¼Œæœ€ç»ˆä¼šåœ¨WindowManagerService.addWindow()åˆ›å»ºä¸€ä¸ªWindowStateä¸ä¹‹ä¸€ä¸€å¯¹åº” WindowTokenæ˜¯ä¸€ä¸ªå¥æŸ„ï¼Œä¿å­˜äº†æ‰€æœ‰å…·æœ‰åŒä¸€ä¸ªtokençš„WindowStateã€‚åº”ç”¨è¯·æ±‚WindowManagerServiceæ·»åŠ çª—å£çš„æ—¶å€™ï¼Œæä¾›äº†ä¸€ä¸ªtokenï¼Œè¯¥tokenæ ‡è¯†äº†è¢«æ·»åŠ çª—å£çš„å½’å±ï¼ŒWindowManagerServiceä¸ºè¯¥tokenç”Ÿæˆä¸€ä¸ªWindowTokenå¯¹è±¡ï¼Œæ‰€æœ‰tokenç›¸åŒçš„WindowStateè¢«å…³è”åˆ°åŒä¸€ä¸ªWindowTokenï¼Œå¦‚è¾“å…¥æ³•æ·»åŠ çª—å£æ—¶ï¼Œä¼šä¼ é€’ä¸€ä¸ªIBinder mCurTokenï¼Œå¢™çº¸æœåŠ¡æ·»åŠ çª—å£æ—¶ï¼Œä¼šä¼ é€’ä¸€ä¸ªWallpaperConnection::final Binder mTokenã€‚ AppWindowTokenç»§æ‰¿äºWindowTokenï¼Œä¸“é—¨ç”¨äºæ ‡è¯†ä¸€ä¸ªActivityã€‚AppWindowTokené‡Œçš„tokenå®é™…ä¸Šå°±æ˜¯æŒ‡å‘äº†ä¸€ä¸ªActivityã€‚ActivityManagerServiceé€šçŸ¥åº”ç”¨å¯åŠ¨çš„æ—¶å€™ï¼Œåœ¨æœåŠ¡ç«¯ç”Ÿæˆä¸€ä¸ªtokenç”¨äºæ ‡è¯†è¯¥Activityï¼Œå¹¶ä¸”æŠŠè¯¥tokenä¼ é€’åˆ°åº”ç”¨å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯çš„Activityåœ¨ç”³è¯·æ·»åŠ çª—å£æ—¶ï¼Œä»¥è¯¥tokenä½œä¸ºæ ‡è¯†ä¼ é€’åˆ°WindowManagerServiceã€‚åŒä¸€ä¸ªActivityä¸­çš„ä¸»çª—å£ã€å¯¹è¯æ¡†çª—å£ã€èœå•çª—å£éƒ½å…³è”åˆ°åŒä¸€ä¸ªAppWindowTokenã€‚ Sessionè¡¨ç¤ºä¸€ä¸ªå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çš„äº¤äº’ä¼šè¯ã€‚ä¸€èˆ¬æ¥è¯´ä¸åŒçš„åº”ç”¨é€šè¿‡ä¸åŒçš„ä¼šè¯æ¥å’ŒWindowManagerServiceäº¤äº’ï¼Œä½†æ˜¯å¤„äºåŒä¸€ä¸ªè¿›ç¨‹çš„ä¸åŒåº”ç”¨é€šè¿‡åŒä¸€ä¸ªSessionæ¥äº¤äº’ã€‚ 1.1ã€Android Tokenä»‹ç»Tokenæ˜¯ActivityRecordçš„å†…éƒ¨é™æ€ç±»ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹Tokençš„ç»§æ‰¿å…³ç³»ï¼ŒToken extends IApplicationToken.Stubï¼Œä»IApplicationToken.Stubç±»è¿›è¡Œç»§æ‰¿ï¼Œæ ¹æ®Binderçš„æœºåˆ¶å¯ä»¥çŸ¥é“Tokenæ˜¯ä¸€ä¸ªåŒ¿åBinderå®ä½“ç±»ï¼Œè¿™ä¸ªåŒ¿åBinderå®ä½“ä¼šä¼ é€’ç»™å…¶ä»–è¿›ç¨‹ï¼Œå…¶ä»–è¿›ç¨‹ä¼šæ‹¿åˆ°Tokençš„ä»£ç†ç«¯ã€‚ æˆ‘ä»¬çŸ¥é“åŒ¿åBinderæœ‰ä¸¤ä¸ªæ¯”è¾ƒé‡è¦çš„ç”¨é€”ï¼Œä¸€ä¸ªæ˜¯æ‹¿åˆ°Binderä»£ç†ç«¯åå¯è·¨Binderè°ƒç”¨å®ä½“ç«¯çš„å‡½æ•°æ¥å£ï¼Œå¦ä¸€ä¸ªä½œç”¨ä¾¿æ˜¯åœ¨å¤šä¸ªè¿›ç¨‹ä¸­æ ‡è¯†åŒä¸€ä¸ªå¯¹è±¡ã€‚å¾€å¾€è¿™ä¸¤ä¸ªä½œç”¨æ˜¯åŒæ—¶å­˜åœ¨çš„ï¼Œæ¯”å¦‚æˆ‘ä»¬è¿™é‡Œç ”ç©¶çš„Tokenå°±åŒæ—¶å­˜åœ¨è¿™ä¸¤ä¸ªä½œç”¨ï¼Œä½†æœ€é‡è¦çš„ä¾¿æ˜¯åè€…ï¼ŒTokenæ ‡è¯†äº†ä¸€ä¸ªActivityRecordå¯¹è±¡ï¼Œå³é—´æ¥æ ‡è¯†äº†ä¸€ä¸ªActivityã€‚ Tokenæ¢³ç†ï¼š åˆ†ææºç ï¼Œæˆ‘ä»¬å‘ç°ï¼Œå¤§å¤šæ•° token çš„å¯¹è±¡ï¼Œéƒ½è¡¨ç¤ºä¸€ä¸ª IBinder å¯¹è±¡ã€‚æåˆ° IBinderï¼Œå¤§å®¶ä¸€ç‚¹ä¹Ÿä¸é™Œç”Ÿï¼Œå°±æ˜¯ Android çš„ IPC é€šä¿¡æœºåˆ¶ã€‚åœ¨åˆ›å»ºçª—å£è¿‡ç¨‹ä¸­ï¼Œæ¶‰åŠåˆ°çš„ IPC é€šä¿¡ï¼Œæ— éåŒ…å«ä¸¤æ–¹é¢ï¼Œä¸€ä¸ªæ˜¯ WmS ç”¨æ¥è·Ÿåº”ç”¨æ‰€åœ¨çš„è¿›ç¨‹è¿›è¡Œé€šä¿¡çš„ ViewRootImpl.W ç±»çš„å¯¹è±¡ï¼Œå¦ä¸€ä¸ªæ˜¯æŒ‡å‘ä¸€ä¸ª ActivityRecord çš„å¯¹è±¡ï¼Œè‡ªç„¶åº”è¯¥æ˜¯WMSç”¨æ¥è·Ÿ AMSè¿›è¡Œé€šä¿¡çš„äº†ã€‚æˆ‘ä»¬æ¢³ç†äº†ä¸€ä¸‹ï¼Œtoken ä»¥ä¸‹å‡ å¤„çš„å®šä¹‰ï¼Œåˆ†åˆ«æ¥è®²è®²è¿™é‡Œçš„ token ä»£è¡¨ä»€ä¹ˆã€‚ åˆ†æä¸€ä¸‹ View çš„ AttachInfo çš„èµ‹å€¼ã€‚ViewRootImpl åœ¨æ„å»ºæ–¹æ³•é‡Œï¼Œä¼šåˆå§‹åŒ–ä¸€ä¸ª AttachInfo å®ä¾‹ï¼ŒæŠŠå®ƒçš„ Sessionï¼Œä»¥åŠ Wç±»å¯¹è±¡èµ‹å€¼ç»™ AttachInfoã€‚åˆ†æå¯ä»¥çœ‹åˆ°ï¼ŒAttachInfo ä¸­çš„ mWindowTokenï¼Œä¸mWindow éƒ½æ˜¯æŒ‡å‘ ViewRootImpl ä¸­çš„ mWindow(Wç±»å®ä¾‹)ã€‚å½“ä¸€ä¸ª View attach åˆ°çª—å£åï¼ŒViewRootImplä¼šæ‰§è¡ŒperformTraversalsï¼Œå¦‚æœå‘ç°æ˜¯é¦–æ¬¡è°ƒç”¨ä¼šï¼Œä¼šæŠŠè‡ªå·±çš„ mAttachInfo ä¼ é€’ç»™æ ¹ Viewï¼ˆé€šè¿‡dispatchAttachedToWindowï¼‰ï¼Œå‘Šè¯‰ View æ ‘ç°åœ¨å·²ç» attch to Window äº†ï¼Œé©¬ä¸Šå¯ä»¥æ˜¾ç¤ºäº†ã€‚æ ¹ Viewï¼ˆä¸€èˆ¬æ˜¯ ViewGroupï¼‰ä¼šæŠŠè¿™ä¸ªä¿¡æ¯ï¼Œéå†åœ°ä¼ é€’ç»™ View æ ‘ä¸­çš„æ¯ä¸€ä¸ªå­ Viewï¼Œè¿™æ ·æ¯ä¸ª View çš„ mAttachInfo éƒ½è¢«èµ‹å€¼ä¸º ViewRootImp çš„ mAttachInfoäº†ã€‚ 1.1.1ã€Tokenå¯¹è±¡çš„åˆ›å»ºä¸‹é¢è¿™ä¸ªå›¾æ˜¯Tokençš„ä¼ é€’ï¼Œé¦–å…ˆä¼šä¼ é€’åˆ°WMSä¸­ï¼Œæ¥ç€ä¼šä¼ é€’åˆ°åº”ç”¨è¿›ç¨‹ActivityThreadä¸­ï¼Œä¸‹é¢æ¥å…·ä½“åˆ†æè¿™ä¸ªä¼ é€’æµç¨‹ã€‚ æ€»ä½“æµç¨‹å›¾ï¼š æˆ‘ä»¬ä¹‹å‰åˆ†æï¼šã€Android 7.1.2 (Android N) Activityå¯åŠ¨æµç¨‹åˆ†æã€‘ åœ¨å¯åŠ¨Activityè¿‡ç¨‹ä¸­ä¼šè°ƒç”¨ActivityStarter.startActivityLocked() 123456789101112131415161718192021222324[-&gt;ActivityStarter.java] final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ...... ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; ...... ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); ...... try &#123; err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); &#125; return err;&#125; å¯ä»¥çœ‹åˆ°åœ¨startActivityLocked()ä¸­åˆ›å»ºäº†ä¸€ä¸ªActivityRecordå¯¹è±¡ 1234567891011121314[-&gt;ActivityRecord.java]final IApplicationToken.Stub appToken; // window manager tokenActivityRecord(ActivityManagerService _service, ProcessRecord _caller, int _launchedFromUid, String _launchedFromPackage, Intent _intent, String _resolvedType, ActivityInfo aInfo, Configuration _configuration, ActivityRecord _resultTo, String _resultWho, int _reqCode, boolean _componentSpecified, boolean _rootVoiceInteraction, ActivityStackSupervisor supervisor, ActivityContainer container, ActivityOptions options, ActivityRecord sourceRecord) &#123; service = _service; appToken = new Token(this, service); ...... &#125; åœ¨ActivityRecordçš„æ„é€ å‡½æ•°ä¸­åˆ›å»ºï¼Œæ ‡è¯†ç€å½“å‰è¿™ä¸ªActivityRecordï¼Œå³é—´æ¥ä»£è¡¨ç€ä¸€ä¸ªActivityã€‚ 1.1.2ã€AMSè°ƒç”¨WMSçš„addAPPToken()æ¥å£åœ¨å¯åŠ¨ä¸€ä¸ªActivityæ—¶ï¼Œä¼šè°ƒç”¨startActivityLocked()æ¥åœ¨WMSä¸­æ·»åŠ ä¸€ä¸ªAppWindowTokenå¯¹è±¡ startActivityLocked()åˆ›å»ºActivityRecordå¯¹è±¡åä¼šç»§ç»­è°ƒç”¨startActivityUnchecked()æ–¹æ³•ã€‚ 12345678[-&gt;ActivityStarter.java]private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ...... mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions); ...... &#125; 12345678910111213141516171819[-&gt;ActivityStack.java]final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123; ...... addConfigOverride(r, task); ...... &#125; void addConfigOverride(ActivityRecord r, TaskRecord task) &#123; final Rect bounds = task.updateOverrideConfigurationFromLaunchBounds(); // è·³è½¬åˆ°WMS mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind, bounds, task.mOverrideConfig, task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(), r.appInfo.targetSdkVersion, r.mRotationAnimationHint); r.taskConfigOverride = task.mOverrideConfig; &#125; æˆ‘ä»¬ç»§ç»­çœ‹ä¸‹WindowManager.addAppToken()æ–¹æ³• 123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;WindowManagerService.java] @Override public void addAppToken(int addPos, IApplicationToken token, int taskId, int stackId, int requestedOrientation, boolean fullscreen, boolean showForAllUsers, int userId, int configChanges, boolean voiceInteraction, boolean launchTaskBehind, Rect taskBounds, Configuration config, int taskResizeMode, boolean alwaysFocusable, boolean homeTask, int targetSdkVersion, int rotationAnimationHint) &#123; ...... synchronized(mWindowMap) &#123; AppWindowToken atoken = findAppWindowToken(token.asBinder()); if (atoken != null) &#123; Slog.w(TAG_WM, \"Attempted to add existing app token: \" + token); return; &#125; //æ ¹æ®ActivityRecordä¸­IApplicationToken.Stubçš„ä»£ç†ï¼Œåˆ›å»ºAppWindowToken atoken = new AppWindowToken(this, token, voiceInteraction); atoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos; atoken.appFullscreen = fullscreen; atoken.showForAllUsers = showForAllUsers; atoken.targetSdk = targetSdkVersion; atoken.requestedOrientation = requestedOrientation; atoken.layoutConfigChanges = (configChanges &amp; (ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_ORIENTATION)) != 0; atoken.mLaunchTaskBehind = launchTaskBehind; atoken.mAlwaysFocusable = alwaysFocusable; atoken.mRotationAnimationHint = rotationAnimationHint; Task task = mTaskIdToTask.get(taskId); if (task == null) &#123; task = createTaskLocked(taskId, stackId, userId, atoken, taskBounds, config); &#125; task.addAppToken(addPos, atoken, taskResizeMode, homeTask); //å°†atokenæ”¾å…¥åˆ°mTokenMapä¸­ï¼Œç­‰åº”ç”¨ç¨‹åºaddWindowæ—¶ï¼Œè¿›è¡Œèº«ä»½éªŒè¯ //å…¶ä¸­token.asBinder()æ˜¯IApplicationToken.Stubçš„ä»£ç†ï¼Œatokenå°±æ˜¯æ ¹æ®ä»£ç†ï¼Œå¾—åˆ°å¯¹åº”AppWindowToken mTokenMap.put(token.asBinder(), atoken); // Application tokens start out hidden. atoken.hidden = true; atoken.hiddenRequested = true; &#125; &#125; 1.1.3ã€AMSè·¨Binderè°ƒç”¨åº”ç”¨è¿›ç¨‹çš„scheduleLaunchActivity()å°†Tokenä¼ é€’ç»™ä¸Šå±‚åº”ç”¨è¿›ç¨‹å½“æ¡†æ¶é€šè¿‡ApplicationThreadçš„ä»£ç†å›è°ƒåˆ°ActivityThreadçš„æ—¶å€™ï¼Œå°†å¯¹åº”çš„æ­¥éª¤ä¸€ç§ç”Ÿæˆçš„tokenä»£ç†ä¼ å…¥ã€‚ ActivityStackSupervisor.realStartActivityLocked() 1234567891011121314 [-&gt;ActivityStackSupervisor.java] final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...... return true;&#125; è¿™é‡Œé€šè¿‡è°ƒç”¨IApplicationThreadçš„æ–¹æ³•å®ç°çš„ï¼Œè¿™é‡Œè°ƒç”¨çš„æ˜¯scheduleLaunchActivity()æ–¹æ³•ï¼Œæ‰€ä»¥çœŸæ­£æ‰§è¡Œçš„æ˜¯ActivityThreadä¸­çš„scheduleLaunchActivity()ã€‚ 12345678910111213141516171819[-&gt; ActivityThread.java :ApplicationThread] @Override public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); //ä¼ é€’ç»™äº†ActivityThreadçš„tokenï¼Œè¿™ä¸ªtokenå°±æ˜¯IApplicationToken.Stubçš„ä»£ç† r.token = token; ...... updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 1.1.4ã€Activityçª—å£æ·»åŠ è¿‡ç¨‹è¯¦ç»†è¿‡ç¨‹è¯·æŸ¥çœ‹ï¼šã€Android 7.1.2 (Android N) Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹åˆ†æã€‘ 1234567891011121314151617181920212223242526272829303132333435[-&gt;ActivityThread.java] final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... r = performResumeActivity(token, clearHide, reason); ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //è·å¾—ä¸ºå½“å‰Activityåˆ›å»ºçš„çª—å£PhoneWindowå¯¹è±¡ r.window = r.activity.getWindow(); //è·å–ä¸ºçª—å£åˆ›å»ºçš„è§†å›¾DecorViewå¯¹è±¡ View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //åœ¨attachå‡½æ•°ä¸­å°±ä¸ºå½“å‰Activityåˆ›å»ºäº†WindowManagerå¯¹è±¡ ViewManager wm = a.getWindowManager(); //å¾—åˆ°è¯¥è§†å›¾å¯¹è±¡çš„å¸ƒå±€å‚æ•° WindowManager.LayoutParams l = r.window.getAttributes(); //å°†è§†å›¾å¯¹è±¡ä¿å­˜åˆ°Activityçš„æˆå‘˜å˜é‡mDecorä¸­ a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ...... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //å°†åˆ›å»ºçš„è§†å›¾å¯¹è±¡DecorViewæ·»åŠ åˆ°Activityçš„çª—å£ç®¡ç†å™¨ä¸­ wm.addView(decor, l); &#125; ...... if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; ...... &#125;&#125; è¿›è€Œå±‚å±‚è°ƒç”¨åˆ°ï¼šViewRootImpl.setView() 12[-&gt;ViewRootImpl.java]WindowManager.LayoutParams l = r.window.getAttributes(); ViewRootImpl.setView()å‡½æ•°ä¸­æ·»åŠ Activityçª—å£æ—¶åœ¨å‚æ•°mWindowAttributesä¸­æºå¸¦Tokenä»£ç†å¯¹è±¡ 123456789101112131415[-&gt;ViewManager.java]public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, InputChannel outInputChannel) &#123; ...... boolean addToken = false; //attrsè¿™ä¸ªæ˜¯åº”ç”¨ç¨‹åºActivityClientRecordä¸­ä¼ é€’è¿‡æ¥çš„å‚æ•°ï¼Œå…¶ä¸­çš„attrs.tokenå°±æ˜¯æ­¥éª¤ä¸‰ç§çš„r.token WindowToken token = mTokenMap.get(attrs.token); ...... win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); mWindowMap.put(client.asBinder(), win); ...... &#125; æ ¹æ®Binderæœºåˆ¶å¯ä»¥çŸ¥é“ä»ä¸Šå±‚åº”ç”¨ä¼ é€’è¿‡æ¥çš„Tokenä»£ç†å¯¹è±¡ä¼šè½¬æ¢æˆSystemServerè¿›ç¨‹ä¸­çš„Tokenæœ¬åœ°å¯¹è±¡ï¼Œåè€…ä¸ç¬¬2æ­¥ä¸­ä»Tokenå¯¹è±¡æ˜¯åŒä¸€ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥ä¸Šé¢è°ƒç”¨mTokenMap.get(attrs.token)æ—¶ä¾¿èƒ½è¿”å›æ­£ç¡®è¿”å›ä¸€ä¸ªWindowTokenï¼ˆè¿™ä¸ªWindowTokenå…¶å®æ˜¯ä¸€ä¸ªAPPWindowTokenï¼‰ï¼Œè¿™æ ·æ·»åŠ çš„çª—å£ä¹Ÿå°±è·ŸActivityå…³è”ä¸Šäº†ã€‚ 1.2ã€WMSç»„ç»‡æ–¹å¼Activityç®¡ç†æœåŠ¡ActivityManagerServiceä¸­æ¯ä¸€ä¸ªActivityRecordå¯¹è±¡åœ¨Windowç®¡ç†æœåŠ¡WindowManagerServiceä¸­éƒ½å¯¹åº”æœ‰ä¸€ä¸ªAppWindowTokenå¯¹è±¡ã€‚ æ­¤å¤–ï¼Œåœ¨è¾“å…¥æ³•ç®¡ç†æœåŠ¡InputMethodManagerServiceä¸­ï¼Œæ¯ä¸€ä¸ªè¾“å…¥æ³•çª—å£éƒ½å¯¹åº”æœ‰ä¸€ä¸ªBinderå¯¹è±¡ï¼Œè¿™ä¸ªBinderå¯¹è±¡åœ¨Windowç®¡ç†æœåŠ¡WindowManagerServiceåˆå¯¹åº”æœ‰ä¸€ä¸ªWindowTokenå¯¹è±¡ã€‚ ä¸è¾“å…¥æ³•çª—å£ç±»ä¼¼ï¼Œåœ¨å£çº¸ç®¡ç†æœåŠ¡WallpaperManagerServiceä¸­ï¼Œæ¯ä¸€ä¸ªå£çº¸çª—å£éƒ½å¯¹åº”æœ‰ä¸€ä¸ªBinderå¯¹è±¡ï¼Œè¿™ä¸ªBinderå¯¹è±¡åœ¨Windowç®¡ç†æœåŠ¡WindowManagerServiceä¹Ÿå¯¹åº”æœ‰ä¸€ä¸ªWindowTokenå¯¹è±¡ã€‚ åœ¨Windowç®¡ç†æœåŠ¡WindowManagerServiceä¸­ï¼Œæ— è®ºæ˜¯AppWindowTokenå¯¹è±¡ï¼Œè¿˜æ˜¯WindowTokenå¯¹è±¡ï¼Œå®ƒä»¬éƒ½æ˜¯ç”¨æ¥æè¿°ä¸€ç»„æœ‰ç€ç›¸åŒä»¤ç‰Œçš„çª—å£çš„ï¼Œæ¯ä¸€ä¸ªçª—å£éƒ½æ˜¯é€šè¿‡ä¸€ä¸ªWindowStateå¯¹è±¡æ¥æè¿°çš„ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªActivityç»„ä»¶çª—å£å¯èƒ½æœ‰ä¸€ä¸ªå¯åŠ¨çª—å£ï¼ˆStarting Windowï¼‰ï¼Œè¿˜æœ‰è‹¥å¹²ä¸ªå­çª—å£ï¼Œé‚£ä¹ˆè¿™äº›çª—å£å°±ä¼šç»„æˆä¸€ç»„ï¼Œå¹¶ä¸”éƒ½æ˜¯ä»¥Activityç»„ä»¶åœ¨Windowç®¡ç†æœåŠ¡WindowManagerServiceä¸­æ‰€å¯¹åº”çš„AppWindowTokenå¯¹è±¡ä¸ºä»¤ç‰Œçš„ã€‚ä»æŠ½è±¡çš„è§’åº¦æ¥çœ‹ï¼Œå°±æ˜¯åœ¨Windowç®¡ç†æœåŠ¡WindowManagerServiceä¸­ï¼Œæ¯ä¸€ä¸ªä»¤ç‰Œï¼ˆAppWindowTokenæˆ–è€…WindowTokenï¼‰éƒ½æ˜¯ç”¨æ¥æè¿°ä¸€ç»„çª—å£ï¼ˆWindowStateï¼‰çš„ï¼Œå¹¶ä¸”æ¯ä¸€ä¸ªçª—å£çš„å­çª—å£ä¹Ÿæ˜¯ä¸å®ƒåŒå±äºä¸€ä¸ªç»„ï¼Œå³éƒ½æœ‰ç€ç›¸åŒçš„ä»¤ç‰Œã€‚ å…¶ä¸­ï¼ŒActivity Stackæ˜¯åœ¨ActivityManagerServiceæœåŠ¡ä¸­åˆ›å»ºçš„ï¼ŒToken Listå’ŒWindow Stackæ˜¯åœ¨WindowManagerServiceä¸­åˆ›å»ºçš„ï¼Œè€ŒBinder for IMå’ŒBinder for WPåˆ†åˆ«æ˜¯åœ¨InputMethodManagerServiceæœåŠ¡å’ŒWallpaperManagerServiceæœåŠ¡ä¸­åˆ›å»ºçš„ï¼Œç”¨æ¥æè¿°ä¸€ä¸ªè¾“å…¥æ³•çª—å£å’Œä¸€ä¸ªå£çº¸çª—å£ã€‚ 1.3ã€WMSçª—å£ç±»å‹æ·»åŠ ä¸€ä¸ªçª—å£æ˜¯é€šè¿‡ WindowManagerGlobal.addView()æ¥å®Œæˆçš„ï¼Œåˆ†æ addView æ–¹æ³•çš„å‚æ•°ï¼Œæœ‰ä¸‰ä¸ªå‚æ•°æ˜¯å¿…ä¸å¯å°‘çš„ï¼Œviewï¼Œparamsï¼Œä»¥åŠ displayã€‚è€Œ display ä¸€èˆ¬ç›´æ¥å– WindowMnagerImpl ä¸­çš„ mDisplayï¼Œè¡¨ç¤ºè¦è¾“å‡ºçš„æ˜¾ç¤ºè®¾å¤‡ã€‚view è‡ªç„¶è¡¨ç¤ºè¦æ˜¾ç¤ºçš„ Viewï¼Œè€Œ params æ˜¯ WindowManager.LayoutParamsï¼Œç”¨æ¥æè¿°è¿™ä¸ª view çš„äº›çª—å£å±æ€§ï¼Œå…¶ä¸­ä¸€ä¸ªé‡è¦çš„å‚æ•° typeï¼Œç”¨æ¥æè¿°çª—å£çš„ç±»å‹ã€‚ 12345678910111213[-&gt;WindowManagerGlobal] public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; ``` } 1234567æ‰“å¼€WindowManagerç±»ï¼Œçœ‹åˆ°é™æ€å†…éƒ¨ç±»ã€‚``` java[-&gt;WindowManager]public static class LayoutParams extends ViewGroup.LayoutParams implements Parcelable &#123;......&#125; å¯ä»¥çœ‹åˆ°åœ¨LayoutParamsä¸­ï¼Œæœ‰2ä¸ªæ¯”è¾ƒé‡è¦çš„å‚æ•°: flags,typeã€‚ æˆ‘ä»¬ç®€è¦çš„åˆ†æä¸€ä¸‹flags,è¯¥å‚æ•°è¡¨ç¤ºWindowçš„å±æ€§ï¼Œå®ƒæœ‰å¾ˆå¤šé€‰é¡¹ï¼Œé€šè¿‡è¿™äº›é€‰é¡¹å¯ä»¥æ§åˆ¶Windowçš„æ˜¾ç¤ºç‰¹æ€§ï¼Œè¿™é‡Œä¸»è¦ä»‹ç»å‡ ä¸ªæ¯”è¾ƒå¸¸ç”¨çš„é€‰é¡¹ã€‚ FLAG_NOT_FOCUSABLE è¡¨ç¤ºWindowä¸éœ€è¦è·å–ç„¦ç‚¹ï¼Œä¹Ÿä¸éœ€è¦æ¥æ”¶å„ç§è¾“å…¥äº‹ä»¶ï¼Œæ­¤æ ‡è®°ä¼šåŒæ—¶å¯ç”¨FLAG_NOT_TOUCH_MODALï¼Œæœ€ç»ˆäº‹ä»¶ä¼šç›´æ¥ä¼ é€’ç»™ä¸‹å±‚å…·æœ‰ç„¦ç‚¹çš„Windowã€‚ FLAG_NOT_TOUCH_MODAL ç³»ç»Ÿä¼šå°†å½“å‰WindowåŒºåŸŸä»¥å¤–çš„å•å‡»äº‹ä»¶ä¼ é€’ç»™åº•å±‚çš„Windowï¼Œå½“å‰WindowåŒºåŸŸä»¥å†…çš„å•å‡»äº‹ä»¶åˆ™è‡ªå·±å¤„ç†ï¼Œè¿™ä¸ªæ ‡è®°å¾ˆé‡è¦ï¼Œä¸€èˆ¬æ¥è¯´éƒ½éœ€è¦å¼€å¯æ­¤æ ‡è®°ï¼Œå¦åˆ™å…¶ä»–Windowå°†æ— æ³•æ¥æ”¶åˆ°å•å‡»äº‹ä»¶ã€‚ FLAG_SHOW_WHEN_LOCKED å¼€å¯æ­¤æ¨¡å¼å¯ä»¥è®©Windowæ˜¾ç¤ºåœ¨é”å±çš„ç•Œé¢ä¸Šã€‚ Typeå‚æ•°è¡¨ç¤ºWindowçš„ç±»å‹ï¼ŒWindowæœ‰ä¸‰ç§ç±»å‹ï¼Œåˆ†åˆ«æ˜¯åº”ç”¨Windowã€å­Windowã€ç³»ç»ŸWindowã€‚åº”ç”¨ç±»Windowå¯¹åº”ç€ä¸€ä¸ªActivityã€‚å­Windowä¸èƒ½å•ç‹¬å­˜åœ¨ï¼Œå®ƒéœ€è¦é™„å±åœ¨ç‰¹å®šçš„çˆ¶Windowä¹‹ä¸­ï¼Œæ¯”å¦‚å¸¸è§çš„PopupWindowå°±æ˜¯ä¸€ä¸ªå­Windowã€‚æœ‰äº›ç³»ç»ŸWindowæ˜¯éœ€è¦å£°æ˜æƒé™æ‰èƒ½åˆ›å»ºçš„Windowï¼Œæ¯”å¦‚Toastå’Œç³»ç»ŸçŠ¶æ€æ è¿™äº›éƒ½æ˜¯ç³»ç»ŸWindowã€‚ 1.3.1ã€åº”ç”¨çª—å£Activity å¯¹åº”çš„çª—å£ç±»å‹æ˜¯åº”ç”¨çª—å£ï¼Œ æ‰€æœ‰ Activity é»˜è®¤çš„çª—å£ç±»å‹æ˜¯ TYPE_BASE_APPLICATIONã€‚ WindowManager çš„ LayoutParams çš„é»˜è®¤ç±»å‹æ˜¯ TYPE_APPLICATIONã€‚ Dialog å¹¶æ²¡æœ‰è®¾ç½®typeï¼Œæ‰€ä»¥ä¹Ÿæ˜¯é»˜è®¤çš„çª—å£ç±»å‹å³ TYPE_APPLICATIONã€‚ 1234567[-&gt;WindowManager.LayoutParams]public LayoutParams() &#123; super(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT); type = TYPE_APPLICATION; format = PixelFormat.OPAQUE;&#125; typeå±‚çº§ ç±»å‹ FIRST_APPLICATION_WINDOW=1 å¼€å§‹åº”ç”¨ç¨‹åºçª—å£ï¼Œç¬¬ä¸€ä¸ªæ™®é€šåº”ç”¨çª—å£ TYPE_BASE_APPLICATION=1 æ‰€æœ‰ç¨‹åºçª—å£çš„baseçª—å£ï¼Œå…¶ä»–åº”ç”¨ç¨‹åºçª—å£éƒ½æ˜¾ç¤ºåœ¨å®ƒä¸Šé¢ TYPE_APPLICATION=2 æ™®é€šåº”ç”¨ç¨‹åºçª—å£ï¼Œtokenå¿…é¡»è®¾ç½®ä¸ºActivityçš„tokenæ¥æŒ‡å®šçª—å£å±äºè° TYPE_APPLICATION_STARTING=3 åº”ç”¨ç¨‹åºå¯åŠ¨æ—¶å…ˆæ˜¾ç¤ºæ­¤çª—å£ï¼Œå½“çœŸæ­£çš„çª—å£é…ç½®å®Œæˆåï¼Œå…³é—­æ­¤çª—å£ LAST_APPLICATION_WINDOW=99 æœ€åä¸€ä¸ªåº”ç”¨çª—å£ 1.3.2ã€å­çª—å£å­çª—å£ä¸èƒ½å•ç‹¬å­˜åœ¨ï¼Œå®ƒéœ€è¦é™„å±åœ¨ç‰¹å®šçš„çˆ¶Windowä¹‹ä¸­ï¼Œä¾‹å¦‚å¼€ç¯‡ç¬¬ä¸€å¼ å›¾ï¼Œç»¿è‰²æ¡†æ¡†å³ä¸ºpopupWindowï¼Œå®ƒå°±æ˜¯å­çª—å£ï¼Œç±»å‹ä¸€èˆ¬ä¸ºTYPE_APPLICATION_PANELã€‚ä¹‹æ‰€ä»¥ç§°ä¸ºå­çª—å£ï¼Œå³å®ƒçš„çˆ¶çª—å£æ˜¾ç¤ºæ—¶ï¼Œå­çª—å£æ‰æ˜¾ç¤ºã€‚çˆ¶çª—å£ä¸æ˜¾ç¤ºï¼Œå®ƒä¹Ÿä¸æ˜¾ç¤ºã€‚è¿½éšçˆ¶çª—å£ã€‚ typeå±‚çº§ ç±»å‹ FIRST_SUB_WINDOW=1000 ç¬¬ä¸€ä¸ªå­çª—å£ TYPE_APPLICATION_PANEL=1000 åº”ç”¨çª—å£çš„å­çª—å£,popupWindowçš„é»˜è®¤ç±»å‹ TYPE_APPLICATION_MEDIA=1001 åª’ä½“çª—å£ TYPE_APPLICATION_SUB_PANEL=1002 TYPE_APPLICATION_PANEçš„å­çª—å£ TYPE_APPLICATION_ATTACHED_DIALOG=1003 å¯¹è¯æ¡†ï¼Œç±»ä¼¼äºé¢æ¿çª—å£(OptionMenu,ContextMenu) TYPE_APPLICATION_MEDIA_OVERLAY=1004 åª’ä½“ä¿¡æ¯ï¼Œæ˜¾ç¤ºåœ¨åª’ä½“å±‚å’Œç¨‹åºçª—å£ä¹‹é—´ï¼Œéœ€è¦å®ç°åŠé€æ˜æ•ˆæœ LAST_SUB_WINDOW=1999 æœ€åä¸€ä¸ªå­çª—å£ 1.3.3ã€ç³»ç»Ÿçª—å£ç³»ç»Ÿçª—å£è·Ÿåº”ç”¨çª—å£ä¸åŒï¼Œä¸éœ€è¦å¯¹åº” Activityã€‚è·Ÿå­çª—å£ä¸åŒï¼Œä¸éœ€è¦æœ‰çˆ¶çª—å£ã€‚ä¸€èˆ¬æ¥è®²ï¼Œç³»ç»Ÿçª—å£åº”è¯¥ç”±ç³»ç»Ÿæ¥åˆ›å»ºçš„ï¼Œä¾‹å¦‚å‘ç”Ÿå¼‚å¸¸ï¼ŒANRæ—¶çš„æç¤ºæ¡†ï¼Œåˆå¦‚ç³»ç»ŸçŠ¶æ€æ ï¼Œå±ä¿ç­‰ã€‚ä½†æ˜¯ï¼ŒFramework è¿˜æ˜¯å®šä¹‰äº†ä¸€äº›ï¼Œå¯ä»¥è¢«åº”ç”¨æ‰€åˆ›å»ºçš„ç³»ç»Ÿçª—å£ï¼Œå¦‚ TYPE _TOASTï¼ŒTYPE INPUT METHODï¼ŒTYPE _WALLPAPTER ç­‰ç­‰ã€‚ typeå±‚çº§ ç±»å‹ FIRST_SYSTEM_WINDOW=2000 ç¬¬ä¸€ä¸ªç³»ç»Ÿçª—å£ TYPE_STATUS_BAR=2000 çŠ¶æ€æ ï¼Œåªèƒ½æœ‰ä¸€ä¸ªçŠ¶æ€æ ï¼Œä½äºå±å¹•é¡¶ç«¯ TYPE_SEARCH_BAR =2001 æœç´¢æ  TYPE_PHONE=2002 ç”µè¯çª—å£ï¼Œå®ƒç”¨äºç”µè¯äº¤äº’ TYPE_SYSTEM_ALERT=2003 ç³»ç»Ÿè­¦å‘Šï¼Œå‡ºç°åœ¨åº”ç”¨ç¨‹åºçª—å£ä¹‹ä¸Š TYPE_KEYGUARD=2004 é”å±çª—å£ TYPE_TOAST=2005 ä¿¡æ¯çª—å£ï¼Œç”¨äºæ˜¾ç¤ºToast TYPE_SYSTEM_OVERLAY=2006 ç³»ç»Ÿé¡¶å±‚çª—å£ï¼Œæ˜¾ç¤ºåœ¨å…¶ä»–å†…å®¹ä¹‹ä¸Šï¼Œæ­¤çª—å£ä¸èƒ½è·å¾—è¾“å…¥ç„¦ç‚¹ï¼Œå¦åˆ™å½±å“é”å± TYPE_PRIORITY_PHONE=2007 å½“é”å±æ—¶æ˜¾ç¤ºçš„æ¥ç”µæ˜¾ç¤ºçª—å£ TYPE_SYSTEM_DIALOG=2008 ç³»ç»Ÿå¯¹è¯æ¡† TYPE_KEYGUARD_DIALOG=2009 é”å±æ—¶æ˜¾ç¤ºçš„å¯¹è¯æ¡† TYPE_SYSTEM_ERROR=2010 ç³»ç»Ÿå†…éƒ¨é”™è¯¯æç¤º TYPE_INPUT_METHOD=2011 è¾“å…¥æ³•çª—å£ï¼Œæ˜¾ç¤ºäºæ™®é€šåº”ç”¨/å­çª—å£ä¹‹ä¸Š TYPE_INPUT_METHOD_DIALOG=2012 è¾“å…¥æ³•ä¸­å¤‡é€‰æ¡†å¯¹åº”çš„çª—å£ TYPE_WALLPAPER=2013 å¢™çº¸çª—å£ TYPE_STATUS_BAR_PANEL=2014 æ»‘åŠ¨çŠ¶æ€æ¡åå‡ºç°çš„çª—å£ TYPE_SECURE_SYSTEM_OVERLAY=2015 å®‰å…¨ç³»ç»Ÿè¦†ç›–çª—å£ â€¦â€¦ â€¦â€¦ LAST_SYSTEM_WINDOW=2999 æœ€åä¸€ä¸ªç³»ç»Ÿçª—å£ é‚£ä¹ˆï¼Œè¿™ä¸ªtypeå±‚çº§åˆ°åº•æœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿ Windowæ˜¯åˆ†å±‚çš„ï¼Œæ¯ä¸ªWindowéƒ½æœ‰å¯¹åº”çš„z-orderedï¼Œï¼ˆzè½´ï¼Œä»1å±‚å±‚å åŠ åˆ°2999ï¼Œä½ å¯ä»¥å°†å±å¹•æƒ³æˆä¸‰ç»´åæ ‡æ¨¡å¼ï¼‰å±‚çº§å¤§çš„ä¼šè¦†ç›–åœ¨å±‚çº§å°çš„Windowä¸Šé¢ã€‚ åœ¨ä¸‰ç±»Windowä¸­ï¼Œåº”ç”¨Windowçš„å±‚çº§èŒƒå›´æ˜¯1~99ã€‚å­Windowçš„å±‚çº§èŒƒå›´æ˜¯1000~1999ï¼Œç³»ç»ŸWindowçš„å±‚çº§èŒƒå›´æ˜¯2000~2999ï¼Œè¿™äº›å±‚çº§èŒƒå›´å¯¹åº”ç€WindowManager.LayoutParamsçš„typeå‚æ•°ã€‚å¦‚æœæƒ³è¦Windowä½äºæ‰€æœ‰Windowçš„æœ€é¡¶å±‚ï¼Œé‚£ä¹ˆé‡‡ç”¨è¾ƒå¤§çš„å±‚çº§å³å¯ã€‚å¦å¤–æœ‰äº›ç³»ç»Ÿå±‚çº§çš„ä½¿ç”¨æ˜¯éœ€è¦å£°æ˜æƒé™çš„ã€‚ ï¼ˆäºŒï¼‰ã€Window Sizeï¼ˆå¤§å°ï¼‰å’Œ Window Positionï¼ˆä½ç½®ï¼‰ è®¡ç®—è¿‡ç¨‹ä¹‹å‰åœ¨ã€Android 7.1.2 (Android N) Android Graphics ç³»ç»Ÿåˆ†æ [i.wonder~]ã€‘åˆ†æè¿‡ï¼Œå½“Vsyncäº‹ä»¶åˆ°æ¥æ—¶ï¼Œå°±ä¼šé€šè¿‡Choreographerçš„postCallback()ï¼Œæ¥ç€æ‰§è¡ŒmTraversalRunnableå¯¹è±¡çš„run()æ–¹æ³•ã€‚ mTraversalRunnableå¯¹è±¡çš„ç±»å‹ä¸ºTraversalRunnableï¼Œè¯¥ç±»å®ç°äº†Runnableæ¥å£ï¼Œåœ¨å…¶run()å‡½æ•°ä¸­è°ƒç”¨äº†doTraversal()å‡½æ•°æ¥å®Œæˆçª—å£å¸ƒå±€ã€‚ä¸ºäº†åˆ†æçš„è¿è´¯æ€§ï¼Œè¿™é‡Œé‡æ–°è´´ä¸€ä¸‹æºç ï¼š 1234567891011121314151617[-&gt;ViewRootImpl.java]final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ...... performTraversals(); ...... &#125;&#125; performTraversals()å‡½æ•°ç›¸å½“å¤æ‚ï¼Œå…¶ä¸»è¦å®ç°ä»¥ä¸‹å‡ ä¸ªé‡è¦æ­¥éª¤ï¼š 1.æ‰§è¡Œçª—å£æµ‹é‡ï¼› 2.æ‰§è¡Œçª—å£æ³¨å†Œï¼› 3.æ‰§è¡Œçª—å£å¸ƒå±€ï¼› 4.æ‰§è¡Œçª—å£ç»˜å›¾ï¼› 12345678910111213141516171819202122232425262728293031[-&gt;ViewRootImpl.java] private void performTraversals() &#123; ...... /****************æ‰§è¡Œçª—å£æµ‹é‡******************/ if (layoutRequested) &#123; windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ...... /****************å‘WMSæœåŠ¡æ·»åŠ çª—å£******************/ if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... &#125; ...... &#125; /****************æ‰§è¡Œçª—å£å¸ƒå±€******************/ if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ...... &#125; /****************æ‰§è¡Œçª—å£ç»˜åˆ¶******************/ if (!cancelDraw &amp;&amp; !newSurface) &#123; ...... performDraw(); &#125; ......&#125; 2.1ã€ Android å±å¹•åŒºåŸŸä»‹ç»é¦–å…ˆæ¥çœ‹relayoutWindow()ã€‚relayoutWindow() æ˜¯Window Manager Service é‡è¦å·¥ä½œä¹‹ä¸€ï¼Œå®ƒçš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æ¯ä¸ªViewå°†æœŸæœ›çª—å£å°ºå¯¸äº¤ç»™WMSï¼ˆWindowManager Service). WMS å°†æ‰€æœ‰çš„çª—å£å¤§å°ä»¥åŠå½“å‰çš„OverscanåŒºåŸŸä¼ ç»™WPM ï¼ˆWindowManager Policy). WPMæ ¹æ®ç”¨æˆ·é…ç½®ç¡®å®šæ¯ä¸ªWindowåœ¨æœ€ç»ˆDisplayè¾“å‡ºä¸Šçš„ä½ç½®ä»¥åŠéœ€è¦åˆ†é…çš„Surfaceå¤§å°ã€‚ è¿”å›è¿™äº›ä¿¡æ¯ç»™æ¯ä¸ªViewï¼Œä»–ä»¬å°†åœ¨ç»™ä¼šçš„åŒºåŸŸç©ºé—´é‡Œç»˜å›¾ã€‚ Androidé‡Œå®šä¹‰äº†å¾ˆå¤šåŒºåŸŸ,å¦‚ä¸‹å›¾æ‰€ç¤º Overscan: Overscan æ˜¯ç”µè§†ç‰¹æœ‰çš„æ¦‚å¿µï¼Œä¸Šå›¾ä¸­é»„è‰²éƒ¨åˆ†å°±æ˜¯OverscanåŒºåŸŸï¼ŒæŒ‡çš„æ˜¯ç”µè§†æœºå±å¹•å››å‘¨æŸäº›ä¸å¯è§çš„åŒºåŸŸï¼ˆå› ä¸ºç”µè§†ç‰¹æ€§ï¼Œè¿™éƒ¨åˆ†åŒºåŸŸçš„bufferå†…å®¹æ˜¾ç¤ºæ—¶è¢«ä¸¢å¼ƒï¼‰ï¼Œä¹Ÿæ„å‘³ç€å¦‚æœçª—å£çš„æŸäº›å†…å®¹ç”»åœ¨è¿™ä¸ªåŒºåŸŸé‡Œï¼Œå®ƒåœ¨æŸäº›ç”µè§†ä¸Šå°±ä¼šçœ‹ä¸åˆ°ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µå‘ç”Ÿï¼Œé€šå¸¸è¦æ±‚UIä¸è¦ç”»åœ¨å±å¹•çš„è¾¹è§’ä¸Šï¼Œè€Œæ˜¯é¢„ç•™ä¸€å®šçš„ç©ºé—´ã€‚å› ä¸ºOverscançš„åŒºåŸŸå¤§å°éšç€ç”µè§†ä¸ åŒè€Œä¸åŒï¼Œå®ƒä¸€èˆ¬ç”±ç»ˆç«¯ç”¨æˆ·é€šè¿‡UIæŒ‡å®šï¼Œï¼ˆæ¯”å¦‚è¯´GoogleTVé‡Œå°±æœ‰ç¡®å®šOverscanå¤§å°çš„åº”ç”¨ï¼‰ã€‚ OverscanScreen, Screen: OverscanScreen æ˜¯åŒ…å«OverscanåŒºåŸŸçš„å±å¹•å¤§å°,è€ŒScreenåˆ™ä¸ºå»é™¤OverscanåŒºåŸŸåçš„å±å¹•åŒºåŸŸ, OverscanScreen &gt; Screen. Restricted and Unrestricted: æŸäº›åŒºåŸŸæ˜¯è¢«ç³»ç»Ÿä¿ç•™çš„ï¼Œæ¯”å¦‚è¯´æ‰‹æœºå±å¹•ä¸Šæ–¹çš„çŠ¶æ€æ (å¦‚å›¾çº¸ç»¿è‰²åŒºåŸŸï¼‰å’Œä¸‹æ–¹çš„å¯¼èˆªæ ï¼Œæ ¹æ®æ˜¯å¦åŒ…æ‹¬è¿™äº›é¢„ç•™çš„åŒºåŸŸï¼ŒAndroidæŠŠåŒºåŸŸåˆ†ä¸ºUnrestricted Area å’Œ Resctrited Aread, å‰è€…åŒ…æ‹¬è¿™éƒ¨åˆ†é¢„ç•™åŒºåŸŸï¼Œåè€…åˆ™ä¸åŒ…å«, Unrestricted area &gt; Rectricted areaã€‚ mFrame, mDisplayFrame, mContainingFrame FrameæŒ‡çš„æ˜¯ä¸€ç‰‡å†…å­˜åŒºåŸŸ, å¯¹åº”äºå±å¹•ä¸Šçš„ä¸€å—çŸ©å½¢åŒºåŸŸ. mFrameçš„å¤§å°å°±æ˜¯Surfaceçš„å¤§å°, å¦‚ä¸Šä¸Šå›¾ä¸­çš„è“è‰²åŒºåŸŸ. mDisplayFrame å’Œ mContainingFrame ä¸€èˆ¬å’ŒmFrame å¤§å°ä¸€è‡´. mXXX æ˜¯Window(ViewRootImpl, Windowstate) é‡Œé¢å®šä¹‰çš„æˆå‘˜å˜é‡. mContentFrame, mVisibleFrame ä¸€ä¸ªSurfaceçš„æ‰€æœ‰å†…å®¹ä¸ä¸€å®šåœ¨å±å¹•ä¸Šéƒ½å¾—åˆ°æ˜¾ç¤º, ä¸Overscané‡å çš„éƒ¨åˆ†ä¼šè¢«æˆªæ‰, ç³»ç»Ÿçš„å…¶ä»–çª—å£ä¹Ÿä¼šé®æŒ¡æ‰éƒ¨åˆ†åŒºåŸŸ (æ¯”å¦‚çŸ­ä¿¡çª—å£ï¼ŒContentFrameæ˜¯800x600(æ²¡æœ‰Status Bar), ä½†å½“è¾“å…¥æ³•çª—å£å¼¹å‡ºæ˜¯ï¼Œå˜æˆäº†800x352), å‰©ä¸‹çš„åŒºåŸŸç§°ä¸ºVisible Frame, UIå†…å®¹åªæœ‰ç”»åœ¨è¿™ä¸ªåŒºåŸŸé‡Œæ‰èƒ½ç¡®ä¿å¯è§. æ‰€ä»¥ä¹Ÿç§°ä¸ºContent Frame. mXXXä¹Ÿæ˜¯Window(ViewRootImpl, WindowState) é‡Œé¢å®šä¹‰çš„æˆå‘˜å˜é‡. Insets insetsçš„å®šä¹‰å¦‚ä¸Šå›¾æ‰€ç¤º, ç”¨äº†è¡¨ç¤ºæŸä¸ªFrameçš„è¾¹ç¼˜å¤§å°. 2.2ã€ Window å¤§å°ä½ç½®è®¡ç®—è¿‡ç¨‹åœ¨Androidç³»ç»Ÿä¸­ï¼ŒActivityçª—å£çš„å¤§å°æ˜¯ç”±WindowManagerServiceæœåŠ¡æ¥è®¡ç®—çš„ã€‚WindowManagerServiceæœåŠ¡ä¼šæ ¹æ®å±å¹•åŠå…¶è£…é¥°åŒºçš„å¤§å°æ¥å†³å®šActivityçª—å£çš„å¤§å°ã€‚ä¸€ä¸ªActivityçª—å£åªæœ‰çŸ¥é“è‡ªå·±çš„å¤§å°ä¹‹åï¼Œæ‰èƒ½å¯¹å®ƒé‡Œé¢çš„UIå…ƒç´ è¿›è¡Œæµ‹é‡ã€å¸ƒå±€ä»¥åŠç»˜åˆ¶ã€‚ ä¸€èˆ¬æ¥è¯´ï¼ŒActivityçª—å£çš„å¤§å°ç­‰äºæ•´ä¸ªå±å¹•çš„å¤§å°ï¼Œä½†æ˜¯å®ƒå¹¶ä¸å æ®ç€æ•´å—å±å¹•ã€‚ä¸ºäº†ç†è§£è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬é¦–å…ˆåˆ†æä¸€ä¸‹Activityçª—å£çš„åŒºåŸŸæ˜¯å¦‚ä½•åˆ’åˆ†çš„ã€‚ æˆ‘ä»¬çŸ¥é“ï¼ŒActivityçª—å£çš„ä¸Šæ–¹ä¸€èˆ¬ä¼šæœ‰ä¸€ä¸ªçŠ¶æ€æ ï¼Œç”¨æ¥æ˜¾ç¤º3Gä¿¡å·ã€ç”µé‡ä½¿ç”¨ç­‰å›¾æ ‡ï¼Œå¦‚å›¾ ä»Activityçª—å£å‰”é™¤æ‰çŠ¶æ€æ æ‰€å ç”¨çš„åŒºåŸŸä¹‹åï¼Œæ‰€å¾—åˆ°çš„åŒºåŸŸå°±ç§°ä¸ºå†…å®¹åŒºåŸŸï¼ˆContent Regionï¼‰ã€‚é¡¾åæ€ä¹‰ï¼Œå†…å®¹åŒºåŸŸå°±æ˜¯ç”¨æ¥æ˜¾ç¤ºActivityçª—å£çš„å†…å®¹çš„ã€‚æˆ‘ä»¬å†æŠ½è±¡ä¸€ä¸‹ï¼Œå‡è®¾Activityçª—å£çš„å››å‘¨éƒ½æœ‰ä¸€å—ç±»ä¼¼çŠ¶æ€æ çš„åŒºåŸŸï¼Œé‚£ä¹ˆå°†è¿™äº›åŒºåŸŸå‰”é™¤ä¹‹åï¼Œå¾—åˆ°ä¸­é—´çš„é‚£ä¸€å—åŒºåŸŸå°±ç§°ä¸ºå†…å®¹åŒºåŸŸï¼Œè€Œè¢«å‰”é™¤å‡ºæ¥çš„åŒºåŸŸæ‰€ç»„æˆçš„åŒºåŸŸå°±ç§°ä¸ºå†…å®¹è¾¹è¡¬åŒºåŸŸï¼ˆContent Insetsï¼‰ã€‚Activityçª—å£çš„å†…å®¹è¾¹è¡¬åŒºåŸŸå¯ä»¥ç”¨ä¸€ä¸ªå››å…ƒç»„ï¼ˆcontent-left, content-top, content-right, content-bottomï¼‰æ¥æè¿°ï¼Œå…¶ä¸­ï¼Œcontent-leftã€content-rightã€content-topã€content-bottomåˆ†åˆ«ç”¨æ¥æè¿°å†…å®¹åŒºåŸŸä¸çª—å£åŒºåŸŸçš„å·¦å³ä¸Šä¸‹è¾¹ç•Œè·ç¦»ã€‚ æˆ‘ä»¬è¿˜çŸ¥é“ï¼ŒActivityçª—å£æœ‰æ—¶å€™éœ€è¦æ˜¾ç¤ºè¾“å…¥æ³•çª—å£ï¼Œå¦‚å›¾ã€‚ è¿™æ—¶å€™Activityçª—å£çš„å†…å®¹åŒºåŸŸçš„å¤§å°æœ‰å¯èƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œè¿™å–å†³äºå®ƒçš„Soft Input Modeã€‚æˆ‘ä»¬å‡è®¾Activityçª—å£çš„å†…å®¹åŒºåŸŸæ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œä½†æ˜¯å®ƒåœ¨åº•éƒ¨çš„ä¸€äº›åŒºåŸŸè¢«è¾“å…¥æ³•çª—å£é®æŒ¡äº†ï¼Œå³å®ƒåœ¨åº•éƒ¨çš„ä¸€äº›å†…å®¹æ˜¯ä¸å¯è§çš„ã€‚ä»Activityçª—å£å‰”é™¤æ‰çŠ¶æ€æ å’Œè¾“å…¥æ³•çª—å£æ‰€å ç”¨çš„åŒºåŸŸä¹‹åï¼Œæ‰€å¾—åˆ°çš„åŒºåŸŸå°±ç§°ä¸ºå¯è§åŒºåŸŸï¼ˆVisible Regionï¼‰ã€‚åŒæ ·ï¼Œæˆ‘ä»¬å†æŠ½è±¡ä¸€ä¸‹ï¼Œå‡è®¾Activityçª—å£çš„å››å‘¨éƒ½æœ‰ä¸€å—ç±»ä¼¼çŠ¶æ€æ å’Œè¾“å…¥æ³•çª—å£çš„åŒºåŸŸï¼Œé‚£ä¹ˆå°†è¿™äº›åŒºåŸŸå‰”é™¤ä¹‹åï¼Œå¾—åˆ°ä¸­é—´çš„é‚£ä¸€å—åŒºåŸŸå°±ç§°ä¸ºå¯è§åŒºåŸŸï¼Œè€Œè¢«å‰”é™¤å‡ºæ¥çš„åŒºåŸŸæ‰€ç»„æˆçš„åŒºåŸŸå°±ç§°ä¸ºå¯è§è¾¹è¡¬åŒºåŸŸï¼ˆVisible Insetsï¼‰ã€‚Activityçª—å£çš„å¯è§è¾¹è¡¬åŒºåŸŸå¯ä»¥ç”¨ä¸€ä¸ªå››å…ƒç»„ï¼ˆvisible-left, visible-top, visible-right, visible-bottomï¼‰æ¥æè¿°ï¼Œå…¶ä¸­ï¼Œvisible-leftã€visible-rightã€visible-topã€visible-bottomåˆ†åˆ«ç”¨æ¥æè¿°å¯è§åŒºåŸŸä¸çª—å£åŒºåŸŸçš„å·¦å³ä¸Šä¸‹è¾¹ç•Œè·ç¦»ã€‚ åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼ŒActivityçª—å£çš„å†…å®¹åŒºåŸŸå’Œå¯è§åŒºåŸŸçš„å¤§å°æ˜¯ä¸€è‡´çš„ï¼Œè€ŒçŠ¶æ€æ å’Œè¾“å…¥æ³•çª—å£æ‰€å ç”¨çš„åŒºåŸŸåˆç§°ä¸ºå±å¹•è£…é¥°åŒºã€‚ç†è§£äº†è¿™äº›æ¦‚å¿µä¹‹åï¼Œæˆ‘ä»¬å°±å¯ä»¥æ¨æ–­ï¼ŒWindowManagerServiceæœåŠ¡å®é™…ä¸Šå°±æ˜¯éœ€è¦æ ¹æ®å±å¹•ä»¥åŠå¯èƒ½å‡ºç°çš„çŠ¶æ€æ å’Œè¾“å…¥æ³•çª—å£çš„å¤§å°æ¥è®¡ç®—å‡ºActivityçª—å£çš„æ•´ä½“å¤§å°åŠå…¶å†…å®¹åŒºåŸŸè¾¹è¡¬å’Œå¯è§åŒºåŸŸè¾¹è¡¬çš„å¤§å°ã€‚æœ‰äº†è¿™ä¸‰ä¸ªæ•°æ®ä¹‹åï¼ŒActivityçª—å£å°±å¯ä»¥å¯¹å®ƒé‡Œé¢çš„UIå…ƒç´ è¿›è¡Œæµ‹é‡ã€å¸ƒå±€ä»¥åŠç»˜åˆ¶ç­‰æ“ä½œäº†ã€‚ æ€»ä½“æµç¨‹å›¾ï¼š è¿™ä¸ªè¿‡ç¨‹å¯ä»¥åˆ†ä¸º13ä¸ªæ­¥éª¤ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±è¯¦ç»†åˆ†ææ¯ä¸€ä¸ªæ­¥éª¤ã€‚ 2.2.1ã€ViewRootImpl.performTraversals()123456789101112131415161718192021222324252627282930313233343536373839[-&gt;ViewRootImpl.java]private void performTraversals() &#123; // cache mView since it is used so much below... final View host = mView; ...... WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; ...... Rect frame = mWinFrame; if (mFirst) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; //ç¬¬ä¸€æ¬¡è¢«è¯·æ±‚æ‰§è¡Œæµ‹é‡ã€å¸ƒå±€å’Œç»˜åˆ¶æ“ä½œï¼ŒdesiredWindowWidthå’ŒdesiredWindowHeightç­‰äºDisplay Sizeï¼Œå¦åˆ™mWinFrameä¿å­˜çš„å®½åº¦å’Œé«˜åº¦å€¼ã€‚ if (shouldUseDisplaySize(lp)) &#123; Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; &#125; else &#123; Configuration config = mContext.getResources().getConfiguration(); desiredWindowWidth = dipToPx(config.screenWidthDp); desiredWindowHeight = dipToPx(config.screenHeightDp); &#125; ...... host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); &#125; else &#123; //ä¸æ˜¯ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼Œå½“desiredWindowWidth != mWidth || desiredWindowHeight != mHeightï¼Œè¯´æ˜Activityçª—å£çš„å¤§å°å‘ç”Ÿäº†å˜åŒ–ï¼Œè¿™æ—¶å€™windowSizeMayChange = trueï¼Œä»¥ä¾¿æ¥ä¸‹æ¥å¯¹Activityçª—å£å¤§å°å˜åŒ–è¿›è¡Œå¤„ç† desiredWindowWidth = frame.width(); desiredWindowHeight = frame.height(); if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123; mFullRedrawNeeded = true; mLayoutRequested = true; windowSizeMayChange = true; &#125; &#125; è¿™æ®µä»£ç ç”¨æ¥è·å¾—Activityçª—å£çš„å½“å‰å®½åº¦desiredWindowWidthå’Œå½“å‰é«˜åº¦desiredWindowHeightã€‚ ç»§ç»­é˜…è¯»ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637[-&gt;ViewRootImpl.java::performTraversals()]boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);if (layoutRequested) &#123; final Resources res = mView.getContext().getResources(); if (mFirst) &#123; ...... &#125; else &#123; //AttachInfoå¯¹è±¡ç”¨æ¥æè¿°Activityçª—å£çš„å±æ€§,mContentInsetså’ŒmVisibleInsetsåˆ†åˆ«ç”¨æ¥æè¿°Activityçª—å£çš„å½“å‰å†…å®¹è¾¹è¡¬å¤§å°å’Œå¯è§è¾¹è¡¬å¤§å°ã€‚ //åˆ¤æ–­Activityçª—å£çš„OverscanInsetsã€ContentInsetsã€StableInsetsã€VisibleInsetså¤§å°æ˜¯å¦å‘ç”Ÿäº†å˜åŒ– if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123; insetsChanged = true; &#125; ...... //WRAP_CONTENTè¡¨æ˜Activityçª—å£çš„å¤§å°è¦ç­‰äºå†…å®¹åŒºåŸŸçš„å¤§å°ï¼ŒåŒæ—¶ç­‰äºDisplay size if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123; windowSizeMayChange = true; if (shouldUseDisplaySize(lp)) &#123; Point size = new Point(); mDisplay.getRealSize(size); desiredWindowWidth = size.x; desiredWindowHeight = size.y; &#125; else &#123; Configuration config = res.getConfiguration(); desiredWindowWidth = dipToPx(config.screenWidthDp); desiredWindowHeight = dipToPx(config.screenHeightDp); &#125; &#125; &#125; // Ask host how big it wants to be //çŸ¥é“äº†é¡¶å±‚Activityçª—å£å¤§å°ä»è€Œè®¡ç®—Activityå†…å„ä¸ªå­Viewçš„å¤§å° windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight);&#125; è¿™æ®µä»£ç ç”¨æ¥åœ¨Activityçª—å£ä¸»åŠ¨è¯·æ±‚WindowManagerServiceæœåŠ¡è®¡ç®—å¤§å°ä¹‹å‰ï¼Œå¯¹å®ƒçš„é¡¶å±‚è§†å›¾è¿›è¡Œä¸€æ¬¡æµ‹é‡æ“ä½œã€‚ ç»§ç»­é˜…è¯»ä»£ç ï¼š 12345678910111213141516171819202122232425262728[-&gt;ViewRootImpl.java::performTraversals()] if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... //relayoutWindowæ¥è¯·æ±‚WMSè®¡ç®—Activityçª—å£çš„å¤§å°ä»¥åŠxxxInsetså¤§å°ï¼Œå¹¶ä¿å­˜åœ¨PendingxxxInsetsä¸­ relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... if (contentInsetsChanged) &#123; mAttachInfo.mContentInsets.set(mPendingContentInsets); &#125; ...... if (visibleInsetsChanged) &#123; mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets); &#125; ...... &#125; catch (RemoteException e) &#123; &#125; ...... //å°†è®¡ç®—å¾—åˆ°çš„Activityçª—å£çš„å·¦ä¸Šè§’åæ ‡ä¿å­˜åœ¨å˜é‡attachInfoæ‰€æŒ‡å‘çš„ä¸€ä¸ªAttachInfoå¯¹è±¡çš„æˆå‘˜å˜é‡mWindowLeftå’ŒmWindowTop mAttachInfo.mWindowLeft = frame.left; mAttachInfo.mWindowTop = frame.top; //å°†è®¡ç®—å¾—åˆ°çš„Activityçª—å£çš„å®½åº¦å’Œé«˜åº¦ä¿å­˜åœ¨ViewRootImplç±»çš„æˆå‘˜å˜é‡mWidthå’ŒmHeightä¸­ if (mWidth != frame.width() || mHeight != frame.height()) &#123; mWidth = frame.width(); mHeight = frame.height(); &#125; è¿™æ®µä»£ç ä¸»è¦è°ƒç”¨relayoutWindow()æ¥è¯·æ±‚WMSè®¡ç®—Activityçª—å£çš„å¤§å°ä»¥åŠè¾¹å¿–xxxInsetså¤§å°ã€‚è®¡ç®—å®Œæ¯•ä¹‹åï¼Œåˆ†åˆ«ä¿å­˜åœ¨mPendingXXXInsetsä¸­ã€‚ ç»§ç»­é˜…è¯»ä»£ç ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940[-&gt;ViewRootImpl.java::performTraversals()] if (!mStopped || mReportNextDraw) &#123; boolean focusChangedDueToTouchMode = ensureTouchModeLocally( (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0); if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight() || contentInsetsChanged || updatedConfiguration) &#123; int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width); int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height); ...... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...... int width = host.getMeasuredWidth(); int height = host.getMeasuredHeight(); boolean measureAgain = false; if (lp.horizontalWeight &gt; 0.0f) &#123; width += (int) ((mWidth - width) * lp.horizontalWeight); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (lp.verticalWeight &gt; 0.0f) &#123; height += (int) ((mHeight - height) * lp.verticalWeight); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY); measureAgain = true; &#125; if (measureAgain) &#123; performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; layoutRequested = true; &#125; &#125; &#125; else &#123; &#125; è¿™æ®µä»£ç ç”¨æ¥æ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°æµ‹é‡Activityçª—å£çš„å¤§å°ã€‚ ç»è¿‡å‰é¢æ¼«é•¿çš„æ“ä½œåï¼ŒActivityçª—å£çš„å¤§å°æµ‹é‡å·¥ä½œç»ˆäºå°˜åŸƒè½å®šï¼Œè¿™æ—¶å€™å°±å¯ä»¥å¯¹Activityçª—å£çš„å†…å®¹è¿›è¡Œå¸ƒå±€ performLayout(lp, mWidth, mHeight)å’Œè¿›è¡Œç»˜ç”»äº†ï¼ŒperformDraw()ï¼Œç”±äºä¸»è¦å…³æ³¨Activityçª—å£å¤§å°è®¡ç®—è¿‡ç¨‹ï¼Œåœ¨æ­¤ä¸åšç»§ç»­åˆ†æã€‚ 2.2.2ã€ViewRootImpl.relayoutWindow()é€šè¿‡è°ƒç”¨è¿™ä¸ªSessionå¯¹è±¡çš„æˆå‘˜å‡½æ•°relayout()æ¥è¯·æ±‚WindowManagerServiceæœåŠ¡è®¡ç®—Activityçª—å£çš„å¤§å°ã€‚ 123456789101112131415[-&gt;ViewRootImpl.java]private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ..... int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;&#125; å‚æ•°è¯´æ˜ï¼š 1ã€mWindow ç”¨æ¥æ ‡å¿—è¦è®¡ç®—çš„æ˜¯å“ªä¸€ä¸ªActivityçª—å£çš„å¤§å°p 2ã€Activityçª—å£çš„é¡¶å±‚è§†å›¾ç»è¿‡æµ‹é‡åå¾—åˆ°çš„å®½åº¦å’Œé«˜åº¦ 3ã€Activityçª—å£çš„å¯è§çŠ¶æ€ï¼Œå³viewVisibility 4ã€Activityçª—å£æ˜¯å¦æœ‰é¢å¤–çš„å†…å®¹åŒºåŸŸè¾¹è¡¬å’Œå¯è§åŒºåŸŸè¾¹è¡¬ç­‰å¾…å‘Šè¯‰ç»™WindowManagerServiceæœåŠ¡ï¼Œå³å‚æ•°insetsPending 5ã€mWinFrameï¼Œè¿™æ˜¯ä¸€ä¸ªè¾“å‡ºå‚æ•°ï¼Œç”¨æ¥ä¿å­˜WindowManagerServiceæœåŠ¡è®¡ç®—åå¾—åˆ°çš„Activityçª—å£çš„å¤§å° 6ã€mPendingOverscanInsetsç”¨æ¥ä¿å­˜Overscanè¾¹è¡¬ï¼ŒmPendingContentInsetsç”¨æ¥ä¿å­˜å†…å®¹åŒºåŸŸè¾¹è¡¬ï¼ŒmPendingVisibleInsetsç”¨æ¥ä¿å­˜å¯è§åŒºåŸŸè¾¹è¡¬ï¼ŒmPendingStableInsetsç”¨æ¥ä¿å­˜å¯èƒ½è¢«ç³»ç»ŸUIå…ƒç´ éƒ¨åˆ†æˆ–å®Œå…¨é®è”½çš„å…¨å±çª—å£åŒºåŸŸ 7ã€mPendingConfigurationï¼Œè¿™æ˜¯ä¸€ä¸ªè¾“å‡ºå‚æ•°ï¼Œç”¨æ¥ä¿å­˜WindowManagerServiceæœåŠ¡è¿”å›æ¥çš„Activityçª—å£çš„é…ç½®ä¿¡æ¯ 8ã€mSurfaceï¼Œè¿™æ˜¯ä¸€ä¸ªè¾“å‡ºå‚æ•°ï¼Œç”¨æ¥ä¿å­˜WindowManagerServiceæœåŠ¡è¿”å›æ¥çš„Activityçª—å£çš„ç»˜å›¾è¡¨é¢ 2.2.3ã€Session.relayout()123456789101112[-&gt;Session.java]public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, outConfig, outSurface); return res;&#125; åªæ˜¯è°ƒç”¨äº†WindowManagerServiceç±»çš„æˆå‘˜å‡½æ•°relayoutWindowæ¥è¿›ä¸€æ­¥è®¡ç®—å‚æ•°windowæ‰€æè¿°çš„ä¸€ä¸ªActivityçª—å“çš„å¤§å° 2.2.4ã€WindowManagerService.relayoutWindow()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[-&gt;WindowManagerService.java]public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int result = 0; ...... synchronized(mWindowMap) &#123; WindowState win = windowForClientLocked(session, client, false); WindowStateAnimator winAnimator = win.mWinAnimator; if (viewVisibility != View.GONE) &#123; win.setRequestedSize(requestedWidth, requestedHeight); &#125; ..... if (attrs != null) &#123; mPolicy.adjustWindowParamsLw(attrs); ...... &#125; win.setWindowScale(win.mRequestedWidth, win.mRequestedHeight); ...... if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges, oldVisibility); try &#123; result = createSurfaceControl(outSurface, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... &#125; ...... win.adjustStartingWindowFlags(); &#125; else &#123; ...... &#125; ...... mWindowPlacerLocked.performSurfacePlacement(); ...... outFrame.set(win.mCompatFrame); outOverscanInsets.set(win.mOverscanInsets); outContentInsets.set(win.mContentInsets); outVisibleInsets.set(win.mVisibleInsets); outStableInsets.set(win.mStableInsets); outOutsets.set(win.mOutsets); outBackdropFrame.set(win.getBackdropFrame(win.mFrame)); ...... return result;&#125; åªå…³æ³¨relayoutWindowä¸­ä¸çª—å£å¤§å°è®¡ç®—æœ‰å…³çš„é€»è¾‘ï¼Œè®¡ç®—è¿‡ç¨‹å¦‚ä¸‹æ‰€ç¤ºï¼š 1ã€å‚æ•°requestedWidthå’ŒrequestedHeightæè¿°çš„æ˜¯åº”ç”¨ç¨‹åºè¿›ç¨‹è¯·æ±‚è®¾ç½®Activityçª—å£ä¸­çš„å®½åº¦å’Œé«˜åº¦ï¼Œå®ƒä»¬ä¼šè¢«è®°å½•åœ¨WindowStateå¯¹è±¡winçš„æˆå‘˜å˜é‡mRequestedWidthå’ŒmRequestedHeightä¸­ 2ã€WindowStateå¯¹è±¡winçš„æˆå‘˜å˜é‡mAttrsï¼Œå®ƒæŒ‡å‘çš„æ˜¯ä¸€ä¸ªWindowManager.LayoutParamså¯¹è±¡ï¼Œç”¨æ¥æè¿°Activityçª—å£çš„å¸ƒå±€å‚æ•° 3ã€è°ƒç”¨WindowSurfacePlacer.performSurfacePlacement()æ¥è®¡ç®—Activityçª—å£çš„å¤§å°ã€‚è®¡ç®—å®Œæˆä¹‹åï¼Œå‚æ•°clientæ‰€æè¿°çš„Activityçª—å£çš„å¤§å°ã€å†…å®¹åŒºåŸŸè¾¹è¡¬å¤§å°å’Œå¯è§åŒºåŸŸè¾¹è¾¹è¡¬å¤§å°å°±ä¼šåˆ†åˆ«ä¿å­˜åœ¨WindowStateå¯¹è±¡winçš„æˆå‘˜å˜é‡mCompatFrameã€mOverscanInsetsã€mContentInsetsã€mVisibleInsetsã€mStableInsetsã€mOutsetsä¸­ 4ã€ å°†WindowStateå¯¹è±¡winçš„æˆå‘˜å˜é‡mCompatFrameã€mOverscanInsetsã€mContentInsetsã€mVisibleInsetsã€mStableInsetsã€mOutsetsæ‹·è´èµ‹å€¼å¯¹åº”å˜é‡ä¸­ï¼Œä»¥ä¾¿å¯ä»¥è¿”å›ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹ ç»è¿‡ä¸Šè¿°4ä¸ªæ“ä½œåï¼ŒActivityçª—å£çš„å¤§å°è®¡ç®—è¿‡ç¨‹å°±å®Œæˆäº†ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­åˆ†æWindowSurfacePlacer.performSurfacePlacement()çš„å®ç°ï¼Œä»¥ä¾¿å¯ä»¥è¯¦ç»†äº†è§£Activityçª—å£çš„å¤§å°è®¡ç®—è¿‡ç¨‹ 2.2.5ã€WindowSurfacePlacer.performSurfacePlacement()1234567891011121314[-&gt;WindowSurfacePlacer.java]final void performSurfacePlacement() &#123; if (mDeferDepth &gt; 0) &#123; return; &#125; int loopCount = 6; do &#123; mTraversalScheduled = false; performSurfacePlacementLoop(); mService.mH.removeMessages(DO_TRAVERSAL); loopCount--; &#125; while (mTraversalScheduled &amp;&amp; loopCount &gt; 0); mWallpaperActionPending = false;&#125; 2.2.6.WindowSurfacePlacer.performSurfacePlacementLoop()12345678910111213141516171819202122232425262728293031323334353637[-&gt;WindowSurfacePlacer.java]private void performSurfacePlacementLoop() &#123; mInLayout = true; boolean recoveringMemory = false; if (!mService.mForceRemoves.isEmpty()) &#123; recoveringMemory = true; while (!mService.mForceRemoves.isEmpty()) &#123; WindowState ws = mService.mForceRemoves.remove(0); mService.removeWindowInnerLocked(ws); &#125; ...... &#125; ...... try &#123; performSurfacePlacementInner(recoveringMemory); mInLayout = false; if (mService.needsLayout()) &#123; if (++mLayoutRepeatCount &lt; 6) &#123; requestTraversal(); &#125; else &#123; Slog.e(TAG, \"Performed 6 layouts in a row. Skipping\"); mLayoutRepeatCount = 0; &#125; &#125; else &#123; mLayoutRepeatCount = 0; &#125; if (mService.mWindowsChanged &amp;&amp; !mService.mWindowChangeListeners.isEmpty()) &#123; mService.mH.removeMessages(REPORT_WINDOWS_CHANGE); mService.mH.sendEmptyMessage(REPORT_WINDOWS_CHANGE); &#125; &#125; catch (RuntimeException e) &#123; mInLayout = false; &#125;&#125; åœ¨è°ƒç”¨æˆå‘˜å‡½æ•°performSurfacePlacementInner()åˆ·æ–°ç³»ç»ŸUIçš„å‰å 1ã€æ£€æŸ¥ç³»ç»Ÿä¸­æ˜¯å¦å­˜åœ¨å¼ºåˆ¶åˆ é™¤çš„çª—å£ 2ã€æ£€æŸ¥ç³»ç»Ÿä¸­æ˜¯å¦æœ‰çª—å£éœ€è¦ç§»é™¤ 2.2.7ã€WindowSurfacePlacer.performSurfacePlacementInner()ç»§ç»­åˆ†æçš„performSurfacePlacementInner()å®ç°ï¼Œä»¥ä¾¿å¯ä»¥äº†è§£Activityçª—å£çš„å¤§å°è®¡ç®—è¿‡ç¨‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[-&gt;WindowSurfacePlacer.java]private void performSurfacePlacementInner(boolean recoveringMemory) &#123; if (DEBUG_WINDOW_TRACE) Slog.v(TAG, \"performSurfacePlacementInner: entry. Called by \" + Debug.getCallers(3)); ...... final DisplayContent defaultDisplay = mService.getDefaultDisplayContentLocked(); final DisplayInfo defaultInfo = defaultDisplay.getDisplayInfo(); final int defaultDw = defaultInfo.logicalWidth; final int defaultDh = defaultInfo.logicalHeight; SurfaceControl.openTransaction(); try &#123; applySurfaceChangesTransaction(recoveringMemory, numDisplays, defaultDw, defaultDh); &#125; catch (RuntimeException e) &#123; Slog.wtf(TAG, \"Unhandled exception in Window Manager\", e); &#125; finally &#123; SurfaceControl.closeTransaction(); &#125; final WindowList defaultWindows = defaultDisplay.getWindowList(); ...... final int N = mService.mPendingRemove.size(); if (N &gt; 0) &#123; if (mService.mPendingRemoveTmp.length &lt; N) &#123; mService.mPendingRemoveTmp = new WindowState[N+10]; &#125; mService.mPendingRemove.toArray(mService.mPendingRemoveTmp); mService.mPendingRemove.clear(); DisplayContentList displayList = new DisplayContentList(); for (i = 0; i &lt; N; i++) &#123; WindowState w = mService.mPendingRemoveTmp[i]; mService.removeWindowInnerLocked(w); final DisplayContent displayContent = w.getDisplayContent(); if (displayContent != null &amp;&amp; !displayList.contains(displayContent)) &#123; displayList.add(displayContent); &#125; &#125; for (DisplayContent displayContent : displayList) &#123; mService.mLayersController.assignLayersLocked(displayContent.getWindowList()); displayContent.layoutNeeded = true; &#125; &#125; ...... mService.scheduleAnimationLocked(); ......&#125; å¯ä»¥çœ‹åˆ°è¿›ä¸€æ­¥è°ƒç”¨applySurfaceChangesTransaction()æ–¹æ³•è¿›è¡Œè¿›ä¸€æ­¥è®¡ç®— 2.2.8ã€WindowSurfacePlacer.applySurfaceChangesTransaction()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869[-&gt;WindowSurfacePlacer.java]private void applySurfaceChangesTransaction(boolean recoveringMemory, int numDisplays, int defaultDw, int defaultDh) &#123; ...... boolean focusDisplayed = false; for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; final DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx); boolean updateAllDrawn = false; WindowList windows = displayContent.getWindowList(); DisplayInfo displayInfo = displayContent.getDisplayInfo(); final int displayId = displayContent.getDisplayId(); final int dw = displayInfo.logicalWidth; final int dh = displayInfo.logicalHeight; final int innerDw = displayInfo.appWidth; final int innerDh = displayInfo.appHeight; final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY); // Reset for each display. mDisplayHasContent = false; mPreferredRefreshRate = 0; mPreferredModeId = 0; int repeats = 0; do &#123; repeats++; if (repeats &gt; 6) &#123;//æœ€å¤šæ‰§è¡Œ7æ¬¡çš„whileå¾ªç¯ displayContent.layoutNeeded = false; break; &#125; //é€šçŸ¥SurfaceFlingeræœåŠ¡äº†ï¼Œä¹Ÿå°±æ˜¯è®©SurfaceFlingeræœåŠ¡æ›´æ–°å®ƒé‡Œé¢çš„å„ä¸ªLayerçš„å±æ€§å€¼ï¼Œä»¥ä¾¿å¯ä»¥å¯¹è¿™äº›Layeræ‰§è¡Œå¯è§æ€§è®¡ç®—ã€åˆæˆç­‰æ“ä½œï¼Œæœ€åæ¸²æŸ“åˆ°ç¡¬ä»¶å¸§ç¼“å†²åŒºä¸­å» if ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_WALLPAPER) != 0 &amp;&amp; mWallpaperControllerLocked.adjustWallpaperWindows()) &#123; mService.mLayersController.assignLayersLocked(windows); displayContent.layoutNeeded = true; &#125; ...... if ((displayContent.pendingLayoutChanges &amp; FINISH_LAYOUT_REDO_LAYOUT) != 0) &#123; displayContent.layoutNeeded = true; &#125; // FIRST LOOP: Perform a layout, if needed. //è®¡ç®—å„ä¸ªçª—å“çš„å¤§å° if (repeats &lt; LAYOUT_REPEAT_THRESHOLD) &#123; performLayoutLockedInner(displayContent, repeats == 1, false /* updateInputWindows */); &#125; else &#123; &#125; // FIRST AND ONE HALF LOOP: Make WindowManagerPolicy think // it is animating. displayContent.pendingLayoutChanges = 0; if (isDefaultDisplay) &#123; mService.mPolicy.beginPostLayoutPolicyLw(dw, dh); for (int i = windows.size() - 1; i &gt;= 0; i--) &#123; WindowState w = windows.get(i); if (w.mHasSurface) &#123; mService.mPolicy.applyPostLayoutPolicyLw(w, w.mAttrs, w.mAttachedWindow); &#125; &#125; displayContent.pendingLayoutChanges |= mService.mPolicy.finishPostLayoutPolicyLw(); &#125; &#125; while (displayContent.pendingLayoutChanges != 0); ......&#125; 2.2.9ã€WindowSurfacePlacer.applySurfaceChangesTransaction()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586[-&gt;WindowSurfacePlacer.java]final void performLayoutLockedInner(final DisplayContent displayContent, boolean initial, boolean updateInputWindows) &#123; displayContent.layoutNeeded = false; WindowList windows = displayContent.getWindowList(); boolean isDefaultDisplay = displayContent.isDefaultDisplay; DisplayInfo displayInfo = displayContent.getDisplayInfo(); final int dw = displayInfo.logicalWidth; final int dh = displayInfo.logicalHeight; ...... final int N = windows.size(); int i; /// mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mService.mRotation, mService.mCurConfiguration.uiMode); ...... displayContent.resize(mTmpContentRect); int seq = mService.mLayoutSeq+1; if (seq &lt; 0) seq = 0; mService.mLayoutSeq = seq; boolean behindDream = false; int topAttached = -1; for (i = N-1; i &gt;= 0; i--) &#123; final WindowState win = windows.get(i); ...... final boolean gone = (behindDream &amp;&amp; mService.mPolicy.canBeForceHidden(win, win.mAttrs)) || win.isGoneForLayoutLw(); ...... if (!gone || !win.mHaveFrame || win.mLayoutNeeded || ((win.isConfigChanged() || win.setReportResizeHints()) &amp;&amp; !win.isGoneForLayoutLw() &amp;&amp; ((win.mAttrs.privateFlags &amp; PRIVATE_FLAG_KEYGUARD) != 0 || (win.mHasSurface &amp;&amp; win.mAppToken != null &amp;&amp; win.mAppToken.layoutConfigChanges)))) &#123; if (!win.mLayoutAttached) &#123; ...... win.mLayoutNeeded = false; win.prelayout(); mService.mPolicy.layoutWindowLw(win, null); win.mLayoutSeq = seq; // Window frames may have changed. Update dim layer with the new bounds. final Task task = win.getTask(); if (task != null) &#123; displayContent.mDimLayerController.updateDimLayer(task); &#125; ...... &#125; else &#123; &#125; &#125; &#125; boolean attachedBehindDream = false; ...... for (i = topAttached; i &gt;= 0; i--) &#123; final WindowState win = windows.get(i); if (win.mLayoutAttached) &#123; ...... if ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled) || !win.mHaveFrame || win.mLayoutNeeded) &#123; ...... win.mLayoutNeeded = false; win.prelayout(); mService.mPolicy.layoutWindowLw(win, win.mAttachedWindow); win.mLayoutSeq = seq; &#125; &#125; else if (win.mAttrs.type == TYPE_DREAM) &#123; attachedBehindDream = behindDream; &#125; &#125; // Window frames may have changed. Tell the input dispatcher about it. mService.mInputMonitor.setUpdateInputWindowsNeededLw(); if (updateInputWindows) &#123; mService.mInputMonitor.updateInputWindowsLw(false /*force*/); &#125; mService.mPolicy.finishLayoutLw(); mService.mH.sendEmptyMessage(UPDATE_DOCKED_STACK_DIVIDER);&#125; 1ã€mPolicyæŒ‡å‘çš„æ˜¯ä¸€ä¸ªçª—å£ç®¡ç†ç­–ç•¥ç±»ï¼Œå³PhoneWindowManagerå¯¹è±¡ï¼Œä¸»è¦æ˜¯ç”¨æ¥åˆ¶å®šçª—å£çš„å¤§å°è®¡ç®—ç­–ç•¥ 2ã€å‡†å¤‡é˜¶æ®µï¼šè°ƒç”¨PhoneWindowManager.beginLayoutLw()æ¥è®¾ç½®å±å¹•çš„å¤§å°ã€‚åŒ…æ‹¬NavigationBarã€StatusBarå¤§å°è®¡ç®— 3ã€è®¡ç®—é˜¶æ®µï¼šè°ƒç”¨PhoneWindowManager.layoutWindowLw()æ¥è®¡ç®—å„ä¸ªçª—å£çš„å¤§å°ã€å†…å®¹åŒºåŸŸè¾¹è¡¬å¤§å°ä»¥åŠå¯è§åŒºåŸŸè¾¹è¡¬å¤§å°ã€‚ 4ã€ç»“æŸé˜¶æ®µï¼šè°ƒç”¨PhoneWindowManagerç±»çš„æˆå‘˜å‡½æ•°finishLayoutLw()æ¥æ‰§è¡Œä¸€äº›æ¸…ç†å·¥ä½œã€‚ 2.2.10ã€PhoneWindowManager.beginLayoutLw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172[-&gt;PhoneWindowManager.java]public void beginLayoutLw(boolean isDefaultDisplay, int displayWidth, int displayHeight, int displayRotation, int uiMode) &#123; mDisplayRotation = displayRotation; final int overscanLeft, overscanTop, overscanRight, overscanBottom; if (isDefaultDisplay) &#123; switch (displayRotation) &#123; case Surface.ROTATION_90: overscanLeft = mOverscanTop; overscanTop = mOverscanRight; overscanRight = mOverscanBottom; overscanBottom = mOverscanLeft; break; ...... &#125; &#125; else &#123; overscanLeft = 0; overscanTop = 0; overscanRight = 0; overscanBottom = 0; &#125; mOverscanScreenLeft = mRestrictedOverscanScreenLeft = 0; mOverscanScreenTop = mRestrictedOverscanScreenTop = 0; mOverscanScreenWidth = mRestrictedOverscanScreenWidth = displayWidth; mOverscanScreenHeight = mRestrictedOverscanScreenHeight = displayHeight; mSystemLeft = 0; mSystemTop = 0; mSystemRight = displayWidth; mSystemBottom = displayHeight; mUnrestrictedScreenLeft = overscanLeft; mUnrestrictedScreenTop = overscanTop; mUnrestrictedScreenWidth = displayWidth - overscanLeft - overscanRight; mUnrestrictedScreenHeight = displayHeight - overscanTop - overscanBottom; mRestrictedScreenLeft = mUnrestrictedScreenLeft; mRestrictedScreenTop = mUnrestrictedScreenTop; mRestrictedScreenWidth = mSystemGestures.screenWidth = mUnrestrictedScreenWidth; mRestrictedScreenHeight = mSystemGestures.screenHeight = mUnrestrictedScreenHeight; mDockLeft = mContentLeft = mVoiceContentLeft = mStableLeft = mStableFullscreenLeft = mCurLeft = mUnrestrictedScreenLeft; mDockTop = mContentTop = mVoiceContentTop = mStableTop = mStableFullscreenTop = mCurTop = mUnrestrictedScreenTop; mDockRight = mContentRight = mVoiceContentRight = mStableRight = mStableFullscreenRight = mCurRight = displayWidth - overscanRight; mDockBottom = mContentBottom = mVoiceContentBottom = mStableBottom = mStableFullscreenBottom = mCurBottom = displayHeight - overscanBottom; mDockLayer = 0x10000000; mStatusBarLayer = -1; // start with the current dock rect, which will be (0,0,displayWidth,displayHeight) final Rect pf = mTmpParentFrame; final Rect df = mTmpDisplayFrame; final Rect of = mTmpOverscanFrame; final Rect vf = mTmpVisibleFrame; final Rect dcf = mTmpDecorFrame; pf.left = df.left = of.left = vf.left = mDockLeft; pf.top = df.top = of.top = vf.top = mDockTop; pf.right = df.right = of.right = vf.right = mDockRight; pf.bottom = df.bottom = of.bottom = vf.bottom = mDockBottom; dcf.setEmpty(); // Decor frame N/A for system bars. ....... if (isDefaultDisplay) &#123; navVisible |= !canHideNavigationBar(); boolean updateSysUiVisibility = layoutNavigationBar(displayWidth, displayHeight, displayRotation, uiMode, overscanLeft, overscanRight, overscanBottom, dcf, navVisible, navTranslucent,navAllowedHidden, statusBarExpandedNotKeyguard); updateSysUiVisibility |= layoutStatusBar(pf, df, of, vf, dcf, sysui, isKeyguardShowing); ...... if (updateSysUiVisibility) &#123; updateSystemUiVisibilityLw(); &#125; &#125;&#125; 1ã€åˆå§‹åŒ–Overscanã€UnrestrictedScreenã€RestrictedScreenç­‰å±å¹•åŒºåŸŸå˜é‡ 2ã€è®¡ç®—NavigationBarå’ŒStatusBarå¤§å° 2.2.11ã€PhoneWindowManager.layoutWindowLw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[-&gt;PhoneWindowManager.java]Overridepublic void layoutWindowLw(WindowState win, WindowState attached) &#123; ...... final int fl = PolicyControl.getWindowFlags(win, attrs); final int pfl = attrs.privateFlags; final int sim = attrs.softInputMode; final int sysUiFl = PolicyControl.getSystemUiVisibility(win, null); final Rect pf = mTmpParentFrame; final Rect df = mTmpDisplayFrame; final Rect of = mTmpOverscanFrame; final Rect cf = mTmpContentFrame; final Rect vf = mTmpVisibleFrame; final Rect dcf = mTmpDecorFrame; final Rect sf = mTmpStableFrame; Rect osf = null; dcf.setEmpty(); final boolean hasNavBar = (isDefaultDisplay &amp;&amp; mHasNavigationBar &amp;&amp; mNavigationBar != null &amp;&amp; mNavigationBar.isVisibleLw()); final int adjust = sim &amp; SOFT_INPUT_MASK_ADJUST; if (isDefaultDisplay) &#123; sf.set(mStableLeft, mStableTop, mStableRight, mStableBottom); &#125; else &#123; sf.set(mOverscanLeft, mOverscanTop, mOverscanRight, mOverscanBottom); &#125; if (!isDefaultDisplay) &#123; if (attached != null) &#123; // If this window is attached to another, our display // frame is the same as the one we are attached to. setAttachedWindowFrames(win, fl, adjust, attached, true, pf, df, of, cf, vf); &#125; else &#123; // Give the window full screen. pf.left = df.left = of.left = cf.left = mOverscanScreenLeft; pf.top = df.top = of.top = cf.top = mOverscanScreenTop; pf.right = df.right = of.right = cf.right = mOverscanScreenLeft + mOverscanScreenWidth; pf.bottom = df.bottom = of.bottom = cf.bottom = mOverscanScreenTop + mOverscanScreenHeight; &#125; &#125; ...... win.computeFrameLw(pf, df, of, cf, vf, dcf, sf, osf); ......&#125; ç„¶åè°ƒç”¨WindowState.computeFrameLwæ¥è®¡ç®—çª—å£winçš„å…·ä½“å¤§å°äº†ã€‚è®¡ç®—çš„ç»“æœä¾¿å¾—åˆ°äº†çª—å£winçš„å¤§å°ï¼Œä»¥åŠå®ƒçš„å†…å®¹åŒºåŸŸè¾¹è¡¬å¤§å°å’Œå¯è§åŒºåŸŸè¾¹è¡¬å¤§å°ã€‚ 2.2.12ã€WindowState.computeFrameLw()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[-&gt;WindowState.java]public void computeFrameLw(Rect pf, Rect df, Rect of, Rect cf, Rect vf, Rect dcf, Rect sf, Rect osf) &#123; ...... final Task task = getTask(); final boolean fullscreenTask = !isInMultiWindowMode(); final boolean windowsAreFloating = task != null &amp;&amp; task.isFloating(); ...... final Rect layoutContainingFrame; final Rect layoutDisplayFrame; // The offset from the layout containing frame to the actual containing frame. final int layoutXDiff; final int layoutYDiff; if (fullscreenTask || layoutInParentFrame()) &#123; // We use the parent frame as the containing frame for fullscreen and child windows mContainingFrame.set(pf); mDisplayFrame.set(df); layoutDisplayFrame = df; layoutContainingFrame = pf; layoutXDiff = 0; layoutYDiff = 0; &#125; else &#123; task.getBounds(mContainingFrame); ...... mDisplayFrame.set(mContainingFrame); layoutXDiff = !mInsetFrame.isEmpty() ? mInsetFrame.left - mContainingFrame.left : 0; layoutYDiff = !mInsetFrame.isEmpty() ? mInsetFrame.top - mContainingFrame.top : 0; layoutContainingFrame = !mInsetFrame.isEmpty() ? mInsetFrame : mContainingFrame; mTmpRect.set(0, 0, mDisplayContent.getDisplayInfo().logicalWidth, mDisplayContent.getDisplayInfo().logicalHeight); subtractInsets(mDisplayFrame, layoutContainingFrame, df, mTmpRect); ...... layoutDisplayFrame = df; layoutDisplayFrame.intersect(layoutContainingFrame); &#125; final int pw = mContainingFrame.width(); final int ph = mContainingFrame.height(); ...... mOverscanFrame.set(of); mContentFrame.set(cf); mVisibleFrame.set(vf); mDecorFrame.set(dcf); mStableFrame.set(sf); final boolean hasOutsets = osf != null; final int fw = mFrame.width(); final int fh = mFrame.height(); ...... if (windowsAreFloating &amp;&amp; !mFrame.isEmpty()) &#123; final int height = Math.min(mFrame.height(), mContentFrame.height()); final int width = Math.min(mContentFrame.width(), mFrame.width()); final DisplayMetrics displayMetrics = getDisplayContent().getDisplayMetrics(); final int minVisibleHeight = Math.min(height, WindowManagerService.dipToPixel( MINIMUM_VISIBLE_HEIGHT_IN_DP, displayMetrics)); final int minVisibleWidth = Math.min(width, WindowManagerService.dipToPixel( MINIMUM_VISIBLE_WIDTH_IN_DP, displayMetrics)); final int top = Math.max(mContentFrame.top, Math.min(mFrame.top, mContentFrame.bottom - minVisibleHeight)); final int left = Math.max(mContentFrame.left + minVisibleWidth - width, Math.min(mFrame.left, mContentFrame.right - minVisibleWidth)); mFrame.set(left, top, left + width, top + height); mContentFrame.set(mFrame); mVisibleFrame.set(mContentFrame); mStableFrame.set(mContentFrame); &#125; else if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123; mDisplayContent.getDockedDividerController().positionDockedStackedDivider(mFrame); mContentFrame.set(mFrame); &#125; else &#123; mContentFrame.set(......); mVisibleFrame.set(......); mStableFrame.set(......); &#125; if (fullscreenTask &amp;&amp; !windowsAreFloating) &#123; // Windows that are not fullscreen can be positioned outside of the display frame, mOverscanInsets.set(......); &#125; if (mAttrs.type == TYPE_DOCK_DIVIDER) &#123; mStableInsets.set(......); mContentInsets.setEmpty(); mVisibleInsets.setEmpty(); &#125; else &#123; getDisplayContent().getLogicalDisplayRect(mTmpRect); boolean overrideRightInset = !fullscreenTask &amp;&amp; mFrame.right &gt; mTmpRect.right; boolean overrideBottomInset = !fullscreenTask &amp;&amp; mFrame.bottom &gt; mTmpRect.bottom; mContentInsets.set(......); mVisibleInsets.set(......); mStableInsets.set(......); &#125; // Offset the actual frame by the amount layout frame is off. mFrame.offset(-layoutXDiff, -layoutYDiff); mCompatFrame.offset(-layoutXDiff, -layoutYDiff); mContentFrame.offset(-layoutXDiff, -layoutYDiff); mVisibleFrame.offset(-layoutXDiff, -layoutYDiff); mStableFrame.offset(-layoutXDiff, -layoutYDiff); mCompatFrame.set(mFrame); if (mEnforceSizeCompat) &#123; mOverscanInsets.scale(mInvGlobalScale); mContentInsets.scale(mInvGlobalScale); mVisibleInsets.scale(mInvGlobalScale); mStableInsets.scale(mInvGlobalScale); mOutsets.scale(mInvGlobalScale); mCompatFrame.scale(mInvGlobalScale); &#125; ......&#125; æ•´ä¸ªçª—å£å¤§å°ä¿å­˜åœ¨WindowStateç±»çš„æˆå‘˜å˜é‡mFrameä¸­ï¼Œè€Œçª—å“çš„å†…å®¹åŒºåŸŸè¾¹è¡¬å¤§å°å’Œå¯è§åŒºåŸŸè¾¹è¡¬å¤§å°åˆ†åˆ«ä¿åœ¨WindowStateç±»çš„æˆå‘˜å˜é‡mContentInsetså’ŒmVisibleInsetsä¸­ 2.2.13ã€PhoneWindowManager.finishLayoutLw()12345[WindowState.java]@Overridepublic void finishLayoutLw() &#123; return;&#125; ï¼ˆä¸‰ï¼‰ã€Window Z-Order è®¡ç®—å’Œè°ƒæ•´è¿‡ç¨‹å£çš„UIæœ€ç»ˆæ˜¯éœ€è¦é€šè¿‡SurfaceFlingeræœåŠ¡æ¥ç»Ÿä¸€æ¸²æŸ“çš„ï¼Œè€ŒSurfaceFlingeræœåŠ¡åœ¨æ¸²æŸ“çª—å£çš„UIä¹‹å‰ï¼Œéœ€è¦è®¡ç®—åŸºäºå„ä¸ªçª—å£çš„Zè½´ä½ç½®æ¥è®¡ç®—å®ƒä»¬çš„å¯è§åŒºåŸŸã€‚å› æ­¤ï¼ŒWindowManagerServiceæœåŠ¡è®¡ç®—å¥½æ¯ä¸€ä¸ªçª—å£çš„Zè½´ä½ç½®ä¹‹åï¼Œè¿˜éœ€è¦å°†å®ƒä»¬è®¾ç½®åˆ°SurfaceFlingeræœåŠ¡ä¸­å»ï¼Œä»¥ä¾¿SurfaceFlingeræœåŠ¡å¯ä»¥æ­£ç¡®åœ°æ¸²æŸ“æ¯ä¸€ä¸ªçª—å£çš„UIã€‚ 3.1ã€éœ€è¦é‡æ–°è®¡ç®—çª—å£Zè½´ä½ç½®çš„æƒ…æ™¯åœ¨ã€Android 7.1.2 (Android N) Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹åˆ†æã€‘ä¸­å·²ç»è¯¦ç»†ä»‹ç»Windowæ·»åŠ è¿‡ç¨‹ï¼Œè¿™é‡Œç›´æ¥ä» WMS.addWindowå¼€å§‹åˆ†æã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[-&gt;WindowManagerService.java]public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ....... synchronized(mWindowMap) &#123; ...... boolean addToken = false; WindowToken token = mTokenMap.get(attrs.token); AppWindowToken atoken = null; boolean addToastWindowRequiresToken = false; ...... // WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); ...... origId = Binder.clearCallingIdentity(); if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); ...... boolean imMayMove = true; if (type == TYPE_INPUT_METHOD) &#123; win.mGivenInsetsPending = true; mInputMethodWindow = win; addInputMethodWindowToListLocked(win); imMayMove = false; &#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123; mInputMethodDialogs.add(win); addWindowToListInOrderLocked(win, true); moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true)); imMayMove = false; &#125; else &#123; addWindowToListInOrderLocked(win, true); ...... &#125; ...... //é‡æ–°è®¡ç®—ç³»ç»Ÿä¸­æ‰€æœ‰çª—å£çš„Zè½´ä½ç½® mLayersController.assignLayersLocked(displayContent.getWindowList()); ...... &#125; ...... return res;&#125; WMS.relayoutWindow()ä¹Ÿä¼šè°ƒç”¨WindowLayersController.assignLayersLocked()é‡æ–°è®¡ç®—ã€è°ƒæ•´ç³»ç»Ÿä¸­æ‰€æœ‰çª—å£çš„Zè½´ä½ç½®ï¼Œç”±äºåŸç†ç±»ä¼¼è¿™é‡Œä¸åšè§£é‡Šã€‚ 3.2ã€è®¡ç®—ç³»ç»Ÿä¸­æ‰€æœ‰çª—å£çš„Zè½´ä½ç½®æ¥ä¸‹æ¥æˆ‘ä»¬å°±é€šè¿‡WindowStateç±»çš„æ„é€ å‡½æ•°æ¥åˆ†æä¸€ä¸ªçª—å£çš„BaseLayerå€¼æ˜¯å¦‚ä½•ç¡®å®š 12345678910111213141516[WindowState.java]WindowState(WindowManagerService service, Session s, IWindow c, WindowToken token, WindowState attachedWindow, int appOp, int seq, WindowManager.LayoutParams a, int viewVisibility, final DisplayContent displayContent) &#123; ...... if ((mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; mAttrs.type &lt;= LAST_SUB_WINDOW)) &#123; ...... //windowTypeToLayerLwçš„è¿”å›å€¼å¹¶ä¸”ä¸æ˜¯ä¸€ä¸ªçª—å£çš„æœ€ç»ˆçš„BaseLayerå€¼ï¼Œè€Œæ˜¯è¦å°†å®ƒçš„è¿”å›å€¼ä¹˜ä»¥ä¸€ä¸ªå¸¸é‡TYPE_LAYER_MULTIPLIERï¼Œå†åŠ ä¸Šå¦å¤–ä¸€ä¸ªå¸¸é‡TYPE_LAYER_OFFSETä¹‹åï¼Œæ‰å¾—åˆ°æœ€ç»ˆçš„BaseLayerå€¼ mBaseLayer = mPolicy.windowTypeToLayerLw( attachedWindow.mAttrs.type) * WindowManagerService.TYPE_LAYER_MULTIPLIER + WindowManagerService.TYPE_LAYER_OFFSET; mSubLayer = mPolicy.subWindowTypeToLayerLw(a.type); ......&#125; ä¸€ä¸ªçª—å£é™¤äº†æœ‰ä¸€ä¸ªBaseLayerå€¼ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªSubLayerå€¼ï¼Œåˆ†åˆ«ä¿å­˜åœ¨ä¸€ä¸ªå¯¹åº”çš„WindowStateå¯¹è±¡çš„æˆå‘˜å˜é‡mBaseLayerå’ŒmSubLayerã€‚SubLayerå€¼æ˜¯ç”¨æ¥æè¿°ä¸€ä¸ªçª—å£æ˜¯å¦æ˜¯å¦å¤–ä¸€ä¸ªçª—å£çš„å­çª—å£çš„ã€‚ åœ¨ç»§ç»­åˆ†æWindowLayersController.assignLayersLocked()ä¹‹å‰ï¼Œæˆ‘ä»¬é¦–å…ˆåˆ†æPhoneWindowManager.windowTypeToLayerLw()å’ŒsubWindowTypeToLayerLw()çš„å®ç°ï¼Œä»¥ä¾¿å¯ä»¥äº†è§£ä¸€ä¸ªçª—å£çš„BaseLayerå€¼å’ŒSubLayerå€¼æ˜¯å¦‚ä½•ç¡®å®šçš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[-&gt;PhoneWindowManager.java]@Overridepublic int windowTypeToLayerLw(int type) &#123; if (type &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; type &lt;= LAST_APPLICATION_WINDOW) &#123; return 2; &#125; switch (type) &#123; ...... case TYPE_SYSTEM_DIALOG: return 7; case TYPE_TOAST: // toasts and the plugged-in battery thing return 8; ...... case TYPE_SYSTEM_ALERT: // like the ANR / app crashed dialogs return 11; ...... case TYPE_STATUS_BAR_SUB_PANEL: return 15; case TYPE_STATUS_BAR: return 16; case TYPE_STATUS_BAR_PANEL: return 17; case TYPE_KEYGUARD_DIALOG: return 18; ...... case TYPE_NAVIGATION_BAR: // the navigation bar, if available, shows atop most things return 21; case TYPE_NAVIGATION_BAR_PANEL: // some panels (e.g. search) need to show on top of the navigation bar return 22; ...... &#125; return 2;&#125;/** &#123;@inheritDoc&#125; */@Overridepublic int subWindowTypeToLayerLw(int type) &#123; switch (type) &#123; case TYPE_APPLICATION_PANEL: case TYPE_APPLICATION_ATTACHED_DIALOG: return APPLICATION_PANEL_SUBLAYER; ...... case TYPE_APPLICATION_ABOVE_SUB_PANEL: return APPLICATION_ABOVE_SUB_PANEL_SUBLAYER; &#125; return 0;&#125; ä¸»è¦æ ¹æ®ä¸åŒçš„Window Typeè¿”å›ä¸ä¸€æ ·çš„æ•°å€¼ã€‚ 123[-&gt;WindowManagerService.java]static final int TYPE_LAYER_MULTIPLIER = 10000;static final int TYPE_LAYER_OFFSET = 1000; æˆ‘ä»¬å¯ä»¥ç”¨adb shell dumpsys window -a å‘½ä»¤æŸ¥çœ‹ä¸€ä¸‹Layerçš„æ•°å€¼ï¼Œå¯ä»¥çœ‹åˆ°StatusBarçš„æ•°å€¼è®¡ç®—ï¼š mBaseLayer = 16 _WindowManagerService.TYPE_LAYER_MULTIPLIER+ WindowManagerService.TYPE_LAYEROFFSET StatusBar.mBaseLayer = 16 10000 + 1000 = 161000 ã€‚ 12345678910Window #4 Window&#123;3c1f1fb u0 StatusBar&#125;: mBaseLayer=161000 mSubLayer=0 mAnimLayer=161000+0=161000 mLastLayer=161000Window #3 Window&#123;fe4aae2 u0 KeyguardScrim&#125;: mBaseLayer=141000 mSubLayer=0 mAnimLayer=141000+0=141000 mLastLayer=141000Window #2 Window&#123;173ee76 u0 DockedStackDivider&#125;: mBaseLayer=21000 mSubLayer=0 mAnimLayer=21010+0=21010 mLastLayer=0Window #1 Window&#123;3a83a4a u0 com.android.launcher&#125;: mBaseLayer=21000 mSubLayer=0 mAnimLayer=21005+0=21005 mLastLayer=21005Window #0 Window&#123;aefb7bc u0 com.android.systemui.ImageWallpaper&#125;: mBaseLayer=21000 mSubLayer=0 mAnimLayer=21000+0=21000 mLastLayer=21000 ç†è§£äº†çª—å£çš„BaseLayerå€¼å’ŒSubLayerå€¼çš„è®¡ç®—è¿‡ç¨‹ä¹‹å¤–ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±å¯ä»¥åˆ†æWindowManagerServiceç±»çš„æˆå‘˜å‡½æ•°assignLayersLocked()çš„å®ç°äº† 3.2.1ã€WindowLayersController.assignLayersLocked()123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;WindowLayersController.java]final void assignLayersLocked(WindowList windows) &#123; if (DEBUG_LAYERS) Slog.v(TAG_WM, \"Assigning layers based on windows=\" + windows, new RuntimeException(\"here\").fillInStackTrace()); clear(); int curBaseLayer = 0; int curLayer = 0; boolean anyLayerChanged = false; for (int i = 0, windowCount = windows.size(); i &lt; windowCount; i++) &#123; final WindowState w = windows.get(i); boolean layerChanged = false; int oldLayer = w.mLayer; if (w.mBaseLayer == curBaseLayer || w.mIsImWindow || (i &gt; 0 &amp;&amp; w.mIsWallpaper)) &#123; curLayer += WINDOW_LAYER_MULTIPLIER; &#125; else &#123; curBaseLayer = curLayer = w.mBaseLayer; &#125; assignAnimLayer(w, curLayer); // TODO: Preserved old behavior of code here but not sure comparing // oldLayer to mAnimLayer and mLayer makes sense...though the // worst case would be unintentionalp layer reassignment. if (w.mLayer != oldLayer || w.mWinAnimator.mAnimLayer != oldLayer) &#123; layerChanged = true; anyLayerChanged = true; &#125; if (w.mAppToken != null) &#123; mHighestApplicationLayer = Math.max(mHighestApplicationLayer, w.mWinAnimator.mAnimLayer); &#125; collectSpecialWindows(w); if (layerChanged) &#123; w.scheduleAnimationIfDimming(); &#125; &#125; adjustSpecialWindows(); ......&#125; è°ƒç”¨ assignAnimLayer() è¿›è¡ŒLayerè°ƒæ•´ï¼š 12345678910[-&gt;WindowLayersController.java] private void assignAnimLayer(WindowState w, int layer) &#123; w.mLayer = layer; w.mWinAnimator.mAnimLayer = w.mLayer + w.getAnimLayerAdjustment() + getSpecialWindowAnimLayerAdjustment(w); if (w.mAppToken != null &amp;&amp; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer &gt; 0 &amp;&amp; w.mWinAnimator.mAnimLayer &gt; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer) &#123; w.mAppToken.mAppAnimator.thumbnailForceAboveLayer = w.mWinAnimator.mAnimLayer; &#125; &#125; 3.3ã€è®¾ç½®çª—å£çš„Zè½´ä½ç½®åˆ°SurfaceFlingeræœåŠ¡ä¸­å»WindowManagerServiceæœåŠ¡åœ¨åˆ·æ–°ç³»ç»Ÿçš„UIçš„æ—¶å€™ï¼Œå°±ä¼šå°†ç³»ç»Ÿä¸­å·²ç»è®¡ç®—å¥½äº†çš„çª—å£Zè½´ä½ç½®è®¾ç½®åˆ°SurfaceFlingeræœåŠ¡ä¸­å»ï¼Œä»¥ä¾¿SurfaceFlingeræœåŠ¡å¯ä»¥å¯¹ç³»ç»Ÿä¸­çš„çª—å£è¿›è¡Œå¯è§æ€§è®¡ç®—ä»¥åŠåˆæˆå’Œæ¸²æŸ“ç­‰æ“ä½œ é¦–å…ˆçœ‹ä¸€ä¸‹å †æ ˆä¿¡æ¯ï¼š 123456789101112131415161718192021WindowSurfaceController.showSurface()æ·»åŠ æ‰“å°LogSlog.i(\"zhoujinjian\", \"zhoujinjian\",new RuntimeException(\"here\").fillInStackTrace());03-01 19:06:45.229: I/zhoujinjian(1424): zhoujinjian03-01 19:06:45.229: I/zhoujinjian(1424): java.lang.RuntimeException: here03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowSurfaceController.showSurface(WindowSurfaceController.java:414)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowSurfaceController.updateVisibility(WindowSurfaceController.java:402)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowSurfaceController.showRobustlyInTransaction(WindowSurfaceController.java:391)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowStateAnimator.showSurfaceRobustlyLocked(WindowStateAnimator.java:1814)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowStateAnimator.prepareSurfaceLocked(WindowStateAnimator.java:1609)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowAnimator.animateLocked(WindowAnimator.java:791)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowAnimator.-wrap0(WindowAnimator.java)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.wm.WindowAnimator$1.doFrame(WindowAnimator.java:166)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer$CallbackRecord.run(Choreographer.java:879)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer.doCallbacks(Choreographer.java:693)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer.doFrame(Choreographer.java:625)03-01 19:06:45.229: I/zhoujinjian(1424): at android.view.Choreographer$FrameDisplayEventReceiver.run(Choreographer.java:867)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.Handler.handleCallback(Handler.java:751)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.Handler.dispatchMessage(Handler.java:95)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.Looper.loop(Looper.java:154)03-01 19:06:45.229: I/zhoujinjian(1424): at android.os.HandlerThread.run(HandlerThread.java:61)03-01 19:06:45.229: I/zhoujinjian(1424): at com.android.server.ServiceThread.run(ServiceThread.java:46) ä¸ºäº†äº†è§£WMSæ˜¯å¦‚ä½•å°†Zè½´ä½ç½®è®¾ç½®åˆ°SurfaceFlingeræœåŠ¡ä¸­å»ï¼Œé¦–å…ˆçœ‹ä¸€ä¸‹WMSæ„é€ æ–¹æ³•ä¸­å…³é”®å¯¹è±¡WindowAnimatorçš„åˆ›å»º 3.3.1ã€Vsyncåˆ·æ–°UIå›è°ƒè¿‡ç¨‹å¼€æœºå¯åŠ¨æ—¶ä¼šåˆå§‹åŒ–WMSã€‚ 1234567[-&gt;WindowManagerService.java]private WindowManagerService(Context context, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) &#123; ...... mAnimator = new WindowAnimator(this); ...... &#125; è°ƒç”¨WindowAnimatoræ„é€ æ–¹æ³• 12345678910111213141516[-&gt;WindowAnimator.java]WindowAnimator(final WindowManagerService service) &#123; mService = service; mContext = service.mContext; mPolicy = service.mPolicy; mWindowPlacerLocked = service.mWindowPlacerLocked; mAnimationFrameCallback = new Choreographer.FrameCallback() &#123; public void doFrame(long frameTimeNs) &#123; synchronized (mService.mWindowMap) &#123; mService.mAnimationScheduled = false; animateLocked(frameTimeNs); &#125; &#125; &#125;;&#125; å¯ä»¥çœ‹åˆ°åˆ›å»ºäº†Choreographer.FrameCallback()ï¼Œå‰é¢åœ¨ã€Android-7-1-2-Android-N-Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ã€‘åˆ†æè¿‡ï¼ŒFrameDisplayEventReceiverï¼ˆåœ¨Choreographeræ„é€ æ–¹æ³•ä¸­åˆå§‹åŒ–ï¼‰å¯¹è±¡ç”¨äºè¯·æ±‚å¹¶æ¥æ”¶Vsyncä¿¡å·ï¼Œå½“Vsyncä¿¡å·åˆ°æ¥æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è°ƒç”¨å…¶onVsync()å‡½æ•°ï¼Œåé¢ä¼šå›è°ƒåˆ°FrameDisplayEventReceiver.run()æ–¹æ³•ï¼Œå†å›è°ƒå‡½æ•°ä¸­æ‰§è¡ŒdoFrame()å®ç°å±å¹•åˆ·æ–°ï¼ŒdoFrame()ä¼šé¡ºåºæ‰§è¡ŒCALLBACK_INPUTã€CALLBACK_ANIMATIONã€CALLBACK_TRAVERSAL å’ŒCALLBACK_COMMIT å¯¹åº”CallbackQueueé˜Ÿåˆ—ä¸­æ³¨å†Œçš„å›è°ƒï¼Œä»è€Œä¼šæ‰§è¡ŒCallbackRecord.run()ï¼Œåœ¨æ‰§è¡Œå…¶å›è°ƒå‡½æ•°æ—¶ï¼Œå°±éœ€è¦åŒºåˆ«è¿™ä¸¤ç§å¯¹è±¡ç±»å‹ï¼Œå¦‚æœæ³¨å†Œçš„æ˜¯Runnableå¯¹è±¡ï¼Œåˆ™è°ƒç”¨å…¶run()å‡½æ•°ï¼Œå¦‚æœæ³¨å†Œçš„æ˜¯FrameCallbackå¯¹è±¡ï¼Œåˆ™è°ƒç”¨å®ƒçš„doFrame()å‡½æ•°ã€‚ 123456789101112131415[-&gt;Choreographer.java]private static final class CallbackRecord &#123; public CallbackRecord next; public long dueTime; public Object action; // Runnable or FrameCallback public Object token; public void run(long frameTimeNanos) &#123; if (token == FRAME_CALLBACK_TOKEN) &#123; ((FrameCallback)action).doFrame(frameTimeNanos); &#125; else &#123; ((Runnable)action).run(); &#125; &#125;&#125; åœ¨æ­¤ç§æƒ…å†µä¸‹ä¼šæ‰§è¡ŒFrameCallbackå¯¹è±¡çš„doFrame()å‡½æ•°ï¼ˆåŸå› ç¨åå†åˆ†æåŠ¨ç”»æ—¶è¯¦ç»†åˆ†æï¼‰ï¼Œç”±WindowAnimatoræ„é€ å‡½æ•°ä¸­å¯çŸ¥æ¥ç€å°±ä¼šæ‰§è¡ŒWindowAnimator.animateLocked() 3.3.2ã€å‡†å¤‡åˆ·æ–°UI123456789101112131415161718192021222324252627282930313233[-&gt;WindowAnimator.java] private void animateLocked(long frameTimeNs) &#123; ...... if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&gt;&gt;&gt; OPEN TRANSACTION animateLocked\"); SurfaceControl.openTransaction(); SurfaceControl.setAnimationTransaction(); try &#123; final int numDisplays = mDisplayContentsAnimators.size(); for (int i = 0; i &lt; numDisplays; i++) &#123; final int displayId = mDisplayContentsAnimators.keyAt(i); updateAppWindowsLocked(displayId); DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i); ...... updateWindowsLocked(displayId); updateWallpaperLocked(displayId); final WindowList windows = mService.getWindowListLocked(displayId); final int N = windows.size(); //é€šè¿‡ä¸€ä¸ªforå¾ªç¯æ¥éå†ä¿å­˜åœ¨çª—å£å †æ ˆçš„æ¯ä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œä»¥ä¾¿å¯ä»¥å¯¹ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªçª—å£çš„ç»˜å›¾è¡¨é¢è¿›è¡Œæ›´æ–° for (int j = 0; j &lt; N; j++) &#123; windows.get(j).mWinAnimator.prepareSurfaceLocked(true); &#125; &#125; ...... catch (RuntimeException e) &#123; ...... &#125; finally &#123; SurfaceControl.closeTransaction(); if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked\"); &#125;&#125; é¦–å…ˆè·å–windowsåˆ—è¡¨ï¼Œç„¶åå¾ªç¯è°ƒç”¨windows.get(j).mWinAnimator.prepareSurfaceLocked(true)ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[-&gt;WindowStateAnimator.java]void prepareSurfaceLocked(final boolean recoveringMemory) &#123; final WindowState w = mWin; ...... boolean displayed = false; //ç¡®å®šè¯¥çª—å£å®é™…è¦æ˜¾ç¤ºçš„å¤§å°ã€ä½ç½®ã€Alphaé€šé“å’Œå˜æ¢çŸ©é˜µç­‰ä¿¡æ¯ computeShownFrameLocked(); setSurfaceBoundariesLocked(recoveringMemory); if (mIsWallpaper &amp;&amp; !mWin.mWallpaperVisible) &#123; ...... &#125; else if (w.mAttachedHidden || !w.isOnScreen()) &#123; ...... &#125; else if (mLastLayer != mAnimLayer || mLastAlpha != mShownAlpha || mLastDsDx != mDsDx || mLastDtDx != mDtDx || mLastDsDy != mDsDy || mLastDtDy != mDtDy || w.mLastHScale != w.mHScale || w.mLastVScale != w.mVScale || mLastHidden) &#123; displayed = true; mLastAlpha = mShownAlpha; mLastLayer = mAnimLayer; mLastDsDx = mDsDx; mLastDtDx = mDtDx; mLastDsDy = mDsDy; mLastDtDy = mDtDy; w.mLastHScale = w.mHScale; w.mLastVScale = w.mVScale; ...... boolean prepared = mSurfaceController.prepareToShowInTransaction(mShownAlpha, mAnimLayer, mDsDx * w.mHScale * mExtraHScale, mDtDx * w.mVScale * mExtraVScale, mDsDy * w.mHScale * mExtraHScale, mDtDy * w.mVScale * mExtraVScale, recoveringMemory); if (prepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN) &#123; if (showSurfaceRobustlyLocked()) &#123; markPreservedSurfaceForDestroy(); mAnimator.requestRemovalOfReplacedWindows(w); mLastHidden = false; if (mIsWallpaper) &#123; mWallpaperControllerLocked.dispatchWallpaperVisibility(w, true); &#125; ...... mAnimator.setPendingLayoutChanges(w.getDisplayId(), WindowManagerPolicy.FINISH_LAYOUT_REDO_ANIM); &#125; else &#123; w.mOrientationChanging = false; &#125; &#125; if (hasSurface()) &#123; w.mToken.hasVisible = true; &#125; &#125; else &#123; displayed = true; &#125; ......&#125; è°ƒç”¨prepareToShowInTransaction()å°†alphã€alayerã€setMatrixè®¾ç½®åˆ°mSurfaceControlä¸­ã€‚ 1234567891011121314151617boolean prepareToShowInTransaction(float alpha, int layer, float dsdx, float dtdx, float dsdy, float dtdy, boolean recoveringMemory) &#123; if (mSurfaceControl != null) &#123; try &#123; mSurfaceAlpha = alpha; mSurfaceControl.setAlpha(alpha); mSurfaceLayer = layer; mSurfaceControl.setLayer(layer); mSurfaceControl.setMatrix( dsdx, dtdx, dsdy, dtdy); &#125; catch (RuntimeException e) &#123; ....... &#125; &#125; return true; &#125; setSurfaceBoundariesLocked()æ–¹æ³•ä¸­ä¼šè°ƒç”¨SurfaceControl.setPosition()ç­‰ç­‰æ–¹æ³•å°†è®¡ç®—å¥½çš„æ•°å€¼è®¾ç½®åˆ°mSurfaceControlä¸­ã€‚ è¯´æ˜ï¼šä¸€ä¸ªçª—å£çš„æ˜¾ç¤ºå’Œéšè—ï¼Œä»¥åŠå¤§å°ã€Xè½´å’ŒYè½´ä½ç½®ã€Zè½´ä½ç½®ã€Alphaé€šé“å’Œå˜æ¢çŸ©é˜µè®¾ç½®ï¼Œæ˜¯é€šè¿‡è°ƒç”¨Javaå±‚çš„SurfaceControlç±»çš„æˆå‘˜å‡½æ•°showã€hideã€setSizeã€setPositionã€setLayerã€setAlphaå’ŒsetMatrixæ¥å®ç°çš„ï¼Œå®ƒä»¬æœ€ç»ˆéƒ½æ˜¯é€šè¿‡è°ƒç”¨JNIæ–¹æ³•å®ç°çš„ 1234567891011121314151617181920212223242526272829303132SurfaceControl.java......public void setAlpha(float alpha) &#123; checkNotReleased(); nativeSetAlpha(mNativeObject, alpha);&#125;public void setMatrix(float dsdx, float dtdx, float dsdy, float dtdy) &#123; checkNotReleased(); nativeSetMatrix(mNativeObject, dsdx, dtdx, dsdy, dtdy);&#125;public void setWindowCrop(Rect crop) &#123; checkNotReleased(); if (crop != null) &#123; nativeSetWindowCrop(mNativeObject, crop.left, crop.top, crop.right, crop.bottom); &#125; else &#123; nativeSetWindowCrop(mNativeObject, 0, 0, 0, 0); &#125;&#125;public void setFinalCrop(Rect crop) &#123; checkNotReleased(); if (crop != null) &#123; nativeSetFinalCrop(mNativeObject, crop.left, crop.top, crop.right, crop.bottom); &#125; else &#123; nativeSetFinalCrop(mNativeObject, 0, 0, 0, 0); &#125;&#125;.... 3.3.3ã€å‘ŠçŸ¥SurfaceFlingeræ˜¾ç¤ºUIå¦‚æœWindowStateå¯¹è±¡wæ‰€æè¿°çš„çª—å£æ»¡è¶³æ¡ä»¶ï¼šprepared &amp;&amp; mLastHidden &amp;&amp; mDrawState == HAS_DRAWN é‚£ä¹ˆå°±è¯´æ˜ç°åœ¨æ˜¯æ—¶å€™è¦å°†WindowStateå¯¹è±¡wæ‰€æè¿°çš„çª—å£æ˜¾ç¤ºå‡ºæ¥äº†ï¼Œé€šè¿‡è°ƒç”¨showSurfaceRobustlyLockedå®ç° 123456789101112131415[-&gt;WindowStateAnimator.java]private boolean showSurfaceRobustlyLocked() &#123; final Task task = mWin.getTask(); if (task != null &amp;&amp; StackId.windowsAreScaleable(task.mStack.mStackId)) &#123; mSurfaceController.forceScaleableInTransaction(true); &#125; boolean shown = mSurfaceController.showRobustlyInTransaction(); ...... if (mWin.mTurnOnScreen) &#123; ...... mWin.mTurnOnScreen = false; mAnimator.mBulkUpdateParams |= SET_TURN_ON_SCREEN; &#125; return true;&#125; ç›´æ¥è°ƒç”¨WindowSurfaceController.showRobustlyInTransaction() â€“&gt; updateVisibility()â€“&gt;showSurface()-&gt;SurfaceControl.show() 123456789101112131415161718192021222324252627282930[-&gt;WindowSurfaceController.java] boolean showRobustlyInTransaction() &#123; ...... mHiddenForOtherReasons = false; return updateVisibility(); &#125; private boolean updateVisibility() &#123; if (mHiddenForCrop || mHiddenForOtherReasons) &#123; if (mSurfaceShown) &#123;hideSurface();&#125; return false; &#125; else &#123; if (!mSurfaceShown) &#123;return showSurface(); &#125; else &#123; return true; &#125; &#125; &#125; private boolean showSurface() &#123; try &#123; mSurfaceShown = true; mSurfaceControl.show(); Slog.i(\"zhoujinjian\", \"zhoujinjian\",new RuntimeException(\"here\").fillInStackTrace()); return true; &#125; catch (RuntimeException e) &#123; ...... &#125; //å‡ºç°å¼‚å¸¸,å›æ”¶ç³»ç»Ÿå†…å­˜èµ„æº mAnimator.reclaimSomeSurfaceMemory(\"show\", true); return false; &#125; 12345[-&gt;SurfaceControl.java]public void show() &#123; checkNotReleased(); nativeSetFlags(mNativeObject, 0, SURFACE_HIDDEN);&#125; é€šè¿‡JNIè°ƒç”¨android_view_SurfaceControl.cppçš„nativeSetFlagså‡½æ•°ï¼Œå¯ä»¥çœ‹åˆ°flags == 0ï¼› 12345678[-&gt;android_view_SurfaceControl.cpp]static void nativeSetFlags(JNIEnv* env, jclass clazz, jlong nativeObject, jint flags, jint mask) &#123; SurfaceControl* const ctrl = reinterpret_cast&lt;SurfaceControl *&gt;(nativeObject); status_t err = ctrl-&gt;setFlags(flags, mask); if (err &lt; 0 &amp;&amp; err != NO_INIT) &#123; doThrowIAE(env); &#125;&#125; è°ƒç”¨SurfaceControl.cppçš„setFlags()å‡½æ•° 123456[-&gt;SurfaceControl.cpp]status_t SurfaceControl::setFlags(uint32_t flags, uint32_t mask) &#123; status_t err = validate(); if (err &lt; 0) return err; return mClient-&gt;setFlags(mHandle, flags, mask);&#125; è¿›ä¸€æ­¥é€šè¿‡Binder IPCæœºåˆ¶ï¼ŒSurfaceComposerClient.cpp-&gt;Composer::setFlags() 1234567891011121314151617[-&gt;SurfaceComposerClient.cpp]status_t Composer::setFlags(const sp&lt;SurfaceComposerClient&gt;&amp; client, const sp&lt;IBinder&gt;&amp; id, uint32_t flags, uint32_t mask) &#123; Mutex::Autolock _l(mLock); layer_state_t* s = getLayerStateLocked(client, id); ...... if ((mask &amp; layer_state_t::eLayerOpaque) || (mask &amp; layer_state_t::eLayerHidden) || (mask &amp; layer_state_t::eLayerSecure)) &#123; s-&gt;what |= layer_state_t::eFlagsChanged; &#125; s-&gt;flags &amp;= ~mask; s-&gt;flags |= (flags &amp; mask); s-&gt;mask |= mask; return NO_ERROR;&#125; å…·ä½“æ•°å€¼å°±ä¸è¯¦ç»†è®¡ç®—äº†ï¼Œå‰é¢åˆ†æã€Android 7.1.2 (Android N) Android Graphics ç³»ç»Ÿåˆ†æ [i.wonder~]ã€‘å¯çŸ¥ï¼ŒSurfaceFlingeræ¥æ”¶Vsyncä¿¡å·ä¸Appæœ‰ä¸€ä¸ªoffseté—´éš”æ—¶é—´ï¼Œå½“SurfaceFlingeræ¥æ”¶Vsyncä¿¡å·æ—¶ï¼Œå°±å¯ä»¥æ ¹æ®flagsæ˜¯å¦æ˜¾ç¤º å’Œ ä¸Šé¢è®¾ç½®çš„ä¸€ç³»åˆ—æ•°å€¼è¿›è¡Œæ¸²æŸ“åˆæˆï¼Œæœ€ç»ˆæ˜¾ç¤ºåˆ°å±å¹•ä¸Šã€‚ ï¼ˆå››ï¼‰ã€Activityå¯åŠ¨çª—å£(Starting Window)æ·»åŠ è¿‡ç¨‹4.1ã€Activityç»„ä»¶çš„å¯åŠ¨çª—å£(Starting Window)çš„æ·»åŠ è¿‡ç¨‹æ—¶åºå›¾ï¼š 4.1.1ã€ ActivityStack.startActivityLocked()123456789101112131415161718192021222324252627282930313233343536373839[-&gt;ActivityStack.java] final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123; ...... if (!isHomeStack() || numActivities() &gt; 0) &#123; ...... if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123; mWindowManager.prepareAppTransition(TRANSIT_NONE, keepCurTransition); mNoAnimActivities.add(r); &#125; else &#123; mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? TRANSIT_TASK_OPEN_BEHIND : TRANSIT_TASK_OPEN : TRANSIT_ACTIVITY_OPEN, keepCurTransition); mNoAnimActivities.remove(r); &#125; addConfigOverride(r, task); boolean doShow = true; ...... if (r.mLaunchTaskBehind) &#123; ....... &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; ActivityRecord prev = r.task.topRunningActivityWithStartingWindowLocked(); if (prev != null) &#123; // We don't want to reuse the previous starting preview if: // (1) The current activity is in a different task. if (prev.task != r.task) &#123; prev = null; &#125; // (2) The current activity is already displayed. else if (prev.nowVisible) &#123; prev = null; &#125; &#125; r.showStartingWindow(prev, showStartingIcon); &#125; &#125; ...... &#125; å¯ä»¥çœ‹åˆ°ç›´æ¥è°ƒç”¨ActivityRecord.showStartingWindow()è¿›ä¸€æ­¥æ·»åŠ å¯åŠ¨çª—å£ 4.1.2ã€ ActivityRecord.showStartingWindow()1234567891011[-&gt;ActivityRecord.java]void showStartingWindow(ActivityRecord prev, boolean createIfNeeded) &#123; final CompatibilityInfo compatInfo = service.compatibilityInfoForPackageLocked(info.applicationInfo); final boolean shown = service.mWindowManager.setAppStartingWindow( appToken, packageName, theme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags, prev != null ? prev.appToken : null, createIfNeeded); if (shown) &#123; mStartingWindowState = STARTING_WINDOW_SHOWN; &#125;&#125; 4.1.2ã€ActivityRecord.setAppStartingWindow()1234567891011121314151617181920[-&gt;ActivityRecord.java]public boolean setAppStartingWindow(IBinder token, String pkg, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, IBinder transferFrom, boolean createIfNeeded) &#123; ...... synchronized(mWindowMap) &#123; AppWindowToken wtoken = findAppWindowToken(token); ...... if (transferStartingWindow(transferFrom, wtoken)) &#123; return true; &#125; ...... wtoken.startingData = new StartingData(pkg, theme, compatInfo, nonLocalizedLabel, labelRes, icon, logo, windowFlags); Message m = mH.obtainMessage(H.ADD_STARTING, wtoken); mH.sendMessageAtFrontOfQueue(m); &#125; return true;&#125; å¦‚æœå‚æ•°transferFromæ‰€æè¿°çš„Activityç»„ä»¶æ²¡æœ‰å¯åŠ¨çª—å£æˆ–è€…å¯åŠ¨çª—å£æ•°æ®è½¬ç§»ç»™å‚æ•°tokenæ‰€æè¿°çš„Activityç»„ä»¶ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥å°±å¯èƒ½éœ€è¦ä¸ºå‚æ•°tokenæ‰€æè¿°çš„Activityç»„ä»¶åˆ›å»ºä¸€ä¸ªæ–°çš„å¯åŠ¨çª—å£ 4.1.3ã€ H.handleMessage()12345678910111213141516171819202122232425262728293031323334353637[-&gt;WindowManagerService.java::H]case ADD_STARTING: &#123; final AppWindowToken wtoken = (AppWindowToken)msg.obj; final StartingData sd = wtoken.startingData; ...... View view = null; try &#123; final Configuration overrideConfig = wtoken != null &amp;&amp; wtoken.mTask != null ? wtoken.mTask.mOverrideConfig : null; view = mPolicy.addStartingWindow(wtoken.token, sd.pkg, sd.theme, sd.compatInfo, sd.nonLocalizedLabel, sd.labelRes, sd.icon, sd.logo, sd.windowFlags, overrideConfig); &#125; catch (Exception e) &#123; &#125; if (view != null) &#123; boolean abort = false; synchronized(mWindowMap) &#123; if (wtoken.removed || wtoken.startingData == null) &#123; wtoken.startingWindow = null; wtoken.startingData = null; abort = true; &#125; &#125; else &#123; wtoken.startingView = view; &#125; &#125; if (abort) &#123; try &#123; mPolicy.removeStartingWindow(wtoken.token, view); &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125; break; PhoneWindowManagerå®ç°WindowManagerPolicyï¼Œæ‰€ä»¥ä¼šè°ƒç”¨PhoneWindowManagerä¸­çš„æ–¹æ³• ç»§ç»­åˆ†æPhoneWindowManager.addStartingWindow() 4.1.4ã€PhoneWindowManager.addStartingWindow()12345678910111213141516171819202122232425262728293031323334353637383940414243[-&gt;PhoneWindowManager.java]public View addStartingWindow(IBinder appToken, String packageName, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes, int icon, int logo, int windowFlags, Configuration overrideConfig) &#123; ...... WindowManager wm = null; View view = null; try &#123; Context context = mContext; ...... final PhoneWindow win = new PhoneWindow(context); win.setIsStartingWindow(true); ...... win.setType( WindowManager.LayoutParams.TYPE_APPLICATION_STARTING); ...... win.setLayout(WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT); final WindowManager.LayoutParams params = win.getAttributes(); params.token = appToken; params.packageName = packageName; params.windowAnimations = win.getWindowStyle().getResourceId( com.android.internal.R.styleable.Window_windowAnimationStyle, 0); ...... params.setTitle(\"Starting \" + packageName); wm = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); view = win.getDecorView(); ...... wm.addView(view, params); return view.getParent() != null ? view : null; &#125; catch (WindowManager.BadTokenException e) &#123; ...... &#125; catch (RuntimeException e) &#123; ...... &#125; finally &#123; if (view != null &amp;&amp; view.getParent() == null) &#123; wm.removeViewImmediate(view); &#125; &#125; return null;&#125; åˆ›å»ºPhoneWindowå¯¹è±¡ï¼Œæ¥ä¸‹æ¥ç»§ç»­è®¾ç½®æ‰€åˆ›å»ºçš„çª—å£winçš„ä»¥ä¸‹å±æ€§ï¼š 1ã€çª—å£ç±»å‹ï¼šè®¾ç½®ä¸ºWindowManager.LayoutParams.TYPE_APPLICATION_STARTINGï¼Œå³è®¾ç½®ä¸ºå¯åŠ¨çª—å£ç±»å‹ï¼› 2ã€çª—å£æ ‡é¢˜ï¼šç”±å‚æ•°labelResã€nonLocalizedLabelï¼Œä»¥åŠçª—å£çš„è¿è¡Œä¸Šä¸‹æ–‡contextæ¥ç¡®å®šï¼› 3ã€çª—å£æ ‡å¿—ï¼šåˆ†åˆ«å°†indowManager.LayoutParams.FLAG_NOT_TOUCHABLEã€WindowManager.LayoutParams.FLAG_NOT_FOCUSABLEå’ŒWindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IMä½è®¾ç½®ä¸º1ï¼Œå³ä¸å¯æ¥å—è§¦æ‘¸äº‹ä»¶å’Œä¸å¯è·å¾—ç„¦ç‚¹ï¼Œä½†æ˜¯å¯ä»¥æ¥å—è¾“å…¥æ³•çª—å£ï¼› 4ã€çª—å£å¤§å°ï¼šè®¾ç½®ä¸ºWindowManager.LayoutParams.MATCH_PARENTï¼Œå³ä¸çˆ¶çª—å£ä¸€æ ·å¤§ï¼Œä½†æ˜¯ç”±äºè¿™æ˜¯ä¸€ä¸ªé¡¶å±‚çª—å£ï¼Œå› æ­¤å®é™…ä¸Šæ˜¯æŒ‡ä¸å±å¹•ä¸€æ ·å¤§ï¼› 5ã€å¸ƒå±€å‚æ•°ï¼šåŒ…æ‹¬çª—å£æ‰€å¯¹åº”çš„çª—å£ä»¤ç‰Œï¼ˆtokenï¼‰å’ŒåŒ…åï¼ˆpackageNameï¼‰ï¼Œä»¥åŠçª—å£æ‰€ä½¿ç”¨çš„åŠ¨ç”»ç±»å‹ï¼ˆwindowAnimationsï¼‰å’Œæ ‡é¢˜ï¼ˆtitleï¼‰ã€‚ wm.addView(view, params)ï¼Œä¸€ä¸ªæ–°åˆ›å»ºçš„Activityç»„ä»¶çš„å¯åŠ¨çª—å£å°±å¢åŠ åˆ°WindowManagerServiceæœåŠ¡ä¸­å»äº†ï¼Œè¿™æ ·ï¼ŒWindowManagerServiceæœåŠ¡å°±å¯ä»¥ä¸‹æ¬¡åˆ·æ–°ç³»ç»ŸUIæ—¶ï¼Œå°†è¯¥å¯åŠ¨çª—å£æ˜¾ç¤ºå‡ºæ¥ ï¼ˆäº”ï¼‰ã€WMSåˆ‡æ¢Activityçª—å£ï¼ˆApp Transitionï¼‰è¿‡ç¨‹WindowManagerServiceæœåŠ¡åœ¨æ‰§è¡ŒActivityçª—å£çš„åˆ‡æ¢æ“ä½œçš„æ—¶å€™ï¼Œä¼šç»™å‚ä¸åˆ‡æ¢æ“ä½œçš„Activityç»„ä»¶çš„è®¾ç½®ä¸€ä¸ªåŠ¨ç”»ï¼Œä»¥ä¾¿å¯ä»¥å‘ç”¨æˆ·å±•ç°ä¸€ä¸ªActivityç»„ä»¶åˆ‡æ¢æ•ˆæœï¼Œä»è€Œæé«˜ç”¨æˆ·ä½“éªŒã€‚ é¦–å…ˆçœ‹ä¸€ä¸‹App TransitionåŠ¨æ€å›¾ï¼š æ—¶åºå›¾ï¼š æˆ‘ä»¬ç›´æ¥åˆ†æApp Transitionè¿‡ç¨‹çš„prepareAppTransitionã€executeAppTransition å…³äºActivityå¯åŠ¨è¿‡ç¨‹è¯·å‚è€ƒï¼šã€Android-7-1-2-Android-N-Activityå¯åŠ¨æµç¨‹åˆ†æã€‘ 5.1ã€prepareAppTransition()è¿‡ç¨‹5.1.1ã€ActivityStack.startActivityLocked()12345678[-&gt;ActivityStack.java]......mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? TRANSIT_TASK_OPEN_BEHIND : TRANSIT_TASK_OPEN : TRANSIT_ACTIVITY_OPEN, keepCurTransition);...... 5.1.2ã€WindowManagerService.prepareAppTransition()123456789101112[-&gt;WindowManagerService.java]@Overridepublic void prepareAppTransition(int transit, boolean alwaysKeepCurrent) &#123; ...... synchronized(mWindowMap) &#123; boolean prepared = mAppTransition.prepareAppTransitionLocked( transit, alwaysKeepCurrent); if (prepared &amp;&amp; okToDisplay()) &#123; mSkipAppTransitionAnimation = false; &#125; &#125;&#125; å‘ç°æ˜¯ç›´æ¥è°ƒç”¨AppTransition.prepareAppTransitionLocked()å®ç°çš„ã€‚ 5.1.3ã€AppTransition.prepareAppTransitionLocked()è¿›ä¸€æ­¥è°ƒç”¨setAppTransition() 12345private void setAppTransition(int transit) &#123; mNextAppTransition = transit; setLastAppTransition(TRANSIT_UNSET, null, null);&#125; å‘ç°åªæ˜¯å°†transitï¼ˆå³AppTransitionåŠ¨ç”»ç±»å‹ï¼‰èµ‹å€¼ç»™å˜é‡mNextAppTransition 5.2ã€AppTransition animationè®¾ç½®è¿‡ç¨‹ç»§ç»­åˆ†æActivityStackSupervisor.realStartActivityLocked() 123456789101112[-&gt;ActivityStackSupervisor.java]final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... if (andResume) &#123; r.startFreezingScreenLocked(app, 0); mWindowManager.setAppVisibility(r.appToken, true); // schedule launch ticks to collect information about slow apps. r.startLaunchTickingLocked(); &#125; é¦–å…ˆä¼šé€šçŸ¥WindowManagerServiceæœåŠ¡å°†å‚æ•°r.appTokenæ‰€æè¿°çš„Activityç»„ä»¶çš„å¯è§æ€§è®¾ç½®ä¸ºtrue 12345678910111213141516171819[-&gt;WindowManagerService.java]@Overridepublic void setAppVisibility(IBinder token, boolean visible) &#123; ...... AppWindowToken wtoken; synchronized(mWindowMap) &#123; wtoken = findAppWindowToken(token); ...... mOpeningApps.remove(wtoken); mClosingApps.remove(wtoken); ...... final long origId = Binder.clearCallingIdentity(); wtoken.inPendingTransaction = false; setTokenVisibilityLocked(wtoken, null, visible, AppTransition.TRANSIT_UNSET, true, wtoken.voiceInteraction); wtoken.updateReportedVisibilityLocked(); &#125; &#125; è°ƒç”¨WindowManagerService.setTokenVisibilityLocked() 1234567891011121314151617[-&gt;WindowManagerService.java] boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp, boolean visible, int transit, boolean performLayout, boolean isVoiceInteraction) &#123; ...... if (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) || (visible &amp;&amp; wtoken.waitingForReplacement())) &#123; ...... if (transit != AppTransition.TRANSIT_UNSET) &#123; ...... if (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123; delayed = runningAppAnimation = true; &#125; ...... changed = true; &#125; &#125; &#125; è°ƒç”¨WindowManagerService.applyAnimationLocked()è®¾ç½®AppTransitionåŠ¨ç”» 12345678910[-&gt;WindowManagerService.java] private boolean applyAnimationLocked(AppWindowToken atoken, WindowManager.LayoutParams lp, int transit, boolean enter, boolean isVoiceInteraction) &#123; ...... if (okToDisplay()) &#123; Animation a = mAppTransition.loadAnimation(lp, transit, enter, mCurConfiguration.uiMode, mCurConfiguration.orientation, frame, displayFrame, insets, surfaceInsets, isVoiceInteraction, freeform, atoken.mTask.mTaskId); &#125;&#125; ç»ˆäºåˆ°äº†AppTransitionçœŸæ­£è®¾ç½®è¿‡ç¨‹äº† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[-&gt;AppTransition.java]Animation loadAnimation(WindowManager.LayoutParams lp, int transit, boolean enter, int uiMode, int orientation, Rect frame, Rect displayFrame, Rect insets, @Nullable Rect surfaceInsets, boolean isVoiceInteraction, boolean freeform, int taskId) &#123; Animation a; if()&#123;&#125; ...... &#125; else if()&#123; ...... &#125;else &#123; int animAttr = 0; switch (transit) &#123; case TRANSIT_ACTIVITY_OPEN: animAttr = enter ? WindowAnimation_activityOpenEnterAnimation : WindowAnimation_activityOpenExitAnimation; break; case TRANSIT_ACTIVITY_CLOSE: animAttr = enter ? WindowAnimation_activityCloseEnterAnimation : WindowAnimation_activityCloseExitAnimation; break; case TRANSIT_DOCK_TASK_FROM_RECENTS: case TRANSIT_TASK_OPEN: animAttr = enter ? WindowAnimation_taskOpenEnterAnimation : WindowAnimation_taskOpenExitAnimation; break; case TRANSIT_TASK_CLOSE: animAttr = enter ? WindowAnimation_taskCloseEnterAnimation : WindowAnimation_taskCloseExitAnimation; break; case TRANSIT_TASK_TO_FRONT: animAttr = enter ? WindowAnimation_taskToFrontEnterAnimation : WindowAnimation_taskToFrontExitAnimation; break; case TRANSIT_TASK_TO_BACK: animAttr = enter ? WindowAnimation_taskToBackEnterAnimation : WindowAnimation_taskToBackExitAnimation; break; ...... &#125; a = animAttr != 0 ? loadAnimationAttr(lp, animAttr) : null; &#125; return a;&#125; æœ€åé€šè¿‡loadAnimationAttråŠ è½½xmlæ–‡ä»¶åŠ è½½åŠ¨ç”»ï¼ŒåŠ¨ç”»xmlæ–‡ä»¶çš„å­˜æ”¾è·¯å¾„ï¼ˆ/frameworks/base/core/res/res/anim/ï¼‰ 5.3ã€executeAppTransitionè¿‡ç¨‹ ActivityStackSupervisor.realStartActivityLocked() ActivityStack.minimalResumeActivityLocked() ActivityStack.completeResumeLocked() ActivityStackSupervisor.reportResumedActivityLocked() ç»§ç»­åˆ†æActivityStackSupervisor.reportResumedActivityLocked() 1234567891011[-&gt;ActivityStackSupervisor.java]boolean reportResumedActivityLocked(ActivityRecord r) &#123; final ActivityStack stack = r.task.stack; ...... if (allResumedActivitiesComplete()) &#123; ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); mWindowManager.executeAppTransition(); return true; &#125; return false;&#125; é¦–å…ˆæ˜¯Activityç»„ä»¶çš„å¯è§æ€§è®¾ç½®ï¼Œç„¶åæ‰§è¡ŒexecuteAppTransition() 5.3.1.WindowManagerService.executeAppTransition()123456789101112131415[-&gt;WindowManagerService.java] public void executeAppTransition() &#123; ...... synchronized(mWindowMap) &#123; if (mAppTransition.isTransitionSet()) &#123; mAppTransition.setReady(); ...... try &#123; mWindowPlacerLocked.performSurfacePlacement(); &#125; finally &#123; ...... &#125; &#125; &#125; &#125; è€ŒWindowSurfacePlacer.performSurfacePlacement()è¯·çœ‹å‰é¢ç¬¬äºŒèŠ‚åˆ†æ ï¼ˆå…­ï¼‰ã€Activity Window åŠ¨ç”»æ˜¾ç¤ºè¿‡ç¨‹6.1ã€åŠ¨ç”»çš„è®¾ç½®è¿‡ç¨‹åœ¨Androidç³»ç»Ÿä¸­ï¼Œçª—å£åŠ¨ç”»çš„æœ¬è´¨å°±æ˜¯å¯¹åŸå§‹çª—å£æ–½åŠ ä¸€ä¸ªå˜æ¢ï¼ˆTransformationï¼‰ã€‚åœ¨çº¿æ€§æ•°å­¦ä¸­ï¼Œå¯¹ç‰©ä½“çš„å½¢çŠ¶è¿›è¡Œå˜æ¢æ˜¯é€šè¿‡ä¹˜ä»¥ä¸€ä¸ªçŸ©é˜µï¼ˆMatrixï¼‰æ¥å®ç°ï¼Œç›®çš„å°±æ˜¯å¯¹ç‰©ä½“è¿›è¡Œåç§»ã€æ—‹è½¬ã€ç¼©æ”¾ã€åˆ‡å˜ã€åå°„å’ŒæŠ•å½±ç­‰ã€‚å› æ­¤ï¼Œç»™çª—å£è®¾ç½®åŠ¨ç”»å®é™…ä¸Šå°±ç»™çª—å£è®¾ç½®ä¸€ä¸ªå˜æ¢çŸ©é˜µï¼ˆTransformation Matrixï¼‰ã€‚ çª—å£è¢«è®¾ç½®çš„åŠ¨ç”»è™½ç„¶å¯ä»¥è¾¾åˆ°ä¸‰ä¸ªï¼Œä½†æ˜¯è¿™ä¸‰ä¸ªåŠ¨ç”»å¯ä»¥å½’ç»“ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯æ™®é€šåŠ¨ç”»ï¼Œä¾‹å¦‚ï¼Œçª—å£åœ¨æ‰“å¼€è¿‡ç¨‹ä¸­è¢«è®¾ç½®çš„è¿›å…¥åŠ¨ç”»å’Œåœ¨å…³é—­è¿‡ç¨‹ä¸­è¢«è®¾ç½®çš„é€€å‡ºåŠ¨ç”»ï¼Œå¦ä¸€ç±»æ˜¯åˆ‡æ¢åŠ¨ç”»ã€‚å…¶ä¸­ï¼ŒSelf Transformationå’ŒAttached Transformationéƒ½æ˜¯å±äºæ™®é€šåŠ¨ç”»ï¼Œè€ŒApp Transformationå±äºåˆ‡æ¢åŠ¨ç”»ã€‚å‰é¢å·²ç»åˆ†æè¿‡App Transformationçš„è®¾ç½®è¿‡ç¨‹ æ¥ä¸‹æ¥åˆ†ææ™®é€šåŠ¨ç”»çš„è®¾ç½®è¿‡ç¨‹ã€‚ 6.1ã€æ™®é€šåŠ¨ç”»çš„è®¾ç½®è¿‡ç¨‹æ™®é€šåŠ¨ç”»çš„è®¾ç½®è¿‡ç¨‹ä¹Ÿæ˜¯é€šè¿‡setTokenVisibilityLocked()è®¾ç½®çš„ 6.1.1ã€WindowManagerService.setTokenVisibilityLocked()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354[-&gt;WindowManagerService.java] boolean setTokenVisibilityLocked(AppWindowToken wtoken, WindowManager.LayoutParams lp, boolean visible, int transit, boolean performLayout, boolean isVoiceInteraction) &#123; ...... if (wtoken.hidden == visible || (wtoken.hidden &amp;&amp; wtoken.mIsExiting) || (visible &amp;&amp; wtoken.waitingForReplacement())) &#123; ...... if (transit != AppTransition.TRANSIT_UNSET) &#123; ...... if (applyAnimationLocked(wtoken, lp, transit, visible, isVoiceInteraction)) &#123; delayed = runningAppAnimation = true; &#125; ...... changed = true; &#125; final int windowsCount = wtoken.allAppWindows.size(); for (int i = 0; i &lt; windowsCount; i++) &#123; WindowState win = wtoken.allAppWindows.get(i); ...... if (visible) &#123; if (!win.isVisibleNow()) &#123; if (!runningAppAnimation) &#123; win.mWinAnimator.applyAnimationLocked( WindowManagerPolicy.TRANSIT_ENTER, true); ...... &#125; changed = true; win.setDisplayLayoutNeeded(); &#125; &#125; else if (win.isVisibleNow()) &#123; if (!runningAppAnimation) &#123; win.mWinAnimator.applyAnimationLocked( WindowManagerPolicy.TRANSIT_EXIT, false); ...... &#125; changed = true; win.setDisplayLayoutNeeded(); &#125; &#125; wtoken.hidden = wtoken.hiddenRequested = !visible; visibilityChanged = true; ...... if (changed) &#123; mInputMonitor.setUpdateInputWindowsNeededLw(); if (performLayout) &#123; updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES, false /*updateInputWindows*/); mWindowPlacerLocked.performSurfacePlacement(); &#125; mInputMonitor.updateInputWindowsLw(false /*force*/); &#125; &#125; &#125; å¯ä»¥çœ‹åˆ°æ™®é€šåŠ¨ç”»æ˜¯é€šè¿‡win.mWinAnimator.applyAnimationLocked(WindowManagerPolicy.TRANSIT_ENTER, true) 6.1.1.WindowStateAnimator.applyAnimationLocked()1234567891011121314151617181920212223242526272829303132333435363738[-&gt;WindowStateAnimator.java]boolean applyAnimationLocked(int transit, boolean isEntrance) &#123; ...... if (mService.okToDisplay()) &#123; int anim = mPolicy.selectAnimationLw(mWin, transit); int attr = -1; Animation a = null; if (anim != 0) &#123; a = anim != -1 ? AnimationUtils.loadAnimation(mContext, anim) : null; &#125; else &#123; switch (transit) &#123; case WindowManagerPolicy.TRANSIT_ENTER: attr = com.android.internal.R.styleable.WindowAnimation_windowEnterAnimation; break; case WindowManagerPolicy.TRANSIT_EXIT: attr = com.android.internal.R.styleable.WindowAnimation_windowExitAnimation; break; case WindowManagerPolicy.TRANSIT_SHOW: attr = com.android.internal.R.styleable.WindowAnimation_windowShowAnimation; break; case WindowManagerPolicy.TRANSIT_HIDE: attr = com.android.internal.R.styleable.WindowAnimation_windowHideAnimation; break; &#125; if (attr &gt;= 0) &#123; a = mService.mAppTransition.loadAnimationAttr(mWin.mAttrs, attr); &#125; &#125; if (a != null) &#123; setAnimation(a); mAnimationIsEntrance = isEntrance; &#125; &#125; else &#123; clearAnimation(); &#125; ...... return mAnimation != null;&#125; å¯ä»¥çœ‹åˆ°ä¹Ÿæ˜¯æ ¹æ®åŠ¨ç”»ç±»å‹ä»è€Œé€šè¿‡AppTransition.loadAnimationAttr(mWin.mAttrs, attr)åŠ è½½ä¸åŒçš„anim xmlæ–‡ä»¶ã€‚ 6.2ã€çª—å£åŠ¨ç”»çš„æ˜¾ç¤ºæ¡†æ¶é€šè¿‡å †æ ˆä¿¡æ¯å¯ä»¥çœ‹åˆ°ï¼Œç”±Vsyncä¿¡å·é©±åŠ¨ï¼Œç„¶åè°ƒç”¨Choreographer.doFrameå®ŒæˆåŠ¨ç”»çš„ç›¸å…³æ“ä½œï¼Œå…³äºVsyncè¿™éƒ¨åˆ†ä¹‹å‰æ–‡ç« å·²ç»åˆ†æè¿‡ï¼Œè¿™é‡Œä¸å†åˆ†æäº†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130[-&gt;WindowAnimator.java]/** Locked on mService.mWindowMap. */private void animateLocked(long frameTimeNs) &#123; ...... mCurrentTime = frameTimeNs / TimeUtils.NANOS_PER_MS; mBulkUpdateParams = SET_ORIENTATION_CHANGE_COMPLETE; boolean wasAnimating = mAnimating; setAnimating(false); mAppWindowAnimating = false; ...... if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&gt;&gt;&gt; OPEN TRANSACTION animateLocked\"); SurfaceControl.openTransaction(); SurfaceControl.setAnimationTransaction(); try &#123; final int numDisplays = mDisplayContentsAnimators.size(); for (int i = 0; i &lt; numDisplays; i++) &#123; final int displayId = mDisplayContentsAnimators.keyAt(i); //1ã€Activityç»„ä»¶åˆ‡æ¢åŠ¨ç”»çš„æ¨è¿›è¿‡ç¨‹ updateAppWindowsLocked(displayId); DisplayContentsAnimator displayAnimator = mDisplayContentsAnimators.valueAt(i); final ScreenRotationAnimation screenRotationAnimation = displayAnimator.mScreenRotationAnimation; if (screenRotationAnimation != null &amp;&amp; screenRotationAnimation.isAnimating()) &#123; if (screenRotationAnimation.stepAnimationLocked(mCurrentTime)) &#123; setAnimating(true); &#125; else &#123; mBulkUpdateParams |= SET_UPDATE_ROTATION; screenRotationAnimation.kill(); displayAnimator.mScreenRotationAnimation = null; //TODO (multidisplay): Accessibility supported only for the default display. if (mService.mAccessibilityController != null &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123; // We just finished rotation animation which means we did not // anounce the rotation and waited for it to end, announce now. mService.mAccessibilityController.onRotationChangedLocked( mService.getDefaultDisplayContentLocked(), mService.mRotation); &#125; &#125; &#125; // Update animations of all applications, including those // associated with exiting/removed apps //2ã€çª—å£åŠ¨ç”»çš„æ¨è¿›è¿‡ç¨‹ updateWindowsLocked(displayId); //å£çº¸åŠ¨ç”»çš„æ¨è¿›è¿‡ç¨‹ updateWallpaperLocked(displayId); final WindowList windows = mService.getWindowListLocked(displayId); final int N = windows.size(); //3ã€é€šè¿‡ä¸€ä¸ªforå¾ªç¯æ¥éå†ä¿å­˜åœ¨çª—å£å †æ ˆçš„æ¯ä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œä»¥ä¾¿å¯ä»¥å¯¹ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªçª—å£çš„ç»˜å›¾è¡¨é¢è¿›è¡Œæ›´æ–° //ç¡®å®šè¯¥çª—å£å®é™…è¦æ˜¾ç¤ºçš„å¤§å°ã€ä½ç½®ã€Alphaé€šé“å’Œå˜æ¢çŸ©é˜µç­‰ä¿¡æ¯ for (int j = 0; j &lt; N; j++) &#123; windows.get(j).mWinAnimator.prepareSurfaceLocked(true); &#125; &#125; for (int i = 0; i &lt; numDisplays; i++) &#123; final int displayId = mDisplayContentsAnimators.keyAt(i); testTokenMayBeDrawnLocked(displayId); final ScreenRotationAnimation screenRotationAnimation = mDisplayContentsAnimators.valueAt(i).mScreenRotationAnimation; if (screenRotationAnimation != null) &#123; screenRotationAnimation.updateSurfacesInTransaction(); &#125; orAnimating(mService.getDisplayContentLocked(displayId).animateDimLayers()); orAnimating(mService.getDisplayContentLocked(displayId).getDockedDividerController() .animate(mCurrentTime)); //TODO (multidisplay): Magnification is supported only for the default display. if (mService.mAccessibilityController != null &amp;&amp; displayId == Display.DEFAULT_DISPLAY) &#123; mService.mAccessibilityController.drawMagnifiedRegionBorderIfNeededLocked(); &#125; &#125; ...... //4ã€è§¦å‘ä¸‹ä¸€å¸§åŠ¨ç”»é€»è¾‘ if (mAnimating) &#123; mService.scheduleAnimationLocked(); &#125; if (mService.mWatermark != null) &#123; mService.mWatermark.drawIfNeeded(); &#125; &#125; catch (RuntimeException e) &#123; ...... &#125; finally &#123; SurfaceControl.closeTransaction(); if (SHOW_TRANSACTIONS) Slog.i( TAG, \"&lt;&lt;&lt; CLOSE TRANSACTION animateLocked\"); &#125; boolean hasPendingLayoutChanges = false; final int numDisplays = mService.mDisplayContents.size(); for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; final DisplayContent displayContent = mService.mDisplayContents.valueAt(displayNdx); final int pendingChanges = getPendingLayoutChanges(displayContent.getDisplayId()); if ((pendingChanges &amp; WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER) != 0) &#123; mBulkUpdateParams |= SET_WALLPAPER_ACTION_PENDING; &#125; if (pendingChanges != 0) &#123; hasPendingLayoutChanges = true; &#125; &#125; boolean doRequest = false; if (mBulkUpdateParams != 0) &#123; doRequest = mWindowPlacerLocked.copyAnimToLayoutParamsLocked(); &#125; //5ã€åˆ·æ–°ç³»ç»ŸUI if (hasPendingLayoutChanges || doRequest) &#123; mWindowPlacerLocked.requestTraversal(); &#125; ...... if (mRemoveReplacedWindows) &#123; removeReplacedWindowsLocked(); &#125; mService.stopUsingSavedSurfaceLocked(); mService.destroyPreservedSurfaceLocked(); mService.mWindowPlacerLocked.destroyPendingSurfaces(); ......&#125; 1ã€Activityç»„ä»¶åˆ‡æ¢åŠ¨ç”»çš„æ¨è¿›ã€ 2ã€çª—å£åŠ¨ç”»çš„æ¨è¿›ã€å£çº¸åŠ¨ç”»æ¨è¿› 3ã€å¾ªç¯éå†ä¿å­˜åœ¨çª—å£å †æ ˆçš„æ¯ä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œä»¥ä¾¿å¯ä»¥å¯¹ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªçª—å£çš„ç»˜å›¾è¡¨é¢è¿›è¡Œæ›´æ–° ç¡®å®šè¯¥çª—å£å®é™…è¦æ˜¾ç¤ºçš„å¤§å°ã€ä½ç½®ã€Alphaé€šé“å’Œå˜æ¢çŸ©é˜µç­‰ä¿¡æ¯ 4ã€è§¦å‘ä¸‹ä¸€å¸§åŠ¨ç”»é€»è¾‘ 5ã€åˆ·æ–°ç³»ç»ŸUI å…¶ä¸­ç¬¬3ç‚¹ prepareSurfaceLockedåœ¨3.3.å°èŠ‚å·²ç»åˆ†æè¿‡äº†ã€ç¬¬5ç‚¹æœ€ç»ˆä¼šè°ƒç”¨mWindowPlacerLocked.performSurfacePlacementæ¥åˆ·æ–°UIï¼Œä¹Ÿå·²ç»åˆ†æè¿‡äº†ã€‚ æ¥ä¸‹æ¥åˆ†æActivityç»„ä»¶åˆ‡æ¢åŠ¨ç”»ã€çª—å£åŠ¨ç”»çš„æ¨è¿›è¿‡ç¨‹ã€‚ 6.3ã€Activityç»„ä»¶åˆ‡æ¢åŠ¨ç”»AppWindowAnimator:å±äºAppWindowTokenï¼Œå®ƒçš„æˆå‘˜å˜é‡mAppAnimatorä»£è¡¨äº†æ­¤åº”ç”¨ç¨‹åºæ‰€å±çš„AppWindowAnimator WindowStateAnimator:WMSè®°å½•äº†æ‰€æœ‰çª—å£çš„WindowStateï¼Œå…¶ä¸­WindowState.mWinAnimatoræ˜¯ä¸€ä¸ªWindowStateAnimatorå¯¹è±¡ï¼Œå®ƒå’Œä¸Šé¢AppWindowAnimatorä¸€æ ·å¯ä»¥ç”±å¼€å‘äººå‘˜å®šåˆ¶ WindowAnimator.updateAppWindowsLocked() 123456789101112131415161718192021222324[-&gt;WindowAnimator.java]private void updateAppWindowsLocked(int displayId) &#123; ArrayList&lt;TaskStack&gt; stacks = mService.getDisplayContentLocked(displayId).getStacks(); for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final TaskStack stack = stacks.get(stackNdx); final ArrayList&lt;Task&gt; tasks = stack.getTasks(); for (int taskNdx = tasks.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; final AppTokenList tokens = tasks.get(taskNdx).mAppTokens; for (int tokenNdx = tokens.size() - 1; tokenNdx &gt;= 0; --tokenNdx) &#123; final AppWindowAnimator appAnimator = tokens.get(tokenNdx).mAppAnimator; appAnimator.wasAnimating = appAnimator.animating; if (appAnimator.stepAnimationLocked(mCurrentTime, displayId)) &#123; appAnimator.animating = true; setAnimating(true); mAppWindowAnimating = true; &#125; else if (appAnimator.wasAnimating) &#123; // stopped animating, do one more pass through the layout setAppLayoutChanges(appAnimator, WindowManagerPolicy.FINISH_LAYOUT_REDO_WALLPAPER, \"appToken \" + appAnimator.mAppToken + \" done\", displayId); ...... &#125; &#125; &#125; è°ƒç”¨stepAnimationLocked() 12345678910111213141516171819202122232425[-&gt;AppWindowAnimator.java] // This must be called while inside a transaction. boolean stepAnimationLocked(long currentTime, final int displayId) &#123; if (mService.okToDisplay()) &#123; ...... if ((mAppToken.allDrawn || animating || mAppToken.startingDisplayed) &amp;&amp; animation != null) &#123; ...... if (stepAnimation(currentTime)) &#123; // animation isn't over, step any thumbnail and that's // it for now. if (thumbnail != null) &#123; stepThumbnailAnimation(currentTime); &#125; return true; &#125; &#125; &#125; else if (animation != null) &#123; animating = true; animation = null; &#125; ...... &#125;&#125; è°ƒç”¨stepAnimation() 123456789101112131415161718192021222324252627[-&gt;AppWindowAnimator.java]private boolean stepAnimation(long currentTime) &#123; if (animation == null) &#123; return false; &#125; //1. transformation.clear(); final long animationFrameTime = getAnimationFrameTime(animation, currentTime); //2. boolean hasMoreFrames = animation.getTransformation(animationFrameTime, transformation); if (!hasMoreFrames) &#123; if (deferThumbnailDestruction &amp;&amp; !deferFinalFrameCleanup) &#123; deferFinalFrameCleanup = true; hasMoreFrames = true; &#125; else &#123; deferFinalFrameCleanup = false; if (mProlongAnimation == PROLONG_ANIMATION_AT_END) &#123; hasMoreFrames = true; &#125; else &#123; setNullAnimation(); clearThumbnail(); &#125; &#125; &#125; hasTransformation = hasMoreFrames; return hasMoreFrames;&#125; 1.å°†æˆå‘˜å˜é‡transformationæ‰€æè¿°çš„å˜æ¢çŸ©é˜µçš„æ•°æ®æ¸…ç©º 2.è°ƒç”¨Animation.getTransformation()æ¥è®¡ç®—Activityç»„ä»¶åˆ‡æ¢åŠ¨ç”»ä¸‹ä¸€æ­¥æ‰€å¯¹åº”çš„å˜æ¢çŸ©é˜µï¼Œå¹¶ä¸”å°†è¿™ä¸ªå˜æ¢çŸ©é˜µçš„æ•°æ®ä¿å­˜åœ¨æˆå‘˜å˜é‡transformation 6.4ã€çª—å£åŠ¨ç”»çš„æ¨è¿›è¿‡ç¨‹ç»§ç»­åˆ†æWindowAnimator.animateLocked()çš„updateWindowsLocked() 6.4.1ã€WindowAnimator.updateWindowsLocked()1234567891011121314151617181920212223[-&gt;WindowAnimator.java]private void updateWindowsLocked(final int displayId) &#123; ++mAnimTransactionSequence; final WindowList windows = mService.getWindowListLocked(displayId); ...... for (int i = windows.size() - 1; i &gt;= 0; i--) &#123; WindowState win = windows.get(i); WindowStateAnimator winAnimator = win.mWinAnimator; final int flags = win.mAttrs.flags; boolean canBeForceHidden = mPolicy.canBeForceHidden(win, win.mAttrs); boolean shouldBeForceHidden = shouldForceHide(win); if (winAnimator.hasSurface()) &#123; final boolean wasAnimating = winAnimator.mWasAnimating; final boolean nowAnimating = winAnimator.stepAnimationLocked(mCurrentTime); winAnimator.mWasAnimating = nowAnimating; orAnimating(nowAnimating); &#125; &#125; ...... &#125; ......&#125; WindowStateAnimator.stepAnimationLocked() å¦‚æœçª—å£çš„åŠ¨ç”»å°šæœªç»“æŸæ˜¾ç¤ºï¼Œé‚£ä¹ˆstepAnimationLocked()ä¼šè¿”å›ä¸€ä¸ªtrueå€¼ç»™è°ƒç”¨è€…ï¼Œå¦åˆ™çš„è¯ï¼Œå°±ä¼šè¿”å›ä¸€ä¸ªfalseå€¼ç»™è°ƒç”¨è€… 12345678910111213141516171819202122232425262728293031323334353637383940[-&gt;WindowStateAnimator.java] boolean stepAnimationLocked(long currentTime) &#123; // Save the animation state as it was before this step so WindowManagerService can tell if // we just started or just stopped animating by comparing mWasAnimating with isAnimationSet(). mWasAnimating = mAnimating; final DisplayContent displayContent = mWin.getDisplayContent(); if (displayContent != null &amp;&amp; mService.okToDisplay()) &#123; // We will run animations as long as the display isn't frozen. if (mWin.isDrawnLw() &amp;&amp; mAnimation != null) &#123; mHasTransformation = true; mHasLocalTransformation = true; if (!mLocalAnimating) &#123; final DisplayInfo displayInfo = displayContent.getDisplayInfo(); if (mAnimateMove) &#123; mAnimateMove = false; mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(), mAnimDx, mAnimDy); &#125; else &#123; mAnimation.initialize(mWin.mFrame.width(), mWin.mFrame.height(), displayInfo.appWidth, displayInfo.appHeight); &#125; mAnimDx = displayInfo.appWidth; mAnimDy = displayInfo.appHeight; mAnimation.setStartTime(mAnimationStartTime != -1 ? mAnimationStartTime : currentTime); mLocalAnimating = true; mAnimating = true; &#125; if ((mAnimation != null) &amp;&amp; mLocalAnimating) &#123; mLastAnimationTime = currentTime; if (stepAnimation(currentTime)) &#123; return true; &#125; &#125; ...... &#125; ...... return false; &#125; 12345678910111213[-&gt;WindowStateAnimator.java]private boolean stepAnimation(long currentTime) &#123; ...... currentTime = getAnimationFrameTime(mAnimation, currentTime); //1. mTransformation.clear(); //2. final boolean more = mAnimation.getTransformation(currentTime, mTransformation); if (mAnimationStartDelayed &amp;&amp; mAnimationIsEntrance) &#123; mTransformation.setAlpha(0f); &#125; return more;&#125; 1ã€å°†æˆå‘˜å˜é‡mTransformationæ‰€æè¿°çš„å˜æ¢çŸ©é˜µçš„æ•°æ®æ¸…ç©ºã€‚ 2ã€è°ƒç”¨mAnimation.getTransformation()æ¥è®¡ç®—çª—å£åŠ¨ç”»ä¸‹ä¸€æ­¥æ‰€å¯¹åº”çš„å˜æ¢çŸ©é˜µï¼Œå¹¶ä¸”å°†è¿™ä¸ªå˜æ¢çŸ©é˜µçš„æ•°æ®ä¿å­˜åœ¨æˆå‘˜å˜é‡mTransformationã€‚ ç„¶åå°±æ˜¯åŠ¨ç”»è¿‡åï¼Œçª—å£å¤§å°è®¡ç®—ã€æ¸²æŸ“åˆæˆç­‰ç­‰æ˜¾ç¤ºæ­¥éª¤äº†ï¼Œç”±äºä¹‹å‰å·²ç»åˆ†æè¿‡äº†ï¼Œä¸å†åˆ†æäº†ï¼š 3ã€å¾ªç¯éå†ä¿å­˜åœ¨çª—å£å †æ ˆçš„æ¯ä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œä»¥ä¾¿å¯ä»¥å¯¹ç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªçª—å£çš„ç»˜å›¾è¡¨é¢è¿›è¡Œæ›´æ–° ç¡®å®šè¯¥çª—å£å®é™…è¦æ˜¾ç¤ºçš„å¤§å°ã€ä½ç½®ã€Alphaé€šé“å’Œå˜æ¢çŸ©é˜µç­‰ä¿¡æ¯ 12345[-&gt;WindowAnimator.java::animateLocked()]//ç¡®å®šè¯¥çª—å£å®é™…è¦æ˜¾ç¤ºçš„å¤§å°ã€ä½ç½®ã€Alphaé€šé“å’Œå˜æ¢çŸ©é˜µç­‰ä¿¡æ¯for (int j = 0; j &lt; N; j++) &#123; windows.get(j).mWinAnimator.prepareSurfaceLocked(true);&#125; 4ã€è§¦å‘ä¸‹ä¸€å¸§åŠ¨ç”»é€»è¾‘ 1234[-&gt;WindowAnimator.java::animateLocked()]if (mAnimating) &#123; mService.scheduleAnimationLocked();&#125; 5ã€åˆ·æ–°ç³»ç»ŸUI 1234[-&gt;WindowAnimator.java::animateLocked()]if (hasPendingLayoutChanges || doRequest) &#123; mWindowPlacerLocked.requestTraversal();&#125; æœ€ç»ˆç»è¿‡SurfaceFlingeråˆæˆæ˜¾ç¤ºåˆ°å±å¹•ä¸Šã€‚ æ€»ä½“æµç¨‹å›¾(â€¦)ï¼š ï¼ˆä¸ƒï¼‰ã€å‚è€ƒæ–‡æ¡£(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šæµ…æ Android çš„çª—å£WMS:çª—å£å¤§å°çš„è®¡ç®—Android çª—å£çš„è®¡ç®—è¿‡ç¨‹Android Window æœºåˆ¶æ¢ç´¢Android çª—å£ç®¡ç† - ä¸”å¬é£åŸAndroid å…³äºWindow OverscanWindowManagerServiceåŠ¨ç”»åˆ†ææ·±å…¥ç†è§£Activityâ€”-Tokenä¹‹æ—… - CSDNåšå®¢Android 4.4(KitKat)çª—å£ç®¡ç†å­ç³»ç»Ÿ - ä½“ç³»æ¡†æ¶Androidçª—å£ç³»ç»Ÿç¬¬å››ç¯‡â€”ActivityåŠ¨ç”»çš„è®¾ç½®è¿‡ç¨‹Android 7.1 GUIç³»ç»Ÿ-çª—å£ç®¡ç†WMS-Surfaceç®¡ç†ï¼ˆå››ï¼‰Android çš„çª—å£ç®¡ç†ç³»ç»Ÿ (View, Canvas, WindowManager)WMSâ€“å¯åŠ¨çª—å£(StartingWindow) - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢Viewç»˜åˆ¶æµç¨‹åŠæºç è§£æ(ä¸€)â€”-performTraversals()æºç åˆ†æAndroidçª—å£ç³»ç»Ÿç¬¬ä¸‰ç¯‡â€”WindowManagerServiceä¸­çª—å£çš„ç»„ç»‡æ–¹å¼google è¿›å…¥åˆ†å±ååœ¨æ¨ªå±æ¨¡å¼æŒ‰ home é”®ç•Œé¢é”™ä¹± (äºŒ) - Android - æ˜é‡‘Androidåº”ç”¨Activityã€Dialogã€PopWindowã€Toastçª—å£æ·»åŠ æœºåˆ¶åŠæºç åˆ†æAndroidçª—å£ç®¡ç†æœåŠ¡WindowManagerServiceçš„ç®€è¦ä»‹ç»å’Œå­¦ä¹ è®¡åˆ’ - CSDNåšå®¢Androidçª—å£ç®¡ç†åˆ†æï¼ˆ2ï¼‰ï¼šWindowManagerServiceçª—å£ç®¡ç†ä¹‹Windowæ·»åŠ æµç¨‹Androidçª—å£ç®¡ç†æœåŠ¡WindowManagerServiceæ˜¾ç¤ºçª—å£åŠ¨ç”»çš„åŸç†åˆ†æ - CSDNåšå®¢Android6.0 WMSï¼ˆäº”ï¼‰ WMSè®¡ç®—Activityçª—å£å¤§å°çš„è¿‡ç¨‹åˆ†æï¼ˆäºŒï¼‰WMSçš„relayoutWindow","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android Graphics ç³»ç»Ÿ åˆ†æ [i.wonder~]","slug":"Android-7-1-2-Android-N-Android-Graphics-ç³»ç»Ÿåˆ†æ","date":"2018-01-31T16:00:00.000Z","updated":"2018-04-19T14:30:01.581Z","comments":true,"path":"2018/02/01/Android-7-1-2-Android-N-Android-Graphics-ç³»ç»Ÿåˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-ç³»ç»Ÿåˆ†æ/","excerpt":"Androidç³»ç»Ÿå›¾å½¢æ¡†æ¶ç”±ä¸‹å¾€ä¸Šä¸»è¦çš„åŒ…æ‹¬HAL(HWComposerå’ŒGrallocä¸¤ä¸ªmoudle)ï¼ŒSurfaceFlingerï¼ˆBufferQueueçš„æ¶ˆè´¹è€…ï¼‰ï¼ŒWindowManagerServiceï¼ˆçª—å£ç®¡ç†è€…ï¼‰ï¼ŒViewï¼ˆBufferQueueçš„ç”Ÿäº§è€…ï¼‰å››å¤§æ¨¡å—ã€‚â— HAL: åŒ…æ‹¬HWComposerå’ŒGrallocä¸¤ä¸ªmoudleï¼ŒAndroid Nä¸Šç”±SurfaceFlingeræ‰“å¼€ï¼Œå› æ­¤åœ¨åŒä¸€è¿›ç¨‹ã€‚ gralloc ç”¨äºBufferQueueçš„å†…å­˜åˆ†é…ï¼ŒåŒæ—¶ä¹Ÿæœ‰fbçš„æ˜¾ç¤ºæ¥å£ï¼ŒHWComposerä½œä¸ºåˆæˆSurfaceFlingeré‡Œé¢çš„Layerï¼Œå¹¶æ˜¾ç¤ºï¼ˆé€šè¿‡grallocçš„postå‡½æ•°ï¼‰â— SurfaceFlingerå¯ä»¥å«åšLayerFlingerï¼Œä½œä¸ºLayerçš„ç®¡ç†è€…ï¼ŒåŒæ˜¯ä¹Ÿæ˜¯BufferQueueçš„æ¶ˆè´¹è€…ï¼Œå½“æ¯ä¸ªLayerçš„ç”Ÿäº§è€…drawå®Œå®Œæ•´çš„ä¸€å¸§æ—¶ï¼Œä¼šé€šçŸ¥SurfaceFlingerï¼Œé€šçŸ¥çš„æ–¹å¼é‡‡ç”¨BufferQueueã€‚â— WindowManagerService: ä½œä¸ºWindowçš„ç®¡ç†è€…ï¼ŒæŒç®¡ç€è®¡ç®—çª—å£å¤§å°ï¼Œçª—å£åˆ‡æ¢ç­‰ä»»åŠ¡ï¼ŒåŒæ—¶ä¹Ÿä¼šå°†ç›¸åº”çš„å‚æ•°è®¾ç½®ç»™SurfaceFlingerï¼Œæ¯”å¦‚Windowçš„åœ¨z-orderï¼Œå’Œçª—å£çš„å¤§å°ã€‚â— View: ä½œä¸ºBufferQueueçš„ç”Ÿäº§è€…ï¼Œæ¯å½“æ‰§è¡ŒlockCanvas-&gt;draw-&gt;unlockCanvasï¼Œä¹‹åä¼šå­˜å…¥ä¸€å¸§æ•°æ®è¿›å…¥BufferQueueä¸­ã€‚ å˜¿å˜¿(^â–½^),ä½†è¿™ä¹Ÿæ˜¯æ— å¯å¥ˆä½•çš„äº‹æƒ…ï¼Œæ¯•ç«Ÿä¸–ä¸Šä¸å¯èƒ½æœ‰é‚£ä¹ˆå¤šåå…¨åç¾çš„å¥½äº‹ï¼Œåšäººåœ¨æŸäº›æ—¶å€™æ€»æ˜¯è¦æœ‰äº›å–èˆçš„ã€‚","text":"Androidç³»ç»Ÿå›¾å½¢æ¡†æ¶ç”±ä¸‹å¾€ä¸Šä¸»è¦çš„åŒ…æ‹¬HAL(HWComposerå’ŒGrallocä¸¤ä¸ªmoudle)ï¼ŒSurfaceFlingerï¼ˆBufferQueueçš„æ¶ˆè´¹è€…ï¼‰ï¼ŒWindowManagerServiceï¼ˆçª—å£ç®¡ç†è€…ï¼‰ï¼ŒViewï¼ˆBufferQueueçš„ç”Ÿäº§è€…ï¼‰å››å¤§æ¨¡å—ã€‚â— HAL: åŒ…æ‹¬HWComposerå’ŒGrallocä¸¤ä¸ªmoudleï¼ŒAndroid Nä¸Šç”±SurfaceFlingeræ‰“å¼€ï¼Œå› æ­¤åœ¨åŒä¸€è¿›ç¨‹ã€‚ gralloc ç”¨äºBufferQueueçš„å†…å­˜åˆ†é…ï¼ŒåŒæ—¶ä¹Ÿæœ‰fbçš„æ˜¾ç¤ºæ¥å£ï¼ŒHWComposerä½œä¸ºåˆæˆSurfaceFlingeré‡Œé¢çš„Layerï¼Œå¹¶æ˜¾ç¤ºï¼ˆé€šè¿‡grallocçš„postå‡½æ•°ï¼‰â— SurfaceFlingerå¯ä»¥å«åšLayerFlingerï¼Œä½œä¸ºLayerçš„ç®¡ç†è€…ï¼ŒåŒæ˜¯ä¹Ÿæ˜¯BufferQueueçš„æ¶ˆè´¹è€…ï¼Œå½“æ¯ä¸ªLayerçš„ç”Ÿäº§è€…drawå®Œå®Œæ•´çš„ä¸€å¸§æ—¶ï¼Œä¼šé€šçŸ¥SurfaceFlingerï¼Œé€šçŸ¥çš„æ–¹å¼é‡‡ç”¨BufferQueueã€‚â— WindowManagerService: ä½œä¸ºWindowçš„ç®¡ç†è€…ï¼ŒæŒç®¡ç€è®¡ç®—çª—å£å¤§å°ï¼Œçª—å£åˆ‡æ¢ç­‰ä»»åŠ¡ï¼ŒåŒæ—¶ä¹Ÿä¼šå°†ç›¸åº”çš„å‚æ•°è®¾ç½®ç»™SurfaceFlingerï¼Œæ¯”å¦‚Windowçš„åœ¨z-orderï¼Œå’Œçª—å£çš„å¤§å°ã€‚â— View: ä½œä¸ºBufferQueueçš„ç”Ÿäº§è€…ï¼Œæ¯å½“æ‰§è¡ŒlockCanvas-&gt;draw-&gt;unlockCanvasï¼Œä¹‹åä¼šå­˜å…¥ä¸€å¸§æ•°æ®è¿›å…¥BufferQueueä¸­ã€‚ å˜¿å˜¿(^â–½^),ä½†è¿™ä¹Ÿæ˜¯æ— å¯å¥ˆä½•çš„äº‹æƒ…ï¼Œæ¯•ç«Ÿä¸–ä¸Šä¸å¯èƒ½æœ‰é‚£ä¹ˆå¤šåå…¨åç¾çš„å¥½äº‹ï¼Œåšäººåœ¨æŸäº›æ—¶å€™æ€»æ˜¯è¦æœ‰äº›å–èˆçš„ã€‚ ã€åšå®¢åŸå›¾é“¾æ¥ã€‘æºç ï¼ˆéƒ¨åˆ†ï¼‰ï¼š/frameworks/native/services/surfaceflinger/ tests/Transaction_test.cpp tests/vsync/vsync.cpp /frameworks/native/include/gui/ BitTube.h BufferSlot.h BufferQueueCore.h BufferQueueProducer.h /frameworks/base/core/java/android/app/ Activity.java ActivityThread.java Instrumentation.java /frameworks/base/core/jni/ android_view_DisplayEventReceiver.cpp android_view_SurfaceControl.cpp android_view_Surface.cpp android_view_SurfaceSession.cpp /frameworks/native/include/gui/ SurfaceComposerClient.h IDisplayEventConnection.h SurfaceComposerClient.h /frameworks/native/services/surfaceflinger/ SurfaceFlinger.cpp Client.cpp main_surfaceflinger.cpp DisplayDevice.cpp DispSync.cpp EventControlThread.cpp EventThread.cpp Layer.cpp MonitoredProducer.cpp /frameworks/base/core/java/android/view/ WindowManagerImpl.java ViewManager.java WindowManagerGlobal.java ViewRootImpl.java Choreographer.java IWindowSession.aidl DisplayEventReceiver.java SurfaceControl.java Surface.java SurfaceSession.java /frameworks/native/include/ui/ GraphicBuffer.h GraphicBufferAllocator.h /frameworks/base/services/core/java/com/android/server/wm/ WindowManagerService.java Session.java WindowState.java WindowStateAnimator.java WindowSurfaceController.java ã€åšå®¢åŸå›¾é“¾æ¥ã€‘ï¼ˆä¸€ï¼‰ã€Android Graphics ç³»ç»Ÿæ¡†æ¶ï¼ˆè¯•ç”¨é™åˆ¶ï¼Ÿï¼Ÿï¼Ÿä¸‡æ¶çš„äº¿å›¾(EDraw)å¼ºåŠ æ°´å°~ç«~ï¼‰ App åŸºäºAndroidç³»ç»Ÿçš„GUIæ¡†æ¶å¼€å‘å®Œæ•´çš„Apkåº”ç”¨ã€‚ Android Graphics Stack Client(SurfaceFlinger Client)Androidåœ¨å®¢æˆ·ç«¯çš„ç»˜å›¾å †æ ˆé€šå¸¸åŒ…æ‹¬ï¼š OpenGL ESï¼šä½¿ç”¨GPUè¿›è¡Œ3Då’Œ2Dçš„ç»˜å›¾çš„API EGLï¼šè¡”æ¥GLESå’Œç³»ç»Ÿçš„Native Windowç³»ç»Ÿçš„é€‚é…å±‚ Vulkanï¼šVulkanä¸ºKhronos Groupæ¨å‡ºçš„ä¸‹ä¸€ä»£è·¨å¹³å°å›¾å½¢å¼€å‘æ¥å£ï¼Œç”¨äºæ›¿ä»£å†å²æ‚ ä¹…çš„OpenGLã€‚Androidä»7.0(Nougat)å¼€å§‹åŠ å…¥äº†å¯¹å…¶çš„æ”¯æŒã€‚Vulkanä¸OpenGLç›¸æ¯”ï¼Œæ¥å£æ›´åº•å±‚ï¼Œä»è€Œä½¿å¼€å‘è€…èƒ½æ›´ç›´æ¥åœ°æ§åˆ¶GPUã€‚ç”±äºæ›´å¥½çš„å¹¶è¡Œæ”¯æŒï¼ŒåŠæ›´å°çš„å¼€é”€ï¼Œæ€§èƒ½ä¸Šä¹Ÿæœ‰ä¸€å®šçš„æå‡ã€‚Android Graphics Stack Serverï¼ˆSurfaceFlinger Serverï¼‰SurfaceFlingeræ˜¯Androidç”¨äºç®¡ç†Displayå’Œè´Ÿè´£Window Compositeï¼ˆçª—å£æ··åˆï¼‰ï¼ŒæŠŠåº”ç”¨çš„æ˜¾ç¤ºçª—å£è¾“å‡ºåˆ°Displayçš„ç³»ç»ŸæœåŠ¡ã€‚ Android Driversï¼ˆHALï¼‰Androidçš„é©±åŠ¨å±‚ï¼Œé€šè¿‡Androidæœ¬èº«çš„HALï¼ˆç¡¬ä»¶æŠ½è±¡å±‚ï¼‰æœºåˆ¶ï¼Œè¿è¡ŒäºUser Spaceï¼Œè·Ÿæ¸²æŸ“ç›¸å…³çš„åŒ…æ‹¬ï¼š Hwcomposerï¼šå¦‚æœç¡¬ä»¶æ”¯æŒï¼ŒSurfaceFlingerå¯ä»¥è¯·æ±‚hwcomposerå»åšçª—å£æ··åˆè€Œä¸éœ€è¦è‡ªå·±æ¥åšï¼Œè¿™æ ·çš„æ•ˆç‡ä¹Ÿä¼šæ›´é«˜ï¼Œå‡å°‘å¯¹GPUèµ„æºçš„å ç”¨ Grallocï¼šç”¨æ¥ç®¡ç†Graphics Bufferçš„åˆ†é…å’Œç®¡ç†ç³»ç»Ÿçš„framebuffer OpenGL ES/EGL Linux Kernel and Driversé™¤äº†æ ‡å‡†çš„Linuxå†…æ ¸å’Œé©±åŠ¨ï¼ˆä¾‹å¦‚fbæ˜¯framebufferé©±åŠ¨ï¼‰ï¼Œç¡¬ä»¶å‚å•†è‡ªå·±çš„é©±åŠ¨å¤–ï¼ŒAndroidè‡ªå·±çš„ä¸€äº›Patchesï¼š Ashmemï¼šå¼‚æ­¥å…±äº«å†…å­˜ï¼Œç”¨äºåœ¨è¿›ç¨‹é—´å…±äº«ä¸€å—å†…å­˜åŒºåŸŸï¼Œå¹¶å…è®¸ç³»ç»Ÿåœ¨èµ„æºç´§å¼ æ—¶å›æ”¶ä¸åŠ é”çš„å†…å­˜å— IONï¼šå†…å­˜ç®¡ç†å™¨ IONæ˜¯googleåœ¨Android4.0 ä¸ºäº†è§£å†³å†…å­˜ç¢ç‰‡ç®¡ç†è€Œå¼•å…¥çš„é€šç”¨å†…å­˜ç®¡ç†å™¨,åœ¨é¢å‘ç¨‹åºå‘˜ç¼–ç¨‹æ–¹é¢ï¼Œå®ƒå’Œashmemå¾ˆç›¸ä¼¼ã€‚ä½†IONæ¯”ashmemæ›´å¼ºå¤§ Binderï¼šé«˜æ•ˆçš„è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶ Vsyncï¼šAndroid 4.1å¼•å…¥äº†Vsync(Vertical Syncronization)ç”¨äºæ¸²æŸ“åŒæ­¥ï¼Œä½¿å¾—App UIå’ŒSurfaceFlingerå¯ä»¥æŒ‰ç¡¬ä»¶äº§ç”Ÿçš„VSyncèŠ‚å¥æ¥è¿›è¡Œå·¥ä½œ Hardware Displayï¼ˆæ˜¾ç¤ºå™¨ï¼‰ã€CPUã€GPUã€VPUï¼ˆVideo Process Unitï¼‰ã€å’Œå†…å­˜ç­‰ç­‰ ï¼ˆäºŒï¼‰ã€Android Graphics æµ‹è¯•ç¨‹åºï¼ˆC++ï¼‰ä¸ºäº†ä¾¿äºè§‚å¯Ÿå¯¹åŸç”Ÿæµ‹è¯•ç¨‹åºæ˜¾ç¤ºå›¾åƒå¤§å°åšäº†å¦‚ä¸‹ä¿®æ”¹ï¼š frameworks/native/services/surfaceflinger/tests/Transaction_test.cpp Disable_HWUI_GPU_HWC.patch åŸç”ŸSurfaceFlingeræµ‹è¯•ç¨‹åºç¼–è¯‘ï¼š1ã€ç¼–è¯‘Android 7.1.2æºç -userdebugç‰ˆæœ¬ï¼Œçƒ§å½•é‡å¯2ã€ç¼–è¯‘/frameworks/native/services/surfaceflinger/tests/ä¼šç”ŸæˆSurfaceFlinger_test3ã€è¿æ¥æ‰‹æœºæ‰§è¡Œå‘½ä»¤ adb rootã€adb remountã€adb push SurfaceFlinger_test /system/bin/4ã€adb shell setenforce 0(æš‚æ—¶å…³é—­SELinuxæƒé™)5ã€adb shellã€cd system/bin/ã€chmod 0777 SurfaceFlinger_test6ã€è¿è¡Œæµ‹è¯•ç¨‹åºï¼š./SurfaceFlinger_test å¯ä»¥çœ‹åˆ°åœ¨Android æ˜¾ç¤ºå±æ¥æ›¿ç»˜åˆ¶äº†å¤šä¸ªå›¾åƒï¼Œå¹¶ä¸”ä¼šå˜æ¢å½¢çŠ¶ã€ä½ç½®ã€é¢œè‰²ã€é€æ˜åº¦ç­‰ã€‚ æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ä¸»è¦æ­¥éª¤ï¼š 1ã€ åˆ›å»ºSurfaceComposerClient 12sp&lt;SurfaceComposerClient&gt; mComposerClient;mComposerClient = new SurfaceComposerClient; 2ã€ å®¢æˆ·ç«¯SurfaceComposerClientè¯·æ±‚SurfaceFlingeråˆ›å»ºSurface æ³¨ï¼šAppç«¯å¯¹åº”SurfaceControl&lt;â€”&gt;SurfaceFlingerå¯¹åº”Layer 12345678sp&lt;SurfaceControl&gt; mBGSurfaceControl;sp&lt;SurfaceControl&gt; mFGSurfaceControl; // Background surfacemBGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"BG Test Surface\"), displayWidth, displayHeight, PIXEL_FORMAT_RGBA_8888, 0);fillSurfaceRGBA8(mBGSurfaceControl, 63, 63, 195); 1234// Foreground surfacemFGSurfaceControl = mComposerClient-&gt;createSurface( String8(\"FG Test Surface\"), 64, 64, PIXEL_FORMAT_RGBA_8888, 0);fillSurfaceRGBA8(mFGSurfaceControl, 195, 63, 63); 3ã€å¤„ç†äº‹åŠ¡ï¼Œå°†SurfaceControlï¼ˆAppï¼‰çš„å˜åŒ–æ›´æ–°åˆ°Layerï¼ˆSurfaceFlingerï¼‰å›¾å±‚ 123456789101112SurfaceComposerClient::openGlobalTransaction(); mComposerClient-&gt;setDisplayLayerStack(display, 0); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX-2)); ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show()); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX-1)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(64, 64)); ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show()); SurfaceComposerClient::closeGlobalTransaction(true); 4ã€æ¥å—VsyncåŒæ­¥ä¿¡å·ï¼Œæ¸²æŸ“åˆæˆï¼Œæ¨é€åˆ°æ˜¾ç¤ºå±æ˜¾ç¤º æ¥ä¸‹æ¥å¼€å§‹Android Graphicsç³»ç»Ÿç¥ç§˜æ¢ç´¢ä¹‹è°œã€‚ ï¼ˆä¸‰ï¼‰ã€Android Graphics ç¦ç”¨hwcå’ŒGPU3.1ã€Disable_HWUI_GPU_HWCæ³¨ï¼šåŸºäºAndroid 7.1.2 Qualcomm MSM89XXæºç ï¼Œç”±äºä»£ç æ®µè¾ƒé•¿ï¼Œå·²æ”¾åˆ°GitHub Disable_HWUI_GPU_HWC.patch ç¼–è¯‘userdebugç‰ˆæœ¬ï¼Œçƒ§å½•å¼€æœº: è¿è¡Œæµ‹è¯•ç¨‹åºï¼š./SurfaceFlinger_test ç»“æœè·Ÿä¸Šè¿°ä¸€è‡´ï¼Œè¿™é‡Œä¸å†è´´å›¾äº†ã€‚ 3.2ã€Vsyncæµ‹è¯•ç¨‹åºVsync(Vertical Syncronization)ç”¨äºæ¸²æŸ“åŒæ­¥ï¼Œä½¿å¾—App UIå’ŒSurfaceFlingerå¯ä»¥æŒ‰ç¡¬ä»¶äº§ç”Ÿçš„VSyncèŠ‚å¥æ¥è¿›è¡Œå·¥ä½œã€‚ æŸ¥çœ‹frameworks/native/services/surfaceflinger/tests/ä¸‹è¿˜æœ‰vsyncæµ‹è¯•ç¨‹åº 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;android/looper.h&gt;#include &lt;gui/DisplayEventReceiver.h&gt;#include &lt;utils/Looper.h&gt;using namespace android;int receiver(int fd, int events, void* data)&#123; DisplayEventReceiver* q = (DisplayEventReceiver*)data; ssize_t n; DisplayEventReceiver::Event buffer[1]; static nsecs_t oldTimeStamp = 0; while ((n = q-&gt;getEvents(buffer, 1)) &gt; 0) &#123; for (int i=0 ; i&lt;n ; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; printf(\"event vsync: count=%d\\t\", buffer[i].vsync.count); &#125; if (oldTimeStamp) &#123; float t = float(buffer[i].header.timestamp - oldTimeStamp) / s2ns(1); printf(\"%f ms (%f Hz)\\n\", t*1000, 1.0/t); &#125; oldTimeStamp = buffer[i].header.timestamp; &#125; &#125; if (n&lt;0) &#123;printf(\"error reading events (%s)\\n\", strerror(-n));&#125; return 1;&#125;int main(int argc, char** argv)&#123; DisplayEventReceiver myDisplayEvent; sp&lt;Looper&gt; loop = new Looper(false); loop-&gt;addFd(myDisplayEvent.getFd(), 0, ALOOPER_EVENT_INPUT, receiver, &amp;myDisplayEvent); myDisplayEvent.setVsyncRate(1); do &#123; //printf(\"about to poll...\\n\"); int32_t ret = loop-&gt;pollOnce(-1); switch (ret) &#123; case ALOOPER_POLL_WAKE: //(\"ALOOPER_POLL_WAKE\\n\"); break; case ALOOPER_POLL_CALLBACK: //(\"ALOOPER_POLL_CALLBACK\\n\"); break; case ALOOPER_POLL_TIMEOUT: printf(\"ALOOPER_POLL_TIMEOUT\\n\"); break; case ALOOPER_POLL_ERROR: printf(\"ALOOPER_POLL_TIMEOUT\\n\"); break; default: printf(\"ugh? poll returned %d\\n\", ret); break; &#125; &#125; while (1); return 0;&#125; ç¼–è¯‘è¿è¡Œçœ‹çœ‹ï¼šå¯ä»¥çœ‹åˆ°vsyncä¿¡å·æ¯éš”16 msä¸€æ¬¡ï¼Œå…³äºvsyncçŸ¥è¯†ç¨åå†åˆ†æã€‚ 123456event vsync: count=2631 16.168612 ms (61.848231 Hz)event vsync: count=2632 16.168613 ms (61.848224 Hz)event vsync: count=2633 16.168312 ms (61.849378 Hz)event vsync: count=2634 16.168682 ms (61.847961 Hz)event vsync: count=2635 16.168596 ms (61.848288 Hz)event vsync: count=2636 16.168867 ms (61.847255 Hz) ï¼ˆå››ï¼‰ã€Android SurfaceFlinger å†…éƒ¨æœºåˆ¶4.1ã€APPä¸SurfaceFlingerçš„æ•°æ®ç»“æ„ 4.1.1ã€BufferQueueä»‹ç»BufferQueue ç±»æ˜¯ Android ä¸­æ‰€æœ‰å›¾å½¢å¤„ç†æ“ä½œçš„æ ¸å¿ƒã€‚å®ƒçš„æ˜¯å°†ç”Ÿæˆå›¾å½¢æ•°æ®ç¼“å†²åŒºçš„ä¸€æ–¹ï¼ˆç”Ÿäº§è€…Producerï¼‰è¿æ¥åˆ°æ¥å—æ•°æ®ä»¥è¿›è¡Œæ˜¾ç¤ºæˆ–è¿›ä¸€æ­¥å¤„ç†çš„ä¸€æ–¹ï¼ˆæ¶ˆè´¹è€…Consumerï¼‰ã€‚å‡ ä¹æ‰€æœ‰åœ¨ç³»ç»Ÿä¸­ç§»åŠ¨å›¾å½¢æ•°æ®ç¼“å†²åŒºçš„å†…å®¹éƒ½ä¾èµ–äº BufferQueueã€‚ ä»ä¸Šå›¾APPä¸SurfaceFlingeräº¤äº’ä¸­å¯ä»¥çœ‹å‡ºï¼ŒBufferQueueå†…éƒ¨ç»´æŒç€64ä¸ªBufferSlotï¼Œæ¯ä¸€ä¸ªBufferSlotå†…éƒ¨æœ‰ä¸€ä¸ªGraphicBufferæŒ‡å‘åˆ†é…çš„Graphic Bufferã€‚å…ˆæ¥çœ‹ä¸€ä¸‹å›¾ä¸­å‡ ä¸ªçŠ¶æ€ä»£è¡¨çš„å«ä¹‰ï¼š 1234567891011frameworks/native/include/gui/BufferSlot.h// A buffer can be in one of five states, represented as below://// | mShared | mDequeueCount | mQueueCount | mAcquireCount |// --------|---------|---------------|-------------|---------------|// FREE | false | 0 | 0 | 0 |// DEQUEUED| false | 1 | 0 | 0 |// QUEUED | false | 0 | 1 | 0 |// ACQUIRED| false | 0 | 0 | 1 |// SHARED | true | any | any | any | FREE : FREEè¡¨ç¤ºç¼“å†²åŒºå¯ç”±ç”Ÿäº§è€…ï¼ˆProducerï¼‰DEQUEUEDå‡ºåˆ—ã€‚ è¯¥BufferSlotç”±BufferQueueâ€æ‹¥æœ‰â€ã€‚ å®ƒè½¬æ¢åˆ°DEQUEUED å½“è°ƒç”¨dequeueBufferæ—¶ã€‚ DEQUEUEDï¼š DEQUEUEDè¡¨ç¤ºç¼“å†²åŒºå·²ç»è¢«ç”Ÿäº§è€…ï¼ˆProducerï¼‰å‡ºåˆ—ï¼Œä½†æ˜¯å°šæœªqueued æˆ–canceledã€‚ç”Ÿäº§è€…ï¼ˆProducerï¼‰å¯ä»¥ä¿®æ”¹ç¼“å†²åŒºçš„å†…å®¹ä¸€æ—¦ç›¸å…³çš„é‡Šæ”¾å›´æ è¢«å‘ä¿¡å·é€šçŸ¥ã€‚BufferSlotç”±Producerâ€æ‹¥æœ‰â€ã€‚ å®ƒå¯ä»¥è½¬æ¢åˆ°QUEUEDï¼ˆé€šè¿‡ queueBufferæˆ–è€…attachBufferï¼‰æˆ–è€…è¿”å›FREEï¼ˆé€šè¿‡cancelBufferæˆ–è€…detachBufferï¼‰ã€‚ QUEUEDï¼š QUEUEDè¡¨ç¤ºç¼“å†²åŒºå·²ç»è¢«ç”Ÿäº§è€…ï¼ˆProducerï¼‰å¡«å……æ’é˜Ÿç­‰å¾…æ¶ˆè´¹è€…ï¼ˆConsumerï¼‰ä½¿ç”¨ã€‚ ç¼“å†²åŒºå†…å®¹å¯èƒ½è¢«ç»§ç»­ ä¿®æ”¹åœ¨æœ‰é™çš„æ—¶é—´å†…ï¼Œæ‰€ä»¥å†…å®¹ä¸èƒ½è¢«è®¿é—®ï¼Œç›´åˆ°å…³è”çš„æ …æ fenceå‘ä¿¡å·ã€‚ è¯¥BufferSlotç”±BufferQueueâ€æ‹¥æœ‰â€ã€‚ å®ƒ å¯ä»¥è½¬æ¢ä¸ºACQUIREDï¼ˆé€šè¿‡acquireBufferï¼‰æˆ–FREEï¼ˆå¦‚æœæ˜¯å¦ä¸€ä¸ªç¼“å†²åŒºä»¥å¼‚æ­¥æ¨¡å¼æ’é˜Ÿï¼‰ã€‚ ACQUIREDï¼š ACQUIREDè¡¨ç¤ºç¼“å†²åŒºå·²è¢«æ¶ˆè´¹è€…ï¼ˆConsumerï¼‰è·å–ã€‚ å¦‚ä¸QUEUEDï¼Œå†…å®¹ä¸èƒ½è¢«æ¶ˆè´¹è€…è®¿é—®ï¼Œç›´åˆ° è·å¾—æ …æ fenceä¿¡å·ã€‚ BufferSlotç”±Consumerâ€æ‹¥æœ‰â€ã€‚ å®ƒå½“releaseBufferï¼ˆæˆ–detachBufferï¼‰è¢«è°ƒç”¨æ—¶è½¬æ¢ä¸ºFREEã€‚ ä¸€ä¸ª åˆ†ç¦»çš„ç¼“å†²åŒºä¹Ÿå¯ä»¥é€šè¿‡attachBufferè¿›å…¥ACQUIREDçŠ¶æ€ã€‚ SHAREDï¼š SHAREDè¡¨ç¤ºæ­¤ç¼“å†²åŒºæ­£åœ¨å…±äº«ç¼“å†²åŒºä¸­ä½¿ç”¨æ¨¡å¼ã€‚ å®ƒå¯ä»¥åŒæ—¶åœ¨å…¶ä»–Stateçš„ä»»ä½•ç»„åˆï¼Œ é™¤äº†FREE ï¼ˆå› ä¸ºè¿™ä¸åŒ…æ‹¬åœ¨ä»»ä½•å…¶ä»–Stateï¼‰ã€‚ å®ƒå¯ä»¥ä¹Ÿå¯ä»¥å‡ºåˆ—ï¼Œæ’é˜Ÿæˆ–å¤šæ¬¡è·å¾—ã€‚ ç®€å•æè¿°ä¸€ä¸‹çŠ¶æ€è½¬æ¢è¿‡ç¨‹ï¼š 1ã€é¦–å…ˆç”Ÿäº§è€…dequeueè¿‡æ¥ä¸€å—Bufferï¼Œæ­¤æ—¶è¯¥bufferçš„çŠ¶æ€ä¸ºDEQUEUEDï¼Œæ‰€æœ‰è€…ä¸ºPRODUCERï¼Œç”Ÿäº§è€…å¯ä»¥å¡«å……æ•°æ®äº†ã€‚åœ¨æ²¡æœ‰dequeueæ“ä½œæ—¶ï¼Œbufferçš„çŠ¶æ€ä¸ºfree,æ‰€æœ‰è€…ä¸ºBUFFERQUEUEã€‚ 2ã€ç”Ÿäº§è€…å¡«å……å®Œæ•°æ®å,è¿›è¡Œqueueæ“ä½œï¼Œæ­¤æ—¶bufferçš„çŠ¶æ€ç”±DEQUEUED-&gt;QUEUEDçš„è½¬å˜ï¼Œbufferæ‰€æœ‰è€…ä¹Ÿå˜æˆäº†BufferQueueäº†ã€‚ 3ã€ä¸Šé¢å·²ç»é€šçŸ¥æ¶ˆè´¹è€…å»æ‹¿bufferäº†ï¼Œè¿™ä¸ªæ—¶å€™æ¶ˆè´¹è€…å°±è¿›è¡Œacquireæ“ä½œå°†bufferæ‹¿è¿‡æ¥ï¼Œæ­¤æ—¶bufferçš„çŠ¶æ€ç”±QUEUED-&gt;ACQUIREDè½¬å˜ï¼Œbufferçš„æ‹¥æœ‰è€…ç”±BufferQueueå˜æˆConsumerã€‚ 4ã€å½“æ¶ˆè´¹è€…å·²ç»æ¶ˆè´¹äº†è¿™å—buffer(å·²ç»åˆæˆï¼Œå·²ç»ç¼–ç ç­‰)ï¼Œå°±è¿›è¡Œreleaseæ“ä½œé‡Šæ”¾buffer,å°†bufferå½’è¿˜ç»™BufferQueue,bufferçŠ¶æ€ç”±ACQUIREDå˜æˆFREE.bufferæ‹¥æœ‰è€…ç”±Consumerå˜æˆBufferQueue. 4.1.2ã€ç”Ÿäº§è€…Producerç”Ÿäº§è€…Producerå®ç°IGraphicBufferProducerçš„æ¥å£ï¼Œåœ¨å®é™…è¿ä½œè¿‡ç¨‹ä¸­ï¼Œåº”ç”¨ï¼ˆClientç«¯ï¼‰å­˜åœ¨ä»£ç†ç«¯BpGraphicBufferProducerï¼ŒSurfaceFlingerï¼ˆServerç«¯ï¼‰å­˜åœ¨Nativeç«¯BnGraphicBufferProducerã€‚ç”Ÿäº§è€…ä»£ç†ç«¯Bpé€šè¿‡Binderé€šä¿¡ï¼Œä¸æ–­çš„dequeueBufferå’ŒqueueBufferæ“ä½œï¼ŒNativeç«¯åŒæ ·å“åº”è¿™äº›æ“ä½œè¯·æ±‚ï¼Œè¿™æ ·bufferå°±è½¬äº†èµ·æ¥äº†ã€‚ è¿™é‡Œä»‹ç»å‡ ä¸ªéå¸¸é‡è¦çš„å‡½æ•°ï¼š 1ã€requestBuffer requestBufferä¸ºç»™å®šçš„ç´¢å¼•è¯·æ±‚ä¸€ä¸ªæ–°çš„Bufferã€‚ æœåŠ¡å™¨ï¼ˆå³IGraphicBufferProducerå®ç°ï¼‰åˆ†é…æ–°åˆ›å»ºçš„Bufferåˆ°ç»™å®šçš„BufferSlotæ§½ç´¢å¼•ï¼Œå¹¶ä¸”å®¢æˆ·ç«¯å¯ä»¥é•œåƒslot-&gt;Bufferæ˜ å°„ï¼Œè¿™æ ·å°±æ²¡æœ‰å¿…è¦ä¼ è¾“ä¸€ä¸ªGraphicBufferç”¨äºæ¯ä¸ªå‡ºé˜Ÿæ“ä½œã€‚ 12345678// requestBuffer requests a new buffer for the given index. The server (i.e.// the IGraphicBufferProducer implementation) assigns the newly created// buffer to the given slot index, and the client is expected to mirror the// slot-&gt;buffer mapping so that it&apos;s not necessary to transfer a// GraphicBuffer for every dequeue operation.//// The slot must be in the range of [0, NUM_BUFFER_SLOTS).virtual status_t requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) = 0; 2ã€dequeueBuffer dequeueBufferè¯·æ±‚ä¸€ä¸ªæ–°çš„Buffer Slotä¾›å®¢æˆ·ç«¯ä½¿ç”¨ã€‚ æ’æ§½çš„æ‰€æœ‰æƒè¢«è½¬ç§»åˆ°å®¢æˆ·ç«¯ï¼Œè¿™æ„å‘³ç€æœåŠ¡å™¨ä¸ä¼šä½¿ç”¨ä¸è¯¥æ’æ§½å…³è”çš„ç¼“å†²åŒºçš„å†…å®¹ã€‚ 123456// dequeueBuffer requests a new buffer slot for the client to use. Ownership// of the slot is transfered to the client, meaning that the server will not// use the contents of the buffer associated with that slot.//virtual status_t dequeueBuffer(int* slot, sp&lt;Fence&gt;* fence, uint32_t w, uint32_t h, PixelFormat format, uint32_t usage) = 0; 3ã€detachBuffer detachBufferå°è¯•åˆ é™¤ç»™å®šbuffer çš„æ‰€æœ‰æƒæ’æ§½ä»buffer queueã€‚ å¦‚æœè¿™ä¸ªè¯·æ±‚æˆåŠŸï¼Œè¯¥slotå°†ä¼šè¢«freeï¼Œå¹¶ä¸”å°†æ— æ³•ä»è¿™ä¸ªæ¥å£è·å¾—ç¼“å†²åŒºã€‚é‡Šæ”¾çš„æ’æ§½å°†ä¿æŒæœªåˆ†é…çŠ¶æ€ï¼Œç›´åˆ°è¢«é€‰ä¸­ä¸ºæ­¢åœ¨dequeueBufferä¸­ä¿å­˜ä¸€ä¸ªæ–°åˆ†é…çš„ç¼“å†²åŒºï¼Œæˆ–è€…é™„åŠ ä¸€ä¸ªç¼“å†²åŒºåˆ°æ’æ§½ã€‚ ç¼“å†²åŒºå¿…é¡»å·²ç»è¢«å–å‡ºï¼Œå¹¶ä¸”è°ƒç”¨è€…å¿…é¡»å·²ç»æ‹¥æœ‰sp ï¼ˆå³å¿…é¡»è°ƒç”¨requestBufferï¼‰ 12345678910// detachBuffer attempts to remove all ownership of the buffer in the given// slot from the buffer queue. If this call succeeds, the slot will be// freed, and there will be no way to obtain the buffer from this interface.// The freed slot will remain unallocated until either it is selected to// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached// to the slot. The buffer must have already been dequeued, and the caller// must already possesses the sp&lt;GraphicBuffer&gt; (i.e., must have called// requestBuffer).//virtual status_t detachBuffer(int slot) = 0; 4ã€attachBuffer attachBufferå°è¯•å°†ç¼“å†²åŒºçš„æ‰€æœ‰æƒè½¬ç§»ç»™ç¼“å†²åŒºé˜Ÿåˆ—ã€‚ å¦‚æœè¿™ä¸ªè°ƒç”¨æˆåŠŸï¼Œå°±å¥½åƒè¿™ä¸ªç¼“å†²åŒºå·²ç»å‡ºé˜Ÿä¸€æ ·ä»è¿”å›çš„æ’æ§½å·ç ã€‚ å› æ­¤ï¼Œå¦‚æœè¿æ¥ï¼Œè¿™ä¸ªè°ƒç”¨å°†å¤±è´¥è¿™ä¸ªç¼“å†²åŒºä¼šå¯¼è‡´å¾ˆå¤šçš„ç¼“å†²åŒºåŒæ—¶å‡ºé˜Ÿã€‚ 1234567// attachBuffer attempts to transfer ownership of a buffer to the buffer// queue. If this call succeeds, it will be as if this buffer was dequeued// from the returned slot number. As such, this call will fail if attaching// this buffer would cause too many buffers to be simultaneously dequeued.//virtual status_t attachBuffer(int* outSlot, const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0; 4.1.3ã€æ¶ˆè´¹è€…Consumerè¿™é‡Œä»‹ç»å‡ ä¸ªéå¸¸é‡è¦çš„å‡½æ•°ï¼š 1ã€acquireBuffer acquireBufferå°è¯•è·å–ä¸‹ä¸€ä¸ªæœªå†³ç¼“å†²åŒºçš„æ‰€æœ‰æƒBufferQueueã€‚ å¦‚æœæ²¡æœ‰ç¼“å†²åŒºç­‰å¾…ï¼Œåˆ™è¿”å›NO_BUFFER_AVAILABLEã€‚ å¦‚æœç¼“å†²åŒºè¢«æˆåŠŸè·å–ï¼Œæœ‰å…³ç¼“å†²åŒºçš„ä¿¡æ¯å°†åœ¨BufferItemä¸­è¿”å›ã€‚ 1234567// acquireBuffer attempts to acquire ownership of the next pending buffer in// the BufferQueue. If no buffer is pending then it returns// NO_BUFFER_AVAILABLE. If a buffer is successfully acquired, the// information about the buffer is returned in BufferItem.//virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen, uint64_t maxFrameNumber = 0) = 0; 2ã€releaseBuffer releaseBufferä»æ¶ˆè´¹è€…é‡Šæ”¾ä¸€ä¸ªBufferSlotå›åˆ°BufferQueueã€‚ è¿™å¯ä»¥åœ¨ç¼“å†²åŒºçš„å†…å®¹ä»ç„¶å­˜åœ¨æ—¶å®Œæˆè¢«è®¿é—®ã€‚ æ …æ å°†åœ¨ç¼“å†²åŒºä¸å†æ­£åœ¨ä½¿ç”¨æ—¶å‘å‡ºä¿¡å·ã€‚ frameNumberç”¨äºæ ‡è¯†è¿”å›çš„ç¡®åˆ‡ç¼“å†²åŒºã€‚ 12345678// releaseBuffer releases a buffer slot from the consumer back to the// BufferQueue. This may be done while the buffer&apos;s contents are still// being accessed. The fence will signal when the buffer is no longer// in use. frameNumber is used to indentify the exact buffer returned.//virtual status_t releaseBuffer(int buf, uint64_t frameNumber, EGLDisplay display, EGLSyncKHR fence, const sp&lt;Fence&gt;&amp; releaseFence) = 0; 3ã€detachBuffer detachBufferå°è¯•åˆ é™¤ç»™å®šç¼“å†²åŒºçš„æ‰€æœ‰æƒæ’æ§½ä»ç¼“å†²åŒºé˜Ÿåˆ—ã€‚ å¦‚æœè¿™ä¸ªè¯·æ±‚æˆåŠŸï¼Œè¯¥æ’æ§½å°†ä¼šæ˜¯é‡Šæ”¾ï¼Œå¹¶ä¸”å°†æ— æ³•ä»è¿™ä¸ªæ¥å£è·å¾—ç¼“å†²åŒºã€‚é‡Šæ”¾çš„æ’æ§½å°†ä¿æŒæœªåˆ†é…çŠ¶æ€ï¼Œç›´åˆ°è¢«é€‰ä¸­ä¸ºæ­¢åœ¨dequeueBufferä¸­ä¿å­˜ä¸€ä¸ªæ–°åˆ†é…çš„ç¼“å†²åŒºï¼Œæˆ–è€…é™„åŠ ä¸€ä¸ªç¼“å†²åŒºåˆ°slotã€‚ ç¼“å†²åŒºå¿…é¡»å·²è¢«acquiredã€‚ 12345678// detachBuffer attempts to remove all ownership of the buffer in the given// slot from the buffer queue. If this call succeeds, the slot will be// freed, and there will be no way to obtain the buffer from this interface.// The freed slot will remain unallocated until either it is selected to// hold a freshly allocated buffer in dequeueBuffer or a buffer is attached// to the slot. The buffer must have already been acquired.//virtual status_t detachBuffer(int slot) = 0; 4ã€attachBuffer attachBufferå°è¯•å°†ç¼“å†²åŒºçš„æ‰€æœ‰æƒè½¬ç§»ç»™ç¼“å†²åŒºé˜Ÿåˆ—ã€‚ å¦‚æœè¿™ä¸ªè°ƒç”¨æˆåŠŸï¼Œå°±å¥½åƒè¿™ä¸ªç¼“å†²åŒºè¢«è·å–äº†ä¸€æ ·ä»è¿”å›çš„æ’æ§½å·ç ã€‚ å› æ­¤ï¼Œå¦‚æœè¿æ¥ï¼Œè¿™ä¸ªè°ƒç”¨å°†å¤±è´¥è¿™ä¸ªç¼“å†²åŒºä¼šå¯¼è‡´å¤ªå¤šçš„ç¼“å†²åŒºè¢«åŒæ—¶acquiredã€‚ 1234567// attachBuffer attempts to transfer ownership of a buffer to the buffer// queue. If this call succeeds, it will be as if this buffer was acquired// from the returned slot number. As such, this call will fail if attaching// this buffer would cause too many buffers to be simultaneously acquired.//virtual status_t attachBuffer(int *outSlot, const sp&lt;GraphicBuffer&gt;&amp; buffer) = 0; 4.2ã€Appï¼ˆJavaå±‚ï¼‰è¯·æ±‚åˆ›å»ºSurfaceè¿‡ç¨‹4.2.1ã€Activityå¯åŠ¨æµç¨‹Activityåˆ›å»ºè¿‡ç¨‹è¿™é‡Œä¸å†å™è¿°ã€‚ è¯·å‚è€ƒã€Android 7.1.2 (Android N) Activityå¯åŠ¨æµç¨‹åˆ†æã€‘ &amp;&amp; ã€Android 7.1.2 (Android N) Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹åˆ†æã€‘ â— ActivityManagerServiceæ¥æ”¶å¯åŠ¨Activityçš„è¯·æ±‚ Activity.startActivity()Activity.startActivityForResult()Instrumentation.execStartActivity()ActivityManagerProxy.startActivity()ActivityManagerNative.onTransact()ActivityManagerService.startActivity()ActivityStarter.startActivityMayWait()ActivityStarter.startActivityLocked()ActivityStarter.startActivityUnchecked()ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() ActivityStack.resumeTopActivityUncheckedLocked()ActivityStack.resumeTopActivityInnerLocked()ActivityStackSupervisor.startSpecificActivityLocked() â—â— åˆ›å»ºActivityæ‰€å±çš„åº”ç”¨è¿›ç¨‹ ActivityManagerService.startProcessLocked() â—â—â— Zygoteé€šè¿‡socketé€šä¿¡forkä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œå¹¶æ ¹æ®â€android.app.ActivityThreadâ€å­—ç¬¦ä¸² â—â—â— åå°„å‡ºè¯¥å¯¹è±¡å¹¶æ‰§è¡ŒActivityThreadçš„mainæ–¹æ³• ActivityThread.main() ActivityThread.attach() ActivityManagerProxy.attachApplication() ActivityManagerNative.onTransact() ActivityManagerService.attachApplication() ActivityManagerService.attachApplicationLocked() ActivityStackSupervisor.attachApplicationLocked() ActivityStackSupervisor.realStartActivityLocked() â—â—â—â— æ‰§è¡Œå¯åŠ¨AcitivityIApplicationThread.scheduleLaunchActivity()ActivityThread.ApplicationThread.scheduleLaunchActivity()ActivityThread.sendMessage() ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()ActivityThread.handleResumeActivity() 4.2.2ã€WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ç”»å›¾ï¼Œéœ€è¦é‡æ–°åˆ†æä¸€ä¸‹ä¸‹ï¼Œå˜¿å˜¿(^â–½^)~ 4.2.2.1ã€ActivityThread.handleLaunchActivity()æ¥ç€ä»ActivityThreadçš„handleLaunchActivityæ–¹æ³•ï¼š 123456789101112131415 [-&gt;ActivityThread.java] private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason)&#123; ...... //åˆ›å»ºActivity Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; ...... //å¯åŠ¨Activity handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... &#125;&#125; 4.2.2.2ã€ActivityThread.handleResumeActivity()å›åˆ°æˆ‘ä»¬åˆšåˆšçš„handleLaunchActivity()æ–¹æ³•ï¼Œåœ¨è°ƒç”¨å®ŒperformLaunchActivity()æ–¹æ³•ä¹‹åï¼Œå…¶æœ‰æ‰ç”¨äº†handleResumeActivity()æ³•ã€‚performLaunchActivity()æ–¹æ³•å®Œæˆäº†ä¸¤ä»¶äº‹ï¼š 1) Activityçª—å£å¯¹è±¡çš„åˆ›å»ºï¼Œé€šè¿‡attachå‡½æ•°æ¥å®Œæˆï¼› 2) Activityè§†å›¾å¯¹è±¡çš„åˆ›å»ºï¼Œé€šè¿‡setContentViewå‡½æ•°æ¥å®Œæˆï¼› è¿™äº›å‡†å¤‡å·¥ä½œå®Œæˆåï¼Œå°±å¯ä»¥æ˜¾ç¤ºè¯¥Activityäº†ï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹é€šè¿‡è°ƒç”¨handleResumeActivityå‡½æ•°æ¥å¯åŠ¨Activityçš„æ˜¾ç¤ºè¿‡ç¨‹ã€‚ [-&gt;ActivityThread.java] 123456789101112131415161718192021222324252627282930 final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... r = performResumeActivity(token, clearHide, reason); ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //è·å¾—ä¸ºå½“å‰Activityåˆ›å»ºçš„çª—å£PhoneWindowå¯¹è±¡ r.window = r.activity.getWindow(); //è·å–ä¸ºçª—å£åˆ›å»ºçš„è§†å›¾DecorViewå¯¹è±¡ View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //åœ¨attachå‡½æ•°ä¸­å°±ä¸ºå½“å‰Activityåˆ›å»ºäº†WindowManagerå¯¹è±¡ ViewManager wm = a.getWindowManager(); //å¾—åˆ°è¯¥è§†å›¾å¯¹è±¡çš„å¸ƒå±€å‚æ•° WindowManager.LayoutParams l = r.window.getAttributes(); //å°†è§†å›¾å¯¹è±¡ä¿å­˜åˆ°Activityçš„æˆå‘˜å˜é‡mDecorä¸­ a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ...... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //å°†åˆ›å»ºçš„è§†å›¾å¯¹è±¡DecorViewæ·»åŠ åˆ°Activityçš„çª—å£ç®¡ç†å™¨ä¸­ wm.addView(decor, l); &#125; ...... &#125; &#125;&#125; åœ¨å‰é¢çš„performLaunchActivityå‡½æ•°ä¸­å®ŒæˆActivityçš„åˆ›å»ºåï¼Œä¼šå°†å½“å‰å½“å‰åˆ›å»ºçš„Activityåœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ç«¯çš„æè¿°ç¬¦ActivityClientRecordä»¥é”®å€¼å¯¹çš„å½¢å¼ä¿å­˜åˆ°ActivityThreadçš„æˆå‘˜å˜é‡mActivitiesä¸­ï¼šmActivities.put(r.token, r)ï¼Œr.tokenå°±æ˜¯Activityçš„èº«ä»½è¯ï¼Œå³æ˜¯IApplicationToken.Proxyä»£ç†å¯¹è±¡ï¼Œä¹Ÿç”¨äºä¸AMSé€šä¿¡ã€‚ä¸Šé¢çš„å‡½æ•°é¦–å…ˆé€šè¿‡performResumeActivityä»mActivitieså˜é‡ä¸­å–å‡ºActivityçš„åº”ç”¨ç¨‹åºç«¯æè¿°ç¬¦ActivityClientRecordï¼Œç„¶åå–å‡ºå‰é¢ä¸ºActivityåˆ›å»ºçš„è§†å›¾å¯¹è±¡DecorViewå’Œçª—å£ç®¡ç†å™¨WindowManagerï¼Œæœ€åå°†è§†å›¾å¯¹è±¡æ·»åŠ åˆ°çª—å£ç®¡ç†å™¨ä¸­ã€‚ ViewManager.addView()çœŸæ­£å®ç°çš„çš„åœ°æ–¹åœ¨WindowManagerImpl.javaä¸­ã€‚ 12345public interface ViewManager&#123;public void addView(View view, ViewGroup.LayoutParams params);......&#125; [-&gt;WindowManagerImpl.java] 12345Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ...... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; [-&gt;WindowManagerGlobal.java] 123456789101112131415161718 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; try &#123; root.setView(view, wparams, panelParentView); &#125; ......&#125; 4.2.2.3ã€ViewRootImpl()æ„é€ è¿‡ç¨‹ï¼š[ViewRootImpl.java # ViewRootImpl()] 1234567891011121314151617181920 final W mWindow; final Surface mSurface = new Surface(); final ViewRootHandler mHandler = new ViewRootHandler(); ...... public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession();//IWindowSessionçš„ä»£ç†å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨äºå’ŒWMSé€šä¿¡ã€‚ mDisplay = display; ...... mWindow = new W(this);//åˆ›å»ºäº†ä¸€ä¸ªWæœ¬åœ°Binderå¯¹è±¡ï¼Œç”¨äºWMSé€šçŸ¥åº”ç”¨ç¨‹åºè¿›ç¨‹ ...... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); ...... mViewConfiguration = ViewConfiguration.get(context); mDensity = context.getResources().getDisplayMetrics().densityDpi; mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi; mFallbackEventHandler = new PhoneFallbackEventHandler(context); mChoreographer = Choreographer.getInstance();//Choreographerå¯¹è±¡ ......&#125; åœ¨ViewRootImplçš„æ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–äº†ä¸€äº›æˆå‘˜å˜é‡ï¼ŒViewRootImplåˆ›å»ºäº†ä»¥ä¸‹å‡ ä¸ªä¸»è¦å¯¹è±¡ï¼š (1) é€šè¿‡WindowManagerGlobal.getWindowSession()å¾—åˆ°IWindowSessionçš„ä»£ç†å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨äºå’ŒWMSé€šä¿¡ã€‚ (2) åˆ›å»ºäº†ä¸€ä¸ªWæœ¬åœ°Binderå¯¹è±¡ï¼Œç”¨äºWMSé€šçŸ¥åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ (3) é‡‡ç”¨å•ä¾‹æ¨¡å¼åˆ›å»ºäº†ä¸€ä¸ªChoreographerå¯¹è±¡ï¼Œç”¨äºç»Ÿä¸€è°ƒåº¦çª—å£ç»˜å›¾ã€‚ (4) åˆ›å»ºViewRootHandlerå¯¹è±¡ï¼Œç”¨äºå¤„ç†å½“å‰è§†å›¾æ¶ˆæ¯ã€‚ (5) æ„é€ ä¸€ä¸ªAttachInfoå¯¹è±¡ï¼› â—â—â—(6) åˆ›å»ºSurfaceå¯¹è±¡ï¼Œç”¨äºç»˜åˆ¶å½“å‰è§†å›¾ï¼Œå½“ç„¶è¯¥Surfaceå¯¹è±¡çš„çœŸæ­£åˆ›å»ºæ˜¯ç”±WMSæ¥å®Œæˆçš„ï¼Œåªä¸è¿‡æ˜¯WMSä¼ é€’ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹çš„ã€‚ 4.2.2.4ã€IWindowSessionä»£ç†è·å–è¿‡ç¨‹[-&gt;WindowManagerGlobal.java] 12345678910111213141516171819202122 private static IWindowSession sWindowSession; public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; ...... //å¾—åˆ°IWindowSessionä»£ç†å¯¹è±¡ sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; ä»¥ä¸Šå‡½æ•°é€šè¿‡WMSçš„openSessionå‡½æ•°åˆ›å»ºåº”ç”¨ç¨‹åºä¸WMSä¹‹é—´çš„è¿æ¥é€šé“ï¼Œå³è·å–IWindowSessionä»£ç†å¯¹è±¡ï¼Œå¹¶å°†è¯¥ä»£ç†å¯¹è±¡ä¿å­˜åˆ°ViewRootImplçš„é™æ€æˆå‘˜å˜é‡sWindowSessionä¸­,å› æ­¤åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­æœ‰ä¸”åªæœ‰ä¸€ä¸ªIWindowSessionä»£ç†å¯¹è±¡ã€‚ [-&gt;WindowManagerService.java] 12345678Overridepublic IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; if (client == null) throw new IllegalArgumentException(\"null client\"); if (inputContext == null) throw new IllegalArgumentException(\"null inputContext\"); Session session = new Session(this, callback, client, inputContext); return session;&#125; åœ¨WMSæœåŠ¡ç«¯æ„é€ äº†ä¸€ä¸ªSessionå®ä¾‹å¯¹è±¡ã€‚ViewRootImpl æ˜¯ä¸€å¾ˆé‡è¦çš„ç±»ï¼Œç±»ä¼¼ ActivityThread è´Ÿè´£è·ŸAmSé€šä¿¡ä¸€æ ·ï¼ŒViewRootImpl çš„ä¸€ä¸ªé‡è¦èŒè´£å°±æ˜¯è·Ÿ WmS é€šä¿¡ï¼Œå®ƒé€šé™æ€å˜é‡ sWindowSessionï¼ˆIWindowSessionå®ä¾‹ï¼‰ä¸ WmS è¿›è¡Œé€šä¿¡ã€‚æ¯ä¸ªåº”ç”¨è¿›ç¨‹ï¼Œä»…æœ‰ä¸€ä¸ª sWindowSession å¯¹è±¡ï¼Œå®ƒå¯¹åº”äº† WmS ä¸­çš„ Session å­ç±»ï¼ŒWmS ä¸ºæ¯ä¸€ä¸ªåº”ç”¨è¿›ç¨‹åˆ†é…ä¸€ä¸ª Session å¯¹è±¡ã€‚WindowState ç±»æœ‰ä¸€ä¸ª IWindow mClient å‚æ•°ï¼Œæ˜¯åœ¨æ„é€ æ–¹æ³•ä¸­èµ‹å€¼çš„ï¼Œæ˜¯ç”± Session è°ƒç”¨ addWindow ä¼ é€’è¿‡æ¥äº†ï¼Œå¯¹åº”äº† ViewRootImpl ä¸­çš„ W ç±»çš„å®ä¾‹ã€‚ 4.2.2.5ã€è§†å›¾Viewæ·»åŠ è¿‡ç¨‹ViewRootImpl.setView()çª—å£ç®¡ç†å™¨WindowManagerImplä¸ºå½“å‰æ·»åŠ çš„çª—å£åˆ›å»ºå¥½å„ç§å¯¹è±¡åï¼Œè°ƒç”¨ViewRootImplçš„setViewå‡½æ•°å‘WMSæœåŠ¡æ·»åŠ ä¸€ä¸ªçª—å£å¯¹è±¡ã€‚ [-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324252627282930public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; ////å°†DecorViewä¿å­˜åˆ°ViewRootImplçš„æˆå‘˜å˜é‡mViewä¸­ mView = view; ...... //1ï¼‰åœ¨æ·»åŠ çª—å£å‰è¿›è¡ŒUIå¸ƒå±€ requestLayout(); ...... try &#123; ...... //2)å°†çª—å£æ·»åŠ åˆ°WMSæœåŠ¡ä¸­ï¼ŒmWindowä¸ºWæœ¬åœ°Binderå¯¹è±¡ï¼Œé€šè¿‡Binderä¼ è¾“åˆ°WMSæœåŠ¡ç«¯åï¼Œå˜ä¸ºIWindowä»£ç†å¯¹è±¡ res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; ...... //3)å»ºç«‹çª—å£æ¶ˆæ¯é€šé“ if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ...... &#125; &#125;&#125; é€šè¿‡å‰é¢çš„åˆ†æå¯ä»¥çŸ¥é“ï¼Œç”¨æˆ·è‡ªå®šä¹‰çš„UIä½œä¸ºä¸€ä¸ªå­Viewè¢«æ·»åŠ åˆ°DecorViewä¸­ï¼Œç„¶åå°†é¡¶çº§è§†å›¾DecorViewæ·»åŠ åˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹çš„çª—å£ç®¡ç†å™¨ä¸­ï¼Œçª—å£ç®¡ç†å™¨é¦–å…ˆä¸ºå½“å‰æ·»åŠ çš„Viewåˆ›å»ºä¸€ä¸ªViewRootImplå¯¹è±¡ã€ä¸€ä¸ªå¸ƒå±€å‚æ•°å¯¹è±¡ViewGroup.LayoutParamsï¼Œç„¶åå°†è¿™ä¸‰ä¸ªå¯¹è±¡åˆ†åˆ«ä¿å­˜åˆ°å½“å‰åº”ç”¨ç¨‹åºè¿›ç¨‹çš„çª—å£ç®¡ç†å™¨WindowManagerImplä¸­ï¼Œæœ€åé€šè¿‡ViewRootImplå¯¹è±¡å°†å½“å‰è§†å›¾å¯¹è±¡æ³¨å†Œåˆ°WMSæœåŠ¡ä¸­ã€‚ ViewRootImplçš„setViewå‡½æ•°å‘WMSæœåŠ¡æ·»åŠ ä¸€ä¸ªçª—å£å¯¹è±¡è¿‡ç¨‹ï¼š (1) requestLayout()åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­è¿›è¡Œçª—å£UIå¸ƒå±€ï¼› (2) WindowSession.addToDisplay()å‘WMSæœåŠ¡æ³¨å†Œä¸€ä¸ªçª—å£å¯¹è±¡ï¼› (3) æ³¨å†Œåº”ç”¨ç¨‹åºè¿›ç¨‹ç«¯çš„æ¶ˆæ¯æ¥æ”¶é€šé“ï¼› 4.2.2.6ã€requestLayout()åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­è¿›è¡Œçª—å£UIå¸ƒå±€ï¼›2.10ã€çª—å£UIå¸ƒå±€è¿‡ç¨‹ requestLayoutå‡½æ•°è°ƒç”¨é‡Œé¢ä½¿ç”¨äº†Hanlderçš„ä¸€ä¸ªå°æ‰‹æ®µï¼Œé‚£å°±æ˜¯åˆ©ç”¨postSyncBarrieræ·»åŠ äº†ä¸€ä¸ªBarrierï¼ˆæŒ¡æ¿ï¼‰ï¼Œè¿™ä¸ªæŒ¡æ¿çš„ä½œç”¨æ˜¯é˜»å¡æ™®é€šçš„åŒæ­¥æ¶ˆæ¯çš„æ‰§è¡Œï¼Œåœ¨æŒ¡æ¿è¢«æ’¤é”€ä¹‹å‰ï¼Œåªä¼šæ‰§è¡Œå¼‚æ­¥æ¶ˆæ¯ï¼Œè€ŒrequestLayoutå…ˆæ·»åŠ äº†ä¸€ä¸ªæŒ¡æ¿Barrierï¼Œä¹‹åè‡ªå·±æ’å…¥äº†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡mTraversalRunnableï¼Œå…¶ä¸»è¦ä½œç”¨å°±æ˜¯ä¿è¯mTraversalRunnableåœ¨æ‰€æœ‰åŒæ­¥Messageä¹‹å‰è¢«æ‰§è¡Œï¼Œä¿è¯Viewç»˜åˆ¶çš„æœ€é«˜ä¼˜å…ˆçº§ã€‚å…·ä½“å®ç°å¦‚ä¸‹ï¼š 12345678910111213Overridepublic void requestLayout() &#123; scheduleTraversals();&#125;void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ...... &#125;&#125; è¿™é‡Œæš‚æ—¶ä¸è®¨è®ºChoreographerå’ŒVsyncçŸ¥è¯†ï¼Œç¨åå†è¯¦ç»†åˆ†æã€‚ ç°åœ¨å…ˆè¯´å‡ºç»“è®ºï¼šChoreographeræ„é€ å‡½æ•°ä¸­ï¼Œæ„é€ äº†ä¸€ä¸ªFrameDisplayEventReceiverå¯¹è±¡ï¼Œç”¨äºè¯·æ±‚å¹¶æ¥æ”¶Vsyncä¿¡å·ã€‚ æ­¤æ—¶FrameDisplayEventReceiverä¼šCall requestNextVsync()æ¥å‘Šè¯‰ç³»ç»Ÿæˆ‘è¦åœ¨ä¸‹ä¸€ä¸ªVSYNCéœ€è¦è¢«triggerã€‚Vsyncä¿¡å·æ¯éš”16msä¸€æ¬¡ï¼Œæ­¤æ—¶Vsyncä¿¡å·è¿˜æœªæ¥åˆ°ï¼Œç»§ç»­åˆ†æmWindowSession.addToDisplay()ã€‚ 4.2.2.7ã€mWindowSession.addToDisplay()å‘WMSæœåŠ¡æ³¨å†Œä¸€ä¸ªçª—å£å¯¹è±¡ï¼›[Session.java] 1234567Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);&#125; [WindowManagerService.java] 123456789101112131415161718192021public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ...... synchronized(mWindowMap) &#123; ...... WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); return WindowManagerGlobal.ADD_APP_EXITING; &#125; ...... if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); ...... return res;&#125; æ„é€ ä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œå¹¶å°†æ·»åŠ çš„çª—å£ä¿¡æ¯è®°å½•åˆ°mTokenMapå’ŒmWindowMapå“ˆå¸Œè¡¨ä¸­ã€‚ åœ¨WMSæœåŠ¡ç«¯åˆ›å»ºäº†æ‰€éœ€å¯¹è±¡åï¼Œæ¥ç€è°ƒç”¨äº†WindowStateçš„attach()æ¥è¿›ä¸€æ­¥å®Œæˆçª—å£æ·»åŠ ã€‚ [WindowState.java] 12345void attach() &#123; if (WindowManagerService.localLOGV) Slog.v(TAG, \"Attaching \" + this + \" token=\" + mToken + \", list=\" + mToken.windows); mSession.windowAddedLocked();&#125; [Session.java] 12345678910111213 void windowAddedLocked() &#123; if (mSurfaceSession == null) &#123; if (WindowManagerService.localLOGV) Slog.v( TAG_WM, \"First window added to \" + this + \", creating SurfaceSession\"); mSurfaceSession = new SurfaceSession(); if (SHOW_TRANSACTIONS) Slog.i(TAG_WM, \" NEW SURFACE SESSION \" + mSurfaceSession); mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123; mService.dispatchNewAnimatorScaleLocked(this); &#125; &#125; mNumWindow++;&#125; 4.2.2.8ã€SurfaceSessionå»ºç«‹è¿‡ç¨‹SurfaceSessionå¯¹è±¡æ‰¿æ‹…äº†åº”ç”¨ç¨‹åºä¸SurfaceFlingerä¹‹é—´çš„é€šä¿¡è¿‡ç¨‹ï¼Œæ¯ä¸€ä¸ªéœ€è¦ä¸SurfaceFlingerè¿›ç¨‹äº¤äº’çš„åº”ç”¨ç¨‹åºç«¯éƒ½éœ€è¦åˆ›å»ºä¸€ä¸ªSurfaceSessionå¯¹è±¡ã€‚ å®¢æˆ·ç«¯è¯·æ±‚ [SurfaceSession.java] 123public SurfaceSession() &#123; mNativeClient = nativeCreate();&#125; Javaå±‚çš„SurfaceSessionå¯¹è±¡æ„é€ è¿‡ç¨‹ä¼šé€šè¿‡JNIåœ¨nativeå±‚åˆ›å»ºä¸€ä¸ªSurfaceComposerClientå¯¹è±¡ã€‚ [android_view_SurfaceSession.cpp] 12345static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;SurfaceComposerClient* client = new SurfaceComposerClient();client-&gt;incStrong((void*)nativeCreate);return reinterpret_cast&lt;jlong&gt;(client);&#125; Javaå±‚çš„SurfaceSessionå¯¹è±¡ä¸C++å±‚çš„SurfaceComposerClientå¯¹è±¡ä¹‹é—´æ˜¯ä¸€å¯¹ä¸€å…³ç³»ã€‚ æ˜¯å¦ä¼¼æ›¾ç›¸è¯†ï¼Œå°±æ˜¯å‰é¢æœ€å¼€å§‹SurfaceFlinger_Testç¨‹åºç¬¬ä¸€æ­¥ï¼šnew SurfaceComposerClientçš„è¿‡ç¨‹ã€‚ [SurfaceComposerClient.cpp] 12345678910111213SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;void SurfaceComposerClient::onFirstRef() &#123;//å¾—åˆ°SurfaceFlingerçš„ä»£ç†å¯¹è±¡BpSurfaceComposer sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125;&#125;&#125; SurfaceComposerClientç»§æ‰¿äºRefBaseç±»ï¼Œå½“ç¬¬ä¸€æ¬¡è¢«å¼ºå¼•ç”¨æ—¶ï¼ŒonFirstRefå‡½æ•°è¢«å›è°ƒï¼Œåœ¨è¯¥å‡½æ•°ä¸­SurfaceComposerClientä¼šè¯·æ±‚SurfaceFlingerä¸ºå½“å‰åº”ç”¨ç¨‹åºåˆ›å»ºä¸€ä¸ªClientå¯¹è±¡ï¼Œä¸“é—¨æ¥æ”¶è¯¥åº”ç”¨ç¨‹åºçš„è¯·æ±‚ï¼Œåœ¨SurfaceFlingerç«¯åˆ›å»ºå¥½Clientæœ¬åœ°Binderå¯¹è±¡åï¼Œå°†è¯¥Binderä»£ç†å¯¹è±¡è¿”å›ç»™åº”ç”¨ç¨‹åºç«¯ï¼Œå¹¶ä¿å­˜åœ¨SurfaceComposerClientçš„æˆå‘˜å˜é‡mClientä¸­ã€‚ æœåŠ¡ç«¯å¤„ç† åœ¨SurfaceFlingeræœåŠ¡ç«¯ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºäº¤äº’çš„Clientå¯¹è±¡ [SurfaceFlinger.cpp] 12345678910sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123;sp&lt;ISurfaceComposerClient&gt; bclient;sp&lt;Client&gt; client(new Client(this));status_t err = client-&gt;initCheck();if (err == NO_ERROR) &#123; bclient = client;&#125;return bclient;&#125; 4.2.3ã€Appï¼ˆC++å±‚ï¼‰è¯·æ±‚åˆ›å»ºSurfaceFlingerå®¢æˆ·ç«¯(client)çš„è¿‡ç¨‹ ç»§ç»­è¯¦ç»†åˆ†æAppAppï¼ˆC++å±‚ï¼‰è¯·æ±‚åˆ›å»ºSurfaceFlingerå®¢æˆ·ç«¯(client)çš„è¿‡ç¨‹ SurfaceComposerClientç¬¬ä¸€æ¬¡å¼ºå¼•ç”¨æ—¶ï¼Œä¼šæ‰§è¡ŒonFirstRef() [SurfaceComposerClient.cpp] 12345678910111213SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;void SurfaceComposerClient::onFirstRef() &#123;//å¾—åˆ°SurfaceFlingerçš„ä»£ç†å¯¹è±¡BpSurfaceComposer sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125;&#125;&#125; ç¬¬ä¸€æ­¥ï¼šè·å–â€SurfaceFlingerâ€æœåŠ¡ ComposerService::getComposerService() 12345678910/*static*/ sp&lt;ISurfaceComposer&gt; ComposerService::getComposerService() &#123; ComposerService&amp; instance = ComposerService::getInstance(); Mutex::Autolock _l(instance.mLock); if (instance.mComposerService == NULL) &#123; ComposerService::getInstance().connectLocked(); assert(instance.mComposerService != NULL); ALOGD(\"ComposerService reconnected\"); &#125; return instance.mComposerService;&#125; ComposerService::getInstance()ä¼šè°ƒç”¨connectLocked()è·å–â€SurfaceFlingerâ€æœåŠ¡ã€‚ 12345678910111213ComposerService::ComposerService(): Singleton&lt;ComposerService&gt;() &#123; Mutex::Autolock _l(mLock); connectLocked();&#125;void ComposerService::connectLocked() &#123; const String16 name(&quot;SurfaceFlinger&quot;); while (getService(name, &amp;mComposerService) != NO_ERROR) &#123; usleep(250000); &#125; ......&#125; æ‰€ä»¥å‰é¢instance.mComposerServiceå…¶å®è¿”å›çš„æ˜¯â€SurfaceFlingerâ€æœåŠ¡ã€‚ ç¬¬äºŒæ­¥ï¼šcreateConnection() æ¥ä¸‹æ¥å°±ä¼šè°ƒç”¨â€SurfaceFlingerâ€æœåŠ¡çš„createConnection() 12345678910sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123; sp&lt;ISurfaceComposerClient&gt; bclient; sp&lt;Client&gt; client(new Client(this)); status_t err = client-&gt;initCheck(); if (err == NO_ERROR) &#123; bclient = client; &#125; return bclient;&#125; 4.2.4ã€APPç”³è¯·åˆ›å»ºSurfaceè¿‡ç¨‹å‰é¢è®²ViewRootImpl.setViewæ—¶ï¼ŒrequestLayout()éœ€è¦Vsync triggerï¼ŒåŠ å…¥ç°åœ¨Vsyncä¿¡å·æ¥åˆ°ï¼Œäºæ˜¯ä¼šç»§ç»­æ‰§è¡Œã€‚Appç”³è¯·åˆ›å»ºSurfaceçš„è¿‡ç¨‹å°±åœ¨å…¶ä¸­ã€‚ å½“Vsyncäº‹ä»¶åˆ°æ¥æ—¶ï¼Œå°±ä¼šé€šè¿‡Choreographerçš„postCallback()ï¼Œæ¥ç€æ‰§è¡ŒmTraversalRunnableå¯¹è±¡çš„run()æ–¹æ³•ã€‚ mTraversalRunnableå¯¹è±¡çš„ç±»å‹ä¸ºTraversalRunnableï¼Œè¯¥ç±»å®ç°äº†Runnableæ¥å£ï¼Œåœ¨å…¶run()å‡½æ•°ä¸­è°ƒç”¨äº†doTraversal()å‡½æ•°æ¥å®Œæˆçª—å£å¸ƒå±€ã€‚ [-&gt;ViewRootImpl.java] 12345678910111213141516final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); ...... performTraversals(); ...... &#125;&#125; performTraversalså‡½æ•°ç›¸å½“å¤æ‚ï¼Œå…¶ä¸»è¦å®ç°ä»¥ä¸‹å‡ ä¸ªé‡è¦æ­¥éª¤ï¼š 1.æ‰§è¡Œçª—å£æµ‹é‡ï¼› 2.æ‰§è¡Œçª—å£æ³¨å†Œï¼› 3.æ‰§è¡Œçª—å£å¸ƒå±€ï¼› 4.æ‰§è¡Œçª—å£ç»˜å›¾ï¼› [-&gt;ViewRootImpl.java] 12345678910111213141516171819202122232425262728293031 private void performTraversals() &#123; ...... /****************æ‰§è¡Œçª—å£æµ‹é‡******************/ if (layoutRequested) &#123; windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ...... /****************å‘WMSæœåŠ¡æ·»åŠ çª—å£******************/ if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... &#125; ...... &#125; /****************æ‰§è¡Œçª—å£å¸ƒå±€******************/ if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ...... &#125; /****************æ‰§è¡Œçª—å£ç»˜åˆ¶******************/ if (!cancelDraw &amp;&amp; !newSurface) &#123; ...... performDraw(); &#125; ......&#125; 1ã€æ‰§è¡Œçª—å£æµ‹é‡performMeasure() [-&gt;ViewRootImpl.java] 123456 private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; ......&#125; 4.2.4.1ã€APPç”³è¯·åˆ›å»ºSurfaceè¿‡ç¨‹(Javaå±‚)2ã€æ‰§è¡Œçª—å£æ³¨å†ŒrelayoutWindowï¼› [-&gt;ViewRootImpl.java] 12345678910111213141516 private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ...... int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;&#125; è¿™é‡Œé€šè¿‡å‰é¢è·å–çš„IWindowSessionä»£ç†å¯¹è±¡è¯·æ±‚WMSæœåŠ¡æ‰§è¡Œçª—å£å¸ƒå±€ï¼ŒmSurfaceæ˜¯ViewRootImplçš„æˆå‘˜å˜é‡ [-&gt;ViewRootImpl.java] 1final Surface mSurface = new Surface(); [-&gt;Surface.java] 123456/** * Create an empty surface, which will later be filled in by readFromParcel(). * @hide */public Surface() &#123;&#125; è¯¥Surfaceæ„é€ å‡½æ•°ä»…ä»…åˆ›å»ºäº†ä¸€ä¸ªç©ºSurfaceå¯¹è±¡ï¼Œå¹¶æ²¡æœ‰å¯¹è¯¥Surfaceè¿›ç¨‹nativeå±‚çš„åˆå§‹åŒ–ï¼Œåˆ°æ­¤æˆ‘ä»¬çŸ¥é“åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸ºæ¯ä¸ªçª—å£å¯¹è±¡éƒ½åˆ›å»ºäº†ä¸€ä¸ªSurfaceå¯¹è±¡ã€‚å¹¶ä¸”å°†è¯¥Surfaceé€šè¿‡è·¨è¿›ç¨‹æ–¹å¼ä¼ è¾“ç»™WMSæœåŠ¡è¿›ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œåœ¨Androidç³»ç»Ÿä¸­ï¼Œå¦‚æœä¸€ä¸ªå¯¹è±¡éœ€è¦åœ¨ä¸åŒè¿›ç¨‹é—´ä¼ è¾“ï¼Œå¿…é¡»å®ç°Parcelableæ¥å£ï¼ŒSurfaceç±»æ­£å¥½å®ç°äº†Parcelableæ¥å£ã€‚ViewRootImplé€šè¿‡IWindowSessionæ¥å£è¯·æ±‚WMSçš„å®Œæ•´è¿‡ç¨‹å¦‚ä¸‹ï¼š [-&gt;IWindowSession.java$ Proxy] 123456789101112131415161718192021/** This file is auto-generated. DO NOT MODIFY* * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl*/@Override public int relayout(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface) throws android.os.RemoteException &#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();int _result;try &#123; ...... mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0); ...... if ((0 != _reply.readInt())) &#123; outSurface.readFromParcel(_reply); &#125;&#125; finally &#123; ......&#125;return _result;&#125; ä»è¯¥å‡½æ•°çš„å®ç°å¯ä»¥çœ‹å‡ºï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­åˆ›å»ºçš„Surfaceå¯¹è±¡å¹¶æ²¡æœ‰ä¼ é€’åˆ°WMSæœåŠ¡è¿›ç¨‹ï¼Œåªæ˜¯è¯»å–WMSæœåŠ¡è¿›ç¨‹è¿”å›æ¥çš„Surfaceã€‚é‚£ä¹ˆWMSæœåŠ¡è¿›ç¨‹æ˜¯å¦‚ä½•å“åº”åº”ç”¨ç¨‹åºè¿›ç¨‹å¸ƒå±€è¯·æ±‚çš„å‘¢ï¼Ÿ [-&gt;IWindowSession.java$ Stub] 1234567891011121314151617181920@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;switch (code)&#123;case TRANSACTION_relayout: &#123; ...... android.view.Surface _arg15; _arg15 = new android.view.Surface(); int _result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15); reply.writeNoException(); reply.writeInt(_result); ...... if ((_arg15!=null)) &#123; reply.writeInt(1); _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; return true; &#125;&#125; è¯¥å‡½æ•°å¯ä»¥çœ‹å‡ºï¼ŒWMSæœåŠ¡åœ¨å“åº”åº”ç”¨ç¨‹åºè¿›ç¨‹è¯·æ±‚æ·»åŠ çª—å£æ—¶ï¼Œé¦–å…ˆåœ¨å½“å‰è¿›ç¨‹ç©ºé—´åˆ›å»ºä¸€ä¸ªSurfaceå¯¹è±¡ 12android.view.Surface _arg15;_arg15 = new android.view.Surface(); ç„¶åè°ƒç”¨Sessionçš„relayout()å‡½æ•°è¿›ä¸€æ­¥å®Œæˆçª—å£æ·»åŠ è¿‡ç¨‹ï¼Œæœ€åå°†WMSæœåŠ¡ä¸­åˆ›å»ºçš„Surfaceè¿”å›ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹å’ŒWMSæœåŠ¡è¿›ç¨‹åˆ†åˆ«åˆ›å»ºäº†ä¸€ä¸ªSurfaceå¯¹è±¡ï¼Œä½†æ˜¯ä»–ä»¬è°ƒç”¨çš„éƒ½æ˜¯Surfaceçš„æ— å‚æ„é€ å‡½æ•°ï¼Œåœ¨è¯¥æ„é€ å‡½æ•°ä¸­å¹¶æœªçœŸæ­£åˆå§‹åŒ–nativeå±‚çš„Surfaceï¼Œé‚£nativeå±‚çš„Surfaceæ˜¯åœ¨é‚£é‡Œåˆ›å»ºçš„å‘¢ï¼Ÿ [-&gt;Session.java] 1234567891011 public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, outConfig, outSurface); return res;&#125; [-&gt;WindowManagerService.java] 1234567891011121314151617181920212223242526 public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int result = 0; ...... if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges, oldVisibility); try &#123; result = createSurfaceControl(outSurface, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... return 0; &#125; ...... &#125; else &#123; ...... &#125; ...... return result;&#125; [-&gt;WindowManagerService.java] 12345678910111213 private int createSurfaceControl(Surface outSurface, int result, WindowState win, WindowStateAnimator winAnimator) &#123; if (!win.mHasSurface) &#123; result |= RELAYOUT_RES_SURFACE_CHANGED; &#125; WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(); if (surfaceController != null) &#123; surfaceController.getSurface(outSurface); &#125; else &#123; outSurface.release(); &#125; return result;&#125; [-&gt;WindowSurfaceController.java] 123 void getSurface(Surface outSurface) &#123; outSurface.copyFrom(mSurfaceControl);&#125; [-&gt;WindowStateAnimator.java] 123456789101112 WindowSurfaceController createSurfaceLocked() &#123; ...... try &#123; ...... mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession, attrs.getTitle().toString(), width, height, format, flags, this); w.setHasSurface(true); &#125; ...... return mSurfaceController;&#125; [-&gt;WindowSurfaceController.java] 123456789101112131415public WindowSurfaceController(SurfaceSession s, String name, int w, int h, int format, int flags, WindowStateAnimator animator) &#123; mAnimator = animator; mSurfaceW = w; mSurfaceH = h; ...... if (animator.mWin.isChildWindow() &amp;&amp; animator.mWin.mSubLayer &lt; 0 &amp;&amp; animator.mWin.mAppToken != null) &#123; ...... &#125; else &#123; mSurfaceControl = new SurfaceControl( s, name, w, h, format, flags); &#125;&#125; 4.2.4.1ã€APPç”³è¯·åˆ›å»ºSurfaceè¿‡ç¨‹(C++å±‚)SurfaceControlåˆ›å»ºè¿‡ç¨‹ [-&gt;SurfaceControl.java] 1234567 public SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags) throws OutOfResourcesException &#123; ...... mNativeObject = nativeCreate(session, name, w, h, format, flags); ......&#125; [-&gt;android_view_SurfaceControl.cpp] 12345678910111213static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags) &#123;ScopedUtfChars name(env, nameStr);sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface( String8(name.c_str()), w, h, format, flags);if (surface == NULL) &#123; jniThrowException(env, OutOfResourcesException, NULL); return 0;&#125;surface-&gt;incStrong((void *)nativeCreate);return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; è¯¥å‡½æ•°é¦–å…ˆå¾—åˆ°å‰é¢åˆ›å»ºå¥½çš„SurfaceComposerClientå¯¹è±¡ï¼Œé€šè¿‡è¯¥å¯¹è±¡å‘SurfaceFlingerç«¯çš„Clientå¯¹è±¡å‘é€åˆ›å»ºSurfaceçš„è¯·æ±‚ï¼Œæœ€åå¾—åˆ°ä¸€ä¸ªSurfaceControlå¯¹è±¡ã€‚ [-&gt;SurfaceComposerClient.cpp] 1234567891011121314151617181920sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) &#123;sp&lt;SurfaceControl&gt; sur;if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp); ALOGE_IF(err, \"SurfaceComposerClient::createSurface error %s\", strerror(-err)); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp); &#125;&#125;return sur;&#125; SurfaceComposerClientå°†Surfaceåˆ›å»ºè¯·æ±‚è½¬äº¤ç»™ä¿å­˜åœ¨å…¶æˆå‘˜å˜é‡ä¸­çš„Bp SurfaceComposerClientå¯¹è±¡æ¥å®Œæˆï¼Œåœ¨SurfaceFlingerç«¯çš„Clientæœ¬åœ°å¯¹è±¡ä¼šè¿”å›ä¸€ä¸ªISurfaceä»£ç†å¯¹è±¡ç»™åº”ç”¨ç¨‹åºï¼Œé€šè¿‡è¯¥ä»£ç†å¯¹è±¡ä¸ºåº”ç”¨ç¨‹åºå½“å‰åˆ›å»ºçš„Surfaceåˆ›å»ºä¸€ä¸ªSurfaceControlå¯¹è±¡ã€‚ [ISurfaceComposerClient.cpp] 1234567891011 virtual status_t createSurface(const String8&amp; name, uint32_t width, uint32_t height, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) &#123; Parcel data, reply; ...... remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply); *handle = reply.readStrongBinder(); *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder()); return reply.readInt32();&#125; [Client.cpp] MessageCreateSurfaceæ¶ˆæ¯æ˜¯ä¸“é—¨ä¸ºåº”ç”¨ç¨‹åºè¯·æ±‚åˆ›å»ºSurfaceè€Œå®šä¹‰çš„ä¸€ç§æ¶ˆæ¯ç±»å‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 status_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; /* * createSurface must be called from the GL thread so that it can * have access to the GL context. */ class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), result(NO_ERROR), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult(); &#125;Clientå°†åº”ç”¨ç¨‹åºåˆ›å»ºSurfaceçš„è¯·æ±‚è½¬æ¢ä¸ºå¼‚æ­¥æ¶ˆæ¯æŠ•é€’åˆ°SurfaceFlingerçš„æ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œå°†åˆ›å»ºSurfaceçš„ä»»åŠ¡è½¬äº¤ç»™SurfaceFlingerã€‚[-&gt;SurfaceFlinger.cpp] status_t SurfaceFlinger::createLayer( const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; //ALOGD(\"createLayer for (%d x %d), name=%s\", w, h, name.string()); ...... status_t result = NO_ERROR; sp&lt;Layer&gt; layer; ////æ ¹æ®flagsåˆ›å»ºä¸åŒç±»å‹çš„layer switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123; case ISurfaceComposerClient::eFXSurfaceNormal: result = createNormalLayer(client, name, w, h, flags, format, handle, gbp, &amp;layer); break; case ISurfaceComposerClient::eFXSurfaceDim: result = createDimLayer(client, name, w, h, flags, handle, gbp, &amp;layer); break; default: result = BAD_VALUE; break; &#125; if (result != NO_ERROR) &#123; return result; &#125; //å°†åˆ›å»ºå¥½çš„Layerå¯¹è±¡ä¿å­˜åœ¨Clientä¸­ result = addClientLayer(client, *handle, *gbp, layer); if (result != NO_ERROR) &#123; return result; &#125; setTransactionFlags(eTransactionNeeded); return result; &#125; SurfaceFlingeræ ¹æ®æ ‡å¿—ä½åˆ›å»ºå¯¹åº”ç±»å‹çš„Surfaceï¼Œå½“å‰ç³»ç»Ÿå®šä¹‰äº†3ç§ç±»å‹çš„Layer: [-&gt;ISurfaceComposerClient.h] 123eFXSurfaceNormal = 0x00000000,eFXSurfaceDim = 0x00020000,eFXSurfaceMask = 0x000F0000 [-&gt;SurfaceFlinger.cpp] 123456789101112131415161718192021222324status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;// initialize the surfacesswitch (format) &#123;case PIXEL_FORMAT_TRANSPARENT:case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break;case PIXEL_FORMAT_OPAQUE: format = PIXEL_FORMAT_RGBX_8888; break;&#125;//åœ¨SurfaceFlingerç«¯ä¸ºåº”ç”¨ç¨‹åºçš„Surfaceåˆ›å»ºå¯¹åº”çš„Layerå¯¹è±¡ *outLayer = new Layer(this, client, name, w, h, flags);status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);if (err == NO_ERROR) &#123; *handle = (*outLayer)-&gt;getHandle(); *gbp = (*outLayer)-&gt;getProducer();&#125;ALOGE_IF(err, \"createNormalLayer() failed (%s)\", strerror(-err));return err;&#125; åœ¨SurfaceFlingeræœåŠ¡ç«¯ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºçš„Surfaceåˆ›å»ºå¯¹åº”çš„Layerå¯¹è±¡ã€‚åº”ç”¨ç¨‹åºè¯·æ±‚åˆ›å»ºSurfaceè¿‡ç¨‹å¦‚ä¸‹ï¼šç¬¬ä¸€æ¬¡å¼ºå¼•ç”¨Layerå¯¹è±¡æ—¶ï¼ŒonFirstRef()å‡½æ•°è¢«å›è°ƒ [Layer.cpp] 123456789101112131415161718192021void Layer::onFirstRef() &#123;// Creates a custom BufferQueue for SurfaceFlingerConsumer to usesp&lt;IGraphicBufferProducer&gt; producer;sp&lt;IGraphicBufferConsumer&gt; consumer;//åˆ›å»ºBufferQueueå¯¹è±¡BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);mProducer = new MonitoredProducer(producer, mFlinger);mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this);mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);mSurfaceFlingerConsumer-&gt;setName(mName);#ifdef TARGET_DISABLE_TRIPLE_BUFFERING#warning \"disabling triple buffering\"#elsemProducer-&gt;setMaxDequeuedBufferCount(2);#endifconst sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());updateTransformHint(hw);&#125; æ ¹æ®bufferå¯ç”¨ç›‘å¬å™¨çš„æ³¨å†Œè¿‡ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå½“ç”Ÿäº§è€…ä¹Ÿå°±æ˜¯åº”ç”¨ç¨‹åºå¡«å……å¥½å›¾å½¢bufferæ•°æ®åï¼Œé€šè¿‡å›è°ƒæ–¹å¼é€šçŸ¥æ¶ˆè´¹è€…çš„ 4.2.4.2ã€BufferQueueæ„é€ è¿‡ç¨‹[-&gt;BufferQueue.cpp] 1234567891011void BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;......sp&lt;BufferQueueCore&gt; core(new BufferQueueCore(allocator));sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core));*outProducer = producer;*outConsumer = consumer;&#125; [-&gt;BufferQueueCore.cpp] æ‰€ä»¥æ ¸å¿ƒéƒ½æ˜¯è¿™ä¸ªBufferQueueCoreï¼Œä»–æ˜¯ç®¡ç†å›¾å½¢ç¼“å†²åŒºçš„ä¸­æ¢ã€‚ 123456789101112131415161718192021BufferQueueCore::BufferQueueCore(const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :mAllocator(allocator),......&#123;if (allocator == NULL) &#123; sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService()); mAllocator = composer-&gt;createGraphicBufferAlloc(); if (mAllocator == NULL) &#123; BQ_LOGE(\"createGraphicBufferAlloc failed\"); &#125;&#125;int numStartingBuffers = getMaxBufferCountLocked();for (int s = 0; s &lt; numStartingBuffers; s++) &#123; mFreeSlots.insert(s);&#125;for (int s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; mUnusedSlots.push_front(s);&#125;&#125; BufferQueueCoreç±»ä¸­å®šä¹‰äº†ä¸€ä¸ª64é¡¹çš„æ•°æ®mSlotsï¼Œæ˜¯ä¸€ä¸ªå®¹é‡å¤§å°ä¸º64çš„æ•°ç»„ï¼Œå› æ­¤BufferQueueCoreå¯ä»¥ç®¡ç†æœ€å¤š64å—çš„GraphicBufferã€‚ [-&gt;ISurfaceComposer.cpp] 1234567 virtual sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()&#123; Parcel data, reply; data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor()); remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply); return interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());&#125; [-&gt;SurfaceFlinger.cpp] 12345sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()&#123;sp&lt;GraphicBufferAlloc&gt; gba(new GraphicBufferAlloc());return gba;&#125; GraphicBufferAllocæ„é€ è¿‡ç¨‹ [-&gt;GraphicBufferAlloc.cpp] 123456789sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t width, uint32_t height, PixelFormat format, uint32_t usage, std::string requestorName, status_t* error) &#123;sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer( width, height, format, usage, std::move(requestorName)));status_t err = graphicBuffer-&gt;initCheck();......return graphicBuffer;&#125; å›¾å½¢ç¼“å†²åŒºåˆ›å»ºè¿‡ç¨‹ [-&gt;GraphicBuffer.cpp] 1234567891011121314GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat, uint32_t inUsage, std::string requestorName): BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()), mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(0) &#123;width =height =stride =format =usage = 0;handle = NULL;mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage, std::move(requestorName)); &#125; æ ¹æ®å›¾å½¢bufferçš„å®½é«˜ã€æ ¼å¼ç­‰ä¿¡æ¯ä¸ºå›¾å½¢ç¼“å†²åŒºåˆ†é…å­˜å‚¨ç©ºé—´ã€‚ ä½¿ç”¨GraphicBufferAllocatorå¯¹è±¡æ¥ä¸ºå›¾å½¢ç¼“å†²åŒºåˆ†é…å†…å­˜ç©ºé—´ï¼ŒGraphicBufferAllocatoræ˜¯å¯¹Grallocæ¨¡å—ä¸­çš„gpuè®¾å¤‡çš„å°è£…ç±»ã€‚å…³äºGraphicBufferAllocatorå†…å­˜åˆ†é…è¿‡ç¨‹è¯·ä»¥åä½œåˆ†æï¼Œå›¾å½¢ç¼“å†²åŒºåˆ†é…å®Œæˆåï¼Œè¿˜ä¼šæ˜ å°„åˆ°SurfaceFlingeræœåŠ¡è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚ Androidå›¾å½¢ç¼“å†²åŒºåˆ†é…è¿‡ç¨‹æºç åˆ†æ [-&gt;Layer.cpp] 123456789101112131415Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags): contentDirty(false), sequence(uint32_t(android_atomic_inc(&amp;sSequence))), mFlinger(flinger), mTextureName(-1U), mPremultipliedAlpha(true), mName(\"unnamed\"), mFormat(PIXEL_FORMAT_NONE), ......&#123;mCurrentCrop.makeInvalid();mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);......&#125; åˆ°æ­¤æ‰ç®—çœŸæ­£åˆ›å»ºäº†ä¸€ä¸ªå¯ç”¨äºç»˜å›¾çš„Surface (Layer)ï¼Œä»ä¸Šé¢çš„åˆ†ææˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œåœ¨WMSæœåŠ¡è¿›ç¨‹ç«¯ï¼Œå…¶å®åˆ›å»ºäº†ä¸¤ä¸ªJavaå±‚çš„Surfaceå¯¹è±¡ï¼Œç¬¬ä¸€ä¸ªSurfaceä½¿ç”¨äº†æ— å‚æ„é€ å‡½æ•°ï¼Œä»…ä»…æ„é€ ä¸€ä¸ªSurfaceå¯¹è±¡è€Œå·²ï¼Œè€Œç¬¬äºŒä¸ªSurfaceå´ä½¿ç”¨äº†æœ‰å‚æ„é€ å‡½æ•°ï¼Œå‚æ•°æŒ‡å®šäº†å›¾è±¡å®½é«˜ç­‰ä¿¡æ¯ï¼Œè¿™ä¸ªJavaå±‚Surfaceå¯¹è±¡è¿˜ä¼šåœ¨nativeå±‚è¯·æ±‚SurfaceFlingeråˆ›å»ºä¸€ä¸ªçœŸæ­£èƒ½ç”¨äºç»˜åˆ¶å›¾è±¡çš„nativeå±‚Surfaceã€‚æœ€åé€šè¿‡æµ…æ‹·è´çš„æ–¹å¼å°†ç¬¬äºŒä¸ªSurfaceå¤åˆ¶åˆ°ç¬¬ä¸€ä¸ªSurfaceä¸­ï¼Œæœ€åé€šè¿‡writeToParcelæ–¹å¼å†™å›åˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåº”ç”¨ç¨‹åºå’ŒWMSä¸€å…±åˆ›å»ºäº†3ä¸ªJavaå±‚Surfaceï¼ˆSurfaceControlï¼‰å¯¹è±¡ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œè€ŒçœŸæ­£èƒ½ç”¨äºç»˜å›¾çš„Surfaceåªæœ‰3å·ï¼Œé‚£ä¹ˆ3å·Surfaceä¸2å·Surfaceä¹‹é—´æ˜¯ä»€ä¹ˆå…³ç³»å‘¢ï¼ŸoutSurface.copyFrom(surface) [Surface.java] 12345678910111213 public void copyFrom(SurfaceControl other) &#123; ...... long surfaceControlPtr = other.mNativeObject; ...... long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr); synchronized (mLock) &#123; if (mNativeObject != 0) &#123; nativeRelease(mNativeObject); &#125; setNativeObjectLocked(newNativeObject); &#125;&#125; [android_view_Surface.cpp] 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 2å·Surfaceå¼•ç”¨åˆ°äº†3å·Surfaceçš„SurfaceControlå¯¹è±¡åï¼Œé€šè¿‡writeToParcel()å‡½æ•°å†™ä¼šåˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ [Surface.java] 12345678910111213141516 @Overridepublic void writeToParcel(Parcel dest, int flags) &#123; if (dest == null) &#123; throw new IllegalArgumentException(\"dest must not be null\"); &#125; synchronized (mLock) &#123; // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp dest.writeString(mName); dest.writeInt(mIsSingleBuffered ? 1 : 0); nativeWriteToParcel(mNativeObject, dest); &#125; if ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) &#123; release(); &#125;&#125; [android_view_Surface.cpp] 12345678910111213141516static void nativeWriteToParcel(JNIEnv* env, jclass clazz, jlong nativeObject, jobject parcelObj) &#123;Parcel* parcel = parcelForJavaObject(env, parcelObj);if (parcel == NULL) &#123; doThrowNPE(env); return;&#125;sp&lt;Surface&gt; self(reinterpret_cast&lt;Surface *&gt;(nativeObject));android::view::Surface surfaceShim;if (self != nullptr) &#123; surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();&#125;// Calling code in Surface.java has already written the name of the Surface// to the ParcelsurfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);&#125; åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­çš„1å·SurfaceæŒ‰ç›¸åé¡ºåºè¯»å–WMSæœåŠ¡ç«¯è¿”å›è¿‡æ¥çš„Binderå¯¹è±¡ç­‰æ•°æ®ï¼Œå¹¶æ„é€ ä¸€ä¸ªnativeå±‚çš„Surfaceå¯¹è±¡ã€‚ 1234567891011121314151617 public void readFromParcel(Parcel source) &#123; if (source == null) &#123; throw new IllegalArgumentException(\"source must not be null\"); &#125; synchronized (mLock) &#123; // nativeReadFromParcel() will either return mNativeObject, or // create a new native Surface and return it after reducing // the reference count on mNativeObject. Either way, it is // not necessary to call nativeRelease() here. // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp mName = source.readString(); mIsSingleBuffered = source.readInt() != 0; setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source)); &#125;&#125; åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­çš„1å·SurfaceæŒ‰ç›¸åé¡ºåºè¯»å–WMSæœåŠ¡ç«¯è¿”å›è¿‡æ¥çš„Binderå¯¹è±¡ç­‰æ•°æ®ï¼Œå¹¶æ„é€ ä¸€ä¸ªnativeå±‚çš„Surfaceå¯¹è±¡ã€‚ 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; æ¯ä¸ªActivityå¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªSurfaceï¼Œé»˜è®¤æƒ…å†µä¸‹ä¸€ä¸ªActivityåªæœ‰ä¸€ä¸ªSurfaceï¼Œå½“Activityä¸­ä½¿ç”¨SurfaceViewæ—¶ï¼Œå°±å­˜åœ¨å¤šä¸ªSurfaceã€‚Activityé»˜è®¤surfaceæ˜¯åœ¨relayoutWindowè¿‡ç¨‹ä¸­ç”±WMSæœåŠ¡åˆ›å»ºçš„ï¼Œç„¶åå›ä¼ ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ä¸€ä¸ªSurfaceå…¶å®å°±æ˜¯åº”ç”¨ç¨‹åºç«¯çš„æœ¬åœ°çª—å£ï¼Œå…³äºSurfaceçš„åˆå§‹åŒ–è¿‡ç¨‹è¿™é‡Œå°±ä¸åœ¨ä»‹ç»ã€‚ 4.2.4.2ã€ç”Ÿäº§è€…Produceræ„é€ è¿‡ç¨‹12sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core)); å®ä¾‹åŒ–BufferQueueProducerï¼Œè¿™é‡Œåˆå§‹åŒ–äº†mCore(core) å’Œ mSlots(core-&gt;mSlots) 1234567891011BufferQueueProducer::BufferQueueProducer(const sp&lt;BufferQueueCore&gt;&amp; core) : mCore(core), mSlots(core-&gt;mSlots), mConsumerName(), mStickyTransform(0), mLastQueueBufferFence(Fence::NO_FENCE), mCallbackMutex(), mNextCallbackTicket(0), mCurrentCallbackTicket(0), mCallbackCondition(), mDequeueTimeout(-1) &#123;&#125; 4.2.4.3ã€æ¶ˆè´¹è€…Consumeræ„é€ è¿‡ç¨‹12sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core)); å®ä¾‹åŒ–BufferQueueConsumerï¼Œè¿™é‡Œåˆå§‹åŒ–äº†mCore(core) å’Œ mSlots(core-&gt;mSlots) 1234BufferQueueConsumer::BufferQueueConsumer(const sp&lt;BufferQueueCore&gt;&amp; core) : mCore(core), mSlots(core-&gt;mSlots), mConsumerName() &#123;&#125; 4.2.4.4ã€SurfaceFlingerè®¾ç½®ç›‘å¬12345mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this);mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);mSurfaceFlingerConsumer-&gt;setName(mName); 4.2.4.5ã€åº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceåˆ›å»ºè¿‡ç¨‹ä»å‰é¢åˆ†æå¯çŸ¥ï¼ŒSurfaceFlingeråœ¨å¤„ç†åº”ç”¨ç¨‹åºè¯·æ±‚åˆ›å»ºSurfaceä¸­ï¼Œåœ¨SurfaceFlingeræœåŠ¡ç«¯ä»…ä»…åˆ›å»ºäº†Layerå¯¹è±¡ï¼Œé‚£ä¹ˆåº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceåœ¨ä»€ä¹ˆæ—¶å€™ã€ä»€ä¹ˆåœ°æ–¹åˆ›å»ºå‘¢ï¼Ÿ ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºå¥½äº†Layerå¯¹è±¡å¹¶è¿”å›ISurfaceçš„ä»£ç†å¯¹è±¡ç»™åº”ç”¨ç¨‹åºï¼Œåº”ç”¨ç¨‹åºé€šè¿‡è¯¥ä»£ç†å¯¹è±¡åˆ›å»ºäº†ä¸€ä¸ªSurfaceControlå¯¹è±¡ï¼ŒJavaå±‚Surfaceéœ€è¦é€šè¿‡android_view_Surface.cppä¸­çš„JNIå‡½æ•°æ¥æ“ä½œnativeå±‚çš„Surfaceï¼Œåœ¨æ“ä½œnativeå±‚Surfaceå‰ï¼Œé¦–å…ˆéœ€è¦è·å–åˆ°nativeçš„Surfaceï¼Œåº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceå°±æ˜¯åœ¨è¿™ä¸ªæ—¶å€™åˆ›å»ºçš„ã€‚ [-&gt;SurfaceControl.cpp] 12345678910sp&lt;Surface&gt; SurfaceControl::getSurface() const&#123;Mutex::Autolock _l(mLock);if (mSurfaceData == 0) &#123; // This surface is always consumed by SurfaceFlinger, so the // producerControlledByApp value doesn't matter; using false. mSurfaceData = new Surface(mGraphicBufferProducer, false);&#125;return mSurfaceData;&#125; [Surface.cpp] 1234567891011121314151617181920212223242526272829303132333435Surface::Surface( const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp): mGraphicBufferProducer(bufferProducer), mCrop(Rect::EMPTY_RECT), mGenerationNumber(0), mSharedBufferMode(false), mAutoRefresh(false), mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT), mSharedBufferHasBeenQueued(false), mNextFrameNumber(1) &#123;// Initialize the ANativeWindow function pointers.ANativeWindow::setSwapInterval = hook_setSwapInterval;ANativeWindow::dequeueBuffer = hook_dequeueBuffer;ANativeWindow::cancelBuffer = hook_cancelBuffer;ANativeWindow::queueBuffer = hook_queueBuffer;ANativeWindow::query = hook_query;ANativeWindow::perform = hook_perform;ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;ANativeWindow::cancelBuffer_DEPRECATED = hook_cancelBuffer_DEPRECATED;ANativeWindow::lockBuffer_DEPRECATED = hook_lockBuffer_DEPRECATED;ANativeWindow::queueBuffer_DEPRECATED = hook_queueBuffer_DEPRECATED;const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;mReqWidth = 0;mReqHeight = 0;mReqFormat = 0;mReqUsage = 0;......mSwapIntervalZero = false;&#125; åœ¨åˆ›å»ºå®Œåº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceåï¼Œæƒ³è¦åœ¨è¯¥Surfaceä¸Šç»˜å›¾ï¼Œé¦–å…ˆéœ€è¦ä¸ºè¯¥Surfaceåˆ†é…å›¾å½¢bufferã€‚æˆ‘ä»¬å‰é¢ä»‹ç»äº†Androidåº”ç”¨ç¨‹åºå›¾å½¢ç¼“å†²åŒºçš„åˆ†é…éƒ½æ˜¯ç”±SurfaceFlingeræœåŠ¡è¿›ç¨‹æ¥å®Œæˆï¼Œåœ¨è¯·æ±‚åˆ›å»ºSurfaceæ—¶ï¼Œåœ¨æœåŠ¡ç«¯åˆ›å»ºäº†ä¸€ä¸ªBufferQueueæœ¬åœ°Binderå¯¹è±¡ï¼Œè¯¥å¯¹è±¡è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºä¸€ä¸ªæœ¬åœ°çª—å£Surfaceçš„å›¾å½¢ç¼“å†²åŒºã€‚ 4.2.4.5ã€æ‰§è¡Œçª—å£å¸ƒå±€performLayout()[-&gt;ViewRootImpl.java] 1234567891011121314151617181920 private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; ...... measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ...... &#125; mInLayout = false;&#125; 4.2.4.7ã€æ‰§è¡Œçª—å£ç»˜åˆ¶performDraw()12345678[-&gt;ViewRootImpl.java]private void performDraw() &#123; ...... try &#123; draw(fullRedrawNeeded); &#125; ...... &#125; &#125; Androidæ˜¯æ€æ ·å°†Viewç”»å‡ºæ¥çš„ï¼Ÿç”±äºä¹‹å‰æˆ‘ä»¬å·²ç»å…³é—­äº†HWCã€GPUã€HWUIï¼Œè¿™é‡Œåªå…³æ³¨è½¯ä»¶ç»˜åˆ¶ã€‚ [-&gt;ViewRootImpl.java] 123456789101112131415 private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ...... if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; ...... &#125; else &#123; ...... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; .....&#125; å…³äºæ¸²æŸ“è¿™ä¸ªæµç¨‹å¾ˆå¤æ‚ï¼Œæˆ‘ä»¬åç»­ç« èŠ‚å†åˆ†æã€‚ 4.3ã€APPç”³è¯·(lock)Bufferçš„è¿‡ç¨‹ 1234567891011121314151617181920212223242526272829303132 private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; ...... canvas = mSurface.lockCanvas(dirty); ...... &#125; ...... try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125;...... &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; ...... return false; &#125; &#125; return true;&#125; å…ˆçœ‹çœ‹Surfaceçš„lockCanvasæ–¹æ³•ï¼š [-&gt;Surface.java] 1234567891011//mCanvas å˜é‡ç›´æ¥èµ‹å€¼private final Canvas mCanvas = new CompatibleCanvas();public Canvas lockCanvas(Rect inOutDirty) throws Surface.OutOfResourcesException, IllegalArgumentException &#123;synchronized (mLock) &#123; checkNotReleasedLocked(); ...... mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); return mCanvas;&#125;&#125; [-&gt;android_view_Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static jlong nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123; //è·å–javaå±‚çš„Surfaceä¿å­˜çš„longå‹å¥æŸ„sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; doThrowIAE(env); return 0;&#125;Rect dirtyRect(Rect::EMPTY_RECT);Rect* dirtyRectPtr = NULL;//è·å–javaå±‚dirty Rectçš„ä½ç½®å¤§å°ä¿¡æ¯if (dirtyRectObj) &#123; dirtyRect.left = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left); dirtyRect.top = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top); dirtyRect.right = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right); dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom); dirtyRectPtr = &amp;dirtyRect;&#125;ANativeWindow_Buffer outBuffer; //è°ƒç”¨Surfaceçš„lockæ–¹æ³•,å°†ç”³è¯·çš„å›¾å½¢ç¼“å†²åŒºèµ‹ç»™outBufferstatus_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);......SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height, convertPixelFormat(outBuffer.format), outBuffer.format == PIXEL_FORMAT_RGBX_8888 ? kOpaque_SkAlphaType : kPremul_SkAlphaType);SkBitmap bitmap;//åˆ›å»ºä¸€ä¸ªSkBitmap//å›¾å½¢ç¼“å†²åŒºæ¯ä¸€è¡Œåƒç´ å¤§å°ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);bitmap.setInfo(info, bpr);if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123; bitmap.setPixels(outBuffer.bits);&#125; else &#123; // be safe with an empty bitmap. bitmap.setPixels(NULL);&#125;Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(bitmap);if (dirtyRectPtr) &#123; nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top, dirtyRect.right, dirtyRect.bottom);&#125;if (dirtyRectObj) &#123; env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left, dirtyRect.left); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top, dirtyRect.top); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right, dirtyRect.right); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);&#125;......sp&lt;Surface&gt; lockedSurface(surface);lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);return (jlong) lockedSurface.get();&#125; è¿™æ®µä»£ç é€»è¾‘ä¸»è¦å¦‚ä¸‹ï¼š 1ï¼‰è·å–javaå±‚dirty çš„Rectå¤§å°å’Œä½ç½®ä¿¡æ¯ï¼› 2ï¼‰è°ƒç”¨Surfaceçš„lockæ–¹æ³•,å°†ç”³è¯·çš„å›¾å½¢ç¼“å†²åŒºèµ‹ç»™outBufferï¼› 3ï¼‰åˆ›å»ºä¸€ä¸ªSkbitmapï¼Œå¡«å……å®ƒç”¨æ¥ä¿å­˜ç”³è¯·çš„å›¾å½¢ç¼“å†²åŒºï¼Œå¹¶èµ‹å€¼ç»™Javaå±‚çš„Canvaså¯¹è±¡ï¼› 4ï¼‰å°†å‰ªè£ä½ç½®å¤§å°ä¿¡æ¯èµ‹ç»™javaå±‚Canvaså¯¹è±¡ã€‚ 4.3.1ã€Surfaceç®¡ç†å›¾å½¢ç¼“å†²åŒº-APPç”³è¯·(lock)Bufferçš„è¿‡ç¨‹æˆ‘ä»¬ä¸Šè¾¹åˆ†æåˆ°äº†ç”³è¯·å›¾å½¢ç¼“å†²åŒºï¼Œç”¨åˆ°äº†Surfaceçš„lockå‡½æ•°ï¼Œæˆ‘ä»¬ç»§ç»­æŸ¥çœ‹ã€‚ [-&gt;Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384status_t Surface::lock( ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds) &#123;......ANativeWindowBuffer* out;int fenceFd = -1;//è°ƒç”¨dequeueBufferå‡½æ•°ï¼Œç”³è¯·å›¾å½¢ç¼“å†²åŒºstatus_t err = dequeueBuffer(&amp;out, &amp;fenceFd);ALOGE_IF(err, \"dequeueBuffer failed (%s)\", strerror(-err));if (err == NO_ERROR) &#123; //è·å–å›¾å½¢ç¼“å†²åŒºåŒºåŸŸå¤§å°,èµ‹ç»™åå¤‡ç¼“å†²åŒºå˜é‡backBuffer sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out)); const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height); Region newDirtyRegion; if (inOutDirtyBounds) &#123; //å¦‚æœä¸Šå±‚æŒ‡å®šä¹åˆ·æ–°è„çŸ©å½¢åŒºåŸŸï¼Œåˆ™ç”¨è¿™ä¸ªåŒºåŸŸå’Œç¼“å†²åŒºåŒºåŸŸæ±‚äº¤é›†ï¼Œ //ç„¶åå°†äº¤é›†çš„ç»“æœè®¾ç»™éœ€è¦å»åˆ·æ–°çš„æ–°åŒºåŸŸ newDirtyRegion.set(static_cast&lt;Rect const&amp;&gt;(*inOutDirtyBounds)); newDirtyRegion.andSelf(bounds); &#125; else &#123; /å¦‚æœä¸Šå±‚æ²¡æœ‰æŒ‡å®šè„çŸ©å½¢åŒºåŸŸï¼Œæ‰€ä»¥åˆ·æ–°æ•´ä¸ªå›¾å½¢ç¼“å†²åŒº newDirtyRegion.set(bounds); &#125; // figure out if we can copy the frontbuffer back //ä¸Šä¸€æ¬¡ç»˜åˆ¶çš„ä¿¡æ¯ä¿å­˜åœ¨mPostedBufferä¸­ï¼Œè€Œè¿™ä¸ªmPostedBufferåˆ™è¦åœ¨unLockAndPostå‡½æ•°ä¸­è®¾ç½® int backBufferSlot(getSlotFromBufferLocked(backBuffer.get())); const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); const bool canCopyBack = (frontBuffer != 0 &amp;&amp; backBuffer-&gt;width == frontBuffer-&gt;width &amp;&amp; backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp; backBuffer-&gt;format == frontBuffer-&gt;format); if (canCopyBack) &#123; Mutex::Autolock lock(mMutex); Region oldDirtyRegion; if(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123; oldDirtyRegion.set(bounds); &#125; else &#123; for(int i = 0 ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123; if(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty()) oldDirtyRegion.orSelf(mSlots[i].dirtyRegion); &#125; &#125; const Region copyback(oldDirtyRegion.subtract(newDirtyRegion)); if (!copyback.isEmpty()) //è¿™é‡ŒæŠŠmPostedBufferä¸­çš„æ—§æ•°æ®æ‹·è´åˆ°BackBufferä¸­ã€‚ //åç»­çš„ç»˜ç”»åªè¦æ›´æ–°è„åŒºåŸŸå°±å¯ä»¥äº†ï¼Œè¿™ä¼šèŠ‚çº¦ä¸å°‘èµ„æº copyBlt(backBuffer, frontBuffer, copyback); &#125; else &#123; // if we can't copy-back anything, modify the user's dirty // region to make sure they redraw the whole buffer //å¦‚æœä¸¤æ¬¡å›¾å½¢ç¼“å†²åŒºå¤§å°ä¸ä¸€è‡´ï¼Œæˆ‘ä»¬å°±è¦ä¿®æ”¹ç”¨æˆ·æŒ‡å®šçš„dirtyåŒºåŸŸå¤§å°ä¸ºæ•´ä¸ªç¼“å†²åŒºå¤§å°ï¼Œ //ç„¶åå»æ›´æ–°æ•´ä¸ªç¼“å†²åŒº newDirtyRegion.set(bounds); Mutex::Autolock lock(mMutex); for (size_t i=0 ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123; mSlots[i].dirtyRegion.clear(); &#125; &#125; &#123; // scope for the lock Mutex::Autolock lock(mMutex); //å°†æ–°çš„dirtyèµ‹ç»™è¿™ä¸ªbufferslot mSlots[backBufferSlot].dirtyRegion = newDirtyRegion; &#125; if (inOutDirtyBounds) &#123; *inOutDirtyBounds = newDirtyRegion.getBounds(); &#125; void* vaddr; //lockå’Œunlockåˆ†åˆ«ç”¨æ¥é”å®šå’Œè§£é”ä¸€ä¸ªæŒ‡å®šçš„å›¾å½¢ç¼“å†²åŒºï¼Œåœ¨è®¿é—®ä¸€å—å›¾å½¢ç¼“å†²åŒºçš„æ—¶å€™ï¼Œ //ä¾‹å¦‚ï¼Œå‘ä¸€å—å›¾å½¢ç¼“å†²å†™å…¥å†…å®¹çš„æ—¶å€™ï¼Œéœ€è¦å°†è¯¥å›¾å½¢ç¼“å†²åŒºé”å®šï¼Œç”¨æ¥é¿å…è®¿é—®å†²çª, //é”å®šä¹‹åï¼Œå°±å¯ä»¥è·å¾—ç”±å‚æ•°å‚æ•°lã€tã€wå’Œhæ‰€åœˆå®šçš„ä¸€å—ç¼“å†²åŒºçš„èµ·å§‹åœ°å€ï¼Œä¿å­˜åœ¨è¾“å‡ºå‚æ•°vaddrä¸­ status_t res = backBuffer-&gt;lockAsync( GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, newDirtyRegion.bounds(), &amp;vaddr, fenceFd); ......&#125;return err;&#125; Surfaceçš„lockå‡½æ•°ç”¨æ¥ç”³è¯·å›¾å½¢ç¼“å†²åŒºå’Œä¸€äº›æ“ä½œï¼Œæ–¹æ³•ä¸é•¿ï¼Œå¤§æ¦‚å·¥ä½œæœ‰ï¼š 1ï¼‰è°ƒç”¨connectå‡½æ•°å®Œæˆä¸€äº›åˆå§‹åŒ–ï¼› 2ï¼‰è°ƒç”¨dequeueBufferå‡½æ•°ï¼Œç”³è¯·å›¾å½¢ç¼“å†²åŒºï¼› 3ï¼‰è®¡ç®—éœ€è¦ç»˜åˆ¶çš„æ–°çš„dirtyåŒºåŸŸï¼Œæ—§çš„åŒºåŸŸåŸæ ·copyæ•°æ®ã€‚ [-&gt;BufferQueueProducer.cpp] 123456789101112131415161718192021222324252627int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;uint32_t reqWidth;uint32_t reqHeight;PixelFormat reqFormat;uint32_t reqUsage;&#123; ......//ç”³è¯·å›¾å½¢ç¼“å†²åŒºstatus_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight, reqFormat, reqUsage);......//æ ¹æ®indexè·å–ç¼“å†²åŒºsp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);......if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123; //ç”±äºç”³è¯·çš„å†…å­˜æ˜¯åœ¨surfaceflingerè¿›ç¨‹ä¸­ï¼Œ //BufferQueueä¸­çš„å›¾å½¢ç¼“å†²åŒºä¹Ÿæ˜¯é€šè¿‡åŒ¿åå…±äº«å†…å­˜å’Œbinderä¼ é€’æè¿°ç¬¦æ˜ å°„è¿‡å»çš„ï¼Œ //Surfaceé€šè¿‡è°ƒç”¨requestBufferå°†å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°Surfaceæ‰€åœ¨è¿›ç¨‹ result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf); ......&#125;......//è·å–è¿™ä¸ªè¿™ä¸ªbufferå¯¹è±¡çš„æŒ‡é’ˆå†…å®¹*buffer = gbuf.get();......return OK;&#125; [-&gt;BufferQueueProducer.cpp] 12345678910status_t BufferQueueProducer::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;ATRACE_CALL();Mutex::Autolock lock(mCore-&gt;mMutex);......mSlots[slot].mRequestBufferCalled = true;*buf = mSlots[slot].mGraphicBuffer;return NO_ERROR;&#125; è¿™ä¸ªæ¯”è¾ƒç®€å•ï¼Œè¿˜æ˜¯å¾ˆå¥½ç†è§£çš„é¢ï¼Œå°±æ˜¯æ ¹æ®æŒ‡å®šindexå–å‡ºmSlotsä¸­çš„slotä¸­çš„bufferã€‚ 4.4ã€APPæäº¤(unlockAndPost)Bufferçš„è¿‡ç¨‹Surfaceç»˜åˆ¶å®Œæ¯•åï¼ŒunlockCanvasAndPostæ“ä½œã€‚ [-&gt;android_view_Surface.cpp] 1234567891011121314151617static void nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj) &#123;sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; return;&#125;// detach the canvas from the surfaceCanvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(SkBitmap());// unlock surfacestatus_t err = surface-&gt;unlockAndPost();if (err &lt; 0) &#123; doThrowIAE(env);&#125;&#125; [-&gt;Surface.cpp] 123456789101112131415status_t Surface::unlockAndPost()&#123;......int fd = -1;//è§£é”å›¾å½¢ç¼“å†²åŒºï¼Œå’Œå‰é¢çš„lockAsyncæˆå¯¹å‡ºç°status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd);//queueBufferå»å½’è¿˜å›¾å½¢ç¼“å†²åŒºerr = queueBuffer(mLockedBuffer.get(), fd);mPostedBuffer = mLockedBuffer;mLockedBuffer = 0;return err;&#125; è¿™é‡Œä¹Ÿæ¯”è¾ƒç®€å•ï¼Œæ ¸å¿ƒä¹Ÿæ˜¯åˆ†ä¸¤æ­¥ï¼š 1ï¼‰è§£é”å›¾å½¢ç¼“å†²åŒºï¼Œå’Œå‰é¢çš„lockAsyncæˆå¯¹å‡ºç°ï¼› 2ï¼‰queueBufferå»å½’è¿˜å›¾å½¢ç¼“å†²åŒºï¼› æ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯é‡ç‚¹åˆ†æç¬¬äºŒæ­¥ï¼ŒæŸ¥çœ‹queueBufferçš„å®ç°ï¼š [-&gt;Surface.cpp] 1234567int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;......status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);mLastQueueDuration = systemTime() - now;......return err;&#125; è°ƒç”¨BufferQueueProducerçš„queueBufferå½’è¿˜ç¼“å†²åŒºï¼Œå°†ç»˜åˆ¶åçš„å›¾å½¢ç¼“å†²åŒºqueueå›å»ã€‚ [-&gt;BufferQueueProducer.cpp] 1234567891011121314151617181920status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;......&#123; // scope for the lock Mutex::Autolock lock(mCallbackMutex); while (callbackTicket != mCurrentCallbackTicket) &#123; mCallbackCondition.wait(mCallbackMutex); &#125; if (frameAvailableListener != NULL) &#123; frameAvailableListener-&gt;onFrameAvailable(item); &#125; else if (frameReplacedListener != NULL) &#123; frameReplacedListener-&gt;onFrameReplaced(item); &#125; ......&#125;......return NO_ERROR;&#125; æ€»ç»“ï¼š 1ï¼‰ä»ä¼ å…¥çš„QueueBufferInput ï¼Œè§£æå¡«å……ä¸€äº›å˜é‡ï¼› 2ï¼‰æ”¹å˜å…¥é˜ŸSlotçš„çŠ¶æ€ä¸ºQUEUEDï¼Œæ¯æ¬¡æ¨è¿›æ¥ï¼ŒmFrameCounteréƒ½åŠ 1ã€‚è¿™é‡Œçš„slotï¼Œä¸Šä¸€ç¯‡è®²åˆ†é…ç¼“å†²åŒºè¿”å›æœ€è€çš„FREEçŠ¶æ€bufferï¼Œå°±æ˜¯ç”¨è¿™ä¸ªmFrameCounteræœ€å°å€¼åˆ¤æ–­ï¼Œå°±æ˜¯ä¸Šä¸€ç¯‡LRUç®—æ³•çš„åˆ¤æ–­ï¼› 3ï¼‰åˆ›å»ºä¸€ä¸ªBufferItemæ¥æè¿°GraphicBufferï¼Œç”¨mSlots[slot]ä¸­çš„slotå¡«å……BufferItemï¼› 4ï¼‰å°†BufferItemå¡è¿›mCoreçš„mQueueé˜Ÿåˆ—ï¼Œä¾ç…§æŒ‡å®šè§„åˆ™ï¼› 5ï¼‰ç„¶åé€šçŸ¥SurfaceFlingerå»æ¶ˆè´¹ã€‚ Folwï¼š ï¼ˆäº”ï¼‰ã€é€šçŸ¥SFæ¶ˆè´¹åˆæˆå½“ç»˜åˆ¶å®Œæ¯•çš„GraphicBufferå…¥é˜Ÿä¹‹åï¼Œä¼šé€šçŸ¥SurfaceFlingerå»æ¶ˆè´¹ï¼Œå°±æ˜¯BufferQueueProducerçš„queueBufferå‡½æ•°çš„æœ€åå‡ è¡Œï¼Œlistener-&gt;onFrameAvailable()ã€‚ listeneræœ€ç»ˆé€šè¿‡å›è°ƒï¼Œä¼šå›åˆ°Layerå½“ä¸­ï¼Œæ‰€ä»¥æœ€ç»ˆè°ƒç”¨Layerçš„onFrameAvailableæ¥å£ï¼Œæˆ‘ä»¬çœ‹çœ‹å®ƒçš„å®ç°ï¼š [Layer.cpp] 123456789101112void Layer::onFrameAvailable(const BufferItem&amp; item) &#123;// Add this buffer from our internal queue tracker&#123; // Autolock scope ...... mQueueItems.push_back(item); android_atomic_inc(&amp;mQueuedFrames); // Wake up any pending callbacks mLastFrameNumberReceived = item.mFrameNumber; mQueueItemCondition.broadcast();&#125;mFlinger-&gt;signalLayerUpdate();&#125; è¿™é‡Œåˆè°ƒç”¨SurfaceFlingerçš„signalLayerUpdateå‡½æ•°ï¼Œç»§ç»­æŸ¥çœ‹ï¼š [SurfaceFlinger.cpp] 123void SurfaceFlinger::signalLayerUpdate() &#123;mEventQueue.invalidate();&#125; è¿™é‡Œåˆè°ƒç”¨MessageQueueçš„invalidateå‡½æ•°ï¼š [MessageQueue.cpp] 123void MessageQueue::invalidate() &#123;mEvents-&gt;requestNextVsync();&#125; è´´ä¸€ä¸‹SurfaceFlingerçš„åˆå§‹åŒ–è¯·æ±‚vsyncä¿¡å·æµç¨‹å›¾ï¼š æœ€ç»ˆç»“æœä¼šèµ°åˆ°SurfaceFlingerçš„vsyncä¿¡å·æ¥æ”¶é€»è¾‘ï¼Œå³SurfaceFlingerçš„onMessageReceivedå‡½æ•°ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930void SurfaceFlinger::onMessageReceived(int32_t what) &#123;ATRACE_CALL();switch (what) &#123; case MessageQueue::INVALIDATE: &#123; bool frameMissed = !mHadClientComposition &amp;&amp; mPreviousPresentFence != Fence::NO_FENCE &amp;&amp; mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX; ATRACE_INT(\"FrameMissed\", static_cast&lt;int&gt;(frameMissed)); if (mPropagateBackpressure &amp;&amp; frameMissed) &#123; signalLayerUpdate(); break; &#125; bool refreshNeeded = handleMessageTransaction(); refreshNeeded |= handleMessageInvalidate(); refreshNeeded |= mRepaintEverything; if (refreshNeeded) &#123; // Signal a refresh if a transaction modified the window state, // a new buffer was latched, or if HWC has requested a full // repaint signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125;&#125;&#125; SurfaceFlingeræ”¶åˆ°äº†VSyncä¿¡å·åï¼Œè°ƒç”¨äº†handleMessageRefreshå‡½æ•° [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627void SurfaceFlinger::handleMessageRefresh() &#123;ATRACE_CALL();nsecs_t refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime);mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);mHadClientComposition = false;for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123; const sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId]; mHadClientComposition = mHadClientComposition || mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());&#125;// Release any buffers which were replaced this framefor (auto&amp; layer : mLayersWithQueuedFrames) &#123; layer-&gt;releasePendingBuffer();&#125;mLayersWithQueuedFrames.clear();&#125; æˆ‘ä»¬ä¸»è¦çœ‹ä¸‹ä¸‹é¢å‡ ä¸ªå‡½æ•°ã€‚ [SurfaceFlinger.cpp] 123456preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime); ä¸€ã€preComposition()å‡½æ•°æˆ‘ä»¬å…ˆæ¥çœ‹ç¬¬ä¸€ä¸ªå‡½æ•°preComposition() [SurfaceFlinger.cpp] 1234567891011121314void SurfaceFlinger::preComposition()&#123;bool needExtraInvalidate = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);const size_t count = layers.size();for (size_t i=0 ; i&lt;count ; i++) &#123; if (layers[i]-&gt;onPreComposition()) &#123; needExtraInvalidate = true; &#125;&#125;if (needExtraInvalidate) &#123; signalLayerUpdate();&#125;&#125; ä¸Šé¢å‡½æ•°å…ˆæ˜¯è°ƒç”¨äº†mDrawingStateçš„layersSortedByZæ¥å¾—åˆ°ä¸Šæ¬¡ç»˜å›¾çš„Layerå±‚åˆ—è¡¨ã€‚å¹¶ä¸æ˜¯æ‰€æœ‰çš„Layeréƒ½ä¼šå‚ä¸å±å¹•å›¾åƒçš„ç»˜åˆ¶ï¼Œå› æ­¤SurfaceFlingerç”¨stateå¯¹è±¡æ¥è®°å½•å‚ä¸ç»˜åˆ¶çš„Layerå¯¹è±¡ã€‚ è®°å¾—æˆ‘ä»¬ä¹‹å‰åˆ†æè¿‡createLayerå‡½æ•°æ¥åˆ›å»ºLayerï¼Œåˆ›å»ºä¹‹åä¼šè°ƒç”¨addClientLayerå‡½æ•°ã€‚ [SurfaceFlinger.cpp] 1234567891011121314151617181920status_t SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbc, const sp&lt;Layer&gt;&amp; lbc) &#123;// add this layer to the current state list&#123; Mutex::Autolock _l(mStateLock); if (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123; return NO_MEMORY; &#125; mCurrentState.layersSortedByZ.add(lbc); mGraphicBufferProducerList.add(IInterface::asBinder(gbc));&#125;// attach this layer to the clientclient-&gt;attachLayer(handle, lbc);return NO_ERROR;&#125; æˆ‘ä»¬æ¥çœ‹ä¸‹addClientLayerå‡½æ•°ï¼Œè¿™é‡Œä¼šæŠŠLayerå¯¹è±¡æ”¾åœ¨mCurrentStateçš„layersSortedByZå¯¹è±¡ä¸­ã€‚è€ŒmDrawingStateå’ŒmCurrentStateä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿåœ¨åé¢æˆ‘ä»¬ä¼šä»‹ç»ï¼ŒmDrawingStateä»£è¡¨ä¸Šä¸€æ¬¡ç»˜å›¾æ—¶çš„çŠ¶æ€ï¼Œå¤„ç†å®Œä¹‹åä¼šæŠŠmCurrentStateèµ‹ç»™mDrawingStateã€‚ å›åˆ°preCompositionå‡½æ•°ï¼Œéå†æ‰€æœ‰çš„Layerå¯¹è±¡ï¼Œè°ƒç”¨å…¶onPreCompositionå‡½æ•°æ¥æ£€æµ‹Layerå±‚ä¸­çš„å›¾åƒæ˜¯å¦æœ‰å˜åŒ–ã€‚ 1.1ã€æ¯ä¸ªLayerçš„onFrameAvailableå‡½æ•°onPreCompositionå‡½æ•°æ¥æ ¹æ®mQueuedFramesæ¥åˆ¤æ–­å›¾åƒæ˜¯å¦å‘ç”Ÿäº†å˜åŒ–ï¼Œæˆ–è€…æ˜¯mSidebandStreamChangedã€mAutoRefreshã€‚ [Layer.cpp] 1234bool Layer::onPreComposition() &#123;mRefreshPending = false;return mQueuedFrames &gt; 0 || mSidebandStreamChanged || mAutoRefresh;&#125; å½“Layeræ‰€å¯¹åº”çš„Surfaceæ›´æ–°å›¾åƒåï¼Œå®ƒæ‰€å¯¹åº”çš„Layerå¯¹è±¡çš„onFrameAvailableå‡½æ•°ä¼šè¢«è°ƒç”¨æ¥é€šçŸ¥è¿™ç§å˜åŒ–ã€‚ åœ¨SurfaceFlingerçš„preCompositionå‡½æ•°ä¸­å½“æœ‰Layerçš„å›¾åƒæ”¹å˜äº†ï¼Œæœ€åä¹Ÿä¼šè°ƒç”¨SurfaceFlingerçš„signalLayerUpdateå‡½æ•°ã€‚ SurfaceFlinger::signalLayerUpdateæ˜¯è°ƒç”¨äº†MessageQueueçš„invalidateå‡½æ•° æœ€åå¤„ç†è¿˜æ˜¯è°ƒç”¨äº†SurfaceFlingerçš„onMessageReceivedå‡½æ•°ã€‚çœ‹çœ‹SurfaceFlingerçš„onMessageReceivedå‡½æ•°å¯¹NVALIDATEçš„å¤„ç† handleMessageInvalidateå‡½æ•°ä¸­è°ƒç”¨äº†handlePageFlipå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å°†ä¼šå¤„ç†Layerä¸­çš„ç¼“å†²åŒºï¼ŒæŠŠæ›´æ–°è¿‡çš„å›¾åƒç¼“å†²åŒºåˆ‡æ¢åˆ°å‰å°ï¼Œç­‰å¾…VSyncä¿¡å·æ›´æ–°åˆ°FrameBufferã€‚ 1.2ã€ç»˜åˆ¶æµç¨‹ç”¨æˆ·è¿›ç¨‹æ›´æ–°Surfaceå›¾åƒï¼Œå°†å¯¼è‡´SurfaceFlingerä¸­çš„Layerå‘é€invalidateæ¶ˆæ¯ï¼Œå¤„ç†è¯¥æ¶ˆæ¯ä¼šè°ƒç”¨handleTransactionå‡½æ•°å’ŒhandlePageFilpå‡½æ•°æ¥æ›´æ–°Layerå¯¹è±¡ã€‚ä¸€æ—¦VSyncä¿¡å·åˆ°æ¥ï¼Œå†è°ƒç”¨rebuildlayerStacks setUpHWComposer doComposition postCompositionå‡½æ•°å°†æ‰€æœ‰Layerçš„å›¾åƒæ··åˆåæ›´æ–°åˆ°æ˜¾ç¤ºè®¾å¤‡ä¸Šå»ã€‚ äºŒã€handleTransaction handPageFlipæ›´æ–°Layerå¯¹è±¡åœ¨ä¸Šä¸€èŠ‚ä¸­çš„ç»˜å›¾çš„æµç¨‹ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†handleTransactionå’ŒhandPageFlipè¿™ä¸¤ä¸ªå‡½æ•°é€šå¸¸æ˜¯åœ¨ç”¨æˆ·è¿›ç¨‹æ›´æ–°Surfaceå›¾åƒæ—¶ä¼šè°ƒç”¨ï¼Œæ¥æ›´æ–°Layerå¯¹è±¡ã€‚è¿™èŠ‚å°±ä¸»è¦è®²è§£è¿™ä¸¤ä¸ªå‡½æ•°ã€‚ 2.1ã€handleTransactionå‡½æ•°handleTransactionå‡½æ•°çš„å‚æ•°æ˜¯transactionFlagsï¼Œä¸è¿‡å‡½æ•°ä¸­æ²¡æœ‰ä½¿ç”¨è¿™ä¸ªå‚æ•°ï¼Œè€Œæ˜¯é€šè¿‡getTransactionFlags(eTransactionMask)æ¥é‡æ–°å¯¹transactionFlagsèµ‹å€¼ï¼Œç„¶åä½¿ç”¨å®ƒä½œä¸ºå‚æ•°æ¥è°ƒç”¨å‡½æ•° handleTransactionLockedã€‚ [SurfaceFlinger.cpp] 123456789101112131415void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)&#123;ATRACE_CALL();Mutex::Autolock _l(mStateLock);const nsecs_t now = systemTime();mDebugInTransaction = now;transactionFlags = getTransactionFlags(eTransactionMask);handleTransactionLocked(transactionFlags);mLastTransactionTime = systemTime() - now;mDebugInTransaction = 0;invalidateHwcGeometry();&#125; getTransactionFlagså‡½æ•°çš„å‚æ•°æ˜¯eTransactionMaskåªæ˜¯å±è”½å…¶ä»–ä½ã€‚ handleTransactionLockedå‡½æ•°ä¼šè°ƒç”¨æ¯ä¸ªLayerç±»çš„doTransactionå‡½æ•°ï¼Œåœ¨åˆ†æhandleTransactionLockedå‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹Layerç±» çš„doTransactionå‡½æ•°ã€‚ 2.2ã€Layerçš„doTransactionå‡½æ•°ä¸‹é¢æ˜¯Layerçš„doTransactionå‡½æ•°ä»£ç  [Layer.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475uint32_t Layer::doTransaction(uint32_t flags) &#123;ATRACE_CALL();pushPendingState();//ä¸Šæ¬¡ç»˜åˆ¶çš„Stateå¯¹è±¡ Layer::State c = getCurrentState();//å½“å‰ä½¿ç”¨çš„Stateå¯¹è±¡const Layer::State&amp; s(getDrawingState());const bool sizeChanged = (c.requested.w != s.requested.w) || (c.requested.h != s.requested.h);if (sizeChanged) &#123; // the size changed, we need to ask our client to request a new buffer //å¦‚æœLayerçš„å°ºå¯¸å‘ç”Ÿå˜åŒ–ï¼Œå°±è¦æ”¹å˜Surfaceçš„ç¼“å†²åŒºçš„å°ºå¯¸ // record the new size, form this point on, when the client request // a buffer, it'll get the new size. mSurfaceFlingerConsumer-&gt;setDefaultBufferSize( c.requested.w, c.requested.h);&#125;const bool resizePending = (c.requested.w != c.active.w) || (c.requested.h != c.active.h);if (!isFixedSize()) &#123; if (resizePending &amp;&amp; mSidebandStream == NULL) &#123; //å¦‚æœLayerä¸æ˜¯å›ºå®šå°ºå¯¸çš„ç±»å‹ï¼Œæ¯”è¾ƒå®ƒçš„å®é™…å¤§å°å’Œè¦æ±‚çš„æ”¹å˜å¤§å° flags |= eDontUpdateGeometryState; &#125;&#125;//å¦‚æœæ²¡æœ‰eDontUpdateGeometryStateæ ‡å¿—ï¼Œæ›´æ–°activeçš„å€¼ä¸ºrequest if (flags &amp; eDontUpdateGeometryState) &#123;&#125; else &#123; Layer::State&amp; editCurrentState(getCurrentState()); if (mFreezePositionUpdates) &#123; float tx = c.active.transform.tx(); float ty = c.active.transform.ty(); c.active = c.requested; c.active.transform.set(tx, ty); editCurrentState.active = c.active; &#125; else &#123; editCurrentState.active = editCurrentState.requested; c.active = c.requested; &#125;&#125;// å¦‚æœå½“å‰stateçš„activeå’Œä»¥å‰çš„Stateçš„activeä¸ç­‰ï¼Œè®¾ç½®æ›´æ–°æ ‡å¿— if (s.active != c.active) &#123; // invalidate and recompute the visible regions if needed flags |= Layer::eVisibleRegion;&#125;//å¦‚æœå½“å‰stateçš„sequenceå’Œä»¥å‰stateçš„sequenceä¸ç­‰ï¼Œè®¾ç½®æ›´æ–°æ ‡å¿—if (c.sequence != s.sequence) &#123; // invalidate and recompute the visible regions if needed flags |= eVisibleRegion; this-&gt;contentDirty = true; // we may use linear filtering, if the matrix scales us const uint8_t type = c.active.transform.getType(); mNeedsFiltering = (!c.active.transform.preserveRects() || (type &gt;= Transform::SCALE));&#125;// If the layer is hidden, signal and clear out all local sync points so// that transactions for layers depending on this layer's frames becoming// visible are not blockedif (c.flags &amp; layer_state_t::eLayerHidden) &#123; Mutex::Autolock lock(mLocalSyncPointMutex); for (auto&amp; point : mLocalSyncPoints) &#123; point-&gt;setFrameAvailable(); &#125; mLocalSyncPoints.clear();&#125;// Commit the transactioncommitTransaction(c);return flags;&#125; Layerç±»ä¸­çš„ä¸¤ä¸ªç±»å‹ä¸ºLayer::Stateçš„æˆå‘˜å˜é‡mDrawingStateã€mCurrentStateï¼Œè¿™é‡Œä¸ºä»€ä¹ˆè¦ä¸¤ä¸ªå¯¹è±¡å‘¢ï¼ŸLayerå¯¹è±¡åœ¨ç»˜åˆ¶å›¾å½¢æ—¶ï¼Œä½¿ç”¨çš„æ˜¯mDrawingStateå˜é‡ï¼Œç”¨æˆ·è°ƒç”¨æ¥å£è®¾ç½®Layerå¯¹è±¡å±æ€§æ˜¯ï¼Œè®¾ç½®çš„å€¼ä¿å­˜åœ¨mCurrentStateå¯¹è±¡ä¸­ï¼Œè¿™æ ·å°±ä¸ä¼šå› ä¸ºç”¨æˆ·çš„æ“ä½œè€Œå¹²æ‰°Layerå¯¹è±¡çš„ç»˜åˆ¶äº†ã€‚ Layerçš„doTransactionå‡½æ•°æ®ä½ æ˜¯æ¯”è¾ƒè¿™ä¸¤ä¸ªå˜é‡ï¼Œå¦‚æœæœ‰ä¸åŒçš„åœ°æ–¹ï¼Œè¯´æ˜åœ¨ä¸Šæ¬¡ç»˜åˆ¶ä»¥åï¼Œç”¨æˆ·æ”¹å˜çš„Layerçš„è®¾ç½®ï¼Œè¦æŠŠè¿™ç§å˜åŒ–é€šè¿‡flagsè¿”å›ã€‚ Stateçš„ç»“æ„ä¸­æœ‰ä¸¤ä¸ªGeometryå­—æ®µï¼Œactiveå’Œrequestedã€‚ä»–ä»¬è¡¨ç¤ºlayerçš„å°ºå¯¸ï¼Œå…¶ä¸­requestedä¿å­˜æ˜¯ç”¨æˆ·è®¾ç½®çš„å°ºå¯¸ï¼Œè€Œactiveä¿å­˜çš„å€¼é€šè¿‡è®¡ç®—åçš„å®é™…å°ºå¯¸ã€‚ Stateä¸­çš„zå­—æ®µçš„å€¼å°±æ˜¯Layeråœ¨æ˜¾ç¤ºè½´çš„ä½ç½®ï¼Œå€¼è¶Šå°ä½ç½®è¶Šé ä¸‹ã€‚ layerStackå­—æ®µæ˜¯ç”¨æˆ·æŒ‡å®šçš„ä¸€ä¸ªå€¼ï¼Œç”¨æˆ·å¯ä»¥ç»™DisplayDeviceä¹ŸæŒ‡å®šä¸€ä¸ªlayerStackå€¼ï¼Œåªæœ‰Layerå¯¹è±¡å’ŒDisplayDeviceå¯¹è±¡çš„layerStackç›¸ç­‰ï¼Œè¿™ä¸ªLayeræ‰èƒ½åœ¨è¿™ä¸ªæ˜¾ç¤ºè®¾å¤‡ä¸Šè¾“å‡ºï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯å¯ä»¥è®©æ˜¾ç¤ºè®¾å¤‡åªæ˜¾ç¤ºæŸä¸ªSurfaceçš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è®©HDMIæ˜¾ç¤ºè®¾å¤‡åªæ˜¾ç¤ºæ‰‹æœºä¸Šæ’­æ”¾è§†é¢‘çš„Surfaceçª—å£ï¼Œä½†ä¸æ˜¾ç¤ºActivityçª—å£ã€‚ sequenceå­—æ®µæ˜¯ä¸ªåºåˆ—å€¼ï¼Œæ¯å½“ç”¨æˆ·è°ƒç”¨äº†Layerçš„æ¥å£ï¼Œä¾‹å¦‚setAlphaã€setSizeæˆ–è€…setLayerç­‰æ”¹å˜Layerå¯¹è±¡å±æ€§çš„å“ˆæ•°ï¼Œè¿™ä¸ªå€¼éƒ½ä¼šåŠ 1ã€‚å› æ­¤åœ¨doTransactionå‡½æ•°ä¸­èƒ½é€šè¿‡æ¯”è¾ƒsequenceå€¼æ¥åˆ¤æ–­Layerçš„å±æ€§å€¼æœ‰æ²¡æœ‰å˜åŒ–ã€‚ doTransactionå‡½æ•°æœ€åä¼šè°ƒç”¨commitTransactionå‡½æ•°ï¼Œå°±æ˜¯æŠŠmCurrentStateèµ‹å€¼ç»™mDrawingState [Layer.cpp] 123void Layer::commitTransaction(const State&amp; stateToCommit) &#123;mDrawingState = stateToCommit;&#125; 2.3ã€handleTransactionLockedå‡½æ•°ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æhandleTransactionLockedå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¯”è¾ƒé•¿ï¼Œæˆ‘ä»¬åˆ†æ®µåˆ†æ 2.3.1 å¤„ç†Layerçš„äº‹åŠ¡ [SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123;const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);const size_t count = currentLayers.size();// Notify all layers of available framesfor (size_t i = 0; i &lt; count; ++i) &#123; currentLayers[i]-&gt;notifyAvailableFrames();&#125;if (transactionFlags &amp; eTraversalNeeded) &#123; for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) continue; const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125;&#125; åœ¨SurfaceFlingerä¸­ä¹Ÿæœ‰ä¸¤ä¸ªç±»å‹ä¸ºStateçš„å˜é‡mCurrentStateå’ŒmDrawingStateï¼Œä½†æ˜¯å’ŒLayerä¸­çš„ä¸è¦æ··èµ·æ¥ã€‚å®ƒçš„åå­—ç›¸åŒè€Œå·² 1234 struct State &#123; LayerVector layersSortedByZ; DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;&#125;; ç»“æ„layersSortedByZå­—æ®µä¿å­˜æ‰€æœ‰å‚ä¸ç»˜åˆ¶çš„Layerå¯¹è±¡ï¼Œè€Œå­—æ®µdisplaysä¿å­˜çš„æ˜¯æ‰€æœ‰è¾“å‡ºè®¾å¤‡çš„DisplayDeviceStateå¯¹è±¡ è¿™é‡Œç”¨ä¸¤ä¸ªå˜é‡çš„ç›®çš„æ˜¯å’ŒLayerä¸­ä½¿ç”¨ä¸¤ä¸ªå˜é‡æ˜¯ä¸€æ ·çš„ã€‚ ä¸Šé¢ä»£ç æ ¹æ®eTraversalNeededæ ‡å¿—æ¥å†³å®šæ˜¯å¦è¦æ£€æŸ¥æ‰€æœ‰çš„Layerå¯¹è±¡ã€‚å¦‚æœæŸä¸ªLayerå¯¹è±¡ä¸­æœ‰eTransactionNeededæ ‡å¿—ï¼Œå°†è°ƒç”¨å®ƒçš„doTransactionå‡½æ•°ã€‚Layerçš„doTransactionå‡½æ•°è¿”å›çš„flagså¦‚æœæœ‰eVisibleRegionï¼Œè¯´æ˜è¿™ä¸ªLayeréœ€è¦æ›´æ–°ï¼Œå°±æŠŠmVisibleRegionsDirtyè®¾ç½®ä¸ºtrue 2.3.2ã€å¤„ç†æ˜¾ç¤ºè®¾å¤‡çš„å˜åŒ–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 if (transactionFlags &amp; eDisplayTransactionNeeded) &#123; // here we take advantage of Vector's copy-on-write semantics to // improve performance by skipping the transaction entirely when // know that the lists are identical const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays); const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays); if (!curr.isIdenticalTo(draw)) &#123; mVisibleRegionsDirty = true; const size_t cc = curr.size(); size_t dc = draw.size(); // find the displays that were removed // (ie: in drawing state but not in current state) // also handle displays that changed // (ie: displays that are in both lists) for (size_t i=0 ; i&lt;dc ; i++) &#123; const ssize_t j = curr.indexOfKey(draw.keyAt(i)); if (j &lt; 0) &#123; // in drawing state but not in current state if (!draw[i].isMainDisplay()) &#123; // Call makeCurrent() on the primary display so we can // be sure that nothing associated with this display // is current. const sp&lt;const DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice()); defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext); sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i))); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); if (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) mEventThread-&gt;onHotplugReceived(draw[i].type, false); mDisplays.removeItem(draw.keyAt(i)); &#125; else &#123; ALOGW(\"trying to remove the main display\"); &#125; &#125; else &#123; // this display is in both lists. see if something changed. const DisplayDeviceState&amp; state(curr[j]); const wp&lt;IBinder&gt;&amp; display(curr.keyAt(j)); const sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface); const sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface); if (state_binder != draw_binder) &#123; // changing the surface is like destroying and // recreating the DisplayDevice, so we just remove it // from the drawing state, so that it get re-added // below. sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display)); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); mDisplays.removeItem(display); mDrawingState.displays.removeItemsAt(i); dc--; i--; // at this point we must loop to the next item continue; &#125; const sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display)); if (disp != NULL) &#123; if (state.layerStack != draw[i].layerStack) &#123; disp-&gt;setLayerStack(state.layerStack); &#125; if ((state.orientation != draw[i].orientation) || (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123; disp-&gt;setProjection(state.orientation, state.viewport, state.frame); &#125; if (state.width != draw[i].width || state.height != draw[i].height) &#123; disp-&gt;setDisplaySize(state.width, state.height); &#125; &#125; &#125; &#125; // find displays that were added // (ie: in current state but not in drawing state) for (size_t i=0 ; i&lt;cc ; i++) &#123; if (draw.indexOfKey(curr.keyAt(i)) &lt; 0) &#123; const DisplayDeviceState&amp; state(curr[i]); sp&lt;DisplaySurface&gt; dispSurface; sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferProducer&gt; bqProducer; sp&lt;IGraphicBufferConsumer&gt; bqConsumer; BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer, new GraphicBufferAlloc()); int32_t hwcDisplayId = -1; if (state.isVirtualDisplay()) &#123; // Virtual displays without a surface are dormant: // they have external state (layer stack, projection, // etc.) but no internal state (i.e. a DisplayDevice). if (state.surface != NULL) &#123; int width = 0; DisplayUtils* displayUtils = DisplayUtils::getInstance(); int status = state.surface-&gt;query( NATIVE_WINDOW_WIDTH, &amp;width); ALOGE_IF(status != NO_ERROR, \"Unable to query width (%d)\", status); int height = 0; status = state.surface-&gt;query( NATIVE_WINDOW_HEIGHT, &amp;height); ALOGE_IF(status != NO_ERROR, \"Unable to query height (%d)\", status); if (MAX_VIRTUAL_DISPLAY_DIMENSION == 0 || (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp; height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123; int usage = 0; status = state.surface-&gt;query( NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage); ALOGW_IF(status != NO_ERROR, \"Unable to query usage (%d)\", status); if ( (status == NO_ERROR) &amp;&amp; displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123; hwcDisplayId = allocateHwcDisplayId(state.type); &#125; &#125; displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface, dispSurface, producer, bqProducer, bqConsumer, state.displayName, state.isSecure, state.type); &#125; &#125; else &#123; ALOGE_IF(state.surface!=NULL, \"adding a supported display, but rendering \" \"surface is provided (%p), ignoring it\", state.surface.get()); hwcDisplayId = allocateHwcDisplayId(state.type); // for supported (by hwc) displays we provide our // own rendering surface dispSurface = new FramebufferSurface(*mHwc, state.type, bqConsumer); producer = bqProducer; &#125; const wp&lt;IBinder&gt;&amp; display(curr.keyAt(i)); if (dispSurface != NULL &amp;&amp; producer != NULL) &#123; sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, state.type, hwcDisplayId, mHwc-&gt;getFormat(hwcDisplayId), state.isSecure, display, dispSurface, producer, mRenderEngine-&gt;getEGLConfig()); hw-&gt;setLayerStack(state.layerStack); hw-&gt;setProjection(state.orientation, state.viewport, state.frame); hw-&gt;setDisplayName(state.displayName); // When a new display device is added update the active // config by querying HWC otherwise the default config // (config 0) will be used. if (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp; hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123; int activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId); if (activeConfig &gt;= 0) &#123; hw-&gt;setActiveConfig(activeConfig); &#125; &#125; mDisplays.add(display, hw); if (state.isVirtualDisplay()) &#123; if (hwcDisplayId &gt;= 0) &#123; mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId, hw-&gt;getWidth(), hw-&gt;getHeight(), hw-&gt;getFormat()); &#125; &#125; else &#123; mEventThread-&gt;onHotplugReceived(state.type, true); &#125; &#125; &#125; &#125; &#125;&#125; è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯å¤„ç†æ˜¾ç¤ºè®¾å¤‡çš„å˜åŒ–ï¼Œåˆ†æˆ3ç§æƒ…å†µï¼š 1.æ˜¾ç¤ºè®¾å¤‡å‡å°‘äº†ï¼Œéœ€è¦æŠŠæ˜¾ç¤ºè®¾å¤‡å¯¹åº”çš„DisplayDeviceç§»é™¤ 2.æ˜¾ç¤ºè®¾å¤‡å‘ç”Ÿäº†å˜åŒ–ï¼Œä¾‹å¦‚ç”¨æˆ·è®¾ç½®äº†Surfaceã€é‡æ–°è®¾ç½®äº†layerStackã€æ—‹è½¬äº†å±å¹•ç­‰ï¼Œè¿™å°±éœ€è¦é‡æ–°è®¾ç½®æ˜¾ç¤ºå¯¹è±¡çš„å±æ€§ 3.æ˜¾ç¤ºè®¾å¤‡å¢åŠ äº†ï¼Œåˆ›å»ºæ–°çš„DisplayDeviceåŠ å…¥ç³»ç»Ÿä¸­ã€‚ 2.3.3ã€è®¾ç½®TransfromHit12345678910111213141516171819202122232425262728293031323334353637383940 if (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123; ...... sp&lt;const DisplayDevice&gt; disp; uint32_t currentlayerStack = 0; for (size_t i=0; i&lt;count; i++) &#123; // NOTE: we rely on the fact that layers are sorted by // layerStack first (so we don't have to traverse the list // of displays for every layer). const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t layerStack = layer-&gt;getDrawingState().layerStack; if (i==0 || currentlayerStack != layerStack) &#123; currentlayerStack = layerStack; // figure out if this layerstack is mirrored // (more than one display) if so, pick the default display, // if not, pick the only display it's on. disp.clear(); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); if (hw-&gt;getLayerStack() == currentlayerStack) &#123; if (disp == NULL) &#123; disp = hw; &#125; else &#123; disp = NULL; break; &#125; &#125; &#125; &#125; if (disp == NULL) &#123; // NOTE: TEMPORARY FIX ONLY. Real fix should cause layers to // redraw after transform hint changes. See bug 8508397. // could be null when this layer is using a layerStack // that is not visible on any display. Also can occur at // screen off/on times. disp = getDefaultDisplayDevice(); &#125; layer-&gt;updateTransformHint(disp); &#125;&#125; è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯æ ¹æ®æ¯ç§æ˜¾ç¤ºè®¾å¤‡çš„ä¸åŒï¼Œè®¾ç½®å’Œæ˜¾ç¤ºè®¾å¤‡å…³è”åœ¨ä¸€èµ·çš„Layerï¼ˆä¸»è¦çœ‹Layerçš„layerStackæ˜¯å¦å’ŒDisplayDeviceçš„layerStackï¼‰çš„TransformHintï¼ˆä¸»è¦æŒ‡è®¾å¤‡çš„æ˜¾ç¤ºæ–¹å‘orientationï¼‰ã€‚ 2.3.4ã€å¤„ç†Layerå¢åŠ æƒ…å†µ123456789101112131415161718192021222324252627282930/* * Perform our own transaction if needed */const LayerVector&amp; layers(mDrawingState.layersSortedByZ);if (currentLayers.size() &gt; layers.size()) &#123; // layers have been added mVisibleRegionsDirty = true;&#125;// some layers might have been removed, so// we need to update the regions they're exposing.if (mLayersRemoved) &#123; mLayersRemoved = false; mVisibleRegionsDirty = true; const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (currentLayers.indexOf(layer) &lt; 0) &#123; // this layer is not visible anymore // TODO: we could traverse the tree from front to back and // compute the actual visible region // TODO: we could cache the transformed region const Layer::State&amp; s(layer-&gt;getDrawingState()); Region visibleReg = s.active.transform.transform( Region(Rect(s.active.w, s.active.h))); invalidateLayerStack(s.layerStack, visibleReg); &#125; &#125;&#125; è¿™æ®µä»£ç å¤„ç†Layerçš„å¢åŠ æƒ…å†µï¼Œå¦‚æœLayerå¢åŠ äº†ï¼Œéœ€è¦é‡æ–°è®¡ç®—è®¾å¤‡çš„æ›´æ–°åŒºåŸŸï¼Œå› æ­¤æŠŠmVisibleRegionsDirtyè®¾ä¸ºtrueï¼Œå¦‚æœLayeråˆ é™¤äº†ï¼Œéœ€è¦æŠŠLayerçš„å¯è§åŒºåŸŸåŠ å…¥åˆ°ç³»ç»Ÿéœ€è¦æ›´æ–°çš„åŒºåŸŸä¸­ã€‚ 2.3.5ã€è®¾ç½®mDrawingState12commitTransaction();updateCursorAsync(); è°ƒç”¨commitTransactionå’ŒupdateCursorAsyncå‡½æ•° commitTransactionå‡½æ•°ä½œç”¨æ˜¯æŠŠmDrawingStateçš„å€¼è®¾ç½®æˆmCurrentStateçš„å€¼ã€‚è€ŒupdateCursorAsyncå‡½æ•°ä¼šæ›´æ–°æ‰€æœ‰æ˜¾ç¤ºè®¾å¤‡ä¸­å…‰æ ‡çš„ä½ç½®ã€‚ 2.3.6 å°ç»“ handleTransactionå‡½æ•°çš„ä½œç”¨çš„å°±æ˜¯å¤„ç†ç³»ç»Ÿåœ¨ä¸¤æ¬¡åˆ·æ–°æœŸé—´çš„å„ç§å˜åŒ–ã€‚SurfaceFlingeræ¨¡å—ä¸­ä¸ç®¡æ˜¯SurfaceFlingerç±»è¿˜æ˜¯Layerç±»ï¼Œéƒ½é‡‡ç”¨äº†åŒç¼“å†²çš„æ–¹å¼æ¥ä¿å­˜ä»–ä»¬çš„å±æ€§ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯åˆšæ”¹å˜SurfaceFlingerå¯¹è±¡æˆ–è€…Layerç±»å¯¹è±¡çš„å±æ€§æ˜¯ï¼Œä¸éœ€è¦ä¸Šé”ï¼Œå¤§å¤§çš„æé«˜äº†ç³»ç»Ÿæ•ˆç‡ã€‚åªæœ‰åœ¨æœ€åçš„å›¾åƒè¾“å‡ºæ˜¯ï¼Œæ‰è¿›è¡Œä¸€æ¬¡ä¸Šé”ï¼Œå¹¶è¿›è¡Œå†…å­˜çš„å±æ€§å˜åŒ–å¤„ç†ã€‚æ­£å› æ­¤ï¼Œåº”ç”¨è¿›ç¨‹å¿…é¡»æ”¶åˆ°VSyncä¿¡å·æ‰å¼€å§‹æ”¹å˜Surfaceçš„å†…å®¹ã€‚ 2.4ã€handlePageFlipå‡½æ•°handlePageFlipå‡½æ•°ä»£ç å¦‚ä¸‹ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool SurfaceFlinger::handlePageFlip()&#123;Region dirtyRegion;bool visibleRegions = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);bool frameQueued = false;// Store the set of layers that need updates. This set must not change as// buffers are being latched, as this could result in a deadlock.// Example: Two producers share the same command stream and:// 1.) Layer 0 is latched// 2.) Layer 0 gets a new frame// 2.) Layer 1 gets a new frame// 3.) Layer 1 is latched.// Display is now waiting on Layer 1's frame, which is behind layer 0's// second frame. But layer 0's second frame could be waiting on display.Vector&lt;Layer*&gt; layersWithQueuedFrames;for (size_t i = 0, count = layers.size(); i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (layer-&gt;hasQueuedFrame()) &#123; frameQueued = true; if (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123; layersWithQueuedFrames.push_back(layer.get()); &#125; else &#123; layer-&gt;useEmptyDamage(); &#125; &#125; else &#123; layer-&gt;useEmptyDamage(); &#125;&#125;for (size_t i = 0, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123; Layer* layer = layersWithQueuedFrames[i]; const Region dirty(layer-&gt;latchBuffer(visibleRegions)); layer-&gt;useSurfaceDamage(); const Layer::State&amp; s(layer-&gt;getDrawingState()); invalidateLayerStack(s.layerStack, dirty);&#125;mVisibleRegionsDirty |= visibleRegions;// If we will need to wake up at some time in the future to deal with a// queued frame that shouldn't be displayed during this vsync period, wake// up during the next vsync period to check again.if (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123; signalLayerUpdate();&#125;// Only continue with the refresh if there is actually new work to doreturn !layersWithQueuedFrames.empty();&#125; handlePageFlipå‡½æ•°å…ˆè°ƒç”¨æ¯ä¸ªLayerå¯¹è±¡çš„hasQueuedFrameå‡½æ•°ï¼Œç¡®å®šè¿™ä¸ªLayerå¯¹è±¡æ˜¯å¦æœ‰éœ€è¦æ›´æ–°çš„å›¾å±‚ï¼Œç„¶åæŠŠéœ€è¦æ›´æ–°çš„Layerå¯¹è±¡æ”¾åˆ°layersWithQueuedFramesä¸­ã€‚ æˆ‘ä»¬å…ˆæ¥çœ‹Layerçš„hasQueuedFrameæ–¹æ³•å°±æ˜¯çœ‹å…¶mQueuedFramesæ˜¯å¦å¤§äº0 å’ŒmSidebandStreamChangedã€‚å‰é¢å°èŠ‚åˆ†æåªè¦Surfaceæœ‰æ•°æ®å†™å…¥ï¼Œå°±ä¼šè°ƒç”¨Layerçš„onFrameAvailableå‡½æ•°ï¼Œç„¶åmQueuedFrameså€¼åŠ 1. ç»§ç»­çœ‹handlePageFlipå‡½æ•°ï¼Œæ¥ç€è°ƒç”¨éœ€è¦æ›´æ–°çš„Layerå¯¹è±¡çš„latchBufferå‡½æ•°ï¼Œç„¶åæ ¹æ®è¿”å›çš„æ›´æ–°åŒºåŸŸè°ƒç”¨invalidateLayerStackå‡½æ•°æ¥è®¾ç½®æ›´æ–°è®¾å¤‡å¯¹è±¡çš„æ›´æ–°åŒºåŸŸã€‚ ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹latchBufferå‡½æ•° LatchBufferå‡½æ•°è°ƒç”¨updateTextImageæ¥å¾—åˆ°éœ€è¦çš„å›¾åƒã€‚è¿™é‡Œå‚æ•°ræ˜¯Rejectå¯¹è±¡ï¼Œå…¶ä½œç”¨æ˜¯åˆ¤æ–­åœ¨ç¼“å†²åŒºçš„å°ºå¯¸æ˜¯å¦ç¬¦åˆè¦æ±‚ã€‚è°ƒç”¨updateTextImageå‡½æ•°å¦‚æœå¾—åˆ°çš„ç»“æœæ˜¯PRESENT_LATER,è¡¨ç¤ºæ¨è¿Ÿå¤„ç†ï¼Œç„¶åè°ƒç”¨signalLayerUpdateå‡½æ•°æ¥å‘é€invalidateæ¶ˆæ¯ï¼Œè¿™æ¬¡ç»˜åˆ¶è¿‡ç¨‹å°±ä¸å¤„ç†è¿™ä¸ªSurfaceçš„å›¾åƒäº†ã€‚ å¦‚æœä¸éœ€è¦æ¨è¿Ÿå¤„ç†ï¼ŒæŠŠmQueuedFramesçš„å€¼å‡1. æœ€åLatchBufferå‡½æ•°è°ƒç”¨mSurfaceFlingerConsumerçš„getCurrentBufferæ¥å–å›å½“å‰çš„å›¾åƒç¼“å†²åŒºæŒ‡é’ˆï¼Œä¿å­˜åœ¨mActiveBufferä¸­ã€‚ 2.5 å°ç»“è¿™æ ·ç»è¿‡handleTransaction handlePageFlipä¸¤ä¸ªå‡½æ•°å¤„ç†ï¼ŒSurfaceFlingerä¸­æ— è®ºæ˜¯Layerå±æ€§çš„å˜åŒ–è¿˜æ˜¯å›¾åƒçš„å˜åŒ–éƒ½å¤„ç†å¥½äº†ï¼Œåªç­‰VSyncä¿¡å·åˆ°æ¥å°±å¯ä»¥è¾“å‡ºäº†ã€‚ ä¸‰ã€rebuildLayerStackså‡½æ•°å‰é¢ä»‹ç»ï¼ŒVSyncä¿¡å·åˆ°æ¥åï¼Œå…ˆæ˜¯è°ƒç”¨äº†rebuildLayerStackså‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445void SurfaceFlinger::rebuildLayerStacks() &#123;updateExtendedMode();// rebuild the visible layer list per screenif (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_CALL(); mVisibleRegionsDirty = false; invalidateHwcGeometry(); //è®¡ç®—æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡ä¸Šå¯è§çš„Layer const LayerVector&amp; layers(mDrawingState.layersSortedByZ); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; Region opaqueRegion; Region dirtyRegion; Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); const Transform&amp; tr(hw-&gt;getTransform()); const Rect bounds(hw-&gt;getBounds()); if (hw-&gt;isDisplayOn()) &#123; //è®¡ç®—æ¯ä¸ªlayerçš„å¯è§åŒºåŸŸï¼Œç¡®å®šè®¾å¤‡éœ€è¦é‡æ–°ç»˜åˆ¶çš„åŒºåŸŸ computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers, hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); &#123; //åªéœ€è¦å’Œæ˜¾ç¤ºè®¾å¤‡çš„LayerStackç›¸åŒçš„layer Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); drawRegion.andSelf(bounds); if (!drawRegion.isEmpty()) &#123; //å¦‚æœLayerçš„æ˜¾ç¤ºåŒºåŸŸå’Œæ˜¾ç¤ºè®¾å¤‡çš„çª—å£æœ‰äº¤é›† //æŠŠLayeråŠ å…¥åˆ—è¡¨ä¸­ layersSortedByZ.add(layer); &#125; &#125; &#125; &#125; //è®¾ç½®æ˜¾ç¤ºè®¾å¤‡çš„å¯è§Layeråˆ—è¡¨ hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); hw-&gt;undefinedRegion.set(bounds); hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); hw-&gt;dirtyRegion.orSelf(dirtyRegion); &#125;&#125;&#125; rebuildLayerStackså‡½æ•°çš„ä½œç”¨æ˜¯é‡å»ºæ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡çš„å¯è§layerå¯¹è±¡åˆ—è¡¨ã€‚å¯¹äºæŒ‰æ˜¾ç¤ºè½´ï¼ˆZè½´ï¼‰æ’åˆ—çš„Layerå¯¹è±¡ï¼Œæ’åœ¨æœ€å‰é¢çš„å½“ç„¶ä¼šä¼˜å…ˆæ˜¾ç¤ºï¼Œä½†æ˜¯Layerå›¾åƒå¯èƒ½æœ‰é€æ˜åŸŸï¼Œä¹Ÿå¯èƒ½æœ‰å°ºå¯¸æ²¡æœ‰è¦†ç›–æ•´ä¸ªå±å¹•ï¼Œå› æ­¤ä¸‹é¢çš„layerä¹Ÿæœ‰æ˜¾ç¤ºçš„æœºä¼šã€‚rebuildLayerStackså‡½æ•°å¯¹æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡ï¼Œå…ˆè®¡ç®—å’Œæ˜¾ç¤ºè®¾å¤‡å…·æœ‰ç›¸åŒlayerStackå€¼çš„Layerå¯¹è±¡åœ¨è¯¥æ˜¾ç¤ºè®¾å¤‡ä¸Šçš„å¯è§åŒºåŸŸã€‚ç„¶åå°†å¯è§åŒºåŸŸå’Œæ˜¾ç¤ºè®¾å¤‡çš„çª—å£åŒºåŸŸæœ‰äº¤é›†çš„layerç»„æˆä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼Œæœ€åæŠŠè¿™ä¸ªåˆ—è¡¨è®¾ç½®åˆ°æ˜¾ç¤ºè®¾å¤‡å¯¹è±¡ä¸­ã€‚ computeVisibleRegionså‡½æ•°é¦–å…ˆè®¡ç®—æ¯ä¸ªLayeråœ¨è®¾å¤‡ä¸Šçš„å¯è§åŒºåŸŸvisibleRegionã€‚è®¡ç®—æ–¹æ³•å°±æ˜¯ç”¨æ•´ä¸ªLayerçš„åŒºåŸŸå‡å»ä¸Šå±‚æ‰€æœ‰ä¸é€æ˜åŒºåŸŸaboveOpaqueLayersã€‚è€Œä¸Šå±‚æ‰€æœ‰ä¸é€æ˜åŒºåŸŸå€¼æ˜¯ä¸€ä¸ªé€å±‚ç´¯è®¡çš„è¿‡ç¨‹ï¼Œæ¯å±‚éƒ½éœ€è¦æŠŠè‡ªå·±çš„ä¸é€æ˜åŒºåŸŸç´¯åŠ åˆ°aboveOpaqueLayersä¸­ã€‚ è€Œæ¯å±‚çš„ä¸é€æ˜åŒºåŸŸçš„è®¡ç®—æ–¹æ³•ï¼šå¦‚æœLayerçš„alphaçš„å€¼ä¸º255ï¼Œå¹¶ä¸”layerçš„isOpaqueå‡½æ•°ä¸ºtrueï¼Œåˆ™æœ¬å±‚çš„ä¸é€æ˜åŒºåŸŸç­‰äºLayeræ‰€åœ¨åŒºåŸŸï¼Œå¦åˆ™ä¸º0.è¿™æ ·ä¸€å±‚å±‚ç®—ä¸‹æ¥ï¼Œå°±å¾ˆå®¹æ˜“å¾—åˆ°æ¯å±‚çš„å¯è§åŒºåŸŸå¤§å°äº†ã€‚ å…¶æ¬¡ï¼Œè®¡ç®—æ•´ä¸ªæ˜¾ç¤ºè®¾å¤‡éœ€è¦æ›´æ–°çš„åŒºåŸŸoutDirtyRegionã€‚outDirtyRegionçš„å€¼ä¹Ÿæ˜¯ç´¯è®¡æ‰€æœ‰å±‚çš„éœ€è¦é‡å›çš„åŒºåŸŸå¾—åˆ°çš„ã€‚å¦‚æœLayerä¸­çš„æ˜¾ç¤ºå†…å®¹å‘ç”Ÿäº†å˜åŒ–ï¼Œåˆ™æ•´ä¸ªå¯è§åŒºåŸŸvisibleRegionéƒ½éœ€è¦æ›´æ–°ï¼ŒåŒæ—¶è¿˜è¦åŒ…æ‹¬ä¸Šä¸€æ¬¡çš„å¯è§åŒºåŸŸï¼Œç„¶ååœ¨å»æ‰è¢«ä¸Šå±‚è¦†ç›–åçš„åŒºåŸŸå¾—åˆ°çš„å°±æ˜¯Layeréœ€è¦æ›´æ–°çš„åŒºåŸŸã€‚å¦‚æœLayeræ˜¾ç¤ºçš„å†…å®¹æ²¡æœ‰å˜åŒ–ï¼Œä½†æ˜¯è€ƒè™‘åˆ°çª—å£å¤§å°çš„å˜åŒ–æˆ–è€…ä¸Šå±‚çª—å£çš„å˜åŒ–ï¼Œå› æ­¤Layerä¸­è¿˜æ˜¯æœ‰åŒºåŸŸå¯ä»¥éœ€è¦é‡ç»˜çš„åœ°æ–¹ã€‚è¿™ç§æƒ…å†µä¸‹æœ€ç®€å•çš„ç®—æ³•æ˜¯ç”¨Layerè®¡ç®—å‡ºå¯è§åŒºåŸŸå‡å»ä»¥å‰çš„å¯è§åŒºåŸŸå°±å¯ä»¥äº†ã€‚ä½†æ˜¯åœ¨computeVisibleRegionså‡½æ•°è¿˜å¼•å…¥äº†è¢«è¦†ç›–åŒºåŸŸï¼Œé€šå¸¸è¢«è¦†ç›–åŒºåŸŸå’Œå¯è§åŒºåŸŸå¹¶ä¸é‡å¤ï¼Œå› æ­¤å‡½æ•°ä¸­è®¡ç®—æš´éœ²åŒºåŸŸæ˜¯ç”¨å¯è§åŒºåŸŸå‡å»è¢«è¦†ç›–åŒºåŸŸçš„ã€‚ å››ã€setUpHWComposerå‡½æ•°setUpHWComposerå‡½æ•°çš„ä½œç”¨æ˜¯æ›´æ–°HWComposerå¯¹è±¡ä¸­å›¾å±‚å¯¹è±¡åˆ—è¡¨ä»¥åŠå›¾å±‚å±æ€§ã€‚ [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void SurfaceFlinger::setUpHWComposer() &#123;for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; bool dirty = !mDisplays[dpy]-&gt;getDirtyRegion(false).isEmpty(); bool empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0; bool wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers; ...... bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); ...... mDisplays[dpy]-&gt;beginFrame(mustRecompose); if (mustRecompose) &#123; mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty; &#125;&#125;//å¾—åˆ°ç³»ç»ŸHWComposerå¯¹è±¡ HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; // build the h/w work list if (CC_UNLIKELY(mHwWorkListDirty)) &#123; mHwWorkListDirty = false; for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); //æ ¹æ®Layeræ•°é‡åœ¨HWComposerä¸­åˆ›å»ºhwc_layer_list_tåˆ—è¡¨ if (hwc.createWorkList(id, count) == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); layer-&gt;setGeometry(hw, *cur); if (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123; cur-&gt;setSkip(true); &#125; &#125; &#125; &#125; &#125; &#125; // set the per-frame data for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; bool freezeSurfacePresent = false; isfreezeSurfacePresent(freezeSurfacePresent, hw, id); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; /* * update the per-frame h/w composer data for each layer * and build the transparent region of the FB */ const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); //å°†Layerçš„mActiveBufferè®¾ç½®åˆ°HWComposerä¸­ layer-&gt;setPerFrameData(hw, *cur); setOrientationEventControl(freezeSurfacePresent,id); &#125; &#125; &#125; // If possible, attempt to use the cursor overlay on each display. for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); if (layer-&gt;isPotentialCursor()) &#123; cur-&gt;setIsCursorLayerHint(); break; &#125; &#125; &#125; &#125; dumpDrawCycle(true); status_t err = hwc.prepare(); ALOGE_IF(err, \"HWComposer::prepare failed (%s)\", strerror(-err)); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); hw-&gt;prepareFrame(hwc); &#125;&#125;&#125; HWComposerä¸­æœ‰ä¸€ä¸ªç±»å‹ä¸ºDisplayDataç»“æ„çš„æ•°ç»„mDisplayDataï¼Œå®ƒç»´æŠ¤ç€æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡çš„ä¿¡æ¯ã€‚DisplayDataç»“æ„ä¸­æœ‰ä¸€ä¸ªç±»å‹ä¸ºhwc_display_contents_lå­—æ®µlistï¼Œè¿™ä¸ªå­—æ®µåˆæœ‰ä¸€ä¸ªhwc_layer_lç±»å‹çš„æ•°ç»„hwLayersï¼Œè®°å½•è¯¥æ˜¾ç¤ºè®¾å¤‡æ‰€æœ‰éœ€è¦è¾“å‡ºçš„Layerä¿¡æ¯ã€‚ setUpHWComposerå‡½æ•°è°ƒç”¨HWComposerçš„createWorkListå‡½æ•°å°±æ˜¯æ ¹æ®æ¯ç§æ˜¾ç¤ºè®¾å¤‡çš„Layeræ•°é‡ï¼Œåˆ›å»ºå’Œåˆå§‹åŒ–hwc_display_contents_lå¯¹è±¡å’Œhwc_layer_læ•°ç»„ åˆ›å»ºå®ŒHWComposerä¸­çš„åˆ—è¡¨åï¼Œæ¥ä¸‹æ¥æ˜¯å¯¹æ¯ä¸ªLayerå¯¹è±¡è°ƒç”¨å®ƒçš„setPerFrameDataå‡½æ•°ï¼Œå‚æ•°æ˜¯HWComposerå’ŒHWCLayerInterfaceã€‚setPerFrameDataå‡½æ•°å°†Layerå¯¹è±¡çš„å½“å‰å›¾åƒç¼“å†²åŒºmActiveBufferè®¾ç½®åˆ°HWCLayerInterfaceå¯¹è±¡å¯¹åº”çš„hwc_layer_lå¯¹è±¡ä¸­ã€‚ HWComposerç±»ä¸­é™¤äº†å‰é¢ä»‹ç»çš„Grallocè¿˜ç®¡ç†ç€Composeræ¨¡å—ï¼Œè¿™ä¸ªæ¨¡å—å®ç°äº†ç¡¬ä»¶çš„å›¾åƒåˆæˆåŠŸèƒ½ã€‚setUpHWComposerå‡½æ•°æ¥ä¸‹æ¥è°ƒç”¨HWComposerç±»çš„prepareå‡½æ•°ï¼Œè€Œprepareå‡½æ•°ä¼šè°ƒç”¨Composeræ¨¡å—çš„prepareæ¥å£ã€‚æœ€ååˆ°å„ä¸ªå‚å®¶çš„å®ç°hwc_prepareå‡½æ•°å°†æ¯ç§HWComposerä¸­çš„æ‰€æœ‰å›¾å±‚çš„ç±»å‹éƒ½è®¾ç½®ä¸ºHWC_FRAMEBUFFERå°±ç»“æŸäº†ã€‚ äº”ã€åˆæˆæ‰€æœ‰å±‚çš„å›¾åƒ ï¼ˆdoComposition()å‡½æ•°ï¼‰doCompositionå‡½æ•°æ˜¯åˆæˆæ‰€æœ‰å±‚çš„å›¾åƒï¼Œä»£ç å¦‚ä¸‹ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::doComposition() &#123;ATRACE_CALL();const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); // repaint the framebuffer (if needed) doDisplayComposition(hw, dirtyRegion); hw-&gt;dirtyRegion.clear(); hw-&gt;flip(hw-&gt;swapRegion); hw-&gt;swapRegion.clear(); &#125; // inform the h/w that we're done compositing hw-&gt;compositionComplete();&#125;postFramebuffer();&#125; doCompositionå‡½æ•°é’ˆå¯¹æ¯ç§æ˜¾ç¤ºè®¾å¤‡è°ƒç”¨doDisplayCompositionå‡½æ•°æ¥åˆæˆï¼Œåˆæˆåè°ƒç”¨postFramebufferå‡½æ•°ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹doDisplayCompositionå‡½æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SurfaceFlinger::doDisplayComposition(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; inDirtyRegion) &#123;// We only need to actually compose the display if:// 1) It is being handled by hardware composer, which may need this to// keep its virtual display state machine in sync, or// 2) There is work to be done (the dirty region isn't empty)bool isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= 0;if (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123; ALOGV(\"Skipping display composition\"); return;&#125;ALOGV(\"doDisplayComposition\");Region dirtyRegion(inDirtyRegion);// compute the invalid region//swapRegionè®¾ç½®ä¸ºéœ€è¦æ›´æ–°çš„åŒºåŸŸ hw-&gt;swapRegion.orSelf(dirtyRegion);uint32_t flags = hw-&gt;getFlags();//è·å¾—æ˜¾ç¤ºè®¾å¤‡æ”¯æŒçš„æ›´æ–°æ–¹å¼æ ‡å¿— if (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123; // we can redraw only what's dirty, but since SWAP_RECTANGLE only // takes a rectangle, we must make sure to update that whole // rectangle in that case dirtyRegion.set(hw-&gt;swapRegion.bounds());&#125; else &#123; if (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;//æ”¯æŒéƒ¨åˆ†æ›´æ–° // We need to redraw the rectangle that will be updated // (pushed to the framebuffer). // This is needed because PARTIAL_UPDATES only takes one // rectangle instead of a region (see DisplayDevice::flip()) //å°†æ›´æ–°åŒºåŸŸè°ƒæ•´ä¸ºæ•´ä¸ªçª—å£å¤§å° dirtyRegion.set(hw-&gt;swapRegion.bounds()); &#125; else &#123; // we need to redraw everything (the whole screen) dirtyRegion.set(hw-&gt;bounds()); hw-&gt;swapRegion = dirtyRegion; &#125;&#125;//åˆæˆ if (!doComposeSurfaces(hw, dirtyRegion)) return;// update the swap region and clear the dirty regionhw-&gt;swapRegion.orSelf(dirtyRegion);//æ²¡æœ‰ç¡¬ä»¶composerçš„æƒ…å†µï¼Œè¾“å‡ºå›¾åƒ// swap buffers (presentation)hw-&gt;swapBuffers(getHwComposer());&#125; doDisplayCompositionå‡½æ•°æ ¹æ®æ˜¾ç¤ºè®¾å¤‡æ”¯æŒçš„æ›´æ–°æ–¹å¼ï¼Œé‡æ–°è®¾ç½®éœ€è¦æ›´æ–°åŒºåŸŸçš„å¤§å°ã€‚ çœŸæ­£çš„åˆæˆå·¥ä½œæ˜¯åœ¨doComposerSurfaceså‡½æ•°ä¸­å®Œæˆï¼Œè¿™ä¸ªå‡½æ•°åœ¨layerçš„ç±»å‹ä¸ºHWC_FRAMEBUFFER,æˆ–è€…ä¸æ”¯æŒç¡¬ä»¶çš„composerçš„æƒ…å†µä¸‹ï¼Œè°ƒç”¨layerçš„drawå‡½æ•°æ¥ä¸€å±‚ä¸€å±‚ä½åˆæˆæœ€åçš„å›¾åƒã€‚ åˆæˆå®Œåï¼ŒdoDisplayCompositionå‡½æ•°è°ƒç”¨äº†hwçš„swapBufferså‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å‰é¢ä»‹ç»è¿‡äº†ï¼Œå®ƒå°†åœ¨ç³»ç»Ÿä¸æ”¯æŒç¡¬ä»¶çš„composeræƒ…å†µä¸‹è°ƒç”¨eglSwapBuffersæ¥è¾“å‡ºå›¾åƒåˆ°æ˜¾ç¤ºè®¾å¤‡ã€‚ å…­ã€postFramebuffer()å‡½æ•°ä¸Šä¸€èŠ‚çš„doCompositionå‡½æ•°æœ€åè°ƒç”¨äº†postFramebufferå‡½æ•°ï¼Œä»£ç å¦‚ä¸‹ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void SurfaceFlinger::postFramebuffer()&#123;ATRACE_CALL();const nsecs_t now = systemTime();mDebugInSwapBuffers = now;HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; if (!hwc.supportsFramebufferTarget()) &#123; // EGL spec says: // \"surface must be bound to the calling thread's current context, // for the current rendering API.\" getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext); &#125; hwc.commit();&#125;// make the default display current because the VirtualDisplayDevice code cannot// deal with dequeueBuffer() being called outside of the composition loop; however// the code below can call glFlush() which is allowed (and does in some case) call// dequeueBuffer().getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ()); hw-&gt;onSwapBuffersCompleted(hwc); const size_t count = currentLayers.size(); int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;=0 &amp;&amp; hwc.initCheck() == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i = 0; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur); &#125; &#125; else &#123; for (size_t i = 0; i &lt; count; i++) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, NULL); &#125; &#125;&#125;mLastSwapBufferTime = systemTime() - now;mDebugInSwapBuffers = 0;uint32_t flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();if (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123; logFrameStats();&#125;&#125; postFramebufferå…ˆåˆ¤æ–­ç³»ç»Ÿæ˜¯å¦æ”¯æŒcomposerï¼Œå¦‚æœä¸æ”¯æŒï¼Œæˆ‘ä»¬çŸ¥é“å›¾åƒå·²ç»åœ¨doCompositionå‡½æ•°æ—¶è°ƒç”¨hw-&gt;swapBuffersè¾“å‡ºäº†ï¼Œå°±è¿”å›äº†ã€‚å¦‚æœæ”¯æŒç¡¬ä»¶composerï¼ŒpostFramebufferå‡½æ•°å°†è°ƒç”¨HWComposerçš„commitå‡½æ•°ç»§ç»­æ‰§è¡Œã€‚ [HWComposer.cpp] 12345678910111213141516171819202122232425262728293031323334353637status_t HWComposer::commit() &#123;int err = NO_ERROR;if (mHwc) &#123; if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; // On version 1.0, the OpenGL ES target surface is communicated // by the (dpy, sur) fields and we are guaranteed to have only // a single display. mLists[0]-&gt;dpy = eglGetCurrentDisplay(); mLists[0]-&gt;sur = eglGetCurrentSurface(EGL_DRAW); &#125; for (size_t i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); if (disp.outbufHandle) &#123; mLists[i]-&gt;outbuf = disp.outbufHandle; mLists[i]-&gt;outbufAcquireFenceFd = disp.outbufAcquireFence-&gt;dup(); &#125; &#125; err = mHwc-&gt;set(mHwc, mNumDisplays, mLists); for (size_t i=0 ; i&lt;mNumDisplays ; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); disp.lastDisplayFence = disp.lastRetireFence; disp.lastRetireFence = Fence::NO_FENCE; if (disp.list) &#123; if (disp.list-&gt;retireFenceFd != -1) &#123; disp.lastRetireFence = new Fence(disp.list-&gt;retireFenceFd); disp.list-&gt;retireFenceFd = -1; &#125; disp.list-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED; &#125; &#125;&#125;return (status_t)err;&#125; åˆæˆæ•ˆæœå›¾ï¼š ï¼ˆå…­ï¼‰ã€Android SurfaceFlinger - VSyncå·¥ä½œåŸç†ä¸€ã€VSYNC æ€»ä½“æ¦‚å¿µ6.1.1ã€VSYNC æ¦‚å¿µVSYNCï¼ˆVertical Synchronizationï¼‰æ˜¯ä¸€ä¸ªç›¸å½“å¤è€çš„æ¦‚å¿µï¼Œå¯¹äºæ¸¸æˆç©å®¶ï¼Œå®ƒæœ‰ä¸€ä¸ªæ›´åŠ å¤§åé¼é¼çš„ä¸­æ–‡åå­—â€”å‚ç›´åŒæ­¥ã€‚ â€œå‚ç›´åŒæ­¥(vsync)â€æŒ‡çš„æ˜¯æ˜¾å¡çš„è¾“å‡ºå¸§æ•°å’Œå±å¹•çš„å‚ç›´åˆ·æ–°ç‡ç›¸åŒï¼Œè¿™å®Œå…¨æ˜¯ä¸€ä¸ªCRTæ˜¾ç¤ºå™¨ä¸Šçš„æ¦‚å¿µã€‚å…¶å®æ— è®ºæ˜¯VSYNCè¿˜æ˜¯å‚ç›´åŒæ­¥è¿™ä¸ªåå­—ï¼Œå› ä¸ºLCDæ ¹æœ¬å°±æ²¡æœ‰å‚ç›´æ‰«æçš„è¿™ç§ä¸œè¥¿ï¼Œå› æ­¤è¿™ä¸ªåå­—æœ¬èº«å·²ç»æ²¡æœ‰æ„ä¹‰ã€‚ä½†æ˜¯åŸºäºå†å²çš„åŸå› ï¼Œè¿™ä¸ªåç§°åœ¨å›¾å½¢å›¾åƒé¢†åŸŸè¢«æ²¿è¢­ä¸‹æ¥ã€‚ åœ¨å½“ä¸‹ï¼Œå‚ç›´åŒæ­¥çš„å«ä¹‰æˆ‘ä»¬å¯ä»¥ç†è§£ä¸ºï¼Œä½¿å¾—æ˜¾å¡ç”Ÿæˆå¸§çš„é€Ÿåº¦å’Œå±å¹•åˆ·æ–°çš„é€Ÿåº¦çš„ä¿æŒä¸€è‡´ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œå¦‚æœå±å¹•çš„åˆ·æ–°ç‡ä¸º60Hzï¼Œé‚£ä¹ˆç”Ÿæˆå¸§çš„é€Ÿåº¦å°±åº”è¯¥è¢«å›ºå®šåœ¨1/60 sã€‚ 6.1.2ã€Android VSYNC â€“ é»„æ²¹è®¡åˆ’è°·æ­Œä¸ºè§£å†³Androidç³»ç»Ÿæµç•…æ€§é—®é¢˜ã€‚åœ¨4.1ç‰ˆæœ¬å¼•å…¥äº†ä¸€ä¸ªé‡å¤§çš„æ”¹è¿›â€“Project Butteré»„æ²¹è®¡åˆ’ã€‚ Project Butterå¯¹Android Displayç³»ç»Ÿè¿›è¡Œäº†é‡æ„ï¼Œå¼•å…¥äº†ä¸‰ä¸ªæ ¸å¿ƒå…ƒç´ ï¼Œå³VSYNCã€Triple Bufferå’ŒChoreographerã€‚ VSYNCæœ€é‡è¦çš„ä½œç”¨æ˜¯é˜²æ­¢å‡ºç°ç”»é¢æ’•è£‚ï¼ˆscreentearingï¼‰ã€‚æ‰€è°“ç”»é¢æ’•è£‚ï¼Œå°±æ˜¯æŒ‡ä¸€ä¸ªç”»é¢ä¸Šå‡ºç°äº†ä¸¤å¸§ç”»é¢çš„å†…å®¹ï¼Œå¦‚ä¸‹å›¾ã€‚ ä¸ºä»€ä¹ˆä¼šå‡ºç°è¿™ç§æƒ…å†µå‘¢ï¼Ÿè¿™ç§æƒ…å†µä¸€èˆ¬æ˜¯å› ä¸ºæ˜¾å¡è¾“å‡ºå¸§çš„é€Ÿåº¦é«˜äºæ˜¾ç¤ºå™¨çš„åˆ·æ–°é€Ÿåº¦ï¼Œå¯¼è‡´æ˜¾ç¤ºå™¨å¹¶ä¸èƒ½åŠæ—¶å¤„ç†è¾“å‡ºçš„å¸§ï¼Œè€Œæœ€ç»ˆå‡ºç°äº†å¤šä¸ªå¸§çš„ç”»é¢éƒ½ç•™åœ¨äº†æ˜¾ç¤ºå™¨ä¸Šçš„é—®é¢˜ã€‚è¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬æ‰€è¯´çš„ç”»é¢æ’•è£‚ã€‚ è¿™ä¸ªå›¾ä¸­æœ‰ä¸‰ä¸ªå…ƒç´ ï¼ŒDisplayæ˜¯æ˜¾ç¤ºå±å¹•ï¼ŒGPUå’ŒCPUè´Ÿè´£æ¸²æŸ“å¸§æ•°æ®ï¼Œæ¯ä¸ªå¸§ä»¥æ–¹æ¡†è¡¨ç¤ºï¼Œå¹¶ä»¥æ•°å­—è¿›è¡Œç¼–å·ï¼Œå¦‚0ã€1ã€2ç­‰ç­‰ã€‚VSyncç”¨äºæŒ‡å¯¼åŒç¼“å†²åŒºçš„äº¤æ¢ã€‚ ä»¥æ—¶é—´çš„é¡ºåºæ¥çœ‹ä¸‹å°†ä¼šå‘ç”Ÿçš„å¼‚å¸¸ï¼š Step1. Displayæ˜¾ç¤ºç¬¬0å¸§æ•°æ®ï¼Œæ­¤æ—¶CPUå’ŒGPUæ¸²æŸ“ç¬¬1å¸§ç”»é¢ï¼Œè€Œä¸”èµ¶åœ¨Displayæ˜¾ç¤ºä¸‹ä¸€å¸§å‰å®Œæˆ Step2. å› ä¸ºæ¸²æŸ“åŠæ—¶ï¼ŒDisplayåœ¨ç¬¬0å¸§æ˜¾ç¤ºå®Œæˆåï¼Œä¹Ÿå°±æ˜¯ç¬¬1ä¸ªVSyncåï¼Œæ­£å¸¸æ˜¾ç¤ºç¬¬1å¸§ Step3. ç”±äºæŸäº›åŸå› ï¼Œæ¯”å¦‚CPUèµ„æºè¢«å ç”¨ï¼Œç³»ç»Ÿæ²¡æœ‰åŠæ—¶åœ°å¼€å§‹å¤„ç†ç¬¬2å¸§ï¼Œç›´åˆ°ç¬¬2ä¸ªVSyncå¿«æ¥å‰æ‰å¼€å§‹å¤„ç† Step4. ç¬¬2ä¸ªVSyncæ¥æ—¶ï¼Œç”±äºç¬¬2å¸§æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å°±ç»ªï¼Œæ˜¾ç¤ºçš„è¿˜æ˜¯ç¬¬1å¸§ã€‚è¿™ç§æƒ…å†µè¢«Androidå¼€å‘ç»„å‘½åä¸ºâ€Jankâ€ã€‚ Step5. å½“ç¬¬2å¸§æ•°æ®å‡†å¤‡å®Œæˆåï¼Œå®ƒå¹¶ä¸ä¼šé©¬ä¸Šè¢«æ˜¾ç¤ºï¼Œè€Œæ˜¯è¦ç­‰å¾…ä¸‹ä¸€ä¸ªVSyncã€‚ æ‰€ä»¥æ€»çš„æ¥è¯´ï¼Œå°±æ˜¯å±å¹•å¹³ç™½æ— æ•…åœ°å¤šæ˜¾ç¤ºäº†ä¸€æ¬¡ç¬¬1å¸§ã€‚åŸå› å¤§å®¶åº”è¯¥éƒ½çœ‹åˆ°äº†ï¼Œå°±æ˜¯CPUæ²¡æœ‰åŠæ—¶åœ°å¼€å§‹ç€æ‰‹å¤„ç†ç¬¬2å¸§çš„æ¸²æŸ“å·¥ä½œï¼Œä»¥è‡´â€å»¶è¯¯å†›æœºâ€ã€‚ å…¶å®æ€»ç»“ä¸Šé¢çš„è¿™ä¸ªæƒ…å†µä¹‹æ‰€ä»¥å‘ç”Ÿï¼Œé¦–å…ˆçš„åŸå› å°±åœ¨äºç¬¬äºŒå¸§æ²¡æœ‰åŠæ—¶çš„ç»˜åˆ¶ï¼ˆå½“ç„¶å³ä½¿ç¬¬äºŒå¸§åŠæ—¶ç»˜åˆ¶ï¼Œä¹Ÿä¾ç„¶å¯èƒ½å‡ºç°Jankï¼Œè¿™å°±æ˜¯åŒæ—¶å¼•å…¥ä¸‰é‡ç¼“å†²çš„ä½œç”¨ã€‚æˆ‘ä»¬å°†åœ¨ä¸‰é‡ç¼“å†²ä¸€èŠ‚ä¸­å†è®²è§£è¿™ç§æƒ…å†µï¼‰ã€‚é‚£ä¹ˆå¦‚ä½•ä½¿å¾—ç¬¬äºŒå¸§å³ä½¿è¢«ç»˜åˆ¶å‘¢ï¼Ÿ è¿™å°±æ˜¯æˆ‘ä»¬åœ¨Graphicç³»ç»Ÿä¸­å¼•å…¥VSYNCçš„åŸå› ï¼Œè€ƒè™‘ä¸‹é¢è¿™å¼ å›¾ï¼š å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œä¸€æ—¦VSyncå‡ºç°åï¼Œç«‹åˆ»å°±å¼€å§‹æ‰§è¡Œä¸‹ä¸€å¸§çš„ç»˜åˆ¶å·¥ä½œã€‚è¿™æ ·å°±å¯ä»¥å¤§å¤§é™ä½Jankå‡ºç°çš„æ¦‚ç‡ã€‚å¦å¤–ï¼ŒVSYNCå¼•å…¥åï¼Œè¦æ±‚ç»˜åˆ¶ä¹Ÿåªèƒ½åœ¨æ”¶åˆ°VSYNCæ¶ˆæ¯ä¹‹åæ‰èƒ½è¿›è¡Œï¼Œå› æ­¤ï¼Œä¹Ÿå°±æœç»äº†å¦å¤–ä¸€ç§æç«¯æƒ…å†µçš„å‡ºç°â€”CPUï¼ˆGPUï¼‰ä¸€ç›´ä¸åœçš„è¿›è¡Œç»˜åˆ¶ï¼Œå¸§çš„ç”Ÿæˆé€Ÿåº¦é«˜äºå±å¹•çš„åˆ·æ–°é€Ÿåº¦ï¼Œå¯¼è‡´ç”Ÿæˆçš„å¸§ä¸èƒ½è¢«æ˜¾ç¤ºï¼Œåªèƒ½ä¸¢å¼ƒï¼Œè¿™æ ·å°±å‡ºç°äº†ä¸¢å¸§çš„æƒ…å†µâ€”å¼•å…¥VSYNCåï¼Œç»˜åˆ¶çš„é€Ÿåº¦å°±å’Œå±å¹•åˆ·æ–°çš„é€Ÿåº¦ä¿æŒä¸€è‡´äº†ã€‚ äºŒã€VSyncä¿¡å·äº§ç”Ÿé‚£ä¹ˆVSYNCä¿¡å·æ˜¯å¦‚ä½•ç”Ÿæˆçš„å‘¢ï¼Ÿ Androidç³»ç»Ÿä¸­VSYNCä¿¡å·åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯ç¡¬ä»¶ç”Ÿæˆçš„ä¿¡å·ï¼Œä¸€ç§æ˜¯è½¯ä»¶æ¨¡æ‹Ÿçš„ä¿¡å·ã€‚ ç¡¬ä»¶ä¿¡å·æ˜¯ç”±HardwareComposeræä¾›çš„ï¼ŒHWCå°è£…äº†ç›¸å…³çš„HALå±‚ï¼Œå¦‚æœç¡¬ä»¶å‚å•†æä¾›çš„HALå±‚å®ç°èƒ½å®šæ—¶äº§ç”ŸVSYNCä¸­æ–­ï¼Œåˆ™ç›´æ¥ä½¿ç”¨ç¡¬ä»¶çš„VSYNCä¸­æ–­ï¼Œå¦åˆ™HardwareComposerå†…éƒ¨ä¼šé€šè¿‡VSyncThreadæ¥æ¨¡æ‹Ÿäº§ç”ŸVSYNCä¸­æ–­ï¼ˆå…¶å®ç°å¾ˆç®€å•ï¼Œå°±æ˜¯sleepå›ºå®šæ—¶é—´ï¼Œç„¶åå”¤é†’ï¼‰ã€‚ SurfaceFlingerçš„å¯åŠ¨è¿‡ç¨‹ä¸­inti()ä¼šåˆ›å»ºä¸€ä¸ªHWComposerå¯¹è±¡ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071HWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false) &#123; ... //é¦–å…ˆæ˜¯ä¸€äº›å’ŒVSYNCæœ‰å…³çš„ä¿¡æ¯çš„åˆå§‹åŒ– //å› ä¸ºåœ¨ç¡¬ä»¶æ”¯æŒçš„æƒ…å†µä¸‹ï¼ŒVSYNCçš„åŠŸèƒ½å°±æ˜¯ç”±HWCæä¾›çš„ for (size_t i=0 ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123; mLastHwVSync[i] = 0; mVSyncCounts[i] = 0; &#125; //æ ¹æ®é…ç½®æ¥çœ‹æ˜¯å¦éœ€è¦æ¨¡æ‹ŸVSYNCæ¶ˆæ¯ char value[PROPERTY_VALUE_MAX]; property_get(\"debug.sf.no_hw_vsync\", value, \"0\"); mDebugForceFakeVSync = atoi(value); ... // don't need a vsync thread if we have a hardware composer needVSyncThread = false; // always turn vsync off when we start,åªæ˜¯æš‚æ—¶å…³é—­ä¿¡å·ï¼Œåé¢ä¼šå†å¼€å¯ eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0); //æ˜¾ç„¶ï¼Œå¦‚æœéœ€è¦æ¨¡æ‹ŸVSyncä¿¡å·çš„è¯ï¼Œæˆ‘ä»¬éœ€è¦çº¿ç¨‹æ¥åšè¿™ä¸ªå·¥ä½œ if (needVSyncThread) &#123; // we don't have VSYNC support, we need to fake it //VSyncThreadç±»çš„å®ç°å¾ˆç®€å•ï¼Œæ— éå°±æ˜¯ä¸€ä¸ªè®¡æ—¶å™¨è€Œå·²ï¼Œå®šæ—¶å‘é€æ¶ˆæ¯è€Œå·² //TODO VSYNCä¸“é¢˜ mVSyncThread = new VSyncThread(*this); &#125; ... &#125; HWComposer::HWComposer( const sp&lt;SurfaceFlinger&gt;&amp; flinger, EventHandler&amp; handler) : mFlinger(flinger), mFbDev(0), mHwc(0), mNumDisplays(1), mCBContext(new cb_context), mEventHandler(handler), mDebugForceFakeVSync(false) &#123; ... //é¦–å…ˆæ˜¯ä¸€äº›å’ŒVSYNCæœ‰å…³çš„ä¿¡æ¯çš„åˆå§‹åŒ– //å› ä¸ºåœ¨ç¡¬ä»¶æ”¯æŒçš„æƒ…å†µä¸‹ï¼ŒVSYNCçš„åŠŸèƒ½å°±æ˜¯ç”±HWCæä¾›çš„ for (size_t i=0 ; i&lt;HWC_NUM_PHYSICAL_DISPLAY_TYPES ; i++) &#123; mLastHwVSync[i] = 0; mVSyncCounts[i] = 0; &#125; //æ ¹æ®é…ç½®æ¥çœ‹æ˜¯å¦éœ€è¦æ¨¡æ‹ŸVSYNCæ¶ˆæ¯ char value[PROPERTY_VALUE_MAX]; property_get(\"debug.sf.no_hw_vsync\", value, \"0\"); mDebugForceFakeVSync = atoi(value); ... // don't need a vsync thread if we have a hardware composer needVSyncThread = false; // always turn vsync off when we start,åªæ˜¯æš‚æ—¶å…³é—­ä¿¡å·ï¼Œåé¢ä¼šå†å¼€å¯ eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0); //æ˜¾ç„¶ï¼Œå¦‚æœéœ€è¦æ¨¡æ‹ŸVSyncä¿¡å·çš„è¯ï¼Œæˆ‘ä»¬éœ€è¦çº¿ç¨‹æ¥åšè¿™ä¸ªå·¥ä½œ if (needVSyncThread) &#123; // we don't have VSYNC support, we need to fake it //VSyncThreadç±»çš„å®ç°å¾ˆç®€å•ï¼Œæ— éå°±æ˜¯ä¸€ä¸ªè®¡æ—¶å™¨è€Œå·²ï¼Œå®šæ—¶å‘é€æ¶ˆæ¯è€Œå·² //TODO VSYNCä¸“é¢˜ mVSyncThread = new VSyncThread(*this); &#125; ... &#125; æˆ‘ä»¬æ¥çœ‹ä¸‹ä¸Šé¢è¿™æ®µä»£ç ã€‚ é¦–å…ˆmDebugForceFakeVSyncæ˜¯ä¸ºäº†è°ƒåˆ¶ï¼Œå¯ä»¥é€šè¿‡è¿™ä¸ªå˜é‡è®¾ç½®å¼ºåˆ¶ä½¿ç”¨è½¯ä»¶VSYNCæ¨¡æ‹Ÿã€‚ ç„¶åé’ˆå¯¹ä¸åŒçš„å±å¹•ï¼Œåˆå§‹åŒ–äº†ä»–ä»¬çš„mLastHwVSyncå’ŒmVSyncCountså€¼ã€‚ å¦‚æœç¡¬ä»¶æ”¯æŒï¼Œé‚£ä¹ˆå°±æŠŠneedVSyncThreadè®¾ç½®ä¸ºfalseï¼Œè¡¨ç¤ºä¸éœ€è¦è½¯ä»¶æ¨¡æ‹Ÿã€‚ æ¥ç€é€šè¿‡eventControlæ¥æš‚æ—¶çš„å…³é—­äº†VSYNCä¿¡å·ï¼Œè¿™ä¸€ç‚¹å°†åœ¨ä¸‹é¢è®²è§£eventControlæ—¶ä¸€å¹¶è®²è§£ã€‚ æœ€åï¼Œå¦‚æœéœ€è¦è½¯ä»¶æ¨¡æ‹ŸVsyncä¿¡å·çš„è¯ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°†é€šè¿‡ä¸€ä¸ªå•ç‹¬çš„VSyncThreadçº¿ç¨‹æ¥åšè¿™ä¸ªå·¥ä½œ(fake VSYNCæ˜¯è¿™ä¸ªçº¿ç¨‹å”¯ä¸€çš„ä½œç”¨)ã€‚æˆ‘ä»¬æ¥çœ‹ä¸‹è¿™ä¸ªçº¿ç¨‹ã€‚ è½¯ä»¶æ¨¡æ‹Ÿ 1234567891011121314151617181920212223242526272829303132333435bool HWComposer::VSyncThread::threadLoop() &#123; const nsecs_t period = mRefreshPeriod; //å½“å‰çš„æ—¶é—´ const nsecs_t now = systemTime(CLOCK_MONOTONIC); //ä¸‹ä¸€æ¬¡VSYNCåˆ°æ¥çš„æ—¶é—´ nsecs_t next_vsync = mNextFakeVSync; //ä¸ºäº†ç­‰å¾…ä¸‹ä¸ªæ—¶é—´åˆ°æ¥åº”è¯¥ä¼‘çœ çš„æ—¶é—´ nsecs_t sleep = next_vsync - now; //é”™è¿‡äº†VSYNCçš„æ—¶é—´ if (sleep &lt; 0) &#123; // we missed, find where the next vsync should be //é‡æ–°è®¡ç®—ä¸‹åº”è¯¥ä¼‘æ¯çš„æ—¶é—´ sleep = (period - ((now - next_vsync) % period)); //æ›´æ–°ä¸‹æ¬¡VSYNCçš„æ—¶é—´ next_vsync = now + sleep; &#125; //æ›´æ–°ä¸‹ä¸‹æ¬¡VSYNCçš„æ—¶é—´ mNextFakeVSync = next_vsync + period; struct timespec spec; spec.tv_sec = next_vsync / 1000000000; spec.tv_nsec = next_vsync % 1000000000; int err; do &#123; //çº³ç§’ç²¾åº¦çº§çš„ä¼‘çœ  err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &amp;spec, NULL); &#125; while (err&lt;0 &amp;&amp; errno == EINTR); if (err == 0) &#123; //ä¼‘çœ ä¹‹åï¼Œåˆ°äº†è¯¥å‘ç”ŸVSYNCçš„æ—¶é—´äº† mHwc.mEventHandler.onVSyncReceived(0, next_vsync); &#125; return true; &#125; è¿™ä¸ªå‡½æ•°å…¶å®å¾ˆç®€å•ï¼Œæ— éå°±æ˜¯ä¸€ä¸ªç®€å•çš„æ—¶é—´è®¡ç®—ï¼Œè®¡ç®—è¿‡ç¨‹æˆ‘å·²ç»å†™åœ¨äº†ç¨‹åºæ³¨é‡Šé‡Œé¢ã€‚æ€»ä¹‹åˆ°äº†åº”è¯¥å‘ç”ŸVSYNCä¿¡å·çš„æ—¶å€™ï¼Œå°±è°ƒç”¨äº†mHwc.mEventHandler.onVSyncReceived(0, next_vsync)å‡½æ•°æ¥é€šçŸ¥VSYNCçš„åˆ°æ¥ã€‚ æˆ‘ä»¬æ³¨æ„åˆ°mEventHandlerå®é™…ä¸Šæ˜¯åœ¨HWCåˆ›å»ºæ—¶è¢«ä¼ å…¥çš„ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹HWCåˆ›å»ºæ—¶çš„ä»£ç . 123456mHwc = new HWComposer(this, *static_cast&lt;HWComposer::EventHandler *&gt;(this)); class SurfaceFlinger : public BnSurfaceComposer, private IBinder::DeathRecipient, private HWComposer::EventHandler å¯ä»¥çœ‹åˆ°è¿™ä¸ªmEventHandlerå®é™…ä¸Šå°±æ˜¯SurfaceFlingerã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒVSYNCä¿¡å·åˆ°æ¥æ—¶ï¼ŒSurfaceFlingerçš„onVSyncReceivedå‡½æ•°å¤„ç†äº†è¿™ä¸ªæ¶ˆæ¯ã€‚ è¿™é‡Œæˆ‘ä»¬æš‚æ—¶å…ˆä¸å±•å¼€SurfaceFlingerå†…çš„é€»è¾‘å¤„ç†ï¼Œç­‰æˆ‘ä»¬ä¸‹é¢åˆ†æå®Œç¡¬ä»¶å®ç°åï¼Œä¸€å¹¶è¿›è¡Œåˆ†æ ç¡¬ä»¶å®ç° ä¸Šé¢æˆ‘ä»¬è®²äº†è½¯ä»¶å¦‚ä½•æ¨¡æ‹Ÿä¸€ä¸ªVSYNCä¿¡å·å¹¶é€šçŸ¥SurfaceFlinger,é‚£ä¹ˆç¡¬ä»¶åˆæ˜¯å¦‚ä½•å®ç°è¿™ä¸€ç‚¹çš„å‘¢ï¼Ÿ æˆ‘ä»¬å†ä¸€æ¬¡å›åˆ°HWCçš„åˆ›å»ºè¿‡ç¨‹ä¸­æ¥ï¼š 123456789101112131415if (mHwc) &#123; ALOGE(\"Lee Using %s version %u.%u\", HWC_HARDWARE_COMPOSER, (hwcApiVersion(mHwc) &gt;&gt; 24) &amp; 0xff, (hwcApiVersion(mHwc) &gt;&gt; 16) &amp; 0xff); if (mHwc-&gt;registerProcs) &#123; mCBContext-&gt;hwc = this; mCBContext-&gt;procs.invalidate = &amp;hook_invalidate; mCBContext-&gt;procs.vsync = &amp;hook_vsync; if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) mCBContext-&gt;procs.hotplug = &amp;hook_hotplug; else mCBContext-&gt;procs.hotplug = NULL; memset(mCBContext-&gt;procs.zero, 0, sizeof(mCBContext-&gt;procs.zero)); mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs); &#125; æ¥çœ‹ä¸‹ä¸Šé¢è¿™æ®µå®ç°ã€‚ å½“HWCæœ‰vsyncä¿¡å·ç”Ÿæˆæ—¶ï¼Œç¡¬ä»¶æ¨¡å—ä¼šé€šè¿‡procs.vsyncæ¥é€šçŸ¥è½¯ä»¶éƒ¨åˆ†ï¼Œå› æ­¤ä¹Ÿå°±æ˜¯è°ƒç”¨äº†hook_vsyncå‡½æ•°ã€‚ 123456789101112131415void HWComposer::hook_vsync(const struct hwc_procs* procs, int disp, int64_t timestamp) &#123; cb_context* ctx = reinterpret_cast&lt;cb_context*&gt;( const_cast&lt;hwc_procs_t*&gt;(procs)); ctx-&gt;hwc-&gt;vsync(disp, timestamp); &#125; void HWComposer::vsync(int disp, int64_t timestamp) &#123; //åªæœ‰çœŸå®çš„ç¡¬ä»¶è®¾å¤‡æ‰ä¼šäº§ç”ŸVSYNC if (uint32_t(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123; &#123; mLastHwVSync[disp] = timestamp; &#125; mEventHandler.onVSyncReceived(disp, timestamp); &#125; æˆ‘ä»¬å‘ç°æœ€åæ®Šé€”åŒå½’ï¼Œç¡¬ä»¶ä¿¡å·æœ€ç»ˆä¹Ÿé€šè¿‡onVSyncReceivedå‡½æ•°é€šçŸ¥åˆ°äº†SurfaceFlingeräº†ã€‚ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æä¸‹SurfaceFlingerçš„å¤„ç†è¿‡ç¨‹ã€‚ ä¸‰ã€Surfaceflingerå¯¹VSYNCæ¶ˆæ¯çš„å¤„ç†å…ˆæ¥ç›´æ¥çœ‹ä¸‹Surfaceflingerçš„onVSyncReceivedå‡½æ•°ï¼š 12345678910111213141516void SurfaceFlinger::onVSyncReceived(int32_t type, nsecs_t timestamp) &#123; bool needsHwVsync = false; &#123; // Scope for the lock Mutex::Autolock _l(mHWVsyncLock); if (type == 0 &amp;&amp; mPrimaryHWVsyncEnabled) &#123; needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp); &#125; &#125; if (needsHwVsync) &#123; enableHardwareVsync(); &#125; else &#123; disableHardwareVsync(false); &#125;&#125; mPrimaryDispSyncæ˜¯ä»€ä¹ˆï¼ŸaddResyncSampleæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ è¦å›ç­”è¿™ä¸‰ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆè¿˜æ˜¯å¾—å›åˆ°SurfaceFlingerçš„initå‡½æ•°ä¸­æ¥ã€‚ 6.3.1ã€Surfaceflinger.init()å…ˆçœ‹ä¸€ä¸‹æ€»ä½“flowï¼š 123456789101112131415161718192021void SurfaceFlinger::init() &#123; ALOGI( &quot;SurfaceFlinger&apos;s main thread ready to run. &quot; &quot;Initializing graphics H/W...&quot;); &#123; ...... // start the EventThread sp&lt;VSyncSource&gt; vsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, vsyncPhaseOffsetNs, true, &quot;app&quot;); mEventThread = new EventThread(vsyncSrc, *this); sp&lt;VSyncSource&gt; sfVsyncSrc = new DispSyncSource(&amp;mPrimaryDispSync, sfVsyncPhaseOffsetNs, true, &quot;sf&quot;); mSFEventThread = new EventThread(sfVsyncSrc, *this); mEventQueue.setEventThread(mSFEventThread); ...... &#125; ...... mEventControlThread = new EventControlThread(this); mEventControlThread-&gt;run(&quot;EventControl&quot;, PRIORITY_URGENT_DISPLAY); ......&#125; 2ä¸ªEventThreadå¯¹è±¡åˆ†åˆ«æ˜¯mEventThreadï¼Œç»™appç”¨ï¼ŒmSFEventThreadï¼Œç»™surfaceflingerè‡ªå·±ç”¨ã€‚ ä¸‹é¢ç»™å‡ºè¿™4ä¸ªThreadå…³ç³»å›¾ã€‚ è¿™ä¸¤ä¸ªDispSyncSourceå°±æ˜¯KKå¼•å…¥çš„é‡å¤§å˜åŒ–ã€‚Android 4.4(KitKat)å¼•å…¥äº†VSyncçš„è™šæ‹ŸåŒ–ï¼Œå³æŠŠç¡¬ä»¶çš„VSyncä¿¡å·å…ˆåŒæ­¥åˆ°ä¸€ä¸ªæœ¬åœ°VSyncæ¨¡å‹ä¸­ï¼Œå†ä»ä¸­ä¸€åˆ†ä¸ºäºŒï¼Œå¼•å‡ºä¸¤æ¡VSyncæ—¶é—´ä¸ä¹‹æœ‰å›ºå®šåç§»çš„çº¿ç¨‹ã€‚ç¤ºæ„å›¾å¦‚ä¸‹ï¼š Googleè¿™æ ·ä¿®æ”¹çš„ç›®çš„åˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ =åœ¨å½“å‰ä¸‰é‡ç¼“å†²åŒºçš„æ¶æ„ä¸‹ï¼Œå³å¯¹äºä¸€å¸§å†…å®¹ï¼Œå…ˆç­‰App UIç”»å®Œäº†ï¼ŒSurfaceFlingerå†å‡ºåœºå¯¹å…¶è¿›è¡Œåˆå¹¶æ¸²æŸ“åæ”¾å…¥framebufferï¼Œæœ€åæ•´åˆ°å±å¹•ä¸Šã€‚è€Œç°æœ‰çš„VSyncæ¨¡å‹æ˜¯è®©å¤§å®¶ä¸€èµ·å¼€å§‹å¹²æ´»ã€‚ è¿™ä¸ªæ¶æ„å…¶å®ä¼šäº§ç”Ÿä¸€ä¸ªé—®é¢˜ï¼Œå› ä¸ºAppå’ŒSurfaceFlingerè¢«åŒæ—¶å”¤é†’ï¼Œå¯¼è‡´ä»–ä»¬äºŒè€…æ€»æ˜¯ä¸€èµ·å·¥ä½œï¼Œå¿…ç„¶å¯¼è‡´VSyncæ¥ä¸´çš„æ—¶åˆ»ï¼Œè¿™äºŒè€…ä¹‹é—´äº§ç”Ÿäº†CPUèµ„æºçš„æŠ¢å ã€‚å› æ­¤ï¼Œè°·æ­Œç»™è¿™ä¸¤ä¸ªå·¥ä½œéƒ½åŠ ä¸Šä¸€ä¸ªå°å°çš„å»¶è¿Ÿï¼Œè®©è¿™ä¸¤ä¸ªå·¥ä½œå¹¶ä¸æ˜¯åŒæ—¶è¢«å”¤é†’ï¼Œè¿™æ ·å¤§å®¶å°±å¯ä»¥é”™å¼€ä½¿ç”¨èµ„æºçš„é«˜å³°æœŸï¼Œæé«˜å·¥ä½œçš„æ•ˆç‡ã€‚ è¿™ä¸¤ä¸ªå»¶è¿Ÿï¼Œå…¶å®å°±åˆ†åˆ«å¯¹åº”ä¸Šé¢ä»£ç ä¸­çš„vsyncSrcï¼ˆç»˜åˆ¶å»¶è¿Ÿï¼‰å’ŒsfVsyncSrcï¼ˆåˆæˆå»¶è¿Ÿï¼‰ã€‚ åœ¨åˆ›å»ºäº†ä¸¤ä¸ªDispSyncSourceå˜é‡åï¼Œæˆ‘ä»¬ä½¿ç”¨å®ƒä»¬æ¥åˆå§‹åŒ–äº†ä¸¤ä¸ªEventThreadã€‚ä¸‹é¢æˆ‘ä»¬æ¥è¯¦ç»†çœ‹ä¸‹EventThreadçš„åˆ›å»ºæµç¨‹ï¼š 123456789101112131415161718192021222324EventThread::EventThread(const sp&lt;VSyncSource&gt;&amp; src, SurfaceFlinger&amp; flinger) : mVSyncSource(src), mFlinger(flinger), mUseSoftwareVSync(false), mVsyncEnabled(false), mDebugVsyncEnabled(false), mVsyncHintSent(false) &#123; for (int32_t i=0 ; i&lt;DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) &#123; mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC; mVSyncEvent[i].header.id = 0; mVSyncEvent[i].header.timestamp = 0; mVSyncEvent[i].vsync.count = 0; &#125; struct sigevent se; se.sigev_notify = SIGEV_THREAD; se.sigev_value.sival_ptr = this; se.sigev_notify_function = vsyncOffCallback; se.sigev_notify_attributes = NULL; timer_create(CLOCK_MONOTONIC, &amp;se, &amp;mTimerId);&#125;void EventThread::onFirstRef() &#123; run(\"EventThread\", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);&#125; EventThreadçš„æ„é€ å‡½æ•°å¾ˆç®€å•ã€‚é‡ç‚¹æ˜¯å®ƒçš„onFirstRefå‡½æ•°å¯åŠ¨äº†ä¸€ä¸ªEventThreadçº¿ç¨‹ï¼Œäºæ˜¯ä¸‹é¢çš„ä»£ç æ‰æ˜¯é‡ç‚¹ï¼š 123456789101112131415bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event); ...... &#125; return true;&#125; ä¸Šé¢çš„å‡½æ•°æœ¬èº«å¹¶ä¸å¤æ‚ï¼Œå…¶ä¸­è°ƒç”¨äº†ä¸€ä¸ªwaitForEventçš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ç›¸å½“ä¹‹é•¿ï¼Œä¸ºäº†é˜²æ­¢ä»£ç å±•å¼€å¤ªå¤šï¼Œæˆ‘ä»¬è¿™é‡Œæš‚æ—¶ä¸å†è¯¦ç»†åˆ†æè¿™ä¸ªå‡½æ•°ã€‚æˆ‘ä»¬ç›®å‰åªéœ€è¦çŸ¥é“è¿™ä¸ªå‡½æ•°çš„æœ€é‡è¦çš„ä½œç”¨æ˜¯ç­‰å¾…Eventçš„åˆ°æ¥ï¼Œå¹¶ä¸”æŸ¥æ‰¾å¯¹eventæ„Ÿå…´è¶£çš„ç›‘å¬è€…ï¼Œè€Œåœ¨æ²¡æœ‰eventåˆ°æ¥æ—¶ï¼Œçº¿ç¨‹å¤„äºä¼‘çœ çŠ¶æ€ï¼Œç­‰å¾…eventçš„å”¤é†’ï¼ˆæˆ‘ä»¬å°†ä¸‹ä¸€ç¯‡VSYNCçš„æ¥æ”¶å’Œå¤„ç†ä¸­å±•å¼€åˆ†æè¿™ä¸ªå‡½æ•°ï¼‰ã€‚ è¿™æ ·ï¼ŒEventThreadçº¿ç¨‹å°±è¿è¡Œèµ·æ¥ï¼Œå¤„åœ¨ç­‰å¾…è¢«eventå”¤é†’çš„çŠ¶æ€ä¸‹ã€‚ MessageQueueå’ŒEventThreadå»ºç«‹è¿æ¥ ç®€å•è¯´æ˜å®ŒEventThreadä¹‹åï¼Œæˆ‘ä»¬å†æ¬¡å›åˆ°SurfaceFlingerçš„initè¿‡ç¨‹ä¸­æ¥ã€‚å›åˆ°init()å‡½æ•°ä»£ç ä¸­æ¥ï¼š å°†SurfaceFlingerçš„MessageQueueçœŸæ­£å’Œæˆ‘ä»¬åˆšæ‰åˆ›å»ºçš„EventThreadå»ºç«‹èµ·äº†è¿æ¥ï¼Œè¿™æ ·SurfaceFlingeræ‰èƒ½çœŸæ­£æ¥æ”¶åˆ°æ¥è‡ªHWCçš„VSYNCä¿¡å·ã€‚ æˆ‘ä»¬æ¥çœ‹ä¸‹è¿™æ®µä»£ç ï¼š 12345678void MessageQueue::setEventThread(const sp&lt;EventThread&gt;&amp; eventThread) &#123; mEventThread = eventThread; mEvents = eventThread-&gt;createEventConnection(); mEventTube = mEvents-&gt;getDataChannel(); mLooper-&gt;addFd(mEventTube-&gt;getFd(), 0, ALOOPER_EVENT_INPUT, MessageQueue::cb_eventReceiver, this); &#125; è¿™é‡Œä»£ç é€»è¾‘å…¶å®å¾ˆç®€å•ï¼Œå°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªåˆ°EventThreadçš„è¿æ¥ï¼Œå¾—åˆ°äº†å‘é€VSYNCäº‹ä»¶é€šçŸ¥çš„BitTubeï¼Œç„¶åç›‘æ§è¿™ä¸ªBitTubeä¸­çš„å¥—æ¥å­—ï¼Œå¹¶ä¸”æŒ‡å®šäº†æ”¶åˆ°é€šçŸ¥åçš„å›è°ƒå‡½æ•°ï¼ŒMessageQueue::cb_eventReceiverã€‚è¿™æ ·ä¸€æ—¦VSyncä¿¡å·ä¼ æ¥ï¼Œå‡½æ•°cb_eventReceiverå°†è¢«è°ƒç”¨ã€‚ å‘Eventhreadæ³¨å†Œä¸€ä¸ªäº‹ä»¶çš„ç›‘å¬è€…â€”-createEventConnection åœ¨SurfaceFlingerçš„initå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬è°ƒç”¨äº†mEventQueue.setEventThread(mSFEventThread)å‡½æ•°ï¼Œæˆ‘ä»¬åœ¨å‰é¢ä¸€ç« ä¸­å·²ç»æåˆ°è¿‡ï¼Œè¿™ä¸ªå‡½æ•°å°†SurfaceFlingerçš„MessageQueueçœŸæ­£å’Œæˆ‘ä»¬åˆšæ‰åˆ›å»ºçš„EventThreadå»ºç«‹èµ·äº†è¿æ¥ã€‚æˆ‘ä»¬æ¥çœ‹ä¸‹è¿™æ®µä»£ç ï¼š 12345678910111213141516sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this)); &#125; EventThread::Connection::Connection( const sp&lt;EventThread&gt;&amp; eventThread) : count(-1), mEventThread(eventThread), mChannel(new BitTube()) &#123; &#125; void EventThread::Connection::onFirstRef() &#123; mEventThread-&gt;registerDisplayEventConnection(this); &#125; status_t EventThread::registerDisplayEventConnection( const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; mDisplayEventConnections.add(connection); mCondition.broadcast(); &#125; è¿™ä¸ªå‡½æ•°ä¼šå¯¼è‡´ä¸€ä¸ªConnectionç±»çš„åˆ›å»ºï¼Œè€Œè¿™ä¸ªconnectionç±»ä¼šè¢«ä¿å­˜åœ¨EventThreadä¸‹çš„ä¸€ä¸ªå®¹å™¨å†…ã€‚ é€šè¿‡createEventConnectionè¿™æ ·ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å…¶å®å°±æ³¨å†Œäº†ä¸€ä¸ªäº‹ä»¶çš„ç›‘å¬è€…ï¼Œå¾—åˆ°äº†å‘é€VSYNCäº‹ä»¶é€šçŸ¥çš„BitTubeï¼Œç„¶åç›‘æ§è¿™ä¸ªBitTubeä¸­çš„å¥—æ¥å­—ï¼Œå¹¶ä¸”æŒ‡å®šäº†æ”¶åˆ°é€šçŸ¥åçš„å›è°ƒå‡½æ•°ï¼ŒMessageQueue::cb_eventReceiverã€‚è¿™æ ·ä¸€æ—¦VSyncä¿¡å·ä¼ æ¥ï¼Œå‡½æ•°cb_eventReceiverå°†è¢«è°ƒç”¨ã€‚ 6.3.2ã€VSyncä¿¡å·çš„å¤„ç†æˆ‘ä»¬åœ¨å‰é¢ä¸€ç« ä¹Ÿæåˆ°äº†æ— è®ºæ˜¯è½¯ä»¶æ–¹å¼è¿˜æ˜¯ç¡¬ä»¶æ–¹å¼ï¼ŒSurfaceFlingeræ”¶åˆ°VSyncä¿¡å·åï¼Œå¤„ç†å‡½æ•°éƒ½æ˜¯onVSyncReceivedå‡½æ•°ï¼š VSyncæ¶ˆæ¯å¤„ç†â€”-addResyncSample 12345678bool DispSync::addResyncSample(nsecs_t timestamp) &#123; size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES; mResyncSamples[idx] = timestamp; ...... updateModelLocked(); .......&#125; ç²—ç•¥æµè§ˆä¸‹è¿™ä¸ªå‡½æ•°ï¼Œå‘ç°å‰åŠéƒ¨åˆ†å…¶å®åœ¨åšä¸€äº›ç®€å•çš„è®¡æ•°ç»Ÿè®¡ï¼Œé‡ç‚¹å®ç°æ˜¾ç„¶æ˜¯updateModelLockedå‡½æ•°ï¼š 123456789101112131415161718192021222324252627282930void DispSync::updateModelLocked() &#123; if (mNumResyncSamples &gt;= MIN_RESYNC_SAMPLES_FOR_UPDATE) &#123; nsecs_t durationSum = 0; for (size_t i = 1; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; size_t prev = (idx + MAX_RESYNC_SAMPLES - 1) % MAX_RESYNC_SAMPLES; durationSum += mResyncSamples[idx] - mResyncSamples[prev]; &#125; mPeriod = durationSum / (mNumResyncSamples - 1); double sampleAvgX = 0; double sampleAvgY = 0; double scale = 2.0 * M_PI / double(mPeriod); for (size_t i = 0; i &lt; mNumResyncSamples; i++) &#123; size_t idx = (mFirstResyncSample + i) % MAX_RESYNC_SAMPLES; nsecs_t sample = mResyncSamples[idx]; double samplePhase = double(sample % mPeriod) * scale; sampleAvgX += cos(samplePhase); sampleAvgY += sin(samplePhase); &#125; sampleAvgX /= double(mNumResyncSamples); sampleAvgY /= double(mNumResyncSamples); mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale); ...... mThread-&gt;updateModel(mPeriod, mPhase); &#125; &#125; ä¸å¾—ä¸è¯´ï¼Œå‰é¢å¤§æ®µçš„æ•°å­¦è®¡ç®—è®©äººæœ‰äº›å›°æƒ‘ï¼Œæˆ‘ä»¬æš‚ä¸”è·³è¿‡ï¼Œå…ˆåˆ†æä¸‹ä¸»çº¿æµç¨‹ï¼Œä¹Ÿå°±æ˜¯mThread-&gt;updateModel(mPeriod, mPhase)è¿™ä¸ªè°ƒç”¨ï¼š DispSyncThread.updateModelçš„ç”¨é€” 123456void updateModel(nsecs_t period, nsecs_t phase) &#123; Mutex::Autolock lock(mMutex); mPeriod = period; mPhase = phase; mCond.signal(); &#125; updateModelæ˜¯DispSyncThreadç±»çš„å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æœ¬èº«ä»£ç å¾ˆçŸ­ï¼Œå…¶å®å®ƒçš„ä¸»è¦ä½œç”¨æ˜¯mCond.signalå‘é€ä¸€ä¸ªä¿¡å·ç»™ç­‰å¾…ä¸­çš„çº¿ç¨‹ã€‚é‚£ä¹ˆç©¶ç«Ÿæ˜¯è°åœ¨ç­‰å¾…è¿™ä¸ªæ¡ä»¶å‘¢ï¼Ÿ å…¶å®ç­‰å¾…è¿™ä¸ªæ¡ä»¶çš„æ­£æ˜¯DispSyncThreadçš„å¾ªç¯å‡½æ•°ï¼š 12345678910111213141516171819202122232425262728virtual bool threadLoop() &#123; status_t err; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); nsecs_t nextEventTime = 0; while (true) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t targetTime = 0; &#123; // Scope for lock Mutex::Autolock lock(mMutex); ...... if (mPeriod == 0) &#123; err = mCond.wait(mMutex); ...... &#125; nextEventTime = computeNextEventTimeLocked(now); targetTime = nextEventTime; ...... &#125; now = systemTime(SYSTEM_TIME_MONOTONIC); ...... callbackInvocations = gatherCallbackInvocationsLocked(now); &#125; if (callbackInvocations.size() &gt; 0) &#123; fireCallbackInvocations(callbackInvocations); &#125; &#125; return false; &#125; å¤§é‡çš„æ—¶é—´ç›¸å…³çš„è®¡ç®—å’ŒçŠ¶æ€çš„è½¬å˜æˆ‘ä»¬ä¸å†æ·±å…¥ç ”ç©¶ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹è¿™ä¸ªçº¿ç¨‹è¢«é€šçŸ¥å”¤é†’ä¹‹ååšçš„ä¸¤ä¸ªä¸»è¦çš„å‡½æ•°çš„å¤„ç†ï¼ŒgatherCallbackInvocationsLocked()å’ŒfireCallbackInvocations()ã€‚ gatherCallbackInvocationsLocked()çš„ä»£ç å…¶å®å¾ˆç®€å•ï¼š 12345678910111213141516Vector&lt;CallbackInvocation&gt; gatherCallbackInvocationsLocked(nsecs_t now) &#123; Vector&lt;CallbackInvocation&gt; callbackInvocations; nsecs_t ref = now - mPeriod; for (size_t i = 0; i &lt; mEventListeners.size(); i++) &#123; nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i], ref); if (t &lt; now) &#123; CallbackInvocation ci; ci.mCallback = mEventListeners[i].mCallback; ci.mEventTime = t; callbackInvocations.push(ci); mEventListeners.editItemAt(i).mLastEventTime = t; &#125; &#125; return callbackInvocations; &#125; å…¶å®å°±æ˜¯ä»mEventListenerså–å‡ºä¹‹å‰æ³¨å†Œçš„äº‹ä»¶ç›‘å¬è€…ï¼Œæ”¾å…¥callbackInvocationsä¸­ï¼Œç­‰å¾…åé¢çš„è°ƒç”¨ã€‚è‡³äºç›‘å¬è€…ä»ä½•å¤„è€Œæ¥ï¼Ÿåœ¨waitforeventæ—¶é€šè¿‡enableVSyncLockedæ³¨å†Œçš„ã€‚ ç»§ç»­çœ‹ä¸‹fireCallbackInvocations()å‡½æ•°ï¼š 12345void fireCallbackInvocations(const Vector&lt;CallbackInvocation&gt;&amp; callbacks) &#123; for (size_t i = 0; i &lt; callbacks.size(); i++) &#123; callbacks[i].mCallback-&gt;onDispSyncEvent(callbacks[i].mEventTime); &#125; &#125;` æˆ‘ä»¬ç›®å‰åªåˆ†æä¸»çº¿çš„èµ°å‘,æ¥ä¸‹æ¥è°ƒç”¨äº†DispSyncSourceçš„onDispSyncEventåœ¨ï¼š 1234567891011121314151617virtual void onDispSyncEvent(nsecs_t when) &#123; sp&lt;VSyncSource::Callback&gt; callback; &#123; callback = mCallback; &#125; if (callback != NULL) &#123; callback-&gt;onVSyncEvent(when); &#125; &#125; void EventThread::onVSyncEvent(nsecs_t timestamp) &#123; Mutex::Autolock _l(mLock); mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC; mVSyncEvent[0].header.id = 0; mVSyncEvent[0].header.timestamp = timestamp; mVSyncEvent[0].vsync.count++; mCondition.broadcast(); &#125; æˆ‘ä»¬çœ‹åˆ°è¿™é‡ŒmCondition.broadcaså‘å‡ºäº†å‘½ä»¤ï¼Œé‚£ä¹ˆEventThreadä¸­waitforEventçš„ç­‰å¾…å°±ä¼šè¢«å”¤é†’ã€‚è€Œä¸€æ—¦å”¤é†’ï¼Œæˆ‘ä»¬å°±å›åˆ°äº†EventThreadçš„loopä¸­ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹ä»£ç ï¼š 123456789101112131415bool EventThread::threadLoop() &#123; DisplayEventReceiver::Event event; Vector&lt; sp&lt;EventThread::Connection&gt; &gt; signalConnections; signalConnections = waitForEvent(&amp;event); // dispatch events to listeners... const size_t count = signalConnections.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Connection&gt;&amp; conn(signalConnections[i]); // now see if we still need to report this event status_t err = conn-&gt;postEvent(event); ...... &#125; return true; &#125; è¿™é‡Œä¸»è¦å°±æ˜¯é€šè¿‡conn-&gt;postEventæ¥åˆ†å‘äº‹ä»¶ï¼š 12345678910status_t EventThread::Connection::postEvent( const DisplayEventReceiver::Event&amp; event) &#123; ssize_t size = DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1); return size &lt; 0 ? status_t(size) : status_t(NO_ERROR); &#125; ssize_t DisplayEventReceiver::sendEvents(const sp&lt;BitTube&gt;&amp; dataChannel, Event const* events, size_t count) &#123; return BitTube::sendObjects(dataChannel, events, count); &#125; å…¶å®çœ‹åˆ°è¿™é‡Œçš„BitTubeæˆ‘ä»¬å°±æ˜ç™½äº†ï¼Œåœ¨æœ¬æ–‡å¼€å§‹æ—¶å€™æˆ‘ä»¬æåˆ°ï¼š é€šè¿‡createEventConnectionè¿™æ ·ä¸€ä¸ªç®€å•çš„æ–¹æ³•ï¼Œæˆ‘ä»¬å…¶å®å°±æ³¨å†Œäº†ä¸€ä¸ªäº‹ä»¶çš„ç›‘å¬è€…ï¼Œå¾—åˆ°äº†å‘é€VSYNCäº‹ä»¶é€šçŸ¥çš„BitTubeï¼Œç„¶åç›‘æ§è¿™ä¸ªBitTubeä¸­çš„å¥—æ¥å­—ï¼Œå¹¶ä¸”æŒ‡å®šäº†æ”¶åˆ°é€šçŸ¥åçš„å›è°ƒå‡½æ•°ï¼ŒMessageQueue::cb_eventReceiverã€‚è¿™æ ·ä¸€æ—¦VSyncä¿¡å·ä¼ æ¥ï¼Œå‡½æ•°cb_eventReceiverå°†è¢«è°ƒç”¨ã€‚ æ‰€ä»¥æˆ‘ä»¬è¿™é‡Œå¯ä»¥æ¥çœ‹çœ‹MessageQueue::cb_eventReceiverå‡½æ•°äº†ï¼š 123456789101112131415161718int MessageQueue::cb_eventReceiver(int fd, int events, void* data) &#123; MessageQueue* queue = reinterpret_cast&lt;MessageQueue *&gt;(data); return queue-&gt;eventReceiver(fd, events); &#125; int MessageQueue::eventReceiver(int fd, int events) &#123; ssize_t n; DisplayEventReceiver::Event buffer[8]; while ((n = DisplayEventReceiver::getEvents(mEventTube, buffer, 8)) &gt; 0) &#123; for (int i=0 ; i&lt;n ; i++) &#123; if (buffer[i].header.type == DisplayEventReceiver::DISPLAY_EVENT_VSYNC) &#123; mHandler-&gt;dispatchInvalidate(); break; &#125; &#125; &#125; return 1; &#125; æˆ‘ä»¬çœ‹åˆ°æ”¶åˆ°æ¶ˆæ¯ä¹‹åMessageQueueå¯¹æ¶ˆæ¯è¿›è¡Œäº†åˆ†å‘ï¼Œæˆ‘ä»¬ç›®å‰èµ°çš„æ˜¯dispatchInvalidate()ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839void MessageQueue::Handler::dispatchInvalidate() &#123; if ((android_atomic_or(eventMaskInvalidate, &amp;mEventMask) &amp; eventMaskInvalidate) == 0) &#123; mQueue.mLooper-&gt;sendMessage(this, Message(MessageQueue::INVALIDATE)); &#125; &#125; void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case TRANSACTION: android_atomic_and(~eventMaskTransaction, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125; &#125; void SurfaceFlinger::onMessageReceived(int32_t what) &#123; ATRACE_CALL(); switch (what) &#123; case MessageQueue::TRANSACTION: handleMessageTransaction(); break; case MessageQueue::INVALIDATE: handleMessageTransaction(); handleMessageInvalidate(); signalRefresh(); break; case MessageQueue::REFRESH: handleMessageRefresh(); break; &#125; &#125; åˆ°äº†è¿™é‡Œï¼Œå°±è¿›å…¥äº†SurfaceFlingerçš„å¤„ç†æµç¨‹ï¼Œæˆ‘ä»¬çœ‹åˆ°å¯¹äºINVALIDATEçš„æ¶ˆæ¯ï¼Œå®é™…ä¸Šç³»ç»Ÿåœ¨å¤„ç†è¿‡ç¨‹ä¸­å®é™…è¿˜æ˜¯ä¼šå‘é€ä¸€ä¸ªRefreshæ¶ˆæ¯ã€‚ 6.4ã€Appå‘Eventhreadæ³¨å†Œä¸€ä¸ªäº‹ä»¶çš„ç›‘å¬è€…â€“createEventConnection()åœ¨ViewRootImplçš„æ„é€ å‡½æ•°ä¸­ä¼šå®ä¾‹åŒ–Choreographerå¯¹è±¡ 1234public ViewRootImpl(Context context, Display display) &#123; . . . . . mChoreographer = Choreographer.getInstance(); &#125; åœ¨mChoreographer çš„æ„é€ å‡½æ•°ä¸­å®ä¾‹åŒ–FrameDisplayEventReceiverå¯¹è±¡ 1234private Choreographer(Looper looper) &#123; . . . . . . mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null; &#125; åœ¨FrameDisplayEventReceiverçš„çˆ¶ç±»æ„é€ å‡½æ•°ä¸­ä¼šè°ƒç”¨åˆ°ï¼Œandroid_view_DisplayEventReceiver.cppä¸­çš„nativeInitæ–¹æ³•,åœ¨nativeInitæ–¹æ³•ä¸­æœ‰å¦‚ä¸‹è¿‡ç¨‹ 1234567static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject messageQueueObj) &#123; . . . . . . sp&lt;NativeDisplayEventReceiver&gt; receiver = new NativeDisplayEventReceiver(env, receiverWeak, messageQueue); status_t status = receiver-&gt;initialize(); . . . . . . åˆ›å»ºNativeDisplayEventReceiverç±» ç±»å‹æŒ‡é’ˆ åœ¨NativeDisplayEventReceiverçš„æ„é€ å‡½æ•°ä¸­ä¼šè°ƒç”¨DisplayEventReceiverç±»çš„æ— å‚æ„é€ å‡½æ•°å®ä¾‹åŒ–æˆå‘˜mReceiverï¼› 123456789DisplayEventReceiver::DisplayEventReceiver() &#123; sp&lt;ISurfaceComposer&gt; sf(ComposerService::getComposerService()); if (sf != NULL) &#123; mEventConnection = sf-&gt;createDisplayEventConnection(); if (mEventConnection != NULL) &#123; mDataChannel = mEventConnection-&gt;getDataChannel(); &#125; &#125;&#125; åœ¨è¿™æ®µä»£ç ä¸­è·å–SurfaceflingeræœåŠ¡çš„ä»£ç†å¯¹è±¡ï¼Œç„¶åé€šè¿‡Binder IPCåˆ›å»ºBpDisplayEventConnectionå¯¹è±¡ è¯¥å‡½æ•°ç»ç”±BnSurfaceComposer.onTransactå‡½æ•°è¾—è½¬è°ƒç”¨åˆ°SurfaceFlinger.createDisplayEventConnectionå‡½æ•°ï¼š 123sp&lt;IDisplayEventConnection&gt; SurfaceFlinger::createDisplayEventConnection() &#123; return mEventThread-&gt;createEventConnection();&#125; å‡ºç°äº†ç†Ÿæ‚‰çš„é¢å­”mEventThreadï¼Œè¯¥å¯¹è±¡æ˜¯ä¸€ä¸ªEventThreadå¯¹è±¡ï¼Œè¯¥å¯¹è±¡åœ¨SurfaceFlinger.initå‡½æ•°é‡Œé¢åˆ›å»ºï¼Œä½†æ˜¯åˆ›å»ºè¿è¡Œä»¥åï¼Œè²Œä¼¼è¿˜æ²¡æœ‰è¿›è¡Œä»»ä½•çš„åŠ¨ä½œï¼Œè¿™é‡Œè°ƒç”¨createEventConnectionå‡½æ•°ï¼š 123sp&lt;EventThread::Connection&gt; EventThread::createEventConnection() const &#123; return new Connection(const_cast&lt;EventThread*&gt;(this));&#125; ç„¶åmEventConnection-&gt;getDataChannel()æ–¹æ³•å†æ¬¡é€šè¿‡Binder IPCåˆ›å»º BitTubeå¯¹è±¡mDataChannel ï¼Œåœ¨Binder IPCåˆ›å»ºmDataChannel è¿‡ç¨‹ä¸­ä¼šä»æœåŠ¡ç«¯EventThread::Connection::Connectionä¸­ï¼ˆåœ¨EventThreadç±»ä¸­å®šä¹‰ï¼‰æ¥æ”¶ä¸€ä¸ªsocketpairåˆ›å»ºçš„FIFOæ–‡ä»¶æè¿°ç¬¦ï¼› EventThread::Connection::Connectionåˆ›å»ºæè¿°ç¬¦çš„ä»£ç ï¼š Connectionæ„é€ å‡½æ•°è°ƒç”¨BitTubeçš„æ— å‚æ„é€ å‡½æ•°ï¼Œåœ¨BitTubeçš„æ„é€ å‡½æ•°ä¸­è°ƒç”¨initå‡½æ•°ï¼› 123456789101112131415161718void BitTube::init(size_t rcvbuf, size_t sndbuf) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets) == 0) &#123; size_t size = DEFAULT_SOCKET_BUFFER_SIZE; setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;rcvbuf, sizeof(rcvbuf)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;sndbuf, sizeof(sndbuf)); // sine we don't use the \"return channel\", we keep it small... setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;size, sizeof(size)); fcntl(sockets[0], F_SETFL, O_NONBLOCK); fcntl(sockets[1], F_SETFL, O_NONBLOCK); mReceiveFd = sockets[0]; mSendFd = sockets[1]; &#125; else &#123; mReceiveFd = -errno; ALOGE(\"BitTube: pipe creation failed (%s)\", strerror(-mReceiveFd)); &#125;&#125; è°ƒç”¨åˆ°NativeDisplayEventReceiverç±»çš„çˆ¶ç±»DisplayEventDispatcherä¸­çš„initialize()æ–¹æ³•ï¼Œ å°†BpDisplayEventConnectionå¯¹è±¡è·å–åˆ°çš„mDataChannel ï¼ˆBitTubeç±»å‹ï¼‰ä¸­çš„æ–‡ä»¶æè¿°ç¬¦æ·»åŠ åˆ°UIä¸»çº¿ç¨‹Looperçš„epollä¸­ï¼Œ å½“æ–‡ä»¶æè¿°ç¬¦ä¸­è¢«å†™å…¥æ•°æ®æ—¶ï¼Œè¯¥epoll_waitä¼šè¢«å”¤é†’ï¼› ç›´æ¥çœ‹ä»£ç ï¼š 123456789101112status_t NativeDisplayEventReceiver::initialize() &#123; status_t result = mReceiver.initCheck(); if (result) &#123; ALOGW(\"Failed to initialize display event receiver, status=%d\", result); return result; &#125; int rc = mMessageQueue-&gt;getLooper()-&gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL); if (rc &lt; 0) &#123; return UNKNOWN_ERROR; &#125; return OK;&#125; è¿™é‡Œçš„ä¸»è¦ä»£ç æ˜¯mMessageQueue-&gt;getLooper()-&gt;addFd()è¿™ä¸€è¡Œï¼Œå…¶ä¸­çš„å‚æ•°mReceiver.getFd()è¿”å›çš„æ˜¯åœ¨åˆ›å»ºNativeDisplayEventReceiveræ—¶ä»SurfaceFlingeræœåŠ¡ç«¯æ¥æ”¶å›æ¥çš„socketæ¥æ”¶ç«¯æè¿°ç¬¦ï¼Œå‰é¢åˆ†æåˆ° mMessageQueueæ˜¯ä¸å½“å‰åº”ç”¨çº¿ç¨‹å…³è”çš„javaå±‚çš„MessageQueueå¯¹åº”çš„nativeå±‚çš„MessageQueueå¯¹è±¡ï¼Œä¸‹é¢çœ‹ä¸€ä¸‹Looper.addFdè¿™ä¸ªå‡½æ•°ï¼Œä¸Šé¢è°ƒç”¨æ—¶ä¼ è¿›æ¥çš„thisæŒ‡é’ˆå¯¹åº”çš„æ˜¯ä¸€ä¸ªNativeDisplayEventReceiverå¯¹è±¡ï¼Œè¯¥ç±»ç»§æ‰¿äº†LooperCallbackï¼š 1234567891011121314151617181920212223242526272829303132333435363738int Looper::addFd(int fd, int ident, int events, Looper_callbackFunc callback, void* data) &#123; return addFd(fd, ident, events, callback ? new SimpleLooperCallback(callback) : NULL, data);&#125;int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123; int epollEvents = 0; if (events &amp; EVENT_INPUT) epollEvents |= EPOLLIN; if (events &amp; EVENT_OUTPUT) epollEvents |= EPOLLOUT; &#123; // acquire lock AutoMutex _l(mLock); Request request; request.fd = fd; request.ident = ident; request.callback = callback; request.data = data; struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union eventItem.events = epollEvents; eventItem.data.fd = fd; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; &#125; mRequests.add(fd, request); &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; return -1; &#125; mRequests.replaceValueAt(requestIndex, request); &#125; &#125; // release lock return 1;&#125; é¦–å…ˆå°†ä¸Šé¢ä¼ è¿›æ¥çš„NativeDisplayEventReceiverå¯¹è±¡å°è£…æˆä¸€ä¸ªSimpleLooperCallbackå¯¹è±¡ï¼Œè°ƒç”¨ä¸‹é¢çš„addFdå‡½æ•°çš„æ—¶å€™ä¸»è¦æ­¥éª¤å¦‚ä¸‹ï¼š ï¼ˆ1ï¼‰åˆ›å»ºä¸€ä¸ªstruct epoll_eventç»“æ„ä½“å¯¹è±¡ï¼Œå°†å¯¹åº”çš„å†…å­˜å…¨éƒ¨ç”¨æ¸…0ï¼Œå¹¶ä½œå¯¹åº”çš„åˆå§‹åŒ–ï¼› ï¼ˆ2ï¼‰æŸ¥è¯¢é€šè¿‡addFdæ–¹æ³•å·²ç»æ·»åŠ åˆ°epollä¸­ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦ï¼› ï¼ˆ3ï¼‰æŸ¥è¯¢ä¸åˆ°çš„è¯ï¼Œåˆ™è°ƒç”¨epoll_ctlæ–¹æ³•è®¾ç½®EPOLL_CTL_ADDå±æ€§å°†å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦æ·»åŠ åˆ°epollç›‘å¬çš„æè¿°ç¬¦ä¸­ï¼› ï¼ˆ4ï¼‰æ ¹æ®å‰é¢addFdä¼ å…¥çš„å‚æ•°EVENT_INPUTï¼Œè¯´æ˜å½“å‰åº”ç”¨çº¿ç¨‹çš„nativeå±‚çš„Looperå¯¹è±¡ä¸­çš„epollæœºåˆ¶å·²ç»å¼€å§‹ç›‘å¬æ¥è‡ªäºSurfaceFlingeræœåŠ¡ç«¯socketç«¯çš„å†™å…¥äº‹ä»¶ã€‚ 6.5ã€Appè¯·æ±‚Vsyncä¿¡å·å‰é¢è®²è§£ViewRootImpl.setView()çš„æ—¶å€™ï¼Œå› æ¶‰åŠåˆ°Vsyncä¿¡å·çŸ¥è¯†ï¼ŒrequestLayout()æ²¡æœ‰å…·ä½“è®²è§£ï¼Œç°åœ¨ç»§ç»­ã€‚ 12345678910111213Overridepublic void requestLayout() &#123; scheduleTraversals();&#125;void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); ...... &#125;&#125; [-&gt;Choreographer.java] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; ...... postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; ...... synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //å°†è¦æ‰§è¡Œçš„å›è°ƒå°è£…æˆCallbackRecordå¯¹è±¡ï¼Œä¿å­˜åˆ°mCallbackQueuesæ•°ç»„ä¸­ mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125;private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; æ¶ˆæ¯å¤„ç†ï¼š 12345678910111213141516171819202122232425 private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; &#125; &#125;&#125; void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; //ç”³è¯·Vsyncä¿¡å· mDisplayEventReceiver.scheduleVsync(); &#125; åœ¨è¯¥å‡½æ•°ä¸­è€ƒè™‘äº†ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯ç³»ç»Ÿæ²¡æœ‰ä½¿ç”¨Vsyncæœºåˆ¶ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¦–å…ˆæ ¹æ®å±å¹•åˆ·æ–°é¢‘ç‡è®¡ç®—ä¸‹ä¸€æ¬¡åˆ·æ–°æ—¶é—´ï¼Œé€šè¿‡å¼‚æ­¥æ¶ˆæ¯æ–¹å¼å»¶æ—¶æ‰§è¡ŒdoFrame()å‡½æ•°å®ç°å±å¹•åˆ·æ–°ã€‚å¦‚æœç³»ç»Ÿä½¿ç”¨äº†Vsyncæœºåˆ¶ï¼Œå¹¶ä¸”å½“å‰çº¿ç¨‹å…·å¤‡æ¶ˆæ¯å¾ªç¯ï¼Œåˆ™ç›´æ¥è¯·æ±‚Vsyncä¿¡å·ï¼Œå¦åˆ™å°±é€šè¿‡ä¸»çº¿ç¨‹æ¥è¯·æ±‚Vsyncä¿¡å·ã€‚ 6.5.1ã€Vsyncè¯·æ±‚è¿‡ç¨‹æˆ‘ä»¬çŸ¥é“åœ¨Choreographeræ„é€ å‡½æ•°ä¸­ï¼Œæ„é€ äº†ä¸€ä¸ªFrameDisplayEventReceiverå¯¹è±¡ï¼Œç”¨äºè¯·æ±‚å¹¶æ¥æ”¶Vsyncä¿¡å·ï¼ŒVsyncä¿¡å·è¯·æ±‚è¿‡ç¨‹å¦‚ä¸‹ï¼š 1234private void scheduleVsyncLocked() &#123; //ç”³è¯·Vsyncä¿¡å· mDisplayEventReceiver.scheduleVsync(); &#125; [-&gt;DisplayEventReceiver.java] 12345678public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125;&#125; [-&gt;android_view_DisplayEventReceiver.cpp ] 12345678910static void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;sp&lt;NativeDisplayEventReceiver&gt; receiver = reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);status_t status = receiver-&gt;scheduleVsync();if (status) &#123; String8 message; message.appendFormat(\"Failed to schedule next vertical sync pulse. status=%d\", status); jniThrowRuntimeException(env, message.string());&#125;&#125; VSyncè¯·æ±‚è¿‡ç¨‹åˆè½¬äº¤ç»™äº†DisplayEventReceiverï¼š [-&gt;DisplayEventReceiver.cpp] 1234567status_t DisplayEventReceiver::requestNextVsync() &#123;if (mEventConnection != NULL) &#123; mEventConnection-&gt;requestNextVsync(); return NO_ERROR;&#125;return NO_INIT;&#125; è¿™é‡Œçš„mEventConnectionä¹Ÿæ˜¯å‰é¢åˆ›å»ºnativeå±‚å¯¹è±¡NativeDisplayEventReceiveræ—¶åˆ›å»ºçš„ï¼Œå®é™…å¯¹è±¡æ˜¯ä¸€ä¸ªBpDisplayEventConnectionå¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªBinderå®¢æˆ·ç«¯ï¼Œå¯¹åº”çš„BinderæœåŠ¡ç«¯BnDisplayEventConnectionæ˜¯ä¸€ä¸ªEventThread::Connectionå¯¹è±¡ï¼Œå¯¹åº”çš„BpDisplayEventConnection.requestNextVsyncå‡½æ•°å’ŒBnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)å‡½æ•°æ²¡æœ‰è¿›è¡Œç‰¹åˆ«çš„å¤„ç†ï¼Œä¸‹é¢å°±è°ƒç”¨åˆ°EventThread::Connection.requestNextVsyncå‡½æ•°ï¼Œä»BnDisplayEventConnection.onTransact(REQUEST_NEXT_VSYNC)å¼€å§‹å·²ç»ä»ç”¨æˆ·è¿›ç¨‹å°†éœ€è¦å‚ç›´åŒæ­¥ä¿¡å·çš„è¯·æ±‚å‘é€åˆ°äº†SurfaceFlingerè¿›ç¨‹ï¼Œä¸‹é¢çš„å‡½æ•°è°ƒç”¨å¼€å§‹è¿›å…¥SFè¿›ç¨‹ï¼š 123void EventThread::Connection::requestNextVsync() &#123; mEventThread-&gt;requestNextVsync(this); &#125; è¾—è½¬è°ƒç”¨åˆ°EventThread.requestNextVsyncå‡½æ•°ï¼Œæ³¨æ„é‡Œé¢ä¼ äº†å‚æ•°thisï¼Œä¹Ÿå°±æ˜¯å½“å‰çš„EventThread::Connectionå¯¹è±¡ï¼Œéœ€è¦æ˜ç¡®çš„æ˜¯ï¼Œè¿™é‡Œçš„mEventThreadå¯¹è±¡æ˜¯åˆ›å»ºEventThread::Connectionå¯¹è±¡çš„æ—¶å€™ä¿å­˜çš„ï¼Œå¯¹åº”çš„æ˜¯SurfaceFlingerå¯¹è±¡çš„é‡Œé¢çš„mEventThreadæˆå‘˜ï¼Œè¯¥å¯¹è±¡æ˜¯ä¸€ä¸ªåœ¨SurfaceFlinger.inité‡Œé¢åˆ›å»ºå¹¶å¯åŠ¨çš„çº¿ç¨‹å¯¹è±¡ï¼Œå¯è§è®¾è®¡çš„æ—¶å€™å°±ä¸“é—¨ç”¨è¿™ä¸ªSurfaceFlinger.mEventThreadçº¿ç¨‹æ¥æ¥æ”¶æ¥è‡ªåº”ç”¨è¿›ç¨‹çš„åŒæ­¥ä¿¡å·è¯·æ±‚ï¼Œæ¯æ¥ä¸€ä¸ªåº”ç”¨è¿›ç¨‹åŒæ­¥ä¿¡å·è¯·æ±‚ï¼Œå°±é€šè¿‡SurfaceFlinger.mEventThreadåˆ›å»ºä¸€ä¸ªEventThread::Connectionå¯¹è±¡ï¼Œå¹¶é€šè¿‡EventThread.registerDisplayEventConnectionå‡½æ•°å°†åˆ›å»ºçš„EventThread::Connectionå¯¹è±¡ä¿å­˜åˆ°EventThread.mDisplayEventConnectionsé‡Œé¢ï¼Œä¸Šé¢æœ‰è°ƒç”¨åˆ°äº†EventThread.requestNextVsyncå‡½æ•°ï¼š 1234567void EventThread::requestNextVsync(const sp&lt;EventThread::Connection&gt;&amp; connection) &#123; Mutex::Autolock _l(mLock); if (connection-&gt;count &lt; 0) &#123; connection-&gt;count = 0; mCondition.broadcast(); &#125;&#125; ä¼ è¿›æ¥çš„æ˜¯ä¸€ä¸ªå‰é¢åˆ›å»ºçš„EventThread::Connectionå¯¹è±¡ï¼Œé‡Œé¢åˆ¤æ–­åˆ°äº†EventThread::Connection.countæˆå‘˜å˜é‡ï¼Œçœ‹ä¸€ä¸‹EventThread::Connectionæ„é€ å‡½æ•°ä¸­åˆå§‹å˜é‡çš„å€¼ï¼š 123EventThread::Connection::Connection(const sp&lt;EventThread&gt;&amp; eventThread) : count(-1), mEventThread(eventThread), mChannel(new BitTube())&#123;&#125; å¯ä»¥çœ‹åˆ°åˆå§‹å€¼æ˜¯-1ï¼Œè¿™ä¸ªå€¼å°±æ˜¯å‰é¢é‚£ä¸ªé—®é¢˜çš„å…³é”®ï¼ŒEventThread::Connection.countæ ‡ç¤ºäº†è¿™æ¬¡åº”ç”¨è¿›ç¨‹çš„å‚ç›´åŒæ­¥ä¿¡å·çš„è¯·æ±‚æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œè¿˜æ˜¯å¤šæ¬¡é‡å¤çš„ï¼Œçœ‹ä¸€ä¸‹æ³¨é‡Šé‡Œé¢å¯¹äºè¿™ä¸ªå˜é‡çš„è¯´æ˜ï¼š 1234// count &gt;= 1 : continuous event. count is the vsync rate// count == 0 : one-shot event that has not fired// count ==-1 : one-shot event that fired this round / disabledint32_t count; å¾ˆæ¸…æ¥šçš„è¯´æ˜äº†ï¼Œcount = 0è¯´æ˜å½“å‰çš„å‚ç›´åŒæ­¥ä¿¡å·è¯·æ±‚æ˜¯ä¸€ä¸ªä¸€æ¬¡æ€§çš„è¯·æ±‚ï¼Œå¹¶ä¸”è¿˜æ²¡æœ‰è¢«å¤„ç†ã€‚ä¸Šé¢EventThread::requestNextVsyncé‡Œé¢å°†countè®¾ç½®æˆ0ï¼ŒåŒæ—¶è°ƒç”¨äº†mCondition.broadcast()å”¤é†’æ‰€æœ‰æ­£åœ¨ç­‰å¾…mConditionçš„çº¿ç¨‹ï¼Œè¿™ä¸ªä¼šè§¦å‘EventThread.waitForEventå‡½æ•°ä»ï¼š 1mCondition.wait(mLock); ä¸­é†’æ¥ï¼Œé†’æ¥ä¹‹åç»è¿‡ä¸€è½®doâ€¦whileå¾ªç¯å°±ä¼šè¿”å›ï¼Œè¿”å›ä»¥åè°ƒç”¨åºåˆ—å¦‚ä¸‹ï¼š ï¼ˆ1ï¼‰EventThread::Connection.postEvent(event) ï¼ˆ2ï¼‰DisplayEventReceiver::sendEvents(mChannel, &amp;event, 1)ï¼ŒmChannelå‚æ•°å°±æ˜¯å‰é¢åˆ›å»ºDisplayEventReceiveræ˜¯åˆ›å»ºçš„BitTubeå¯¹è±¡ ï¼ˆ3ï¼‰BitTube::sendObjects(dataChannel, events, count)ï¼Œstaticå‡½æ•°ï¼Œé€šè¿‡dataChannelæŒ‡å‘BitTubeå¯¹è±¡ æœ€ç»ˆè°ƒç”¨åˆ°BitTube::sendObjectså‡½æ•°ï¼š 12345ssize_t BitTube::sendObjects(const sp&lt;BitTube&gt;&amp; tube, void const* events, size_t count, size_t objSize)&#123; const char* vaddr = reinterpret_cast&lt;const char*&gt;(events); ssize_t size = tube-&gt;write(vaddr, count*objSize); return size &lt; 0 ? size : size / static_cast&lt;ssize_t&gt;(objSize);&#125; ç»§ç»­è°ƒç”¨åˆ°BitTube::writeå‡½æ•°ï¼š 123456789ssize_t BitTube::write(void const* vaddr, size_t size)&#123; ssize_t err, len; do &#123; len = ::send(mSendFd, vaddr, size, MSG_DONTWAIT | MSG_NOSIGNAL); // cannot return less than size, since we're using SOCK_SEQPACKET err = len &lt; 0 ? errno : 0; &#125; while (err == EINTR); return err == 0 ? len : -err;&#125; è¿™é‡Œè°ƒç”¨åˆ°äº†::sendå‡½æ•°ï¼Œ::æ˜¯ä½œç”¨åŸŸæè¿°ç¬¦ï¼Œå¦‚æœå‰é¢æ²¡æœ‰ç±»åä¹‹ç±»çš„ï¼Œä»£è¡¨çš„å°±æ˜¯å…¨å±€çš„ä½œç”¨åŸŸï¼Œä¹Ÿå°±æ˜¯è°ƒç”¨å…¨å±€å‡½æ•°sendï¼Œè¿™é‡Œå¾ˆå®¹æ˜“å°±èƒ½æƒ³åˆ°è¿™æ˜¯ä¸€ä¸ªsocketçš„å†™å…¥å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯å°†eventäº‹ä»¶æ•°æ®å†™å…¥åˆ°BitTubeä¸­äº’è”çš„socketä¸­ï¼Œè¿™æ ·åœ¨å¦ä¸€ç«¯é©¬ä¸Šå°±èƒ½æ”¶åˆ°å†™å…¥çš„æ•°æ®ï¼Œå‰é¢åˆ†æåˆ°è¿™ä¸ªBitTubeçš„socketçš„ä¸¤ç«¯è¿æ¥ç€SurfaceFlingerè¿›ç¨‹å’Œåº”ç”¨è¿›ç¨‹ï¼Œä¹Ÿå°±æ˜¯è¯´é€šè¿‡è°ƒç”¨BitTube::writeå‡½æ•°ï¼Œå°†æœ€åˆç”±SurfaceFlingeræ•è·åˆ°çš„å‚ç›´ä¿¡å·äº‹ä»¶ç»ç”±BitTubeä¸­äº’è”çš„socketä»SurfaceFlingerè¿›ç¨‹å‘é€åˆ°äº†åº”ç”¨è¿›ç¨‹ä¸­BitTubeçš„socketæ¥æ”¶ç«¯ã€‚ ä¸‹é¢å°±è¦åˆ†æåº”ç”¨è¿›ç¨‹æ˜¯å¦‚ä½•æ¥æ”¶å¹¶ä½¿ç”¨è¿™ä¸ªå‚ç›´åŒæ­¥ä¿¡å·äº‹ä»¶çš„ã€‚ 6.5.2ã€åº”ç”¨è¿›ç¨‹æ¥æ”¶VSync6.5.2.1ã€è§£æVSyncäº‹ä»¶VSyncåŒæ­¥ä¿¡å·äº‹ä»¶å·²ç»å‘é€åˆ°ç”¨æˆ·è¿›ç¨‹ä¸­çš„socketæ¥æ”¶ç«¯ï¼Œåœ¨å‰é¢NativeDisplayEventReceiver.initializeä¸­åˆ†æåˆ°åº”ç”¨è¿›ç¨‹ç«¯çš„socketæ¥æ”¶æè¿°ç¬¦å·²ç»è¢«æ·»åŠ åˆ°Choreographeræ‰€åœ¨çº¿ç¨‹çš„nativeå±‚çš„Looperæœºåˆ¶ä¸­ï¼Œåœ¨epollä¸­ç›‘å¬EPOLLINäº‹ä»¶ï¼Œå½“socketæ”¶åˆ°æ•°æ®åï¼Œepollä¼šé©¬ä¸Šè¿”å›ï¼Œä¸‹é¢åˆ†æ­¥éª¤çœ‹ä¸€ä¸‹Looper.pollInner()æ•°ï¼š ï¼ˆ1ï¼‰epoll_wait 12struct epoll_event eventItems[EPOLL_MAX_EVENTS];int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); åœ¨ç›‘å¬åˆ°æè¿°ç¬¦å¯¹åº”çš„äº‹ä»¶åï¼Œepoll_waitä¼šé©¬ä¸Šè¿”å›ï¼Œå¹¶å°†äº§ç”Ÿçš„å…·ä½“äº‹ä»¶ç±»å‹å†™å…¥åˆ°å‚æ•°eventItemsé‡Œé¢ï¼Œæœ€ç»ˆè¿”å›çš„eventCountæ˜¯ç›‘å¬åˆ°çš„äº‹ä»¶çš„ä¸ªæ•° ï¼ˆ2ï¼‰äº‹ä»¶åˆ†æ 12345678910111213141516171819202122232425for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeReadPipeFd) &#123; //åˆ¤æ–­æ˜¯ä¸æ˜¯pipeè¯»ç®¡é“çš„äº‹ä»¶ è¿™é‡Œå¦‚æœæ˜¯EventThread,è¿™é‡Œå°±æ˜¯ä¸€ä¸ªsocketçš„æè¿°ç¬¦,è€Œä¸æ˜¯mWakeReadPipeFd if (epollEvents &amp; EPOLLIN) &#123; awoken(); // æ¸…ç©ºè¯»ç®¡é“ä¸­çš„æ•°æ® &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake read pipe.\", epollEvents); &#125; &#125; else &#123; //EventThreadæ¥æ”¶åˆ°åŒæ­¥ä¿¡å·èµ°çš„è¿™é‡Œ ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex)); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125; &#125; Looperç›®å‰äº†è§£åˆ°çš„ä¸»è¦ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦ç§ç±»æœ‰ä¸¤ç§ï¼š 1ï¼‰æ¶ˆæ¯äº‹ä»¶ï¼Œepoll_waitç›‘å¬pipeç®¡é“çš„æ¥æ”¶ç«¯æè¿°ç¬¦mWakeReadPipeFd 2ï¼‰ä¸VSyncä¿¡å·ï¼Œepoll_waitç›‘å¬socketæ¥æ”¶ç«¯æè¿°ç¬¦ï¼Œå¹¶åœ¨addFdçš„è¿‡ç¨‹ä¸­å°†ç›¸å…³çš„ä¿¡æ¯å°è£…åœ¨ä¸€ä¸ªRequestç»“æ„ä¸­ï¼Œå¹¶ä»¥fdä¸ºkeyå­˜å‚¨åˆ°äº†mRequestsä¸­ï¼Œå…·ä½“å¯ä»¥å›è¿‡å¤´çœ‹3.1.2å…³äºaddFdçš„åˆ†æï¼› å› æ­¤ï¼Œä¸Šé¢èµ°çš„æ˜¯elseçš„åˆ†æ”¯ï¼Œè¾¨åˆ«å‡ºå½“å‰çš„äº‹ä»¶ç±»å‹åï¼Œè°ƒç”¨pushResponseï¼š 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; //å¤åˆ¶ä¸æ˜¯å¼•ç”¨ï¼Œè°ƒç”¨æ‹·è´æ„é€ å‡½æ•° mResponses.push(response);&#125; è¯¥å‡½æ•°å°†Requestå’Œeventså°è£…åœ¨ä¸€ä¸ªResponseå¯¹è±¡é‡Œé¢ï¼Œå­˜å‚¨åˆ°äº†mResponsesé‡Œé¢ï¼Œä¹Ÿå°±æ˜¯mResponsesé‡Œé¢æ”¾çš„æ˜¯â€æŸæŸfdä¸Šæ¥æ”¶åˆ°äº†ç±»åˆ«ä¸ºeventsçš„æ—¶é—´â€è®°å½•ï¼Œç»§ç»­å‘ä¸‹çœ‹Looper.pollInnerå‡½æ•° ï¼ˆ3ï¼‰äº‹ä»¶åˆ†å‘å¤„ç† 1234567891011121314151617// Invoke all response callbacks.for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd); &#125; // Clear the callback reference in the response structure promptly because we // will not clear the response vector itself until the next poll. response.request.callback.clear(); result = POLL_CALLBACK; &#125;&#125; è¿™é‡Œçš„response.requestæ˜¯ä»pushResponseé‡Œé¢å¤åˆ¶è¿‡æ¥çš„ï¼Œé‡Œé¢çš„requestå¯¹åº”çš„Requestå¯¹è±¡æ˜¯åœ¨addFdçš„æ—¶å€™åˆ›å»ºçš„ï¼Œidentæˆå‘˜å°±æ˜¯POLL_CALLBACKï¼Œæ‰€ä»¥ç»§ç»­èµ°åˆ°response.request.callback-&gt;handleEventè¿™ä¸ªå‡½æ•°ï¼Œå›å¿†ä¸€ä¸‹3.1.2é‡Œé¢çš„addFdå‡½æ•°ï¼Œè¿™é‡Œçš„callbackå®é™…ä¸Šæ˜¯ä¸€ä¸ªSimpleLooperCallbackï¼ˆå®šä¹‰åœ¨Looper.cppä¸­ï¼‰å¯¹è±¡ï¼Œçœ‹ä¸€ä¸‹é‡Œé¢çš„handleEventå‡½æ•°ï¼š 123int SimpleLooperCallback::handleEvent(int fd, int events, void* data) &#123; return mCallback(fd, events, data);&#125; è¿™é‡Œçš„mCallbackå°±æ˜¯å½“æ—¶åœ¨addFdçš„æ—¶å€™ä¼ è¿›æ¥çš„callBackå‚æ•°ï¼Œå®é™…ä¸Šå¯¹åº”çš„å°±æ˜¯NativeDisplayEventReceiverå¯¹è±¡æœ¬èº«ï¼Œå› æ­¤æœ€ç»ˆå°±å°†å‚ç›´åŒæ­¥ä¿¡å·äº‹ä»¶åˆ†å‘åˆ°äº†NativeDisplayEventReceiver.handleEventå‡½æ•°ä¸­ã€‚ 6.5.3ã€VSyncäº‹ä»¶åˆ†å‘è°ƒç”¨åˆ°NativeDisplayEventReceiver.handleEventå‡½æ•°ï¼Œè¯¥å‡½æ•°å®šä¹‰åœ¨android_view_DisplayEventReceiver.cppä¸­ï¼Œç›´æ¥åˆ—å‡ºè¯¥å‡½æ•°ï¼š 1234567891011121314151617181920212223int NativeDisplayEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123; ALOGE(\"Display event receiver pipe was closed or an error occurred. \" \"events=0x%x\", events); return 0; // remove the callback &#125; if (!(events &amp; Looper::EVENT_INPUT)) &#123; ALOGW(\"Received spurious callback for unhandled poll event. \" \"events=0x%x\", events); return 1; // keep the callback &#125; // Drain all pending events, keep the last vsync. nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123; ALOGV(\"receiver %p ~ Vsync pulse: timestamp=%\" PRId64 \", id=%d, count=%d\", this, vsyncTimestamp, vsyncDisplayId, vsyncCount); mWaitingForVsync = false; dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount); &#125; return 1; // keep the callback&#125; é¦–å…ˆåˆ¤æ–­äº‹ä»¶æ˜¯ä¸æ˜¯æ­£ç¡®çš„Looper::EVENT_INPUTäº‹ä»¶ï¼Œç„¶åè°ƒç”¨åˆ°NativeDisplayEventReceiver.processPendingEventså‡½æ•°ï¼š 123456789101112131415161718192021222324252627282930bool NativeDisplayEventReceiver::processPendingEvents(nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123; bool gotVsync = false; DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE]; ssize_t n; while ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; 0) &#123; for (ssize_t i = 0; i &lt; n; i++) &#123; const DisplayEventReceiver::Event&amp; ev = buf[i]; switch (ev.header.type) &#123; case DisplayEventReceiver::DISPLAY_EVENT_VSYNC: // Later vsync events will just overwrite the info from earlier // ones. That's fine, we only care about the most recent. gotVsync = true; *outTimestamp = ev.header.timestamp; *outId = ev.header.id; *outCount = ev.vsync.count; break; case DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG: dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected); break; default: ALOGW(\"receiver %p ~ ignoring unknown event type %#x\", this, ev.header.type); break; &#125; &#125; &#125; if (n &lt; 0) &#123; ALOGW(\"Failed to get events from display event receiver, status=%d\", status_t(n)); &#125; return gotVsync;&#125; è¿™é‡Œçš„mReceiverä¹Ÿå°±æ˜¯å‰é¢åˆ›å»ºNativeDisplayEventReceiverå¯¹è±¡æ˜¯åˆ›å»ºçš„æˆå‘˜å˜é‡å¯¹è±¡DisplayEventReceiverï¼Œä¸‹é¢è°ƒç”¨åˆ°DisplayEventReceiver.getEventså‡½æ•°ï¼Œåº”è¯¥æ˜¯è¦ä»å‡ºç°åŒæ­¥ä¿¡å·äº‹ä»¶çš„socketä¸­è¯»å–æ•°æ®ï¼Œä¸Šé¢Looperæœºåˆ¶ä¸­epollä¸­ç›‘å¬åˆ°socketä»¥åï¼Œè¿”å›åˆ°NativeDisplayEventReceiver.handleEventé‡Œé¢ï¼Œä½†æ˜¯socketé‡Œé¢çš„æ•°æ®è¿˜æ²¡æœ‰è¯»å–ï¼Œä¸‹é¢çš„è°ƒç”¨æµç¨‹ä¸ºï¼š ï¼ˆ1ï¼‰mReceiver.getEvents(buf, EVENT_BUFFER_SIZE) â€”&gt; DisplayEventReceiver::getEvents(DisplayEventReceiver::Event _events, sizet count) ï¼ˆ2ï¼‰BitTube::recvObjects(dataChannel, events, count) â€”&gt; BitTube::recvObjects(const sp&amp; tube, void events, size_t count, size_t objSize) çœ‹ä¸€ä¸‹è¿™ä¸ªrecvObjectså‡½æ•°ï¼š 123456ssize_t BitTube::recvObjects(const sp&lt;BitTube&gt;&amp; tube, void* events, size_t count, size_t objSize)&#123; char* vaddr = reinterpret_cast&lt;char*&gt;(events); ssize_t size = tube-&gt;read(vaddr, count*objSize); return size &lt; 0 ? size : size / static_cast&lt;ssize_t&gt;(objSize);&#125; è¿™é‡Œåœ¨NativeDisplayEventReceiverä¸­åˆ›å»ºäº†ä¸€ä¸ªç¼“å†²åŒºï¼Œå¹¶åœ¨recvObjectsä¸­å°†socketä¸­çš„Eventæ•°æ®è¯»åˆ°è¿™ä¸ªç¼“å†²åŒºä¸­ï¼Œè¿™ä¸ªEvent.header.typeä¸€èˆ¬éƒ½æ˜¯DISPLAY_EVENT_VSYNCï¼Œå› æ­¤åœ¨ä¸Šé¢çš„processPendingEventså‡½æ•°ä¸­ä¼šå°†Eventæ•°æ®ä¿å­˜åœ¨outCountæ‰€æŒ‡å‘çš„å†…å­˜ä¸­ï¼Œå¹¶è¿”å›trueã€‚ æ¥ä¸‹æ¥è¿”å›åˆ°NativeDisplayEventReceiver.handleEventåä¼šè°ƒç”¨åˆ°dispatchVsyncå‡½æ•°ï¼š 12345void NativeDisplayEventReceiver::dispatchVsync(nsecs_t timestamp, int32_t id, uint32_t count) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); env-&gt;CallVoidMethod(mReceiverObjGlobal, gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count); mMessageQueue-&gt;raiseAndClearException(env, \"dispatchVsync\");&#125; è¿™é‡Œçš„å¤„ç†å¾ˆç›´æ¥ï¼Œç›´æ¥è°ƒç”¨mReceiverObjGlobalå¯¹è±¡åœ¨gDisplayEventReceiverClassInfo.dispatchVsyncä¸­æŒ‡å®šçš„å‡½æ•°ï¼Œå°†åé¢çš„timestampï¼ˆæ—¶é—´æˆ³ï¼‰ idï¼ˆè®¾å¤‡IDï¼‰ countï¼ˆç»è¿‡çš„åŒæ­¥ä¿¡å·çš„æ•°é‡ï¼Œä¸€èˆ¬æ²¡æœ‰è®¾ç½®é‡‡æ ·é¢‘ç‡åº”è¯¥éƒ½æ˜¯1ï¼‰ï¼Œä¸‹é¢åˆ†åˆ«çœ‹ä¸€ä¸‹mReceiverObjGlobalä»¥åŠgDisplayEventReceiverClassInfo.dispatchVsyncä»£è¡¨çš„æ˜¯ä»€ä¹ˆï¼Ÿ ï¼ˆ1ï¼‰mReceiverObjGlobal 1234NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env, jobject receiverObj, const sp&lt;MessageQueue&gt;&amp; messageQueue) : mReceiverObjGlobal(env-&gt;NewGlobalRef(receiverObj)), mMessageQueue(messageQueue), mWaitingForVsync(false) &#123; ALOGV(\"receiver %p ~ Initializing input event receiver.\", this);&#125; å¯ä»¥çœ‹åˆ°mReceiverObjGlobalæ˜¯åˆ›å»ºNativeDisplayEventReceiverå¯¹è±¡æ—¶ä¼ è¿›æ¥çš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œè¯¥å¯¹è±¡æ˜¯åœ¨nativeInitå‡½æ•°ä¸­åˆ›å»ºï¼š 1sp receiver = new NativeDisplayEventReceiver(env, receiverObj, messageQueue); è¿›ä¸€æ­¥çš„ï¼ŒreceiverObjæ˜¯è°ƒç”¨nativeInitå‡½æ•°æ—¶ä¼ è¿›æ¥çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆç¬¬ä¸€ä¸ªå‚æ•°envæ˜¯ç³»ç»Ÿç”¨äºè¿æ¥è™šæ‹Ÿæœºæ—¶è‡ªåŠ¨åŠ ä¸Šçš„ï¼‰ï¼ŒnativeInitå‡½æ•°åˆæ˜¯åœ¨Choreographerä¸­åˆ›å»ºFrameDisplayEventReceiverå¯¹è±¡æ—¶ï¼Œåœ¨åŸºç±»DisplayEventReceiveræ„é€ å™¨ä¸­è°ƒç”¨çš„ï¼Œå› æ­¤è¿™é‡Œçš„mReceiverObjGlobalå¯¹åº”çš„å°±æ˜¯Choreographerä¸­çš„FrameDisplayEventReceiveræˆå‘˜mDisplayEventReceiverã€‚ ï¼ˆ2ï¼‰gDisplayEventReceiverClassInfo.dispatchVsync åœ¨JNIä¸­æœ‰å¾ˆå¤šè¿™æ ·çš„ç±»ä¼¼çš„ç»“æ„ä½“å¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡éƒ½æ˜¯å…¨å±€ç»“æ„ä½“å¯¹è±¡ï¼Œè¿™é‡Œçš„gDisplayEventReceiverClassInfoå°±æ˜¯è¿™æ ·çš„ä¸€ä¸ªå¯¹è±¡ï¼Œé‡Œé¢æè¿°äº†ä¸€äº›åœ¨æ•´ä¸ªæ–‡ä»¶å†…å¯èƒ½ä¼šè°ƒç”¨åˆ°çš„javaå±‚çš„ç›¸å…³ç±»ä»¥åŠæˆå‘˜å‡½æ•°çš„ç›¸å…³ä¿¡æ¯ï¼Œçœ‹ä¸€ä¸‹gDisplayEventReceiverClassInfoï¼š 12345static struct &#123; jclass clazz; jmethodID dispatchVsync; jmethodID dispatchHotplug;&#125; gDisplayEventReceiverClassInfo; çœ‹ä¸€ä¸‹é‡Œé¢çš„å˜é‡åç§°å°±èƒ½çŸ¥é“å¤§è‡´çš„å«ä¹‰ï¼Œclazzæˆå‘˜ä»£è¡¨çš„æ˜¯æŸä¸ªjavaå±‚çš„ç±»çš„classä¿¡æ¯ï¼ŒdispatchVsyncå’ŒdispatchHotplugä»£è¡¨çš„æ˜¯javaå±‚ç±»çš„æ–¹æ³•çš„æ–¹æ³•ä¿¡æ¯ï¼Œçœ‹ä¸€ä¸‹è¯¥æ–‡ä»¶ä¸­æ³¨å†ŒJNIå‡½æ•°çš„æ–¹æ³•ï¼š 12345678int register_android_view_DisplayEventReceiver(JNIEnv* env) &#123; int res = RegisterMethodsOrDie(env, \"android/view/DisplayEventReceiver\", gMethods, NELEM(gMethods)); jclass clazz = FindClassOrDie(env, \"android/view/DisplayEventReceiver\"); gDisplayEventReceiverClassInfo.clazz = MakeGlobalRefOrDie(env, clazz); gDisplayEventReceiverClassInfo.dispatchVsync = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, \"dispatchVsync\", \"(JII)V\"); gDisplayEventReceiverClassInfo.dispatchHotplug = GetMethodIDOrDie(env, gDisplayEventReceiverClassInfo.clazz, \"dispatchHotplug\", \"(JIZ)V\"); return res;&#125; RegisterMethodsOrDieè°ƒç”¨æ³¨å†Œäº†javaå±‚è°ƒç”¨nativeæ–¹æ³•æ—¶é“¾æ¥åˆ°çš„å‡½æ•°çš„å…¥å£ï¼Œä¸‹é¢clazzå¯¹åº”çš„å°±æ˜¯javaå±‚çš„â€android/view/DisplayEventReceiver.javaâ€ç±»ï¼ŒgDisplayEventReceiverClassInfo.dispatchVsyncé‡Œé¢ä¿å­˜çš„å°±æ˜¯clazzç±»ä¿¡æ¯ä¸­ä¸dispatchVsyncæ–¹æ³•ç›¸å…³çš„ä¿¡æ¯ï¼ŒåŒæ ·dispatchHotplugä¹Ÿæ˜¯ã€‚ åˆ†æåˆ°è¿™é‡Œï¼Œå°±çŸ¥é“åº”ç”¨è¿›ç¨‹nativeæ¥æ”¶åˆ°åŒæ­¥ä¿¡å·äº‹ä»¶åï¼Œä¼šè°ƒç”¨Choreographerä¸­çš„FrameDisplayEventReceiveræˆå‘˜mDisplayEventReceiverçš„dispatchVsyncæ–¹æ³•ã€‚ 6.5.4ã€åº”ç”¨æ¥æ”¶Vsyncçœ‹ä¸€ä¸‹FrameDisplayEventReceiver.dispatchVsyncæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯DisplayEventReceiver.dispatchVsyncæ–¹æ³•(Choreographer.java)ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// Called from native code. @SuppressWarnings(&quot;unused&quot;) private void dispatchVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; onVsync(timestampNanos, builtInDisplayId, frame); &#125; æ³¨é‡Šè¡¨æ˜è¿™ä¸ªæ–¹æ³•æ˜¯ä»nativeä»£ç è°ƒç”¨çš„ï¼Œè¯¥å‡½æ•°ç„¶åä¼šè°ƒç”¨FrameDisplayEventReceiver.onVsyncæ–¹æ³•ï¼š @Override public void onVsync(long timestampNanos, int builtInDisplayId, int frame) &#123; // Ignore vsync from secondary display. // This can be problematic because the call to scheduleVsync() is a one-shot. // We need to ensure that we will still receive the vsync from the primary // display which is the one we really care about. Ideally we should schedule // vsync for a particular display. // At this time Surface Flinger won&apos;t send us vsyncs for secondary displays // but that could change in the future so let&apos;s log a message to help us remember // that we need to fix this. //æ³¨é‡Šï¼šå¿½ç•¥æ¥è‡ªéä¸»æ˜¾ç¤ºå™¨çš„Vsyncä¿¡å·ï¼Œä½†æ˜¯æˆ‘ä»¬å‰é¢è°ƒç”¨çš„scheduleVsyncå‡½æ•°åªèƒ½è¯·æ±‚åˆ°ä¸€æ¬¡Vsyncä¿¡å·ï¼Œå› æ­¤éœ€è¦é‡æ–°è°ƒç”¨scheduleVsyncå‡½æ•° //è¯·æ±‚æ¥è‡ªä¸»æ˜¾ç¤ºè®¾å¤‡çš„Vsyncä¿¡å· if (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123; Log.d(TAG, &quot;Received vsync from secondary display, but we don&apos;t support &quot; + &quot;this case yet. Choreographer needs a way to explicitly request &quot; + &quot;vsync for a specific display to ensure it doesn&apos;t lose track &quot; + &quot;of its scheduled vsync.&quot;); scheduleVsync(); return; &#125; // Post the vsync event to the Handler. // The idea is to prevent incoming vsync events from completely starving // the message queue. If there are no messages in the queue with timestamps // earlier than the frame time, then the vsync event will be processed immediately. // Otherwise, messages that predate the vsync event will be handled first. long now = System.nanoTime(); if (timestampNanos &gt; now) &#123; Log.w(TAG, &quot;Frame time is &quot; + ((timestampNanos - now) * 0.000001f) + &quot; ms in the future! Check that graphics HAL is generating vsync &quot; + &quot;timestamps using the correct timebase.&quot;); timestampNanos = now; &#125; if (mHavePendingVsync) &#123; Log.w(TAG, &quot;Already have a pending vsync event. There should only be &quot; + &quot;one at a time.&quot;); &#125; else &#123; mHavePendingVsync = true; &#125; mTimestampNanos = timestampNanos; //åŒæ­¥ä¿¡å·æ—¶é—´æˆ³ mFrame = frame; //åŒæ­¥ä¿¡å·çš„ä¸ªæ•°ï¼Œç†è§£å°±æ˜¯ä»è°ƒç”¨scheduleVsyncåˆ°onVsyncæ¥æ”¶åˆ°ä¿¡å·ä¹‹é—´ç»å†çš„åŒæ­¥ä¿¡å·çš„ä¸ªæ•°ï¼Œä¸€èˆ¬éƒ½æ˜¯1 Message msg = Message.obtain(mHandler, this); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS); &#125; è²Œä¼¼è¿™é‡Œçš„å¤„ç†åªæ˜¯å¾€Choreographerå¯¹è±¡ä¸­çš„mHandlerå¯¹åº”çš„çº¿ç¨‹Looperä¸­å‘é€ä¸€ä¸ªæ¶ˆæ¯ï¼Œæ¶ˆæ¯çš„å†…å®¹æœ‰ä¸¤ä¸ªç‰¹ç‚¹ï¼š ï¼ˆ1ï¼‰å°†thisï¼Œä¹Ÿå°±æ˜¯å½“å‰çš„FrameDisplayEventReceiverå¯¹è±¡ä½œä¸ºå‚æ•°ï¼Œåé¢ä¼šå›è°ƒåˆ°FrameDisplayEventReceiver.runæ–¹æ³•ï¼› ï¼ˆ2ï¼‰ä¸ºMessageè®¾ç½®FLAG_ASYNCHRONOUSå±æ€§ï¼› å‘é€è¿™ä¸ªFLAG_ASYNCHRONOUSæ¶ˆæ¯åï¼Œåé¢ä¼šå›è°ƒåˆ°FrameDisplayEventReceiver.runæ–¹æ³•ï¼Œè‡³äºä¸ºä»€ä¹ˆï¼Œåé¢å†å†™æ–‡ç« ç»“åˆView.invalidateæ–¹æ³•çš„è¿‡ç¨‹åˆ†æï¼Œçœ‹ä¸€ä¸‹FrameDisplayEventReceiver.runæ–¹æ³•ï¼š 12345@Overridepublic void run() &#123; mHavePendingVsync = false; doFrame(mTimestampNanos, mFrame);&#125; è°ƒç”¨Choreographer.doFrameæ–¹æ³•ï¼Œå¦‚æœæ˜¯é‡ç»˜äº‹ä»¶doFrameæ–¹æ³•ä¼šæœ€ç»ˆè°ƒç”¨åˆ°ViewRootImpl.performTraversalsæ–¹æ³•è¿›å…¥å®é™…çš„ç»˜åˆ¶æµç¨‹ã€‚ç»è¿‡ä¸Šé¢çš„åˆ†æå¯ä»¥çŸ¥é“ï¼Œè°ƒç”¨ä¸€æ¬¡Choreographer.scheduleVsyncLockedåªä¼šè¯·æ±‚ä¸€æ¬¡åŒæ­¥ä¿¡å·ï¼Œä¹Ÿå°±æ˜¯å›è°ƒä¸€æ¬¡FrameDisplayEventReceiver.onVsyncæ–¹æ³•ï¼Œåœ¨æ€è€ƒä¸€ä¸ªé—®é¢˜ï¼Œä¸€ä¸ªåº”ç”¨è¿›ç¨‹éœ€è¦å¤šæ¬¡è¯·æ±‚VsyncåŒæ­¥ä¿¡å·ä¼šä¸ä¼šä½¿ç”¨åŒæ ·çš„ä¸€ä¸²å¯¹è±¡ï¼Ÿå¤šä¸ªçº¿ç¨‹åˆæ˜¯æ€ä¹ˆæ ·çš„ï¼Ÿ ç­”ï¼šä¸€èˆ¬ç»˜åˆ¶æ“ä½œåªèƒ½åœ¨ä¸»çº¿ç¨‹é‡Œé¢è¿›è¡Œï¼Œå› æ­¤ä¸€èˆ¬æ¥è¯´åªä¼šåœ¨ä¸»çº¿ç¨‹é‡Œé¢å»è¯·æ±‚åŒæ­¥ä¿¡å·ï¼Œå¯ä»¥è®¤ä¸ºä¸ä¼šå­˜åœ¨åŒä¸€ä¸ªåº”ç”¨çš„å¤šä¸ªçº¿ç¨‹è¯·æ±‚SFçš„Vsyncä¿¡å·ï¼ŒChoreographeræ˜¯ä¸€ä¸ªçº¿ç¨‹å†…çš„å•ä¾‹æ¨¡å¼ï¼Œå­˜å‚¨åœ¨äº† ThreadLocal sThreadInstanceå¯¹è±¡é‡Œé¢ï¼Œæ‰€ä»¥ä¸»çº¿ç¨‹å¤šæ¬¡è¯·æ±‚ä½¿ç”¨çš„æ˜¯åŒä¸€ä¸ªChoreographerå¯¹è±¡ï¼Œæ‰€ä»¥åé¢çš„ä¸€ä¸²å¯¹è±¡åº”è¯¥éƒ½æ˜¯å¯ä»¥å¤ç”¨çš„ã€‚ æ€»ä½“æ¶æ„ï¼š ä¼æœ¨ç´¯:::ç»ˆäºå®Œäº†ï¼Œç”±äºAndroid Graphicsç³»ç»Ÿæ¶‰åŠæ¨¡å—ä»£ç çºµæ¨ªäº¤å‰å¤æ‚ï¼Œå…¶ä¸­ä»£ç å›¾ç¤ºæœ‰è¯¯çš„åœ°æ–¹è¯·è§è°…ï¼Œä¹Ÿæ²¡æœ‰ç²¾åŠ›ä¸€ä¸€æ ¸å¯¹äº†ï¼Œè¿˜è¯·æµ·æ¶µ~~~ä¸»è¦æ˜¯åˆ†æAndroid Graphicsæ€»ä½“çš„ä¸€ä¸ªæµç¨‹æ€æƒ³ï¼Œæœ‰éœ€è¦å†ä¸€ç‚¹ç‚¹æ·±æŒ–ã€‚ ï¼ˆä¸ƒï¼‰ã€å‚è€ƒæ–‡æ¡£(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šAndroid Vsync åŸç†æ—å­¦æ£®çš„Androidä¸“æ Android Graphicsäº†è§£ Systraceå›¾è§£Android - Android GUI ç³»ç»ŸAndroid SurfaceFlinger å­¦ä¹ ä¹‹è·¯&amp;Androidå¤šåª’ä½“å¼€å‘Android7.0 åŸºç¡€ä¸šåŠ¡AMSã€æ•°æ®ä¸šåŠ¡ã€ç”µæºç®¡ç†ä¸šåŠ¡ æºç åˆ†æã€Android æ˜¾ç¤ºæ¨¡å—ã€‘ - æ·±å…¥å‰–æAndroidç³»ç»Ÿ - CSDNåšå®¢æ·±å…¥ç†è§£Androidå·ä¸€å…¨æ–‡-ç¬¬å…«ç« (æ·±å…¥ç†è§£Surfaceç³»ç»Ÿ)androidç³»ç»Ÿ - armwindçš„ä¸“æ  - CSDNåšå®¢androidæ˜¾ç¤ºç³»ç»Ÿ - kc58236582çš„åšå®¢ - CSDNåšå®¢SurfaceView, TextureView, SurfaceTextureç­‰çš„åŒºåˆ«ã€Demoã€‘Android graphics å­¦ä¹ ï¼ç”Ÿäº§è€…ã€æ¶ˆè´¹è€…ã€BufferQueueä»‹ç»æ·±å…¥Android Graphics Pipelineï¼šä»æŒ‰é’®åˆ°å¸§ç¼“å†²ï¼ˆç¬¬ä¸€éƒ¨åˆ†ï¼‰æ·±å…¥Android Graphics Pipelineï¼šä»æŒ‰é’®åˆ°å¸§ç¼“å†²ï¼ˆç¬¬äºŒéƒ¨åˆ†ï¼‰çª—å£ï¼šProfiling è§†å›¾ï¼ˆOpenGL/OpenGL ES* å·¥ä½œè´Ÿè½½ï¼‰Android Nä¸­UIç¡¬ä»¶æ¸²æŸ“ï¼ˆhwuiï¼‰çš„HWUI_NEW_OPS(åŸºäºAndroid 7.1)Androidâ€™s Graphics Buffer Management System (Part I: gralloc)Androidâ€™s Graphics Buffer Management System (Part II: BufferQueue)Android GDIä¹‹SurfaceFlingerAndroid SurfaceFlinger å­¦ä¹ ä¹‹è·¯(äº”)â€”-VSync å·¥ä½œåŸç†Android 5.1 SurfaceFlinger VSYNCè¯¦è§£Android 5.1 SurfaceFlinger VSYNCè¯¦è§£Androidæ¶ˆæ¯æœºåˆ¶Looperä¸VSyncçš„ä¼ æ’­Androidå‚ç›´åŒæ­¥ä¿¡å·VSyncçš„äº§ç”ŸåŠä¼ æ’­ç»“æ„è¯¦è§£Android 4.4(KitKat)ä¸­VSyncä¿¡å·çš„è™šæ‹ŸåŒ–Android 4.4(KitKat)çª—å£ç®¡ç†å­ç³»ç»Ÿ - ä½“ç³»æ¡†æ¶Androidä¸­ç”¨OpenGL ES Traceråˆ†æç»˜åˆ¶è¿‡ç¨‹android viewçš„ç»˜åˆ¶ä¸­ï¼ŒViewç»˜åˆ¶çš„æ—¶é—´å¦‚ä½•å’Œvsyncå±å¹•åˆ·æ–°é¢‘ç‡ä¿æŒåŒæ­¥çš„ï¼Ÿã€æ·±å…¥ç†è§£Androidå·ä¸€å…¨æ–‡-ç¬¬å…«ç« ã€‘å…¥ç†è§£Surfaceç³»ç»ŸAndroid çª—å£ç®¡ç†ï¼šZ-Orderç®¡ç†","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android Binder ç³»ç»Ÿ åˆ†æ","slug":"Android-7-1-2-Android-N-Android-Binderç³»ç»Ÿåˆ†æ","date":"2017-12-31T16:00:00.000Z","updated":"2018-04-19T14:29:56.436Z","comments":true,"path":"2018/01/01/Android-7-1-2-Android-N-Android-Binderç³»ç»Ÿåˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binderç³»ç»Ÿåˆ†æ/","excerpt":"Android Binderç³»ç»Ÿæ¦‚è¿°ï¼š Binderæ˜¯Androidç³»ç»Ÿä¸­å¤§é‡ä½¿ç”¨çš„IPCï¼ˆInter-process communicationï¼Œè¿›ç¨‹é—´é€šè®¯ï¼‰æœºåˆ¶ã€‚æ— è®ºæ˜¯åº”ç”¨ç¨‹åºå¯¹ç³»ç»ŸæœåŠ¡çš„è¯·æ±‚ï¼Œè¿˜æ˜¯åº”ç”¨ç¨‹åºè‡ªèº«æä¾›å¯¹å¤–æœåŠ¡ï¼Œéƒ½éœ€è¦ä½¿ç”¨åˆ°Binderã€‚å› æ­¤ï¼ŒBinderæœºåˆ¶åœ¨Androidç³»ç»Ÿä¸­çš„åœ°ä½éå¸¸é‡è¦ï¼Œå¯ä»¥è¯´ï¼Œç†è§£Binderæ˜¯ç†è§£Androidç³»ç»Ÿçš„ç»å¯¹å¿…è¦å‰æã€‚","text":"Android Binderç³»ç»Ÿæ¦‚è¿°ï¼š Binderæ˜¯Androidç³»ç»Ÿä¸­å¤§é‡ä½¿ç”¨çš„IPCï¼ˆInter-process communicationï¼Œè¿›ç¨‹é—´é€šè®¯ï¼‰æœºåˆ¶ã€‚æ— è®ºæ˜¯åº”ç”¨ç¨‹åºå¯¹ç³»ç»ŸæœåŠ¡çš„è¯·æ±‚ï¼Œè¿˜æ˜¯åº”ç”¨ç¨‹åºè‡ªèº«æä¾›å¯¹å¤–æœåŠ¡ï¼Œéƒ½éœ€è¦ä½¿ç”¨åˆ°Binderã€‚å› æ­¤ï¼ŒBinderæœºåˆ¶åœ¨Androidç³»ç»Ÿä¸­çš„åœ°ä½éå¸¸é‡è¦ï¼Œå¯ä»¥è¯´ï¼Œç†è§£Binderæ˜¯ç†è§£Androidç³»ç»Ÿçš„ç»å¯¹å¿…è¦å‰æã€‚ framework/base/core/java/ (Java) framework/base/core/jni/ (JNI) framework/native/libs/binder (Native) framework/native/cmds/servicemanager/ (Native) kernel/drivers/staging/android (Driver) Java framework framework/base/core/java/android/os/â— IInterface.javaâ— IBinder.javaâ— Parcel.javaâ— IServiceManager.javaâ— ServiceManager.javaâ— ServiceManagerNative.javaâ— Binder.java framework/base/core/jni/â— android_os_Parcel.cppâ— AndroidRuntime.cppâ— android_util_Binder.cpp (æ ¸å¿ƒç±») Native framework framework/native/libs/binderâ— IServiceManager.cppâ— BpBinder.cppâ— Binder.cppâ— IPCThreadState.cpp (æ ¸å¿ƒç±»)â— ProcessState.cpp (æ ¸å¿ƒç±») framework/native/include/binder/â— IServiceManager.hâ— IInterface.h framework/native/cmds/servicemanager/â— bctest.câ— binder.hâ— binder.câ— service_manager.câ— servicemanager.rc Kernel kernel/drivers/staging/android/ â— binder.câ— binder.h åšå®¢åŸå›¾é“¾æ¥ä¸€ã€Android Binderç³»ç»ŸCç¨‹åºç¤ºä¾‹ï¼ˆ1ï¼‰ã€ç®€è¿°Binderè·¨è¿›ç¨‹æœºåˆ¶Androidç³»ç»Ÿä¸­ï¼Œæ¯ä¸ªåº”ç”¨ç¨‹åºæ˜¯ç”±Androidçš„Activityï¼ŒServiceï¼ŒBroadcastï¼ŒContentProviderè¿™å››ç»„ä»¶çš„ä¸­ä¸€ä¸ªæˆ–å¤šä¸ªç»„åˆè€Œæˆï¼Œè¿™å››ç»„ä»¶æ‰€æ¶‰åŠçš„å¤šè¿›ç¨‹é—´çš„é€šä¿¡åº•å±‚éƒ½æ˜¯ä¾èµ–äºBinder IPCæœºåˆ¶ã€‚ ä»è¿›ç¨‹è§’åº¦æ¥çœ‹IPCæœºåˆ¶ ç°åœ¨Clientè¿›ç¨‹éœ€è¦è®¿é—®Serverè¿›ç¨‹ä¸­çš„æœåŠ¡ï¼Œä¼šç»è¿‡ä»¥ä¸‹æ­¥éª¤ï¼š1ã€Serverè¿›ç¨‹é¦–å…ˆå‘ServiceManageræ³¨å†ŒæœåŠ¡ï¼ˆServiceManagerå…ˆäºServerå¯åŠ¨ï¼‰2ã€Clientè¿›ç¨‹å‘ServiceManageræŸ¥è¯¢æœåŠ¡å¾—åˆ°ä¸€ä¸ªå¥æŸ„Handleï¼ˆServerè¿›ç¨‹å¯èƒ½ä¸æ­¢ä¸€ä¸ªæœåŠ¡ï¼Œç”¨HandleåŒºåˆ†æ˜¯å“ªä¸€ä¸ªæœåŠ¡ï¼‰3ã€Clientè¿›ç¨‹ å°è£…æ•°æ®Bufferé€šè¿‡Binderé©±åŠ¨å‘é€ç»™Serverè¿›ç¨‹ï¼ŒServerè¿›ç¨‹å–å¾—æ•°æ®åè§£ææ•°æ®ï¼Œä½¿ç”¨Serverè¿›ç¨‹çš„HandleæœåŠ¡å¯¹åº”çš„å‡½æ•°å¤„ç†æ•°æ®ï¼Œå¤„ç†å®Œæˆåé€šè¿‡Binderé©±åŠ¨ä¼ è¾“ç»™Clientè¿›ç¨‹ 1.1ã€Serverè¿›ç¨‹å‘ServiceManageræ³¨å†ŒæœåŠ¡ServiceManageræ˜¯ä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹ã€‚å®ƒçš„main()å‡½æ•°æºç å¦‚ä¸‹ï¼š ServiceManageræ˜¯å¦‚ä½•å¯åŠ¨çš„ï¼Ÿ è¿™é‡Œç®€è¦ä»‹ç»ä¸€ä¸‹ServiceManagerçš„å¯åŠ¨æ–¹å¼ã€‚å½“Kernelå¯åŠ¨åŠ è½½å®Œé©±åŠ¨ä¹‹åï¼Œä¼šå¯åŠ¨Androidçš„initè¿›ç¨‹ï¼Œinitè¿›ç¨‹ä¼šè§£æservicemanager.rcï¼Œè¿›è€Œå¯åŠ¨servicemanager.rcä¸­å®šä¹‰çš„å®ˆæŠ¤è¿›ç¨‹ã€‚ 1234567891011121314151617[-&gt;ServiceManager.c]int main(int argc, char **argv)&#123; struct binder_state *bs; void *svcmgr = BINDER_SERVICE_MANAGER; bs = binder_open(128*1024); if (binder_become_context_manager(bs)) &#123; ... &#125; svcmgr_handle = svcmgr; binder_loop(bs, svcmgr_handler); return 0;&#125; 123456789101112131415161718192021222324252627282930void binder_loop(struct binder_state *bs, binder_handler func)&#123; int res; struct binder_write_read bwr; unsigned readbuf[32]; bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; // å‘Šè¯‰Kernelï¼ŒServiceManagerè¿›ç¨‹è¿›å…¥äº†æ¶ˆæ¯å¾ªç¯çŠ¶æ€ã€‚ readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; // å‘Kernelä¸­å‘é€æ¶ˆæ¯(å…ˆå†™åè¯»)ã€‚ // å…ˆå°†æ¶ˆæ¯ä¼ é€’ç»™Kernelï¼Œç„¶åå†ä»Kernelè¯»å–æ¶ˆæ¯åé¦ˆ res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... // è§£æè¯»å–çš„æ¶ˆæ¯åé¦ˆ res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... &#125;&#125; binder_loop()ä¸»è¦å·¥ä½œï¼š (1)ã€é€šè¿‡ioctl(,BINDER_WRITE_READ,)è¿›å…¥æ¶ˆæ¯å¾ªç¯ï¼Œä¼‘çœ ç­‰å¾…Clientè¯·æ±‚ (2)ã€å½“Clienté€šè¿‡é©±åŠ¨è¯·æ±‚æœåŠ¡æ—¶ï¼Œbinderé©±åŠ¨ä¼šå”¤é†’ServiceManagerï¼Œé€šè¿‡binder_parse()è§£æå¤„ç†æ•°æ®ï¼Œå›å¤ä¿¡æ¯ ä»£ç è°ƒç”¨å…³ç³»å›¾ï¼š æ—¶åºæµç¨‹å›¾ï¼š main()ä¸»è¦è¿›è¡Œäº†ä¸‰é¡¹å·¥ä½œï¼š (1) ã€é€šè¿‡binder_open()æ‰“å¼€â€/dev/binderâ€æ–‡ä»¶ï¼Œå³æ‰“å¼€Binderè®¾å¤‡æ–‡ä»¶ã€‚ (2) ã€è°ƒç”¨binder_become_context_manager()ï¼Œé€šè¿‡ioctl()å‘Šè¯‰Binderé©±åŠ¨ç¨‹åºè‡ªå·±æ˜¯Binderä¸Šä¸‹æ–‡ç®¡ç†è€…ã€‚ (3) ã€è°ƒç”¨binder_loop()è¿›å…¥æ¶ˆæ¯å¾ªç¯ï¼Œç­‰å¾…Clientçš„è¯·æ±‚ã€‚å¦‚æœæ²¡æœ‰Clientè¯·æ±‚ï¼Œåˆ™è¿›å…¥ç¡çœ ç­‰å¾…çŠ¶æ€ï¼›å½“æœ‰Clientè¯·æ±‚æ—¶ï¼Œå°±è¢«å”¤é†’ï¼Œç„¶åè¯»å–å¹¶å¤„ç†Clientè¯·æ±‚ã€‚ 1.2ã€åˆ†æAndroid binderåŸç”Ÿç¤ºä¾‹ç¨‹åºbctest.cï¼š12345678910111213141516int main(int argc, char **argv)&#123; struct binder_state *bs; uint32_t svcmgr = BINDER_SERVICE_MANAGER; uint32_t handle; bs = binder_open(128*1024); ... while (argc &gt; 0) &#123; //svcmgr_lookupæ–¹æ³•è°ƒç”¨binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE) handle = svcmgr_lookup(bs, svcmgr, \"alt_svc_mgr\"); //svcmgr_publishæ–¹æ³•è°ƒç”¨binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_CHECK_SERVICE) svcmgr_publish(bs, svcmgr, argv[1], &amp;token); &#125; return 0;&#125; 1.3ã€ç¤ºä¾‹ç¨‹åºï¼ˆbctest.cï¼‰æ³¨å†ŒæœåŠ¡ã€è·å–æœåŠ¡è¿‡ç¨‹æ³¨å†ŒæœåŠ¡çš„è¿‡ç¨‹ï¼ˆbctest.cï¼‰: (1) ã€bs = binder_open(128*1024) (2) ã€binder_call(bs, &amp;msg, &amp;reply, 0, SVC_MGR_ADD_SERVICE) å‚æ•°è¯´æ˜ï¼š // msgå«æœ‰æœåŠ¡çš„åå­— // replyå®ƒä¼šå«æœ‰servicemanagerå›å¤çš„æ•°æ® // targetä¸º0è¡¨ç¤ºservicemanager // code: è¡¨ç¤ºè¦è°ƒç”¨servicemanagerä¸­çš„â€addserviceå‡½æ•°â€ è·å–æœåŠ¡çš„è¿‡ç¨‹ï¼ˆbctest.cï¼‰: (1) ã€bs = binder_open(128*1024) (2) ã€binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_CHECK_SERVICE) å‚æ•°è¯´æ˜ï¼š // msgå«æœ‰æœåŠ¡çš„åå­— // replyå®ƒä¼šå«æœ‰servicemanagerå›å¤çš„æ•°æ®, è¡¨ç¤ºæä¾›æœåŠ¡çš„è¿›ç¨‹ // targetä¸º0è¡¨ç¤ºservicemanager // code: è¡¨ç¤ºè¦è°ƒç”¨servicemanagerä¸­çš„â€getserviceå‡½æ•°â€ binder_callè¿œç¨‹å®ç°ï¼š æ ¹æ®msgã€targetã€codeå°±çŸ¥é“éœ€è¦è°ƒç”¨å“ªä¸ªæœåŠ¡çš„å“ªä¸€ä¸ªå‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334353637int binder_call(struct binder_state *bs, struct binder_io *msg, struct binder_io *reply, uint32_t target, uint32_t code)&#123; int res; struct binder_write_read bwr; struct &#123; uint32_t cmd; struct binder_transaction_data txn; &#125; __attribute__((packed)) writebuf; unsigned readbuf[32]; writebuf.cmd = BC_TRANSACTION; writebuf.txn.target.handle = target; writebuf.txn.code = code; writebuf.txn.flags = 0; writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0; writebuf.txn.offsets_size = ((char*) msg-&gt;offs) - ((char*) msg-&gt;offs0); writebuf.txn.data.ptr.buffer = (uintptr_t)msg-&gt;data0; writebuf.txn.data.ptr.offsets = (uintptr_t)msg-&gt;offs0; bwr.write_size = sizeof(writebuf); bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) &amp;writebuf; hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (uintptr_t) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); res = binder_parse(bs, reply, (uintptr_t) readbuf, bwr.read_consumed, 0); &#125;&#125; æ³¨ï¼š ç»“æ„ä½“ç®€ä»‹ binder_io å°è£…ä¸€æ¬¡å‘é€çš„æ•°æ® binder_write_read å­˜å‚¨ä¸€æ¬¡è¯»å†™æ“ä½œçš„æ•°æ® binder_transaction_data å­˜å‚¨ä¸€æ¬¡äº‹åŠ¡çš„æ•°æ® ï¼ˆ1ï¼‰æ„é€ å‚æ•°ï¼Œä½¿ç”¨binder_io æè¿°ï¼ˆ2ï¼‰æ•°æ®è½¬æ¢binder_io -&gt; binder_write_readï¼›é¦–å…ˆæ ¹æ®binder_io ã€targetã€codeä¸‰è€…æ„é€ binder_transaction_dataï¼Œç„¶åå°†binder_write_read.write_bufferæŒ‡å‘binder_transaction_dataï¼ˆ3ï¼‰è°ƒç”¨ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);å‘é€æ•°æ® ï¼ˆ2ï¼‰ã€Android Binderç³»ç»Ÿ_ServiceManageræˆ‘ä»¬å…ˆè·³è¿‡ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr)æ‰€æ¶‰åŠçš„å†…æ ¸çŸ¥è¯†å’Œæµç¨‹ï¼Œç¨åå†Android Binderç³»ç»Ÿ-Driverå±‚è¯¦ç»†ä»‹ç»ã€‚ 2.1ã€ServiceManagerä¸­serviceå¥æŸ„å¦‚ä½•ç®¡ç†å‰é¢åˆ†æè¿‡ï¼ŒServiceManagerå¼€æœºåˆå§‹ä¼šå¯åŠ¨æˆä¸ºä¸€ä¸ªå®ˆæŠ¤è¿›ç¨‹ï¼Œ ServiceManageræ˜¯å¦‚ä½•ç®¡ç†serviceå¥æŸ„çš„ï¼Ÿ è¿›ç¨‹é‡Œæœ‰ä¸€ä¸ªå…¨å±€æ€§çš„svclistå˜é‡ï¼š 1struct svcinfo *svclist = 0; å®ƒè®°å½•ç€æ‰€æœ‰æ·»åŠ è¿›ç³»ç»Ÿçš„â€Serviceâ€ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯è¢«ç»„ç»‡æˆä¸€æ¡å•å‘é“¾è¡¨ï¼Œæˆ‘ä»¬ä¸å¦¨ç§°è¿™æ¡é“¾è¡¨ä¸ºâ€Serviceå‘é‡è¡¨â€ã€‚ç¤ºæ„å›¾å¦‚ä¸‹ï¼š é“¾è¡¨èŠ‚ç‚¹ç±»å‹ä¸ºsvcinfo æ·»åŠ æœåŠ¡ç®€å•ç†è§£å°±æ˜¯ æ–°å»ºsvcinfoèŠ‚ç‚¹æ’å…¥åˆ°å•é“¾è¡¨ä¸­ï¼ŒæŸ¥è¯¢æœåŠ¡å°±æ˜¯çœ‹å•é“¾è¡¨æ˜¯å¦æœ‰æ­¤æœåŠ¡ã€‚ 2.2ã€è§£æBinderä¸Šä¼ æ•°æ®-(binder_parseå‡½æ•°)å›åˆ°ServiceManagerçš„main()å‡½æ•°ã€‚binder_loop()ä¼šå…ˆå‘binderé©±åŠ¨å‘å‡ºäº†BC_ENTER_LOOPERå‘½ä»¤ï¼Œæ¥ç€è¿›å…¥ä¸€ä¸ªforå¾ªç¯ä¸æ–­è°ƒç”¨ioctl()è¯»å–å‘æ¥çš„æ•°æ®ï¼Œæ¥ç€è§£æè¿™äº›æ•°æ®ã€‚å‡è®¾ç°åœ¨Clientæœ‰è¯·æ±‚ï¼ŒBinderé©±åŠ¨å°±é€šè¿‡ä¼šä¸Šä¼ æ•°æ®ã€‚è¯»å–æ•°æ®åä¼šäº¤ç”±binder_parse()è§£æã€‚ 1binder_loop(bs, svcmgr_handler); æ³¨æ„binder_loop()çš„å‚æ•°svcmgr_handler()å‡½æ•°æŒ‡é’ˆã€‚è€Œä¸”è¿™ä¸ªå‚æ•°ä¼šè¿›ä¸€æ­¥ä¼ é€’ç»™binder_parse()ã€‚binder_parse()è´Ÿè´£è§£æä»binderé©±åŠ¨è¯»æ¥çš„æ•°æ®ï¼Œå…¶ä»£ç æˆªé€‰å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738int binder_parse(struct binder_state *bs, struct binder_io *bio, uintptr_t ptr, size_t size, binder_handler func)&#123; int r = 1; uintptr_t end = ptr + (uintptr_t) size; while (ptr &lt; end) &#123; uint32_t cmd = *(uint32_t *) ptr; ptr += sizeof(uint32_t); switch(cmd) &#123; ... //é©±åŠ¨æœ‰æ•°æ®åä¼šè¿”å›æ¬¡cmd case BR_TRANSACTION: &#123; struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr; binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); res = func(bs, txn, &amp;msg, &amp;reply); if (txn-&gt;flags &amp; TF_ONE_WAY) &#123; binder_free_buffer(bs, txn-&gt;data.ptr.buffer); &#125; else &#123; binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; ... &#125; ptr += sizeof(*txn); break; &#125; ... &#125; return r;&#125; ä»å‰æ–‡çš„ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œbinder_loop()å£°æ˜äº†ä¸€ä¸ª128èŠ‚çš„bufferï¼ˆå³uint32_t readbuf[32]ï¼‰ï¼Œæ¯æ¬¡ç”¨BINDER_WRITE_READå‘½ä»¤ä»é©±åŠ¨è¯»å–ä¸€äº›å†…å®¹ï¼Œå¹¶ä¼ å…¥binder_parse()ã€‚ binder_parse()åœ¨åˆé€‚çš„æ—¶æœºï¼Œä¼šå›è°ƒå…¶funcå‚æ•°ï¼ˆbinder_handler funcï¼‰æŒ‡ä»£çš„å›è°ƒå‡½æ•°ï¼Œå³å‰æ–‡è¯´åˆ°çš„svcmgr_handler()å‡½æ•°ã€‚ binder_loop()å°±è¿™æ ·ä¸€ç›´å¾ªç¯ä¸‹å»ï¼Œå®Œæˆäº†æ•´ä¸ªServiceManagerçš„å·¥ä½œã€‚ 2.3ã€æ•°æ®è½¬æ¢binder_transaction_data-&gt;binder_ioåˆå§‹åŒ–replyï¼›æ ¹æ®txt(Binderé©±åŠ¨åé¦ˆçš„ä¿¡æ¯)åˆå§‹åŒ–msg 12bio_init(&amp;reply, rdata, sizeof(rdata), 4);bio_init_from_txn(&amp;msg, txn); 2.4ã€å¦‚ä½•æ·»åŠ æœåŠ¡SVC_MGR_ADD_SERVICEå‰é¢è®²è¿‡ binder_parse()åœ¨åˆé€‚çš„æ—¶æœºï¼Œä¼šå›è°ƒå…¶funcå‚æ•°ï¼ˆbinder_handler funcï¼‰æŒ‡ä»£çš„å›è°ƒå‡½æ•°ï¼Œå³å‰æ–‡è¯´åˆ°çš„svcmgr_handler()å‡½æ•°ã€‚å¹¶ä¸”ä¼šæ ¹æ®binder_transaction_dataçš„codeåˆ¤æ–­å…·ä½“è°ƒç”¨å“ªä¸€ä¸ªå‡½æ•°ã€‚ 12345678910111213141516171819202122232425262728293031323334int svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn, struct binder_io *msg, struct binder_io *reply)&#123; struct svcinfo *si; uint16_t *s; size_t len; uint32_t handle; uint32_t strict_policy; int allow_isolated; ...... switch(txn-&gt;code) &#123; case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;len); handle = do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid); bio_put_ref(reply, handle); return 0; case SVC_MGR_ADD_SERVICE: s = bio_get_string16(msg, &amp;len); handle = bio_get_ref(msg); allow_isolated = bio_get_uint32(msg) ? 1 : 0; if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, txn-&gt;sender_pid)) return -1; break;... &#125; bio_put_uint32(reply, 0); return 0;&#125; ç”±ä»£ç å¯çŸ¥code = SVC_MGR_ADD_SERVICE ä¼šè°ƒç”¨do_add_service()å‡½æ•° 123456789101112131415161718192021222324252627int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle, uid_t uid, int allow_isolated, pid_t spid)&#123; struct svcinfo *si; ... si = find_svc(s, len); if (si) &#123; ... &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); ... si-&gt;handle = handle; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\\0'; si-&gt;death.func = (void*) svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, handle); binder_link_to_death(bs, handle, &amp;si-&gt;death); return 0;&#125; å¯è§æ·»åŠ Serviceåªæ˜¯æ–°å»ºäº†ä¸€ä¸ªsvcinfoç„¶åæ’å…¥åˆ°å‰é¢æ‰€è¯´çš„â€Serviceå‘é‡è¡¨â€ä¸­ã€‚ 2.5ã€å¦‚ä½•è·å–æœåŠ¡SVC_MGR_CHECK_SERVICE123456uint32_t do_find_service(const uint16_t *s, size_t len, uid_t uid, pid_t spid)&#123; struct svcinfo *si = find_svc(s, len); ... return si-&gt;handle;&#125; è·å–æœåŠ¡ä¼šæŸ¥è¯¢â€Serviceå‘é‡è¡¨â€æ˜¯å¦æœ‰æ­¤æœåŠ¡ï¼Œç„¶åè¿”å›Serviceçš„å¥æŸ„handleã€‚ 2.6ã€ServiceManagerå›å¤æ•°æ®å‰é¢åˆ†æå›è°ƒsvcmgr_handler()å‡½æ•°å¤„ç†æ•°æ®åï¼Œä¼šè°ƒç”¨binder_send_reply()å‡½æ•° å›å¤æ¶ˆæ¯ç»™é©±åŠ¨ã€‚ 1binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res) 2.7ã€æ€»ç»“ï¼šç¤ºä¾‹ç¨‹åºï¼ˆbctest.cï¼‰æ³¨å†Œã€è·å–æœåŠ¡ä¸€èˆ¬åˆ†ä»¥ä¸‹æ­¥éª¤ï¼š ï¼ˆ1ï¼‰æºè¿›ç¨‹é€šè¿‡binder_open()æ‰“å¼€â€/dev/binderâ€æ–‡ä»¶ï¼Œå³æ‰“å¼€Binderè®¾å¤‡æ–‡ä»¶ã€‚ ï¼ˆ2ï¼‰æºè¿›ç¨‹æ„é€ æ•°æ®ï¼š[a].æ„é€ binder_io [b].è½¬ä¸ºbinder_transaction_data [c].æ”¾å…¥binder_write_read ï¼ˆ3ï¼‰æºè¿›ç¨‹è°ƒç”¨ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);å‘é€æ•°æ®ç»™é©±åŠ¨ ï¼ˆ4ï¼‰é©±åŠ¨ä¸ŠæŠ¥æ•°æ®åˆ°ç›®çš„è¿›ç¨‹ServiceManager ï¼ˆ5ï¼‰ç›®çš„è¿›ç¨‹ServiceManagerå¤„ç†å®Œæ•°æ®ï¼Œé‡æ–°æ„é€ æ•°æ®ï¼Œé€šè¿‡è°ƒç”¨ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);å‘é€æ•°æ®ç»™é©±åŠ¨ ï¼ˆ6ï¼‰é©±åŠ¨ç„¶åå°†æ•°æ®åé¦ˆåˆ°æºè¿›ç¨‹ ï¼ˆ3ï¼‰ã€Android Binderç³»ç»ŸCç¨‹åº3.1ã€Android Binderç³»ç»ŸCç¨‹åº_æ¡†æ¶æ€»ç»“bctest.cæ³¨å†ŒæœåŠ¡è·å–æœåŠ¡çš„ä¸€èˆ¬æµç¨‹æ¡†æ¶ï¼š 3.2ã€Android Binderç³»ç»ŸCç¨‹åº_ç¼–ç å‚è€ƒbctest.cç¼–ç ï¼š test_serverï¼šå‘ServiceManageræ·»åŠ æœåŠ¡â€helloâ€ &amp;&amp; â€œgoodbyeâ€ Service test_client ï¼šæŸ¥è¯¢è·å–æœåŠ¡(ServiceManager) é“¾æ¥ï¼šBinder_C_App 3.3ã€Android Binderç³»ç»ŸCç¨‹åº_æµ‹è¯•./test_server &amp; ./test_client hello ./test_client hello 100ask.taobao.com ./test_client goodbye ./test_client goodbye 100ask.taobao.com äºŒã€Android Binderç³»ç»Ÿ-Driverå±‚å‰é¢æ‰“å¼€é©±åŠ¨binder_open(128*1024)ã€ServiceManagerå¯åŠ¨æ˜¯å¦‚ä½•ä¸é©±åŠ¨äº¤äº’æˆä¸ºç®¡ç†è€…çš„ï¼Œä»¥åŠæ·»åŠ æœåŠ¡è·å–æœåŠ¡ é©±åŠ¨éƒ¨åˆ†éƒ½æ²¡æœ‰è¯¦ç»†è®²è§£ï¼Œç°åœ¨ä¸€èµ·æ¥çœ‹ä¸‹ã€‚ ï¼ˆ1ï¼‰ã€Binderé©±åŠ¨æ¦‚è¿°1.1 æ¦‚è¿°Binderé©±åŠ¨æ˜¯Androidä¸“ç”¨çš„ï¼Œä½†åº•å±‚çš„é©±åŠ¨æ¶æ„ä¸Linuxé©±åŠ¨ä¸€æ ·ã€‚binderé©±åŠ¨åœ¨ä»¥miscè®¾å¤‡è¿›è¡Œæ³¨å†Œï¼Œä½œä¸ºè™šæ‹Ÿå­—ç¬¦è®¾å¤‡ï¼Œæ²¡æœ‰ç›´æ¥æ“ä½œç¡¬ä»¶ï¼Œåªæ˜¯å¯¹è®¾å¤‡å†…å­˜çš„å¤„ç†ã€‚ä¸»è¦æ˜¯é©±åŠ¨è®¾å¤‡çš„åˆå§‹åŒ–(binder_init)ï¼Œæ‰“å¼€ (binder_open)ï¼Œæ˜ å°„(binder_mmap)ï¼Œæ•°æ®æ“ä½œ(binder_ioctl)ã€‚å¦‚å¯åŠ¨ServiceManagerè°ƒç”¨: 1.2 ç³»ç»Ÿè°ƒç”¨ç”¨æˆ·æ€çš„ç¨‹åºè°ƒç”¨Kernelå±‚é©±åŠ¨æ˜¯éœ€è¦é™·å…¥å†…æ ¸æ€ï¼Œè¿›è¡Œç³»ç»Ÿè°ƒç”¨(syscall)ï¼Œæ¯”å¦‚æ‰“å¼€Binderé©±åŠ¨æ–¹æ³•çš„è°ƒç”¨é“¾ä¸ºï¼š open-&gt; open() -&gt; binder_open()ã€‚ open()ä¸ºç”¨æˆ·ç©ºé—´çš„æ–¹æ³•ï¼Œopen()ä¾¿æ˜¯ç³»ç»Ÿè°ƒç”¨ä¸­ç›¸åº”çš„å¤„ç†æ–¹æ³•ï¼Œé€šè¿‡æŸ¥æ‰¾ï¼Œå¯¹åº”è°ƒç”¨åˆ°å†…æ ¸binderé©±åŠ¨çš„binder_open()æ–¹æ³•ï¼Œè‡³äºå…¶ä»–çš„ä»ç”¨æˆ·æ€é™·å…¥å†…æ ¸æ€çš„æµç¨‹ä¹ŸåŸºæœ¬ä¸€è‡´ã€‚ ï¼ˆ2ï¼‰ã€Binderæ ¸å¿ƒæ–¹æ³•2.1ã€binder_init()ä¸»è¦å·¥ä½œæ˜¯ä¸ºäº†æ³¨å†Œmiscè®¾å¤‡ binder_initå‡½æ•°ä¸­æœ€ä¸»è¦çš„å·¥ä½œå…¶å®ä¸‹é¢è¿™è¡Œï¼š 1ret = misc_register(&amp;binder_miscdev); è¯¥è¡Œä»£ç çœŸæ­£å‘å†…æ ¸ä¸­æ³¨å†Œäº†Binderè®¾å¤‡ã€‚binder_miscdevçš„å®šä¹‰å¦‚ä¸‹ï¼š 12345static struct miscdevice binder_miscdev = &#123; .minor = MISC_DYNAMIC_MINOR, .name = \"binder\", .fops = &amp;binder_fops&#125;; è¿™é‡ŒæŒ‡å®šäº†Binderè®¾å¤‡çš„åç§°æ˜¯â€binderâ€ã€‚è¿™æ ·ï¼Œåœ¨ç”¨æˆ·ç©ºé—´ä¾¿å¯ä»¥é€šè¿‡å¯¹/dev/binderæ–‡ä»¶è¿›è¡Œæ“ä½œæ¥ä½¿ç”¨Binderã€‚ binder_miscdevåŒæ—¶ä¹ŸæŒ‡å®šäº†è¯¥è®¾å¤‡çš„fopsã€‚fopsæ˜¯å¦å¤–ä¸€ä¸ªç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä¸­åŒ…å«äº†ä¸€ç³»åˆ—çš„å‡½æ•°æŒ‡é’ˆï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š 12345678910static const struct file_operations binder_fops = &#123; .owner = THIS_MODULE, .poll = binder_poll, .unlocked_ioctl = binder_ioctl, .compat_ioctl = binder_ioctl, .mmap = binder_mmap, .open = binder_open, .flush = binder_flush, .release = binder_release,&#125;; 2.2ã€ä¸»è¦ç»“æ„Binderé©±åŠ¨ä¸­åŒ…å«äº†å¾ˆå¤šçš„ç»“æ„ä½“ã€‚ä¸ºäº†ä¾¿äºä¸‹æ–‡è®²è§£ï¼Œè¿™é‡Œæˆ‘ä»¬å…ˆå¯¹è¿™äº›ç»“æ„ä½“åšä¸€äº›ä»‹ç»ã€‚ é©±åŠ¨ä¸­çš„ç»“æ„ä½“å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š ä¸€ç±»æ˜¯ä¸ç”¨æˆ·ç©ºé—´å…±ç”¨çš„ï¼Œè¿™äº›ç»“æ„ä½“åœ¨Binderé€šä¿¡åè®®è¿‡ç¨‹ä¸­ä¼šç”¨åˆ°ã€‚å› æ­¤ï¼Œè¿™äº›ç»“æ„ä½“å®šä¹‰åœ¨binder.hä¸­ï¼ŒåŒ…æ‹¬ï¼š ç»“æ„ä½“åç§° è¯´æ˜ flat_binder_object æè¿°åœ¨Binder IPCä¸­ä¼ é€’çš„å¯¹è±¡ï¼Œè§ä¸‹æ–‡ binder_write_read å­˜å‚¨ä¸€æ¬¡è¯»å†™æ“ä½œçš„æ•°æ® binder_version å­˜å‚¨Binderçš„ç‰ˆæœ¬å· transaction_flags æè¿°äº‹åŠ¡çš„flagï¼Œä¾‹å¦‚æ˜¯å¦æ˜¯å¼‚æ­¥è¯·æ±‚ï¼Œæ˜¯å¦æ”¯æŒfd binder_transaction_data å­˜å‚¨ä¸€æ¬¡äº‹åŠ¡çš„æ•°æ® binder_ptr_cookie åŒ…å«äº†ä¸€ä¸ªæŒ‡é’ˆå’Œä¸€ä¸ªcookie binder_handle_cookie åŒ…å«äº†ä¸€ä¸ªå¥æŸ„å’Œä¸€ä¸ªcookie binder_pri_desc æš‚æœªç”¨åˆ° binder_pri_ptr_cookie æš‚æœªç”¨åˆ° ä»å‰é¢Binderç³»ç»ŸCç¨‹åºæ¡†æ¶åˆ†æï¼Œè¿™å…¶ä¸­ï¼Œbinder_write_readå’Œbinder_transaction_dataè¿™ä¸¤ä¸ªç»“æ„ä½“æœ€ä¸ºé‡è¦ï¼Œå®ƒä»¬å­˜å‚¨äº†IPCè°ƒç”¨è¿‡ç¨‹ä¸­çš„æ•°æ®ã€‚å…³äºè¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬åœ¨ä¸‹æ–‡ä¸­ä¼šè®²è§£ã€‚ Binderé©±åŠ¨ä¸­ï¼Œè¿˜æœ‰ä¸€ç±»ç»“æ„ä½“æ˜¯ä»…ä»…Binderé©±åŠ¨å†…éƒ¨å®ç°è¿‡ç¨‹ä¸­éœ€è¦çš„ï¼Œå®ƒä»¬å®šä¹‰åœ¨binder.cä¸­ï¼ŒåŒ…æ‹¬ï¼š ç»“æ„ä½“åç§° è¯´æ˜ binder_node æè¿°Binderå®ä½“èŠ‚ç‚¹ï¼Œå³ï¼šå¯¹åº”äº†ä¸€ä¸ªServer binder_ref æè¿°å¯¹äºBinderå®ä½“çš„å¼•ç”¨ binder_buffer æè¿°Binderé€šä¿¡è¿‡ç¨‹ä¸­å­˜å‚¨æ•°æ®çš„Buffer binder_proc æè¿°ä½¿ç”¨Binderçš„è¿›ç¨‹ binder_thread æè¿°ä½¿ç”¨Binderçš„çº¿ç¨‹ binder_work æè¿°é€šä¿¡è¿‡ç¨‹ä¸­çš„ä¸€é¡¹ä»»åŠ¡ binder_transaction æè¿°ä¸€æ¬¡äº‹åŠ¡çš„ç›¸å…³ä¿¡æ¯ binder_deferred_state æè¿°å»¶è¿Ÿä»»åŠ¡ binder_ref_death æè¿°Binderå®ä½“æ­»äº¡çš„ä¿¡æ¯ binder_transaction_log debugfsæ—¥å¿— binder_transaction_log_entry debugfsæ—¥å¿—æ¡ç›® è¿™é‡Œéœ€è¦è¯»è€…å…³æ³¨çš„ç»“æ„ä½“å·²ç»ç”¨åŠ ç²—åšäº†æ ‡æ³¨ã€‚ 2.3ã€Binderåè®®Binderåè®®å¯ä»¥åˆ†ä¸ºæ§åˆ¶åè®®å’Œé©±åŠ¨åè®®ä¸¤ç±»ã€‚ æ§åˆ¶åè®®æ˜¯è¿›ç¨‹é€šè¿‡ioctl(â€œ/dev/binderâ€) ä¸Binderè®¾å¤‡è¿›è¡Œé€šè®¯çš„åè®®ï¼Œè¯¥åè®®åŒ…å«ä»¥ä¸‹å‡ ç§å‘½ä»¤ï¼š ç»“æ„ä½“åç§° è¯´æ˜ å‚æ•°ç±»å‹ BINDER_WRITE_READ è¯»å†™æ“ä½œï¼Œæœ€å¸¸ç”¨çš„å‘½ä»¤ã€‚IPCè¿‡ç¨‹å°±æ˜¯é€šè¿‡è¿™ä¸ªå‘½ä»¤è¿›è¡Œæ•°æ®ä¼ é€’ binder_write_read BINDER_SET_MAX_THREADS è®¾ç½®è¿›ç¨‹æ”¯æŒçš„æœ€å¤§çº¿ç¨‹æ•°é‡ size_t BINDER_SET_CONTEXT_MGR è®¾ç½®è‡ªèº«ä¸ºServiceManager æ—  BINDER_THREAD_EXIT é€šçŸ¥é©±åŠ¨Binderçº¿ç¨‹é€€å‡º æ—  BINDER_VERSION è·å–Binderé©±åŠ¨çš„ç‰ˆæœ¬å· binder_version BINDER_SET_IDLE_PRIORITY æš‚æœªç”¨åˆ° - BINDER_SET_IDLE_TIMEOUT æš‚æœªç”¨åˆ° - Binderçš„é©±åŠ¨åè®®æè¿°äº†å¯¹äºBinderé©±åŠ¨çš„å…·ä½“ä½¿ç”¨è¿‡ç¨‹ã€‚é©±åŠ¨åè®®åˆå¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š ä¸€ç±»æ˜¯binder_driver_command_protocolï¼Œæè¿°äº†è¿›ç¨‹å‘é€ç»™Binderé©±åŠ¨çš„å‘½ä»¤ ä¸€ç±»æ˜¯binder_driver_return_protocolï¼Œæè¿°äº†Binderé©±åŠ¨å‘é€ç»™è¿›ç¨‹çš„å‘½ä»¤ binder_driver_command_protocolå…±åŒ…å«17ä¸ªå‘½ä»¤ï¼Œåˆ†åˆ«æ˜¯ï¼š ç»“æ„ä½“åç§° è¯´æ˜ å‚æ•°ç±»å‹ BC_TRANSACTION Binderäº‹åŠ¡ï¼Œå³ï¼šClientå¯¹äºServerçš„è¯·æ±‚ binder_transaction_data BC_REPLY äº‹åŠ¡çš„åº”ç­”ï¼Œå³ï¼šServerå¯¹äºClientçš„å›å¤ binder_transaction_data BC_FREE_BUFFER é€šçŸ¥é©±åŠ¨é‡Šæ”¾Buffer binder_uintptr_t BC_ACQUIRE å¼ºå¼•ç”¨è®¡æ•°+1 __u32 BC_RELEASE å¼ºå¼•ç”¨è®¡æ•°-1 __u32 BC_INCREFS å¼±å¼•ç”¨è®¡æ•°+1 __u32 BC_DECREFS å¼±å¼•ç”¨è®¡æ•°-1 __u32 BC_ACQUIRE_DONE BR_ACQUIREçš„å›å¤ binder_ptr_cookie BC_INCREFS_DONE BR_INCREFSçš„å›å¤ binder_ptr_cookie BC_ENTER_LOOPER é€šçŸ¥é©±åŠ¨ä¸»çº¿ç¨‹ready void BC_REGISTER_LOOPER é€šçŸ¥é©±åŠ¨å­çº¿ç¨‹ready void BC_EXIT_LOOPER é€šçŸ¥é©±åŠ¨çº¿ç¨‹å·²ç»é€€å‡º void BC_REQUEST_DEATH_NOTIFICATION è¯·æ±‚æ¥æ”¶æ­»äº¡é€šçŸ¥ binder_handle_cookie BC_CLEAR_DEATH_NOTIFICATION å»é™¤æ¥æ”¶æ­»äº¡é€šçŸ¥ binder_handle_cookie BC_DEAD_BINDER_DONE å·²ç»å¤„ç†å®Œæ­»äº¡é€šçŸ¥ binder_uintptr_t BC_ATTEMPT_ACQUIRE æš‚æœªå®ç° - BC_ACQUIRE_RESULT æš‚æœªå®ç° - binder_driver_return_protocolå…±åŒ…å«18ä¸ªå‘½ä»¤ï¼Œåˆ†åˆ«æ˜¯ï¼š ç»“æ„ä½“åç§° è¯´æ˜ å‚æ•°ç±»å‹ BR_OK æ“ä½œå®Œæˆ void BR_NOOP æ“ä½œå®Œæˆ void BR_ERROR å‘ç”Ÿé”™è¯¯ __s32 BR_TRANSACTION é€šçŸ¥è¿›ç¨‹æ”¶åˆ°ä¸€æ¬¡Binderè¯·æ±‚ï¼ˆServerç«¯ï¼‰ binder_transaction_data BR_REPLY é€šçŸ¥è¿›ç¨‹æ”¶åˆ°Binderè¯·æ±‚çš„å›å¤ï¼ˆClientï¼‰ binder_transaction_data BR_TRANSACTION_COMPLETE é©±åŠ¨å¯¹äºæ¥å—è¯·æ±‚çš„ç¡®è®¤å›å¤ void BR_FAILED_REPLY å‘ŠçŸ¥å‘é€æ–¹é€šä¿¡ç›®æ ‡ä¸å­˜åœ¨ void BR_SPAWN_LOOPER é€šçŸ¥Binderè¿›ç¨‹åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ void BR_ACQUIRE å¼ºå¼•ç”¨è®¡æ•°+1è¯·æ±‚ binder_ptr_cookie BR_RELEASE å¼ºå¼•ç”¨è®¡æ•°-1è¯·æ±‚ binder_ptr_cookie BR_INCREFS å¼±å¼•ç”¨è®¡æ•°+1è¯·æ±‚ binder_ptr_cookie BR_DECREFS è‹¥å¼•ç”¨è®¡æ•°-1è¯·æ±‚ binder_ptr_cookie BR_DEAD_BINDER å‘é€æ­»äº¡é€šçŸ¥ binder_uintptr_t BR_CLEAR_DEATH_NOTIFICATION_DONE æ¸…ç†æ­»äº¡é€šçŸ¥å®Œæˆ binder_uintptr_t BR_DEAD_REPLY å‘ŠçŸ¥å‘é€æ–¹å¯¹æ–¹å·²ç»æ­»äº¡ void BR_ACQUIRE_RESULT æš‚æœªå®ç° - BR_ATTEMPT_ACQUIRE æš‚æœªå®ç° - BR_FINISHED æš‚æœªå®ç° - å•ç‹¬çœ‹ä¸Šé¢çš„åè®®å¯èƒ½å¾ˆéš¾ç†è§£ï¼Œè¿™é‡Œæˆ‘ä»¬ä»¥ä¸€æ¬¡Binderè¯·æ±‚è¿‡ç¨‹æ¥è¯¦ç»†çœ‹ä¸€ä¸‹Binderåè®®æ˜¯å¦‚ä½•é€šä¿¡çš„ï¼Œå°±æ¯”è¾ƒå¥½ç†è§£äº†ã€‚ è¿™å¹…å›¾çš„è¯´æ˜å¦‚ä¸‹ï¼š Binderæ˜¯C/Sæ¶æ„çš„ï¼Œé€šä¿¡è¿‡ç¨‹ç‰µæ¶‰åˆ°ï¼šClientï¼ŒServerä»¥åŠBinderé©±åŠ¨ä¸‰ä¸ªè§’è‰² Clientå¯¹äºServerçš„è¯·æ±‚ä»¥åŠServerå¯¹äºClientå›å¤éƒ½éœ€è¦é€šè¿‡Binderé©±åŠ¨æ¥ä¸­è½¬æ•°æ® BC_XXXå‘½ä»¤æ˜¯è¿›ç¨‹å‘é€ç»™é©±åŠ¨çš„å‘½ä»¤ BR_XXXå‘½ä»¤æ˜¯é©±åŠ¨å‘é€ç»™è¿›ç¨‹çš„å‘½ä»¤ æ•´ä¸ªé€šä¿¡è¿‡ç¨‹ç”±Binderé©±åŠ¨æ§åˆ¶ 2.4ã€binder_open()ä»»ä½•è¿›ç¨‹åœ¨ä½¿ç”¨Binderä¹‹å‰ï¼Œéƒ½éœ€è¦å…ˆé€šè¿‡open(â€œ/dev/binderâ€)æ‰“å¼€Binderè®¾å¤‡ã€‚ä¸Šæ–‡å·²ç»æåˆ°ï¼Œç”¨æˆ·ç©ºé—´çš„openç³»ç»Ÿè°ƒç”¨å¯¹åº”äº†é©±åŠ¨ä¸­çš„binder_openå‡½æ•°ã€‚åœ¨è¿™ä¸ªå‡½æ•°ï¼ŒBinderé©±åŠ¨ä¼šä¸ºè°ƒç”¨çš„è¿›ç¨‹åšä¸€äº›åˆå§‹åŒ–å·¥ä½œã€‚binder_openå‡½æ•°ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011121314151617181920212223242526272829static int binder_open(struct inode *nodp, struct file *filp)&#123; struct binder_proc *proc; // åˆ›å»ºè¿›ç¨‹å¯¹åº”çš„binder_procå¯¹è±¡ proc = kzalloc(sizeof(*proc), GFP_KERNEL); if (proc == NULL) return -ENOMEM; get_task_struct(current); proc-&gt;tsk = current; // åˆå§‹åŒ–binder_proc INIT_LIST_HEAD(&amp;proc-&gt;todo); init_waitqueue_head(&amp;proc-&gt;wait); proc-&gt;default_priority = task_nice(current); // é”ä¿æŠ¤ binder_lock(__func__); binder_stats_created(BINDER_STAT_PROC); // æ·»åŠ åˆ°å…¨å±€åˆ—è¡¨binder_procsä¸­ hlist_add_head(&amp;proc-&gt;proc_node, &amp;binder_procs); proc-&gt;pid = current-&gt;group_leader-&gt;pid; INIT_LIST_HEAD(&amp;proc-&gt;delivered_death); filp-&gt;private_data = proc; binder_unlock(__func__); return 0;&#125; åœ¨Binderé©±åŠ¨ä¸­ï¼Œé€šè¿‡binder_procsè®°å½•äº†æ‰€æœ‰ä½¿ç”¨Binderçš„è¿›ç¨‹ã€‚æ¯ä¸ªåˆæ¬¡æ‰“å¼€Binderè®¾å¤‡çš„è¿›ç¨‹éƒ½ä¼šè¢«æ·»åŠ åˆ°è¿™ä¸ªåˆ—è¡¨ä¸­çš„ã€‚ å¦å¤–ï¼Œè¯·è¯»è€…å›é¡¾ä¸€ä¸‹ä¸Šæ–‡ä»‹ç»çš„Binderé©±åŠ¨ä¸­çš„å‡ ä¸ªå…³é”®ç»“æ„ä½“ï¼š binder_proc binder_node binder_thread binder_ref binder_buffer åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œä¸ºäº†ä¾¿äºæŸ¥æ‰¾ï¼Œè¿™äº›ç»“æ„ä½“äº’ç›¸ä¹‹é—´éƒ½ç•™æœ‰å­—æ®µå­˜å‚¨å…³è”çš„ç»“æ„ã€‚ ä¸‹é¢è¿™å¹…å›¾æè¿°äº†è¿™é‡Œè¯´åˆ°çš„è¿™äº›å†…å®¹ï¼š 2.5ã€binder_mmap()åœ¨æ‰“å¼€Binderè®¾å¤‡ä¹‹åï¼Œè¿›ç¨‹è¿˜ä¼šé€šè¿‡mmapè¿›è¡Œå†…å­˜æ˜ å°„ã€‚mmapçš„ä½œç”¨æœ‰å¦‚ä¸‹ä¸¤ä¸ªï¼š ç”³è¯·ä¸€å—å†…å­˜ç©ºé—´ï¼Œç”¨æ¥æ¥æ”¶Binderé€šä¿¡è¿‡ç¨‹ä¸­çš„æ•°æ® å¯¹è¿™å—å†…å­˜è¿›è¡Œåœ°å€æ˜ å°„ï¼Œä»¥ä¾¿å°†æ¥è®¿é—® binder_mmapå‡½æ•°å¯¹åº”äº†mmapç³»ç»Ÿè°ƒç”¨çš„å¤„ç†ï¼Œè¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯Binderé©±åŠ¨çš„ç²¾åæ‰€åœ¨ï¼ˆè¿™é‡Œè¯´çš„binder_mmapå‡½æ•°ä¹ŸåŒ…æ‹¬å…¶å†…éƒ¨è°ƒç”¨çš„binder_update_page_rangeå‡½æ•°ï¼Œè§ä¸‹æ–‡ï¼‰ã€‚ å‰æ–‡æˆ‘ä»¬è¯´åˆ°ï¼Œä½¿ç”¨Binderæœºåˆ¶ï¼Œæ•°æ®åªéœ€è¦ç»å†ä¸€æ¬¡æ‹·è´å°±å¯ä»¥äº†ï¼Œå…¶åŸç†å°±åœ¨è¿™ä¸ªå‡½æ•°ä¸­ã€‚ binder_mmapè¿™ä¸ªå‡½æ•°ä¸­ï¼Œä¼šç”³è¯·ä¸€å—ç‰©ç†å†…å­˜ï¼Œç„¶ååœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´åŒæ—¶å¯¹åº”åˆ°è¿™å—å†…å­˜ä¸Šã€‚åœ¨è¿™ä¹‹åï¼Œå½“æœ‰Clientè¦å‘é€æ•°æ®ç»™Serverçš„æ—¶å€™ï¼Œåªéœ€ä¸€æ¬¡ï¼Œå°†Clientå‘é€è¿‡æ¥çš„æ•°æ®æ‹·è´åˆ°Serverç«¯çš„å†…æ ¸ç©ºé—´æŒ‡å®šçš„å†…å­˜åœ°å€å³å¯ï¼Œç”±äºè¿™ä¸ªå†…å­˜åœ°å€åœ¨æœåŠ¡ç«¯å·²ç»åŒæ—¶æ˜ å°„åˆ°ç”¨æˆ·ç©ºé—´ï¼Œå› æ­¤æ— éœ€å†åšä¸€æ¬¡å¤åˆ¶ï¼ŒServerå³å¯ç›´æ¥è®¿é—®ï¼Œæ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š è¿™å¹…å›¾çš„è¯´æ˜å¦‚ä¸‹ï¼š Serveråœ¨å¯åŠ¨ä¹‹åï¼Œè°ƒç”¨å¯¹/dev/binderè®¾å¤‡è°ƒç”¨mmap å†…æ ¸ä¸­çš„binder_mmapå‡½æ•°è¿›è¡Œå¯¹åº”çš„å¤„ç†ï¼šç”³è¯·ä¸€å—ç‰©ç†å†…å­˜ï¼Œç„¶ååœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´åŒæ—¶è¿›è¡Œæ˜ å°„ Clienté€šè¿‡BINDER_WRITE_READå‘½ä»¤å‘é€è¯·æ±‚ï¼Œè¿™ä¸ªè¯·æ±‚å°†å…ˆåˆ°é©±åŠ¨ä¸­ï¼ŒåŒæ—¶éœ€è¦å°†æ•°æ®ä»Clientè¿›ç¨‹çš„ç”¨æˆ·ç©ºé—´æ‹·è´åˆ°å†…æ ¸ç©ºé—´ é©±åŠ¨é€šè¿‡BR_TRANSACTIONé€šçŸ¥Serveræœ‰äººå‘å‡ºè¯·æ±‚ï¼ŒServerè¿›è¡Œå¤„ç†ã€‚ç”±äºè¿™å—å†…å­˜ä¹Ÿåœ¨ç”¨æˆ·ç©ºé—´è¿›è¡Œäº†æ˜ å°„ï¼Œå› æ­¤Serverè¿›ç¨‹çš„ä»£ç å¯ä»¥ç›´æ¥è®¿é—® äº†è§£åŸç†ä¹‹åï¼Œæˆ‘ä»¬å†æ¥çœ‹ä¸€ä¸‹Binderé©±åŠ¨çš„ç›¸å…³æºç ã€‚è¿™æ®µä»£ç æœ‰ä¸¤ä¸ªå‡½æ•°ï¼š binder_mmapå‡½æ•°å¯¹åº”äº†mmapçš„ç³»ç»Ÿè°ƒç”¨çš„å¤„ç† binder_update_page_rangeå‡½æ•°çœŸæ­£å®ç°äº†å†…å­˜åˆ†é…å’Œåœ°å€æ˜ å°„ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697static int binder_mmap(struct file *filp, struct vm_area_struct *vma)&#123; int ret; struct vm_struct *area; struct binder_proc *proc = filp-&gt;private_data; const char *failure_string; struct binder_buffer *buffer; ... // åœ¨å†…æ ¸ç©ºé—´è·å–ä¸€å—åœ°å€èŒƒå›´ area = get_vm_area(vma-&gt;vm_end - vma-&gt;vm_start, VM_IOREMAP); if (area == NULL) &#123; ret = -ENOMEM; failure_string = \"get_vm_area\"; goto err_get_vm_area_failed; &#125; proc-&gt;buffer = area-&gt;addr; // è®°å½•å†…æ ¸ç©ºé—´ä¸ç”¨æˆ·ç©ºé—´çš„åœ°å€åç§» proc-&gt;user_buffer_offset = vma-&gt;vm_start - (uintptr_t)proc-&gt;buffer; mutex_unlock(&amp;binder_mmap_lock); ... proc-&gt;pages = kzalloc(sizeof(proc-&gt;pages[0]) * ((vma-&gt;vm_end - vma-&gt;vm_start) / PAGE_SIZE), GFP_KERNEL); if (proc-&gt;pages == NULL) &#123; ret = -ENOMEM; failure_string = \"alloc page array\"; goto err_alloc_pages_failed; &#125; proc-&gt;buffer_size = vma-&gt;vm_end - vma-&gt;vm_start; vma-&gt;vm_ops = &amp;binder_vm_ops; vma-&gt;vm_private_data = proc; /* binder_update_page_range assumes preemption is disabled */ preempt_disable(); // é€šè¿‡ä¸‹é¢è¿™ä¸ªå‡½æ•°çœŸæ­£å®Œæˆå†…å­˜çš„ç”³è¯·å’Œåœ°å€çš„æ˜ å°„ // åˆæ¬¡ä½¿ç”¨ï¼Œå…ˆç”³è¯·ä¸€ä¸ªPAGE_SIZEå¤§å°çš„å†…å­˜ ret = binder_update_page_range(proc, 1, proc-&gt;buffer, proc-&gt;buffer + PAGE_SIZE, vma); ...&#125;static int binder_update_page_range(struct binder_proc *proc, int allocate, void *start, void *end, struct vm_area_struct *vma)&#123; void *page_addr; unsigned long user_page_addr; struct vm_struct tmp_area; struct page **page; struct mm_struct *mm; ... for (page_addr = start; page_addr &lt; end; page_addr += PAGE_SIZE) &#123; int ret; struct page **page_array_ptr; page = &amp;proc-&gt;pages[(page_addr - proc-&gt;buffer) / PAGE_SIZE]; BUG_ON(*page); // çœŸæ­£è¿›è¡Œå†…å­˜çš„åˆ†é… *page = alloc_page(GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO); if (*page == NULL) &#123; pr_err(\"%d: binder_alloc_buf failed for page at %p\\n\", proc-&gt;pid, page_addr); goto err_alloc_page_failed; &#125; tmp_area.addr = page_addr; tmp_area.size = PAGE_SIZE + PAGE_SIZE /* guard page? */; page_array_ptr = page; // åœ¨å†…æ ¸ç©ºé—´è¿›è¡Œå†…å­˜æ˜ å°„ ret = map_vm_area(&amp;tmp_area, PAGE_KERNEL, &amp;page_array_ptr); if (ret) &#123; pr_err(\"%d: binder_alloc_buf failed to map page at %p in kernel\\n\", proc-&gt;pid, page_addr); goto err_map_kernel_failed; &#125; user_page_addr = (uintptr_t)page_addr + proc-&gt;user_buffer_offset; // åœ¨ç”¨æˆ·ç©ºé—´è¿›è¡Œå†…å­˜æ˜ å°„ ret = vm_insert_page(vma, user_page_addr, page[0]); if (ret) &#123; pr_err(\"%d: binder_alloc_buf failed to map page at %lx in userspace\\n\", proc-&gt;pid, user_page_addr); goto err_vm_insert_page_failed; &#125; /* vm_insert_page does not seem to increment the refcount */ &#125; if (mm) &#123; up_write(&amp;mm-&gt;mmap_sem); mmput(mm); &#125; preempt_disable(); return 0;... binder_update_page_rangeä¸»è¦å®Œæˆå·¥ä½œï¼šåˆ†é…ç‰©ç†ç©ºé—´ï¼Œå°†ç‰©ç†ç©ºé—´æ˜ å°„åˆ°å†…æ ¸ç©ºé—´ï¼Œå°†ç‰©ç†ç©ºé—´æ˜ å°„åˆ°è¿›ç¨‹ç©ºé—´. å¦å¤–ï¼Œä¸åŒå‚æ•°ä¸‹è¯¥æ–¹æ³•ä¹Ÿå¯ä»¥é‡Šæ”¾ç‰©ç†é¡µé¢ã€‚ 2.6ã€binder_ioctl()å†…å­˜ç®¡ç†ä¸Šæ–‡ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°binder_mmapçš„æ—¶å€™ï¼Œä¼šç”³è¯·ä¸€ä¸ªPAGE_SIZE(é€šå¸¸æ˜¯4K)çš„å†…å­˜ã€‚è€Œå®é™…ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œä¸€ä¸ªPAGE_SIZEçš„å¤§å°é€šå¸¸æ˜¯ä¸å¤Ÿçš„ã€‚ åœ¨é©±åŠ¨ä¸­ï¼Œä¼šæ ¹æ®å®é™…çš„ä½¿ç”¨æƒ…å†µè¿›è¡Œå†…å­˜çš„åˆ†é…ã€‚æœ‰å†…å­˜çš„åˆ†é…ï¼Œå½“ç„¶ä¹Ÿéœ€è¦å†…å­˜çš„é‡Šæ”¾ã€‚è¿™é‡Œæˆ‘ä»¬å°±æ¥çœ‹çœ‹Binderé©±åŠ¨ä¸­æ˜¯å¦‚ä½•è¿›è¡Œå†…å­˜çš„ç®¡ç†çš„ã€‚ é¦–å…ˆï¼Œæˆ‘ä»¬è¿˜æ˜¯ä»ä¸€æ¬¡IPCè¯·æ±‚è¯´èµ·ã€‚ å½“ä¸€ä¸ªClientæƒ³è¦å¯¹Serverå‘å‡ºè¯·æ±‚æ—¶ï¼Œå®ƒé¦–å…ˆå°†è¯·æ±‚å‘é€åˆ°Binderè®¾å¤‡ä¸Šï¼Œç”±Binderé©±åŠ¨æ ¹æ®è¯·æ±‚çš„ä¿¡æ¯æ‰¾åˆ°å¯¹åº”çš„ç›®æ ‡èŠ‚ç‚¹ï¼Œç„¶åå°†è¯·æ±‚æ•°æ®ä¼ é€’è¿‡å»ã€‚ è¿›ç¨‹é€šè¿‡ioctlç³»ç»Ÿè°ƒç”¨æ¥å‘å‡ºè¯·æ±‚ï¼šioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) è¿™é‡Œçš„bs-&gt;fdå¯¹åº”äº†æ‰“å¼€Binderè®¾å¤‡æ—¶çš„fdã€‚BINDER_WRITE_READå¯¹åº”äº†å…·ä½“è¦åšçš„æ“ä½œç ï¼Œè¿™ä¸ªæ“ä½œç å°†ç”±Binderé©±åŠ¨è§£æã€‚bwrå­˜å‚¨äº†è¯·æ±‚æ•°æ®ï¼Œå…¶ç±»å‹æ˜¯binder_write_readã€‚ binder_write_readå…¶å®æ˜¯ä¸€ä¸ªç›¸å¯¹å¤–å±‚çš„æ•°æ®ç»“æ„ï¼Œå…¶å†…éƒ¨ä¼šåŒ…å«ä¸€ä¸ªbinder_transaction_dataç»“æ„çš„æ•°æ®ã€‚binder_transaction_dataåŒ…å«äº†å‘å‡ºè¯·æ±‚è€…çš„æ ‡è¯†ï¼Œè¯·æ±‚çš„ç›®æ ‡å¯¹è±¡ä»¥åŠè¯·æ±‚æ‰€éœ€è¦çš„å‚æ•°ã€‚å®ƒä»¬çš„å…³ç³»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š binder_ioctlå‡½æ•°å¯¹åº”äº†ioctlç³»ç»Ÿè°ƒç”¨çš„å¤„ç†ã€‚è¿™ä¸ªå‡½æ•°çš„é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æ ¹æ®ioctlçš„å‘½ä»¤æ¥ç¡®å®šè¿›ä¸€æ­¥å¤„ç†çš„é€»è¾‘ï¼Œå…·ä½“å¦‚ä¸‹: â— å¦‚æœå‘½ä»¤æ˜¯BINDER_WRITE_READï¼Œå¹¶ä¸”â— å¦‚æœ bwr.write_size &gt; 0ï¼Œåˆ™è°ƒç”¨binder_thread_writeâ— å¦‚æœ bwr.read_size &gt; 0ï¼Œåˆ™è°ƒç”¨binder_thread_readâ— å¦‚æœå‘½ä»¤æ˜¯BINDER_SET_MAX_THREADSï¼Œåˆ™è®¾ç½®è¿›ç¨‹çš„max_threadsï¼Œå³è¿›ç¨‹æ”¯æŒçš„æœ€å¤§çº¿ç¨‹æ•°â— å¦‚æœå‘½ä»¤æ˜¯BINDER_SET_CONTEXT_MGRï¼Œåˆ™è®¾ç½®å½“å‰è¿›ç¨‹ä¸ºServiceManagerï¼Œè§ä¸‹æ–‡â— å¦‚æœå‘½ä»¤æ˜¯BINDER_THREAD_EXITï¼Œåˆ™è°ƒç”¨binder_free_threadï¼Œé‡Šæ”¾binder_threadâ— å¦‚æœå‘½ä»¤æ˜¯BINDER_VERSIONï¼Œåˆ™è¿”å›å½“å‰çš„Binderç‰ˆæœ¬å· è¿™å…¶ä¸­ï¼Œæœ€å…³é”®çš„å°±æ˜¯binder_thread_writeæ–¹æ³•ã€‚å½“Clientè¯·æ±‚Serverçš„æ—¶å€™ï¼Œä¾¿ä¼šå‘é€ä¸€ä¸ªBINDER_WRITE_READå‘½ä»¤ï¼ŒåŒæ—¶æ¡†æ¶ä¼šå°†å°†å®é™…çš„æ•°æ®åŒ…è£…å¥½ã€‚æ­¤æ—¶ï¼Œbinder_transaction_dataä¸­çš„codeå°†æ˜¯BC_TRANSACTIONï¼Œç”±æ­¤ä¾¿ä¼šè°ƒç”¨åˆ°binder_transactionæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯å¯¹ä¸€æ¬¡Binderäº‹åŠ¡çš„å¤„ç†ï¼Œè¿™å…¶ä¸­ä¼šè°ƒç”¨binder_alloc_bufå‡½æ•°ä¸ºæ­¤æ¬¡äº‹åŠ¡ç”³è¯·ä¸€ä¸ªç¼“å­˜ã€‚ 12345678910111213141516struct binder_buffer &#123; struct list_head entry; struct rb_node rb_node; unsigned free:1; unsigned allow_user_free:1; unsigned async_transaction:1; unsigned debug_id:29; struct binder_transaction *transaction; struct binder_node *target_node; size_t data_size; size_t offsets_size; uint8_t data[0];&#125;; è€Œåœ¨binder_procï¼ˆæè¿°äº†ä½¿ç”¨Binderçš„è¿›ç¨‹ï¼‰ä¸­ï¼ŒåŒ…å«äº†å‡ ä¸ªå­—æ®µç”¨æ¥ç®¡ç†è¿›ç¨‹åœ¨Binder IPCè¿‡ç¨‹ä¸­ç¼“å­˜ï¼Œå¦‚ä¸‹ï¼š 12345678910struct binder_proc &#123; ... struct list_head buffers; // è¿›ç¨‹æ‹¥æœ‰çš„bufferåˆ—è¡¨ struct rb_root free_buffers; // ç©ºé—²bufferåˆ—è¡¨ struct rb_root allocated_buffers; // å·²ä½¿ç”¨çš„bufferåˆ—è¡¨ size_t free_async_space; // å‰©ä½™çš„å¼‚æ­¥è°ƒç”¨çš„ç©ºé—´ size_t buffer_size; // ç¼“å­˜çš„ä¸Šé™ ...&#125;; è¿›ç¨‹åœ¨mmapæ—¶ï¼Œä¼šè®¾å®šæ”¯æŒçš„æ€»ç¼“å­˜å¤§å°çš„ä¸Šé™ï¼ˆä¸‹æ–‡ä¼šè®²åˆ°ï¼‰ã€‚è€Œè¿›ç¨‹æ¯å½“æ”¶åˆ°BC_TRANSACTIONï¼Œå°±ä¼šåˆ¤æ–­å·²ä½¿ç”¨ç¼“å­˜åŠ æœ¬æ¬¡ç”³è¯·çš„å’Œæœ‰æ²¡æœ‰è¶…è¿‡ä¸Šé™ã€‚å¦‚æœæ²¡æœ‰ï¼Œå°±è€ƒè™‘è¿›è¡Œå†…å­˜çš„åˆ†é…ã€‚ è¿›ç¨‹çš„ç©ºé—²ç¼“å­˜è®°å½•åœ¨binder_procçš„free_buffersä¸­ï¼Œè¿™æ˜¯ä¸€ä¸ªä»¥çº¢é»‘æ ‘å½¢å¼å­˜å‚¨çš„ç»“æ„ã€‚æ¯æ¬¡å°è¯•åˆ†é…ç¼“å­˜çš„æ—¶å€™ï¼Œä¼šä»è¿™é‡Œé¢æŒ‰å¤§å°é¡ºåºè¿›è¡ŒæŸ¥æ‰¾ï¼Œæ‰¾åˆ°æœ€æ¥è¿‘éœ€è¦çš„ä¸€å—ç¼“å­˜ã€‚æŸ¥æ‰¾çš„é€»è¾‘å¦‚ä¸‹ï¼š 123456789101112131415while (n) &#123; buffer = rb_entry(n, struct binder_buffer, rb_node); BUG_ON(!buffer-&gt;free); buffer_size = binder_buffer_size(proc, buffer); if (size &lt; buffer_size) &#123; best_fit = n; n = n-&gt;rb_left; &#125; else if (size &gt; buffer_size) n = n-&gt;rb_right; else &#123; best_fit = n; break; &#125;&#125; æ‰¾åˆ°ä¹‹åï¼Œè¿˜éœ€è¦å¯¹binder_procä¸­çš„å­—æ®µè¿›è¡Œç›¸åº”çš„æ›´æ–°ï¼š 123456789101112131415161718192021rb_erase(best_fit, &amp;proc-&gt;free_buffers);buffer-&gt;free = 0;binder_insert_allocated_buffer(proc, buffer);if (buffer_size != size) &#123; struct binder_buffer *new_buffer = (void *)buffer-&gt;data + size; list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry); new_buffer-&gt;free = 1; binder_insert_free_buffer(proc, new_buffer);&#125;binder_debug(BINDER_DEBUG_BUFFER_ALLOC, \"%d: binder_alloc_buf size %zd got %p\\n\", proc-&gt;pid, size, buffer);buffer-&gt;data_size = data_size;buffer-&gt;offsets_size = offsets_size;buffer-&gt;async_transaction = is_async;if (is_async) &#123; proc-&gt;free_async_space -= size + sizeof(struct binder_buffer); binder_debug(BINDER_DEBUG_BUFFER_ALLOC_ASYNC, \"%d: binder_alloc_buf size %zd async free %zd\\n\", proc-&gt;pid, size, proc-&gt;free_async_space);&#125; ä¸‹é¢æˆ‘ä»¬å†æ¥çœ‹çœ‹å†…å­˜çš„é‡Šæ”¾ã€‚ BC_FREE_BUFFERå‘½ä»¤æ˜¯é€šçŸ¥é©±åŠ¨è¿›è¡Œå†…å­˜çš„é‡Šæ”¾ï¼Œbinder_free_bufå‡½æ•°æ˜¯çœŸæ­£å®ç°çš„é€»è¾‘ï¼Œè¿™ä¸ªå‡½æ•°ä¸binder_alloc_bufæ˜¯åˆšå¥½å¯¹åº”çš„ã€‚åœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œæ‰€åšçš„äº‹æƒ…åŒ…æ‹¬ï¼š é‡æ–°è®¡ç®—è¿›ç¨‹çš„ç©ºé—²ç¼“å­˜å¤§å° é€šè¿‡binder_update_page_rangeé‡Šæ”¾å†…å­˜ æ›´æ–°binder_procçš„buffersï¼Œfree_buffersï¼Œallocated_bufferså­—æ®µ 2.7ã€Binderä¸­çš„â€é¢å‘å¯¹è±¡â€Binderæœºåˆ¶æ·¡åŒ–äº†è¿›ç¨‹çš„è¾¹ç•Œï¼Œä½¿å¾—è·¨è¶Šè¿›ç¨‹ä¹Ÿèƒ½å¤Ÿè°ƒç”¨åˆ°æŒ‡å®šæœåŠ¡çš„æ–¹æ³•ï¼Œå…¶åŸå› æ˜¯å› ä¸ºBinderæœºåˆ¶åœ¨åº•å±‚å¤„ç†äº†åœ¨è¿›ç¨‹é—´çš„â€å¯¹è±¡â€ä¼ é€’ã€‚ åœ¨Binderé©±åŠ¨ä¸­ï¼Œå¹¶ä¸æ˜¯çœŸçš„å°†å¯¹è±¡åœ¨è¿›ç¨‹é—´æ¥å›åºåˆ—åŒ–ï¼Œè€Œæ˜¯é€šè¿‡ç‰¹å®šçš„æ ‡è¯†æ¥è¿›è¡Œå¯¹è±¡çš„ä¼ é€’ã€‚Binderé©±åŠ¨ä¸­ï¼Œé€šè¿‡flat_binder_objectæ¥æè¿°éœ€è¦è·¨è¶Šè¿›ç¨‹ä¼ é€’çš„å¯¹è±¡ã€‚å…¶å®šä¹‰å¦‚ä¸‹ï¼š 12345678910struct flat_binder_object &#123; __u32 type; __u32 flags; union &#123; binder_uintptr_t binder; /* local object */ __u32 handle; /* remote object */ &#125;; binder_uintptr_t cookie;&#125;; è¿™å…¶ä¸­ï¼Œtypeæœ‰å¦‚ä¸‹5ç§ç±»å‹ã€‚ 1234567enum &#123; BINDER_TYPE_BINDER = B_PACK_CHARS('s', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_BINDER = B_PACK_CHARS('w', 'b', '*', B_TYPE_LARGE), BINDER_TYPE_HANDLE = B_PACK_CHARS('s', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_WEAK_HANDLE = B_PACK_CHARS('w', 'h', '*', B_TYPE_LARGE), BINDER_TYPE_FD = B_PACK_CHARS('f', 'd', '*', B_TYPE_LARGE),&#125;; å½“å¯¹è±¡ä¼ é€’åˆ°Binderé©±åŠ¨ä¸­çš„æ—¶å€™ï¼Œç”±é©±åŠ¨æ¥è¿›è¡Œç¿»è¯‘å’Œè§£é‡Šï¼Œç„¶åä¼ é€’åˆ°æ¥æ”¶çš„è¿›ç¨‹ã€‚ ä¾‹å¦‚å½“ServeræŠŠBinderå®ä½“ä¼ é€’ç»™Clientæ—¶ï¼Œåœ¨å‘é€æ•°æ®æµä¸­ï¼Œflat_binder_objectä¸­çš„typeæ˜¯BINDER_TYPE_BINDERï¼ŒåŒæ—¶binderå­—æ®µæŒ‡å‘Serverè¿›ç¨‹ç”¨æˆ·ç©ºé—´åœ°å€ã€‚ä½†è¿™ä¸ªåœ°å€å¯¹äºClientè¿›ç¨‹æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼ˆLinuxä¸­ï¼Œæ¯ä¸ªè¿›ç¨‹çš„åœ°å€ç©ºé—´æ˜¯äº’ç›¸éš”ç¦»çš„ï¼‰ï¼Œé©±åŠ¨å¿…é¡»å¯¹æ•°æ®æµä¸­çš„flat_binder_objectåšç›¸åº”çš„ç¿»è¯‘ï¼šå°†typeè¯¥æˆBINDER_TYPE_HANDLEï¼›ä¸ºè¿™ä¸ªBinderåœ¨æ¥æ”¶è¿›ç¨‹ä¸­åˆ›å»ºä½äºå†…æ ¸ä¸­çš„å¼•ç”¨å¹¶å°†å¼•ç”¨å·å¡«å…¥handleä¸­ã€‚å¯¹äºå‘ç”Ÿæ•°æ®æµä¸­å¼•ç”¨ç±»å‹çš„Binderä¹Ÿè¦åšåŒæ ·è½¬æ¢ã€‚ç»è¿‡å¤„ç†åæ¥æ”¶è¿›ç¨‹ä»æ•°æ®æµä¸­å–å¾—çš„Binderå¼•ç”¨æ‰æ˜¯æœ‰æ•ˆçš„ï¼Œæ‰å¯ä»¥å°†å…¶å¡«å…¥æ•°æ®åŒ…binder_transaction_dataçš„target.handleåŸŸï¼Œå‘Binderå®ä½“å‘é€è¯·æ±‚ã€‚ ç”±äºæ¯ä¸ªè¯·æ±‚å’Œè¯·æ±‚çš„è¿”å›éƒ½ä¼šç»å†å†…æ ¸çš„ç¿»è¯‘ï¼Œå› æ­¤è¿™ä¸ªè¿‡ç¨‹ä»è¿›ç¨‹çš„è§’åº¦æ¥çœ‹æ˜¯å®Œå…¨é€æ˜çš„ã€‚è¿›ç¨‹å®Œå…¨ä¸ç”¨æ„ŸçŸ¥è¿™ä¸ªè¿‡ç¨‹ï¼Œå°±å¥½åƒå¯¹è±¡çœŸçš„åœ¨è¿›ç¨‹é—´æ¥å›ä¼ é€’ä¸€æ ·ã€‚ 2.8ã€é©±åŠ¨å±‚çš„çº¿ç¨‹ç®¡ç†ä¸Šæ–‡å¤šæ¬¡æåˆ°ï¼ŒBinderæœ¬èº«æ˜¯C/Sæ¶æ„ã€‚ç”±Serveræä¾›æœåŠ¡ï¼Œè¢«Clientä½¿ç”¨ã€‚æ—¢ç„¶æ˜¯C/Sæ¶æ„ï¼Œå°±å¯èƒ½å­˜åœ¨å¤šä¸ªClientä¼šåŒæ—¶è®¿é—®Serverçš„æƒ…å†µã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå¦‚æœServeråªæœ‰ä¸€ä¸ªçº¿ç¨‹å¤„ç†å“åº”ï¼Œå°±ä¼šå¯¼è‡´å®¢æˆ·ç«¯çš„è¯·æ±‚å¯èƒ½éœ€è¦æ’é˜Ÿè€Œå¯¼è‡´å“åº”è¿‡æ…¢çš„ç°è±¡å‘ç”Ÿã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•å°±æ˜¯å¼•å…¥å¤šçº¿ç¨‹ã€‚ Binderæœºåˆ¶çš„è®¾è®¡ä»æœ€åº•å±‚â€“é©±åŠ¨å±‚ï¼Œå°±è€ƒè™‘åˆ°äº†å¯¹äºå¤šçº¿ç¨‹çš„æ”¯æŒã€‚å…·ä½“å†…å®¹å¦‚ä¸‹ï¼š ä½¿ç”¨Binderçš„è¿›ç¨‹åœ¨å¯åŠ¨ä¹‹åï¼Œé€šè¿‡BINDER_SET_MAX_THREADSå‘ŠçŸ¥é©±åŠ¨å…¶æ”¯æŒçš„æœ€å¤§çº¿ç¨‹æ•°é‡ é©±åŠ¨ä¼šå¯¹çº¿ç¨‹è¿›è¡Œç®¡ç†ã€‚åœ¨binder_procç»“æ„ä¸­ï¼Œè¿™äº›å­—æ®µè®°å½•äº†è¿›ç¨‹ä¸­çº¿ç¨‹çš„ä¿¡æ¯ï¼šmax_threadsï¼Œrequested_threadsï¼Œrequested_threads_startedï¼Œready_threads binder_threadç»“æ„å¯¹åº”äº†Binderè¿›ç¨‹ä¸­çš„çº¿ç¨‹ é©±åŠ¨é€šè¿‡BR_SPAWN_LOOPERå‘½ä»¤å‘ŠçŸ¥è¿›ç¨‹éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ è¿›ç¨‹é€šè¿‡BC_ENTER_LOOPERå‘½ä»¤å‘ŠçŸ¥é©±åŠ¨å…¶ä¸»çº¿ç¨‹å·²ç»ready è¿›ç¨‹é€šè¿‡BC_REGISTER_LOOPERå‘½ä»¤å‘ŠçŸ¥é©±åŠ¨å…¶å­çº¿ç¨‹ï¼ˆéä¸»çº¿ç¨‹ï¼‰å·²ç»ready è¿›ç¨‹é€šè¿‡BC_EXIT_LOOPERå‘½ä»¤å‘ŠçŸ¥é©±åŠ¨å…¶çº¿ç¨‹å°†è¦é€€å‡º åœ¨çº¿ç¨‹é€€å‡ºä¹‹åï¼Œé€šè¿‡BINDER_THREAD_EXITå‘ŠçŸ¥Binderé©±åŠ¨ã€‚é©±åŠ¨å°†å¯¹åº”çš„binder_threadå¯¹è±¡é”€æ¯ 2.9ã€å†èŠServiceManagerä¸Šæ–‡å·²ç»è¯´è¿‡ï¼Œæ¯ä¸€ä¸ªBinder Serveråœ¨é©±åŠ¨ä¸­ä¼šæœ‰ä¸€ä¸ªbinder_nodeè¿›è¡Œå¯¹åº”ã€‚åŒæ—¶ï¼ŒBinderé©±åŠ¨ä¼šè´Ÿè´£åœ¨è¿›ç¨‹é—´ä¼ é€’æœåŠ¡å¯¹è±¡ï¼Œå¹¶è´Ÿè´£åº•å±‚çš„è½¬æ¢ã€‚å¦å¤–ï¼Œæˆ‘ä»¬ä¹Ÿæåˆ°ï¼Œæ¯ä¸€ä¸ªBinderæœåŠ¡éƒ½éœ€è¦æœ‰ä¸€ä¸ªå”¯ä¸€çš„åç§°ã€‚ç”±ServiceManageræ¥ç®¡ç†è¿™äº›æœåŠ¡çš„æ³¨å†Œå’ŒæŸ¥æ‰¾ã€‚ è€Œå®é™…ä¸Šï¼Œä¸ºäº†ä¾¿äºä½¿ç”¨ï¼ŒServiceManageræœ¬èº«ä¹Ÿå®ç°ä¸ºä¸€ä¸ªServerå¯¹è±¡ã€‚ä»»ä½•è¿›ç¨‹åœ¨ä½¿ç”¨ServiceManagerçš„æ—¶å€™ï¼Œéƒ½éœ€è¦å…ˆæ‹¿åˆ°æŒ‡å‘å®ƒçš„æ ‡è¯†ã€‚ç„¶åé€šè¿‡è¿™ä¸ªæ ‡è¯†æ¥ä½¿ç”¨ServiceManagerã€‚ è¿™ä¼¼ä¹å½¢æˆäº†ä¸€ä¸ªäº’ç›¸çŸ›ç›¾çš„ç°è±¡ï¼š é€šè¿‡ServiceManageræˆ‘ä»¬æ‰èƒ½æ‹¿åˆ°Serverçš„æ ‡è¯† ServiceManageræœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªServer è§£å†³è¿™ä¸ªçŸ›ç›¾çš„åŠæ³•å…¶å®ä¹Ÿå¾ˆç®€å•ï¼šBinderæœºåˆ¶ä¸ºServiceManageré¢„ç•™äº†ä¸€ä¸ªç‰¹æ®Šçš„ä½ç½®ã€‚è¿™ä¸ªä½ç½®æ˜¯é¢„å…ˆå®šå¥½çš„ï¼Œä»»ä½•æƒ³è¦ä½¿ç”¨ServiceManagerçš„è¿›ç¨‹åªè¦é€šè¿‡è¿™ä¸ªç‰¹å®šçš„ä½ç½®å°±å¯ä»¥è®¿é—®åˆ°ServiceManageräº†ï¼ˆè€Œä¸ç”¨å†é€šè¿‡ServiceManagerçš„æ¥å£ï¼‰ã€‚ åœ¨Binderé©±åŠ¨ä¸­ï¼Œæœ‰ä¸€ä¸ªå…¨å±€çš„binder_node å˜é‡ï¼š ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå¯¹äºæ¯ä¸€ä¸ªServeré©±åŠ¨å±‚ä¼šå¯¹åº”ä¸€ä¸ªbinder_nodeèŠ‚ç‚¹ï¼Œç„¶è€Œbinder_context_mgr_nodeæ¯”è¾ƒç‰¹æ®Šï¼Œå®ƒæ²¡æœ‰å¯¹åº”çš„åº”ç”¨å±‚binderå®ä½“ã€‚åœ¨æ•´ä¸ªç³»ç»Ÿé‡Œï¼Œå®ƒæ˜¯å¦‚æ­¤ç‰¹æ®Šï¼Œä»¥è‡³äºç³»ç»Ÿè§„å®šï¼Œä»»ä½•åº”ç”¨éƒ½å¿…é¡»ä½¿ç”¨å¥æŸ„0æ¥è·¨è¿›ç¨‹åœ°è®¿é—®å®ƒã€‚ 1static struct binder_node *binder_context_mgr_node; è¿™ä¸ªå˜é‡æŒ‡å‘çš„å°±æ˜¯ServiceManagerã€‚ å½“æœ‰è¿›ç¨‹é€šè¿‡ioctlå¹¶æŒ‡å®šå‘½ä»¤ä¸ºBINDER_SET_CONTEXT_MGRçš„æ—¶å€™ï¼Œé©±åŠ¨è¢«è®¤å®šè¿™ä¸ªè¿›ç¨‹æ˜¯ServiceManagerï¼Œbinder_ioctl()å‡½æ•°ä¸­å¯¹åº”çš„å¤„ç†å¦‚ä¸‹ï¼š 12345678910111213case BINDER_SET_CONTEXT_MGR: if (binder_context_mgr_node != NULL) &#123; &#125; ret = security_binder_set_context_mgr(proc-&gt;tsk); else &#123; binder_context_mgr_uid = current-&gt;cred-&gt;euid; binder_context_mgr_node = binder_new_node(proc, 0, 0);//åœ¨Binderé©±åŠ¨å±‚åˆ›å»ºbinder_nodeç»“æ„ä½“å¯¹è±¡ binder_context_mgr_node-&gt;local_weak_refs++; binder_context_mgr_node-&gt;local_strong_refs++; binder_context_mgr_node-&gt;has_strong_ref = 1; binder_context_mgr_node-&gt;has_weak_ref = 1; &#125; break; ServiceManageråº”å½“è¦å…ˆäºæ‰€æœ‰Binder Serverä¹‹å‰å¯åŠ¨ã€‚åœ¨å®ƒå¯åŠ¨å®Œæˆå¹¶å‘ŠçŸ¥Binderé©±åŠ¨ä¹‹åï¼Œé©±åŠ¨ä¾¿è®¾å®šå¥½äº†è¿™ä¸ªç‰¹å®šçš„èŠ‚ç‚¹ã€‚ åœ¨è¿™ä¹‹åï¼Œå½“æœ‰å…¶ä»–æ¨¡å—æƒ³è¦ä½¿ç”¨ServerManagerçš„æ—¶å€™ï¼Œåªè¦å°†è¯·æ±‚æŒ‡å‘ServiceManageræ‰€åœ¨çš„ä½ç½®å³å¯ã€‚ åœ¨Binderé©±åŠ¨ä¸­ï¼Œé€šè¿‡handle = 0è¿™ä¸ªä½ç½®æ¥è®¿é—®ServiceManagerã€‚ä¾‹å¦‚ï¼Œbinder_transactionä¸­ï¼Œåˆ¤æ–­å¦‚æœtarget.handlerä¸º0ï¼Œåˆ™è®¤ä¸ºè¿™ä¸ªè¯·æ±‚æ˜¯å‘é€ç»™ServiceManagerçš„ï¼Œç›¸å…³ä»£ç å¦‚ä¸‹ï¼š 123456789101112131415161718if (tr-&gt;target.handle) &#123; struct binder_ref *ref; ref = binder_get_ref(proc, tr-&gt;target.handle, true); if (ref == NULL) &#123; binder_user_error(\"%d:%d got transaction to invalid handle\\n\", proc-&gt;pid, thread-&gt;pid); return_error = BR_FAILED_REPLY; goto err_invalid_target_handle; &#125; target_node = ref-&gt;node;&#125; else &#123; target_node = binder_context_mgr_node; if (target_node == NULL) &#123; return_error = BR_DEAD_REPLY; goto err_no_context_mgr_node; &#125;&#125; 2.10ã€binder_nodeç­‰é‡è¦ç»“æ„ä½“ binder_proc binder_node binder_thread binder_ref binder_buffer 1. Binderå®ä½“binder_node Binderå®ä½“ï¼Œæ˜¯å„ä¸ªServerä»¥åŠServiceManageråœ¨å†…æ ¸ä¸­çš„å­˜åœ¨å½¢å¼ã€‚ Binderå®ä½“å®é™…ä¸Šæ˜¯å†…æ ¸ä¸­binder_nodeç»“æ„ä½“çš„å¯¹è±¡ï¼Œå®ƒçš„ä½œç”¨æ˜¯åœ¨å†…æ ¸ä¸­ä¿å­˜Serverå’ŒServiceManagerçš„ä¿¡æ¯(ä¾‹å¦‚ï¼ŒBinderå®ä½“ä¸­ä¿å­˜äº†Serverå¯¹è±¡åœ¨ç”¨æˆ·ç©ºé—´çš„åœ°å€)ã€‚ç®€è¨€ä¹‹ï¼ŒBinderå®ä½“æ˜¯Serveråœ¨Binderé©±åŠ¨ä¸­çš„å­˜åœ¨å½¢å¼ï¼Œå†…æ ¸é€šè¿‡Binderå®ä½“å¯ä»¥æ‰¾åˆ°ç”¨æˆ·ç©ºé—´çš„Serverå¯¹è±¡ã€‚ åœ¨ä¸Šå›¾ä¸­ï¼ŒServerå’ŒServiceManageråœ¨Binderé©±åŠ¨ä¸­éƒ½å¯¹åº”çš„å­˜åœ¨ä¸€ä¸ªBinderå®ä½“ã€‚ 2. Binderå¼•ç”¨binder_ref è¯´åˆ°Binderå®ä½“ï¼Œå°±ä¸å¾—ä¸è¯´â€Binderå¼•ç”¨â€ã€‚æ‰€è°“Binderå¼•ç”¨ï¼Œå®é™…ä¸Šæ˜¯å†…æ ¸ä¸­binder_refç»“æ„ä½“çš„å¯¹è±¡ï¼Œå®ƒçš„ä½œç”¨æ˜¯åœ¨è¡¨ç¤ºâ€Binderå®ä½“â€çš„å¼•ç”¨ã€‚æ¢å¥è¯è¯´ï¼Œæ¯ä¸€ä¸ªBinderå¼•ç”¨éƒ½æ˜¯æŸä¸€ä¸ªBinderå®ä½“çš„å¼•ç”¨ï¼Œé€šè¿‡Binderå¼•ç”¨å¯ä»¥åœ¨å†…æ ¸ä¸­æ‰¾åˆ°å®ƒå¯¹åº”çš„Binderå®ä½“ã€‚ å¦‚æœå°†Serverçœ‹ä½œæ˜¯Binderå®ä½“çš„è¯ï¼Œé‚£ä¹ˆClientå°±å¥½æ¯”Binderå¼•ç”¨ã€‚Clientè¦å’ŒServeré€šä¿¡ï¼Œå®ƒå°±æ˜¯é€šè¿‡ä¿å­˜ä¸€ä¸ªServerå¯¹è±¡çš„Binderå¼•ç”¨ï¼Œå†é€šè¿‡è¯¥Binderå¼•ç”¨åœ¨å†…æ ¸ä¸­æ‰¾åˆ°å¯¹åº”çš„Binderå®ä½“ï¼Œè¿›è€Œæ‰¾åˆ°Serverå¯¹è±¡ï¼Œç„¶åå°†é€šä¿¡å†…å®¹å‘é€ç»™Serverå¯¹è±¡ã€‚ Binderå®ä½“å’ŒBinderå¼•ç”¨éƒ½æ˜¯å†…æ ¸(å³ï¼ŒBinderé©±åŠ¨)ä¸­çš„æ•°æ®ç»“æ„ã€‚æ¯ä¸€ä¸ªServeråœ¨å†…æ ¸ä¸­å°±è¡¨ç°ä¸ºä¸€ä¸ªBinderå®ä½“ï¼Œè€Œæ¯ä¸€ä¸ªClientåˆ™è¡¨ç°ä¸ºä¸€ä¸ªBinderå¼•ç”¨ã€‚è¿™æ ·ï¼Œæ¯ä¸ªBinderå¼•ç”¨éƒ½å¯¹åº”ä¸€ä¸ªBinderå®ä½“ï¼Œè€Œæ¯ä¸ªBinderå®ä½“åˆ™å¯ä»¥å¤šä¸ªBinderå¼•ç”¨ã€‚ 3ã€Binder bufferï¼šbinder_buffer 4ã€Binderè¿›ç¨‹binder_proc 5ã€Binderçº¿ç¨‹binder_thread binderæœºåˆ¶åˆ°åº•æ˜¯å¦‚ä½•ä»Binderå¯¹è±¡æ‰¾åˆ°å…¶å¯¹åº”çš„Binderå®ä½“å‘¢ï¼Ÿ æ³¨æ„å…¶ä¸­çš„é‚£4ä¸ªrb_rootåŸŸï¼Œâ€rbâ€çš„æ„æ€æ˜¯â€red blackâ€ï¼Œå¯è§binder_procé‡Œæå‡ºäº†4ä¸ªçº¢é»‘æ ‘ã€‚ å…¶ä¸­ï¼Œnodesæ ‘ç”¨äºè®°å½•binderå®ä½“ï¼Œrefs_by_descæ ‘å’Œrefs_by_nodeæ ‘åˆ™ç”¨äºè®°å½•binderä»£ç†ã€‚ä¹‹æ‰€ä»¥ä¼šæœ‰ä¸¤ä¸ªä»£ç†æ ‘ï¼Œæ˜¯ä¸ºäº†ä¾¿äºå¿«é€ŸæŸ¥æ‰¾ï¼Œæˆ‘ä»¬æš‚æ—¶åªå…³å¿ƒå…¶ä¸­ä¹‹ä¸€å°±å¯ä»¥äº†ã€‚threadsæ ‘ç”¨äºè®°å½•æ‰§è¡Œä¼ è¾“åŠ¨ä½œçš„çº¿ç¨‹ä¿¡æ¯ã€‚ åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œæœ‰å¤šå°‘â€è¢«å…¶ä»–è¿›ç¨‹è¿›è¡Œè·¨è¿›ç¨‹è°ƒç”¨çš„â€binderå®ä½“ï¼Œå°±ä¼šåœ¨è¯¥è¿›ç¨‹å¯¹åº”çš„nodesæ ‘ä¸­ç”Ÿæˆå¤šå°‘ä¸ªçº¢é»‘æ ‘èŠ‚ç‚¹ã€‚å¦ä¸€æ–¹é¢ï¼Œä¸€ä¸ªè¿›ç¨‹è¦è®¿é—®å¤šå°‘å…¶ä»–è¿›ç¨‹çš„binderå®ä½“ï¼Œåˆ™å¿…é¡»åœ¨å…¶refs_by_descæ ‘ä¸­æ‹¥æœ‰å¯¹åº”çš„å¼•ç”¨èŠ‚ç‚¹ã€‚ è¿™4æ£µæ ‘çš„èŠ‚ç‚¹ç±»å‹æ˜¯ä¸åŒçš„ï¼Œthreadsæ ‘çš„èŠ‚ç‚¹ç±»å‹ä¸ºbinder_threadï¼Œnodesæ ‘çš„èŠ‚ç‚¹ç±»å‹ä¸ºbinder_nodeï¼Œrefs_by_descæ ‘å’Œrefs_by_nodeæ ‘çš„èŠ‚ç‚¹ç±»å‹ç›¸åŒï¼Œä¸ºbinder_refã€‚è¿™äº›èŠ‚ç‚¹å†…éƒ¨éƒ½ä¼šåŒ…å«rb_nodeå­ç»“æ„ï¼Œè¯¥ç»“æ„ä¸“é—¨è´Ÿè´£è¿æ¥èŠ‚ç‚¹çš„å·¥ä½œï¼Œå’Œå‰æ–‡çš„hlist_nodeæœ‰ç‚¹å„¿å¼‚æ›²åŒå·¥ï¼Œè¿™ä¹Ÿæ˜¯linuxä¸Šä¸€ä¸ªå¸¸ç”¨çš„å°æŠ€å·§ã€‚æˆ‘ä»¬ä»¥nodesæ ‘ä¸ºä¾‹ nodesæ ‘æ˜¯ç”¨äºè®°å½•binderå®ä½“çš„ï¼Œæ‰€ä»¥nodesæ ‘ä¸­çš„æ¯ä¸ªbinder_nodeèŠ‚ç‚¹ï¼Œå¿…é¡»èƒ½å¤Ÿè®°å½•ä¸‹ç›¸åº”binderå®ä½“çš„ä¿¡æ¯ã€‚å› æ­¤è¯·å¤§å®¶æ³¨æ„binder_nodeçš„ptråŸŸå’ŒcookieåŸŸã€‚ å¦ä¸€æ–¹é¢ï¼Œrefs_by_descæ ‘å’Œrefs_by_nodeæ ‘çš„æ¯ä¸ªbinder_refèŠ‚ç‚¹åˆ™å’Œä¸Šå±‚çš„ä¸€ä¸ªBpBinderå¯¹åº”ï¼Œè€Œä¸”æ›´é‡è¦çš„æ˜¯ï¼Œå®ƒå¿…é¡»å…·æœ‰å’Œâ€ç›®æ ‡binderå®ä½“çš„binder_nodeâ€è¿›è¡Œå…³è”çš„ä¿¡æ¯ã€‚ è¯·æ³¨æ„binder_refçš„é‚£ä¸ªnodeåŸŸï¼Œå®ƒè´Ÿè´£å’Œbinder_nodeå…³è”ã€‚å¦å¤–ï¼Œbinder_refä¸­æœ‰ä¸¤ä¸ªç±»å‹ä¸ºrb_nodeçš„åŸŸï¼šrb_node_descåŸŸå’Œrb_node_nodeåŸŸï¼Œå®ƒä»¬åˆ†åˆ«ç”¨äºè¿æ¥refs_by_descæ ‘å’Œrefs_by_nodeã€‚ä¹Ÿå°±æ˜¯è¯´è™½ç„¶binder_procä¸­æœ‰ä¸¤æ£µå¼•ç”¨æ ‘ï¼Œä½†è¿™ä¸¤æ£µæ ‘ç”¨åˆ°çš„å…·ä½“binder_refèŠ‚ç‚¹å…¶å®æ˜¯å¤ç”¨çš„ã€‚ binder_node.ptrå¯¹åº”äºflat_binder_object.binderï¼› binder_node.cookieå¯¹åº”äºflat_binder_object.cookieã€‚ OKï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥æ›´æ·±å…¥åœ°è¯´æ˜binderå¥æŸ„çš„ä½œç”¨äº†ï¼Œæ¯”å¦‚è¿›ç¨‹1çš„BpBinderåœ¨å‘èµ·è·¨è¿›ç¨‹è°ƒç”¨æ—¶ï¼Œå‘binderé©±åŠ¨ä¼ å…¥äº†è‡ªå·±è®°å½•çš„å¥æŸ„å€¼ï¼Œbinderé©±åŠ¨å°±ä¼šåœ¨â€è¿›ç¨‹1å¯¹åº”çš„binder_procç»“æ„â€çš„å¼•ç”¨æ ‘ä¸­æŸ¥æ‰¾å’Œå¥æŸ„å€¼ç›¸ç¬¦çš„binder_refèŠ‚ç‚¹ï¼Œä¸€æ—¦æ‰¾åˆ°binder_refèŠ‚ç‚¹ï¼Œå°±å¯ä»¥é€šè¿‡è¯¥èŠ‚ç‚¹çš„nodeåŸŸæ‰¾åˆ°å¯¹åº”çš„binder_nodeèŠ‚ç‚¹ï¼Œè¿™ä¸ªç›®æ ‡binder_nodeå½“ç„¶æ˜¯ä»å±äºè¿›ç¨‹2çš„binder_procå•¦ï¼Œä¸è¿‡ä¸è¦ç´§ï¼Œå› ä¸ºbinder_refå’Œbinder_nodeéƒ½å¤„äºbinderé©±åŠ¨çš„åœ°å€ç©ºé—´ä¸­ï¼Œæ‰€ä»¥æ˜¯å¯ä»¥ç”¨æŒ‡é’ˆç›´æ¥æŒ‡å‘çš„ã€‚ç›®æ ‡binder_nodeèŠ‚ç‚¹çš„cookieåŸŸï¼Œè®°å½•çš„å…¶å®æ˜¯è¿›ç¨‹2ä¸­BBinderçš„åœ°å€ï¼Œbinderé©±åŠ¨åªéœ€æŠŠè¿™ä¸ªå€¼åæ˜ ç»™åº”ç”¨å±‚ï¼Œåº”ç”¨å±‚å°±å¯ä»¥ç›´æ¥æ‹¿åˆ°BBinderäº†ã€‚è¿™å°±æ˜¯Binderå®Œæˆç²¾ç¡®æ‰“å‡»çš„å¤§ä½“è¿‡ç¨‹ã€‚ ä¸‰ã€Android Binderç³»ç»Ÿé©±åŠ¨æƒ…æ™¯åˆ†æä¸ºäº†æ›´æ·±åˆ»çš„äº†è§£Binderç³»ç»Ÿ æ³¨å†ŒæœåŠ¡ã€è·å–æœåŠ¡ã€ä½¿ç”¨æœåŠ¡çš„è¿‡ç¨‹ï¼Œåœ¨Driverå±‚(kernel/drivers/staging/android/binder.c)çš„binder_thread_read()å‡½æ•°ã€binder_transaction()å‡½æ•°å…¥æ‰“å°logï¼Œè®©å‰é¢ç¼–å†™çš„Cç¨‹åºç¤ºä¾‹ä¸binderé©±åŠ¨äº¤äº’æ‰“å°æ›´è¯¦ç»†çš„è¿‡ç¨‹ã€‚ 12345static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed) å·²æ·»åŠ å¥½æ‰“å°logçš„binder.cæ–‡ä»¶è§GitHubï¼ˆæ³¨ï¼šæœç´¢[/* print] å…³é”®å­—ï¼‰ äº‹å…ˆå·²ç»å‡†å¤‡å¥½æ‰“å°logï¼Œç°åœ¨ç»“åˆlogå’ŒBinderäº‹åŠ¡å¤„ç†å¼€å§‹è¯¦ç»†åˆ†æã€‚æ³¨ï¼šlogç¨ååˆ†æå†è´´å‡ºã€‚ ï¼ˆ1ï¼‰ã€Binderç³»ç»Ÿé©±åŠ¨æƒ…æ™¯åˆ†æâ€“æœåŠ¡â€Helloâ€æ³¨å†Œè¿‡ç¨‹ 1.1ã€ServiceManagerä¼‘çœ ç­‰å¾…å›é¡¾ä¸€ä¸‹ServiceManagerå¯åŠ¨æµç¨‹ï¼ŒServiceManagerè¿›å…¥binder_loop()å ä¼šä¼‘çœ ç­‰å¾…å“åº”clientè¯·æ±‚ã€‚ 12345678910111213141516171819202122binder_loop()&#123; // å‘Šè¯‰Kernelï¼ŒServiceManagerè¿›ç¨‹è¿›å…¥äº†æ¶ˆæ¯å¾ªç¯çŠ¶æ€ã€‚ readbuf[0] = BC_ENTER_LOOPER; binder_write(bs, readbuf, sizeof(unsigned)); bwr.write_size = 0; bwr.write_consumed = 0; bwr.write_buffer = 0; for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (unsigned) readbuf; // å‘Kernelä¸­å‘é€æ¶ˆæ¯(å…ˆå†™åè¯»)ã€‚ // å…ˆå°†æ¶ˆæ¯ä¼ é€’ç»™Kernelï¼Œç„¶åå†ä»Kernelè¯»å–æ¶ˆæ¯åé¦ˆ res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); // è§£æè¯»å–çš„æ¶ˆæ¯åé¦ˆ res = binder_parse(bs, 0, readbuf, bwr.read_consumed, func); ... &#125;&#125; binder_write(bs, readbuf, sizeof(unsigned));ä¼šè°ƒç”¨ioctlå‘å†…æ ¸å‘é€æ•°æ®ã€‚ 1234567891011121314 int binder_write(struct binder_state *bs, void *data, size_t len)&#123; struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) data; bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); return res;&#125; å¦‚æœ bwr.write_size &gt; 0ï¼Œåˆ™è°ƒç”¨binder_thread_write å¦‚æœ bwr.read_size &gt;0ï¼Œåˆ™è°ƒç”¨binder_thread_read 123456789101112131415161718192021222324252627282930313233343536373839static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // ä¸­æ–­ç­‰å¾…å‡½æ•°ã€‚ ret = wait_event_interruptible(...); // åœ¨procè¿›ç¨‹ä¸­æŸ¥æ‰¾è¯¥çº¿ç¨‹å¯¹åº”çš„binder_threadï¼›è‹¥æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™æ–°å»ºä¸€ä¸ªbinder_threadï¼Œå¹¶æ·»åŠ åˆ°proc-&gt;threadsä¸­ã€‚ thread = binder_get_thread(proc); ... switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; ... // å°†binder_write_readä»\"ç”¨æˆ·ç©ºé—´\" æ‹·è´åˆ° \"å†…æ ¸ç©ºé—´\" if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ... &#125; // å¦‚æœwrite_size&gt;0ï¼Œåˆ™è¿›è¡Œå†™æ“ä½œ if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... &#125; // å¦‚æœread_size&gt;0ï¼Œåˆ™è¿›è¡Œè¯»æ“ä½œ if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... &#125; ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; &#125; break; &#125; &#125; return ret;&#125; bwr.write_size &gt; 0; ç»§ç»­æŸ¥çœ‹binder_thread_write() æ³¨ï¼šåªæœ‰BR_TRANSACTIONã€BR_REPLYã€BC_TRANSACTIONã€BC_REPLYæ¶‰åŠä¸¤è¿›ç¨‹ å…¶ä»–æ‰€æœ‰BC_XXXã€BR_XXXéƒ½åªæ˜¯Appå’Œé©±åŠ¨äº¤äº’ç”¨äºæ”¹å˜æŠ¥å‘ŠçŠ¶æ€ã€‚ 1234567891011121314151617181920212223242526int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // è¯»å–binder_write_read.write_bufferä¸­çš„å†…å®¹ã€‚ // æ¯æ¬¡è¯»å–32bit(å³4ä¸ªå­—èŠ‚) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // ä»ç”¨æˆ·ç©ºé—´è¯»å–32bitåˆ°å†…æ ¸ä¸­ï¼Œå¹¶èµ‹å€¼ç»™cmdã€‚ if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); switch (cmd) &#123; case BC_ENTER_LOOPER: thread-&gt;looper |= BINDER_LOOPER_STATE_ENTERED; break; ... &#125; // æ›´æ–°bwr.write_consumedçš„å€¼ *consumed = ptr - buffer; &#125; return 0;&#125; å½“å‰çº¿ç¨‹è¿›å…¥BC_ENTER_LOOPERçŠ¶æ€ï¼Œç­‰å¾…è¯·æ±‚ã€‚ ç»§ç»­binder_loop()ä¸­çš„for(;;;)å¾ªç¯ï¼Œbwr.read_size &gt;0;ä¼šé€šè¿‡binder_thread_read()è¯»æ“ä½œã€‚ 123456789101112131415161718static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // å¦‚æœ*consumed=0ï¼Œåˆ™å†™å…¥BR_NOOPåˆ°ç”¨æˆ·ä¼ è¿›æ¥çš„bwr.read_bufferç¼“å­˜åŒº if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; // ä¿®æ”¹æŒ‡é’ˆä½ç½® ptr += sizeof(uint32_t); &#125; ...&#125; å¯ä»¥çœ‹åˆ°é©±åŠ¨put_user(BR_NOOP, (uint32_t __user *)ptr)å‘é€BR_NOOPåˆ°ServiceManager å¯¹äºæ‰€æœ‰çš„è¯»æ“ä½œï¼Œæ•°æ®å¤´éƒ½æ˜¯BR_NOOPï¼Œå¦‚BR_REPLY 1234&gt; ./service_manager &amp;&gt; [ 32.566620] service_manager (1362, 1362), binder_thread_write : BC_ENTER_LOOPER&gt; [ 32.566712] service_manager (1362, 1362), binder_thread_read : BR_NOOP&gt; 1.2ã€Clentï¼ˆæ­¤å¤„ä¸ºTest_serverï¼‰è¯·æ±‚SMæ·»åŠ æœåŠ¡æ„é€ æ•°æ®å‘é€ç»™é©±åŠ¨ æˆ‘ä»¬æ‰§è¡ŒTest_serveræ—¶ï¼Œæ‰“å°äº†å¾ˆå¤šæ•°æ®ï¼Œæˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹æ•°æ®çš„æ„é€ è¿‡ç¨‹ å’Œ ç»„ç»‡æ ¼å¼ï¼Œè¿™æœ‰åŠ©äºåŠ æ·±æˆ‘ä»¬å¯¹binderç³»ç»Ÿçš„ç†è§£ã€‚ 123456789101112131415161718int svcmgr_publish(struct binder_state *bs, uint32_t target, const char *name, void *ptr)&#123; int status; unsigned iodata[512/4]; struct binder_io msg, reply; bio_init(&amp;msg, iodata, sizeof(iodata), 4); bio_put_uint32(&amp;msg, 0); // strict mode header bio_put_string16_x(&amp;msg, SVC_MGR_NAME); bio_put_string16_x(&amp;msg, name); bio_put_obj(&amp;msg, ptr); if (binder_call(bs, &amp;msg, &amp;reply, target, SVC_MGR_ADD_SERVICE)) return -1; status = bio_get_uint32(&amp;reply); binder_done(bs, &amp;msg, &amp;reply); return status;&#125; bio_init()ã€bio_put_uint32()ã€bio_put_string16_x()å‡½æ•°æ¯”è¾ƒç®€æ´ã€‚æˆ‘ä»¬çœ‹ä¸‹bio_put_obj()å‡½æ•°ã€‚ æ„å»ºåˆå§‹åŒ–flat_binder_objectç»“æ„ä½“ï¼š 12345678910111213void bio_put_obj(struct binder_io *bio, void *ptr)&#123; struct flat_binder_object *obj; obj = bio_alloc_obj(bio); if (!obj) return; obj-&gt;flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;// obj-&gt;type = BINDER_TYPE_BINDER;// obj-&gt;binder = (uintptr_t)ptr;// obj-&gt;cookie = 0;//0&#125; æ•°æ®ç»“æ„ç¤ºæ„å›¾ï¼š Clentï¼ˆæ­¤å¤„ä¸ºTest_serverï¼‰ï¼Œtest_server.cè°ƒç”¨æµç¨‹ï¼š -&gt;svcmgr_publish() -&gt;binder_call() -&gt;ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) -&gt;binder_thread_write() -&gt;binder_transaction() ç°åœ¨æ•°æ®æ„é€ å¥½äº†ï¼Œbinder_call()ä¼šè°ƒç”¨ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr) 123456789101112131415161718192021222324252627282930313233343536int binder_call(struct binder_state *bs, struct binder_io *msg, struct binder_io *reply, uint32_t target, uint32_t code)&#123; int res; struct binder_write_read bwr; struct &#123; uint32_t cmd; struct binder_transaction_data txn; &#125; __attribute__((packed)) writebuf; unsigned readbuf[32]; writebuf.cmd = BC_TRANSACTION; writebuf.txn.target.handle = target; writebuf.txn.code = code; writebuf.txn.flags = 0; writebuf.txn.data_size = msg-&gt;data - msg-&gt;data0; writebuf.txn.offsets_size = ((char*) msg-&gt;offs) - ((char*) msg-&gt;offs0); writebuf.txn.data.ptr.buffer = (uintptr_t)msg-&gt;data0; writebuf.txn.data.ptr.offsets = (uintptr_t)msg-&gt;offs0; bwr.write_size = sizeof(writebuf); bwr.write_consumed = 0; bwr.write_buffer = (uintptr_t) &amp;writebuf; hexdump(msg-&gt;data0, msg-&gt;data - msg-&gt;data0); for (;;) &#123; bwr.read_size = sizeof(readbuf); bwr.read_consumed = 0; bwr.read_buffer = (uintptr_t) readbuf; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); ... res = binder_parse(bs, reply, (uintptr_t) readbuf, bwr.read_consumed, 0); &#125;&#125; [ 38.320197] test_server (1363, 1363), binder_thread_write : BC_TRANSACTION å‘é€æ•°æ®ï¼Œè¿›è€Œä¼šè°ƒç”¨binder_thread_write()å¤„ç†æ•°æ®ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; // ä¸­æ–­ç­‰å¾…å‡½æ•°ã€‚ ret = wait_event_interruptible(...); // åœ¨procè¿›ç¨‹ä¸­æŸ¥æ‰¾è¯¥çº¿ç¨‹å¯¹åº”çš„binder_threadï¼›è‹¥æŸ¥æ‰¾å¤±è´¥ï¼Œåˆ™æ–°å»ºä¸€ä¸ªbinder_threadï¼Œå¹¶æ·»åŠ åˆ°proc-&gt;threadsä¸­ã€‚ thread = binder_get_thread(proc); ... switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; ... // å°†binder_write_readä»\"ç”¨æˆ·ç©ºé—´\" æ‹·è´åˆ° \"å†…æ ¸ç©ºé—´\" if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; ... &#125; // å¦‚æœwrite_size&gt;0ï¼Œåˆ™è¿›è¡Œå†™æ“ä½œ if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); ... &#125; // å¦‚æœread_size&gt;0ï¼Œåˆ™è¿›è¡Œè¯»æ“ä½œ if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); ... &#125; ... if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; &#125; break; &#125; &#125; return ret;&#125; ç”±äºwrite_size&gt;0ï¼Œè°ƒç”¨binder_thread_write()å¤„ç†æ•°æ®ï¼š 1234567891011121314151617181920212223242526272829303132333435int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // è¯»å–binder_write_read.write_bufferä¸­çš„å†…å®¹ã€‚ // æ¯æ¬¡è¯»å–32bit(å³4ä¸ªå­—èŠ‚) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // ä»ç”¨æˆ·ç©ºé—´è¯»å–32bitåˆ°å†…æ ¸ä¸­ï¼Œå¹¶èµ‹å€¼ç»™cmdã€‚ if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) &#123; ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; // æ›´æ–°bwr.write_consumedçš„å€¼ *consumed = ptr - buffer; &#125; return 0;&#125; ç”±ä¹‹å‰binder_call()åˆ†æï¼Œwritebuf.cmd = BC_TRANSACTION;ä¼šæ‰§è¡Œbinder_transaction()å‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) &#123; &#125; else &#123; if (tr-&gt;target.handle) &#123; target_node = ref-&gt;node; &#125; else &#123; // äº‹åŠ¡ç›®æ ‡å¯¹è±¡æ˜¯ServiceManagerçš„binderå®ä½“ // å³ï¼Œè¯¥äº‹åŠ¡æ˜¯äº¤ç»™Service Manageræ¥å¤„ç†çš„ã€‚ target_node = binder_context_mgr_node; &#125; // è®¾ç½®å¤„ç†äº‹åŠ¡çš„ç›®æ ‡è¿›ç¨‹ target_proc = target_node-&gt;proc; ... &#125; if (target_thread) &#123; ... &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; ... // åˆ†é…ä¸€ä¸ªå¾…å¤„ç†çš„äº‹åŠ¡tï¼Œtæ˜¯binderäº‹åŠ¡(binder_transactionå¯¹è±¡) t = kzalloc(sizeof(*t), GFP_KERNEL); // åˆ†é…ä¸€ä¸ªå¾…å®Œæˆçš„å·¥ä½œtcompleteï¼Œtcompleteæ˜¯binder_workå¯¹è±¡ã€‚ tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... // äº‹åŠ¡å°†äº¤ç»™target_procè¿›ç¨‹è¿›è¡Œå¤„ç† t-&gt;to_proc = target_proc; // äº‹åŠ¡å°†äº¤ç»™target_threadçº¿ç¨‹è¿›è¡Œå¤„ç† t-&gt;to_thread = target_thread; ... // åˆ†é…ç©ºé—´,ä»ç›®çš„è¿›ç¨‹æ˜ å°„çš„ç©ºé—´åˆ†é…buf t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... // ä¿å­˜äº‹åŠ¡ t-&gt;buffer-&gt;transaction = t; // ä¿å­˜äº‹åŠ¡çš„ç›®æ ‡å¯¹è±¡(å³å¤„ç†è¯¥äº‹åŠ¡çš„binderå¯¹è±¡) t-&gt;buffer-&gt;target_node = target_node; offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // å°†\"ç”¨æˆ·ç©ºé—´çš„æ•°æ®\"æ‹·è´åˆ°å†…æ ¸ä¸­ // tr-&gt;data.ptr.bufferå°±æ˜¯ç”¨æˆ·ç©ºé—´æ•°æ®çš„èµ·å§‹åœ°å€ï¼Œtr-&gt;data_sizeå°±æ˜¯æ•°æ®å¤§å° if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; ... &#125; // å°†\"ç”¨æˆ·ç©ºé—´çš„æ•°æ®ä¸­æ‰€å«å¯¹è±¡çš„åç§»åœ°å€\"æ‹·è´åˆ°å†…æ ¸ä¸­ // tr-&gt;data.ptr.offsetså°±æ˜¯æ•°æ®ä¸­çš„å¯¹è±¡åç§»åœ°å€æ•°ç»„ï¼Œtr-&gt;offsets_sizeå°±æ•°æ®ä¸­çš„å¯¹è±¡ä¸ªæ•° // æ‹·è´ä¹‹åï¼Œoffpå°±æ˜¯flat_binder_objectå¯¹è±¡æ•°ç»„åœ¨å†…æ ¸ç©ºé—´çš„åç§»æ•°ç»„çš„èµ·å§‹åœ°å€ if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; ... &#125; ... // off_endå°±æ˜¯flat_binder_objectå¯¹è±¡æ•°ç»„åœ¨å†…æ ¸ç©ºé—´çš„åç§»åœ°å€çš„ç»“æŸåœ°å€ off_end = (void *)offp + tr-&gt;offsets_size; // å°†æ‰€æœ‰çš„flat_binder_objectå¯¹è±¡è¯»å–å‡ºæ¥ // å¯¹TestServerè€Œè¨€ï¼Œåªæœ‰ä¸€ä¸ªflat_binder_objectå¯¹è±¡ã€‚ for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) &#123; case BINDER_TYPE_BINDER: case BINDER_TYPE_WEAK_BINDER: &#123; struct binder_ref *ref; // åœ¨procä¸­æŸ¥æ‰¾binderå®ä½“å¯¹åº”çš„binder_node struct binder_node *node = binder_get_node(proc, fp-&gt;binder); // è‹¥æ‰¾ä¸åˆ°ï¼Œåˆ™æ–°å»ºä¸€ä¸ªbinder_nodeï¼›ä¸‹æ¬¡å°±å¯ä»¥ç›´æ¥ä½¿ç”¨äº†ã€‚ if (node == NULL) &#123; node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); &#125; ... // åœ¨target_proc(å³ï¼ŒServiceManagerçš„è¿›ç¨‹ä¸Šä¸‹æ–‡)ä¸­æŸ¥æ‰¾æ˜¯å¦åŒ…è¡Œ\"è¯¥Binderå®ä½“çš„å¼•ç”¨\"ï¼Œ // å¦‚æœæ²¡æœ‰æ‰¾åˆ°çš„è¯ï¼Œåˆ™å°†\"è¯¥binderå®ä½“çš„å¼•ç”¨\"æ·»åŠ åˆ°target_proc-&gt;refs_by_nodeçº¢é»‘æ ‘ä¸­ã€‚è¿™æ ·ï¼Œå°±å¯ä»¥é€šè¿‡Service Managerå¯¹è¯¥Binderå®ä½“è¿›è¡Œç®¡ç†äº†ã€‚ ref = binder_get_ref_for_node(target_proc, node); // ç°åœ¨ä¿®æ”¹ç›®çš„è¿›ç¨‹typeï¼Œè¡¨ç¤ºServiceManageræŒæœ‰TestServerå¼•ç”¨ï¼ŒTestServerè¿›ç¨‹æ‰èƒ½æ‹¥æœ‰å®ä½“ã€‚ if (fp-&gt;type == BINDER_TYPE_BINDER) fp-&gt;type = BINDER_TYPE_HANDLE; else fp-&gt;type = BINDER_TYPE_WEAK_HANDLE; // ä¿®æ”¹handleã€‚handleå’Œbinderæ˜¯è”åˆä½“ï¼Œè¿™é‡Œå°†handleè®¾ä¸ºå¼•ç”¨çš„æè¿°ã€‚ // æ ¹æ®è¯¥handleå¯ä»¥æ‰¾åˆ°\"è¯¥binderå®ä½“åœ¨target_procä¸­çš„binderå¼•ç”¨\"ï¼› // å³ï¼Œå¯ä»¥æ ¹æ®è¯¥handleï¼Œå¯ä»¥ä»Service Manageræ‰¾åˆ°å¯¹åº”çš„Binderå®ä½“çš„å¼•ç”¨ï¼Œä»è€Œè·å–Binderå®ä½“ã€‚ fp-&gt;handle = ref-&gt;desc; // å¢åŠ å¼•ç”¨è®¡æ•°ï¼Œé˜²æ­¢\"è¯¥binderå®ä½“\"åœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­è¢«é”€æ¯ã€‚ binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); ... &#125; break; ... &#125; &#125; if (reply) &#123; .. &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; BUG_ON(t-&gt;buffer-&gt;async_transaction != 0); t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; // å°†å½“å‰äº‹åŠ¡æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„äº‹åŠ¡æ ˆä¸­ thread-&gt;transaction_stack = t; &#125; else &#123; ... &#125; // è®¾ç½®äº‹åŠ¡çš„ç±»å‹ä¸ºBINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // å°†äº‹åŠ¡æ·»åŠ åˆ°target_listé˜Ÿåˆ—ä¸­ï¼Œå³target_listçš„å¾…å¤„ç†äº‹åŠ¡ä¸­ list_add_tail(&amp;t-&gt;work.entry, target_list); // è®¾ç½®å¾…å®Œæˆå·¥ä½œçš„ç±»å‹ä¸ºBINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // å°†å¾…å®Œæˆå·¥ä½œæ·»åŠ åˆ°thread-&gt;todoé˜Ÿåˆ—ä¸­ï¼Œå³å½“å‰çº¿ç¨‹çš„å¾…å®Œæˆå·¥ä½œä¸­ã€‚ list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // å”¤é†’ç›®æ ‡è¿›ç¨‹ if (target_wait) wake_up_interruptible(target_wait); return; ...&#125; è¯´æ˜ï¼šè¿™é‡Œçš„tr-&gt;target.handle=0ï¼Œå› æ­¤ï¼Œä¼šè®¾ç½®target_nodeä¸ºServiceManagerå¯¹åº”çš„Binderå®ä½“ã€‚ä¸‹é¢æ˜¯target_node,target_procç­‰å€¼åˆå§‹åŒ–ä¹‹åçš„å€¼ã€‚ 1234target_node = binder_context_mgr_node; // ç›®æ ‡èŠ‚ç‚¹ä¸ºService Managerå¯¹åº”çš„Binderå®ä½“target_proc = target_node-&gt;proc; // ç›®æ ‡è¿›ç¨‹ä¸ºService Managerå¯¹åº”çš„binder_procè¿›ç¨‹ä¸Šä¸‹æ–‡ä¿¡æ¯target_list = &amp;target_thread-&gt;todo; // å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—target_wait = &amp;target_thread-&gt;wait; // ç­‰å¾…é˜Ÿåˆ— å°ç»“ï¼š é©±åŠ¨æ¥æ”¶åˆ°TestServerå‘é€çš„æ•°æ®åï¼Œé©±åŠ¨ä¸»è¦å·¥ä½œï¼š ï¼ˆ1ï¼‰æ ¹æ®Handle = 0 æ‰¾åˆ°ç›®çš„è¿›ç¨‹ServiceManager ï¼ˆ2ï¼‰æŠŠæ•°æ®é€šè¿‡copy_from_user()æ”¾åˆ°ç›®çš„è¿›ç¨‹ServiceManagerçš„ç©ºé—´ï¼ˆmmapï¼‰ ï¼ˆ3ï¼‰å¤„ç†offsæ•°æ®ï¼Œå³è§£æflat_binder_objectç»“æ„ä½“ a. ä¸ºTestServeræ„é€ binder_node node = binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie); b.æ„é€ binder_refç»™ç›®çš„è¿›ç¨‹ServiceManager ref = binder_get_ref_for_node(target_proc, node); c.å¢åŠ å¼•ç”¨è®¡æ•°TestServer binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE, &amp;thread-&gt;todo); å¢åŠ å¼•ç”¨è®¡æ•°ä¼šæ·»åŠ work.entryï¼ˆBR_INCREFSã€BR_ACQUIRï¼‰åˆ°TestServer tododé˜Ÿåˆ— list_add_tail(&amp;node-&gt;work.entry, target_list) è¯´æ˜ï¼šå°±æ–°å»ºBinderå®ä½“çš„å¼•ç”¨ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°target_proc-&gt;refs_by_nodeçº¢é»‘æ ‘ å’Œ target_proc-&gt;refs_by_descçº¢é»‘æ ‘ä¸­ã€‚ è¿™æ ·ï¼ŒServiceManagerçš„è¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­å°±å­˜åœ¨Hello Serviceçš„Binderå¼•ç”¨ï¼ŒServiceManagerä¹Ÿå°±å¯ä»¥å¯¹Hello Serviceè¿›è¡Œç®¡ç†äº†ï¼ç„¶åï¼Œä¿®æ”¹fp-&gt;type=BINDER_TYPE_HANDLEï¼Œå¹¶ä½¿fp-&gt;handle = ref-&gt;descã€‚ ï¼ˆ4)æ–°å»ºä¸€ä¸ªå¾…å¤„ç†äº‹åŠ¡tå’Œå¾…å®Œæˆçš„å·¥ä½œtcompleteï¼Œå¹¶å¯¹å®ƒä»¬è¿›è¡Œåˆå§‹åŒ–ã€‚å¾…å¤„ç†äº‹åŠ¡tä¼šè¢«æäº¤ç»™ç›®æ ‡(å³ServiceManagerå¯¹åº”çš„Binderå®ä½“)è¿›è¡Œå¤„ç†ï¼›è€Œå¾…å®Œæˆçš„å·¥ä½œtcompleteåˆ™æ˜¯ä¸ºäº†åé¦ˆç»™TestServeræœåŠ¡ï¼Œå‘Šè¯‰TestServerå®ƒçš„è¯·æ±‚Binderé©±åŠ¨å·²ç»æ”¶åˆ°äº†ã€‚æ³¨æ„ï¼Œè¿™é‡Œä»…ä»…æ˜¯å‘Šè¯‰TestServerè¯¥è¯·æ±‚å·²ç»è¢«æ”¶åˆ°ï¼Œè€Œä¸æ˜¯å¤„ç†å®Œæ¯•ï¼å¾…ServiceManagerå¤„ç†å®Œæ¯•è¯¥è¯·æ±‚ä¹‹åï¼ŒBinderé©±åŠ¨ä¼šå†æ¬¡åé¦ˆç›¸åº”çš„æ¶ˆæ¯ç»™TestServerã€‚ ï¼ˆ5ï¼‰binder_thread_write()ä¸­æ‰§è¡Œbinder_transaction()åï¼Œä¼šæ›´æ–°*consumedçš„å€¼ï¼Œå³bwr.write_consumedçš„å€¼ ï¼ˆ6ï¼‰æ­¤æ—¶ï¼ŒTestServerè¿›ç¨‹è¿˜ä¼šç»§ç»­è¿è¡Œï¼Œè€Œä¸”å®ƒä¹Ÿé€šè¿‡wake_up_interruptible()å”¤é†’äº†ServiceManagerè¿›ç¨‹ã€‚ 12// æ›´æ–°bwr.write_consumedçš„å€¼*consumed = ptr - buffer; æ¥ä¸‹æ¥ï¼Œioctl()ä¼šæ‰§è¡Œbinder_thread_read()æ¥è®¾ç½®åé¦ˆæ•°æ®ç»™TestServerè¿›ç¨‹ 123456789101112131415161718192021222324252627282930313233343536 static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; // å¦‚æœ*consumed=0ï¼Œåˆ™å†™å…¥BR_NOOPåˆ°ç”¨æˆ·ä¼ è¿›æ¥çš„bwr.read_bufferç¼“å­˜åŒº if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125; ... while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // å¦‚æœå½“å‰çº¿ç¨‹çš„\"å¾…å®Œæˆå·¥ä½œ\"ä¸ä¸ºç©ºï¼Œåˆ™å–å‡ºå¾…å®Œæˆå·¥ä½œã€‚ if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); &#125; ... switch (w-&gt;type) &#123; ... case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // å°†BR_TRANSACTION_COMPLETEå†™å…¥åˆ°ç”¨æˆ·ç¼“å†²ç©ºé—´ä¸­ if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; &#125; break; ... // æ›´æ–°bwr.read_consumedçš„å€¼ *consumed = ptr - buffer;&#125; é¦–å…ˆå‘é€BR_NOOPç»™TestServerï¼Œç„¶åå¤„ç†todoé˜Ÿåˆ—ï¼Œå¤„ç†å®Œæˆåä¼šå‘é€BR_TRANSACTION_COMPLETEã€‚ ç°åœ¨å†…æ ¸å·²ç»å¤„ç†å®Œæ•°æ®ï¼Œæˆ‘ä»¬ä»logçœ‹çœ‹æ•°æ®å‘ç”Ÿäº†å“ªäº›å˜åŒ–ï¼š æˆ‘ä»¬å‘ç°flat_binder_objectç»“æ„ä½“çš„typeå€¼å‘ç”Ÿäº†å˜åŒ–ï¼Œbinderå˜æˆäº†Handleï¼Œçœ‹ä¸€ä¸‹ç»“æ„ä½“ï¼Œhandler å’Œ binderæ˜¯ä¸€ä¸ªunionï¼Œå ç”¨åŒä¸€ä¸ªä½ç½®ï¼›Handleä¸º1ä»£è¡¨ç¬¬ä¸€ä¸ªå¼•ç”¨ï¼Œæ„æ€æ˜¯åœ¨ServiceManagerè¿›ç¨‹é‡Œé¢æ ¹æ®1èƒ½æ‰¾åˆ°ç¬¬ä¸€ä¸ªbinder_refï¼Œæ ¹æ®binder_refèƒ½æ‰¾åˆ°æœåŠ¡helloçš„binder_nodeå®ä½“ã€‚ æ¥ä¸‹æ¥å°±ç­‰å¾…ServiceManagerå¤„ç†å®Œæˆåï¼Œå›å¤æ¶ˆæ¯ã€‚ 1.3ã€å”¤é†’ServiceManageræ‰§è¡Œæ·»åŠ â€helloâ€æœåŠ¡å‰é¢é©±åŠ¨å·²ç»åˆ›å»ºå¥½TestServerçš„binder_nodeï¼Œç°åœ¨å”¤é†’ServiceManageræ·»åŠ svcinfo çœ‹çœ‹ServiceManagerè¢«å”¤é†’åï¼Œä¼šå¹²äº›ä»€ä¹ˆã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; ... wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); while (1) &#123; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // å¦‚æœå½“å‰çº¿ç¨‹çš„\"å¾…å®Œæˆå·¥ä½œ\"ä¸ä¸ºç©ºï¼Œåˆ™å–å‡ºå¾…å®Œæˆå·¥ä½œã€‚ if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... switch (w-&gt;type) &#123; case BINDER_WORK_TRANSACTION: &#123; t = container_of(w, struct binder_transaction, work); &#125; break; ... &#125; // t-&gt;buffer-&gt;target_nodeæ˜¯ç›®æ ‡èŠ‚ç‚¹ã€‚ // è¿™é‡Œï¼ŒaddServiceè¯·æ±‚çš„ç›®æ ‡æ˜¯ServiceManagerï¼Œå› æ­¤target_nodeæ˜¯ServiceManagerå¯¹åº”çš„èŠ‚ç‚¹ï¼› // å®ƒçš„å€¼åœ¨äº‹åŠ¡äº¤äº’æ—¶(binder_transactionä¸­)ï¼Œè¢«èµ‹å€¼ä¸ºServiceManagerå¯¹åº”çš„Binderå®ä½“ã€‚ if (t-&gt;buffer-&gt;target_node) &#123; // äº‹åŠ¡ç›®æ ‡å¯¹åº”çš„Binderå®ä½“(å³ï¼ŒServiceManagerå¯¹åº”çš„Binderå®ä½“) struct binder_node *target_node = t-&gt;buffer-&gt;target_node; // Binderå®ä½“åœ¨ç”¨æˆ·ç©ºé—´çš„åœ°å€(ServiceManagerçš„pträ¸ºNULL) tr.target.ptr = target_node-&gt;ptr; // Binderå®ä½“åœ¨ç”¨æˆ·ç©ºé—´çš„å…¶å®ƒæ•°æ®(ServiceManagerçš„cookieä¸ºNULL) tr.cookie = target_node-&gt;cookie; t-&gt;saved_priority = task_nice(current); if (t-&gt;priority &lt; target_node-&gt;min_priority &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) binder_set_nice(t-&gt;priority); else if (!(t-&gt;flags &amp; TF_ONE_WAY) || t-&gt;saved_priority &gt; target_node-&gt;min_priority) binder_set_nice(target_node-&gt;min_priority); **cmd = BR_TRANSACTION;//å°†å‘½ä»¤æ”¹ä¸ºBR_TRANSACTION &#125; else &#123; tr.target.ptr = NULL; tr.cookie = NULL; cmd = BR_REPLY; &#125; // äº¤æ˜“ç  tr.code = t-&gt;code; tr.flags = t-&gt;flags; tr.sender_euid = t-&gt;sender_euid; if (t-&gt;from) &#123; struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk; tr.sender_pid = task_tgid_nr_ns(sender, current-&gt;nsproxy-&gt;pid_ns); &#125; else &#123; tr.sender_pid = 0; &#125; // æ•°æ®å¤§å° tr.data_size = t-&gt;buffer-&gt;data_size; // æ•°æ®ä¸­å¯¹è±¡çš„åç§»æ•°ç»„çš„å¤§å°(å³å¯¹è±¡çš„ä¸ªæ•°) tr.offsets_size = t-&gt;buffer-&gt;offsets_size; // æ•°æ® tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset; // æ•°æ®ä¸­å¯¹è±¡çš„åç§»æ•°ç»„ tr.data.ptr.offsets = tr.data.ptr.buffer + ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *)); // å°†cmdæŒ‡ä»¤å†™å…¥åˆ°ptrï¼Œå³ä¼ é€’åˆ°ç”¨æˆ·ç©ºé—´ if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; // å°†træ•°æ®æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ ptr += sizeof(uint32_t); if (copy_to_user(ptr, &amp;tr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); ... // åˆ é™¤å·²å¤„ç†çš„äº‹åŠ¡ list_del(&amp;t-&gt;work.entry); t-&gt;buffer-&gt;allow_user_free = 1; // è®¾ç½®å›å¤ä¿¡æ¯ if (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) &#123; // è¯¥äº‹åŠ¡ä¼šå‘é€ç»™Service Managerå®ˆæŠ¤è¿›ç¨‹è¿›è¡Œå¤„ç†ã€‚ // Service Managerå¤„ç†ä¹‹åï¼Œè¿˜éœ€è¦ç»™Binderé©±åŠ¨å›å¤å¤„ç†ç»“æœã€‚ // è¿™é‡Œè®¾ç½®Binderé©±åŠ¨å›å¤ä¿¡æ¯ã€‚ t-&gt;to_parent = thread-&gt;transaction_stack; // to_threadè¡¨ç¤ºService Manageråé¦ˆåï¼Œå°†åé¦ˆç»“æœäº¤ç»™å½“å‰threadè¿›è¡Œå¤„ç† t-&gt;to_thread = thread; // transaction_stackäº¤æ˜“æ ˆä¿å­˜å½“å‰äº‹åŠ¡ã€‚ç”¨äºä¹‹å¤„åé¦ˆæ˜¯é’ˆå¯¹å“ªä¸ªäº‹åŠ¡çš„ã€‚ thread-&gt;transaction_stack = t; &#125; else &#123; ... &#125; break; &#125;done: // æ›´æ–°bwr.read_consumedçš„å€¼ *consumed = ptr - buffer; ... return 0;&#125; è¯´æ˜ï¼šServiceManagerè¿›ç¨‹åœ¨è°ƒç”¨wait_event_interruptible_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread))è¿›å…¥ç­‰å¾…ä¹‹åï¼Œè¢«TestServerè¿›ç¨‹å”¤é†’ã€‚å”¤é†’ä¹‹åï¼Œbinder_has_thread_work()ä¸ºtrueï¼Œå› ä¸ºServiceManagerçš„å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—ä¸­æœ‰ä¸ªå¾…å¤„ç†äº‹åŠ¡(å³ï¼ŒTestServeræ·»åŠ æœåŠ¡çš„è¯·æ±‚)ã€‚ (01) è¿›å…¥whileå¾ªç¯åï¼Œé¦–å…ˆå–å‡ºå¾…å¤„ç†äº‹åŠ¡ã€‚ (02) äº‹åŠ¡çš„ç±»å‹æ˜¯BINDER_WORK_TRANSACTIONï¼Œå¾—åˆ°å¯¹åº”çš„binder_transaction*ç±»å‹æŒ‡é’ˆtä¹‹åï¼Œè·³å‡ºswitchè¯­å¥ã€‚å¾ˆæ˜¾ç„¶ï¼Œæ­¤æ—¶tä¸ä¸ºNULLï¼Œå› æ­¤ç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚ä¸‹é¢çš„å·¥ä½œçš„ç›®çš„ï¼Œæ˜¯å°†tä¸­çš„æ•°æ®è½¬ç§»åˆ°trä¸­(træ˜¯äº‹åŠ¡äº¤äº’æ•°æ®åŒ…ç»“æ„ä½“binder_transaction_dataå¯¹åº”çš„æŒ‡é’ˆ)ï¼Œç„¶åå°†æŒ‡ä»¤å’Œtræ•°æ®éƒ½æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ï¼Œè®©ServiceManagerè¯»å–åè¿›è¡Œå¤„ç†ã€‚ Service Managerå®ˆæŠ¤è¿›ç¨‹åœ¨å¤„ç†å®Œäº‹åŠ¡ä¹‹åï¼Œéœ€è¦åé¦ˆç»“æœç»™Binderé©±åŠ¨ã€‚å› æ­¤ï¼Œæ¥ä¸‹æ¥ä¼šè®¾ç½®t-&gt;to_threadå’Œt-&gt;transaction_stackç­‰æˆå‘˜ã€‚æœ€åï¼Œä¿®æ”¹*consumedçš„å€¼ï¼Œå³bwr.read_consumedçš„å€¼ï¼Œè¡¨ç¤ºå¾…è¯»å–å†…å®¹çš„å¤§å°ã€‚ æ‰§è¡Œå®Œbinder_thread_read()ä¹‹åï¼Œå›åˆ°binder_ioctl()ä¸­ï¼Œæ‰§è¡Œcopy_to_user()å°†æ•°æ®æ‹·è´åˆ°ç”¨æˆ·ç©ºé—´ã€‚æ¥ä¸‹æ¥ï¼Œå°±å›åˆ°äº†Service Managerçš„å®ˆæŠ¤è¿›ç¨‹å½“ä¸­ï¼Œå³å›åˆ°binder_loop()ä¸­ã€‚ binder_loop()ä¼šå°†ioctl()åé¦ˆçš„æ•°æ®å‘é€ç»™binder_parse()è¿›è¡Œè§£æã€‚ 123456789101112131415161718192021222324252627int binder_parse(struct binder_state *bs, struct binder_io *bio, uintptr_t ptr, size_t size, binder_handler func)&#123; switch(cmd) &#123; case BR_NOOP: case BR_TRANSACTION: &#123; struct binder_transaction_data *txn = (struct binder_transaction_data *) ptr; if ((end - ptr) &lt; sizeof(*txn)) &#123; ALOGE(\"parse: txn too small!\\n\"); return -1; &#125; binder_dump_txn(txn); if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; struct binder_io reply; int res; bio_init(&amp;reply, rdata, sizeof(rdata), 4); bio_init_from_txn(&amp;msg, txn); res = func(bs, txn, &amp;msg, &amp;reply); binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); &#125; ptr += sizeof(*txn); break; &#125;&#125; é¦–å…ˆä¼šè°ƒç”¨svcmgr_handler()-&gt;do_add_service() 1234567891011121314151617181920212223242526272829int do_add_service(struct binder_state *bs, const uint16_t *s, size_t len, uint32_t handle, uid_t uid, int allow_isolated, pid_t spid)&#123; struct svcinfo *si; si = find_svc(s, len); if (si) &#123; if (si-&gt;handle) &#123; svcinfo_death(bs, si); &#125; si-&gt;handle = handle; &#125; else &#123; si = malloc(sizeof(*si) + (len + 1) * sizeof(uint16_t)); si-&gt;handle = handle; si-&gt;len = len; memcpy(si-&gt;name, s, (len + 1) * sizeof(uint16_t)); si-&gt;name[len] = '\\0'; si-&gt;death.func = (void*) svcinfo_death; si-&gt;death.ptr = si; si-&gt;allow_isolated = allow_isolated; si-&gt;next = svclist; svclist = si; &#125; binder_acquire(bs, handle); binder_link_to_death(bs, handle, &amp;si-&gt;death); return 0;&#125; å¯ä»¥çœ‹åˆ°é¦–å…ˆä¸ºhelloæœåŠ¡æ–°åˆ†é…ä¸€ä¸ªç»“æ„ä½“svcinfoï¼Œç„¶åå°†handleèµ‹å€¼ç»™svcinfoï¼Œè¿™ä¹Ÿæ˜¯ä»¥åæˆ‘ä»¬æŸ¥æ‰¾æœåŠ¡æ‰€å¾—åˆ°çš„handleã€‚ ç„¶åè°ƒåŠ¨äº†binder_acquireã€binder_link_to_deathå‘é€ä¿¡æ¯ç»™é©±åŠ¨ã€‚ [ 38.467270] service_manager (1362, 1362), binder_thread_write : BC_ACQUIRE [ 38.480122] service_manager (1362, 1362), binder_thread_write : BC_REQUEST_DEATH_NOTIFICATION æ¥ç€çœ‹binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res); 1234567891011121314void binder_send_reply(struct binder_state *bs, struct binder_io *reply, binder_uintptr_t buffer_to_free, int status)&#123; data.cmd_free = BC_FREE_BUFFER; data.buffer = buffer_to_free; data.cmd_reply = BC_REPLY; data.txn.target.ptr = 0; data.txn.cookie = 0; data.txn.code = 0; ... binder_write(bs, &amp;data, sizeof(data));&#125; å¯ä»¥çœ‹åˆ°æœ‰BC_FREE_BUFFERã€BC_REPLYï¼Œé€šè¿‡binder_write(bs, &amp;data, sizeof(data))å›å¤BC_REPLYåˆ°é©±åŠ¨ã€‚ é©±åŠ¨å¤„ç†æ¶ˆæ¯è·Ÿä¹‹å‰æµç¨‹ç±»ä¼¼ï¼Œè¿™é‡Œä¸å†åˆ†æã€‚ç®€å•æ€»ç»“ï¼š 1ã€é©±åŠ¨æ¥æ”¶åˆ°BC_REPLYè¯·æ±‚ï¼Œä¼šæ–°å»ºä¸€ä¸ªå¾…å¤„ç†äº‹åŠ¡tï¼ˆTestServerå¤„ç†ï¼‰å’Œå¾…å®Œæˆçš„å·¥ä½œtcompleteï¼ˆservice_managerå¤„ç†ï¼‰ 2ã€ç„¶åå”¤é†’TestServerå¤„ç†BC_REPLYè¯·æ±‚ è‡³æ­¤ï¼Œå·²ç»æˆåŠŸæ·»åŠ Hello Service svcmgr: add_service(â€˜helloâ€™), handle = 1 ï¼ˆ2ï¼‰ã€Binderç³»ç»Ÿé©±åŠ¨æƒ…æ™¯åˆ†æâ€“TestClentè·å–â€Helloâ€æœåŠ¡è¿‡ç¨‹ 2.0ã€æ„é€ æ•°æ® 2.1ã€å‘é€æ•°æ®ç»™ServiceManagerbwråˆå§‹åŒ–å®Œæˆä¹‹åï¼Œè°ƒç”¨ioctl(,BINDER_WRITE_READ,)å’ŒBinderé©±åŠ¨è¿›è¡Œäº¤äº’ã€‚ 12345678910111213141516171819202122232425262728293031static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123; int ret; struct binder_proc *proc = filp-&gt;private_data; struct binder_thread *thread; unsigned int size = _IOC_SIZE(cmd); void __user *ubuf = (void __user *)arg; switch (cmd) &#123; case BINDER_WRITE_READ: &#123; struct binder_write_read bwr; // å°†binder_write_readä»\"ç”¨æˆ·ç©ºé—´\" æ‹·è´åˆ° \"å†…æ ¸ç©ºé—´\" if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; &#125; // å¦‚æœwrite_size&gt;0ï¼Œåˆ™è¿›è¡Œå†™æ“ä½œ if (bwr.write_size &gt; 0) &#123; ret = binder_thread_write(proc, thread, (void __user *)bwr.write_buffer, bwr.write_size, &amp;bwr.write_consumed); &#125; // å¦‚æœread_size&gt;0ï¼Œåˆ™è¿›è¡Œè¯»æ“ä½œ if (bwr.read_size &gt; 0) &#123; ret = binder_thread_read(proc, thread, (void __user *)bwr.read_buffer, bwr.read_size, &amp;bwr.read_consumed, filp-&gt;f_flags &amp; O_NONBLOCK); &#125; if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123; ret = -EFAULT; goto err; &#125; break; &#125;&#125; é¦–å…ˆï¼Œä¼šå°†binder_write_readä»ç”¨æˆ·ç©ºé—´æ‹·è´åˆ°å†…æ ¸ç©ºé—´ä¹‹åã€‚æ‹·è´ä¹‹åï¼Œè¯»å–å‡ºæ¥çš„bwr.write_sizeå’Œbwr.read_sizeéƒ½&gt;0ï¼Œå› æ­¤å…ˆå†™åè¯»ã€‚å³ï¼Œå…ˆæ‰§è¡Œbinder_thread_write()ï¼Œç„¶åæ‰§è¡Œbinder_thread_read()ã€‚ 2.2ã€binder_thread_write()å¤„ç†æ•°æ®1234567891011121314151617181920212223242526272829303132333435int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // è¯»å–binder_write_read.write_bufferä¸­çš„å†…å®¹ã€‚ // æ¯æ¬¡è¯»å–32bit(å³4ä¸ªå­—èŠ‚) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // ä»ç”¨æˆ·ç©ºé—´è¯»å–32bitåˆ°å†…æ ¸ä¸­ï¼Œå¹¶èµ‹å€¼ç»™cmdã€‚ if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) &#123; ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; // æ›´æ–°bwr.write_consumedçš„å€¼ *consumed = ptr - buffer; &#125; return 0;&#125; è¯´æ˜ï¼šMediaPlayerå‘é€çš„æŒ‡ä»¤æ˜¯BC_TRANSACTIONï¼Œè¿™é‡Œåªå…³å¿ƒä¸BC_TRANSACTIONç›¸å…³çš„éƒ¨åˆ†ã€‚åœ¨é€šè¿‡copy_from_user()å°†æ•°æ®æ‹·è´ä»ç”¨æˆ·ç©ºé—´æ‹·è´åˆ°å†…æ ¸ç©ºé—´ä¹‹åï¼Œå°±è°ƒç”¨binder_transaction()è¿›è¡Œå¤„ç†ã€‚ 2.3ã€Binderé©±åŠ¨ä¸­binder_transaction()çš„æºç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) &#123; ... &#125; else &#123; if (tr-&gt;target.handle) &#123; ... &#125; else &#123; // è¯¥getServiceæ˜¯ä»ServiceManagerä¸­è·å–MediaPlayerï¼› // å› æ­¤äº‹åŠ¡ç›®æ ‡å¯¹è±¡æ˜¯ServiceManagerçš„binderå®ä½“ã€‚ target_node = binder_context_mgr_node; ... &#125; ... // è®¾ç½®å¤„ç†äº‹åŠ¡çš„ç›®æ ‡è¿›ç¨‹ target_proc = target_node-&gt;proc; ... &#125; if (target_thread) &#123; ... &#125; else &#123; target_list = &amp;target_proc-&gt;todo; target_wait = &amp;target_proc-&gt;wait; &#125; ... // åˆ†é…ä¸€ä¸ªå¾…å¤„ç†çš„äº‹åŠ¡tï¼Œtæ˜¯binderäº‹åŠ¡(binder_transactionå¯¹è±¡) t = kzalloc(sizeof(*t), GFP_KERNEL); ... // åˆ†é…ä¸€ä¸ªå¾…å®Œæˆçš„å·¥ä½œtcompleteï¼Œtcompleteæ˜¯binder_workå¯¹è±¡ã€‚ tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); ... t-&gt;debug_id = ++binder_last_id; ... // è®¾ç½®fromï¼Œè¡¨ç¤ºè¯¥äº‹åŠ¡æ˜¯MediaPlayerçº¿ç¨‹å‘èµ·çš„ if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // ä¸‹é¢çš„ä¸€äº›èµ‹å€¼æ˜¯åˆå§‹åŒ–äº‹åŠ¡t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // äº‹åŠ¡å°†äº¤ç»™target_procè¿›ç¨‹è¿›è¡Œå¤„ç† t-&gt;to_proc = target_proc; // äº‹åŠ¡å°†äº¤ç»™target_threadçº¿ç¨‹è¿›è¡Œå¤„ç† t-&gt;to_thread = target_thread; // äº‹åŠ¡ç¼–ç  t-&gt;code = tr-&gt;code; // äº‹åŠ¡æ ‡å¿— t-&gt;flags = tr-&gt;flags; // äº‹åŠ¡ä¼˜å…ˆçº§ t-&gt;priority = task_nice(current); ... // åˆ†é…ç©ºé—´ t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); ... t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // ä¿å­˜äº‹åŠ¡ t-&gt;buffer-&gt;transaction = t; // ä¿å­˜äº‹åŠ¡çš„ç›®æ ‡å¯¹è±¡(å³å¤„ç†è¯¥äº‹åŠ¡çš„binderå¯¹è±¡) t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // å°†\"ç”¨æˆ·ç©ºé—´çš„æ•°æ®\"æ‹·è´åˆ°å†…æ ¸ä¸­ // tr-&gt;data.ptr.bufferå°±æ˜¯ç”¨æˆ·ç©ºé—´æ•°æ®çš„èµ·å§‹åœ°å€ï¼Œtr-&gt;data_sizeå°±æ˜¯æ•°æ®å¤§å° if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; ... &#125; // å°†\"ç”¨æˆ·ç©ºé—´çš„æ•°æ®ä¸­æ‰€å«å¯¹è±¡çš„åç§»åœ°å€\"æ‹·è´åˆ°å†…æ ¸ä¸­ // MediaPlayerä¸­ä¸åŒ…å«å¯¹è±¡, offp=null if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; ... &#125; ... // MediaPlayerä¸­ä¸åŒ…å«å¯¹è±¡, off_endä¸ºnull off_end = (void *)offp + tr-&gt;offsets_size; // MediaPlayerä¸­ä¸åŒ…å«å¯¹è±¡, offp=off_end for (; offp &lt; off_end; offp++) &#123; ... &#125; if (reply) &#123; .. &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; BUG_ON(t-&gt;buffer-&gt;async_transaction != 0); t-&gt;need_reply = 1; t-&gt;from_parent = thread-&gt;transaction_stack; // å°†å½“å‰äº‹åŠ¡æ·»åŠ åˆ°å½“å‰çº¿ç¨‹çš„äº‹åŠ¡æ ˆä¸­ thread-&gt;transaction_stack = t; &#125; else &#123; ... &#125; // è®¾ç½®äº‹åŠ¡çš„ç±»å‹ä¸ºBINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // å°†äº‹åŠ¡æ·»åŠ åˆ°target_listé˜Ÿåˆ—ä¸­ï¼Œå³target_listçš„å¾…å¤„ç†äº‹åŠ¡ä¸­ list_add_tail(&amp;t-&gt;work.entry, target_list); // è®¾ç½®å¾…å®Œæˆå·¥ä½œçš„ç±»å‹ä¸ºBINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // å°†å¾…å®Œæˆå·¥ä½œæ·»åŠ åˆ°thread-&gt;todoé˜Ÿåˆ—ä¸­ï¼Œå³å½“å‰çº¿ç¨‹çš„å¾…å®Œæˆå·¥ä½œä¸­ã€‚ list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // å”¤é†’ç›®æ ‡è¿›ç¨‹ if (target_wait) wake_up_interruptible(target_wait); return; ...&#125; è¯´æ˜ï¼šå‚æ•°reply=0ï¼Œè¡¨æ˜è¿™æ˜¯ä¸ªè¯·æ±‚äº‹åŠ¡ï¼Œè€Œä¸æ˜¯åé¦ˆã€‚binder_transactionæ–°å»ºä¼šæ–°å»ºâ€ä¸€ä¸ªå¾…å¤„ç†äº‹åŠ¡tâ€å’Œâ€å¾…å®Œæˆçš„å·¥ä½œtcompleteâ€ï¼Œå¹¶æ ¹æ®è¯·æ±‚çš„æ•°æ®å¯¹å®ƒä»¬è¿›è¡Œåˆå§‹åŒ–ã€‚ (01) TestClentçš„getServiceè¯·æ±‚æ˜¯æäº¤ç»™ServiceManagerè¿›è¡Œå¤„ç†çš„ï¼Œå› æ­¤ï¼Œâ€å¾…å¤„ç†äº‹åŠ¡tâ€ä¼šè¢«æ·»åŠ åˆ°ServiceManagerçš„å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—ä¸­ã€‚æ­¤æ—¶çš„target_threadæ˜¯ServiceManagerå¯¹åº”çš„çº¿ç¨‹ï¼Œè€Œtarget_procåˆ™æ˜¯ServiceManagerå¯¹åº”çš„è¿›ç¨‹ä¸Šä¸‹æ–‡ç¯å¢ƒã€‚ (02) æ­¤æ—¶ï¼ŒBinderé©±åŠ¨å·²ç»æ”¶åˆ°äº†TestClentçš„getServiceè¯·æ±‚ï¼›äºæ˜¯ï¼Œå°†ä¸€ä¸ªBINDER_WORK_TRANSACTION_COMPLETEç±»å‹çš„â€å¾…å®Œæˆå·¥ä½œtcompleteâ€æ·»åŠ åˆ°å½“å‰çº¿ç¨‹(å³ï¼ŒTestClentçº¿ç¨‹)çš„å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—ä¸­ã€‚ç›®çš„æ˜¯å‘Šè¯‰TestClentï¼ŒBinderé©±åŠ¨å·²ç»æ”¶åˆ°å®ƒçš„getServiceè¯·æ±‚äº†ã€‚ (03) æœ€åï¼Œè°ƒç”¨wake_up_interruptible(target_wait)å°†ServiceManagerå”¤é†’ã€‚ æ¥ä¸‹æ¥ï¼Œè¿˜æ˜¯å…ˆåˆ†æå®ŒTestClentçº¿ç¨‹ï¼Œå†çœ‹ServiceManagerè¢«å”¤é†’ååšäº†äº›ä»€ä¹ˆã€‚ binder_transaction()æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œå°±ä¼šè¿”å›åˆ°binder_thread_write()ä¸­ã€‚binder_thread_write()æ›´æ–°bwr.write_consumedçš„å€¼åï¼Œå°±è¿”å›åˆ°binder_ioctl()ç»§ç»­æ‰§è¡Œâ€è¯»â€åŠ¨ä½œã€‚å³æ‰§è¡Œbinder_thread_read()ã€‚ 2.4ã€Binderé©±åŠ¨ä¸­binder_thread_read()çš„æºç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687static int binder_thread_read(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed, int non_block)&#123; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; int ret = 0; int wait_for_proc_work; // å¦‚æœ*consumed=0ï¼Œåˆ™å†™å…¥BR_NOOPåˆ°ç”¨æˆ·ä¼ è¿›æ¥çš„bwr.read_bufferç¼“å­˜åŒº if (*consumed == 0) &#123; if (put_user(BR_NOOP, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); &#125;retry: // ç­‰å¾…procè¿›ç¨‹çš„äº‹åŠ¡æ ‡è®°ã€‚ // å½“çº¿ç¨‹çš„äº‹åŠ¡æ ˆä¸ºç©º å¹¶ä¸” å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œè¯¥æ ‡è®°ä½trueã€‚ wait_for_proc_work = thread-&gt;transaction_stack == NULL &amp;&amp; list_empty(&amp;thread-&gt;todo); ... if (wait_for_proc_work) &#123; ... &#125; else &#123; if (non_block) &#123; ... &#125; else ret = wait_event_interruptible(thread-&gt;wait, binder_has_thread_work(thread)); &#125; ... while (1) &#123; uint32_t cmd; struct binder_transaction_data tr; struct binder_work *w; struct binder_transaction *t = NULL; // å¦‚æœå½“å‰çº¿ç¨‹çš„\"å¾…å®Œæˆå·¥ä½œ\"ä¸ä¸ºç©ºï¼Œåˆ™å–å‡ºå¾…å®Œæˆå·¥ä½œã€‚ if (!list_empty(&amp;thread-&gt;todo)) w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry); else if (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) ... else &#123; if (ptr - buffer == 4 &amp;&amp; !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN)) /* no data added */ goto retry; break; &#125; ... switch (w-&gt;type) &#123; ... case BINDER_WORK_TRANSACTION_COMPLETE: &#123; cmd = BR_TRANSACTION_COMPLETE; // å°†BR_TRANSACTION_COMPLETEå†™å…¥åˆ°ç”¨æˆ·ç¼“å†²ç©ºé—´ä¸­ if (put_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... // å¾…å®Œæˆäº‹åŠ¡å·²ç»å¤„ç†å®Œæ¯•ï¼Œå°†å…¶ä»å¾…å®Œæˆäº‹åŠ¡é˜Ÿåˆ—ä¸­åˆ é™¤ã€‚ list_del(&amp;w-&gt;entry); kfree(w); binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE); &#125; break; ... &#125; if (!t) continue; ... &#125; ... // æ›´æ–°bwr.read_consumedçš„å€¼ *consumed = ptr - buffer; ... return 0;&#125; è¯´æ˜ï¼š (01) bwr.read_consumed=0ï¼Œå³if (*consumed == 0)ä¸ºtrueã€‚å› æ­¤ï¼Œä¼šå°†BR_NOOPå†™å…¥åˆ°bwr.read_bufferä¸­ã€‚ (02) thread-&gt;transaction_stackä¸ä¸ºç©ºï¼Œthread-&gt;todoä¹Ÿä¸ä¸ºç©ºã€‚å› ä¸ºï¼Œå‰é¢åœ¨binder_transaction()ä¸­æœ‰å°†ä¸€ä¸ªBINDER_WORK_TRANSACTION_COMPLETEç±»å‹çš„å¾…å®Œæˆå·¥ä½œæ·»åŠ åˆ°threadçš„å¾…å®Œæˆå·¥ä½œé˜Ÿåˆ—ä¸­ã€‚å› æ­¤ï¼Œwait_for_proc_workä¸ºfalseã€‚ (03) binder_has_thread_work(thread)ä¸ºtrueã€‚å› æ­¤ï¼Œåœ¨è°ƒç”¨wait_event_interruptible()æ—¶ï¼Œä¸ä¼šè¿›å…¥ç­‰å¾…çŠ¶æ€ï¼Œè€Œæ˜¯ç»§ç»­è¿è¡Œã€‚ (04) è¿›å…¥whileå¾ªç¯åï¼Œé€šè¿‡list_first_entry()å–å‡ºå¾…å®Œæˆå·¥ä½œwã€‚wçš„ç±»å‹w-&gt;type=BINDER_WORK_TRANSACTION_COMPLETEï¼Œè¿›å…¥åˆ°å¯¹åº”çš„switchåˆ†æ”¯ã€‚éšåï¼Œå°†BR_TRANSACTION_COMPLETEå†™å…¥åˆ°bwr.read_bufferä¸­ã€‚æ­¤æ—¶ï¼Œå¾…å¤„ç†å·¥ä½œå·²ç»å®Œæˆï¼Œå°†å…¶ä»å½“å‰çº¿ç¨‹çš„å¾…å¤„ç†å·¥ä½œé˜Ÿåˆ—ä¸­åˆ é™¤ã€‚ (05) æœ€åï¼Œæ›´æ–°bwr.read_consumedçš„å€¼ã€‚ ç»è¿‡binder_thread_read()å¤„ç†ä¹‹åï¼Œbwr.read_bufferä¸­åŒ…å«äº†ä¸¤ä¸ªæŒ‡ä»¤ï¼šBR_NOOPå’ŒBR_TRANSACTION_COMPLETEã€‚ 2.5ã€ServiceManagerå¤„ç†getServiceè¯·æ±‚ä¸‹é¢çœ‹çœ‹ServiceManagerè¢«å”¤é†’ä¹‹åï¼Œæ˜¯å¦‚ä½•å¤„ç†getServiceè¯·æ±‚çš„ 12345678910111213141516171819202122int binder_parse(struct binder_state *bs, struct binder_io *bio, uint32_t *ptr, uint32_t size, binder_handler func)&#123; while (ptr &lt; end) &#123; case BR_TRANSACTION: &#123; struct binder_txn *txn = (void *) ptr; ... if (func) &#123; unsigned rdata[256/4]; struct binder_io msg; // ç”¨äºä¿å­˜&quot;Binderé©±åŠ¨åé¦ˆçš„ä¿¡æ¯&quot; struct binder_io reply; // ç”¨æ¥ä¿å­˜&quot;å›å¤ç»™Binderé©±åŠ¨çš„ä¿¡æ¯&quot; int res; // åˆå§‹åŒ–reply bio_init(&amp;reply, rdata, sizeof(rdata), 4); // æ ¹æ®txt(Binderé©±åŠ¨åé¦ˆçš„ä¿¡æ¯)åˆå§‹åŒ–msg bio_init_from_txn(&amp;msg, txn); // æ¶ˆæ¯å¤„ç† res = func(bs, txn, &amp;msg, &amp;reply); // åé¦ˆæ¶ˆæ¯ç»™Binderé©±åŠ¨ã€‚ binder_send_reply(bs, &amp;reply, txn-&gt;data, res);&#125; binder_send_reply(bs, &amp;reply, txn-&gt;data, res);-&gt;binder_write() 123456789101112131415161718binder_write()int binder_write(struct binder_state *bs, void *data, unsigned len)&#123; struct binder_write_read bwr; int res; bwr.write_size = len; bwr.write_consumed = 0; bwr.write_buffer = (unsigned) data; bwr.read_size = 0; bwr.read_consumed = 0; bwr.read_buffer = 0; res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); if (res &lt; 0) &#123; fprintf(stderr,\"binder_write: ioctl failed (%s)\\n\", strerror(errno)); &#125; return res;&#125; è¯´æ˜ï¼šbinder_write()ä¼šå°†æ•°æ®å°è£…åˆ°binder_write_readçš„å˜é‡bwrä¸­ï¼›å…¶ä¸­ï¼Œbwr.read_size=0ï¼Œè€Œbwr.write_size&gt;0ã€‚æ¥ç€ï¼Œä¾¿é€šè¿‡ioctl(,BINDER_WRITE_READ,)å’ŒBinderé©±åŠ¨äº¤äº’ï¼Œå°†æ•°æ®åé¦ˆç»™Binderé©±åŠ¨ã€‚ å†æ¬¡å›åˆ°Binderé©±åŠ¨çš„binder_ioctl()å¯¹åº”çš„BINDER_WRITE_READåˆ†æ”¯ä¸­ã€‚æ­¤æ—¶ï¼Œç”±äºbwr.read_size=0ï¼Œè€Œbwr.write_size&gt;0ï¼›å› æ­¤ï¼ŒBinderé©±åŠ¨åªè°ƒç”¨binder_thread_writeè¿›è¡Œå†™æ“ä½œï¼Œè€Œä¸ä¼šè¿›è¡Œè¯»ã€‚ è¿”å›æ•°æ®ï¼š handle = 1 ä»£è¡¨ç¬¬ä¸€ä¸ª 2.6ã€Binderé©±åŠ¨ä¸­å¤„ç†ServiceManagerè¿”å›æ•°æ®12345678910111213141516171819202122232425262728293031323334353637int binder_thread_write(struct binder_proc *proc, struct binder_thread *thread, void __user *buffer, int size, signed long *consumed)&#123; uint32_t cmd; void __user *ptr = buffer + *consumed; void __user *end = buffer + size; // è¯»å–binder_write_read.write_bufferä¸­çš„å†…å®¹ã€‚ // æ¯æ¬¡è¯»å–32bit(å³4ä¸ªå­—èŠ‚) while (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) &#123; // ä»ç”¨æˆ·ç©ºé—´è¯»å–32bitåˆ°å†…æ ¸ä¸­ï¼Œå¹¶èµ‹å€¼ç»™cmdã€‚ if (get_user(cmd, (uint32_t __user *)ptr)) return -EFAULT; ptr += sizeof(uint32_t); ... switch (cmd) &#123; case BC_FREE_BUFFER: ... case BC_TRANSACTION: case BC_REPLY: &#123; struct binder_transaction_data tr; if (copy_from_user(&amp;tr, ptr, sizeof(tr))) return -EFAULT; ptr += sizeof(tr); binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY); break; &#125; ... &#125; // æ›´æ–°bwr.write_consumedçš„å€¼ *consumed = ptr - buffer; &#125; return 0;&#125; binder_thread_write()è¿›å…¥BC_REPLYä¹‹åï¼Œä¼šå°†æ•°æ®æ‹·è´åˆ°å†…æ ¸ç©ºé—´ï¼Œç„¶åè°ƒç”¨binder_transaction()è¿›è¡Œå¤„ç† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170static void binder_transaction(struct binder_proc *proc, struct binder_thread *thread, struct binder_transaction_data *tr, int reply)&#123; struct binder_transaction *t; struct binder_work *tcomplete; size_t *offp, *off_end; struct binder_proc *target_proc; struct binder_thread *target_thread = NULL; struct binder_node *target_node = NULL; struct list_head *target_list; wait_queue_head_t *target_wait; struct binder_transaction *in_reply_to = NULL; struct binder_transaction_log_entry *e; uint32_t return_error; ... if (reply) &#123; // äº‹åŠ¡æ ˆ in_reply_to = thread-&gt;transaction_stack; ... // è®¾ç½®ä¼˜å…ˆçº§ binder_set_nice(in_reply_to-&gt;saved_priority); ... thread-&gt;transaction_stack = in_reply_to-&gt;to_parent; // å‘èµ·è¯·æ±‚çš„çº¿ç¨‹ï¼Œå³MediaPlayeræ‰€åœ¨çº¿ç¨‹ã€‚ // fromçš„å€¼ï¼Œæ˜¯MediaPlayerå‘èµ·è¯·æ±‚æ—¶åœ¨binder_transaction()ä¸­èµ‹å€¼çš„ã€‚ target_thread = in_reply_to-&gt;from; ... // MediaPlayerå¯¹åº”çš„è¿›ç¨‹ target_proc = target_thread-&gt;proc; &#125; else &#123; ... &#125; if (target_thread) &#123; e-&gt;to_thread = target_thread-&gt;pid; target_list = &amp;target_thread-&gt;todo; target_wait = &amp;target_thread-&gt;wait; &#125; else &#123; ... &#125; e-&gt;to_proc = target_proc-&gt;pid; // åˆ†é…ä¸€ä¸ªå¾…å¤„ç†çš„äº‹åŠ¡tï¼Œtæ˜¯binderäº‹åŠ¡(binder_transactionå¯¹è±¡) t = kzalloc(sizeof(*t), GFP_KERNEL); if (t == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_alloc_t_failed; &#125; // åˆ†é…ä¸€ä¸ªå¾…å®Œæˆçš„å·¥ä½œtcompleteï¼Œtcompleteæ˜¯binder_workå¯¹è±¡ã€‚ tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL); if (tcomplete == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_alloc_tcomplete_failed; &#125; binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE); t-&gt;debug_id = ++binder_last_id; e-&gt;debug_id = t-&gt;debug_id; if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY)) t-&gt;from = thread; else t-&gt;from = NULL; // ä¸‹é¢çš„ä¸€äº›èµ‹å€¼æ˜¯åˆå§‹åŒ–äº‹åŠ¡t t-&gt;sender_euid = proc-&gt;tsk-&gt;cred-&gt;euid; // äº‹åŠ¡å°†äº¤ç»™target_procè¿›ç¨‹è¿›è¡Œå¤„ç† t-&gt;to_proc = target_proc; // äº‹åŠ¡å°†äº¤ç»™target_threadçº¿ç¨‹è¿›è¡Œå¤„ç† t-&gt;to_thread = target_thread; // äº‹åŠ¡ç¼–ç  t-&gt;code = tr-&gt;code; // äº‹åŠ¡æ ‡å¿— t-&gt;flags = tr-&gt;flags; // äº‹åŠ¡ä¼˜å…ˆçº§ t-&gt;priority = task_nice(current); // åˆ†é…ç©ºé—´ t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size, tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY)); if (t-&gt;buffer == NULL) &#123; return_error = BR_FAILED_REPLY; goto err_binder_alloc_buf_failed; &#125; t-&gt;buffer-&gt;allow_user_free = 0; t-&gt;buffer-&gt;debug_id = t-&gt;debug_id; // ä¿å­˜äº‹åŠ¡ t-&gt;buffer-&gt;transaction = t; // target_nodeä¸ºNULL t-&gt;buffer-&gt;target_node = target_node; trace_binder_transaction_alloc_buf(t-&gt;buffer); if (target_node) binder_inc_node(target_node, 1, 0, NULL); offp = (size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *))); // å°†\"ç”¨æˆ·ä¼ å…¥çš„æ•°æ®\"ä¿å­˜åˆ°äº‹åŠ¡ä¸­ if (copy_from_user(t-&gt;buffer-&gt;data, tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123; ... &#125; // å°†\"ç”¨æˆ·ä¼ å…¥çš„æ•°æ®åç§»åœ°å€\"ä¿å­˜åˆ°äº‹åŠ¡ä¸­ if (copy_from_user(offp, tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123; ... &#125; ... off_end = (void *)offp + tr-&gt;offsets_size; // å°†flat_binder_objectå¯¹è±¡è¯»å–å‡ºæ¥ï¼Œ // è¿™é‡Œå°±æ˜¯Service Managerä¸­åé¦ˆçš„MediaPlayerServiceå¯¹è±¡ã€‚ for (; offp &lt; off_end; offp++) &#123; struct flat_binder_object *fp; ... fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp); switch (fp-&gt;type) &#123; ... case BINDER_TYPE_HANDLE: case BINDER_TYPE_WEAK_HANDLE: &#123; // æ ¹æ®handleè·å–å¯¹åº”çš„Binderå¼•ç”¨ï¼Œå³å¾—åˆ°MediaPlayerServiceçš„Binderå¼•ç”¨ struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle); if (ref == NULL) &#123; ... &#125; // ref-&gt;node-&gt;procæ˜¯MediaPlayerServiceçš„è¿›ç¨‹ä¸Šä¸‹æ–‡ç¯å¢ƒï¼Œ // è€Œtarget_procæ˜¯MediaPlayerçš„è¿›ç¨‹ä¸Šä¸‹æ–‡ç¯å¢ƒ if (ref-&gt;node-&gt;proc == target_proc) &#123; ... &#125; else &#123; struct binder_ref *new_ref; // åœ¨MediaPlayerè¿›ç¨‹ä¸­å¼•ç”¨\"MediaPlayerService\"ã€‚ // è¡¨ç°ä¸ºï¼Œæ‰§è¡Œbinder_get_ref_for_node()ä¼šï¼Œä¼šå…ˆåœ¨MediaPlayerè¿›ç¨‹ä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨MediaPlayerServiceå¯¹åº”çš„Binderå¼•ç”¨ï¼› // å¾ˆæ˜¾ç„¶æ˜¯ä¸å­˜åœ¨çš„ã€‚äºæ˜¯ï¼Œå¹¶æ–°å»ºMediaPlayerServiceå¯¹åº”çš„Binderå¼•ç”¨ï¼Œå¹¶å°†å…¶æ·»åŠ åˆ°MediaPlayerçš„Binderå¼•ç”¨çº¢é»‘æ ‘ä¸­ã€‚ new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node); if (new_ref == NULL) &#123; ... &#125; // å°†new_refçš„å¼•ç”¨æè¿°å¤åˆ¶ç»™fp-&gt;handleã€‚ fp-&gt;handle = new_ref-&gt;desc; binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL); ... &#125; &#125; break; &#125; &#125; if (reply) &#123; binder_pop_transaction(target_thread, in_reply_to); &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123; ... &#125; else &#123; ... &#125; // è®¾ç½®äº‹åŠ¡çš„ç±»å‹ä¸ºBINDER_WORK_TRANSACTION t-&gt;work.type = BINDER_WORK_TRANSACTION; // å°†äº‹åŠ¡æ·»åŠ åˆ°target_listé˜Ÿåˆ—ä¸­ï¼Œå³target_listçš„å¾…å¤„ç†äº‹åŠ¡ä¸­ list_add_tail(&amp;t-&gt;work.entry, target_list); // è®¾ç½®å¾…å®Œæˆå·¥ä½œçš„ç±»å‹ä¸ºBINDER_WORK_TRANSACTION_COMPLETE tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE; // å°†å¾…å®Œæˆå·¥ä½œæ·»åŠ åˆ°thread-&gt;todoé˜Ÿåˆ—ä¸­ï¼Œå³å½“å‰çº¿ç¨‹çš„å¾…å®Œæˆå·¥ä½œä¸­ã€‚ list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo); // å”¤é†’ç›®æ ‡è¿›ç¨‹ if (target_wait) wake_up_interruptible(target_wait); return; ...&#125; è¯´æ˜ï¼šreply=1ï¼Œè¿™é‡Œåªå…³æ³¨replyéƒ¨åˆ†ã€‚ (01) æ­¤åé¦ˆæœ€ç»ˆæ˜¯è¦å›å¤ç»™TestClientçš„ã€‚å› æ­¤ï¼Œtarget_threadè¢«èµ‹å€¼ä¸ºTestServeræ‰€åœ¨çš„çº¿ç¨‹ï¼Œtarget_procåˆ™æ˜¯TestClientå¯¹åº”çš„è¿›ç¨‹ï¼Œtarget_nodeä¸ºnullã€‚ (02) è¿™é‡Œï¼Œå…ˆçœ‹çœ‹forå¾ªç¯é‡Œé¢çš„å†…å®¹ï¼Œå–å‡ºBR_REPLYæŒ‡ä»¤æ‰€å‘é€çš„æ•°æ®ï¼Œç„¶åè·å–æ•°æ®ä¸­çš„flat_binder_objectå˜é‡fpã€‚å› ä¸ºfp-&gt;typeä¸ºBINDER_TYPE_HANDLEï¼Œå› æ­¤è¿›å…¥BINDER_TYPE_HANDLEå¯¹åº”çš„åˆ†æ”¯ã€‚æ¥ç€ï¼Œé€šè¿‡binder_get_ref()è·å–Hello Serviceå¯¹åº”çš„Binderå¼•ç”¨ï¼›å¾ˆæ˜æ˜¾ï¼Œèƒ½å¤Ÿæ­£å¸¸è·å–åˆ°Hello Serviceçš„Binderå¼•ç”¨ã€‚å› ä¸ºåœ¨Hello Serviceè°ƒç”¨addServiceè¯·æ±‚æ—¶ï¼Œå·²ç»åˆ›å»ºäº†å®ƒçš„Binderå¼•ç”¨ã€‚ binder_get_ref_for_node()çš„ä½œç”¨æ˜¯åœ¨TestClentè¿›ç¨‹ä¸Šä¸‹æ–‡ä¸­æ·»åŠ â€TestServerå¯¹åº”çš„Binderå¼•ç”¨â€ã€‚è¿™æ ·ï¼Œåé¢å°±å¯ä»¥æ ¹æ®è¯¥Binderå¼•ç”¨ä¸€æ­¥æ­¥çš„è·å–TestServerå¯¹è±¡ã€‚ æœ€åï¼Œå°†Binderå¼•ç”¨çš„æè¿°èµ‹å€¼ç»™fp-&gt;handleã€‚ (03) æ­¤æ—¶ï¼ŒService Managerå·²ç»å¤„ç†äº†getServiceè¯·æ±‚ã€‚ä¾¿è°ƒç”¨binder_pop_transaction(target_thread, in_reply_to)å°†äº‹åŠ¡ä»â€target_threadçš„äº‹åŠ¡æ ˆâ€ä¸­åˆ é™¤ï¼Œå³ä»MediaPlayerçº¿ç¨‹çš„äº‹åŠ¡æ ˆä¸­åˆ é™¤è¯¥äº‹åŠ¡ã€‚ (04) æ–°å»ºçš„â€å¾…å¤„ç†äº‹åŠ¡tâ€çš„typeä¸ºè®¾ä¸ºBINDER_WORK_TRANSACTIONåï¼Œä¼šè¢«æ·»åŠ åˆ°MediaPlayerçš„å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—ä¸­ã€‚ (05) æ­¤æ—¶ï¼ŒService Managerå·²ç»å¤„ç†äº†getServiceè¯·æ±‚ï¼Œè€ŒBinderé©±åŠ¨åœ¨ç­‰å¾…å®ƒçš„å›å¤ã€‚äºæ˜¯ï¼Œå°†ä¸€ä¸ªBINDER_WORK_TRANSACTION_COMPLETEç±»å‹çš„â€å¾…å®Œæˆå·¥ä½œtcompleteâ€(ä½œä¸ºå›å¤)æ·»åŠ åˆ°å½“å‰çº¿ç¨‹(å³ï¼ŒService Managerçº¿ç¨‹)çš„å¾…å¤„ç†äº‹åŠ¡é˜Ÿåˆ—ä¸­ã€‚ (06) æœ€åï¼Œè°ƒç”¨wake_up_interruptible()å”¤é†’TestServerã€‚TestServerè¢«å”¤é†’åï¼Œä¼šå¯¹äº‹åŠ¡BINDER_WORK_TRANSACTIONè¿›è¡Œå¤„ç†ã€‚ OKï¼Œåˆ°ç°åœ¨ä¸ºæ­¢ï¼Œè¿˜æœ‰ä¸¤ä¸ªå¾…å¤„ç†äº‹åŠ¡ï¼š(01) ServiceManagerå¾…å¤„ç†äº‹åŠ¡åˆ—è¡¨ä¸­æœ‰ä¸ªBINDER_WORK_TRANSACTION_COMPLETEç±»å‹çš„äº‹åŠ¡ (02) TestServerå¾…å¤„ç†äº‹åŠ¡åˆ—è¡¨ä¸­æœ‰ä¸ªBINDER_WORK_TRANSACTIONäº‹åŠ¡ã€‚ 2.7. Testclientè·å–handle ï¼ˆ3ï¼‰ã€Binderç³»ç»Ÿé©±åŠ¨æƒ…æ™¯åˆ†æâ€“TestClentä½¿ç”¨â€Helloâ€æœåŠ¡è¿‡ç¨‹æ„é€ æ•°æ®å‘é€æ•°æ®â€weidongshanâ€ å››ã€Android Binderç³»ç»Ÿ-Nativeå±‚å‰é¢æˆ‘ä»¬åˆ†æå†…æ ¸é©±åŠ¨Binderä½¿ç”¨è¿‡ç¨‹ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œbinderç³»ç»Ÿåœ¨å†…æ ¸èƒ½æ­£å¸¸å®ŒæˆIPCé€šä¿¡ï¼Œæ¥ä¸‹æ¥åˆ†æAndroid framworkå±‚ï¼Œæœ€åæ˜¯Appå±‚ã€‚ Frameworkæ˜¯ä¸€ä¸ªä¸­é—´å±‚ï¼Œå®ƒå¯¹æ¥äº†åº•å±‚å®ç°ï¼Œå°è£…äº†å¤æ‚çš„å†…éƒ¨é€»è¾‘ï¼Œå¹¶æä¾›ä¾›å¤–éƒ¨ä½¿ç”¨çš„æ¥å£ã€‚Frameworkå±‚æ˜¯åº”ç”¨ç¨‹åºå¼€å‘çš„åŸºç¡€ã€‚ Binder Frameworkå±‚åˆ†ä¸ºC++å’ŒJavaä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸ºäº†è¾¾åˆ°åŠŸèƒ½çš„å¤ç”¨ï¼Œä¸­é—´é€šè¿‡JNIè¿›è¡Œè¡”æ¥ã€‚ Binder Frameworkçš„C++éƒ¨åˆ†ï¼Œå¤´æ–‡ä»¶ä½äºè¿™ä¸ªè·¯å¾„ï¼š/frameworks/native/include/binder/ï¼Œå®ç°ä½äºè¿™ä¸ªè·¯å¾„ï¼š/frameworks/native/libs/binder/ ã€‚Binderåº“æœ€ç»ˆä¼šç¼–è¯‘æˆä¸€ä¸ªåŠ¨æ€é“¾æ¥åº“ï¼šlibbinder.soï¼Œä¾›å…¶ä»–è¿›ç¨‹é“¾æ¥ä½¿ç”¨ã€‚ ä¸ºäº†ä¾¿äºè¯´æ˜ï¼Œä¸‹æ–‡ä¸­æˆ‘ä»¬å°†Binder Framework çš„C++éƒ¨åˆ†ç§°ä¹‹ä¸ºlibbinderã€‚é¦–å…ˆè¯´ä¸€ä¸‹ServiceManagerï¼Œç„¶åè¯¦ç»†ä»‹ç»ã€‚ (1)ã€ServiceManagerç±»å›¾(Nativeå±‚)IServiceManagerç›¸å…³ç±»å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š IServiceManageræ˜¯è¡¨ç¤ºservicemanagerçš„æ¥å£ï¼Œæœ‰å¦‚ä¸‹æ–¹æ³•ï¼š 1) getServiceè·å¾—binder serviceå¼•ç”¨ï¼Œ 2) checkServiceè·å¾—binder serviceå¼•ç”¨ï¼Œ 3) addServiceæ·»åŠ binder serviceï¼Œ 4) listServices åˆ—ä¸¾æ‰€æœ‰binder serviceã€‚ servicemanagerçš„binder serviceæœåŠ¡ç«¯å…¶å®æ˜¯åœ¨frameworks/base/cmds/servicemanager é‡Œå®ç°ï¼ŒBnServiceManangerå®é™…ä¸Šå¹¶æœªä½¿ç”¨ã€‚BpServiceManangerå°±æ˜¯åˆ©ç”¨è·å¾—çš„IBinderæŒ‡é’ˆå»ºç«‹çš„IServiceManangerå¯¹è±¡çš„å®é™…ç±»å‹ã€‚ (2)ã€Binderæ¡†æ¶Nativeå±‚libbinderä¸­ï¼Œå°†å®ç°åˆ†ä¸ºProxyå’ŒNativeä¸¤ç«¯ã€‚Proxyå¯¹åº”äº†ä¸Šæ–‡æåˆ°çš„Clientç«¯ï¼Œæ˜¯æœåŠ¡å¯¹å¤–æä¾›çš„æ¥å£ã€‚è€ŒNativeæ˜¯æœåŠ¡å®ç°çš„ä¸€ç«¯ï¼Œå¯¹åº”äº†ä¸Šæ–‡æåˆ°çš„Serverç«¯ã€‚ç±»åä¸­å¸¦æœ‰å°å†™å­—æ¯pçš„ï¼ˆä¾‹å¦‚BpInterfaceï¼‰ï¼Œå°±æ˜¯æŒ‡Proxyç«¯ã€‚ç±»åå¸¦æœ‰å°å†™å­—æ¯nçš„ï¼ˆä¾‹å¦‚BnInterfaceï¼‰ï¼Œå°±æ˜¯æŒ‡Nativeç«¯ã€‚ Proxyä»£è¡¨äº†è°ƒç”¨æ–¹ï¼Œé€šå¸¸ä¸æœåŠ¡çš„å®ç°ä¸åœ¨åŒä¸€ä¸ªè¿›ç¨‹ï¼Œå› æ­¤ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿç§°Proxyç«¯ä¸ºâ€è¿œç¨‹â€ç«¯ã€‚Nativeç«¯æ˜¯æœåŠ¡å®ç°çš„è‡ªèº«ï¼Œå› æ­¤ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¹Ÿç§°Nativeç«¯ä¸ºâ€æœ¬åœ°â€ç«¯ã€‚ è¿™é‡Œï¼Œæˆ‘ä»¬å…ˆå¯¹libbinderä¸­çš„ä¸»è¦ç±»åšä¸€ä¸ªç®€è¦è¯´æ˜ï¼Œäº†è§£ä¸€ä¸‹å®ƒä»¬çš„å…³ç³»ï¼Œç„¶åå†è¯¦ç»†çš„è®²è§£ã€‚ ç±»å è¯´æ˜ BpRefBase RefBaseçš„å­ç±»ï¼Œæä¾›remote()æ–¹æ³•è·å–è¿œç¨‹Binder IInterface BinderæœåŠ¡æ¥å£çš„åŸºç±»ï¼ŒBinderæœåŠ¡é€šå¸¸éœ€è¦åŒæ—¶æä¾›æœ¬åœ°æ¥å£å’Œè¿œç¨‹æ¥å£ BpInterface è¿œç¨‹æ¥å£çš„åŸºç±»ï¼Œè¿œç¨‹æ¥å£æ˜¯ä¾›å®¢æˆ·ç«¯è°ƒç”¨çš„æ¥å£é›† BnInterface æœ¬åœ°æ¥å£çš„åŸºç±»ï¼Œæœ¬åœ°æ¥å£æ˜¯éœ€è¦æœåŠ¡ä¸­çœŸæ­£å®ç°çš„æ¥å£é›† IBiner Binderå¯¹è±¡çš„åŸºç±»ï¼ŒBBinderå’ŒBpBinderéƒ½æ˜¯è¿™ä¸ªç±»çš„å­ç±» BpBinder è¿œç¨‹Binderï¼Œè¿™ä¸ªç±»æä¾›transactæ–¹æ³•æ¥å‘é€è¯·æ±‚ï¼ŒBpXXXå®ç°ä¸­ä¼šç”¨åˆ° BBinder æœ¬åœ°Binderï¼ŒæœåŠ¡å®ç°æ–¹çš„åŸºç±»ï¼Œæä¾›äº†onTransactæ¥å£æ¥æ¥æ”¶è¯·æ±‚ ProcessState ä»£è¡¨äº†ä½¿ç”¨Binderçš„è¿›ç¨‹ IPCThreadState ä»£è¡¨äº†ä½¿ç”¨Binderçš„çº¿ç¨‹ï¼Œè¿™ä¸ªç±»ä¸­å°è£…äº†ä¸Binderé©±åŠ¨é€šä¿¡çš„é€»è¾‘ Parcel åœ¨Binderä¸Šä¼ é€’çš„æ•°æ®çš„åŒ…è£…å™¨ ä¸‹å›¾æè¿°äº†è¿™äº›ç±»ä¹‹é—´çš„å…³ç³»ï¼š å¦å¤–è¯´æ˜ä¸€ä¸‹ï¼ŒBinderæœåŠ¡çš„å®ç°ç±»ï¼ˆå›¾ä¸­ç´«è‰²éƒ¨åˆ†ï¼‰é€šå¸¸éƒ½ä¼šéµå®ˆä¸‹é¢çš„å‘½åè§„åˆ™ï¼š â˜¯ æœåŠ¡çš„æ¥å£ä½¿ç”¨Iå­—æ¯ä½œä¸ºå‰ç¼€ â˜¯ è¿œç¨‹æ¥å£ä½¿ç”¨Bpä½œä¸ºå‰ç¼€ â˜¯ æœ¬åœ°æ¥å£ä½¿ç”¨Bnä½œä¸ºå‰ç¼€ çœ‹äº†ä¸Šé¢è¿™äº›ä»‹ç»ï¼Œä½ å¯èƒ½è¿˜æ˜¯ä¸å¤ªå®¹æ˜“ç†è§£ã€‚ä¸è¿‡ä¸è¦ç´§ï¼Œä¸‹é¢æˆ‘ä»¬ä¼šé€æ­¥æ‹†åˆ†è®²è§£è¿™äº›å†…å®¹ã€‚ åœ¨è¿™å¹…å›¾ä¸­ï¼Œæµ…é»„è‰²éƒ¨åˆ†çš„ç»“æ„æ˜¯æœ€éš¾ç†è§£çš„ï¼Œå› æ­¤æˆ‘ä»¬å…ˆä»å®ƒä»¬ç€æ‰‹ã€‚ æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹IBinderè¿™ä¸ªç±»ã€‚è¿™ä¸ªç±»æè¿°äº†æ‰€æœ‰åœ¨Binderä¸Šä¼ é€’çš„å¯¹è±¡ï¼Œå®ƒæ—¢æ˜¯Binderæœ¬åœ°å¯¹è±¡BBinderçš„çˆ¶ç±»ï¼Œä¹Ÿæ˜¯Binderè¿œç¨‹å¯¹è±¡BpBinderçš„çˆ¶ç±»ã€‚è¿™ä¸ªç±»ä¸­çš„ä¸»è¦æ–¹æ³•è¯´æ˜å¦‚ä¸‹ï¼š æ–¹æ³•å è¯´æ˜ localBinder è·å–æœ¬åœ°Binderå¯¹è±¡ remoteBinder è·å–è¿œç¨‹Binderå¯¹è±¡ transact è¿›è¡Œä¸€æ¬¡Binderæ“ä½œ queryLocalInterface å°è¯•è·å–æœ¬åœ°Binderï¼Œå¦‚ä½•å¤±è´¥è¿”å›NULL getInterfaceDescriptor è·å–Binderçš„æœåŠ¡æ¥å£æè¿°ï¼Œå…¶å®å°±æ˜¯BinderæœåŠ¡çš„å”¯ä¸€æ ‡è¯† isBinderAlive æŸ¥è¯¢BinderæœåŠ¡æ˜¯å¦è¿˜æ´»ç€ pingBinder å‘é€PING_TRANSACTIONç»™BinderæœåŠ¡ BpBinderçš„å®ä¾‹ä»£è¡¨äº†è¿œç¨‹Binderï¼Œè¿™ä¸ªç±»çš„å¯¹è±¡å°†è¢«å®¢æˆ·ç«¯è°ƒç”¨ã€‚å…¶ä¸­handleæ–¹æ³•ä¼šè¿”å›æŒ‡å‘BinderæœåŠ¡å®ç°è€…çš„å¥æŸ„ï¼Œè¿™ä¸ªç±»æœ€é‡è¦å°±æ˜¯æä¾›äº†transactæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šå°†è¿œç¨‹è°ƒç”¨çš„å‚æ•°å°è£…å¥½å‘é€çš„Binderé©±åŠ¨ã€‚ ç”±äºæ¯ä¸ªBinderæœåŠ¡é€šå¸¸éƒ½ä¼šæä¾›å¤šä¸ªæœåŠ¡æ¥å£ï¼Œè€Œè¿™ä¸ªæ–¹æ³•ä¸­çš„uint32_t codeå‚æ•°å°±æ˜¯ç”¨æ¥å¯¹æœåŠ¡æ¥å£è¿›è¡Œç¼–å·åŒºåˆ†çš„ã€‚BinderæœåŠ¡çš„æ¯ä¸ªæ¥å£éƒ½éœ€è¦æŒ‡å®šä¸€ä¸ªå”¯ä¸€çš„codeï¼Œè¿™ä¸ªcodeè¦åœ¨Proxyå’ŒNativeç«¯é…å¯¹å¥½ã€‚å½“å®¢æˆ·ç«¯å°†è¯·æ±‚å‘é€åˆ°æœåŠ¡ç«¯çš„æ—¶å€™ï¼ŒæœåŠ¡ç«¯æ ¹æ®è¿™ä¸ªcodeï¼ˆonTransactæ–¹æ³•ä¸­ï¼‰æ¥åŒºåˆ†è°ƒç”¨å“ªä¸ªæ¥å£æ–¹æ³•ã€‚ BBinderçš„å®ä¾‹ä»£è¡¨äº†æœ¬åœ°Binderï¼Œå®ƒæè¿°äº†æœåŠ¡çš„æä¾›æ–¹ï¼Œæ‰€æœ‰BinderæœåŠ¡çš„å®ç°è€…éƒ½è¦ç»§æ‰¿è¿™ä¸ªç±»ï¼ˆçš„å­ç±»ï¼‰ï¼Œåœ¨ç»§æ‰¿ç±»ä¸­ï¼Œæœ€é‡è¦çš„å°±æ˜¯å®ç°onTransactæ–¹æ³•ï¼Œå› ä¸ºè¿™ä¸ªæ–¹æ³•æ˜¯æ‰€æœ‰è¯·æ±‚çš„å…¥å£ã€‚å› æ­¤ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯å’ŒBpBinderä¸­çš„transactæ–¹æ³•å¯¹åº”çš„ï¼Œè¿™ä¸ªæ–¹æ³•åŒæ ·ä¹Ÿæœ‰ä¸€ä¸ªuint32_t codeå‚æ•°ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•çš„å®ç°ä¸­ï¼Œç”±æœåŠ¡æä¾›è€…é€šè¿‡codeå¯¹è¯·æ±‚çš„æ¥å£è¿›è¡ŒåŒºåˆ†ï¼Œç„¶åè°ƒç”¨å…·ä½“å®ç°æœåŠ¡çš„æ–¹æ³•ã€‚ IBinderä¸­å®šä¹‰äº†uint32_t codeå…è®¸çš„èŒƒå›´ï¼š 12FIRST_CALL_TRANSACTION = 0x00000001,LAST_CALL_TRANSACTION = 0x00ffffff, BinderæœåŠ¡è¦ä¿è¯è‡ªå·±æä¾›çš„æ¯ä¸ªæœåŠ¡æ¥å£æœ‰ä¸€ä¸ªå”¯ä¸€çš„codeï¼Œä¾‹å¦‚helloæœåŠ¡: 123#define HELLO_SVR_CMD_SAYHELLO 1#define HELLO_SVR_CMD_SAYHELLO_TO 2#define HELLO_SVR_CMD_GET_FD 3 è®²å®Œäº†IBinderï¼ŒBpBinderå’ŒBBinderä¸‰ä¸ªç±»ï¼Œæˆ‘ä»¬å†æ¥çœ‹çœ‹BpReBaseï¼ŒIInterfaceï¼ŒBpInterfaceå’ŒBnInterfaceã€‚ æ¯ä¸ªBinderæœåŠ¡éƒ½æ˜¯ä¸ºäº†æŸä¸ªåŠŸèƒ½è€Œå®ç°çš„ï¼Œå› æ­¤å…¶æœ¬èº«ä¼šå®šä¹‰ä¸€å¥—æ¥å£é›†ï¼ˆé€šå¸¸æ˜¯C++çš„ä¸€ä¸ªç±»ï¼‰æ¥æè¿°è‡ªå·±æä¾›çš„æ‰€æœ‰åŠŸèƒ½ã€‚è€ŒBinderæœåŠ¡æ—¢æœ‰è‡ªèº«å®ç°æœåŠ¡çš„ç±»ï¼Œä¹Ÿè¦æœ‰ç»™å®¢æˆ·ç«¯è¿›ç¨‹è°ƒç”¨çš„ç±»ã€‚ä¸ºäº†ä¾¿äºå¼€å‘ï¼Œè¿™ä¸¤ä¸­ç±»é‡Œé¢çš„æœåŠ¡æ¥å£åº”å½“æ˜¯ä¸€è‡´çš„ï¼Œä¾‹å¦‚ï¼šå‡è®¾æœåŠ¡å®ç°æ–¹æä¾›äº†ä¸€ä¸ªæ¥å£ä¸ºsayhello(void)çš„æœåŠ¡æ–¹æ³•ï¼Œé‚£ä¹ˆå…¶è¿œç¨‹æ¥å£ä¸­ä¹Ÿåº”å½“æœ‰ä¸€ä¸ªsayhello(void)æ–¹æ³•ã€‚å› æ­¤ä¸ºäº†å®ç°æ–¹ä¾¿ï¼Œæœ¬åœ°å®ç°ç±»å’Œè¿œç¨‹æ¥å£ç±»éœ€è¦æœ‰ä¸€ä¸ªå…¬å…±çš„æè¿°æœåŠ¡æ¥å£çš„åŸºç±»ï¼ˆå³ä¸Šå›¾ä¸­çš„IXXXServiceï¼‰æ¥ç»§æ‰¿ã€‚è€Œè¿™ä¸ªåŸºç±»é€šå¸¸æ˜¯IInterfaceçš„å­ç±»ï¼ŒIInterfaceçš„å®šä¹‰å¦‚ä¸‹ï¼š 1234567891011class IInterface : public virtual RefBase&#123;public: IInterface(); static sp&lt;IBinder&gt; asBinder(const IInterface*); static sp&lt;IBinder&gt; asBinder(const sp&lt;IInterface&gt;&amp;);protected: virtual ~IInterface(); virtual IBinder* onAsBinder() = 0;&#125;; ä¹‹æ‰€ä»¥è¦ç»§æ‰¿è‡ªIInterfaceç±»æ˜¯å› ä¸ºè¿™ä¸ªç±»ä¸­å®šä¹‰äº†onAsBinderè®©å­ç±»å®ç°ã€‚onAsBinderåœ¨æœ¬åœ°å¯¹è±¡çš„å®ç°ç±»ä¸­è¿”å›çš„æ˜¯æœ¬åœ°å¯¹è±¡ï¼Œåœ¨è¿œç¨‹å¯¹è±¡çš„å®ç°ç±»ä¸­è¿”å›çš„æ˜¯è¿œç¨‹å¯¹è±¡ã€‚onAsBinderæ–¹æ³•è¢«ä¸¤ä¸ªé™æ€æ–¹æ³•asBinderæ–¹æ³•è°ƒç”¨ã€‚æœ‰äº†è¿™äº›æ¥å£ä¹‹åï¼Œåœ¨ä»£ç ä¸­ä¾¿å¯ä»¥ç›´æ¥é€šè¿‡IXXX::asBinderæ–¹æ³•è·å–åˆ°ä¸ç”¨åŒºåˆ†æœ¬åœ°è¿˜æ˜¯è¿œç¨‹çš„IBinderå¯¹è±¡ã€‚è¿™ä¸ªåœ¨è·¨è¿›ç¨‹ä¼ é€’Binderå¯¹è±¡çš„æ—¶å€™æœ‰å¾ˆå¤§çš„ä½œç”¨ï¼ˆå› ä¸ºä¸ç”¨åŒºåˆ†å…·ä½“ç»†èŠ‚ï¼Œåªè¦ç›´æ¥è°ƒç”¨å’Œä¼ é€’å°±å¥½ï¼‰ã€‚ ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹BpInterfaceå’ŒBnInterfaceçš„å®šä¹‰ï¼š 12345678910111213141516171819202122template&lt;typename INTERFACE&gt;class BnInterface : public INTERFACE, public BBinder&#123;public: virtual sp&lt;IInterface&gt; queryLocalInterface(const String16&amp; _descriptor); virtual const String16&amp; getInterfaceDescriptor() const;protected: virtual IBinder* onAsBinder();&#125;;// ----------------------------------------------------------------------template&lt;typename INTERFACE&gt;class BpInterface : public INTERFACE, public BpRefBase&#123;public: BpInterface(const sp&lt;IBinder&gt;&amp; remote);protected: virtual IBinder* onAsBinder();&#125;; è¿™ä¸¤ä¸ªç±»éƒ½æ˜¯æ¨¡æ¿ç±»ï¼Œå®ƒä»¬åœ¨ç»§æ‰¿è‡ªINTERFACEçš„åŸºç¡€ä¸Šå„è‡ªç»§æ‰¿äº†å¦å¤–ä¸€ä¸ªç±»ã€‚è¿™é‡Œçš„INTERFACEä¾¿æ˜¯æˆ‘ä»¬BinderæœåŠ¡æ¥å£çš„åŸºç±»ã€‚å¦å¤–ï¼ŒBnInterfaceç»§æ‰¿äº†BBinderç±»ï¼Œç”±æ­¤å¯ä»¥é€šè¿‡å¤å†™onTransactæ–¹æ³•æ¥æä¾›å®ç°ã€‚BpInterfaceç»§æ‰¿äº†BpRefBaseï¼Œé€šè¿‡è¿™ä¸ªç±»çš„remoteæ–¹æ³•å¯ä»¥è·å–åˆ°æŒ‡å‘æœåŠ¡å®ç°æ–¹çš„å¥æŸ„ã€‚åœ¨å®¢æˆ·ç«¯æ¥å£çš„å®ç°ç±»ä¸­ï¼Œæ¯ä¸ªæ¥å£åœ¨ç»„è£…å¥½å‚æ•°ä¹‹åï¼Œéƒ½ä¼šè°ƒç”¨remote()-&gt;transactæ¥å‘é€è¯·æ±‚ï¼Œè€Œè¿™é‡Œå…¶å®å°±æ˜¯è°ƒç”¨çš„BpBinderçš„transactæ–¹æ³•ï¼Œè¿™æ ·è¯·æ±‚ä¾¿é€šè¿‡Binderåˆ°è¾¾äº†æœåŠ¡å®ç°æ–¹çš„onTransactä¸­ã€‚è¿™ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åŸºäºBinderæ¡†æ¶å¼€å‘çš„æœåŠ¡ï¼Œé™¤äº†æ»¡è¶³ä¸Šæ–‡æåˆ°çš„ç±»åè§„åˆ™ä¹‹å¤–ï¼Œè¿˜éœ€è¦éµå®ˆå…¶ä»–ä¸€äº›å…±åŒçš„è§„çº¦ï¼š â˜¯ä¸ºäº†è¿›è¡ŒæœåŠ¡çš„åŒºåˆ†ï¼Œæ¯ä¸ªBinderæœåŠ¡éœ€è¦æŒ‡å®šä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ï¼Œè¿™ä¸ªæ ‡è¯†é€šè¿‡getInterfaceDescriptorè¿”å›ï¼Œç±»å‹æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚é€šå¸¸ï¼ŒBinderæœåŠ¡ä¼šåœ¨ç±»ä¸­å®šä¹‰static const android::String16 descriptor;è¿™æ ·ä¸€ä¸ªå¸¸é‡æ¥æè¿°è¿™ä¸ªæ ‡è¯†ç¬¦ï¼Œç„¶ååœ¨getInterfaceDescriptoræ–¹æ³•ä¸­è¿”å›è¿™ä¸ªå¸¸é‡ã€‚ â˜¯ä¸ºäº†ä¾¿äºè°ƒç”¨è€…è·å–åˆ°è°ƒç”¨æ¥å£ï¼ŒæœåŠ¡æ¥å£çš„å…¬å…±åŸºç±»éœ€è¦æä¾›ä¸€ä¸ªandroid::sp asInterfaceæ–¹æ³•æ¥è¿”å›åŸºç±»å¯¹è±¡æŒ‡é’ˆã€‚ç”±äºä¸Šé¢æåˆ°çš„è¿™ä¸¤ç‚¹å¯¹äºæ‰€æœ‰BinderæœåŠ¡çš„å®ç°é€»è¾‘éƒ½æ˜¯ç±»ä¼¼çš„ã€‚ä¸ºäº†ç®€åŒ–å¼€å‘è€…çš„é‡å¤å·¥ä½œï¼Œåœ¨libbinderä¸­ï¼Œå®šä¹‰äº†ä¸¤ä¸ªå®æ¥ç®€åŒ–è¿™äº›é‡å¤å·¥ä½œï¼Œå®ƒä»¬æ˜¯ï¼š 12345678910111213141516171819202122232425262728293031#define DECLARE_META_INTERFACE(INTERFACE) \\ static const android::String16 descriptor; \\ static android::sp&lt;I##INTERFACE&gt; asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj); \\ virtual const android::String16&amp; getInterfaceDescriptor() const; \\ I##INTERFACE(); \\ virtual ~I##INTERFACE(); \\#define IMPLEMENT_META_INTERFACE(INTERFACE, NAME) \\ const android::String16 I##INTERFACE::descriptor(NAME); \\ const android::String16&amp; \\ I##INTERFACE::getInterfaceDescriptor() const &#123; \\ return I##INTERFACE::descriptor; \\ &#125; \\ android::sp&lt;I##INTERFACE&gt; I##INTERFACE::asInterface( \\ const android::sp&lt;android::IBinder&gt;&amp; obj) \\ &#123; \\ android::sp&lt;I##INTERFACE&gt; intr; \\ if (obj != NULL) &#123; \\ intr = static_cast&lt;I##INTERFACE*&gt;( \\ obj-&gt;queryLocalInterface( \\ I##INTERFACE::descriptor).get()); \\ if (intr == NULL) &#123; \\ intr = new Bp##INTERFACE(obj); \\ &#125; \\ &#125; \\ return intr; \\ &#125; \\ I##INTERFACE::I##INTERFACE() &#123; &#125; \\ I##INTERFACE::~I##INTERFACE() &#123; &#125; \\ æœ‰äº†è¿™ä¸¤ä¸ªå®ä¹‹åï¼Œå¼€å‘è€…åªè¦åœ¨æ¥å£åŸºç±»ï¼ˆIXXXï¼‰å¤´æ–‡ä»¶ä¸­ï¼Œä½¿ç”¨DECLARE_META_INTERFACEå®ä¾¿å®Œæˆäº†éœ€è¦çš„ç»„ä»¶çš„å£°æ˜ã€‚ç„¶ååœ¨cppæ–‡ä»¶ä¸­ä½¿ç”¨IMPLEMENT_META_INTERFACEä¾¿å®Œæˆäº†è¿™äº›ç»„ä»¶çš„å®ç°ã€‚ 2.1ã€Binderçš„åˆå§‹åŒ–ProcessStateåœ¨è®²è§£Binderé©±åŠ¨çš„æ—¶å€™æˆ‘ä»¬å°±æåˆ°ï¼šä»»ä½•ä½¿ç”¨Binderæœºåˆ¶çš„è¿›ç¨‹éƒ½å¿…é¡»è¦å¯¹/dev/binderè®¾å¤‡è¿›è¡Œopenä»¥åŠmmapä¹‹åæ‰èƒ½ä½¿ç”¨ï¼Œè¿™éƒ¨åˆ†é€»è¾‘æ˜¯æ‰€æœ‰ä½¿ç”¨Binderæœºåˆ¶è¿›ç¨‹å…±åŒçš„ã€‚å¯¹äºè¿™ç§å…±åŒé€»è¾‘çš„å°è£…ä¾¿æ˜¯Frameworkå±‚çš„èŒè´£ä¹‹ä¸€ã€‚libbinderä¸­ï¼ŒProcessStateç±»å°è£…äº†è¿™ä¸ªé€»è¾‘ï¼Œç›¸å…³ä»£ç è§ä¸‹æ–‡ã€‚ è¿™é‡Œæ˜¯ProcessStateæ„é€ å‡½æ•°ï¼Œåœ¨è¿™ä¸ªå‡½æ•°ä¸­ï¼Œåˆå§‹åŒ–mDriverFDçš„æ—¶å€™è°ƒç”¨äº†open_driveræ–¹æ³•æ‰“å¼€binderè®¾å¤‡ï¼Œç„¶ååˆåœ¨å‡½æ•°ä½“ä¸­ï¼Œé€šè¿‡mmapè¿›è¡Œå†…å­˜æ˜ å°„ã€‚ 12345678910111213141516171819ProcessState::ProcessState() : mDriverFD(open_driver()) , mVMStart(MAP_FAILED) , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER) , mThreadCountDecrement(PTHREAD_COND_INITIALIZER) , mExecutingThreadsCount(0) , mMaxThreads(DEFAULT_MAX_BINDER_THREADS) , mStarvationStartTimeMs(0) , mManagesContexts(false) , mBinderContextCheckFunc(NULL) , mBinderContextUserData(NULL) , mThreadPoolStarted(false) , mThreadPoolSeq(1)&#123; if (mDriverFD &gt;= 0) &#123; mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); ... &#125;&#125; open_driverçš„å‡½æ•°å®ç°å¦‚ä¸‹æ‰€ç¤ºã€‚åœ¨è¿™ä¸ªå‡½æ•°ä¸­å®Œæˆäº†ä¸‰ä¸ªå·¥ä½œï¼š â˜¯é¦–å…ˆé€šè¿‡openç³»ç»Ÿè°ƒç”¨æ‰“å¼€äº†dev/binderè®¾å¤‡ â˜¯ç„¶åé€šè¿‡ioctlè·å–Binderå®ç°çš„ç‰ˆæœ¬å·ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦åŒ¹é… â˜¯æœ€åé€šè¿‡ioctlè®¾ç½®è¿›ç¨‹æ”¯æŒçš„æœ€å¤§çº¿ç¨‹æ•°é‡ å…³äºè¿™éƒ¨åˆ†é€»è¾‘èƒŒåçš„å¤„ç†ï¼Œåœ¨è®²è§£Binderé©±åŠ¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬å·²ç»è®²è§£è¿‡äº†ã€‚ 1234567891011121314static int open_driver()&#123; int fd = open(\"/dev/binder\", O_RDWR | O_CLOEXEC); if (fd &gt;= 0) &#123; int vers = 0; status_t result = ioctl(fd, BINDER_VERSION, &amp;vers); ... size_t maxThreads = DEFAULT_MAX_BINDER_THREADS; result = ioctl(fd, BINDER_SET_MAX_THREADS, &amp;maxThreads); &#125; else &#123; ... &#125; return fd;&#125; ProcessStateæ˜¯ä¸€ä¸ªSingletonï¼ˆå•ä¾‹ï¼‰ç±»å‹çš„ç±»ï¼Œåœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œåªä¼šå­˜åœ¨ä¸€ä¸ªå®ä¾‹ã€‚é€šè¿‡ProcessState::self()æ¥å£è·å–è¿™ä¸ªå®ä¾‹ã€‚ä¸€æ—¦è·å–è¿™ä¸ªå®ä¾‹ï¼Œä¾¿ä¼šæ‰§è¡Œå…¶æ„é€ å‡½æ•°ï¼Œç”±æ­¤å®Œæˆäº†å¯¹äºBinderè®¾å¤‡çš„åˆå§‹åŒ–å·¥ä½œã€‚ 2.2ã€å…³äºBinderä¼ é€’æ•°æ®çš„å¤§å°é™åˆ¶ç”±äºBinderçš„æ•°æ®éœ€è¦è·¨è¿›ç¨‹ä¼ é€’ï¼Œå¹¶ä¸”è¿˜éœ€è¦åœ¨å†…æ ¸ä¸Šå¼€è¾Ÿç©ºé—´ï¼Œå› æ­¤å…è®¸åœ¨Binderä¸Šä¼ é€’çš„æ•°æ®å¹¶ä¸æ˜¯æ— æ— é™å¤§çš„ã€‚mmapä¸­æŒ‡å®šçš„å¤§å°ä¾¿æ˜¯å¯¹æ•°æ®ä¼ é€’çš„å¤§å°é™åˆ¶ï¼š 12#define BINDER_VM_SIZE ((1*1024*1024) - (4096 *2)) // 1M - 8kmVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0); è¿™é‡Œæˆ‘ä»¬çœ‹åˆ°ï¼Œåœ¨è¿›è¡Œmmapçš„æ—¶å€™ï¼ŒæŒ‡å®šäº†æœ€å¤§sizeä¸ºBINDER_VM_SIZEï¼Œå³ 1M - 8kçš„å¤§å°ã€‚ å› æ­¤æˆ‘ä»¬åœ¨å¼€å‘è¿‡ç¨‹ä¸­ï¼Œä¸€æ¬¡Binderè°ƒç”¨çš„æ•°æ®æ€»å’Œä¸èƒ½è¶…è¿‡è¿™ä¸ªå¤§å°ã€‚ å¯¹äºè¿™ä¸ªåŒºåŸŸçš„å¤§å°ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥åœ¨è®¾å¤‡ä¸Šè¿›è¡Œç¡®è®¤ã€‚è¿™é‡Œæˆ‘ä»¬è¿˜ä¹‹å‰æåˆ°çš„system_serverä¸ºä¾‹ã€‚ä¸Šé¢æˆ‘ä»¬è®²è§£äº†é€šè¿‡procfsæ¥è·å–æ˜ å°„çš„å†…å­˜åœ°å€ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡showmapå‘½ä»¤ï¼Œæ¥ç¡®å®šè¿™å—åŒºåŸŸçš„å¤§å°ï¼Œç›¸å…³å‘½ä»¤å¦‚ä¸‹ï¼š 1234angler:/ # ps | grep system_server system 1889 526 2353404 135968 SyS_epoll_ 72972eeaf4 S system_serverangler:/ # showmap 1889 | grep \"/dev/binder\" 1016 4 4 0 0 4 0 0 1 /dev/binder è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œè¿™å—åŒºåŸŸçš„å¤§å°æ­£æ˜¯ 1M - 8K = 1016kã€‚ Tips: é€šè¿‡showmapå‘½ä»¤å¯ä»¥çœ‹åˆ°è¿›ç¨‹çš„è¯¦ç»†å†…å­˜å ç”¨æƒ…å†µã€‚åœ¨å®é™…çš„å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå½“æˆ‘ä»¬è¦å¯¹æŸä¸ªè¿›ç¨‹åšå†…å­˜å ç”¨åˆ†æçš„æ—¶å€™ï¼Œè¿™ä¸ªå‘½ä»¤æ˜¯ç›¸å½“æœ‰ç”¨çš„ã€‚å»ºè®®è¯»è€…å°è¯•é€šè¿‡showmapå‘½ä»¤æŸ¥çœ‹system_serveræˆ–å…¶ä»–æ„Ÿå…´è¶£è¿›ç¨‹çš„å®Œæ•´mapï¼Œçœ‹çœ‹è¿™äº›è¿›ç¨‹éƒ½ä¾èµ–äº†å“ªäº›åº“æˆ–è€…æ¨¡å—ï¼Œä»¥åŠå†…å­˜å ç”¨æƒ…å†µæ˜¯æ€æ ·çš„ã€‚ 2.3ã€ä¸é©±åŠ¨çš„é€šä¿¡IPCThreadStateä¸Šæ–‡æåˆ°ProcessStateæ˜¯ä¸€ä¸ªå•ä¾‹ç±»ï¼Œä¸€ä¸ªè¿›ç¨‹åªæœ‰ä¸€ä¸ªå®ä¾‹ã€‚è€Œè´Ÿè´£ä¸Binderé©±åŠ¨é€šä¿¡çš„IPCThreadStateä¹Ÿæ˜¯ä¸€ä¸ªå•ä¾‹ç±»ã€‚ä½†è¿™ä¸ªç±»ä¸æ˜¯ä¸€ä¸ªè¿›ç¨‹åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œè€Œæ˜¯ä¸€ä¸ªçº¿ç¨‹æœ‰ä¸€ä¸ªå®ä¾‹ã€‚ IPCThreadStateè´Ÿè´£äº†ä¸é©±åŠ¨é€šä¿¡çš„ç»†èŠ‚å¤„ç†ã€‚è¿™ä¸ªç±»ä¸­çš„å…³é”®å‡ ä¸ªæ–¹æ³•è¯´æ˜å¦‚ä¸‹ï¼š æ–¹æ³• è¯´æ˜ transact å…¬å¼€æ¥å£ã€‚ä¾›Proxyå‘é€æ•°æ®åˆ°é©±åŠ¨ï¼Œå¹¶è¯»å–è¿”å›ç»“æœ sendReply ä¾›Serverç«¯å†™å›è¯·æ±‚çš„è¿”å›ç»“æœ waitForResponse å‘é€è¯·æ±‚åç­‰å¾…å“åº”ç»“æœ talkWithDriver é€šè¿‡ioctl BINDER_WRITE_READæ¥ä¸é©±åŠ¨é€šä¿¡ writeTransactionData å†™å…¥ä¸€æ¬¡äº‹åŠ¡çš„æ•°æ® executeCommand å¤„ç†binder_driver_return_protocolåè®®å‘½ä»¤ freeBuffer é€šè¿‡BC_FREE_BUFFERå‘½ä»¤é‡Šæ”¾Buffer BpBinder::transactæ–¹æ³•åœ¨å‘é€è¯·æ±‚çš„æ—¶å€™ï¼Œå…¶å®å°±æ˜¯ç›´æ¥è°ƒç”¨äº†IPCThreadStateå¯¹åº”çš„æ–¹æ³•æ¥å‘é€è¯·æ±‚åˆ°Binderé©±åŠ¨çš„ï¼Œç›¸å…³ä»£ç å¦‚ä¸‹ï¼š 123456789101112status_t BpBinder::transact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; if (mAlive) &#123; status_t status = IPCThreadState::self()-&gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; &#125; return DEAD_OBJECT;&#125; è€ŒIPCThreadState::transactæ–¹æ³•ä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š 123456789101112131415161718192021222324252627282930status_t IPCThreadState::transact(int32_t handle, uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; status_t err = data.errorCheck(); flags |= TF_ACCEPT_FDS; if (err == NO_ERROR) &#123; err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL); &#125; if (err != NO_ERROR) &#123; if (reply) reply-&gt;setError(err); return (mLastError = err); &#125; if ((flags &amp; TF_ONE_WAY) == 0) &#123; if (reply) &#123; err = waitForResponse(reply); &#125; else &#123; Parcel fakeReply; err = waitForResponse(&amp;fakeReply); &#125; &#125; else &#123; err = waitForResponse(NULL, NULL); &#125; return err;&#125; è¿™æ®µä»£ç åº”è¯¥è¿˜æ˜¯æ¯”è¾ƒå¥½ç†è§£çš„ï¼šé¦–å…ˆé€šè¿‡writeTransactionDataå†™å…¥æ•°æ®ï¼Œç„¶åé€šè¿‡waitForResponseç­‰å¾…è¿”å›ç»“æœã€‚TF_ONE_WAYè¡¨ç¤ºæ­¤æ¬¡è¯·æ±‚æ˜¯å•å‘çš„ï¼Œå³ï¼šä¸ç”¨çœŸæ­£ç­‰å¾…ç»“æœå³å¯è¿”å›ã€‚ è€ŒwriteTransactionDataæ–¹æ³•å…¶å®å°±æ˜¯åœ¨ç»„è£…binder_transaction_dataæ•°æ®ï¼š 1234567891011121314151617181920212223242526272829303132333435status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; å¯¹äºbinder_transaction_dataåœ¨è®²è§£Binderé©±åŠ¨çš„æ—¶å€™æˆ‘ä»¬å·²ç»è¯¦ç»†è®²è§£è¿‡äº†ã€‚è€Œè¿™é‡Œçš„Parcelæˆ‘ä»¬è¿˜ä¸äº†è§£ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬é©¬ä¸Šå°±æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªç±»ã€‚ æ•°æ®åŒ…è£…å™¨ï¼šParcel Binderä¸Šæä¾›çš„æ˜¯è·¨è¿›ç¨‹çš„æœåŠ¡ï¼Œæ¯ä¸ªæœåŠ¡åŒ…å«äº†ä¸åŒçš„æ¥å£ï¼Œæ¯ä¸ªæ¥å£çš„å‚æ•°æ•°é‡å’Œç±»å‹éƒ½ä¸ä¸€æ ·ã€‚é‚£ä¹ˆå½“å®¢æˆ·ç«¯æƒ³è¦è°ƒç”¨æœåŠ¡ç«¯çš„æ¥å£ï¼Œå‚æ•°æ˜¯å¦‚ä½•è·¨è¿›ç¨‹ä¼ é€’ç»™æœåŠ¡ç«¯çš„å‘¢ï¼Ÿé™¤æ­¤ä¹‹å¤–ï¼ŒæœåŠ¡ç«¯æƒ³è¦ç»™å®¢æˆ·ç«¯è¿”å›ç»“æœï¼Œç»“æœåˆæ˜¯å¦‚ä½•ä¼ é€’å›æ¥çš„å‘¢ï¼Ÿ è¿™äº›é—®é¢˜çš„ç­”æ¡ˆå°±æ˜¯ï¼šParcelã€‚Parcelå°±åƒä¸€ä¸ªåŒ…è£…å™¨ï¼Œè°ƒç”¨è€…å¯ä»¥ä»¥ä»»æ„é¡ºåºå¾€é‡Œé¢æ”¾å…¥éœ€è¦çš„æ•°æ®ï¼Œæ‰€æœ‰å†™å…¥çš„æ•°æ®å°±åƒæ˜¯è¢«æ‰“æˆä¸€ä¸ªæ•´ä½“çš„åŒ…ï¼Œç„¶åå¯ä»¥ç›´æ¥åœ¨Bindeä¸Šä¼ è¾“ã€‚ Parcelæä¾›äº†æ‰€æœ‰åŸºæœ¬ç±»å‹çš„å†™å…¥å’Œè¯»å‡ºæ¥å£ï¼Œä¸‹é¢æ˜¯å…¶ä¸­çš„ä¸€éƒ¨åˆ†ï¼š 123456789...status_t writeInt32(int32_t val);status_t writeUint32(uint32_t val);......status_t readUtf8FromUtf16(std::string* str) const;status_t readUtf8FromUtf16(std::unique_ptr&lt;std::string&gt;* str) const;const char* readCString() const;... å› æ­¤å¯¹äºåŸºæœ¬ç±»å‹ï¼Œå¼€å‘è€…å¯ä»¥ç›´æ¥è°ƒç”¨æ¥å£å†™å…¥å’Œè¯»å‡ºã€‚è€Œå¯¹äºéåŸºæœ¬ç±»å‹ï¼Œéœ€è¦ç”±å¼€å‘è€…å°†å…¶æ‹†åˆ†æˆåŸºæœ¬ç±»å‹ç„¶åå†™å…¥åˆ°Parcelä¸­ï¼ˆè¯»å‡ºçš„æ—¶å€™ä¹Ÿæ˜¯ä¸€æ ·ï¼‰ã€‚ Parcelä¼šå°†æ‰€æœ‰å†™å…¥çš„æ•°æ®è¿›è¡Œæ‰“åŒ…ï¼ŒParcelæœ¬èº«å¯ä»¥ä½œä¸ºä¸€ä¸ªæ•´ä½“åœ¨è¿›ç¨‹é—´ä¼ é€’ã€‚æ¥æ”¶æ–¹åœ¨æ”¶åˆ°Parcelä¹‹åï¼Œåªè¦æŒ‰å†™å…¥åŒæ ·çš„é¡ºåºè¯»å‡ºå³å¯ã€‚ è¿™ä¸ªè¿‡ç¨‹ï¼Œå’Œæˆ‘ä»¬ç°å®ç”Ÿæ´»ä¸­å¯„é€åŒ…è£¹åšæ³•æ˜¯ä¸€æ ·çš„ï¼šæˆ‘ä»¬å°†éœ€è¦å¯„é€çš„åŒ…è£¹æ”¾åˆ°ç¡¬çº¸ç›’ä¸­äº¤ç»™å¿«é€’å…¬å¸ã€‚å¿«é€’å…¬å¸å°†æ‰€æœ‰çš„åŒ…è£¹è¿›è¡Œæ‰“åŒ…ï¼Œç„¶åé›†ä¸­æ”¾åˆ°è¿è¾“è½¦ä¸­é€åˆ°ç›®çš„åœ°ï¼Œåˆ°äº†ç›®çš„åœ°ä¹‹åç„¶åå†è¿›è¡Œæ‹†åˆ†ã€‚ Parcelæ—¢åŒ…å«C++éƒ¨åˆ†çš„å®ç°ï¼Œä¹ŸåŒæ—¶æä¾›äº†Javaçš„æ¥å£ï¼Œä¸­é—´é€šè¿‡JNIè¡”æ¥ã€‚Javaå±‚çš„æ¥å£å…¶å®ä»…ä»…æ˜¯ä¸€å±‚åŒ…è£…ï¼ŒçœŸæ­£çš„å®ç°éƒ½æ˜¯ä½äºC++éƒ¨åˆ†ä¸­ã€‚ ç‰¹åˆ«éœ€è¦è¯´æ˜ä¸€ä¸‹çš„æ˜¯ï¼ŒParcelç±»é™¤äº†å¯ä»¥ä¼ é€’åŸºæœ¬æ•°æ®ç±»å‹ï¼Œè¿˜å¯ä»¥ä¼ é€’Binderå¯¹è±¡ï¼š 1234status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flatten_binder(ProcessState::self(), val, this);&#125; è¿™ä¸ªæ–¹æ³•å†™å…¥çš„æ˜¯sp ç±»å‹çš„å¯¹è±¡ï¼Œè€ŒIBinderæ—¢å¯èƒ½æ˜¯æœ¬åœ°Binderï¼Œä¹Ÿå¯èƒ½æ˜¯è¿œç¨‹Binderï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸å¯ä»¥ä¸ç”¨å…³å¿ƒå…·ä½“ç»†èŠ‚ç›´æ¥è¿›è¡ŒBinderå¯¹è±¡çš„ä¼ é€’ã€‚ è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆIInterfaceä¸­å®šä¹‰äº†ä¸¤ä¸ªasBinderçš„staticæ–¹æ³•ï¼Œå¦‚æœä½ ä¸è®°å¾—äº†ï¼Œè¯·å›å¿†ä¸€ä¸‹è¿™ä¸¤ä¸ªæ–¹æ³•ï¼š 12static sp&lt;IBinder&gt; asBinder(const IInterface*);static sp&lt;IBinder&gt; asBinder(const sp&lt;IInterface&gt;&amp;); è€Œå¯¹äºBinderé©±åŠ¨ï¼Œæˆ‘ä»¬å‰é¢å·²ç»è®²è§£è¿‡ï¼šBinderé©±åŠ¨å¹¶ä¸æ˜¯çœŸçš„å°†å¯¹è±¡åœ¨è¿›ç¨‹é—´åºåˆ—åŒ–ä¼ é€’ï¼Œè€Œæ˜¯ç”±Binderé©±åŠ¨å®Œæˆäº†å¯¹äºBinderå¯¹è±¡æŒ‡é’ˆçš„è§£é‡Šå’Œç¿»è¯‘ï¼Œä½¿è°ƒç”¨è€…çœ‹èµ·æ¥å°±åƒåœ¨è¿›ç¨‹é—´ä¼ é€’å¯¹è±¡ä¸€æ ·ã€‚ 2.4ã€Frameworkå±‚çš„çº¿ç¨‹ç®¡ç†åœ¨è®²è§£Binderé©±åŠ¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±è®²è§£è¿‡é©±åŠ¨ä¸­å¯¹åº”çº¿ç¨‹çš„ç®¡ç†ã€‚è¿™é‡Œæˆ‘ä»¬å†æ¥çœ‹çœ‹ï¼ŒFrameworkå±‚æ˜¯å¦‚ä½•ä¸é©±åŠ¨å±‚å¯¹æ¥è¿›è¡Œçº¿ç¨‹ç®¡ç†çš„ã€‚ ProcessState::setThreadPoolMaxThreadCount æ–¹æ³•ä¸­ï¼Œä¼šé€šè¿‡BINDER_SET_MAX_THREADSå‘½ä»¤è®¾ç½®è¿›ç¨‹æ”¯æŒçš„æœ€å¤§çº¿ç¨‹æ•°é‡ï¼š 123456789101112#define DEFAULT_MAX_BINDER_THREADS 15status_t ProcessState::setThreadPoolMaxThreadCount(size_t maxThreads) &#123; status_t result = NO_ERROR; if (ioctl(mDriverFD, BINDER_SET_MAX_THREADS, &amp;maxThreads) != -1) &#123; mMaxThreads = maxThreads; &#125; else &#123; result = -errno; ALOGE(\"Binder ioctl to set max threads failed: %s\", strerror(-result)); &#125; return result;&#125; ç”±æ­¤é©±åŠ¨ä¾¿çŸ¥é“äº†è¯¥BinderæœåŠ¡æ”¯æŒçš„æœ€å¤§çº¿ç¨‹æ•°ã€‚é©±åŠ¨åœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œä¼šæ ¹æ®éœ€è¦ï¼Œå¹¶åœ¨æ²¡æœ‰è¶…è¿‡ä¸Šé™çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡BR_SPAWN_LOOPERå‘½ä»¤é€šçŸ¥è¿›ç¨‹åˆ›å»ºçº¿ç¨‹ï¼š IPCThreadStateåœ¨æ”¶åˆ°BR_SPAWN_LOOPERè¯·æ±‚ä¹‹åï¼Œä¾¿ä¼šè°ƒç”¨ProcessState::spawnPooledThreadæ¥åˆ›å»ºçº¿ç¨‹ï¼š 12345678status_t IPCThreadState::executeCommand(int32_t cmd)&#123; ... case BR_SPAWN_LOOPER: mProcess-&gt;spawnPooledThread(false); break; ...&#125; ProcessState::spawnPooledThreadæ–¹æ³•è´Ÿè´£ä¸ºçº¿ç¨‹è®¾å®šåç§°å¹¶åˆ›å»ºçº¿ç¨‹ï¼š 123456789void ProcessState::spawnPooledThread(bool isMain)&#123; if (mThreadPoolStarted) &#123; String8 name = makeBinderThreadName(); ALOGV(\"Spawning new pooled thread, name=%s\\n\", name.string()); sp&lt;Thread&gt; t = new PoolThread(isMain); t-&gt;run(name.string()); &#125;&#125; çº¿ç¨‹åœ¨runä¹‹åï¼Œä¼šè°ƒç”¨threadLoopå°†è‡ªèº«æ·»åŠ çš„çº¿ç¨‹æ± ä¸­ï¼š 12345virtual bool threadLoop()&#123; IPCThreadState::self()-&gt;joinThreadPool(mIsMain); return false;&#125; è€ŒIPCThreadState::joinThreadPoolæ–¹æ³•ä¸­ï¼Œä¼šæ ¹æ®å½“å‰çº¿ç¨‹æ˜¯å¦æ˜¯ä¸»çº¿ç¨‹å‘é€BC_ENTER_LOOPERæˆ–è€…BC_REGISTER_LOOPERå‘½ä»¤å‘ŠçŸ¥é©±åŠ¨çº¿ç¨‹å·²ç»åˆ›å»ºå®Œæ¯•ã€‚æ•´ä¸ªè°ƒç”¨æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ï¼ˆ3ï¼‰ã€Android Binderç³»ç»Ÿ-Nativeå±‚æ·»åŠ helloæœåŠ¡3.1ã€Clientæ„é€ æ•°æ®ï¼Œå‘é€æ•°æ®ç»™é©±åŠ¨é¦–å…ˆçœ‹ä¸€ä¸‹Native ServiceManageræ¶æ„å›¾ åªè®²æ•°æ®æ„é€ è¿‡ç¨‹ã€‚ã€‚ æ„é€ ï¼š [-&gt; IServiceManager.cpp ::BpServiceManager] 1234567891011virtual status_t addService(const String16&amp; name, const sp&lt;IBinder&gt;&amp; service, bool allowIsolated) &#123; Parcel data, reply; //Parcelæ˜¯æ•°æ®é€šä¿¡åŒ… //å†™å…¥å¤´ä¿¡æ¯\"android.os.IServiceManager\" data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor()); data.writeString16(name); // nameä¸º \"hello\" data.writeStrongBinder(service); // HelloServiceå¯¹è±¡ï¼ŒæŠŠä¸€ä¸ªbinderå®ä½“â€œæ‰“æ‰â€å¹¶å†™å…¥parcel data.writeInt32(allowIsolated ? 1 : 0); // allowIsolated= false //remote()æŒ‡å‘çš„æ˜¯BpBinderå¯¹è±¡ status_t err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply); return err == NO_ERROR ? reply.readExceptionCode() : err;&#125; æœåŠ¡æ³¨å†Œè¿‡ç¨‹ï¼šå‘ServiceManageræ³¨å†ŒæœåŠ¡hello Serviceï¼ŒæœåŠ¡åä¸ºâ€helloâ€ï¼› è¯·å¤§å®¶æ³¨æ„ä¸Šé¢data.writeStrongBinder()ä¸€å¥ï¼Œå®ƒä¸“é—¨è´Ÿè´£æŠŠä¸€ä¸ªbinderå®ä½“â€æ‰“æ‰â€å¹¶å†™å…¥parcelã€‚å…¶ä»£ç å¦‚ä¸‹ï¼š 3.2.1ã€* writeStrongBinder()[-&gt; parcel.cpp] 1234status_t Parcel::writeStrongBinder(const sp&lt;IBinder&gt;&amp; val)&#123; return flatten_binder(ProcessState::self(), val, this);&#125; 3.2.2ã€flatten_binder()[-&gt; parcel.cpp] 12345678910111213141516171819202122232425status_t flatten_binder(const sp&lt;ProcessState&gt;&amp; /*proc*/, const sp&lt;IBinder&gt;&amp; binder, Parcel* out)&#123; flat_binder_object obj; obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS; if (binder != NULL) &#123; IBinder *local = binder-&gt;localBinder(); //æœ¬åœ°Binderä¸ä¸ºç©º if (!local) &#123; BpBinder *proxy = binder-&gt;remoteBinder(); const int32_t handle = proxy ? proxy-&gt;handle() : 0; obj.type = BINDER_TYPE_HANDLE; obj.binder = 0; obj.handle = handle; obj.cookie = 0; &#125; else &#123; //è¿›å…¥è¯¥åˆ†æ”¯ obj.type = BINDER_TYPE_BINDER; obj.binder = reinterpret_cast&lt;uintptr_t&gt;(local-&gt;getWeakRefs()); obj.cookie = reinterpret_cast&lt;uintptr_t&gt;(local); &#125; &#125; else &#123; ... &#125; return finish_flatten_binder(binder, obj, out);&#125; å°†Binderå¯¹è±¡æ‰å¹³åŒ–ï¼Œè½¬æ¢æˆflat_binder_objectå¯¹è±¡ã€‚ çœ‹åˆ°äº†å—ï¼Ÿâ€æ‰“æ‰â€çš„æ„æ€å°±æ˜¯æŠŠbinderå¯¹è±¡æ•´ç†æˆflat_binder_objectå˜é‡ï¼Œå¦‚æœæ‰“æ‰çš„æ˜¯binderå®ä½“ï¼Œé‚£ä¹ˆflat_binder_objectç”¨cookieåŸŸè®°å½•binderå®ä½“çš„æŒ‡é’ˆï¼Œå³BBinderæŒ‡é’ˆï¼Œè€Œå¦‚æœæ‰“æ‰çš„æ˜¯binderä»£ç†ï¼Œé‚£ä¹ˆflat_binder_objectç”¨handleåŸŸè®°å½•çš„binderä»£ç†çš„å¥æŸ„å€¼ã€‚ æ€»ç»“ï¼šParcelçš„æ•°æ®åŒºåŸŸåˆ†ä¸¤ä¸ªéƒ¨åˆ†ï¼šmDataå’ŒmObjectsï¼Œæ‰€æœ‰çš„æ•°æ®ä¸ç®¡æ˜¯åŸºç¡€æ•°æ®ç±»å‹è¿˜æ˜¯å¯¹è±¡å®ä½“ï¼Œå…¨éƒ½è¿½åŠ åˆ°mDataé‡Œï¼ŒmObjectsæ˜¯ä¸€ä¸ªåç§»é‡æ•°ç»„ï¼Œè®°å½•æ‰€æœ‰å­˜æ”¾åœ¨mDataä¸­çš„flat_binder_objectå®ä½“çš„åç§»é‡ã€‚ 3.2.3ã€finish_flatten_binder()å°†flat_binder_objectå†™å…¥outã€‚ 12345inline static status_t finish_flatten_binder( const sp&lt;IBinder&gt;&amp; , const flat_binder_object&amp; flat, Parcel* out)&#123; return out-&gt;writeObject(flat, false);&#125; ç„¶åflatten_binder()è°ƒç”¨äº†ä¸€ä¸ªå…³é”®çš„finish_flatten_binder()å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šè®°å½•ä¸‹åˆšåˆšè¢«æ‰å¹³åŒ–çš„flat_binder_objectåœ¨parcelä¸­çš„ä½ç½®ã€‚è¯´å¾—æ›´è¯¦ç»†ç‚¹å„¿å°±æ˜¯ï¼Œparcelå¯¹è±¡å†…éƒ¨ä¼šæœ‰ä¸€ä¸ªbufferï¼Œè®°å½•ç€parcelä¸­æ‰€æœ‰æ‰å¹³åŒ–çš„æ•°æ®ï¼Œæœ‰äº›æ‰å¹³æ•°æ®æ˜¯æ™®é€šæ•°æ®ï¼Œè€Œå¦ä¸€äº›æ‰å¹³æ•°æ®åˆ™è®°å½•ç€binderå¯¹è±¡ã€‚æ‰€ä»¥parcelä¸­ä¼šæ„é€ å¦ä¸€ä¸ªmObjectsæ•°ç»„ï¼Œä¸“é—¨è®°å½•é‚£äº›binderæ‰å¹³æ•°æ®æ‰€åœ¨çš„ä½ç½®ï¼Œç¤ºæ„å›¾å¦‚ä¸‹ï¼š ä¸€æ—¦åˆ°äº†å‘é©±åŠ¨å±‚ä¼ é€’æ•°æ®çš„æ—¶å€™ï¼ŒIPCThreadState::writeTransactionData()ä¼šå…ˆæŠŠParcelæ•°æ®æ•´ç†æˆä¸€ä¸ªbinder_transaction_dataæ•°æ® 1234567891011121314151617181920212223242526272829303132333435status_t IPCThreadState::writeTransactionData(int32_t cmd, uint32_t binderFlags, int32_t handle, uint32_t code, const Parcel&amp; data, status_t* statusBuffer)&#123; binder_transaction_data tr; tr.target.ptr = 0; /* Don't pass uninitialized stack data to a remote process */ tr.target.handle = handle; tr.code = code; tr.flags = binderFlags; tr.cookie = 0; tr.sender_pid = 0; tr.sender_euid = 0; const status_t err = data.errorCheck(); if (err == NO_ERROR) &#123; tr.data_size = data.ipcDataSize(); tr.data.ptr.buffer = data.ipcData(); tr.offsets_size = data.ipcObjectsCount()*sizeof(binder_size_t); tr.data.ptr.offsets = data.ipcObjects(); &#125; else if (statusBuffer) &#123; tr.flags |= TF_STATUS_CODE; *statusBuffer = err; tr.data_size = sizeof(status_t); tr.data.ptr.buffer = reinterpret_cast&lt;uintptr_t&gt;(statusBuffer); tr.offsets_size = 0; tr.data.ptr.offsets = 0; &#125; else &#123; return (mLastError = err); &#125; mOut.writeInt32(cmd); mOut.write(&amp;tr, sizeof(tr)); return NO_ERROR;&#125; 3.2.4 ã€waitForResponse()1234567891011121314151617181920212223status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; int32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break;//ç›®çš„å°±æ˜¯æŠŠä¸Šé¢æ‰“åŒ…çš„mOutæ•°æ®ç»™kernel,æ¥ç€çœ‹taklWithDriver(); cmd = mIn.readInt32(); &#125; switch (cmd) &#123; case BR_REPLY: ...... goto finish; default: err = executeCommand(cmd); break; &#125; &#125;finish: ..... return err;&#125; è¯¥å‡½æ•°æ˜¯ä¸serviceManageré€šä¿¡çš„ä¸»è¦å‡½æ•°ï¼Œé¦–å…ˆä¼šè°ƒç”¨talkWithDriver()æ–¹æ³•ï¼Œå°†ä¹‹å‰çš„æ‰“åŒ…åœ¨mOutä¸­çš„æ•°æ®æ‰“åŒ…æˆstruct binder_write_read å¯¹è±¡ï¼Œå¹¶é€šè¿‡ioctrlå‘é€ç»™kernelã€‚ 3.2.5ã€ IPCThreadState::talkWithDriver12345678910111213141516171819202122232425262728status_t IPCThreadState::talkWithDriver(bool doReceive)&#123; binder_write_read bwr; const bool needRead = mIn.dataPosition() &gt;= mIn.dataSize(); const size_t outAvail = (!doReceive || needRead) ? mOut.dataSize() : 0; //doReceiveå‚æ•°ï¼Œé»˜è®¤æ˜¯ä¸ºtrue,ä¸Šé¢æˆ‘ä»¬çœ‹åˆ°æ²¡æœ‰ä¼ å‚æ•°ï¼Œé‚£ä¹ˆdoReceive = 1ï¼› bwr.write_size = outAvail; bwr.write_buffer = (uintptr_t)mOut.data(); //å°†mOutæ•°æ®æŒ‡é’ˆå­˜æ”¾åˆ°è¿™é‡Œ,è¿™å°±æ˜¯æˆ‘ä»¬ä¸Šé¢æ‰“åŒ…çš„æ•°æ®ã€‚ // This is what we'll read. if (doReceive &amp;&amp; needRead) &#123; bwr.read_size = mIn.dataCapacity(); //æ³¨æ„è¿™é‡Œæ•°æ®çš„å¤§å°ï¼Œåœ¨æˆ‘ä»¬new IPCThreadStateå¯¹è±¡æ—¶ï¼Œå·²ç»åˆå§‹åŒ–ä¸º256. bwr.read_buffer = (uintptr_t)mIn.data(); //mInæ•°æ®æŒ‡é’ˆï¼Œæ”¾åˆ°è¿™é‡Œ &#125; else &#123; bwr.read_size = 0; bwr.read_buffer = 0; &#125; //...... bwr.write_consumed = 0; bwr.read_consumed = 0; status_t err; do &#123; if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= 0) //è¿™é‡Œé€šè¿‡ioctlå°†æ•°æ®å†™ç»™kernel ..... &#125; while (err == -EINTR); return err;&#125; è¯¥å‡½æ•°çš„ä½œç”¨å°±æ˜¯å°†ä¹‹å‰æ‰“åŒ…çš„æ•°æ®é€šè¿‡ç³»ç»Ÿè°ƒç”¨ioctlå‘é€ç»™kernelï¼Œæœ€ç»ˆå‘é€ç»™kernelçš„æ•°æ®æ˜¯struct binder_write_readå¯¹è±¡ã€‚è¯¥å¯¹è±¡å·²ç»è¢«æ‰“åŒ…äº†3æ¬¡ï¼Œå®ƒä»¬çš„åŒ…å«å…³ç³»å¦‚ä¸‹æ‰€ç¤ºã€‚ 3.2.6ã€Clientè·å–æœåŠ¡ã€å¤„ç†å›å¤æ•°æ®è¿‡ç¨‹å†…æ ¸ä¼šå”¤é†’Clientè¿›ç¨‹å¤„ç†å›å¤æ¶ˆæ¯ã€‚ 12345678910111213141516171819202122232425262728status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)&#123; int32_t cmd; int32_t err; while (1) &#123; if ((err=talkWithDriver()) &lt; NO_ERROR) break; ... cmd = mIn.readInt32(); switch (cmd) &#123; case BR_REPLY: &#123; binder_transaction_data tr; err = mIn.read(&amp;tr, sizeof(tr)); if (reply) &#123; if ((tr.flags &amp; TF_STATUS_CODE) == 0) &#123; //å½“replyå¯¹è±¡å›æ”¶æ—¶ï¼Œåˆ™ä¼šè°ƒç”¨freeBufferæ¥å›æ”¶å†…å­˜ reply-&gt;ipcSetDataReference( reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer), tr.data_size, reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets), tr.offsets_size/sizeof(binder_size_t), freeBuffer, this); &#125; ... &#125; ... return err;&#125; 3.2.7ã€Parcel::ipcSetDataReference12345678910111213141516171819202122232425262728void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize, const binder_size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)&#123; binder_size_t minOffset = 0; freeDataNoInit(); mError = NO_ERROR; mData = const_cast&lt;uint8_t*&gt;(data); //è¿™æ˜¯æœ‰4ä¸ªå­—èŠ‚çš„bufferã€‚ä¸”å­˜æ”¾çš„æ•°æ®æ˜¯0 mDataSize = mDataCapacity = dataSize; //ä¹‹å‰ç”³è¯·çš„å¤§å°å°±æ˜¯4ä¸ªå­—èŠ‚ã€‚ //ALOGI(\"setDataReference Setting data size of %p to %lu (pid=%d)\", this, mDataSize, getpid()); mDataPos = 0; ALOGV(\"setDataReference Setting data pos of %p to %zu\", this, mDataPos); mObjects = const_cast&lt;binder_size_t*&gt;(objects); //binderå¯¹è±¡å…¶å®åœ°å€ mObjectsSize = mObjectsCapacity = objectsCount; //binderå¯¹è±¡çš„ä¸ªæ•°ã€‚ mNextObjectHint = 0; mOwner = relFunc; //é‡Šæ”¾å†…å­˜çš„å‡½æ•°ï¼Œåé¢æˆ‘ä»¬å°±ä¸è¿›è¡Œäº†ã€‚ mOwnerCookie = relCookie; for (size_t i = 0; i &lt; mObjectsSize; i++) &#123; binder_size_t offset = mObjects[i]; if (offset &lt; minOffset) &#123; ALOGE(\"%s: bad object offset %\"PRIu64\" &lt; %\"PRIu64\"\\n\", __func__, (uint64_t)offset, (uint64_t)minOffset); mObjectsSize = 0; break; &#125; minOffset = offset + sizeof(flat_binder_object); &#125; scanForFds();&#125; ä¸Šé¢åšçš„å·¥ä½œåªæ˜¯å°†äº‹åŠ¡æ•°æ®åˆ†åˆ«å®‰æ”¾åˆ°å½“å‰Parcelå¯¹è±¡çš„ç›¸åº”ä½ç½®ã€‚å…¶ä¸­scanForFdsï¼ˆï¼‰æ˜¯ä¸ºäº†æŸ¥æ‰¾è¿”å›æ¥çš„æ•°æ®ä¸­æ˜¯å¦æœ‰binderå¯¹è±¡ï¼Œè¿™ä¸ªåœ¨è·å–ä»£ç†å¯¹è±¡æ—¶æœ‰ç”¨ã€‚ 3.2.8ã€readStrongBinder()[-&gt; Parcel.java] readStrongBinderçš„è¿‡ç¨‹åŸºæœ¬æ˜¯writeStrongBinderé€†è¿‡ç¨‹ã€‚ 1234567static jobject android_os_Parcel_readStrongBinder(JNIEnv* env, jclass clazz, jlong nativePtr) &#123; Parcel* parcel = reinterpret_cast&lt;Parcel*&gt;(nativePtr); if (parcel != NULL) &#123; return javaObjectForIBinder(env, parcel-&gt;readStrongBinder()); &#125; return NULL;&#125; javaObjectForIBinder å°†nativeå±‚BpBinderå¯¹è±¡è½¬æ¢ä¸ºJavaå±‚BinderProxyå¯¹è±¡ã€‚ 3.2.9ã€readStrongBinder(C++)[-&gt; Parcel.cpp] 123456sp&lt;IBinder&gt; Parcel::readStrongBinder() const&#123; sp&lt;IBinder&gt; val; unflatten_binder(ProcessState::self(), *this, &amp;val); return val;&#125; 3.2.10ã€unflatten_binder()[-&gt; Parcel.cpp] 12345678910111213141516status_t unflatten_binder(const sp&lt;ProcessState&gt;&amp; proc, const Parcel&amp; in, sp&lt;IBinder&gt;* out) &#123; const flat_binder_object* flat = in.readObject(false); if (flat) &#123; switch (flat-&gt;type) &#123; case BINDER_TYPE_BINDER: *out = reinterpret_cast&lt;IBinder*&gt;(flat-&gt;cookie); return finish_unflatten_binder(NULL, *flat, in); case BINDER_TYPE_HANDLE: *out = proc-&gt;getStrongProxyForHandle(flat-&gt;handle); //åˆ›å»ºBpBinderå¯¹è±¡ return finish_unflatten_binder( static_cast&lt;BpBinder*&gt;(out-&gt;get()), *flat, in); &#125; &#125; return BAD_TYPE;&#125; è¯´æ˜ï¼šreadObject()çš„ä½œç”¨æ˜¯ä»Parcelä¸­è¯»å–å‡ºå®ƒæ‰€ä¿å­˜çš„flat_binder_objectç±»å‹çš„å¯¹è±¡ã€‚è¯¥å¯¹è±¡çš„ç±»å‹æ˜¯BINDER_TYPE_HANDLEï¼Œå› æ­¤ä¼šæŒ‡å‘BINDER_TYPE_HANDLEå¯¹åº”çš„switchåˆ†æ”¯ã€‚ (01) è¿™é‡Œçš„procæ˜¯ProcessStateå¯¹è±¡ï¼Œæ‰§è¡Œproc-&gt;getStrongProxyForHandle()ä¼šå°†å¥æŸ„(MediaPlayerServiceçš„Binderå¼•ç”¨æè¿°)ä¿å­˜åˆ°ProcessStateçš„é“¾è¡¨ä¸­ï¼Œç„¶åå†åˆ›å»ºå¹¶è¿”å›è¯¥å¥æŸ„çš„BpBinderå¯¹è±¡(å³Binderçš„ä»£ç†)ã€‚åœ¨Android Binderæœºåˆ¶(å››) defaultServiceManager()çš„å®ç°ä¸­æœ‰getStrongProxyForHandle()çš„è¯¦ç»†è¯´æ˜ï¼Œä¸‹é¢åªç»™å‡ºgetStrongProxyForHandle()ä»£ç ã€‚ (02) finish_unflatten_binder()ä¸­åªæœ‰return NO_ERRORã€‚ 3.2.11ã€getStrongProxyForHandle()[-&gt; ProcessState.cpp] 123456789101112131415161718192021222324sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)&#123; sp&lt;IBinder&gt; result; AutoMutex _l(mLock); //æŸ¥æ‰¾handleå¯¹åº”çš„èµ„æºé¡¹ handle_entry* e = lookupHandleLocked(handle); if (e != NULL) &#123; IBinder* b = e-&gt;binder; if (b == NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123; ... //å½“handleå€¼æ‰€å¯¹åº”çš„IBinderä¸å­˜åœ¨æˆ–å¼±å¼•ç”¨æ— æ•ˆæ—¶ï¼Œåˆ™åˆ›å»ºBpBinderå¯¹è±¡ b = new BpBinder(handle); e-&gt;binder = b; if (b) e-&gt;refs = b-&gt;getWeakRefs(); result = b; &#125; else &#123; result.force_set(b); e-&gt;refs-&gt;decWeak(this); &#125; &#125; return result;&#125; ç»è¿‡è¯¥æ–¹æ³•ï¼Œæœ€ç»ˆåˆ›å»ºäº†æŒ‡å‘BinderæœåŠ¡ç«¯çš„BpBinderä»£ç†å¯¹è±¡ã€‚ ï¼ˆ4ï¼‰ã€Android Binderç³»ç»Ÿ-Nativeå±‚è·å–helloæœåŠ¡ç»è¿‡å‰é¢çš„åˆ†æï¼ŒçŸ¥é“æµç¨‹åŸºæœ¬ç±»ä¼¼ï¼Œè¿™é‡Œä¸å†ç»§ç»­åˆ†æè·å–helloæœåŠ¡ äº”ã€Android Binderç³»ç»Ÿ-Framwork-Javaå±‚ï¼ˆ1ï¼‰ã€Android Binderç³»ç»ŸJavaå±‚ä¸»è¦ç»“æ„ Androidåº”ç”¨ç¨‹åºä½¿ç”¨Javaè¯­è¨€å¼€å‘ï¼ŒBinderæ¡†æ¶è‡ªç„¶ä¹Ÿå°‘ä¸äº†åœ¨Javaå±‚æä¾›æ¥å£ã€‚ å‰æ–‡ä¸­æˆ‘ä»¬çœ‹åˆ°ï¼ŒBinderæœºåˆ¶åœ¨C++å±‚å·²ç»æœ‰äº†å®Œæ•´çš„å®ç°ã€‚å› æ­¤Javaå±‚å®Œå…¨ä¸ç”¨é‡å¤å®ç°ï¼Œè€Œæ˜¯é€šè¿‡JNIè¡”æ¥äº†C++å±‚ä»¥å¤ç”¨å…¶å®ç°ã€‚ ä¸‹å›¾æè¿°äº†Binder Framework Javaå±‚åˆ°C++å±‚çš„è¡”æ¥å…³ç³»ã€‚ è¿™é‡Œå¯¹å›¾ä¸­Javaå±‚å’ŒJNIå±‚çš„å‡ ä¸ªç±»åšä¸€ä¸‹è¯´æ˜( å…³äºC++å±‚çš„è®²è§£è¯·çœ‹è¿™é‡Œ )ï¼š è¿™é‡Œçš„IInterfaceï¼ŒIBinderå’ŒC++å±‚çš„ä¸¤ä¸ªç±»æ˜¯åŒåçš„ã€‚è¿™ä¸ªåŒåå¹¶ä¸æ˜¯å·§åˆï¼šå®ƒä»¬ä¸ä»…ä»…åŒåï¼Œå®ƒä»¬æ‰€èµ·çš„ä½œç”¨ï¼Œä»¥åŠå…¶ä¸­åŒ…å«çš„æ¥å£éƒ½æ˜¯å‡ ä¹ä¸€æ ·çš„ï¼ŒåŒºåˆ«ä»…ä»…åœ¨äºä¸€ä¸ªæ˜¯C++å±‚ï¼Œä¸€ä¸ªæ˜¯Javaå±‚è€Œå·²ã€‚ é™¤äº†IInterfaceï¼ŒIBinderä¹‹å¤–ï¼Œè¿™é‡ŒBinderä¸BinderProxyç±»ä¹Ÿæ˜¯ä¸C++çš„ç±»å¯¹åº”çš„ï¼Œä¸‹é¢åˆ—å‡ºäº†Javaå±‚å’ŒC++å±‚ç±»çš„å¯¹åº”å…³ç³»ï¼š é™¤äº†IInterfaceï¼ŒIBinderä¹‹å¤–ï¼Œè¿™é‡ŒBinderä¸BinderProxyç±»ä¹Ÿæ˜¯ä¸C++çš„ç±»å¯¹åº”çš„ï¼Œä¸‹é¢åˆ—å‡ºäº†Javaå±‚å’ŒC++å±‚ç±»çš„å¯¹åº”å…³ç³»ï¼š ï¼ˆ2ï¼‰ã€JNIçš„è¡”æ¥JNIå…¨ç§°æ˜¯Java Native Interfaceï¼Œè¿™ä¸ªæ˜¯ç”±Javaè™šæ‹Ÿæœºæä¾›çš„æœºåˆ¶ã€‚è¿™ä¸ªæœºåˆ¶ä½¿å¾—nativeä»£ç å¯ä»¥å’ŒJavaä»£ç äº’ç›¸é€šè®¯ã€‚ç®€å•æ¥è¯´å°±æ˜¯ï¼šæˆ‘ä»¬å¯ä»¥åœ¨C/C++ç«¯è°ƒç”¨Javaä»£ç ï¼Œä¹Ÿå¯ä»¥åœ¨Javaç«¯è°ƒç”¨C/C++ä»£ç ã€‚ å…³äºJNIçš„è¯¦ç»†è¯´æ˜ï¼Œå¯ä»¥å‚è§Oracleçš„å®˜æ–¹æ–‡æ¡£ï¼šJava Native Interface ï¼Œè¿™é‡Œä¸å¤šè¯´æ˜ã€‚ å®é™…ä¸Šï¼Œåœ¨Androidä¸­å¾ˆå¤šçš„æœåŠ¡æˆ–è€…æœºåˆ¶éƒ½æ˜¯åœ¨C/C++å±‚å®ç°çš„ï¼Œæƒ³è¦å°†è¿™äº›å®ç°å¤ç”¨åˆ°Javaå±‚ï¼Œå°±å¿…é¡»é€šè¿‡JNIè¿›è¡Œè¡”æ¥ã€‚AOSPæºç ä¸­ï¼Œ/frameworks/base/core/jni/ ç›®å½•ä¸‹çš„æºç å°±æ˜¯ä¸“é—¨ç”¨æ¥å¯¹æ¥Frameworkå±‚çš„JNIå®ç°çš„ã€‚ çœ‹ä¸€ä¸‹Binder.javaçš„å®ç°å°±ä¼šå‘ç°ï¼Œè¿™é‡Œé¢æœ‰ä¸å°‘çš„æ–¹æ³•éƒ½æ˜¯ç”¨nativeå…³é”®å­—ä¿®é¥°çš„ï¼Œå¹¶ä¸”æ²¡æœ‰æ–¹æ³•å®ç°ä½“ï¼Œè¿™äº›æ–¹æ³•å…¶å®éƒ½æ˜¯åœ¨C++ä¸­android_util_Binder.cppå®ç°çš„ï¼š é‚£ä¹ˆï¼Œé‚£ä¹ˆï¼ŒC++æ˜¯å¦‚ä½•è°ƒç”¨Javaçš„å‘¢ï¼Ÿæœ€å…³é”®çš„ï¼Œlibbinderä¸­çš„BBinder::onTransactæ˜¯å¦‚ä½•èƒ½å¤Ÿè°ƒç”¨åˆ°Javaä¸­çš„Binder::onTransactçš„å‘¢ï¼Ÿ è¿™æ®µé€»è¾‘å°±æ˜¯android_util_Binder.cppä¸­JavaBBinder::onTransactä¸­å¤„ç†çš„äº†ã€‚JavaBBinderæ˜¯BBinderå­ç±»ï¼Œå…¶ç±»ç»“æ„å¦‚ä¸‹ï¼šlibbinderä¸­çš„BBinder::onTransactæ˜¯å¦‚ä½•èƒ½å¤Ÿè°ƒç”¨åˆ°Javaä¸­çš„Binder::onTransactçš„å‘¢ï¼Ÿ JavaBBinder::onTransactå…³é”®ä»£ç å¦‚ä¸‹ï¼š 123456789101112virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0)&#123; JNIEnv* env = javavm_to_jnienv(mVM); IPCThreadState* thread_state = IPCThreadState::self(); const int32_t strict_policy_before = thread_state-&gt;getStrictModePolicy(); jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); ...&#125; è¯·æ³¨æ„è¿™æ®µä»£ç ä¸­çš„è¿™ä¸€è¡Œï¼š 12jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags); è¿™ä¸€è¡Œä»£ç å…¶å®æ˜¯åœ¨è°ƒç”¨mObjectä¸Šoffsetä¸ºmExecTransactçš„æ–¹æ³•ã€‚è¿™é‡Œçš„å‡ ä¸ªå‚æ•°è¯´æ˜å¦‚ä¸‹ï¼š mObject æŒ‡å‘äº†Javaç«¯çš„Binderå¯¹è±¡ gBinderOffsets.mExecTransact æŒ‡å‘äº†Binderç±»çš„execTransactæ–¹æ³• data è°ƒç”¨execTransactæ–¹æ³•çš„å‚æ•° code, data, reply, flagséƒ½æ˜¯ä¼ é€’ç»™è°ƒç”¨æ–¹æ³•execTransactçš„å‚æ•° è€ŒJNIEnv.CallBooleanMethodè¿™ä¸ªæ–¹æ³•æ˜¯ç”±è™šæ‹Ÿæœºå®ç°çš„ã€‚å³ï¼šè™šæ‹Ÿæœºä¼šæä¾›nativeæ–¹æ³•æ¥è°ƒç”¨ä¸€ä¸ªJava Objectä¸Šçš„æ–¹æ³•ï¼ˆå…³äºAndroidä¸Šçš„Javaè™šæ‹Ÿæœºï¼Œä»Šåæˆ‘ä»¬ä¼šä¸“é—¨è®²è§£ï¼‰ã€‚ è¿™æ ·ï¼Œå°±åœ¨C++å±‚çš„JavaBBinder::onTransactä¸­è°ƒç”¨äº†Javaå±‚Binder::execTransactæ–¹æ³•ã€‚è€Œåœ¨Binder::execTransactæ–¹æ³•ä¸­ï¼Œåˆè°ƒç”¨äº†è‡ªèº«çš„onTransactæ–¹æ³•ï¼Œç”±æ­¤ä¿è¯æ•´ä¸ªè¿‡ç¨‹ä¸²è”äº†èµ·æ¥ï¼š 123456789101112131415161718192021222324252627282930313233343536private boolean execTransact(int code, long dataObj, long replyObj, int flags) &#123; Parcel data = Parcel.obtain(dataObj); Parcel reply = Parcel.obtain(replyObj); boolean res; try &#123; res = onTransact(code, data, reply, flags); &#125; catch (RemoteException|RuntimeException e) &#123; if (LOG_RUNTIME_EXCEPTION) &#123; Log.w(TAG, \"Caught a RuntimeException from the binder stub implementation.\", e); &#125; if ((flags &amp; FLAG_ONEWAY) != 0) &#123; if (e instanceof RemoteException) &#123; Log.w(TAG, \"Binder call failed.\", e); &#125; else &#123; Log.w(TAG, \"Caught a RuntimeException from the binder stub implementation.\", e); &#125; &#125; else &#123; reply.setDataPosition(0); reply.writeException(e); &#125; res = true; &#125; catch (OutOfMemoryError e) &#123; RuntimeException re = new RuntimeException(\"Out of memory\", e); reply.setDataPosition(0); reply.writeException(re); res = true; &#125; checkParcel(this, code, reply, \"Unreasonably large binder reply buffer\"); reply.recycle(); data.recycle(); StrictMode.clearGatheredViolations(); return res;&#125; ï¼ˆ3ï¼‰ã€Javaå±‚çš„ServiceManager é€šè¿‡è¿™ä¸ªç±»å›¾æˆ‘ä»¬çœ‹åˆ°ï¼ŒJavaå±‚çš„ServiceManagerå’ŒC++å±‚çš„æ¥å£æ˜¯ä¸€æ ·çš„ã€‚ é€šè¿‡è¿™ä¸ªç±»å›¾æˆ‘ä»¬çœ‹åˆ°ï¼ŒJavaå±‚çš„ServiceManagerå’ŒC++å±‚çš„æ¥å£æ˜¯ä¸€æ ·çš„ã€‚ ç„¶åæˆ‘ä»¬å†é€‰å–addServiceæ–¹æ³•çœ‹ä¸€ä¸‹å®ç°ï¼š 1234567891011121314151617public static void addService(String name, IBinder service, boolean allowIsolated) &#123; try &#123; getIServiceManager().addService(name, service, allowIsolated); &#125; catch (RemoteException e) &#123; Log.e(TAG, \"error in addService\", e); &#125;&#125; private static IServiceManager getIServiceManager() &#123; if (sServiceManager != null) &#123; return sServiceManager; &#125; // Find the service manager sServiceManager = ServiceManagerNative.asInterface(BinderInternal.getContextObject()); return sServiceManager;&#125; å¾ˆæ˜¾ç„¶ï¼Œè¿™æ®µä»£ç ä¸­ï¼Œæœ€å…³é”®å°±æ˜¯ä¸‹é¢è¿™ä¸ªè°ƒç”¨ï¼š 1ServiceManagerNative.asInterface(BinderInternal.getContextObject()); ç„¶åæˆ‘ä»¬éœ€è¦å†çœ‹ä¸€ä¸‹BinderInternal.getContextObject()å’ŒServiceManagerNative.asInterfaceä¸¤ä¸ªæ–¹æ³•ã€‚ BinderInternal.getContextObject()æ˜¯ä¸€ä¸ªJNIæ–¹æ³•ï¼Œå…¶å®ç°ä»£ç åœ¨android_util_Binder.cppä¸­ï¼š 12345static jobject android_os_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123; sp&lt;IBinder&gt; b = ProcessState::self()-&gt;getContextObject(NULL); return javaObjectForIBinder(env, b);&#125; è€ŒServiceManagerNative.asInterfaceçš„å®ç°å’Œå…¶ä»–çš„BinderæœåŠ¡æ˜¯ä¸€æ ·çš„å¥—è·¯ï¼š 12345678910111213static public IServiceManager asInterface(IBinder obj)&#123; if (obj == null) &#123; return null; &#125; IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ServiceManagerProxy(obj);&#125; å…ˆé€šè¿‡queryLocalInterfaceæŸ¥çœ‹èƒ½ä¸èƒ½è·å¾—æœ¬åœ°Binderï¼Œå¦‚æœæ— æ³•è·å–ï¼Œåˆ™åˆ›å»ºå¹¶è¿”å›ServiceManagerProxyå¯¹è±¡ã€‚ è€ŒServiceManagerProxyè‡ªç„¶ä¹Ÿæ˜¯å’Œå…¶ä»–Binder Proxyä¸€æ ·çš„å®ç°å¥—è·¯ï¼š 123456789101112public void addService(String name, IBinder service, boolean allowIsolated) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); data.writeStrongBinder(service); data.writeInt(allowIsolated ? 1 : 0); mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0); reply.recycle(); data.recycle();&#125; æ¥ä¸‹æ¥çš„è°ƒç”¨æµç¨‹å‰é¢å·²ç»åˆ†æè¿‡äº†ï¼Œåœ¨æ­¤å°±ä¸å†åˆ†æäº†ã€‚ å…­ã€Android Binderç³»ç»Ÿ-AIDLä½œä¸ºBinderæœºåˆ¶çš„æœ€åä¸€ä¸ªéƒ¨åˆ†å†…å®¹ï¼Œæˆ‘ä»¬æ¥è®²è§£ä¸€ä¸‹å¼€å‘è€…ç»å¸¸ä½¿ç”¨çš„AIDLæœºåˆ¶æ˜¯æ€ä¹ˆå›äº‹ã€‚ AIDLå…¨ç§°æ˜¯Android Interface Definition Languageï¼Œå®ƒæ˜¯Android SDKæä¾›çš„ä¸€ç§æœºåˆ¶ã€‚å€ŸåŠ©è¿™ä¸ªæœºåˆ¶ï¼Œåº”ç”¨å¯ä»¥æä¾›è·¨è¿›ç¨‹çš„æœåŠ¡ä¾›å…¶ä»–åº”ç”¨ä½¿ç”¨ã€‚AIDLçš„è¯¦ç»†è¯´æ˜å¯ä»¥å‚è§å®˜æ–¹å¼€å‘æ–‡æ¡£ï¼šhttps://developer.android.com/guide/components/aidl.html ã€‚ è¿™é‡Œï¼Œæˆ‘ä»¬å°±ä»¥å®˜æ–¹æ–‡æ¡£ä¸Šçš„ä¾‹å­çœ‹æ¥ä¸€ä¸‹AIDLä¸Binderæ¡†æ¶çš„å…³ç³»ã€‚ å¼€å‘ä¸€ä¸ªåŸºäºAIDLçš„Serviceéœ€è¦ä¸‰ä¸ªæ­¥éª¤ï¼š å®šä¹‰ä¸€ä¸ª.aidlæ–‡ä»¶ å®ç°æ¥å£ æš´éœ²æ¥å£ç»™å®¢æˆ·ç«¯ä½¿ç”¨ aidlæ–‡ä»¶ä½¿ç”¨Javaè¯­è¨€çš„è¯­æ³•æ¥å®šä¹‰ï¼Œæ¯ä¸ª.aidlæ–‡ä»¶åªèƒ½åŒ…å«ä¸€ä¸ªinterfaceï¼Œå¹¶ä¸”è¦åŒ…å«interfaceçš„æ‰€æœ‰æ–¹æ³•å£°æ˜ã€‚ é»˜è®¤æƒ…å†µä¸‹ï¼ŒAIDLæ”¯æŒçš„æ•°æ®ç±»å‹åŒ…æ‹¬ï¼š åŸºæœ¬æ•°æ®ç±»å‹ï¼ˆå³intï¼Œlongï¼Œcharï¼Œbooleanç­‰ï¼‰ String CharSequence Listï¼ˆListçš„å…ƒç´ ç±»å‹å¿…é¡»æ˜¯AIDLæ”¯æŒçš„ï¼‰ Mapï¼ˆMapä¸­çš„å…ƒç´ å¿…é¡»æ˜¯AIDLæ”¯æŒçš„ï¼‰ å¯¹äºAIDLä¸­çš„æ¥å£ï¼Œå¯ä»¥åŒ…å«0ä¸ªæˆ–å¤šä¸ªå‚æ•°ï¼Œå¯ä»¥è¿”å›voidæˆ–ä¸€ä¸ªå€¼ã€‚æ‰€æœ‰éåŸºæœ¬ç±»å‹çš„å‚æ•°å¿…é¡»åŒ…å«ä¸€ä¸ªæè¿°æ˜¯æ•°æ®æµå‘çš„æ ‡ç­¾ï¼Œå¯èƒ½çš„å–å€¼æ˜¯ï¼šinï¼Œoutæˆ–è€…inoutã€‚ ä¸‹é¢æ˜¯ä¸€ä¸ªaidlæ–‡ä»¶çš„ç¤ºä¾‹ï¼š 12345678910111213141516// IRemoteService.aidlpackage com.example.android;// Declare any non-default types here with import statements/** Example service interface */interface IRemoteService &#123; /** Request the process ID of this service, to do evil things with it. */ int getPid(); /** Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; è¿™ä¸ªæ–‡ä»¶ä¸­åŒ…å«äº†ä¸¤ä¸ªæ¥å£ ï¼š getPid ä¸€ä¸ªæ— å‚çš„æ¥å£ï¼Œè¿”å›å€¼ç±»å‹ä¸ºint basicTypesï¼ŒåŒ…å«äº†å‡ ä¸ªåŸºæœ¬ç±»å‹ä½œä¸ºå‚æ•°çš„æ¥å£ï¼Œæ— è¿”å›å€¼ å¯¹äºåŒ…å«.aidlæ–‡ä»¶çš„å·¥ç¨‹ï¼ŒAndroid IDEï¼ˆä»¥å‰æ˜¯Eclipseï¼Œç°åœ¨æ˜¯Android Studioï¼‰åœ¨ç¼–è¯‘é¡¹ç›®çš„æ—¶å€™ï¼Œä¼šä¸ºaidlæ–‡ä»¶ç”Ÿæˆå¯¹åº”çš„Javaæ–‡ä»¶ã€‚ é’ˆå¯¹ä¸Šé¢è¿™ä¸ªaidlæ–‡ä»¶ç”Ÿæˆçš„javaæ–‡ä»¶ä¸­åŒ…å«çš„ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åœ¨è¿™ä¸ªç”Ÿæˆçš„Javaæ–‡ä»¶ä¸­ï¼ŒåŒ…æ‹¬äº†ï¼š ä¸€ä¸ªåç§°ä¸ºIRemoteServiceçš„interfaceï¼Œè¯¥interfaceç»§æ‰¿è‡ªandroid.os.IInterfaceå¹¶ä¸”åŒ…å«äº†æˆ‘ä»¬åœ¨aidlæ–‡ä»¶ä¸­å£°æ˜çš„æ¥å£æ–¹æ³• IRemoteServiceä¸­åŒ…å«äº†ä¸€ä¸ªåç§°ä¸ºStubçš„é™æ€å†…éƒ¨ç±»ï¼Œè¿™ä¸ªç±»æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå®ƒç»§æ‰¿è‡ªandroid.os.Binderå¹¶ä¸”å®ç°äº†IRemoteServiceæ¥å£ã€‚è¿™ä¸ªç±»ä¸­åŒ…å«äº†ä¸€ä¸ªonTransactæ–¹æ³• Stubå†…éƒ¨åˆåŒ…å«äº†ä¸€ä¸ªåç§°ä¸ºProxyçš„é™æ€å†…éƒ¨ç±»ï¼ŒProxyç±»åŒæ ·å®ç°äº†IRemoteServiceæ¥å£ ä»”ç»†çœ‹ä¸€ä¸‹Stubç±»å’ŒProxyä¸¤ä¸ªä¸­åŒ…å«çš„æ–¹æ³•ï¼Œæ˜¯ä¸æ˜¯è§‰å¾—å¾ˆç†Ÿæ‚‰ï¼Ÿæ˜¯çš„ï¼Œè¿™é‡Œå’Œå‰é¢ä»‹ç»çš„æœåŠ¡å®ç°æ˜¯ä¸€æ ·çš„æ¨¡å¼ã€‚è¿™é‡Œæˆ‘ä»¬åˆ—ä¸€ä¸‹å„å±‚ç±»çš„å¯¹åº”å…³ç³»ï¼š C++å±‚ Javaå±‚ AIDL BpXXX XXXProxy IXXX.Stub.Proxy BnXXX XXXNative IXXX.Stub ä¸ºäº†æ•´ä¸ªç»“æ„çš„å®Œæ•´æ€§ï¼Œæœ€åæˆ‘ä»¬è¿˜æ˜¯æ¥çœ‹ä¸€ä¸‹ç”Ÿæˆçš„Stubå’ŒProxyç±»ä¸­çš„å®ç°é€»è¾‘ã€‚ Stubæ˜¯æä¾›ç»™å¼€å‘è€…å®ç°ä¸šåŠ¡çš„çˆ¶ç±»ï¼Œè€ŒProxyçš„å®ç°äº†å¯¹å¤–æä¾›çš„æ¥å£ã€‚Stubå’ŒProxyä¸¤ä¸ªç±»éƒ½æœ‰ä¸€ä¸ªasBinderçš„æ–¹æ³•ã€‚ Stubç±»ä¸­çš„asBinderå®ç°å°±æ˜¯è¿”å›è‡ªèº«å¯¹è±¡ï¼š 1234Overridepublic android.os.IBinder asBinder() &#123; return this;&#125; è€ŒProxyä¸­asBinderçš„å®ç°æ˜¯è¿”å›æ„é€ å‡½æ•°ä¸­è·å–çš„mRemoteå¯¹è±¡ï¼Œç›¸å…³ä»£ç å¦‚ä¸‹ï¼š 12345678910private android.os.IBinder mRemote;Proxy(android.os.IBinder remote) &#123; mRemote = remote;&#125;Overridepublic android.os.IBinder asBinder() &#123; return mRemote;&#125; è€Œè¿™é‡Œçš„mRemoteå¯¹è±¡å…¶å®å°±æ˜¯è¿œç¨‹æœåŠ¡åœ¨å½“å‰è¿›ç¨‹çš„æ ‡è¯†ã€‚ ä¸Šæ–‡æˆ‘ä»¬è¯´äº†ï¼ŒStubç±»æ˜¯ç”¨æ¥æä¾›ç»™å¼€å‘è€…å®ç°ä¸šåŠ¡é€»è¾‘çš„çˆ¶ç±»ï¼Œå¼€å‘è€…è€…ç»§æ‰¿è‡ªStubç„¶åå®Œæˆè‡ªå·±çš„ä¸šåŠ¡é€»è¾‘å®ç°ï¼Œä¾‹å¦‚è¿™æ ·ï¼š 123456789private final IRemoteService.Stub mBinder = new IRemoteService.Stub() &#123; public int getPid()&#123; return Process.myPid(); &#125; public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) &#123; // Does something &#125;&#125;; è€Œè¿™ä¸ªProxyç±»ï¼Œå°±æ˜¯ç”¨æ¥ç»™è°ƒç”¨è€…ä½¿ç”¨çš„å¯¹å¤–æ¥å£ã€‚æˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹Proxyä¸­çš„æ¥å£åˆ°åº•æ˜¯å¦‚ä½•å®ç°çš„ï¼š Proxyä¸­getPidæ–¹æ³•å®ç°å¦‚ä¸‹æ‰€ç¤ºï¼š 12345678910111213141516Overridepublic int getPid() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); int _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getPid, _data, _reply, 0); _reply.readException(); _result = _reply.readInt(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result;&#125; è¿™é‡Œå°±æ˜¯é€šè¿‡Parcelå¯¹è±¡ä»¥åŠtransactè°ƒç”¨å¯¹åº”è¿œç¨‹æœåŠ¡çš„æ¥å£ã€‚è€Œåœ¨Stubç±»ä¸­ï¼Œç”Ÿæˆçš„onTransactæ–¹æ³•å¯¹åº”çš„å¤„ç†äº†è¿™é‡Œçš„è¯·æ±‚ï¼š 123456789101112131415161718192021222324252627282930313233343536Overridepublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getPid: &#123; data.enforceInterface(DESCRIPTOR); int _result = this.getPid(); reply.writeNoException(); reply.writeInt(_result); return true; &#125; case TRANSACTION_basicTypes: &#123; data.enforceInterface(DESCRIPTOR); int _arg0; _arg0 = data.readInt(); long _arg1; _arg1 = data.readLong(); boolean _arg2; _arg2 = (0 != data.readInt()); float _arg3; _arg3 = data.readFloat(); double _arg4; _arg4 = data.readDouble(); java.lang.String _arg5; _arg5 = data.readString(); this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); reply.writeNoException(); return true; &#125; &#125; return super.onTransact(code, data, reply, flags);&#125; onTransact()æ‰€è¦åšçš„å°±æ˜¯ï¼š æ ¹æ®codeåŒºåˆ†è¯·æ±‚çš„æ˜¯å“ªä¸ªæ¥å£ é€šè¿‡dataæ¥è·å–è¯·æ±‚çš„å‚æ•° è°ƒç”¨ç”±å­ç±»å®ç°çš„æŠ½è±¡æ–¹æ³• æœ‰äº†å‰æ–‡çš„è®²è§£ï¼Œå¯¹äºè¿™éƒ¨åˆ†å†…å®¹åº”å½“ä¸éš¾ç†è§£äº†ã€‚ åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬ç»ˆäºè®²è§£å®ŒBinderäº†ã€‚ å®Œæ•´æ¡†æ¶ï¼š ä¸ƒã€å‚è€ƒæ–‡æ¡£(ç‰¹åˆ«æ„Ÿè°¢å„ä½å‰è¾ˆçš„åˆ†æå’Œå›¾ç¤º)ï¼šBinderæºç åˆ†ææ·±å…¥åˆ†æAndroid BinderBinderç³»åˆ— - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢Android Binderæœºåˆ¶(1) ~ (12) - Wangkuiwu.github.ioBinderæœºåˆ¶-å…³äºBinderçš„æ–‡ç«  - æ³¡åœ¨ç½‘ä¸Šçš„æ—¥å­ç†è§£Android Binderæœºåˆ¶ - Qiangbo.spaceåšå®¢çº¢èŒ¶ä¸€æ¯è¯Binder - æ‚ ç„¶çº¢èŒ¶Binderæ¡†æ¶è§£æAndroid Binderè¯¦è§£å›¾æ–‡è¯¦è§£ Android Binderè·¨è¿›ç¨‹é€šä¿¡æœºåˆ¶ åŸç†ç†è§£Android Binderæœºåˆ¶(1/3)ï¼šé©±åŠ¨ç¯‡-qiangbo.spaceç†è§£Android Binderæœºåˆ¶(2/3)ï¼šC++å±‚-qiangbo.spaceç†è§£Android Binderæœºåˆ¶(3/3)ï¼šJavaå±‚-qiangbo.spaceAndroid Binder åˆ†æâ€“ç³»åˆ—-light3moonAndroidå­¦ä¹ ç¬”è®°-Binder | Palanceâ€™s Blogandroidç³»ç»Ÿ -Binder - armwindçš„ä¸“æ  - CSDNåšå®¢Bettarwangçš„ä¸“æ  -Android Binderæœºåˆ¶æ·±å…¥å‰–æAndroidç³»ç»Ÿ - binder - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android è¾“å…¥å­ç³»ç»Ÿ - Input System åˆ†æ","slug":"Android-7-1-2-Android-N-Android-è¾“å…¥å­ç³»ç»Ÿ-Input-System","date":"2017-11-30T16:00:00.000Z","updated":"2018-04-19T14:29:52.579Z","comments":true,"path":"2017/12/01/Android-7-1-2-Android-N-Android-è¾“å…¥å­ç³»ç»Ÿ-Input-System/","link":"","permalink":"http://zhoujinjian.cc/2017/12/01/Android-7-1-2-Android-N-Android-è¾“å…¥å­ç³»ç»Ÿ-Input-System/","excerpt":"Android è¾“å…¥å­ç³»ç»Ÿæ¦‚è¿°:â— å½“æ—¶è¾“å…¥è®¾å¤‡ï¼ˆå¦‚è§¦æ‘¸å±ï¼Œé”®ç›˜ç­‰ï¼‰å¯ç”¨æ—¶ï¼ŒLinux Kernelä¼šåœ¨/dev/input/ä¸‹åˆ›å»ºåä¸ºevent0~eventNçš„è®¾å¤‡èŠ‚ç‚¹; å½“è¾“å…¥è®¾å¤‡ä¸å¯ç”¨æ—¶ï¼Œä¼šå°†ç›¸åº”çš„è®¾å¤‡èŠ‚ç‚¹åˆ é™¤ã€‚â— å½“ç”¨æˆ·æ“ä½œè¾“å…¥è®¾å¤‡æ—¶ï¼ŒLinux Kernelä¼šæ”¶åˆ°ç›¸åº”çš„ç¡¬ä»¶ä¸­æ–­ï¼Œç„¶åä¼šå°†ä¸­æ–­åŠ å·¥æˆåŸå§‹è¾“å…¥äº‹ä»¶ï¼ˆraw input eventï¼‰ï¼Œå¹¶å†™å…¥åˆ°è®¾å¤‡èŠ‚ç‚¹ä¸­ã€‚è€Œååœ¨ç”¨æˆ·ç©ºé—´å°±å¯ä»¥é€šè¿‡read()å‡½æ•°è¯»å–äº‹ä»¶æ•°æ®äº†ã€‚â— Androidè¾“å…¥ç³»ç»Ÿä¼šç›‘æ§/dev/input/ä¸‹çš„æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹ï¼Œå½“æŸä¸ªç»“ç‚¹æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œå°†æ•°æ®è¯»å‡ºå¹¶è¿›è¡Œä¸€ç³»åˆ—å¤„ç†ï¼Œç„¶ååœ¨å½“å‰ç³»ç»Ÿä¸­çš„æ‰€æœ‰çª—å£ï¼ˆWindowï¼‰ä¸­å¯»æ‰¾åˆé€‚çš„æ¥æ”¶è€…ï¼Œå¹¶æŠŠäº‹ä»¶æ´¾å‘ç»™å®ƒã€‚â— å…·ä½“æ¥è¯´ï¼ŒLinux Kernelå°†raw input eventå†™å…¥åˆ°è®¾å¤‡èŠ‚ç‚¹åï¼ŒInputReaderä¼šé€šè¿‡EventHubå°†åŸå§‹äº‹ä»¶è¯»å–å‡ºæ¥å¹¶ç¿»è¯‘åŠ å·¥ä¸ºAndroidè¾“å…¥äº‹ä»¶ï¼Œè€ŒåæŠŠå®ƒäº¤ç»™InputDispatcherã€‚InputDispatcheræ ¹æ®WMSï¼ˆWindowManagerServiceï¼‰æä¾›çš„çª—å£ä¿¡æ¯å°†äº‹ä»¶ä¼ é€’ç»™åˆé€‚çš„çª—å£ï¼Œè‹¥çª—å£ä¸ºå£çº¸/SurfaceViewç­‰ï¼Œåˆ™åˆ°äº†ç»ˆç‚¹ï¼›å¦åˆ™ä¼šç”±è¯¥Windowçš„ViewRootç»§ç»­åˆ†å‘åˆ°åˆé€‚çš„Viewã€‚","text":"Android è¾“å…¥å­ç³»ç»Ÿæ¦‚è¿°:â— å½“æ—¶è¾“å…¥è®¾å¤‡ï¼ˆå¦‚è§¦æ‘¸å±ï¼Œé”®ç›˜ç­‰ï¼‰å¯ç”¨æ—¶ï¼ŒLinux Kernelä¼šåœ¨/dev/input/ä¸‹åˆ›å»ºåä¸ºevent0~eventNçš„è®¾å¤‡èŠ‚ç‚¹; å½“è¾“å…¥è®¾å¤‡ä¸å¯ç”¨æ—¶ï¼Œä¼šå°†ç›¸åº”çš„è®¾å¤‡èŠ‚ç‚¹åˆ é™¤ã€‚â— å½“ç”¨æˆ·æ“ä½œè¾“å…¥è®¾å¤‡æ—¶ï¼ŒLinux Kernelä¼šæ”¶åˆ°ç›¸åº”çš„ç¡¬ä»¶ä¸­æ–­ï¼Œç„¶åä¼šå°†ä¸­æ–­åŠ å·¥æˆåŸå§‹è¾“å…¥äº‹ä»¶ï¼ˆraw input eventï¼‰ï¼Œå¹¶å†™å…¥åˆ°è®¾å¤‡èŠ‚ç‚¹ä¸­ã€‚è€Œååœ¨ç”¨æˆ·ç©ºé—´å°±å¯ä»¥é€šè¿‡read()å‡½æ•°è¯»å–äº‹ä»¶æ•°æ®äº†ã€‚â— Androidè¾“å…¥ç³»ç»Ÿä¼šç›‘æ§/dev/input/ä¸‹çš„æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹ï¼Œå½“æŸä¸ªç»“ç‚¹æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œå°†æ•°æ®è¯»å‡ºå¹¶è¿›è¡Œä¸€ç³»åˆ—å¤„ç†ï¼Œç„¶ååœ¨å½“å‰ç³»ç»Ÿä¸­çš„æ‰€æœ‰çª—å£ï¼ˆWindowï¼‰ä¸­å¯»æ‰¾åˆé€‚çš„æ¥æ”¶è€…ï¼Œå¹¶æŠŠäº‹ä»¶æ´¾å‘ç»™å®ƒã€‚â— å…·ä½“æ¥è¯´ï¼ŒLinux Kernelå°†raw input eventå†™å…¥åˆ°è®¾å¤‡èŠ‚ç‚¹åï¼ŒInputReaderä¼šé€šè¿‡EventHubå°†åŸå§‹äº‹ä»¶è¯»å–å‡ºæ¥å¹¶ç¿»è¯‘åŠ å·¥ä¸ºAndroidè¾“å…¥äº‹ä»¶ï¼Œè€ŒåæŠŠå®ƒäº¤ç»™InputDispatcherã€‚InputDispatcheræ ¹æ®WMSï¼ˆWindowManagerServiceï¼‰æä¾›çš„çª—å£ä¿¡æ¯å°†äº‹ä»¶ä¼ é€’ç»™åˆé€‚çš„çª—å£ï¼Œè‹¥çª—å£ä¸ºå£çº¸/SurfaceViewç­‰ï¼Œåˆ™åˆ°äº†ç»ˆç‚¹ï¼›å¦åˆ™ä¼šç”±è¯¥Windowçš„ViewRootç»§ç»­åˆ†å‘åˆ°åˆé€‚çš„Viewã€‚ æœ¬ç« æ¶‰åŠçš„æºä»£ç æ–‡ä»¶ååŠä½ç½®ï¼š frameworks/base/services/java/com/android/server/â— SystemServer.java frameworks/base/services/java/com/android/server/input/â— InputManagerService.java frameworks/base/services/java/com/android/server/wm/â— WindowManagerService.javaâ— WindowState.javaâ— InputMonitor.java frameworks/base/core/java/android/view/â— View.javaâ— ViewGroup.javaâ— InputEventReceiver.javaâ— ViewRootImpl.javaâ— IWindowSession.aidlâ— InputChannel.java frameworks/base/core/java/android/app/â— Activity.java frameworks/base/services/jni/â— android_view_InputChannel.cppâ— android_view_InputEventReceiver.cppâ— com_android_server_input_InputManagerService.cpp frameworks/native/services/inputflinger/â— InputManager.cppâ— EventHub.hâ— EventHub.cppâ— InputReader.hâ— InputReader.cppâ— InputListener.hâ— InputListener.cppâ— InputDispatcher.hâ— InputDispatcher.cpp frameworks/native/libs/input/â— InputTransport.cpp /frameworks/native/include/input/â— InputTransport.h åšå®¢åŸå›¾é“¾æ¥ä¸€ã€Inputç³»ç»Ÿå¿…å¤‡LinuxçŸ¥è¯†æ³¨ï¼šå¿…å¤‡çŸ¥è¯†å¯ç¨åé‡åˆ°å®é™…ä½¿ç”¨çš„åœ°æ–¹å†åšè¯¦ç»†äº†è§£ã€‚ ï¼ˆä¸€ï¼‰ã€å¿…å¤‡çš„LinuxçŸ¥è¯† inotifyå’Œepoll1ã€INotifyä»‹ç»ä¸ä½¿ç”¨INotifyæ˜¯ä¸€ä¸ªLinuxå†…æ ¸æ‰€æä¾›çš„ä¸€ç§æ–‡ä»¶ç³»ç»Ÿå˜åŒ–é€šçŸ¥æœºåˆ¶ã€‚å®ƒå¯ä»¥ä¸ºåº”ç”¨ç¨‹åºç›‘æ§æ–‡ä»¶ç³»ç»Ÿçš„å˜åŒ–ï¼Œå¦‚æ–‡ä»¶çš„æ–°å»ºã€åˆ é™¤ã€è¯»å†™ç­‰ã€‚INotifyæœºåˆ¶æœ‰ä¸¤ä¸ªåŸºæœ¬å¯¹è±¡ï¼Œåˆ†åˆ«ä¸ºinotifyå¯¹è±¡ä¸watchå¯¹è±¡ï¼Œéƒ½ä½¿ç”¨æ–‡ä»¶æè¿°ç¬¦è¡¨ç¤ºã€‚ inotifyå¯¹è±¡å¯¹åº”äº†ä¸€ä¸ªé˜Ÿåˆ—ï¼Œåº”ç”¨ç¨‹åºå¯ä»¥å‘inotifyå¯¹è±¡æ·»åŠ å¤šä¸ªç›‘å¬ã€‚å½“è¢«ç›‘å¬çš„äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œå¯ä»¥é€šè¿‡read()å‡½æ•°ä»inotifyå¯¹è±¡ä¸­å°†äº‹ä»¶ä¿¡æ¯è¯»å–å‡ºæ¥ã€‚Inotifyå¯¹è±¡å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼åˆ›å»ºï¼š 1int inotifyFd = inotify_init(); è€Œwatchå¯¹è±¡åˆ™ç”¨æ¥æè¿°æ–‡ä»¶ç³»ç»Ÿçš„å˜åŒ–äº‹ä»¶çš„ç›‘å¬ã€‚å®ƒæ˜¯ä¸€ä¸ªäºŒå…ƒç»„ï¼ŒåŒ…æ‹¬ç›‘å¬ç›®æ ‡å’Œäº‹ä»¶æ©ç ä¸¤ä¸ªå…ƒç´ ã€‚ç›‘å¬ç›®æ ‡æ˜¯æ–‡ä»¶ç³»ç»Ÿçš„ä¸€ä¸ªè·¯å¾„ï¼Œå¯ä»¥æ˜¯æ–‡ä»¶ä¹Ÿå¯ä»¥æ˜¯æ–‡ä»¶å¤¹ã€‚è€Œäº‹ä»¶æ©ç åˆ™è¡¨ç¤ºäº†éœ€è¦éœ€è¦ç›‘å¬çš„äº‹ä»¶ç±»å‹ï¼Œæ©ç ä¸­çš„æ¯ä¸€ä½ä»£è¡¨ä¸€ç§äº‹ä»¶ã€‚å¯ä»¥ç›‘å¬çš„äº‹ä»¶ç§ç±»å¾ˆå¤šï¼Œå…¶ä¸­å°±åŒ…æ‹¬æ–‡ä»¶çš„åˆ›å»º(IN_CREATE)ä¸åˆ é™¤(IN_DELETE)ã€‚è¯»è€…å¯ä»¥å‚é˜…ç›¸å…³èµ„æ–™ä»¥äº†è§£å…¶ä»–å¯ç›‘å¬çš„äº‹ä»¶ç§ç±»ã€‚ä»¥ä¸‹ä»£ç å³å¯å°†ä¸€ä¸ªç”¨äºç›‘å¬è¾“å…¥è®¾å¤‡èŠ‚ç‚¹çš„åˆ›å»ºä¸åˆ é™¤çš„watchå¯¹è±¡æ·»åŠ åˆ°inotifyå¯¹è±¡ä¸­ï¼š 1int wd = inotify_add_watch (inotifyFd, â€œ/dev/inputâ€,IN_CREATE | IN_DELETE); å®Œæˆä¸Šè¿°watchå¯¹è±¡çš„æ·»åŠ åï¼Œå½“/dev/input/ä¸‹çš„è®¾å¤‡èŠ‚ç‚¹å‘ç”Ÿåˆ›å»ºä¸åˆ é™¤æ“ä½œæ—¶ï¼Œéƒ½ä¼šå°†ç›¸åº”çš„äº‹ä»¶ä¿¡æ¯å†™å…¥åˆ°inotifyFdæ‰€æè¿°çš„inotifyå¯¹è±¡ä¸­ï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡read()å‡½æ•°ä»inotifyFdæè¿°ç¬¦ä¸­å°†äº‹ä»¶ä¿¡æ¯è¯»å–å‡ºæ¥ã€‚ äº‹ä»¶ä¿¡æ¯ä½¿ç”¨ç»“æ„ä½“inotify_eventè¿›è¡Œæè¿°ï¼š 1234567struct inotify_event &#123; __s32 wd; /* äº‹ä»¶å¯¹åº”çš„Watchå¯¹è±¡çš„æè¿°ç¬¦ */ __u32 mask; /* äº‹ä»¶ç±»å‹ï¼Œä¾‹å¦‚æ–‡ä»¶è¢«åˆ é™¤ï¼Œæ­¤å¤„å€¼ä¸ºIN_DELETE */ __u32 cookie; __u32 len; /* nameå­—æ®µçš„é•¿åº¦ */ char name[0]; /* å¯å˜é•¿çš„å­—æ®µï¼Œç”¨äºå­˜å‚¨äº§ç”Ÿæ­¤äº‹ä»¶çš„æ–‡ä»¶è·¯å¾„*/ &#125;; å½“æ²¡æœ‰ç›‘å¬äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œå¯ä»¥é€šè¿‡å¦‚ä¸‹æ–¹å¼å°†ä¸€ä¸ªæˆ–å¤šä¸ªæœªè¯»å–çš„äº‹ä»¶ä¿¡æ¯è¯»å–å‡ºæ¥ï¼š 1size_t len = read (inotifyFd, events_buf,BUF_LEN); å…¶ä¸­events_bufæ˜¯inotify_eventçš„æ•°ç»„æŒ‡é’ˆï¼Œèƒ½å¤Ÿè¯»å–çš„äº‹ä»¶æ•°é‡ç”±å–å†³äºæ•°ç»„çš„é•¿åº¦ã€‚æˆåŠŸè¯»å–äº‹ä»¶ä¿¡æ¯åï¼Œä¾¿å¯æ ¹æ®inotify_eventç»“æ„ä½“çš„å­—æ®µåˆ¤æ–­äº‹ä»¶ç±»å‹ä»¥åŠäº§ç”Ÿäº‹ä»¶çš„æ–‡ä»¶è·¯å¾„äº†ã€‚ æ€»ç»“ä¸€ä¸‹INotifyæœºåˆ¶çš„ä½¿ç”¨è¿‡ç¨‹ï¼š Â· é€šè¿‡inotify_init()åˆ›å»ºä¸€ä¸ªinotifyå¯¹è±¡ã€‚ Â· é€šè¿‡inotify_add_watchå°†ä¸€ä¸ªæˆ–å¤šä¸ªç›‘å¬æ·»åŠ åˆ°inotifyå¯¹è±¡ä¸­ã€‚ Â· é€šè¿‡read()å‡½æ•°ä»inotifyå¯¹è±¡ä¸­è¯»å–ç›‘å¬äº‹ä»¶ã€‚å½“æ²¡æœ‰æ–°äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œinotifyå¯¹è±¡ä¸­æ— ä»»ä½•å¯è¯»æ•°æ®ã€‚ é€šè¿‡INotifyæœºåˆ¶é¿å…äº†è½®è¯¢æ–‡ä»¶ç³»ç»Ÿçš„éº»çƒ¦ï¼Œä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼ŒINotifyæœºåˆ¶å¹¶ä¸æ˜¯é€šè¿‡å›è°ƒçš„æ–¹å¼é€šçŸ¥äº‹ä»¶ï¼Œè€Œéœ€è¦ä½¿ç”¨è€…ä¸»åŠ¨ä»inotifyå¯¹è±¡ä¸­è¿›è¡Œäº‹ä»¶è¯»å–ã€‚é‚£ä¹ˆä½•æ—¶æ‰æ˜¯è¯»å–çš„æœ€ä½³æ—¶æœºå‘¢ï¼Ÿè¿™å°±éœ€è¦å€ŸåŠ©Linuxçš„å¦ä¸€ä¸ªä¼˜ç§€çš„æœºåˆ¶Epolläº†ã€‚ ä½¿ç”¨inotifyç›‘å¬ç›®å½•å®ä¾‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/inotify.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;//å‚è€ƒ: frameworks\\native\\services\\inputflinger\\EventHub.cpp//Usage: inotify &lt;dir&gt;int read_process_inotify_fd(int fd)&#123;int res;char event_buf[512];int event_size;int event_pos = 0;struct inotify_event *event;/* read */ res = read(fd, event_buf, sizeof(event_buf));if(res &lt; (int)sizeof(*event)) &#123; if(errno == EINTR) return 0; printf(\"could not get event, %s\\n\", strerror(errno)); return -1;&#125;//è¯»åˆ°çš„æ•°æ®æ˜¯1ä¸ªæˆ–å¤šä¸ªinotify_event,å®ƒä»¬çš„é•¿åº¦ä¸ä¸€æ ·,é€ä¸ªå¤„ç†while(res &gt;= (int)sizeof(*event)) &#123; event = (struct inotify_event *)(event_buf + event_pos); //printf(\"%d: %08x \\\"%s\\\"\\n\", event-&gt;wd, event-&gt;mask, event-&gt;len ? event-&gt;name : \"\"); if(event-&gt;len) &#123; if(event-&gt;mask &amp; IN_CREATE) &#123; printf(\"create file: %s\\n\", event-&gt;name); &#125; else &#123; printf(\"delete file: %s\\n\", event-&gt;name); &#125; &#125; event_size = sizeof(*event) + event-&gt;len; res -= event_size; event_pos += event_size;&#125;return 0;&#125;int main(int argc, char **argv)&#123;int mINotifyFd;int result;if (argc != 2)&#123; printf(\"Usage: %s &lt;dir&gt;\\n\", argv[0]); return -1;&#125;/* inotify_init */mINotifyFd = inotify_init();/* add watch */result = inotify_add_watch(mINotifyFd, argv[1], IN_DELETE | IN_CREATE);/* read */while (1)&#123; read_process_inotify_fd(mINotifyFd);&#125;return 0;&#125; ç¼–è¯‘ä¸éªŒè¯ï¼š gcc -o inotify inotify.c //GCCç¼–è¯‘ mkdir tmp //åˆ›å»ºtmpæ–‡ä»¶å¤¹ ./inotify tmp &amp; //åå°ç›‘æµ‹tmpæ–‡ä»¶å¤¹ echo &gt; tmp/1 //tmpæ–‡ä»¶å¤¹æ–°å»ºæ–‡ä»¶1 echo &gt; tmp/2 //tmpæ–‡ä»¶å¤¹æ–°å»ºæ–‡ä»¶2 rm tmp/1 tmp/2 //ç§»é™¤tmpæ–‡ä»¶1/2 æµ‹è¯•ç»“æœå¯ä»¥çœ‹åˆ°ï¼Œinotify æˆåŠŸçš„ç›‘æµ‹äº†tmpæ–‡ä»¶å¤¹ã€‚ 2ã€Epollä»‹ç»ä¸ä½¿ç”¨æ— è®ºæ˜¯ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è·å–åŸå§‹è¾“å…¥äº‹ä»¶è¿˜æ˜¯ä»inotifyå¯¹è±¡ä¸­è¯»å–æ–‡ä»¶ç³»ç»Ÿäº‹ä»¶ï¼Œéƒ½é¢ä¸´ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯è¿™äº›äº‹ä»¶éƒ½æ˜¯å¶å‘çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹è®¾å¤‡èŠ‚ç‚¹ã€inotifyå¯¹è±¡è¿™äº›æ–‡ä»¶æè¿°ç¬¦ä¸­éƒ½æ˜¯æ— æ•°æ®å¯è¯»çš„ï¼ŒåŒæ—¶åˆå¸Œæœ›æœ‰äº‹ä»¶åˆ°æ¥æ—¶å¯ä»¥å°½å¿«åœ°å¯¹äº‹ä»¶ä½œå‡ºååº”ã€‚ä¸ºè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸å¸Œæœ›ä¸æ–­åœ°è½®è¯¢è¿™äº›æè¿°ç¬¦ï¼Œä¹Ÿä¸å¸Œæœ›ä¸ºæ¯ä¸ªæè¿°ç¬¦åˆ›å»ºä¸€ä¸ªå•ç‹¬çš„çº¿ç¨‹è¿›è¡Œé˜»å¡æ—¶çš„è¯»å–ï¼Œå› ä¸ºè¿™éƒ½å°†ä¼šå¯¼è‡´èµ„æºçš„æå¤§æµªè´¹ã€‚ æ­¤æ—¶æœ€ä½³çš„åŠæ³•æ˜¯ä½¿ç”¨Epollæœºåˆ¶ã€‚Epollå¯ä»¥ä½¿ç”¨ä¸€æ¬¡ç­‰å¾…ç›‘å¬å¤šä¸ªæè¿°ç¬¦çš„å¯è¯»/å¯å†™çŠ¶æ€ã€‚ç­‰å¾…è¿”å›æ—¶æºå¸¦äº†å¯è¯»çš„æè¿°ç¬¦æˆ–è‡ªå®šä¹‰çš„æ•°æ®ï¼Œä½¿ç”¨è€…å¯ä»¥æ®æ­¤è¯»å–æ‰€éœ€çš„æ•°æ®åå¯ä»¥å†æ¬¡è¿›å…¥ç­‰å¾…ã€‚å› æ­¤ä¸éœ€è¦ä¸ºæ¯ä¸ªæè¿°ç¬¦åˆ›å»ºç‹¬ç«‹çš„çº¿ç¨‹è¿›è¡Œé˜»å¡è¯»å–ï¼Œé¿å…äº†èµ„æºæµªè´¹çš„åŒæ—¶åˆå¯ä»¥è·å¾—è¾ƒå¿«çš„å“åº”é€Ÿåº¦ã€‚ Epollæœºåˆ¶çš„æ¥å£åªæœ‰ä¸‰ä¸ªå‡½æ•°ï¼Œååˆ†ç®€å•ã€‚ Â· epoll_create(int max_fds)ï¼šåˆ›å»ºä¸€ä¸ªepollå¯¹è±¡çš„æè¿°ç¬¦ï¼Œä¹‹åå¯¹epollçš„æ“ä½œå‡ä½¿ç”¨è¿™ä¸ªæè¿°ç¬¦å®Œæˆã€‚max_fdså‚æ•°è¡¨ç¤ºäº†æ­¤epollå¯¹è±¡å¯ä»¥ç›‘å¬çš„æè¿°ç¬¦çš„æœ€å¤§æ•°é‡ã€‚ Â· epoll_ctl (int epfd, int op,int fd, struct epoll_event *event)ï¼šç”¨äºç®¡ç†æ³¨å†Œäº‹ä»¶çš„å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°å¯ä»¥å¢åŠ /åˆ é™¤/ä¿®æ”¹äº‹ä»¶çš„æ³¨å†Œã€‚ Â· int epoll_wait(int epfd, structepoll_event * events, int maxevents, int timeout)ï¼šç”¨äºç­‰å¾…äº‹ä»¶çš„åˆ°æ¥ã€‚å½“æ­¤å‡½æ•°è¿”å›æ—¶ï¼Œeventsæ•°ç»„å‚æ•°ä¸­å°†ä¼šåŒ…å«äº§ç”Ÿäº‹ä»¶çš„æ–‡ä»¶æè¿°ç¬¦ã€‚ æ¥ä¸‹æ¥ä»¥ç›‘æ§è‹¥å¹²æè¿°ç¬¦å¯è¯»äº‹ä»¶ä¸ºä¾‹ä»‹ç»ä¸€ä¸‹epollçš„ç”¨æ³•ã€‚ ï¼ˆ1ï¼‰ åˆ›å»ºepollå¯¹è±¡ é¦–å…ˆé€šè¿‡epoll_create()å‡½æ•°åˆ›å»ºä¸€ä¸ªepollå¯¹è±¡ï¼š Int epfd = epoll_create(MAX_FDS) ï¼ˆ2ï¼‰ å¡«å……epoll_eventç»“æ„ä½“ æ¥ç€ä¸ºæ¯ä¸€ä¸ªéœ€ç›‘æ§çš„æè¿°ç¬¦å¡«å……epoll_eventç»“æ„ä½“ï¼Œä»¥æè¿°ç›‘æ§äº‹ä»¶ï¼Œå¹¶é€šè¿‡epoll_ctl()å‡½æ•°å°†æ­¤æè¿°ç¬¦ä¸epoll_eventç»“æ„ä½“æ³¨å†Œè¿›epollå¯¹è±¡ã€‚epoll_eventç»“æ„ä½“çš„å®šä¹‰å¦‚ä¸‹: 12345struct epoll_event &#123;__uint32_tevents; /* äº‹ä»¶æ©ç ï¼ŒæŒ‡æ˜äº†éœ€è¦ç›‘å¬çš„äº‹ä»¶ç§ç±»*/ epoll_data_t data; /* ä½¿ç”¨è€…è‡ªå®šä¹‰çš„æ•°æ®ï¼Œå½“æ­¤äº‹ä»¶å‘ç”Ÿæ—¶è¯¥æ•°æ®å°†åŸå°ä¸åŠ¨åœ°è¿”å›ç»™ä½¿ç”¨è€… */ &#125;; epoll_data_tè”åˆä½“çš„å®šä¹‰å¦‚ä¸‹ï¼Œå½“ç„¶ï¼ŒåŒä¸€æ—¶é—´ä½¿ç”¨è€…åªèƒ½ä½¿ç”¨ä¸€ä¸ªå­—æ®µï¼š 123456typedef union epoll_data &#123;void*ptr;int fd;__uint32_t u32;__uint64_t u64;&#125; epoll_data_t; epoll_eventç»“æ„ä¸­çš„eventså­—æ®µæ˜¯ä¸€ä¸ªäº‹ä»¶æ©ç ï¼Œç”¨ä»¥æŒ‡æ˜éœ€è¦ç›‘å¬çš„äº‹ä»¶ç§ç±»ï¼ŒåŒINotifyä¸€æ ·ï¼Œæ©ç çš„æ¯ä¸€ä½ä»£è¡¨äº†ä¸€ç§äº‹ä»¶ã€‚å¸¸ç”¨çš„äº‹ä»¶æœ‰EPOLLINï¼ˆå¯è¯»ï¼‰ï¼ŒEPOLLOUTï¼ˆå¯å†™ï¼‰ï¼ŒEPOLLERRï¼ˆæè¿°ç¬¦å‘ç”Ÿé”™è¯¯ï¼‰ï¼ŒEPOLLHUPï¼ˆæè¿°ç¬¦è¢«æŒ‚èµ·ï¼‰ç­‰ã€‚æ›´å¤šæ”¯æŒçš„äº‹ä»¶è¯»è€…å¯å‚è€ƒç›¸å…³èµ„æ–™ã€‚ dataå­—æ®µæ˜¯ä¸€ä¸ªè”åˆä½“ï¼Œå®ƒè®©ä½¿ç”¨è€…å¯ä»¥å°†ä¸€äº›è‡ªå®šä¹‰æ•°æ®åŠ å…¥åˆ°äº‹ä»¶é€šçŸ¥ä¸­ï¼Œå½“æ­¤äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œç”¨æˆ·è®¾ç½®çš„dataå­—æ®µå°†ä¼šè¿”å›ç»™ä½¿ç”¨è€…ã€‚åœ¨å®é™…ä½¿ç”¨ä¸­å¸¸è®¾ç½®epoll_event.data.fdä¸ºéœ€è¦ç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œäº‹ä»¶å‘ç”Ÿæ—¶ä¾¿å¯ä»¥æ ¹æ®epoll_event.data.fdå¾—çŸ¥å¼•å‘äº‹ä»¶çš„æè¿°ç¬¦ã€‚å½“ç„¶ä¹Ÿå¯ä»¥è®¾ç½®epoll_event.data.fdä¸ºå…¶ä»–ä¾¿äºè¯†åˆ«çš„æ•°æ®ã€‚ å¡«å……epoll_eventçš„æ–¹æ³•å¦‚ä¸‹ï¼š 1234567structepoll_event eventItem;memset(&amp;eventItem, 0, sizeof(eventItem));eventItem.events = EPOLLIN | EPOLLERR | EPOLLHUP; // ç›‘å¬æè¿°ç¬¦å¯è¯»ä»¥åŠå‡ºé”™çš„äº‹ä»¶eventItem.data.fd= listeningFd; // å¡«å†™è‡ªå®šä¹‰æ•°æ®ä¸ºéœ€è¦ç›‘å¬çš„æè¿°ç¬¦ æ¥ä¸‹æ¥å°±å¯ä»¥ä½¿ç”¨epoll_ctl()å°†äº‹ä»¶æ³¨å†Œè¿›epollå¯¹è±¡äº†ã€‚epoll_ctl()çš„å‚æ•°æœ‰å››ä¸ªï¼š Â· epfdæ˜¯ç”±epoll_create()å‡½æ•°æ‰€åˆ›å»ºçš„epollå¯¹è±¡çš„æè¿°ç¬¦ã€‚ Â· opè¡¨ç¤ºäº†ä½•ç§æ“ä½œï¼ŒåŒ…æ‹¬EPOLL_CTL_ADD/DEL/MODä¸‰ç§ï¼Œåˆ†åˆ«è¡¨ç¤ºå¢åŠ /åˆ é™¤/ä¿®æ”¹æ³¨å†Œäº‹ä»¶ã€‚ Â· fdè¡¨ç¤ºäº†éœ€è¦ç›‘å¬çš„æè¿°ç¬¦ã€‚ Â· eventå‚æ•°æ˜¯æè¿°äº†ç›‘å¬äº‹ä»¶çš„è¯¦ç»†ä¿¡æ¯çš„epoll_eventç»“æ„ä½“ã€‚ æ³¨å†Œæ–¹æ³•å¦‚ä¸‹ï¼š 123// å°†äº‹ä»¶ç›‘å¬æ·»åŠ åˆ°epollå¯¹è±¡ä¸­å»result =epoll_ctl(epfd, EPOLL_CTL_ADD, listeningFd, &amp;eventItem); é‡å¤è¿™ä¸ªæ­¥éª¤å¯ä»¥å°†å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦çš„å¤šç§äº‹ä»¶ç›‘å¬æ³¨å†Œåˆ°epollå¯¹è±¡ä¸­ã€‚å®Œæˆäº†ç›‘å¬çš„æ³¨å†Œä¹‹åï¼Œä¾¿å¯ä»¥é€šè¿‡epoll_wait()å‡½æ•°ç­‰å¾…äº‹ä»¶çš„åˆ°æ¥äº†ã€‚ ï¼ˆ3ï¼‰ ä½¿ç”¨epoll_wait()å‡½æ•°ç­‰å¾…äº‹ä»¶ epoll_wait()å‡½æ•°å°†ä¼šä½¿è°ƒç”¨è€…é™·å…¥ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°å…¶æ³¨å†Œçš„äº‹ä»¶ä¹‹ä¸€å‘ç”Ÿä¹‹åæ‰ä¼šè¿”å›ï¼Œå¹¶ä¸”æºå¸¦äº†åˆšåˆšå‘ç”Ÿçš„äº‹ä»¶çš„è¯¦ç»†ä¿¡æ¯ã€‚å…¶ç­¾åå¦‚ä¸‹ï¼š int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); Â· epfdæ˜¯ç”±epoll_create()å‡½æ•°æ‰€åˆ›å»ºçš„epollå¯¹è±¡æè¿°ç¬¦ã€‚ Â· eventsæ˜¯ä¸€ä¸ªepoll_eventçš„æ•°ç»„ï¼Œæ­¤å‡½æ•°è¿”å›æ—¶ï¼Œäº‹ä»¶çš„ä¿¡æ¯å°†è¢«å¡«å……è‡³æ­¤ã€‚ Â· maxeventsè¡¨ç¤ºæ­¤æ¬¡è°ƒç”¨æœ€å¤šå¯ä»¥è·å–å¤šå°‘ä¸ªäº‹ä»¶ï¼Œå½“ç„¶ï¼Œeventså‚æ•°å¿…é¡»èƒ½å¤Ÿè¶³å¤Ÿå®¹çº³è¿™ä¹ˆå¤šäº‹ä»¶ã€‚ Â· timeoutè¡¨ç¤ºç­‰å¾…è¶…æ—¶çš„äº‹ä»¶ã€‚ epoll_wait()å‡½æ•°è¿”å›å€¼è¡¨ç¤ºè·å–äº†å¤šå°‘ä¸ªäº‹ä»¶ã€‚ ï¼ˆ4ï¼‰ å¤„ç†äº‹ä»¶ epoll_waitè¿”å›åï¼Œä¾¿å¯ä»¥æ ¹æ®eventsæ•°ç»„ä¸­æ‰€ä¿å­˜çš„æ‰€æœ‰epoll_eventç»“æ„ä½“çš„eventså­—æ®µä¸dataå­—æ®µè¯†åˆ«äº‹ä»¶çš„ç±»å‹ä¸æ¥æºã€‚ Epollçš„ä½¿ç”¨æ­¥éª¤æ€»ç»“å¦‚ä¸‹ï¼š Â· é€šè¿‡epoll_create()åˆ›å»ºä¸€ä¸ªepollå¯¹è±¡ã€‚ Â· ä¸ºéœ€è¦ç›‘å¬çš„æè¿°ç¬¦å¡«å……epoll_eventsç»“æ„ä½“ï¼Œå¹¶ä½¿ç”¨epoll_ctl()æ³¨å†Œåˆ°epollå¯¹è±¡ä¸­ã€‚ Â· ä½¿ç”¨epoll_wait()ç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿã€‚ Â· æ ¹æ®epoll_wait()è¿”å›çš„epoll_eventsç»“æ„ä½“æ•°ç»„åˆ¤æ–­äº‹ä»¶çš„ç±»å‹ä¸æ¥æºå¹¶è¿›è¡Œå¤„ç†ã€‚ Â· ç»§ç»­ä½¿ç”¨epoll_wait()ç­‰å¾…æ–°äº‹ä»¶çš„å‘ç”Ÿã€‚ ä½¿ç”¨inotifyç›‘å¬ç›®å½•å®ä¾‹ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;sys/epoll.h&gt;#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#if 0typedef union epoll_data &#123;void *ptr; int fd; uint32_t u32; uint64_t u64; &#125; epoll_data_t;#endif#define DATA_MAX_LEN 500/* usage: epoll &lt;file1&gt; [file2] [file3] ... */int add_to_epoll(int fd, int epollFd)&#123;int result;struct epoll_event eventItem;memset(&amp;eventItem, 0, sizeof(eventItem));eventItem.events = EPOLLIN;eventItem.data.fd = fd;result = epoll_ctl(epollFd, EPOLL_CTL_ADD, fd, &amp;eventItem);return result;&#125;void rm_from_epoll(int fd, int epollFd)&#123;epoll_ctl(epollFd, EPOLL_CTL_DEL, fd, NULL);&#125;int main(int argc, char **argv)&#123;int mEpollFd;int i;char buf[DATA_MAX_LEN];// Maximum number of signalled FDs to handle at a time.static const int EPOLL_MAX_EVENTS = 16;// The array of pending epoll events and the index of the next event to be handled.struct epoll_event mPendingEventItems[EPOLL_MAX_EVENTS];if (argc &lt; 2)&#123; printf(\"Usage: %s &lt;file1&gt; [file2] [file3] ...\\n\", argv[0]); return -1;&#125;/* epoll_create */mEpollFd = epoll_create(8);// for each file:* open it// add it to epoll: epoll_ctl(...EPOLL_CTL_ADD...)for (i = 1; i &lt; argc; i++) &#123; //int tmpFd = open(argv[i], O_RDONLY|O_NONBLOCK); int tmpFd = open(argv[i], O_RDWR); add_to_epoll(tmpFd, mEpollFd);&#125;/* epoll_wait */while (1)&#123; int pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, -1); for (i = 0; i &lt; pollResult; i++) &#123; printf(\"Reason: 0x%x\\n\", mPendingEventItems[i].events); int len = read(mPendingEventItems[i].data.fd, buf, DATA_MAX_LEN); buf[len] = '\\0'; printf(\"get data: %s\\n\", buf); //sleep(3); &#125;&#125;return 0;&#125; epoll , fifo : o-rdwr-on-named-pipes-with-poll ä½¿ç”¨fifoæ˜¯, æˆ‘ä»¬çš„epollç¨‹åºæ˜¯reader echo aa &gt; tmp/1 æ˜¯writer a. å¦‚æœreaderä»¥ O_RDONLY|O_NONBLOCKæ‰“å¼€FIFOæ–‡ä»¶, å½“writerå†™å…¥æ•°æ®æ—¶, epoll_waitä¼šç«‹åˆ»è¿”å›; å½“writerå…³é—­FIFOä¹‹å, readerå†æ¬¡è°ƒç”¨epoll_wait, å®ƒä¹Ÿä¼šç«‹åˆ»è¿”å›(åŸå› æ˜¯EPPLLHUP, æè¿°ç¬¦è¢«æŒ‚æ–­) b. å¦‚æœreaderä»¥ O_RDWRæ‰“å¼€FIFOæ–‡ä»¶ å½“writerå†™å…¥æ•°æ®æ—¶, epoll_waitä¼šç«‹åˆ»è¿”å›; å½“writerå…³é—­FIFOä¹‹å, readerå†æ¬¡è°ƒç”¨epoll_wait, å®ƒå¹¶ä¸ä¼šç«‹åˆ»è¿”å›, è€Œæ˜¯ç»§ç»­ç­‰å¾…æœ‰æ•°æ® ç¼–è¯‘ä¸éªŒè¯ï¼š gcc -o epoll epoll.c //GCCç¼–è¯‘ mkdir tmp //åˆ›å»ºtmpæ–‡ä»¶å¤¹ mkfifo tmp/1 tmp/2 tmp/3 //åˆ›å»ºæ–‡ä»¶1ã€2ã€3 ./epoll tmp/1 tmp/2 tmp/3 &amp; //epollåå°ç›‘æµ‹æ–‡ä»¶1ã€2ã€3 echo aaa &gt; tmp/1 //å†™äººaaaåˆ°1 echo bbb &gt; tmp/2 //å†™å…¥bbbåˆ°2 æµ‹è¯•ç»“æœå¯ä»¥çœ‹åˆ°ï¼ŒepollæˆåŠŸçš„ç›‘æµ‹äº†æ–‡ä»¶å†…å®¹çš„æ”¹å˜ã€‚ 3ã€INotifyä¸Epollçš„å°ç»“INotifyä¸Epollè¿™ä¸¤å¥—ç”±Linuxæä¾›çš„äº‹ä»¶ç›‘å¬æœºåˆ¶ä»¥æœ€å°çš„å¼€é”€è§£å†³äº†æ–‡ä»¶ç³»ç»Ÿå˜åŒ–ä»¥åŠæ–‡ä»¶æè¿°ç¬¦å¯è¯»å¯å†™çŠ¶æ€å˜åŒ–çš„ç›‘å¬é—®é¢˜ã€‚å®ƒä»¬æ˜¯Readerå­ç³»ç»Ÿè¿è¡Œçš„åŸºçŸ³ï¼Œäº†è§£äº†è¿™ä¸¤ä¸ªæœºåˆ¶çš„ä½¿ç”¨æ–¹æ³•ä¹‹åä¾¿ä¸ºå¯¹Readerå­ç³»ç»Ÿçš„åˆ†æå­¦ä¹ é“ºå¹³äº†é“è·¯ã€‚ å‚è€ƒï¼šhttps://github.com/weidongshan/APP_0006_inotify_epoll inotify_epoll.c, ç”¨å®ƒæ¥ç›‘æµ‹tmp/ç›®å½•: æœ‰æ–‡ä»¶è¢«åˆ›å»º/åˆ é™¤, æœ‰æ–‡ä»¶å¯è¯»å‡ºæ•°æ® a. å½“åœ¨tmp/ä¸‹åˆ›å»ºæ–‡ä»¶æ—¶, ä¼šç«‹åˆ»ç›‘æµ‹åˆ°ï¼Œå¹¶ä¸”ä½¿ç”¨epollç›‘æµ‹è¯¥æ–‡ä»¶ b. å½“æ–‡ä»¶æœ‰æ•°æ®æ—¶ï¼Œè¯»å‡ºæ•°æ® c. å½“tmp/ä¸‹æ–‡ä»¶è¢«åˆ é™¤æ—¶ï¼Œä¼šç«‹åˆ»ç›‘æµ‹åˆ°ï¼Œå¹¶ä¸”æŠŠå®ƒä»epollä¸­ç§»é™¤ä¸å†ç›‘æµ‹ inotify_epoll.c ç¼–è¯‘ä¸éªŒè¯ï¼š gcc -o inotify_epoll inotify_epoll.c mkdir tmp ./inotify_epoll tmp/ &amp; mkfifo tmp/1 tmp/2 tmp/3 echo aaa &gt; tmp/1 echo bbb &gt; tmp/2 rm tmp/3 ç”±å®ä¾‹å¯çŸ¥ï¼Œä½¿ç”¨inotify å’Œ epoll ç»“åˆå°±å¯ä»¥ç›‘æµ‹æ–‡ä»¶å¢åŠ å’Œç§»é™¤ ï¼Œè¿˜èƒ½ç›‘æµ‹æ–‡ä»¶å†…å®¹çš„æ”¹å˜ã€‚ ç”¨é€”ç®€ä»‹[ç¨åè¿›è¡Œinput systemè¯¦ç»†åˆ†æ]ï¼š /dev/input ä¸‹æœ‰å¤šä¸ªeventæ–‡ä»¶,å¯¹åº”å¤šä¸ªè¾“å…¥è®¾å¤‡ï¼Œå¦‚:/dev/input/event0, /dev/input/mouse0, /dev/input/misc ä½¿ç”¨inotify å’Œ epoll å°±å¯ä»¥ç›‘å¬è¾“å…¥è®¾å¤‡çš„å˜åŒ–ã€å¦‚Androidæ–°è¿æ¥ä¸€ä¸ªé¼ æ ‡å¯æ£€æµ‹åˆ°æ”¹å˜ã€‚åŒæ—¶å¯ç›‘å¬æ˜¯å¦æœ‰è¾“å…¥äº‹ä»¶ã€‚ Lnux IOæ¨¡å¼åŠ selectã€pollã€epollè¯¦è§£ ï¼ˆäºŒï¼‰ã€å¿…å¤‡LinuxçŸ¥è¯†_åŒå‘é€šä¿¡(scoketpair)1ã€è¿›ç¨‹å’ŒAPPé€šä¿¡Â· åˆ›å»ºè¿›ç¨‹ Â· è¯»å–ã€åˆ†å‘ Â· è¿›ç¨‹å‘é€è¾“å…¥äº‹ä»¶ç»™APP Â· è¿›ç¨‹è¯»å–APPå›åº”çš„äº‹ä»¶ Â· è¾“å…¥ç³»ç»Ÿæ¶‰åŠåŒå‘çš„è¿›ç¨‹é—´é€šä¿¡ 2ã€å›é¡¾Binderç³»ç»ŸÂ· Serverâ€“ å•å‘å‘å‡ºè¯·æ±‚ Â· Client â€“ å•å‘å›å¤è¯·æ±‚ Â· æ¯æ¬¡è¯·æ±‚åªå¯ä»¥å•æ–¹å‘å‡º 3ã€å¼•å…¥SocketpairåŸå› ï¼šå¦‚æœåˆ›å»ºä¸¤ç»„è¿›ç¨‹ï¼ˆClientï¼ŒServerï¼‰è¿›è¡ŒåŒå‘é€šä¿¡ï¼Œå®ç°ååˆ†å¤æ‚ å¼•å…¥Socketpairï¼š Socketpair();ä¸¤æ¬¡ï¼Œè·å¾—ä¸¤ä¸ªfdï¼Œåœ¨å†…æ ¸è·å¾—ç¼“å†²åŒºï¼Œä¸€ä¸ªä½œä¸ºsendbufåŒºä¸€ä¸ªä½œä¸ºreceivebufåŒº APPé€šè¿‡fd1å°†æ•°æ®å†™å…¥fd1çš„sendbufåŒºä¸­ï¼Œé€šè¿‡å†…æ ¸å½“ä¸­çš„socketæœºåˆ¶å°±ä¼šå†™åˆ°fd2ä¸­receivebufåŒºï¼ŒåŒç†fd2ä¹Ÿæ˜¯å¦‚æ­¤ socketpairç¼ºç‚¹ï¼šåªé€‚ç”¨äºçº¿ç¨‹é—´ã€çˆ¶å­è¿›ç¨‹é€šä¿¡ è§£å†³æ–¹æ³•ï¼šé€šè¿‡Binderæœºåˆ¶é€šä¿¡å¯ä»¥è®¿é—®ä»»æ„è¿›ç¨‹ï¼Œå°±è§£å†³äº†sockpairç¼ºç‚¹ 4ã€socketpairå…·ä½“ä½¿ç”¨åˆ›å»ºä¸€ä¸ªçº¿ç¨‹â€“pthread_create(); åˆ›å»ºsocketpairâ€“socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets); çº¿ç¨‹å¤„ç†å‡½æ•°â€“å¾€socket[1]å†™å…¥æ•°æ®ï¼Œè¯»å–socket[0]è¯»å–æ•°æ® ä¸»å‡½æ•°â€“ä»socket[1]è¯»å–æ•°æ®ï¼Œå¾€socket[0]å†™å…¥æ•°æ® 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; /* See NOTES */#include &lt;sys/socket.h&gt;#define SOCKET_BUFFER_SIZE (32768U)#define MAX 512/* å‚è€ƒ:frameworks/native/libs/input/InputTransport.cpp */ /* çº¿ç¨‹æ‰§è¡Œå‡½æ•° */int *function_thread(void *arg)&#123;int thread1_fd = (int)arg;int cnt=0;int len;char buf[MAX];while(1)&#123; /* å‘ mainçº¿ç¨‹å‘å‡º: Hello, main thread */ len = sprintf(buf,\"Hello , main thread , cnt = %d\",cnt++); write(thread1_fd,buf,len); /* è¯»å–æ•°æ®(mainçº¿ç¨‹å‘å›çš„æ•°æ®) */ len = read(thread1_fd,buf,MAX); buf[len] = '\\0'; printf(\"thread1 read : %s\\n\",buf); sleep(5);&#125;close(thread1_fd);return NULL;&#125;int main(int argc,char *argv[])&#123;pthread_t threadID;int sockets[2];int bufferSize = SOCKET_BUFFER_SIZE;socketpair(AF_UNIX,SOCK_SEQPACKET,0,sockets); //åˆ›å»ºsocketpair//åˆå§‹åŒ–setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize));setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize));setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize));setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize));pthread_create(threadID,NULL,function_thread,(void *)sockets[1]); //åˆ›å»ºçº¿ç¨‹int mainThread_fd = sockets[0];int cnt=0;int len;char buf[MAX];while(1)&#123; /* è¯»æ•°æ®: çº¿ç¨‹1å‘å‡ºçš„æ•°æ® */ len = read(mainThread_fd,buf,MAX); buf[len] = '\\0'; printf(\"main thread read : %s\\n\",buf); /* main threadå‘thread1 å‘å‡º: Hello, thread1 */ len = sprintf(buf,\"Hello , thread1 , cnt = %d\",cnt++); write(mainThread_fd,buf,len); &#125;close(mainThread_fd);return 0;&#125; ä½¿ç”¨æ–¹æ³•ï¼š gcc socketpair.c -o socketpair -pthread æ³¨ï¼šå‡ºç°å°‘é‡è­¦å‘Šï¼Œå¯ä»¥å¿½ç•¥ ./socketpair å¯ä»¥çœ‹åˆ°mainçº¿ç¨‹ å’Œ thread1åŒå‘é€šä¿¡ã€‚ main å’Œ thread1å±äºä¸¤ä¸ªçº¿ç¨‹ï¼š çˆ¶å­è¿›ç¨‹é€šä¿¡ï¼š åˆ©ç”¨socketpairåˆ›å»ºä¸€å¯¹æ— åç®¡é“ï¼Œç„¶åé€šè¿‡sendmsgç”±æœåŠ¡å™¨è¿›ç¨‹å‘é€æ–‡ä»¶çš„fdç»™å®¢æˆ·ç«¯è¿›ç¨‹ï¼Œå®¢æˆ·ç«¯è¿›ç¨‹é€šè¿‡recvmsgæ¥æ”¶æœåŠ¡å™¨è¿›ç¨‹å‘æ¥çš„fd socketpairå®ç°çˆ¶å­è¿›ç¨‹é€šä¿¡ å›¾ç¤ºï¼š ï¼ˆä¸‰ï¼‰ã€å¿…å¤‡LinuxçŸ¥è¯†_å®ç°ä»»æ„è¿›ç¨‹é—´åŒå‘é€šä¿¡(scoketpair+binder)ä»£ç å®ä¾‹ï¼Œç”±äºä»£ç è¾ƒå¤šï¼Œè¯·å¾€GitHubä¸ŠæŸ¥çœ‹ã€‚ å®ç°ä»»æ„è¿›ç¨‹é—´åŒå‘é€šä¿¡(scoketpair+binder) ç”±ç¬¬äºŒèŠ‚æœ€åå¯çŸ¥socketpairå¯å®ç°çˆ¶å­è¿›ç¨‹é€šä¿¡ï¼Œå›¾ä¸­çˆ¶è¿›ç¨‹å’Œå­è¿›ç¨‹å¯åŒå‘é€šä¿¡ï¼Œå‡å¦‚æ­¤æ—¶é€šè¿‡binderé€šä¿¡å°†æ–‡ä»¶å¥æŸ„Fd[1]ä¼ ç»™å¦å¤–ä¸€ä¸ªç‹¬ç«‹è¿›ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“Linuxä¸€åˆ‡çš†æ–‡ä»¶ï¼Œé‚£ä¸ªç‹¬ç«‹è¿›ç¨‹å°±å¯ä»¥å¯¹Fd[1]è¯»å†™äº†ï¼Œä¹Ÿå°±æ˜¯è¯´çˆ¶è¿›ç¨‹ å°±å¯ä»¥å’Œ é‚£ä¸ªç‹¬ç«‹è¿›ç¨‹åŒå‘é€šä¿¡äº†ï¼Œå…·ä½“å®ç°è¯·ç ”ç©¶ä¸Šé¢çš„ä»£ç ã€‚ æµ‹è¯•ï¼š å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªæ²¡æœ‰ä»»ä½•å…³ç³»çš„è¿›ç¨‹ä½¿ç”¨socketpairå®ç°äº†åŒå‘é€šä¿¡ã€‚ ç”¨é€”ç®€ä»‹[ç¨åè¿›è¡Œinput systemè¯¦ç»†åˆ†æ]ï¼š InputManagerServiceè·å–äº‹ä»¶åéœ€è¦å‘é€ç»™Appï¼Œå‡å¦‚Appè¿›ç¨‹å…³æ‰äº†ï¼Œéœ€è¦å‘ŠçŸ¥IMSï¼Œå°±ä¸éœ€è¦æ¥å—äº‹ä»¶äº†ã€‚å¯ä»¥çœ‹åˆ°éœ€è¦è¿›ç¨‹é—´ç›¸äº’é€šä¿¡ï¼Œè¿™å°±æ˜¯scoketpair+binderå®é™…ä½œç”¨ã€‚ äºŒã€è¾“å…¥ç³»ç»Ÿçš„æ€»ä½“æ¶æ„ï¼ˆä¸€ï¼‰ã€è¾“å…¥å­ç³»ç»Ÿåˆ†å±‚è§£æè¾“å…¥å­ç³»ç»Ÿçš„ç³»ç»Ÿæ¶æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š Androidè¾“å…¥ç³»ç»Ÿç³»ç»Ÿç»¼è¿°ï¼š Linuxå†…æ ¸ä¼šåœ¨/dev/input/ä¸‹åˆ›å»ºå¯¹åº”çš„åä¸ºevent0~næˆ–å…¶ä»–åç§°çš„è®¾å¤‡èŠ‚ç‚¹ã€‚è€Œå½“è¾“å…¥è®¾å¤‡ä¸å¯ç”¨æ—¶ï¼Œåˆ™ä¼šå°†å¯¹åº”çš„èŠ‚ç‚¹åˆ é™¤ã€‚åœ¨ç”¨æˆ·ç©ºé—´å¯ä»¥é€šè¿‡ioctlçš„æ–¹å¼ä»è¿™äº›è®¾å¤‡èŠ‚ç‚¹ä¸­è·å–å…¶å¯¹åº”çš„è¾“å…¥è®¾å¤‡çš„ç±»å‹ã€å‚å•†ã€æè¿°ç­‰ä¿¡æ¯ã€‚ å½“ç”¨æˆ·æ“ä½œè¾“å…¥è®¾å¤‡æ—¶ï¼ŒLinuxå†…æ ¸æ¥æ”¶åˆ°ç›¸åº”çš„ç¡¬ä»¶ä¸­æ–­ï¼Œç„¶åå°†ä¸­æ–­åŠ å·¥æˆåŸå§‹çš„è¾“å…¥äº‹ä»¶æ•°æ®å¹¶å†™å…¥å…¶å¯¹åº”çš„è®¾å¤‡èŠ‚ç‚¹ä¸­ï¼Œåœ¨ç”¨æˆ·ç©ºé—´å¯ä»¥é€šè¿‡read()å‡½æ•°å°†äº‹ä»¶æ•°æ®è¯»å‡ºã€‚ Androidè¾“å…¥ç³»ç»Ÿçš„å·¥ä½œåŸç†æ¦‚æ‹¬æ¥è¯´ï¼Œå°±æ˜¯ç›‘æ§/dev/input/ä¸‹çš„æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹ï¼Œå½“æŸä¸ªèŠ‚ç‚¹æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œå°†æ•°æ®è¯»å‡ºå¹¶è¿›è¡Œä¸€ç³»åˆ—çš„ç¿»è¯‘åŠ å·¥ï¼Œç„¶ååœ¨æ‰€æœ‰çš„çª—å£ä¸­å¯»æ‰¾åˆé€‚çš„äº‹ä»¶æ¥æ”¶è€…ï¼Œå¹¶æ´¾å‘ç»™å®ƒã€‚ 1ã€è¾“å…¥å­ç³»ç»Ÿåˆ†å±‚è§£æâ— Hardwareå±‚ ç¡¬ä»¶å±‚ä¸»è¦å°±æ˜¯æŒ‰é”®ã€è§¦æ‘¸å±ã€Sensorç­‰å„ç§è¾“å…¥è®¾å¤‡ã€‚ â— Kernelå±‚ Kernel å±‚å¯¹Inputç›¸å…³å¤„ç†åªåšç®€å•çš„ä»‹ç»ã€‚ Kernel å±‚ä¸»è¦åˆ†ä¸ºä¸‰å±‚ï¼Œå¦‚ä¸‹ï¼š Input è®¾å¤‡é©±åŠ¨å±‚: é‡‡é›†è¾“å…¥è®¾å¤‡çš„æ•°æ®ä¿¡æ¯ï¼Œé€šè¿‡ Input Core çš„ API ä¸ŠæŠ¥æ•°æ®ã€‚ Input Coreï¼ˆæ ¸å¿ƒå±‚ï¼‰ï¼šä¸ºäº‹ä»¶å¤„ç†å±‚å’Œè®¾å¤‡é©±åŠ¨å±‚æä¾›æ¥å£APIã€‚ Event Handlerï¼ˆäº‹ä»¶å¤„ç†å±‚ï¼‰ï¼šé€šè¿‡æ ¸å¿ƒå±‚çš„APIè·å–è¾“å…¥äº‹ä»¶ä¸ŠæŠ¥çš„æ•°æ®ï¼Œå®šä¹‰APIä¸åº”ç”¨å±‚äº¤äº’ã€‚ Event Handlerï¼š Event Handler å±‚ä»¥é€šç”¨çš„ evdev.c ä¸ºä¾‹æ¥è§£æï¼Œä¸Šå±‚å’Œ Kernel å±‚çš„äº¤äº’åœ¨æ­¤æ–‡ä»¶å®Œæˆã€‚ â— Framework å±‚ Androidç³»ç»Ÿä¸­Framework å±‚è´Ÿè´£ç®¡ç†è¾“å…¥äº‹ä»¶çš„ä¸»è¦æ˜¯InputManagerServiceï¼ˆIMSï¼‰ã€‚å®ƒä¸»è¦çš„ä»»åŠ¡å°±æ˜¯ä»è®¾å¤‡ä¸­è¯»äº‹ä»¶æ•°æ®ï¼Œç„¶åå°†è¾“å…¥äº‹ä»¶å‘é€åˆ°ç„¦ç‚¹çª—å£ä¸­å»ï¼Œå¦å¤–è¿˜éœ€è¦è®©ç³»ç»Ÿæœ‰æœºä¼šæ¥å¤„ç†ä¸€äº›ç³»ç»ŸæŒ‰é”®ã€‚æ˜¾ç„¶ï¼Œè¦å®Œæˆè¿™ä¸ªå·¥ä½œï¼ŒIMSéœ€è¦ä¸å…¶å®ƒæ¨¡å—æ‰“äº¤é“ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„å°±æ˜¯WMSå’ŒViewRootImplã€‚ä¸»è¦çš„å‡ ä¸ªæ¨¡å—ç¤ºæ„å¦‚ä¸‹ï¼š â— Appå±‚ WindowManagerService(WMS)æ˜¯çª—å£ç®¡ç†æœåŠ¡ï¼Œæ ¸å¿ƒç»´æŠ¤äº†ä¸€ä¸ªæœ‰åºçš„çª—å£å †æ ˆã€‚PhoneWindowManager(PWM)é‡Œæœ‰å…³äºæ‰‹æœºç­–ç•¥çš„å®ç°ï¼Œå’Œè¾“å…¥ç›¸å…³çš„ä¸»è¦æ˜¯å¯¹ç³»ç»ŸæŒ‰é”®çš„å¤„ç†ã€‚InputManagerServiceæ˜¯è¾“å…¥ç®¡ç†æœåŠ¡ï¼Œä¸»è¦å¹²æ´»çš„æ˜¯Nativeå±‚çš„InputManagerã€‚InputManagerä¸­çš„InputReaderè´Ÿè´£ä½¿ç”¨EventHubä»Input driverä¸­æ‹¿äº‹ä»¶ï¼Œç„¶åè®©InputMapperè§£æã€‚æ¥ç€ä¼ ç»™InputDispatcherï¼ŒInputDispatcherè´Ÿè´£ä¸€æ–¹é¢å°†äº‹ä»¶é€šè¿‡InputManagerï¼ŒInputMonitorä¸€è·¯ä¼ ç»™PhoneWindowManageræ¥åšç³»ç»Ÿè¾“å…¥äº‹ä»¶çš„å¤„ç†ï¼Œå¦ä¸€æ–¹é¢å°†è¿™äº›äº‹ä»¶ä¼ ç»™ç„¦ç‚¹åŠç›‘è§†çª—å£ã€‚NativeInputManagerå®ç°InputReaderPolicyInterfaceå’ŒInputDispatcherPolicyInterfaceæ¥å£ï¼Œåœ¨Nativeå±‚çš„InputManagerå’ŒJavaå±‚çš„IMSé—´èµ·åˆ°ä¸€ä¸ªèƒ¶æ°´å±‚çš„ä½œç”¨ã€‚InputMonitorå®ç°äº†WindowManagerCallbacksæ¥å£ï¼Œèµ·åˆ°äº†IMSåˆ°WMSçš„è¿æ¥ä½œç”¨ã€‚Appè¿™è¾¹ï¼ŒViewRootImplç›¸å½“äºAppç«¯ä¸€ä¸ªé¡¶å±‚Viewçš„Controllerã€‚è¿™ä¸ªé¡¶å±‚Viewåœ¨WMSä¸­å¯¹åº”ä¸€ä¸ªçª—å£ï¼Œç”¨WindowStateæè¿°ã€‚WindowStateä¸­æœ‰InputWindowHandleä»£è¡¨ä¸€ä¸ªæ¥æ”¶è¾“å…¥äº‹ä»¶çš„çª—å£å¥æŸ„ã€‚InputDispatcherä¸­çš„mFocusedWindowHandleæŒ‡ç¤ºäº†ç„¦ç‚¹çª—å£çš„å¥æŸ„ã€‚InputDispatcherç®¡ç†äº†ä¸€å¨è¿æ¥ï¼ˆä¸€ä¸ªè¿æ¥å¯¹åº”ä¸€ä¸ªæ³¨å†Œåˆ°WMSçš„çª—å£ï¼‰ï¼Œé€šè¿‡è¿™äº›ä¸ªè¿æ¥InputDispatcherå¯ä»¥ç›´æ¥å°†è¾“å…¥äº‹ä»¶å‘å¾€Appç«¯çš„ç„¦ç‚¹çª—å£ã€‚è¾“å…¥äº‹ä»¶ä»Driverå¼€å§‹çš„å¤„ç†è¿‡ç¨‹å¤§è‡´å¦‚ä¸‹ï¼š äº‹ä»¶å‘å¾€Appç«¯åï¼Œå°±è¿›å…¥äº‹ä»¶åˆ†å‘é˜¶æ®µï¼Œè¿™é‡Œç®€å•æä¸‹ï¼Œä¸åšè¯¦ç»†åˆ†æã€‚ é™„ï¼š Kernel å±‚ç”Ÿæˆä¸‰ä¸ªè·¯å¾„åŠç›¸å…³è®¾å¤‡æ–‡ä»¶ï¼š 123456789101112131415161718192021222324252627282930313233# /sys/class/input/event0 event11 event4 event7 input0 input11 input4 input7event1 event2 event5 event8 input1 input2 input5 input8event10 event3 event6 event9 input10 input3 input6 input9# /dev/inputevent0 event10 event2 event4 event6 event8event1 event11 event3 event5 event7 event9# /proc/bus/input devices handlers# cat devices æŸ¥çœ‹æ€»çº¿ä¸Šçš„å·²ç»æ³¨å†Œä¸Šçš„è¾“å…¥è®¾å¤‡I: Bus=0019 Vendor=0000 Product=0000 Version=0000N: Name=\"ACCDET\"P: Phys=S: Sysfs=/devices/virtual/input/input0U: Uniq=H: Handlers=gpufreq_ib event0B: PROP=0B: EV=3B: KEY=40 0 0 0 0 0 0 1000000000 c000001800000 0...I: Bus=0019 Vendor=0000 Product=0000 Version=0001N: Name=\"fingerprint_key\"P: Phys=S: Sysfs=/devices/virtual/input/input2U: Uniq=H: Handlers=gpufreq_ib event2B: PROP=0B: EV=3B: KEY=2000100000000000 180001f 8000000000000000...cat handlers // æŸ¥çœ‹æ³¨å†Œçš„handlerN: Number=0 Name=gpufreq_ibN: Number=1 Name=evdev Minor=64 2ã€geteventä¸sendeventå·¥å…·Androidç³»ç»Ÿæä¾›äº†geteventä¸sendeventä¸¤ä¸ªå·¥å…·ä¾›å¼€å‘è€…ä»è®¾å¤‡èŠ‚ç‚¹ä¸­ç›´æ¥è¯»å–è¾“å…¥äº‹ä»¶æˆ–å†™å…¥è¾“å…¥äº‹ä»¶ã€‚ geteventç›‘å¬è¾“å…¥è®¾å¤‡èŠ‚ç‚¹çš„å†…å®¹ï¼Œå½“è¾“å…¥äº‹ä»¶è¢«å†™å…¥åˆ°èŠ‚ç‚¹ä¸­æ—¶ï¼Œgeteventä¼šå°†å…¶è¯»å‡ºå¹¶æ‰“å°åœ¨å±å¹•ä¸Šã€‚ç”±äºgeteventä¸ä¼šå¯¹äº‹ä»¶æ•°æ®åšä»»ä½•åŠ å·¥ï¼Œå› æ­¤å…¶è¾“å‡ºçš„å†…å®¹æ˜¯ç”±å†…æ ¸æä¾›çš„æœ€åŸå§‹çš„äº‹ä»¶ã€‚å…¶ç”¨æ³•å¦‚ä¸‹ï¼š 1adb shell getevent [-é€‰é¡¹] [device_path] å…¶ä¸­device_pathæ˜¯å¯é€‰å‚æ•°ï¼Œç”¨ä»¥æŒ‡æ˜éœ€è¦ç›‘å¬çš„è®¾å¤‡èŠ‚ç‚¹è·¯å¾„ã€‚å¦‚æœçœç•¥æ­¤å‚æ•°ï¼Œåˆ™ç›‘å¬æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹çš„äº‹ä»¶ã€‚ æ‰“å¼€æ¨¡æ‹Ÿå™¨ï¼Œæ‰§è¡Œadb shell getevent â€“tï¼ˆ-tå‚æ•°è¡¨ç¤ºæ‰“å°äº‹ä»¶çš„æ—¶é—´æˆ³ï¼‰ï¼Œå¹¶æŒ‰ä¸€ä¸‹ç”µæºé”®ï¼ˆä¸è¦æ¾æ‰‹ï¼‰ï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹ä¸€æ¡è¾“å‡ºï¼Œè¾“å‡ºçš„éƒ¨åˆ†æ•°å€¼ä¼šå› æœºå‹çš„ä¸åŒè€Œæœ‰æ‰€å·®å¼‚ï¼Œä½†æ ¼å¼ä¸€è‡´ï¼š 1[1262.443489] /dev/input/event0: 0001 0074 00000001 æ¾å¼€ç”µæºé”®æ—¶ï¼Œåˆä¼šäº§ç”Ÿä»¥ä¸‹ä¸€æ¡è¾“å‡ºï¼š 1[1262.557130] /dev/input/event0: 0001 0074 00000000 è¿™ä¸¤æ¡è¾“å‡ºä¾¿æ˜¯æŒ‰ä¸‹å’ŒæŠ¬èµ·ç”µæºé”®æ—¶ç”±å†…æ ¸ç”Ÿæˆçš„åŸå§‹äº‹ä»¶ã€‚æ³¨æ„å…¶è¾“å‡ºæ˜¯åå…­è¿›åˆ¶çš„ã€‚æ¯æ¡æ•°æ®æœ‰äº”é¡¹ä¿¡æ¯ï¼šäº§ç”Ÿäº‹ä»¶æ—¶çš„æ—¶é—´æˆ³ï¼ˆ[ 1262.443489]ï¼‰ï¼Œäº§ç”Ÿäº‹ä»¶çš„è®¾å¤‡èŠ‚ç‚¹ï¼ˆ/dev/input/event0ï¼‰ï¼Œäº‹ä»¶ç±»å‹ï¼ˆ0001ï¼‰ï¼Œäº‹ä»¶ä»£ç ï¼ˆ0074ï¼‰ä»¥åŠäº‹ä»¶çš„å€¼ï¼ˆ00000001ï¼‰ã€‚å…¶ä¸­æ—¶é—´æˆ³ã€ç±»å‹ã€ä»£ç ã€å€¼ä¾¿æ˜¯åŸå§‹äº‹ä»¶çš„å››é¡¹åŸºæœ¬å…ƒç´ ã€‚é™¤æ—¶é—´æˆ³å¤–ï¼Œå…¶ä»–ä¸‰é¡¹å…ƒç´ çš„å®é™…æ„ä¹‰ä¾ç…§è®¾å¤‡ç±»å‹åŠå‚å•†çš„ä¸åŒè€Œæœ‰æ‰€åŒºåˆ«ã€‚åœ¨æœ¬ä¾‹ä¸­ï¼Œç±»å‹0x01è¡¨ç¤ºæ­¤äº‹ä»¶ä¸ºä¸€æ¡æŒ‰é”®äº‹ä»¶ï¼Œä»£ç 0x74è¡¨ç¤ºç”µæºé”®çš„æ‰«æç ï¼Œå€¼0x01è¡¨ç¤ºæŒ‰ä¸‹ï¼Œ0x00åˆ™è¡¨ç¤ºæŠ¬èµ·ã€‚è¿™ä¸¤æ¡åŸå§‹æ•°æ®è¢«è¾“å…¥ç³»ç»ŸåŒ…è£…æˆä¸¤ä¸ªKeyEventå¯¹è±¡ï¼Œä½œä¸ºä¸¤ä¸ªæŒ‰é”®äº‹ä»¶æ´¾å‘ç»™Frameworkä¸­æ„Ÿå…´è¶£çš„æ¨¡å—æˆ–åº”ç”¨ç¨‹åºã€‚ æ³¨æ„ä¸€æ¡åŸå§‹äº‹ä»¶æ‰€åŒ…å«çš„ä¿¡æ¯é‡æ˜¯æ¯”è¾ƒæœ‰é™çš„ã€‚è€Œåœ¨Android APIä¸­æ‰€ä½¿ç”¨çš„æŸäº›è¾“å…¥äº‹ä»¶ï¼Œå¦‚è§¦æ‘¸å±ç‚¹å‡»/æ»‘åŠ¨ï¼ŒåŒ…å«äº†å¾ˆå¤šçš„ä¿¡æ¯ï¼Œå¦‚XYåæ ‡ï¼Œè§¦æ‘¸ç‚¹ç´¢å¼•ç­‰ï¼Œå…¶å®æ˜¯è¾“å…¥ç³»ç»Ÿæ•´åˆäº†å¤šä¸ªåŸå§‹äº‹ä»¶åçš„ç»“æœã€‚è¿™ä¸ªè¿‡ç¨‹å°†åœ¨5.2.4èŠ‚ä¸­è¯¦ç»†æ¢è®¨ã€‚ ä¸ºäº†å¯¹åŸå§‹äº‹ä»¶æœ‰ä¸€ä¸ªæ„Ÿæ€§çš„è®¤è¯†ï¼Œè¯»è€…å¯ä»¥åœ¨è¿è¡Œgeteventçš„è¿‡ç¨‹ä¸­å°è¯•ä¸€ä¸‹å…¶ä»–çš„è¾“å…¥æ“ä½œï¼Œè§‚å¯Ÿä¸€ä¸‹æ¯ç§è¾“å…¥æ‰€å¯¹åº”çš„è®¾å¤‡èŠ‚ç‚¹åŠå››é¡¹å…ƒç´ çš„å–å€¼ã€‚ è¾“å…¥è®¾å¤‡çš„èŠ‚ç‚¹ä¸ä»…åœ¨ç”¨æˆ·ç©ºé—´å¯è¯»ï¼Œè€Œä¸”æ˜¯å¯å†™çš„ï¼Œå› æ­¤å¯ä»¥å°†å°†åŸå§‹äº‹ä»¶å†™å…¥åˆ°èŠ‚ç‚¹ä¸­ï¼Œä»è€Œå®ç°æ¨¡æ‹Ÿç”¨æˆ·è¾“å…¥çš„åŠŸèƒ½ã€‚sendeventå·¥å…·çš„ä½œç”¨æ­£æ˜¯å¦‚æ­¤ã€‚å…¶ç”¨æ³•å¦‚ä¸‹ï¼š 1sendevent &lt;èŠ‚ç‚¹è·¯å¾„&gt; &lt;ç±»å‹&gt;&lt;ä»£ç &gt; &lt;å€¼&gt; å¯ä»¥çœ‹å‡ºï¼Œsendeventçš„è¾“å…¥å‚æ•°ä¸geteventçš„è¾“å‡ºæ˜¯å¯¹åº”çš„ï¼Œåªä¸è¿‡sendeventçš„å‚æ•°ä¸ºåè¿›åˆ¶ã€‚ç”µæºé”®çš„ä»£ç 0x74çš„åè¿›åˆ¶ä¸º116ï¼Œå› æ­¤å¯ä»¥é€šè¿‡å¿«é€Ÿæ‰§è¡Œå¦‚ä¸‹ä¸¤æ¡å‘½ä»¤å®ç°ç‚¹å‡»ç”µæºé”®çš„æ•ˆæœï¼š 123adb shell sendevent /dev/input/event0 1 116 1 #æŒ‰ä¸‹ç”µæºé”®adb shell sendevent /dev/input/event0 1 116 0 #æŠ¬èµ·ç”µæºé”® æ‰§è¡Œå®Œè¿™ä¸¤æ¡å‘½ä»¤åï¼Œå¯ä»¥çœ‹åˆ°è®¾å¤‡è¿›å…¥äº†ä¼‘çœ æˆ–è¢«å”¤é†’ï¼Œä¸æŒ‰ä¸‹å®é™…çš„ç”µæºé”®çš„æ•ˆæœä¸€æ¨¡ä¸€æ ·ã€‚å¦å¤–ï¼Œæ‰§è¡Œè¿™ä¸¤æ¡å‘½ä»¤çš„æ—¶é—´é—´éš”ä¾¿æ˜¯ç”¨æˆ·æŒ‰ä½ç”µæºé”®æ‰€ä¿æŒçš„æ—¶é—´ï¼Œæ‰€ä»¥å¦‚æœæ‰§è¡Œç¬¬ä¸€æ¡å‘½ä»¤åè¿Ÿè¿Ÿä¸æ‰§è¡Œç¬¬äºŒæ¡ï¼Œåˆ™ä¼šäº§ç”Ÿé•¿æŒ‰ç”µæºé”®çš„æ•ˆæœâ€”-å…³æœºå¯¹è¯æ¡†å‡ºç°äº†ã€‚å¾ˆæœ‰è¶£ä¸æ˜¯ä¹ˆï¼Ÿè¾“å…¥è®¾å¤‡èŠ‚ç‚¹åœ¨ç”¨æˆ·ç©ºé—´å¯è¯»å¯å†™çš„ç‰¹æ€§ä¸ºè‡ªåŠ¨åŒ–æµ‹è¯•æä¾›äº†ä¸€æ¡é«˜æ•ˆçš„é€”å¾„ã€‚[1] ç°åœ¨ï¼Œè¯»è€…å¯¹è¾“å…¥è®¾å¤‡èŠ‚ç‚¹ä»¥åŠåŸå§‹äº‹ä»¶æœ‰äº†ç›´è§‚çš„è®¤è¯†ï¼Œæ¥ä¸‹æ¥çœ‹ä¸€ä¸‹Androidè¾“å…¥ç³»ç»Ÿçš„åŸºæœ¬åŸç†ã€‚ 3ã€Input driveræ¨¡æ‹Ÿé©±åŠ¨ä»£ç å®ä¾‹ï¼š Input driveræ¨¡æ‹Ÿé©±åŠ¨-ä½œè€…éŸ¦ä¸œå±± 123456789101112131415161718192021222324252627282930313233343536373839404142/* å‚è€ƒdrivers\\input\\keyboard\\gpio_keys.c */#include &lt;linux/module.h&gt;#include &lt;linux/version.h&gt;#include &lt;linux/init.h&gt;#include &lt;linux/fs.h&gt;#include &lt;linux/input.h&gt;static struct input_dev *input_emulator_dev;static int input_emulator_init(void)&#123;int i;/* 1\\. åˆ†é…ä¸€ä¸ªinput_devç»“æ„ä½“ */input_emulator_dev = input_allocate_device();;/* 2\\. è®¾ç½® *//* 2.1 èƒ½äº§ç”Ÿå“ªç±»äº‹ä»¶ */set_bit(EV_KEY, input_emulator_dev-&gt;evbit);set_bit(EV_REP, input_emulator_dev-&gt;evbit);/* 2.2 èƒ½äº§ç”Ÿæ‰€æœ‰çš„æŒ‰é”® */for (i = 0; i &lt; BITS_TO_LONGS(KEY_CNT); i++) input_emulator_dev-&gt;keybit[i] = ~0UL;/* 2.3 ä¸ºandroidæ„é€ ä¸€äº›è®¾å¤‡ä¿¡æ¯ */input_emulator_dev-&gt;name = \"InputEmulatorFrom100ask.net\";input_emulator_dev-&gt;id.bustype = 1;input_emulator_dev-&gt;id.vendor = 0x1234;input_emulator_dev-&gt;id.product = 0x5678;input_emulator_dev-&gt;id.version = 1;/* 3\\. æ³¨å†Œ */input_register_device(input_emulator_dev);return 0;&#125;static void input_emulator_exit(void)&#123;input_unregister_device(input_emulator_dev);input_free_device(input_emulator_dev);&#125;module_init(input_emulator_init);module_exit(input_emulator_exit);MODULE_LICENSE(\"GPL\"); æµ‹è¯•: insmod InputEmulator.ko sendevent /dev/input/event5 1 2 1 // 1 2 1 : EV_KEY, KEY_1, down sendevent /dev/input/event5 1 2 0 // 1 2 0 : EV_KEY, KEY_1, up sendevent /dev/input/event5 0 0 0 // sync sendevent /dev/input/event5 1 3 1 // 1 3 1 : EV_KEY, KEY_2, down sendevent /dev/input/event5 1 3 0 // 1 3 0 : EV_KEY, KEY_1, up sendevent /dev/input/event5 0 0 0 // sync é€šè¿‡sendevent æœ€åä¼šæˆåŠŸè¾“å…¥å­—ç¬¦1ã€2ã€‚ ä¸‰ã€Android Inputç³»ç»Ÿï¼ˆä¸€ï¼‰ã€Android Input ç³»ç»Ÿå…³é”®ç±»ä»‹ç»ä¸Šä¸€èŠ‚è®²è¿°äº†è¾“å…¥äº‹ä»¶çš„æºå¤´æ˜¯ä½äº/dev/input/ä¸‹çš„è®¾å¤‡èŠ‚ç‚¹ï¼Œè€Œè¾“å…¥ç³»ç»Ÿçš„ç»ˆç‚¹æ˜¯ç”±WMSç®¡ç†çš„æŸä¸ªçª—å£ã€‚æœ€åˆçš„è¾“å…¥äº‹ä»¶ä¸ºå†…æ ¸ç”Ÿæˆçš„åŸå§‹äº‹ä»¶ï¼Œè€Œæœ€ç»ˆäº¤ä»˜ç»™çª—å£çš„åˆ™æ˜¯KeyEventæˆ–MotionEventå¯¹è±¡ã€‚å› æ­¤Androidè¾“å…¥ç³»ç»Ÿçš„ä¸»è¦å·¥ä½œæ˜¯è¯»å–è®¾å¤‡èŠ‚ç‚¹ä¸­çš„åŸå§‹äº‹ä»¶ï¼Œå°†å…¶åŠ å·¥å°è£…ï¼Œç„¶åæ´¾å‘ç»™ä¸€ä¸ªç‰¹å®šçš„çª—å£ä»¥åŠçª—å£ä¸­çš„æ§ä»¶ã€‚è¿™ä¸ªè¿‡ç¨‹ç”±InputManagerServiceï¼ˆä»¥ä¸‹ç®€ç§°IMSï¼‰ç³»ç»ŸæœåŠ¡ä¸ºæ ¸å¿ƒçš„å¤šä¸ªå‚ä¸è€…å…±åŒå®Œæˆã€‚ è¾“å…¥ç³»ç»Ÿçš„æ€»ä½“æµç¨‹å’Œå‚ä¸è€…å¦‚å›¾3-1æ‰€ç¤ºã€‚ ä¸Šå›¾æè¿°äº†è¾“å…¥äº‹ä»¶çš„å¤„ç†æµç¨‹ä»¥åŠè¾“å…¥ç³»ç»Ÿä¸­æœ€åŸºæœ¬çš„å‚ä¸è€…ã€‚å®ƒä»¬æ˜¯ï¼š Â· Linuxå†…æ ¸ï¼Œæ¥å—è¾“å…¥è®¾å¤‡çš„ä¸­æ–­ï¼Œå¹¶å°†åŸå§‹äº‹ä»¶çš„æ•°æ®å†™å…¥åˆ°è®¾å¤‡èŠ‚ç‚¹ä¸­ã€‚ Â· è®¾å¤‡èŠ‚ç‚¹ï¼Œä½œä¸ºå†…æ ¸ä¸IMSçš„æ¡¥æ¢ï¼Œå®ƒå°†åŸå§‹äº‹ä»¶çš„æ•°æ®æš´éœ²ç»™ç”¨æˆ·ç©ºé—´ï¼Œä»¥ä¾¿IMSå¯ä»¥ä»ä¸­è¯»å–äº‹ä»¶ã€‚ Â· InputManagerServiceï¼Œä¸€ä¸ªAndroidç³»ç»ŸæœåŠ¡ï¼Œå®ƒåˆ†ä¸ºJavaå±‚å’ŒNativeå±‚ä¸¤éƒ¨åˆ†ã€‚Javaå±‚è´Ÿè´£ä¸WMSçš„é€šä¿¡ã€‚è€ŒNativeå±‚åˆ™æ˜¯InputReaderå’ŒInputDispatcherä¸¤ä¸ªè¾“å…¥ç³»ç»Ÿå…³é”®ç»„ä»¶çš„è¿è¡Œå®¹å™¨ã€‚ Â· EventHubï¼Œç›´æ¥è®¿é—®æ‰€æœ‰çš„è®¾å¤‡èŠ‚ç‚¹ã€‚å¹¶ä¸”æ­£å¦‚å…¶åå­—æ‰€æè¿°çš„ï¼Œå®ƒé€šè¿‡ä¸€ä¸ªåä¸ºgetEvents()çš„å‡½æ•°å°†æ‰€æœ‰è¾“å…¥ç³»ç»Ÿç›¸å…³çš„å¾…å¤„ç†çš„åº•å±‚äº‹ä»¶è¿”å›ç»™ä½¿ç”¨è€…ã€‚è¿™äº›äº‹ä»¶åŒ…æ‹¬åŸå§‹è¾“å…¥äº‹ä»¶ã€è®¾å¤‡èŠ‚ç‚¹çš„å¢åˆ ç­‰ã€‚ Â· InputReaderï¼ŒIæ˜¯IMSä¸­çš„å…³é”®ç»„ä»¶ä¹‹ä¸€ã€‚å®ƒè¿è¡Œäºä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ä¸­ï¼Œè´Ÿè´£ç®¡ç†è¾“å…¥è®¾å¤‡çš„åˆ—è¡¨ä¸é…ç½®ï¼Œä»¥åŠè¿›è¡Œè¾“å…¥äº‹ä»¶çš„åŠ å·¥å¤„ç†ã€‚å®ƒé€šè¿‡å…¶çº¿ç¨‹å¾ªç¯ä¸æ–­åœ°é€šè¿‡getEvents()å‡½æ•°ä»EventHubä¸­å°†äº‹ä»¶å–å‡ºå¹¶è¿›è¡Œå¤„ç†ã€‚å¯¹äºè®¾å¤‡èŠ‚ç‚¹çš„å¢åˆ äº‹ä»¶ï¼Œå®ƒä¼šæ›´æ–°è¾“å…¥è®¾å¤‡åˆ—è¡¨äºé…ç½®ã€‚å¯¹äºåŸå§‹è¾“å…¥äº‹ä»¶ï¼ŒInputReaderå¯¹å…¶è¿›è¡Œç¿»è¯‘ã€ç»„è£…ã€å°è£…ä¸ºåŒ…å«äº†æ›´å¤šä¿¡æ¯ã€æ›´å…·å¯è¯»æ€§çš„è¾“å…¥äº‹ä»¶ï¼Œç„¶åäº¤ç»™InputDispatcherè¿›è¡Œæ´¾å‘ã€‚ Â· InputReaderPolicyï¼Œå®ƒä¸ºInputReaderçš„äº‹ä»¶åŠ å·¥å¤„ç†æä¾›ä¸€äº›ç­–ç•¥é…ç½®ï¼Œä¾‹å¦‚é”®ç›˜å¸ƒå±€ä¿¡æ¯ç­‰ã€‚ Â· InputDispatcherï¼Œæ˜¯IMSä¸­çš„å¦ä¸€ä¸ªå…³é”®ç»„ä»¶ã€‚å®ƒä¹Ÿè¿è¡Œäºä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹ä¸­ã€‚InputDispatcherä¸­ä¿ç®¡äº†æ¥è‡ªWMSçš„æ‰€æœ‰çª—å£çš„ä¿¡æ¯ï¼Œå…¶æ”¶åˆ°æ¥è‡ªInputReaderçš„è¾“å…¥äº‹ä»¶åï¼Œä¼šåœ¨å…¶ä¿ç®¡çš„çª—å£ä¸­å¯»æ‰¾åˆé€‚çš„çª—å£ï¼Œå¹¶å°†äº‹ä»¶æ´¾å‘ç»™æ­¤çª—å£ã€‚ Â· InputDispatcherPolicyï¼Œå®ƒä¸ºInputDispatcherçš„æ´¾å‘è¿‡ç¨‹æä¾›ç­–ç•¥æ§åˆ¶ã€‚ä¾‹å¦‚æˆªå–æŸäº›ç‰¹å®šçš„è¾“å…¥äº‹ä»¶ç”¨ä½œç‰¹æ®Šç”¨é€”ï¼Œæˆ–è€…é˜»æ­¢å°†æŸäº›äº‹ä»¶æ´¾å‘ç»™ç›®æ ‡çª—å£ã€‚ä¸€ä¸ªå…¸å‹çš„ä¾‹å­å°±æ˜¯HOMEé”®è¢«InputDispatcherPolicyæˆªå–åˆ°PhoneWindowManagerä¸­è¿›è¡Œå¤„ç†ï¼Œå¹¶é˜»æ­¢çª—å£æ”¶åˆ°HOMEé”®æŒ‰ä¸‹çš„äº‹ä»¶ã€‚ Â· WMSï¼Œè™½è¯´ä¸æ˜¯è¾“å…¥ç³»ç»Ÿä¸­çš„ä¸€å‘˜ï¼Œä½†æ˜¯å®ƒå´å¯¹InputDispatcherçš„æ­£å¸¸å·¥ä½œèµ·åˆ°äº†è‡³å…³é‡è¦çš„ä½œç”¨ã€‚å½“æ–°å»ºçª—å£æ—¶ï¼ŒWMSä¸ºæ–°çª—å£å’ŒIMSåˆ›å»ºäº†äº‹ä»¶ä¼ é€’æ‰€ç”¨çš„é€šé“ã€‚å¦å¤–ï¼ŒWMSè¿˜å°†æ‰€æœ‰çª—å£çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬çª—å£çš„å¯ç‚¹å‡»åŒºåŸŸï¼Œç„¦ç‚¹çª—å£ç­‰ä¿¡æ¯ï¼Œå®æ—¶åœ°æ›´æ–°åˆ°IMSçš„InputDispatcherä¸­ï¼Œä½¿å¾—InputDispatcherå¯ä»¥æ­£ç¡®åœ°å°†äº‹ä»¶æ´¾å‘åˆ°æŒ‡å®šçš„çª—å£ã€‚ Â· ViewRootImplï¼Œå¯¹äºæŸäº›çª—å£ï¼Œå¦‚å£çº¸çª—å£ã€SurfaceViewçš„çª—å£æ¥è¯´ï¼Œçª—å£å³æ˜¯è¾“å…¥äº‹ä»¶æ´¾å‘çš„ç»ˆç‚¹ã€‚è€Œå¯¹äºå…¶ä»–çš„å¦‚Activityã€å¯¹è¯æ¡†ç­‰ä½¿ç”¨äº†Androidæ§ä»¶ç³»ç»Ÿçš„çª—å£æ¥è¯´ï¼Œè¾“å…¥äº‹ä»¶çš„ç»ˆç‚¹æ˜¯æ§ä»¶ï¼ˆViewï¼‰ã€‚ViewRootImplå°†çª—å£æ‰€æ¥æ”¶åˆ°çš„è¾“å…¥äº‹ä»¶æ²¿ç€æ§ä»¶æ ‘å°†äº‹ä»¶æ´¾å‘ç»™æ„Ÿå…´è¶£çš„æ§ä»¶ã€‚ ç®€å•æ¥è¯´ï¼Œå†…æ ¸å°†åŸå§‹äº‹ä»¶å†™å…¥åˆ°è®¾å¤‡èŠ‚ç‚¹ä¸­ï¼ŒInputReaderä¸æ–­åœ°é€šè¿‡EventHubå°†åŸå§‹äº‹ä»¶å–å‡ºæ¥å¹¶ç¿»è¯‘åŠ å·¥æˆAndroidè¾“å…¥äº‹ä»¶ï¼Œç„¶åäº¤ç»™InputDispatcherã€‚InputDispatcheræ ¹æ®WMSæä¾›çš„çª—å£ä¿¡æ¯å°†äº‹ä»¶äº¤ç»™åˆé€‚çš„çª—å£ã€‚çª—å£çš„ViewRootImplå¯¹è±¡å†æ²¿ç€æ§ä»¶æ ‘å°†äº‹ä»¶æ´¾å‘ç»™æ„Ÿå…´è¶£çš„æ§ä»¶ã€‚æ§ä»¶å¯¹å…¶æ”¶åˆ°çš„äº‹ä»¶ä½œå‡ºå“åº”ï¼Œæ›´æ–°è‡ªå·±çš„ç”»é¢ã€æ‰§è¡Œç‰¹å®šçš„åŠ¨ä½œã€‚æ‰€æœ‰è¿™äº›å‚ä¸è€…ä»¥IMSä¸ºæ ¸å¿ƒï¼Œæ„å»ºäº†Androidåºå¤§è€Œå¤æ‚çš„è¾“å…¥ä½“ç³»ã€‚ æ¥ä¸‹æ¥è¯¦ç»†è®¨è®ºé™¤Linuxå†…æ ¸ä»¥å¤–çš„å…¶ä»–å‚ä¸è€…çš„å·¥ä½œåŸç†ã€‚ ï¼ˆäºŒï¼‰ã€IMSçš„åˆ›å»ºä¸å¯åŠ¨IMSåˆ†ä¸ºJavaå±‚ä¸Nativeå±‚ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå…¶å¯åŠ¨è¿‡ç¨‹æ˜¯ä»Javaéƒ¨åˆ†çš„åˆå§‹åŒ–å¼€å§‹ï¼Œè¿›è€Œå®ŒæˆNativeéƒ¨åˆ†çš„åˆå§‹åŒ–ã€‚ IMSåœ¨SystemServer.startOtherServices()æ–¹æ³•ä¸­å¯åŠ¨çš„ã€‚IMSçš„è¯ç”Ÿåˆ†ä¸ºä¸¤ä¸ªé˜¶æ®µï¼š Â· åˆ›å»ºæ–°çš„IMSå¯¹è±¡ã€‚ Â· è°ƒç”¨IMSå¯¹è±¡çš„start()å‡½æ•°å®Œæˆå¯åŠ¨ã€‚ æˆ‘ä»¬å…ˆçœ‹ä¸‹æ•´ä¸ªå¯åŠ¨è¿‡ç¨‹çš„åºåˆ—å›¾ï¼Œç„¶åæ ¹æ®åºåˆ—å›¾æ¥ä¸€æ­¥æ­¥åˆ†æã€‚ Step 1ã€ SystemServer.startOtherServices()12345678910111213141516171819202122232425262728 [-&gt;frameworks/base/services/java/com/android/server/SystemServer.java] private void startOtherServices() &#123; ...... try &#123; ...... // â‘  æ–°å»ºIMSå¯¹è±¡ã€‚ traceBeginAndSlog(\"StartInputManagerService\"); inputManager = new InputManagerService(context); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); traceBeginAndSlog(\"StartWindowManagerService\"); wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore); //å°†WindowManagerServiceåŠ å…¥åˆ°ServiceManagerä¸­ ServiceManager.addService(Context.WINDOW_SERVICE, wm); //å°†InputManagerServiceåŠ å…¥åˆ°ServiceManagerä¸­ ServiceManager.addService(Context.INPUT_SERVICE, inputManager); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); mActivityManagerService.setWindowManager(wm); // è®¾ç½®å‘WMSå‘èµ·å›è°ƒçš„callbackå¯¹è±¡ inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); // â‘¡ æ­£å¼å¯åŠ¨IMS inputManager.start(); &#125;&#125; åœ¨SystemServerä¸­å…ˆæ„é€ äº†ä¸€ä¸ªInputManagerServiceå¯¹è±¡å’Œä¸€ä¸ªWindowManagerServiceå¯¹è±¡ï¼Œç„¶åå°†InputManagerServiceå¯¹è±¡ä¼ ç»™WindowManagerServiceå¯¹è±¡ï¼ŒWindowManagerServiceä¸­åˆå§‹åŒ–äº†ä¸€ä¸ªInputMonitorå¯¹è±¡ï¼Œè°ƒç”¨InputManagerService.setWindowManagerCallbackså‡½æ•°å°†InputMonitorä¼ è¿›å»ï¼Œåé¢nativeå±‚å›è°ƒæ—¶ä¼šè°ƒç”¨åˆ°è¯¥InputMonitorå¯¹è±¡ã€‚ Step 2ã€ InputManagerService()1234567891011 [-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java] public InputManagerService(Context context) &#123; this.mContext = context; //æ³¨æ„è¿™é‡Œæ‹¿äº†DisplayThreadçš„Handlerï¼Œæ„å‘³ç€IMSä¸­çš„æ¶ˆæ¯é˜Ÿåˆ—å¤„ç†éƒ½æ˜¯åœ¨å•ç‹¬çš„DisplayThreadä¸­è¿›è¡Œçš„ã€‚ //å®ƒæ˜¯ç³»ç»Ÿä¸­å…±äº«çš„å•ä¾‹å‰å°çº¿ç¨‹ï¼Œä¸»è¦ç”¨ä½œè¾“å…¥è¾“å‡ºçš„å¤„ç†ç”¨ã€‚è¿™æ ·å¯ä»¥ä½¿ç”¨æˆ·ä½“éªŒæ•æ„Ÿçš„å¤„ç†å°‘å—å…¶å®ƒå·¥ä½œçš„å½±å“ï¼Œå‡å°‘å»¶æ—¶ã€‚ this.mHandler = new InputManagerHandler(DisplayThread.get().getLooper()); //è°ƒç”¨nativeInitæ¥æ‰§è¡ŒC++å±‚çš„åˆå§‹åŒ–æ“ä½œ mPtr = nativeInit(this, mContext, mHandler.getLooper().getQueue()); LocalServices.addService(InputManagerInternal.class, new LocalService());&#125; Step 3ã€ InputManagerService.nativeInit()1234567891011121314[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]static jlong nativeInit(JNIEnv* env, jclass /* clazz */, jobject serviceObj, jobject contextObj, jobject messageQueueObj) &#123;sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);...... // æ–°å»ºäº†ä¸€ä¸ªNativeInputManagerå¯¹è±¡ï¼ŒNativeInputManagerï¼Œæ­¤å¯¹è±¡å°†æ˜¯Nativeå±‚ç»„ä»¶ä¸ //Javaå±‚IMSè¿›è¡Œé€šä¿¡çš„æ¡¥æ¢NativeInputManager* im = new NativeInputManager(contextObj, serviceObj, messageQueue-&gt;getLooper());im-&gt;incStrong(0);// è¿”å›äº†NativeInputManagerå¯¹è±¡çš„æŒ‡é’ˆç»™Javaå±‚çš„IMSï¼ŒIMSå°†å…¶ä¿å­˜åœ¨mPtræˆå‘˜å˜é‡ä¸­return reinterpret_cast&lt;jlong&gt;(im);&#125; è¿™ä¸ªå‡½æ•°ä¸»è¦ä½œç”¨æ˜¯åˆ›å»ºä¸€ä¸ªNativeInputManagerå®ä¾‹ï¼Œå¹¶å°†å…¶ä½œä¸ºè¿”å›å€¼ä¿å­˜åœ¨InputManagerService.javaä¸­çš„mPtrå­—æ®µä¸­ã€‚ Step 4ã€NativeInputManager()1234567891011[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]NativeInputManager::NativeInputManager(jobject contextObj, jobject serviceObj, const sp&lt;Looper&gt;&amp; looper) : mLooper(looper), mInteractive(true) &#123;// å‡ºç°é‡ç‚¹äº†ï¼Œ NativeInputManageråˆ›å»ºäº†EventHub//æ„é€ ä¸€ä¸ªEventHubå¯¹è±¡,æœ€åŸå§‹çš„è¾“å…¥äº‹ä»¶éƒ½æ˜¯é€šè¿‡å®ƒæ”¶é›†å¹¶ä¸”ç²—åŠ å·¥ç„¶åç»™åˆ°InputReaderå¯¹è±¡sp&lt;EventHub&gt; eventHub = new EventHub();// æ¥ç€åˆ›å»ºäº†Nativeå±‚çš„InputManagermInputManager = new InputManager(eventHub, this, this);&#125; NativeInputManageræ„é€ å‡½æ•°ä¸­åˆ›å»ºäº†ä¸€ä¸ªEventHubå®ä¾‹ï¼ˆç¨åä¼šè¯¦ç»†ä»‹ç»ï¼‰ï¼Œå¹¶ä¸”å°†è¿™ä¸ªå®ä¾‹ä½œä¸ºå‚æ•°æ¥åˆ›å»ºä¸€ä¸ªInputManagerå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ä¼šåšä¸€äº›åˆå§‹åŒ–çš„æ“ä½œã€‚ Step 5ã€InputManager()12345678910[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]InputManager::InputManager( const sp&lt;EventHubInterface&gt;&amp; eventHub, const sp&lt;InputReaderPolicyInterface&gt;&amp; readerPolicy, const sp&lt;InputDispatcherPolicyInterface&gt;&amp; dispatcherPolicy) &#123;mDispatcher = new InputDispatcher(dispatcherPolicy);mReader = new InputReader(eventHub, readerPolicy, mDispatcher);initialize();&#125; è¿™é‡Œåˆ›å»ºäº†InputDispatcherå¯¹è±¡ç”¨äºåˆ†å‘æŒ‰é”®ç»™å½“å‰focusçš„çª—å£çš„ï¼ŒåŒæ—¶åˆ›å»ºäº†ä¸€ä¸ªInputReaderç”¨äºä»EventHubä¸­è¯»å–äº‹ä»¶ã€‚ Step 6ã€InputManager.initialize()12345678[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]void InputManager::initialize() &#123; // åˆ›å»ºä¾›InputReaderè¿è¡Œçš„çº¿ç¨‹InputReaderThreadmReaderThread = new InputReaderThread(mReader); // åˆ›å»ºä¾›InputDispatcherè¿è¡Œçš„çº¿ç¨‹InputDispatcherThreadmDispatcherThread = new InputDispatcherThread(mDispatcher);&#125; è¿™é‡Œåˆ›å»ºäº†ä¸€ä¸ªInputReaderThreadå’ŒInputDispatcherThreadå¯¹è±¡ï¼Œå‰é¢æ„é€ å‡½æ•°ä¸­åˆ›å»ºçš„InputReaderå®é™…ä¸Šæ˜¯é€šè¿‡InputReaderThreadæ¥è¯»å–äº‹ä»¶ï¼Œè€ŒInputDispatcherå®é™…é€šè¿‡InputDispatcherThreadæ¥åˆ†å‘äº‹ä»¶ å›¾3-1ï¼š InputManagerçš„æ„é€ å‡½æ•°ä¹Ÿæ¯”è¾ƒç®€æ´ï¼Œå®ƒåˆ›å»ºäº†å››ä¸ªå¯¹è±¡ï¼Œåˆ†åˆ«ä¸ºIMSçš„æ ¸å¿ƒå‚ä¸è€…InputReaderä¸InputDispatcherï¼Œä»¥åŠå®ƒä»¬æ‰€åœ¨çš„çº¿ç¨‹InputReaderThreadä¸InputDispatcherThreadã€‚æ³¨æ„InputManagerçš„æ„é€ å‡½æ•°çš„å‚æ•°readerPolicyä¸dispatcherPolicyï¼Œå®ƒä»¬éƒ½æ˜¯NativeInputManagerã€‚ è‡³æ­¤ï¼ŒIMSçš„åˆ›å»ºå®Œæˆäº†ã€‚åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œè¾“å…¥ç³»ç»Ÿçš„é‡è¦å‚ä¸è€…å‡å®Œæˆåˆ›å»ºï¼Œå¹¶å¾—åˆ°äº†å¦‚å›¾3-1æ‰€æè¿°çš„ä¸€å¥—ä½“ç³»ã€‚ ä¾æ¬¡åˆå§‹åŒ–NativeInputManagerï¼ŒEventHubï¼ŒInputManager, InputDispatcherï¼ŒInputReaderï¼ŒInputReaderThread, InputDispatcherThreadã€‚NativeInputManagerå¯çœ‹ä½œIMSå’ŒInputManagerçš„ä¸­é—´å±‚ï¼Œå°†IMSçš„è¯·æ±‚è½¬åŒ–ä¸ºå¯¹InputManageråŠå…¶å†…éƒ¨å¯¹è±¡çš„æ“ä½œï¼ŒåŒæ—¶å°†InputManagerä¸­æ¨¡å—çš„è¯·æ±‚é€šè¿‡JNIè°ƒå›IMSã€‚InputManageræ˜¯è¾“å…¥æ§åˆ¶ä¸­å¿ƒï¼Œå®ƒæœ‰ä¸¤ä¸ªå…³é”®çº¿ç¨‹InputReaderThreadå’ŒInputDispatcherThreadï¼Œå®ƒä»¬çš„ä¸»è¦åŠŸèƒ½éƒ¨åˆ†åˆ†åˆ«åœ¨InputReaderå’ŒInputDispacherã€‚å‰è€…ç”¨äºä»è®¾å¤‡ä¸­è¯»å–äº‹ä»¶ï¼Œåè€…å°†äº‹ä»¶åˆ†å‘ç»™ç›®æ ‡çª—å£ã€‚EventHubæ˜¯è¾“å…¥è®¾å¤‡çš„æ§åˆ¶ä¸­å¿ƒï¼Œå®ƒç›´æ¥ä¸input driveræ‰“äº¤é“ã€‚è´Ÿè´£å¤„ç†è¾“å…¥è®¾å¤‡çš„å¢å‡ï¼ŒæŸ¥è¯¢ï¼Œè¾“å…¥äº‹ä»¶çš„å¤„ç†å¹¶å‘ä¸Šå±‚æä¾›getEvents()æ¥å£æ¥æ”¶äº‹ä»¶ã€‚åœ¨å®ƒçš„æ„é€ å‡½æ•°ä¸­ï¼Œä¸»è¦åšä¸‰ä»¶äº‹ï¼ˆç»“åˆä¹‹å‰Linuxå¿…å¤‡çŸ¥è¯†ï¼‰ï¼š åˆ›å»ºepollå¯¹è±¡ï¼Œä¹‹åå°±å¯ä»¥æŠŠå„è¾“å…¥è®¾å¤‡çš„fdæŒ‚åœ¨ä¸Šé¢å¤šè·¯ç­‰å¾…è¾“å…¥äº‹ä»¶ã€‚ å»ºç«‹ç”¨äºå”¤é†’çš„pipeï¼ŒæŠŠè¯»ç«¯æŒ‚åˆ°epollä¸Šï¼Œä»¥åå¦‚æœæœ‰è®¾å¤‡å‚æ•°çš„å˜åŒ–éœ€è¦å¤„ç†ï¼Œè€ŒgetEvents()åˆé˜»å¡åœ¨è®¾å¤‡ä¸Šï¼Œå°±å¯ä»¥è°ƒç”¨wake()åœ¨pipeçš„å†™ç«¯å†™å…¥ï¼Œå°±å¯ä»¥è®©çº¿ç¨‹ä»ç­‰å¾…ä¸­è¿”å›ã€‚ åˆ©ç”¨inotifyæœºåˆ¶ç›‘å¬/dev/inputç›®å½•ä¸‹çš„å˜æ›´ï¼Œå¦‚æœ‰åˆ™æ„å‘³ç€è®¾å¤‡çš„å˜åŒ–ï¼Œéœ€è¦å¤„ç†ã€‚ å› ä¸ºäº‹ä»¶çš„å¤„ç†æ˜¯æµæ°´çº¿ï¼Œéœ€è¦InputReaderå…ˆè¯»äº‹ä»¶ï¼Œç„¶åInputDispatcheræ‰èƒ½è¿›ä¸€æ­¥å¤„ç†å’Œåˆ†å‘ã€‚å› æ­¤InputDispatcheréœ€è¦ç›‘å¬InputReaderã€‚è¿™é‡Œä½¿ç”¨äº†Listeneræ¨¡å¼ï¼ŒInputDispacherä½œä¸ºInputReaderæ„é€ å‡½æ•°çš„ç¬¬ä¸‰ä¸ªå‚æ•°ï¼Œå®ƒå®ç°InputListenerInterfaceæ¥å£ã€‚åˆ°äº†InputReaderçš„æ„é€ å‡½æ•°ä¸­ï¼Œå°†ä¹‹åŒ…è£…æˆQueuedInputListenerã€‚QueuedInputListenerä¸­çš„æˆå‘˜å˜é‡mArgsQueueæ˜¯ä¸€ä¸ªç¼“å†²é˜Ÿåˆ—ï¼Œåªæœ‰åœ¨flush()æ—¶ï¼Œæ‰ä¼šä¸€æ¬¡æ€§é€šçŸ¥InputDispatcherã€‚QueuedInputListeneråº”ç”¨äº†Commandæ¨¡å¼ï¼Œå®ƒé€šè¿‡åŒ…è£…InputDispatcher(å®ç°InputListenerInterfaceæ¥å£)ï¼Œå°†äº‹ä»¶çš„å¤„ç†è¯·æ±‚å°è£…æˆNotifyArgsï¼Œä½¿å…¶æœ‰äº†ç¼“å†²æ‰§è¡Œçš„åŠŸèƒ½ã€‚ IMSçš„æˆå‘˜å…³ç³» ï¼ˆä¸‰ï¼‰ã€IMSå¯åŠ¨IMSå¯åŠ¨ä¸»è¦æ˜¯å°†å‰é¢åˆ›å»ºçš„InputReaderThreadå’ŒInputDispatcherThreadå¯åŠ¨èµ·æ¥ Step 1ã€InputManagerService.start()1234567[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]public void start() &#123; Slog.i(TAG, \"Starting input manager\"); nativeStart(mPtr); ...&#125; è¯¥å‡½æ•°ä¸»è¦è°ƒç”¨äº†nativeStartè¿›å…¥nativeå±‚å¯åŠ¨ Step 2. InputManagerService.nativeStart()1234567[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]static void nativeStart(JNIEnv* env, jclass /* clazz */, jlong ptr) &#123;NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr);status_t result = im-&gt;getInputManager()-&gt;start();&#125; è¿›å…¥nativeå±‚InputManagerçš„startå‡½æ•° Step 3ã€InputManager.start()1234567[-&gt;frameworks/native/services/inputflinger/InputManager.cpp]status_t InputManager::start() &#123;status_t result = mDispatcherThread-&gt;run(\"InputDispatcher\", PRIORITY_URGENT_DISPLAY);result = mReaderThread-&gt;run(\"InputReader\", PRIORITY_URGENT_DISPLAY);return OK;&#125; è¿™ä¸ªå‡½æ•°å®é™…å¯åŠ¨äº†ä¸€ä¸ªInputReaderThreadå’ŒInputDispatcherThreadæ¥ä»è¯»å–å’Œåˆ†å‘é”®ç›˜æ¶ˆæ¯ï¼Œè°ƒç”¨å®ƒä»¬çš„runæ–¹æ³•åï¼Œå°±ä¼šè¿›å…¥threadLoopå‡½æ•°ä¸­ï¼Œåªè¦threadLoopå‡½æ•°è¿”å›trueï¼Œè¯¥å‡½æ•°å°±ä¼šå¾ªç¯æ‰§è¡Œã€‚ InputReaderThreadä¸æ–­è°ƒç”¨InputReaderçš„pollOnce()-&gt;getEvents()å‡½æ•°æ¥å¾—åˆ°äº‹ä»¶ï¼Œè¿™äº›äº‹ä»¶å¯ä»¥æ˜¯è¾“å…¥äº‹ä»¶ï¼Œä¹Ÿå¯ä»¥æ˜¯ç”±inotifyç›‘æµ‹åˆ°è®¾å¤‡å¢å‡å˜æ›´æ‰€è§¦å‘çš„äº‹ä»¶ï¼Œç¨åä¼šè¯¦ç»†ä»‹ç»ã€‚ Step 4ã€InputReaderThread.threadLoop()123456[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]bool InputReaderThread::threadLoop() &#123;mReader-&gt;loopOnce();return true;&#125; è¿™é‡Œè°ƒç”¨å‰é¢åˆ›å»ºçš„InputReaderThreadå¯¹è±¡çš„loopOnceè¿›è¡Œä¸€æ¬¡çº¿ç¨‹å¾ªç¯ Step5ã€InputReaderThread.loopOnce()123456789101112131415161718192021[-&gt;frameworks/native/services/inputflinger/InputReader.cpp] void InputReader::loopOnce() &#123;....../* â‘  é€šè¿‡EventHubæŠ½å–äº‹ä»¶åˆ—è¡¨ã€‚è¯»å–çš„ç»“æœå­˜å‚¨åœ¨å‚æ•°mEventBufferä¸­ï¼Œè¿”å›å€¼è¡¨ç¤ºäº‹ä»¶çš„ä¸ªæ•° å½“EventHubä¸­æ— äº‹ä»¶å¯ä»¥æŠ½å–æ—¶ï¼Œæ­¤å‡½æ•°çš„è°ƒç”¨å°†ä¼šé˜»å¡ç›´åˆ°äº‹ä»¶åˆ°æ¥æˆ–è€…è¶…æ—¶ */size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);&#123; AutoMutex _l(mLock); ...... if(count) &#123; // â‘¡ å¦‚æœæœ‰æŠ½å¾—äº‹ä»¶ï¼Œåˆ™è°ƒç”¨processEventsLocked()å‡½æ•°å¯¹äº‹ä»¶è¿›è¡ŒåŠ å·¥å¤„ç† processEventsLocked(mEventBuffer, count); &#125; ......&#125;....../* â‘¢ å‘å¸ƒäº‹ä»¶ã€‚ processEventsLocked()å‡½æ•°åœ¨å¯¹äº‹ä»¶è¿›è¡ŒåŠ å·¥å¤„ç†ä¹‹åï¼Œä¾¿å°†å¤„ç†åçš„äº‹ä»¶å­˜å‚¨åœ¨ mQueuedListenerä¸­ã€‚åœ¨å¾ªç¯çš„æœ€åï¼Œé€šè¿‡è°ƒç”¨flush()å‡½æ•°å°†æ‰€æœ‰äº‹ä»¶äº¤ä»˜ç»™InputDispatcher */ mQueuedListener-&gt;flush(); &#125; InputReaderçš„ä¸€æ¬¡çº¿ç¨‹å¾ªç¯çš„å·¥ä½œæ€è·¯æ¯”è¾ƒæ¸…æ™°ï¼Œä¸€å…±ä¸‰æ­¥ï¼š Â· é¦–å…ˆä»EventHubä¸­æŠ½å–æœªå¤„ç†çš„äº‹ä»¶åˆ—è¡¨ã€‚è¿™äº›äº‹ä»¶åˆ†ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è¯»å–çš„åŸå§‹è¾“å…¥äº‹ä»¶ï¼Œå¦ä¸€ç±»åˆ™æ˜¯è¾“å…¥è®¾å¤‡å¯ç”¨æ€§å˜åŒ–äº‹ä»¶ï¼Œç®€ç§°ä¸ºè®¾å¤‡äº‹ä»¶ã€‚ Â· é€šè¿‡processEventsLocked()å¯¹äº‹ä»¶è¿›è¡Œå¤„ç†ã€‚å¯¹äºè®¾å¤‡äº‹ä»¶ï¼Œæ­¤å‡½æ•°å¯¹æ ¹æ®è®¾å¤‡çš„å¯ç”¨æ€§åŠ è½½æˆ–ç§»é™¤è®¾å¤‡å¯¹åº”çš„é…ç½®ä¿¡æ¯ã€‚å¯¹äºåŸå§‹è¾“å…¥äº‹ä»¶ï¼Œåˆ™åœ¨è¿›è¡Œè½¬è¯‘ã€å°è£…ä¸åŠ å·¥åå°†ç»“æœæš‚å­˜åˆ°mQueuedListenerä¸­ã€‚ Â· æ‰€æœ‰äº‹ä»¶å¤„ç†å®Œæ¯•åï¼Œè°ƒç”¨mQueuedListener.flush()å°†æ‰€æœ‰æš‚å­˜çš„è¾“å…¥äº‹ä»¶ä¸€æ¬¡æ€§åœ°äº¤ä»˜ç»™InputDispatcherã€‚ è¿™ä¾¿æ˜¯InputReaderçš„æ€»ä½“å·¥ä½œæµç¨‹ã€‚è€Œæˆ‘ä»¬æ¥ä¸‹æ¥å°†è¯¦ç»†è®¨è®ºè¿™ä¸‰æ­¥çš„å®ç°ã€‚ Step 6ã€InputDispatcherThread.threadLoop()InputDisptacherçš„ä¸»è¦ä»»åŠ¡æ˜¯æŠŠæ”¶åˆ°çš„è¾“å…¥äº‹ä»¶å‘é€åˆ°PhoneWIndowManageræˆ–Appç«¯çš„ç„¦ç‚¹çª—å£ä¸Šï¼Œç¨åè¯¦ç»†ä»‹ç»ã€‚ 123456[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]bool InputDispatcherThread::threadLoop() &#123;mDispatcher-&gt;dispatchOnce();return true;&#125; è¿™é‡Œè°ƒç”¨å‰é¢åˆ›å»ºçš„InputDispatcherå¯¹è±¡çš„dispatchOnceå‡½æ•°è¿›è¡Œä¸€æ¬¡æŒ‰é”®åˆ†å‘ Step 7ã€InputDispatcher.dispatchOnce()12345678910111213141516171819[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchOnce() &#123;nsecs_t nextWakeupTime = LONG_LONG_MAX;&#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125;&#125; // release lock// Wait for callback or timeout or wake. (make sure we round up, not down)nsecs_t currentTime = now();int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);mLooper-&gt;pollOnce(timeoutMillis);&#125; ä¸Šè¿°å‡½æ•°ä¸»è¦æ˜¯è°ƒç”¨dispatchOnceInnerLockedæ¥è¿›è¡Œä¸€æ¬¡æŒ‰é”®åˆ†å‘ï¼Œå½“æ²¡æœ‰æŒ‰é”®æ¶ˆæ¯æ—¶ä¼šèµ°åˆ°mLooper-&gt;pollOnce(timeoutMillis)ï¼›è¿™ä¸ªå‡½æ•°ä¼šè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œå½“æœ‰æŒ‰é”®æ¶ˆæ¯å‘ç”Ÿæ—¶è¯¥å‡½æ•°ä¼šè¿”å›ï¼Œç„¶åèµ°åˆ°dispatchOnceInnerLockedå‡½æ•°ã€‚è¿™é‡ŒmLooper-&gt;pollOnceä¸ºä½•ä¼šç¡çœ æ¶‰åŠåˆ°Androidçš„Handleræœºåˆ¶[â˜ºå†æ€»ç»“â˜º]ã€‚ å°ç»“ï¼šå®ŒæˆIMSçš„åˆ›å»ºä¹‹åï¼ŒInputManagerService.start()å‡½æ•°ä»¥å¯åŠ¨IMSã€‚InputManagerçš„åˆ›å»ºè¿‡ç¨‹åˆ†åˆ«ä¸ºInputReaderä¸InputDispatcheråˆ›å»ºäº†æ‰¿è½½å®ƒä»¬è¿è¡Œçš„çº¿ç¨‹ï¼Œç„¶è€Œå¹¶æœªå°†è¿™ä¸¤ä¸ªçº¿ç¨‹å¯åŠ¨ï¼Œå› æ­¤IMSçš„å„å‘˜å¤§å°†ä»å¤„äºå¾…å‘½çŠ¶æ€ã€‚æ­¤æ—¶start()å‡½æ•°çš„åŠŸèƒ½å°±æ˜¯å¯åŠ¨è¿™ä¸¤ä¸ªçº¿ç¨‹ï¼Œä½¿å¾—InputReaderäºInputDispatcherå¼€å§‹å·¥ä½œã€‚ å½“ä¸¤ä¸ªçº¿ç¨‹å¯åŠ¨åï¼ŒInputReaderåœ¨å…¶çº¿ç¨‹å¾ªç¯ä¸­ä¸æ–­åœ°ä»EventHubä¸­æŠ½å–åŸå§‹è¾“å…¥äº‹ä»¶ï¼Œè¿›è¡ŒåŠ å·¥å¤„ç†åå°†åŠ å·¥æ‰€å¾—çš„äº‹ä»¶æ”¾å…¥InputDispatcherçš„æ´¾å‘å‘é˜Ÿåˆ—ä¸­ã€‚InputDispatcheråˆ™åœ¨å…¶çº¿ç¨‹å¾ªç¯ä¸­å°†æ´¾å‘é˜Ÿåˆ—ä¸­çš„äº‹ä»¶å–å‡ºï¼ŒæŸ¥æ‰¾åˆé€‚çš„çª—å£ï¼Œå°†äº‹ä»¶å†™å…¥åˆ°çª—å£çš„äº‹ä»¶æ¥æ”¶ç®¡é“ä¸­ã€‚çª—å£äº‹ä»¶æ¥æ”¶çº¿ç¨‹çš„Looperä»ç®¡é“ä¸­å°†äº‹ä»¶å–å‡ºï¼Œäº¤ç”±äº‹ä»¶å¤„ç†å‡½æ•°è¿›è¡Œäº‹ä»¶å“åº”ã€‚æ•´ä¸ªè¿‡ç¨‹å…±æœ‰ä¸‰ä¸ªçº¿ç¨‹é¦–å°¾ç›¸æ¥ï¼Œåƒä¸‰å°æ°´æ³µä¼¼çš„ä¸€å±‚å±‚åœ°å°†äº‹ä»¶äº¤ä»˜ç»™äº‹ä»¶å¤„ç†å‡½æ•°ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ InputManagerService.start()å‡½æ•°çš„ä½œç”¨ï¼Œå°±åƒä¸ºReaderçº¿ç¨‹ã€Dispatcherçº¿ç¨‹è¿™ä¸¤å°æ°´æ³µæŒ‰ä¸‹å¼€å…³ï¼Œè€ŒLooperè¿™å°æ°´æ³µåœ¨çª—å£åˆ›å»ºæ—¶ä¾¿å·²ç»å¤„äºè¿è¡ŒçŠ¶æ€äº†ã€‚è‡ªæ­¤ï¼Œè¾“å…¥ç³»ç»ŸåŠ¨åŠ›åè¶³åœ°å¼€å§‹è¿è½¬ï¼Œè®¾å¤‡èŠ‚ç‚¹ä¸­çš„è¾“å…¥äº‹ä»¶å°†è¢«æºæºä¸æ–­åœ°æŠ½å–ç»™äº‹ä»¶å¤„ç†è€…ã€‚ å››ã€æ·±å…¥ç†è§£EventHubInputReaderThreadç»§æ‰¿è‡ªC++çš„Threadç±»ï¼ŒThreadç±»å°è£…äº†pthreadçº¿ç¨‹å·¥å…·ï¼Œæä¾›äº†ä¸Javaå±‚Threadç±»ç›¸ä¼¼çš„APIã€‚C++çš„Threadç±»æä¾›äº†ä¸€ä¸ªåä¸ºthreadLoop()çš„çº¯è™šå‡½æ•°ï¼Œå½“çº¿ç¨‹å¼€å§‹è¿è¡Œåï¼Œå°†ä¼šåœ¨å†…å»ºçš„çº¿ç¨‹å¾ªç¯ä¸­ä¸æ–­åœ°è°ƒç”¨threadLoop()ï¼Œç›´åˆ°æ­¤å‡½æ•°è¿”å›falseï¼Œåˆ™é€€å‡ºçº¿ç¨‹å¾ªç¯ï¼Œä»è€Œç»“æŸçº¿ç¨‹ã€‚ InputReaderThreadå¯åŠ¨åï¼Œå…¶çº¿ç¨‹å¾ªç¯å°†ä¸æ–­åœ°æ‰§è¡ŒInputReader.loopOnce()å‡½æ•°ã€‚å› æ­¤è¿™ä¸ªloopOnce()å‡½æ•°ä½œä¸ºçº¿ç¨‹å¾ªç¯çš„å¾ªç¯ä½“åŒ…å«äº†InputReaderçš„æ‰€æœ‰å·¥ä½œã€‚å‰é¢ä¸€å°èŠ‚ Step5. InputReaderThread.loopOnce() å·²ç»è¯´åˆ°InputReaderThreadä¸€æ¬¡çº¿ç¨‹å¾ªç¯ã€‚æ¥ä¸‹æ¥è¯¦ç»†è¯´æ˜EventHubã€‚ Â· é¦–å…ˆä»EventHubä¸­æŠ½å–æœªå¤„ç†çš„äº‹ä»¶åˆ—è¡¨ã€‚è¿™äº›äº‹ä»¶åˆ†ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è¯»å–çš„åŸå§‹è¾“å…¥äº‹ä»¶ï¼Œå¦ä¸€ç±»åˆ™æ˜¯è¾“å…¥è®¾å¤‡å¯ç”¨æ€§å˜åŒ–äº‹ä»¶ï¼Œç®€ç§°ä¸ºè®¾å¤‡äº‹ä»¶ã€‚ 123456789 [-&gt;frameworks/native/services/inputflinger/InputReader.cpp] void InputReader::loopOnce() &#123;....../* â‘  é€šè¿‡EventHubæŠ½å–äº‹ä»¶åˆ—è¡¨ã€‚è¯»å–çš„ç»“æœå­˜å‚¨åœ¨å‚æ•°mEventBufferä¸­ï¼Œè¿”å›å€¼è¡¨ç¤ºäº‹ä»¶çš„ä¸ªæ•° å½“EventHubä¸­æ— äº‹ä»¶å¯ä»¥æŠ½å–æ—¶ï¼Œæ­¤å‡½æ•°çš„è°ƒç”¨å°†ä¼šé˜»å¡ç›´åˆ°äº‹ä»¶åˆ°æ¥æˆ–è€…è¶…æ—¶ */size_tcount = mEventHub-&gt;getEvents(timeoutMillis,mEventBuffer, EVENT_BUFFER_SIZE);......&#125; é¦–å…ˆè´´ä¸€å¼ EventHub-&gt;getEvents()å·¥ä½œæ—¶åºå›¾ï¼Œè·Ÿç€æ—¶åºå›¾ä¸€æ­¥æ­¥ä»‹ç»ã€‚ ï¼ˆ1ï¼‰ã€æ·±å…¥ç†è§£EventHub1ã€è®¾å¤‡èŠ‚ç‚¹ç›‘å¬çš„å»ºç«‹123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263frameworks/native/services/inputflinger/EventHub.cppEventHub::EventHub(void) : mBuiltInKeyboardId(NO_BUILT_IN_KEYBOARD), mNextDeviceId(1), mControllerNumbers(), mOpeningDevices(0), mClosingDevices(0), mNeedToSendFinishedDeviceScan(false), mNeedToReopenDevices(false), mNeedToScanDevices(true), mPendingEventCount(0), mPendingEventIndex(0), mPendingINotify(false) &#123;acquire_wake_lock(PARTIAL_WAKE_LOCK, WAKE_LOCK_ID);// â‘  é¦–å…ˆä½¿ç”¨epoll_create()å‡½æ•°åˆ›å»ºä¸€ä¸ªepollå¯¹è±¡ã€‚EPOLL_SIZE_HINTæŒ‡å®šæœ€å¤§ç›‘å¬ä¸ªæ•°ä¸º8//è¿™ä¸ªepollå¯¹è±¡å°†ç”¨æ¥ç›‘å¬è®¾å¤‡èŠ‚ç‚¹æ˜¯å¦æœ‰æ•°æ®å¯è¯»ï¼ˆæœ‰æ— äº‹ä»¶ï¼‰mEpollFd = epoll_create(EPOLL_SIZE_HINT);LOG_ALWAYS_FATAL_IF(mEpollFd &lt; 0, \"Could not create epoll instance. errno=%d\", errno);// â‘¡ åˆ›å»ºä¸€ä¸ªinotifyå¯¹è±¡ã€‚è¿™ä¸ªinotifyå¯¹è±¡å°†è¢«ç”¨æ¥ç›‘å¬è®¾å¤‡èŠ‚ç‚¹çš„å¢åˆ äº‹ä»¶mINotifyFd = inotify_init(); //å°†å­˜å‚¨è®¾å¤‡èŠ‚ç‚¹çš„è·¯å¾„/dev/inputä½œä¸ºç›‘å¬å¯¹è±¡æ·»åŠ åˆ°inotifyå¯¹è±¡ä¸­ã€‚å½“æ­¤æ–‡ä»¶å¤¹ä¸‹çš„è®¾å¤‡èŠ‚ç‚¹ //å‘ç”Ÿåˆ›å»ºä¸åˆ é™¤äº‹ä»¶æ—¶ï¼Œéƒ½å¯ä»¥é€šè¿‡mINotifyFdè¯»å–äº‹ä»¶çš„è¯¦ç»†ä¿¡æ¯ //static const char *DEVICE_PATH = \"/dev/input\";int result = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);LOG_ALWAYS_FATAL_IF(result &lt; 0, \"Could not register INotify for %s. errno=%d\", DEVICE_PATH, errno);//â‘¢ æ¥ä¸‹æ¥å°†mINotifyFdä½œä¸ºepollçš„ä¸€ä¸ªç›‘æ§å¯¹è±¡ã€‚å½“inotifyäº‹ä»¶åˆ°æ¥æ—¶ï¼Œepoll_wait()å°†//ç«‹åˆ»è¿”å›ï¼ŒEventHubä¾¿å¯ä»mINotifyFdä¸­è¯»å–è®¾å¤‡èŠ‚ç‚¹çš„å¢åˆ ä¿¡æ¯ï¼Œå¹¶ä½œç›¸åº”å¤„ç†struct epoll_event eventItem;memset(&amp;eventItem, 0, sizeof(eventItem));eventItem.events = EPOLLIN;// ç›‘å¬mINotifyFdå¯è¯»eventItem.data.u32 = EPOLL_ID_INOTIFY; // æ³¨æ„è¿™é‡Œå¹¶æ²¡æœ‰ä½¿ç”¨fdå­—æ®µï¼Œè€Œä½¿ç”¨äº†è‡ªå®šä¹‰çš„å€¼EPOLL_ID_INOTIFYresult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);// å°†å¯¹mINotifyFdçš„ç›‘å¬æ³¨å†Œåˆ°epollå¯¹è±¡ä¸­LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add INotify to epoll instance. errno=%d\", errno);//åœ¨æ„é€ å‡½æ•°å‰©ä½™çš„ä»£ç ä¸­ï¼ŒEventHubåˆ›å»ºäº†ä¸€ä¸ªåä¸ºwakeFdsçš„åŒ¿åç®¡é“ï¼Œå¹¶å°†ç®¡é“è¯»å–ç«¯çš„æè¿°ç¬¦//çš„å¯è¯»äº‹ä»¶æ³¨å†Œåˆ°epollå¯¹è±¡ä¸­ã€‚å› ä¸ºInputReaderåœ¨æ‰§è¡ŒgetEvents()æ—¶ä¼šå› æ— äº‹ä»¶è€Œå¯¼è‡´å…¶çº¿ç¨‹//é˜»å¡åœ¨epoll_wait()çš„è°ƒç”¨é‡Œï¼Œç„¶è€Œæœ‰æ—¶å¸Œæœ›èƒ½å¤Ÿç«‹åˆ»å”¤é†’InputReaderçº¿ç¨‹ä½¿å…¶å¤„ç†ä¸€äº›è¯·æ±‚ã€‚æ­¤//æ—¶åªéœ€å‘wakeFdsç®¡é“çš„å†™å…¥ç«¯å†™å…¥ä»»æ„æ•°æ®ï¼Œæ­¤æ—¶è¯»å–ç«¯æœ‰æ•°æ®å¯è¯»ï¼Œä½¿å¾—epoll_wait()å¾—ä»¥è¿”å›//ä»è€Œè¾¾åˆ°å”¤é†’InputReaderçº¿ç¨‹çš„ç›®çš„int wakeFds[2];result = pipe(wakeFds);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not create wake pipe. errno=%d\", errno);mWakeReadPipeFd = wakeFds[0];mWakeWritePipeFd = wakeFds[1];result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake read pipe non-blocking. errno=%d\", errno);result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not make wake write pipe non-blocking. errno=%d\", errno);eventItem.data.u32 = EPOLL_ID_WAKE;result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);LOG_ALWAYS_FATAL_IF(result != 0, \"Could not add wake read pipe to epoll instance. errno=%d\", errno);int major, minor;getLinuxRelease(&amp;major, &amp;minor);// EPOLLWAKEUP was introduced in kernel 3.5mUsingEpollWakeup = major &gt; 3 || (major == 3 &amp;&amp; minor &gt;= 5);&#125; EventHubçš„æ„é€ å‡½æ•°åˆè¯†åŒ–äº†Epollå¯¹è±¡å’ŒINotifyå¯¹è±¡ï¼Œåˆ†åˆ«ç›‘å¬åŸå§‹è¾“å…¥äº‹ä»¶ä¸è®¾å¤‡èŠ‚ç‚¹å¢åˆ äº‹ä»¶ã€‚åŒæ—¶å°†INotifyå¯¹è±¡çš„å¯è¯»æ€§äº‹ä»¶ä¹Ÿæ³¨å†Œåˆ°Epollä¸­ï¼Œå› æ­¤EventHubå¯ä»¥åƒå¤„ç†åŸå§‹è¾“å…¥äº‹ä»¶ä¸€æ ·ç›‘å¬è®¾å¤‡èŠ‚ç‚¹å¢åˆ äº‹ä»¶äº†ã€‚ æ„é€ å‡½æ•°åŒæ—¶ä¹Ÿæ­ç¤ºäº†EventHubçš„ç›‘å¬å·¥ä½œåˆ†ä¸ºè®¾å¤‡èŠ‚ç‚¹å’ŒåŸå§‹è¾“å…¥äº‹ä»¶ä¸¤ä¸ªæ–¹é¢ï¼Œæ¥ä¸‹æ¥å°†æ·±å…¥æ¢è®¨è¿™ä¸¤æ–¹é¢çš„å†…å®¹ã€‚ 2ã€getEvents()å‡½æ•°çš„å·¥ä½œæ–¹å¼æ­£å¦‚å‰æ–‡æ‰€è¿°ï¼ŒInputReaderThreadçš„çº¿ç¨‹å¾ªç¯ä¸ºReaderå­ç³»ç»Ÿæä¾›äº†è¿è½¬çš„åŠ¨åŠ›ï¼ŒEventHubçš„å·¥ä½œä¹Ÿæ˜¯ç”±å®ƒé©±åŠ¨çš„ã€‚InputReader::loopOnce()å‡½æ•°è°ƒç”¨EventHub::getEvents()å‡½æ•°è·å–äº‹ä»¶åˆ—è¡¨ï¼Œæ‰€ä»¥è¿™ä¸ªgetEvents()æ˜¯EventHubè¿è¡Œçš„åŠ¨åŠ›æ‰€åœ¨ï¼Œå‡ ä¹åŒ…å«äº†EventHubçš„æ‰€æœ‰å·¥ä½œå†…å®¹ï¼Œå› æ­¤é¦–å…ˆè¦å°†getEvents()å‡½æ•°çš„å·¥ä½œæ–¹å¼ææ¸…æ¥šã€‚ getEvents()å‡½æ•°çš„ç­¾åå¦‚ä¸‹ï¼š 1size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) æ­¤å‡½æ•°å°†å°½å¯èƒ½å¤šåœ°è¯»å–è®¾å¤‡å¢åˆ äº‹ä»¶ä¸åŸå§‹è¾“å…¥äº‹ä»¶ï¼Œå°†å®ƒä»¬å°è£…ä¸ºRawEventç»“æ„ä½“ï¼Œå¹¶æ”¾å…¥bufferä¸­ä¾›InputReaderè¿›è¡Œå¤„ç†ã€‚RawEventç»“æ„ä½“çš„å®šä¹‰å¦‚ä¸‹ï¼š [EventHub.hâ€“&gt;RawEvent] 12345678struct RawEvent &#123; nsecs_t when; /* å‘ç”Ÿäº‹ä»¶æ—¶çš„æ—¶é—´æˆ³ */ int32_t deviceId; //äº§ç”Ÿäº‹ä»¶çš„è®¾å¤‡Idï¼Œå®ƒæ˜¯ç”±EventHubè‡ªè¡Œåˆ†é…çš„ï¼ŒInputReader //ä»¥æ ¹æ®å®ƒä»EventHubä¸­è·å–æ­¤è®¾å¤‡çš„è¯¦ç»†ä¿¡æ¯ int32_t type; /* äº‹ä»¶çš„ç±»å‹ */ int32_t code; /* äº‹ä»¶ä»£ç  */ int32_t value; /* äº‹ä»¶å€¼ */ &#125;; å¯ä»¥çœ‹å‡ºï¼ŒRawEventç»“æ„ä½“ä¸geteventå·¥å…·çš„è¾“å‡ºååˆ†ä¸€è‡´ï¼ŒåŒ…å«äº†åŸå§‹è¾“å…¥äº‹ä»¶çš„å››ä¸ªåŸºæœ¬å…ƒç´ ï¼Œå› æ­¤ç”¨RawEventç»“æ„ä½“è¡¨ç¤ºåŸå§‹è¾“å…¥äº‹ä»¶æ˜¯éå¸¸ç›´è§‚çš„ã€‚RawEventåŒæ—¶ä¹Ÿç”¨æ¥è¡¨ç¤ºè®¾å¤‡å¢åˆ äº‹ä»¶ï¼Œä¸ºæ­¤ï¼ŒEventHubå®šä¹‰äº†ä¸‰ä¸ªç‰¹æ®Šçš„äº‹ä»¶ç±»å‹DEVICE_ADDã€DEVICE_REMOVEDä»¥åŠFINISHED_DEVICE_SCANï¼Œç”¨ä»¥ä¸åŸå§‹è¾“å…¥äº‹ä»¶è¿›è¡ŒåŒºåˆ«ã€‚ ç”±äºgetEvents()å‡½æ•°è¾ƒä¸ºå¤æ‚ï¼Œä¸ºäº†ç»™åç»­åˆ†æé“ºå¹³é“è·¯ï¼Œæœ¬èŠ‚ä¸è®¨è®ºå…¶ç»†èŠ‚ï¼Œå…ˆé€šè¿‡ä¼ªä»£ç ç†è§£æ­¤å‡½æ•°çš„ç»“æ„ä¸å·¥ä½œæ–¹å¼ï¼Œåœ¨åç»­æ·±å…¥åˆ†ææ—¶æ€è·¯æ‰ä¼šæ¯”è¾ƒæ¸…æ™°ã€‚ getEvents()å‡½æ•°çš„æœ¬è´¨å°±æ˜¯è¯»å–å¹¶å¤„ç†Epolläº‹ä»¶ä¸INotifyäº‹ä»¶ å‚è€ƒä»¥ä¸‹ä»£ç ï¼š [EventHub.cppâ€“&gt;EventHub::getEvents()] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;// eventæŒ‡é’ˆæŒ‡å‘äº†åœ¨bufferä¸‹ä¸€ä¸ªå¯ç”¨äºå­˜å‚¨äº‹ä»¶çš„RawEventç»“æ„ä½“ã€‚æ¯å­˜å‚¨ä¸€ä¸ªäº‹ä»¶ï¼Œ// eventæŒ‡é’ˆéƒ½å›å‘ååç§»ä¸€ä¸ªå…ƒç´  */RawEvent* event = buffer;// capacityè®°å½•äº†bufferä¸­å‰©ä½™çš„å…ƒç´ æ•°é‡ã€‚å½“capacityä¸º0æ—¶ï¼Œè¡¨ç¤ºbufferå·²æ»¡ï¼Œæ­¤æ—¶éœ€è¦åœ// ç»§ç»­å¤„ç†æ–°äº‹ä»¶ï¼Œå¹¶å°†å·²å¤„ç†çš„äº‹ä»¶è¿”å›ç»™è°ƒç”¨è€…size_tcapacity = bufferSize;// æ¥ä¸‹æ¥çš„å¾ªç¯æ˜¯getEvents()å‡½æ•°çš„ä¸»ä½“ã€‚åœ¨è¿™ä¸ªå¾ªç¯ä¸­ï¼Œä¼šå…ˆå°†å¯ç”¨äº‹ä»¶æ”¾å…¥åˆ°bufferä¸­å¹¶è¿”å›ã€‚// å¦‚æœæ²¡æœ‰å¯ç”¨äº‹ä»¶ï¼Œåˆ™è¿›å…¥epoll_wait()ç­‰å¾…äº‹ä»¶çš„åˆ°æ¥ï¼Œepoll_wait()è¿”å›åä¼šé‡æ–°å¾ªç¯å°†å¯ç”¨// å°†æ–°äº‹ä»¶æ”¾å…¥bufferfor (;;)&#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); /* â‘  é¦–å…ˆè¿›è¡Œä¸è®¾å¤‡ç›¸å…³çš„å·¥ä½œã€‚æŸäº›æƒ…å†µä¸‹ï¼Œå¦‚EventHubåˆ›å»ºåç¬¬ä¸€æ¬¡æ‰§è¡ŒgetEvents()å‡½æ•° */ /* æ—¶ï¼Œéœ€è¦æ‰«æ/dev/inputæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹å¹¶å°†è¿™äº›è®¾å¤‡æ‰“å¼€ã€‚å¦å¤–ï¼Œå½“è®¾å¤‡èŠ‚ç‚¹çš„å‘ç”Ÿå¢ */ /* åŠ¨ä½œç”Ÿæ—¶ï¼Œä¼šå°†è®¾å¤‡äº‹ä»¶å­˜å…¥åˆ°bufferä¸­ */ ...... /* â‘¡ å¤„ç†æœªè¢«InputReaderå–èµ°çš„è¾“å…¥äº‹ä»¶ä¸è®¾å¤‡äº‹ä»¶ã€‚epoll_wait()æ‰€å–å‡ºçš„epoll_event */ /* å­˜å‚¨åœ¨mPendingEventItemsä¸­ï¼ŒmPendingEventCountæŒ‡å®šäº†mPendingEventItemsæ•°ç»„ */ /* æ‰€å­˜å‚¨çš„äº‹ä»¶ä¸ªæ•°ã€‚è€ŒmPendingEventIndexæŒ‡å®šå°šæœªå¤„ç†çš„epoll_eventçš„ç´¢å¼• */ while (mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; /* åœ¨è¿™é‡Œåˆ†ææ¯ä¸€ä¸ªepoll_eventï¼Œå¦‚æœæ˜¯è¡¨ç¤ºè®¾å¤‡èŠ‚ç‚¹å¯è¯»ï¼Œåˆ™è¯»å–åŸå§‹äº‹ä»¶å¹¶æ”¾ç½®åˆ°buffer */ /* ä¸­ã€‚å¦‚æœæ˜¯è¡¨ç¤ºmINotifyFdå¯è¯»ï¼Œåˆ™è®¾ç½®mPendingINotifyä¸ºtrueï¼Œå½“InputReader */ /* å°†ç°æœ‰çš„è¾“å…¥äº‹ä»¶éƒ½å–å‡ºåè¯»å–mINotifyFdä¸­çš„äº‹ä»¶ï¼Œå¹¶è¿›è¡Œç›¸åº”çš„è®¾å¤‡åŠ è½½ä¸å¸è½½æ“ä½œã€‚ */ /* å¦å¤–ï¼Œå¦‚æœæ­¤epoll_eventè¡¨ç¤ºwakeFdsçš„è¯»å–ç«¯æœ‰æ•°æ®å¯è¯»ï¼Œåˆ™è®¾ç½®awakeæ ‡å¿—ä¸ºtrueï¼Œ */ /* æ— è®ºæ­¤æ¬¡getEvents()è°ƒç”¨æœ‰æ— å–åˆ°äº‹ä»¶ï¼Œéƒ½ä¸ä¼šå†æ¬¡è¿›è¡Œepoll_wait()è¿›è¡Œäº‹ä»¶ç­‰å¾… */ ...... &#125; // â‘¢ å¦‚æœmINotifyFdæœ‰æ•°æ®å¯è¯»ï¼Œè¯´æ˜è®¾å¤‡èŠ‚ç‚¹å‘ç”Ÿäº†å¢åˆ æ“ä½œ if(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123; /* è¯»å–mINotifyFdä¸­çš„äº‹ä»¶ï¼ŒåŒæ—¶å¯¹è¾“å…¥è®¾å¤‡è¿›è¡Œç›¸åº”çš„åŠ è½½ä¸å¸è½½æ“ä½œã€‚è¿™ä¸ªæ“ä½œå¿…é¡»å½“ */ /* InputReaderå°†ç°æœ‰è¾“å…¥äº‹ä»¶è¯»å–å¹¶å¤„ç†å®Œæ¯•åæ‰èƒ½è¿›è¡Œï¼Œå› ä¸ºç°æœ‰çš„è¾“å…¥äº‹ä»¶å¯èƒ½æ¥è‡ªéœ€è¦ */ /* è¢«å¸è½½çš„è¾“å…¥è®¾å¤‡ï¼ŒInputReaderå¤„ç†è¿™äº›äº‹ä»¶ä¾èµ–äºå¯¹åº”çš„è®¾å¤‡ä¿¡æ¯ */ ...... deviceChanged= true; &#125; // è®¾å¤‡èŠ‚ç‚¹å¢åˆ æ“ä½œå‘ç”Ÿæ—¶ï¼Œåˆ™é‡æ–°æ‰§è¡Œå¾ªç¯ä½“ï¼Œä»¥ä¾¿å°†è®¾å¤‡å˜åŒ–çš„äº‹ä»¶æ”¾å…¥bufferä¸­ if(deviceChanged) &#123; continue; &#125; // å¦‚æœæ­¤æ¬¡getEvents()è°ƒç”¨æˆåŠŸè·å–äº†ä¸€äº›äº‹ä»¶ï¼Œæˆ–è€…è¦æ±‚å”¤é†’InputReaderï¼Œåˆ™é€€å‡ºå¾ªç¯å¹¶ // ç»“æŸgetEvents()çš„è°ƒç”¨ï¼Œä½¿InputReaderå¯ä»¥ç«‹åˆ»å¯¹äº‹ä»¶è¿›è¡Œå¤„ç† if(event != buffer || awoken) &#123; break; &#125; /* â‘£ å¦‚æœæ­¤æ¬¡getEvents()è°ƒç”¨æ²¡èƒ½è·å–äº‹ä»¶ï¼Œè¯´æ˜mPendingEventItemsä¸­æ²¡æœ‰äº‹ä»¶å¯ç”¨ï¼Œ */ /* äºæ˜¯æ‰§è¡Œepoll_wait()å‡½æ•°ç­‰å¾…æ–°çš„äº‹ä»¶åˆ°æ¥ï¼Œå°†ç»“æœå­˜å‚¨åˆ°mPendingEventItemsé‡Œï¼Œå¹¶é‡ */ /* ç½®mPendingEventIndexä¸º0 */ mPendingEventIndex = 0; ...... intpollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS,timeoutMillis); ...... mPendingEventCount= size_t(pollResult); // ä»epoll_wait()ä¸­å¾—åˆ°æ–°çš„äº‹ä»¶åï¼Œé‡æ–°å¾ªç¯ï¼Œå¯¹æ–°äº‹ä»¶è¿›è¡Œå¤„ç†&#125;// è¿”å›æœ¬æ¬¡getEvents()è°ƒç”¨æ‰€è¯»å–çš„äº‹ä»¶æ•°é‡returnevent - buffer;&#125; getEvents()å‡½æ•°ä½¿ç”¨Epollçš„æ ¸å¿ƒæ˜¯mPendingEventItemsæ•°ç»„ï¼Œå®ƒæ˜¯ä¸€ä¸ªäº‹ä»¶æ± ã€‚getEvents()å‡½æ•°ä¼šä¼˜å…ˆä»è¿™ä¸ªäº‹ä»¶æ± è·å–epolläº‹ä»¶è¿›è¡Œå¤„ç†ï¼Œå¹¶å°†è¯»å–ç›¸åº”çš„åŸå§‹è¾“å…¥äº‹ä»¶è¿”å›ç»™è°ƒç”¨è€…ã€‚å½“å› ä¸ºäº‹ä»¶æ± æ¯ç«­è€Œå¯¼è‡´è°ƒç”¨è€…æ— æ³•è·å¾—ä»»ä½•äº‹ä»¶æ—¶ï¼Œä¼šè°ƒç”¨epoll_wait()å‡½æ•°ç­‰å¾…æ–°äº‹ä»¶çš„åˆ°æ¥ï¼Œå°†äº‹ä»¶æ± é‡æ–°æ³¨æ»¡ï¼Œç„¶åå†é‡æ–°å¤„ç†äº‹ä»¶æ± ä¸­çš„Epolläº‹ä»¶ã€‚ä»è¿™ä¸ªæ„ä¹‰æ¥è¯´ï¼ŒgetEvents()å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹ï¼Œå°±æ˜¯æ¶ˆè´¹epoll_wait()æ‰€äº§ç”Ÿçš„Epolläº‹ä»¶çš„è¿‡ç¨‹ã€‚å› æ­¤å¯ä»¥å°†ä»epoll_wait()çš„è°ƒç”¨å¼€å§‹ï¼Œåˆ°å°†Epolläº‹ä»¶æ¶ˆè´¹å®Œæ¯•çš„è¿‡ç¨‹ç§°ä¸ºEventHubçš„ä¸€ä¸ªç›‘å¬å‘¨æœŸã€‚ä¾æ®æ¯æ¬¡epoll_wait()äº§ç”Ÿçš„Epolläº‹ä»¶çš„æ•°é‡ä»¥åŠè®¾å¤‡èŠ‚ç‚¹ä¸­åŸå§‹è¾“å…¥äº‹ä»¶çš„æ•°é‡ï¼Œä¸€ä¸ªç›‘å¬å‘¨æœŸåŒ…å«ä¸€æ¬¡æˆ–å¤šæ¬¡getEvents()è°ƒç”¨ã€‚å‘¨æœŸä¸­çš„ç¬¬ä¸€æ¬¡è°ƒç”¨ä¼šå› ä¸ºäº‹ä»¶æ± æ¯ç«­è€Œç›´æ¥è¿›å…¥epoll_wait()ï¼Œè€Œå‘¨æœŸä¸­çš„æœ€åä¸€æ¬¡è°ƒç”¨ä¸€å®šä¼šå°†æœ€åçš„äº‹ä»¶å–èµ°ã€‚ æ³¨æ„getEvents()é‡‡ç”¨äº‹ä»¶æ± æœºåˆ¶çš„æ ¹æœ¬åŸå› æ˜¯bufferçš„å®¹é‡é™åˆ¶ã€‚ç”±äºä¸€æ¬¡epoll_wait()å¯èƒ½è¿”å›å¤šä¸ªè®¾å¤‡èŠ‚ç‚¹çš„å¯è¯»äº‹ä»¶ï¼Œæ¯ä¸ªè®¾å¤‡èŠ‚ç‚¹åˆæœ‰å¯èƒ½è¯»å–å¤šæ¡åŸå§‹è¾“å…¥äº‹ä»¶ï¼Œä¸€æ®µæ—¶é—´å†…åŸå§‹è¾“å…¥äº‹ä»¶çš„æ•°é‡å¯èƒ½å¤§äºbufferçš„å®¹é‡ã€‚å› æ­¤éœ€è¦ä¸€ä¸ªäº‹ä»¶æ± ä»¥ç¼“å­˜å› bufferå®¹é‡ä¸å¤Ÿè€Œæ— æ³•å¤„ç†çš„epolläº‹ä»¶ï¼Œä»¥ä¾¿åœ¨ä¸‹æ¬¡è°ƒç”¨æ—¶å¯ä»¥å°†è¿™äº›äº‹ä»¶ä¼˜å…ˆå¤„ç†ã€‚è¿™æ˜¯ç¼“å†²åŒºæ“ä½œçš„ä¸€ä¸ªå¸¸ç”¨æŠ€å·§ã€‚ å½“æœ‰INotifyäº‹ä»¶å¯ä»¥ä»mINotifyFdä¸­è¯»å–æ—¶ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªepolläº‹ä»¶ï¼ŒEventHubä¾¿å¾—çŸ¥è®¾å¤‡èŠ‚ç‚¹å‘ç”Ÿäº†å¢åˆ æ“ä½œã€‚åœ¨getEvents()å°†äº‹ä»¶æ± ä¸­çš„æ‰€æœ‰äº‹ä»¶å¤„ç†å®Œæ¯•åï¼Œä¾¿ä¼šä»mINotifyFdä¸­è¯»å–INotifyäº‹ä»¶ï¼Œè¿›è¡Œè¾“å…¥è®¾å¤‡çš„åŠ è½½/å¸è½½æ“ä½œï¼Œç„¶åç”Ÿæˆå¯¹åº”çš„RawEventç»“æ„ä½“å¹¶è¿”å›ç»™è°ƒç”¨è€…ã€‚ é€šè¿‡ä¸Šè¿°åˆ†æå¯ä»¥çœ‹åˆ°ï¼ŒgetEvents()åŒ…å«äº†åŸå§‹è¾“å…¥äº‹ä»¶è¯»å–ã€è¾“å…¥è®¾å¤‡åŠ è½½/å¸è½½ç­‰æ“ä½œã€‚è¿™å‡ ä¹æ˜¯EventHubçš„å…¨éƒ¨å·¥ä½œäº†ã€‚å¦‚æœæ²¡æœ‰geEvents()çš„è°ƒç”¨ï¼ŒEventHubå°†å¯¹è¾“å…¥äº‹ä»¶ã€è®¾å¤‡èŠ‚ç‚¹å¢åˆ äº‹ä»¶ç½®è‹¥ç½”é—»ï¼Œå› æ­¤å¯ä»¥å°†ä¸€æ¬¡getEvents()è°ƒç”¨ç†è§£ä¸ºä¸€æ¬¡å¿ƒè·³ï¼ŒEventHubçš„æ ¸å¿ƒåŠŸèƒ½éƒ½ä¼šåœ¨è¿™æ¬¡å¿ƒè·³ä¸­å®Œæˆã€‚ getEvents()çš„ä»£ç è¿˜æ­ç¤ºäº†å¦å¤–ä¸€ä¸ªä¿¡æ¯ï¼šåœ¨ä¸€ä¸ªç›‘å¬å‘¨æœŸå†…çš„è®¾å¤‡å¢åˆ äº‹ä»¶ä¸Epolläº‹ä»¶çš„ä¼˜å…ˆçº§ã€‚è®¾å¤‡äº‹ä»¶çš„ç”Ÿæˆé€»è¾‘ä½äºEpolläº‹ä»¶çš„å¤„ç†ä¹‹å‰ï¼Œå› æ­¤getEvents()å°†ä¼˜å…ˆç”Ÿæˆè®¾å¤‡å¢åˆ äº‹ä»¶ï¼Œå®Œæˆæ‰€æœ‰è®¾å¤‡å¢åˆ äº‹ä»¶çš„ç”Ÿæˆä¹‹å‰ä¸ä¼šå¤„ç†Epolläº‹ä»¶ï¼Œä¹Ÿå°±æ˜¯ä¸ä¼šç”ŸæˆåŸå§‹è¾“å…¥äº‹ä»¶ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬å°†ä»è®¾å¤‡ç®¡ç†ä¸åŸå§‹è¾“å…¥äº‹ä»¶å¤„ç†ä¸¤ä¸ªæ–¹é¢æ·±å…¥æ¢è®¨EventHubã€‚ 3ã€è¾“å…¥è®¾å¤‡ç®¡ç†å› ä¸ºè¾“å…¥è®¾å¤‡æ˜¯è¾“å…¥äº‹ä»¶çš„æ¥æºï¼Œå¹¶ä¸”å†³å®šäº†è¾“å…¥äº‹ä»¶çš„å«ä¹‰ï¼Œå› æ­¤é¦–å…ˆè®¨è®ºEventHubçš„è¾“å…¥è®¾å¤‡ç®¡ç†æœºåˆ¶ã€‚ è¾“å…¥è®¾å¤‡æ˜¯ä¸€ä¸ªå¯ä»¥ä¸ºæ¥æ”¶ç”¨æˆ·æ“ä½œçš„ç¡¬ä»¶ï¼Œå†…æ ¸ä¼šä¸ºæ¯ä¸€ä¸ªè¾“å…¥è®¾å¤‡åœ¨/dev/input/ä¸‹åˆ›å»ºä¸€ä¸ªè®¾å¤‡èŠ‚ç‚¹ï¼Œè€Œå½“è¾“å…¥è®¾å¤‡ä¸å¯ç”¨æ—¶ï¼ˆä¾‹å¦‚è¢«æ‹”å‡ºï¼‰ï¼Œå°†å…¶è®¾å¤‡èŠ‚ç‚¹åˆ é™¤ã€‚è¿™ä¸ªè®¾å¤‡èŠ‚ç‚¹åŒ…å«äº†è¾“å…¥è®¾å¤‡çš„æ‰€æœ‰ä¿¡æ¯ï¼ŒåŒ…æ‹¬åç§°ã€å‚å•†ã€è®¾å¤‡ç±»å‹ï¼Œè®¾å¤‡çš„åŠŸèƒ½ç­‰ã€‚é™¤äº†è®¾å¤‡èŠ‚ç‚¹ï¼ŒæŸäº›è¾“å…¥è®¾å¤‡è¿˜åŒ…å«ä¸€äº›è‡ªå®šä¹‰é…ç½®ï¼Œè¿™äº›é…ç½®ä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨åœ¨æŸä¸ªæ–‡ä»¶ä¸­ã€‚è¿™äº›ä¿¡æ¯å†³å®šäº†Readerå­ç³»ç»Ÿå¦‚ä½•åŠ å·¥åŸå§‹è¾“å…¥äº‹ä»¶ã€‚EventHubè´Ÿè´£åœ¨è®¾å¤‡èŠ‚ç‚¹å¯ç”¨æ—¶åŠ è½½å¹¶ç»´æŠ¤è¿™äº›ä¿¡æ¯ï¼Œå¹¶åœ¨è®¾å¤‡èŠ‚ç‚¹è¢«åˆ é™¤æ—¶å°†å…¶ç§»é™¤ã€‚ EventHubé€šè¿‡ä¸€ä¸ªå®šä¹‰åœ¨å…¶å†…éƒ¨çš„åä¸ºDeviceçš„ç§æœ‰ç»“æ„ä½“æ¥æè¿°ä¸€ä¸ªè¾“å…¥è®¾å¤‡ã€‚å…¶å®šä¹‰å¦‚ä¸‹ï¼š [EventHub.hâ€“&gt;EventHub::Device] 123456789101112131415161718192021222324252627struct Device &#123;Device* next; /* Deviceç»“æ„ä½“å®é™…ä¸Šæ˜¯ä¸€ä¸ªå•é“¾è¡¨ */int fd; /* fdè¡¨ç¤ºæ­¤è®¾å¤‡çš„è®¾å¤‡èŠ‚ç‚¹çš„æè¿°ç¬¦ï¼Œå¯ä»¥ä»æ­¤æè¿°ç¬¦ä¸­è¯»å–åŸå§‹è¾“å…¥äº‹ä»¶ */const int32_t id; /* idåœ¨è¾“å…¥ç³»ç»Ÿä¸­å”¯ä¸€æ ‡è¯†è¿™ä¸ªè®¾å¤‡ï¼Œç”±EventHubåœ¨åŠ è½½è®¾å¤‡æ—¶è¿›è¡Œåˆ†é… */const String8 path; /* pathå­˜å‚¨äº†è®¾å¤‡èŠ‚ç‚¹åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è·¯å¾„ */const InputDeviceIdentifier identifier; /* å‚å•†ä¿¡æ¯ï¼Œå­˜å‚¨äº†è®¾å¤‡çš„ä¾›åº”å•†ã€å‹å·ç­‰ä¿¡æ¯ è¿™äº›ä¿¡æ¯ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è·å¾— */uint32_t classes; /* classesè¡¨ç¤ºäº†è®¾å¤‡çš„ç±»åˆ«ï¼Œé”®ç›˜è®¾å¤‡ï¼Œè§¦æ§è®¾å¤‡ç­‰ã€‚ä¸€ä¸ªè®¾å¤‡å¯ä»¥åŒæ—¶å±äº å¤šä¸ªè®¾å¤‡ç±»åˆ«ã€‚ç±»åˆ«å†³å®šäº†InputReaderå¦‚ä½•åŠ å·¥å…¶åŸå§‹è¾“å…¥äº‹ä»¶ *//* æ¥ä¸‹æ¥æ˜¯ä¸€ç³»åˆ—çš„äº‹ä»¶ä½æ©ç ï¼Œå®ƒä»¬è¯¦ç»†åœ°æè¿°äº†è®¾å¤‡èƒ½å¤Ÿäº§ç”Ÿçš„äº‹ä»¶ç±»å‹ã€‚è®¾å¤‡èƒ½å¤Ÿäº§ç”Ÿçš„äº‹ä»¶ç±»å‹ å†³å®šäº†æ­¤è®¾å¤‡æ‰€å±çš„ç±»å‹*/uint8_t keyBitmask[(KEY_MAX + 1) / 8];....../* é…ç½®ä¿¡æ¯ã€‚ä»¥é”®å€¼å¯¹çš„å½¢å¼å­˜å‚¨åœ¨ä¸€ä¸ªæ–‡ä»¶ä¸­ï¼Œå…¶è·¯å¾„å–å†³äºidentfierå­—æ®µä¸­çš„å‚å•†ä¿¡æ¯ï¼Œè¿™äº› é…ç½®ä¿¡æ¯å°†ä¼šå½±å“InputReaderå¯¹æ­¤è®¾å¤‡çš„äº‹ä»¶çš„åŠ å·¥è¡Œä¸º */String8 configurationFile;PropertyMap* configuration;/* é”®ç›˜æ˜ å°„è¡¨ã€‚å¯¹äºé”®ç›˜ç±»å‹çš„è®¾å¤‡ï¼Œè¿™äº›é”®ç›˜æ˜ å°„è¡¨å°†åŸå§‹äº‹ä»¶ä¸­çš„é”®ç›˜æ‰«æç è½¬æ¢ä¸ºAndroidå®šä¹‰çš„ çš„æŒ‰é”®å€¼ã€‚è¿™ä¸ªæ˜ å°„è¡¨ä¹Ÿæ˜¯ä»ä¸€ä¸ªæ–‡ä»¶ä¸­åŠ è½½çš„ï¼Œæ–‡ä»¶è·¯å¾„å–å†³äºdentifierå­—æ®µä¸­çš„å‚å•†ä¿¡æ¯ */ VirtualKeyMap* virtualKeyMap;KeyMap keyMap; sp&lt;KeyCharacterMap&gt; overlayKeyMap; sp&lt;KeyCharacterMap&gt; combinedKeyMap;// åŠ›åé¦ˆç›¸å…³çš„ä¿¡æ¯ã€‚æœ‰äº›è®¾å¤‡å¦‚é«˜çº§çš„æ¸¸æˆæ‰‹æŸ„æ”¯æŒåŠ›åé¦ˆåŠŸèƒ½ï¼Œç›®å‰æš‚ä¸è€ƒè™‘bool ffEffectPlaying;int16_t ffEffectId;&#125;; Deviceç»“æ„ä½“æ‰€å­˜å‚¨çš„ä¿¡æ¯ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ï¼š Â· è®¾å¤‡èŠ‚ç‚¹ä¿¡æ¯ï¼šä¿å­˜äº†è¾“å…¥è®¾å¤‡èŠ‚ç‚¹çš„æ–‡ä»¶æè¿°ç¬¦ã€æ–‡ä»¶è·¯å¾„ç­‰ã€‚ Â· å‚å•†ä¿¡æ¯ï¼šåŒ…æ‹¬ä¾›åº”å•†ã€è®¾å¤‡å‹å·ã€åç§°ç­‰ä¿¡æ¯ï¼Œè¿™äº›ä¿¡æ¯å†³å®šäº†åŠ è½½é…ç½®æ–‡ä»¶ä¸é”®ç›˜æ˜ å°„è¡¨çš„è·¯å¾„ã€‚ Â· è®¾å¤‡ç‰¹æ€§ä¿¡æ¯ï¼šåŒ…æ‹¬è®¾å¤‡çš„ç±»åˆ«ï¼Œå¯ä»¥ä¸ŠæŠ¥çš„äº‹ä»¶ç§ç±»ç­‰ã€‚è¿™äº›ç‰¹æ€§ä¿¡æ¯ç›´æ¥å½±å“äº†InputReaderå¯¹å…¶æ‰€äº§ç”Ÿçš„äº‹ä»¶çš„åŠ å·¥å¤„ç†æ–¹å¼ã€‚ Â· è®¾å¤‡çš„é…ç½®ä¿¡æ¯ï¼šåŒ…æ‹¬é”®ç›˜æ˜ å°„è¡¨åŠå…¶ä»–è‡ªå®šä¹‰çš„ä¿¡æ¯ï¼Œä»ç‰¹å®šä½ç½®çš„é…ç½®æ–‡ä»¶ä¸­è¯»å–ã€‚ å¦å¤–ï¼ŒDeviceç»“æ„ä½“è¿˜å­˜å‚¨äº†åŠ›åé¦ˆæ‰€éœ€çš„ä¸€äº›æ•°æ®ã€‚åœ¨æœ¬èŠ‚ä¸­æš‚ä¸è®¨è®ºã€‚ EventHubç”¨ä¸€ä¸ªåä¸ºmDevicesçš„å­—å…¸ä¿å­˜å½“å‰å¤„äºæ‰“å¼€çŠ¶æ€çš„è®¾å¤‡èŠ‚ç‚¹çš„Deviceç»“æ„ä½“ã€‚å­—å…¸çš„é”®ä¸ºè®¾å¤‡Idã€‚ ï¼ˆ1ï¼‰ã€è¾“å…¥è®¾å¤‡çš„åŠ è½½EventHubåœ¨åˆ›å»ºååœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨getEvents()å‡½æ•°æ—¶å®Œæˆå¯¹ç³»ç»Ÿä¸­ç°æœ‰è¾“å…¥è®¾å¤‡çš„åŠ è½½ã€‚ å†çœ‹ä¸€ä¸‹getEvents()å‡½æ•°ä¸­ç›¸å…³å†…å®¹çš„å®ç°ï¼š [EventHub.cppâ€“&gt;EventHub::getEvents()] 1234567891011121314151617size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; // å¤„ç†è¾“å…¥è®¾å¤‡å¸è½½æ“ä½œ ...... /* åœ¨EventHubçš„æ„é€ å‡½æ•°ä¸­ï¼ŒmNeedToScanDevicesè¢«è®¾ç½®ä¸ºtrueï¼Œå› æ­¤åˆ›å»ºåç¬¬ä¸€æ¬¡è°ƒç”¨ getEvents()å‡½æ•°ä¼šæ‰§è¡ŒscanDevicesLocked()ï¼ŒåŠ è½½æ‰€æœ‰è¾“å…¥è®¾å¤‡ */ if(mNeedToScanDevices) &#123; mNeedToScanDevices = false; /*scanDevicesLocked()å°†ä¼šæŠŠ/dev/inputä¸‹æ‰€æœ‰å¯ç”¨çš„è¾“å…¥è®¾å¤‡æ‰“å¼€å¹¶å­˜å‚¨åˆ°Device ç»“æ„ä½“ä¸­ */ scanDevicesLocked(); mNeedToSendFinishedDeviceScan = true; &#125; ......&#125;returnevent â€“ buffer;&#125; åŠ è½½æ‰€æœ‰è¾“å…¥è®¾å¤‡ç”±scanDevicesLocked()å‡½æ•°å®Œæˆã€‚çœ‹ä¸€ä¸‹å…¶å®ç°ï¼š [EventHub.cppâ€“&gt;EventHub::scanDevicesLocked()] 12345678910void EventHub::scanDevicesLocked() &#123;// è°ƒç”¨scanDirLocked()å‡½æ•°éå†/dev/inputæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹å¹¶æ‰“å¼€status_tres = scanDirLocked(DEVICE_PATH);......// é”™è¯¯å¤„ç†// æ‰“å¼€ä¸€ä¸ªåä¸ºVIRTUAL_KEYBOARDçš„è¾“å…¥è®¾å¤‡ã€‚è¿™ä¸ªè®¾å¤‡æ—¶åˆ»æ˜¯æ‰“å¼€ç€çš„ã€‚å®ƒæ˜¯ä¸€ä¸ªè™šæ‹Ÿçš„è¾“å…¥è®¾ å¤‡ï¼Œæ²¡æœ‰å¯¹åº”çš„è¾“å…¥èŠ‚ç‚¹ã€‚è¯»è€…å…ˆè®°ä½æœ‰è¿™ä¹ˆä¸€ä¸ªè¾“å…¥è®¾å¤‡å­˜åœ¨äºè¾“å…¥ç³»ç»Ÿä¸­ */if(mDevices.indexOfKey(VIRTUAL_KEYBOARD_ID) &lt; 0) &#123; createVirtualKeyboardLocked();&#125;&#125; scanDirLocked()éå†æŒ‡å®šæ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰è®¾å¤‡èŠ‚ç‚¹ï¼Œåˆ†åˆ«å¯¹å…¶æ‰§è¡ŒopenDeviceLocked()å®Œæˆè®¾å¤‡çš„æ‰“å¼€æ“ä½œã€‚åœ¨è¿™ä¸ªå‡½æ•°ä¸­å°†ä¸ºè®¾å¤‡èŠ‚ç‚¹åˆ›å»ºå¹¶åŠ è½½Deviceç»“æ„ä½“ã€‚å‚è€ƒå…¶ä»£ç ï¼š [EventHub.cppâ€“&gt;EventHub::openDeviceLocked()] 12345678910111213141516171819202122232425262728293031status_t EventHub::openDeviceLocked(const char*devicePath) &#123;// æ‰“å¼€è®¾å¤‡èŠ‚ç‚¹çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºè·å–è®¾å¤‡ä¿¡æ¯ä»¥åŠè¯»å–åŸå§‹è¾“å…¥äº‹ä»¶int fd =open(devicePath, O_RDWR | O_CLOEXEC);// æ¥ä¸‹æ¥çš„ä»£ç é€šè¿‡ioctl()å‡½æ•°ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è·å–è¾“å…¥è®¾å¤‡çš„å‚å•†ä¿¡æ¯InputDeviceIdentifier identifier;......// åˆ†é…ä¸€ä¸ªè®¾å¤‡Idå¹¶åˆ›å»ºDeviceç»“æ„ä½“int32_tdeviceId = mNextDeviceId++;Device*device = new Device(fd, deviceId, String8(devicePath), identifier);// ä¸ºæ­¤è®¾å¤‡åŠ è½½é…ç½®ä¿¡æ¯ã€‚ loadConfigurationLocked(device); // â‘  é€šè¿‡ioctlå‡½æ•°è·å–è®¾å¤‡çš„äº‹ä»¶ä½æ©ç ã€‚äº‹ä»¶ä½æ©ç æŒ‡å®šäº†è¾“å…¥è®¾å¤‡å¯ä»¥äº§ç”Ÿä½•ç§ç±»å‹çš„è¾“å…¥äº‹ä»¶ ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(device-&gt;keyBitmask)),device-&gt;keyBitmask);...... ioctl(fd, EVIOCGPROP(sizeof(device-&gt;propBitmask)),device-&gt;propBitmask); // æ¥ä¸‹æ¥çš„ä¸€å¤§æ®µå†…å®¹æ˜¯æ ¹æ®äº‹ä»¶ä½æ©ç ä¸ºè®¾å¤‡åˆ†é…ç±»åˆ«ï¼Œå³è®¾ç½®classeså­—æ®µã€‚ã€...... /* â‘¡ å°†è®¾å¤‡èŠ‚ç‚¹çš„æè¿°ç¬¦çš„å¯è¯»äº‹ä»¶æ³¨å†Œåˆ°Epollä¸­ã€‚å½“æ­¤è®¾å¤‡çš„è¾“å…¥äº‹ä»¶åˆ°æ¥æ—¶ï¼ŒEpollä¼šåœ¨ getEvents()å‡½æ•°çš„è°ƒç”¨ä¸­äº§ç”Ÿä¸€æ¡epolläº‹ä»¶ */ structepoll_event eventItem; memset(&amp;eventItem, 0, sizeof(eventItem)); eventItem.events = EPOLLIN; eventItem.data.u32 = deviceId; /* æ³¨æ„ï¼Œepoll_eventçš„è‡ªå®šä¹‰ä¿¡æ¯æ˜¯è®¾å¤‡çš„Id if(epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;eventItem)) &#123; ...... &#125; ...... // â‘¢ è°ƒç”¨addDeviceLocked()å°†Deviceæ·»åŠ åˆ°mDeviceså­—å…¸ä¸­ addDeviceLocked(device); return0; &#125; openDeviceLocked()å‡½æ•°æ‰“å¼€æŒ‡å®šè·¯å¾„çš„è®¾å¤‡èŠ‚ç‚¹ï¼Œä¸ºå…¶åˆ›å»ºå¹¶å¡«å……Deviceç»“æ„ä½“ï¼Œç„¶åå°†è®¾å¤‡èŠ‚ç‚¹çš„å¯è¯»äº‹ä»¶æ³¨å†Œåˆ°Epollä¸­ï¼Œæœ€åå°†æ–°å»ºçš„Deviceç»“æ„ä½“æ·»åŠ åˆ°mDeviceså­—å…¸ä¸­ä»¥ä¾›æ£€ç´¢ä¹‹éœ€ã€‚æ•´ä¸ªè¿‡ç¨‹æ¯”è¾ƒæ¸…æ™°ï¼Œä½†ä»æœ‰ä»¥ä¸‹å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š Â· openDeviceLocked()å‡½æ•°ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è·å–äº†è®¾å¤‡å¯èƒ½ä¸ŠæŠ¥çš„äº‹ä»¶ç±»å‹ï¼Œå¹¶æ®æ­¤ä¸ºè®¾å¤‡åˆ†é…äº†ç±»åˆ«ã€‚æ•´ä¸ªåˆ†é…è¿‡ç¨‹éå¸¸ç¹çï¼Œç”±äºå®ƒå’ŒInputReaderçš„äº‹ä»¶åŠ å·¥è¿‡ç¨‹å…³ç³»ç´§å¯†ï¼Œå› æ­¤è¿™éƒ¨åˆ†å†…å®¹å°†åœ¨5.2.4èŠ‚å†åšè¯¦ç»†è®¨è®ºã€‚ Â· å‘Epollæ³¨å†Œè®¾å¤‡èŠ‚ç‚¹çš„å¯è¯»äº‹ä»¶æ—¶ï¼Œepoll_eventçš„è‡ªå®šä¹‰æ•°æ®è¢«è®¾ç½®ä¸ºè®¾å¤‡çš„Idè€Œä¸æ˜¯fdã€‚ Â· addDeviceLocked()å°†æ–°å»ºçš„Deviceå¯¹è±¡æ·»åŠ åˆ°mDeviceså­—å…¸ä¸­çš„åŒæ—¶ä¹Ÿä¼šå°†å…¶æ·»åŠ åˆ°ä¸€ä¸ªåä¸ºmOpeningDevicesçš„é“¾è¡¨ä¸­ã€‚è¿™ä¸ªé“¾è¡¨ä¿å­˜äº†åˆšåˆšè¢«åŠ è½½ï¼Œä½†å°šæœªé€šè¿‡getEvents()å‡½æ•°å‘InputReaderå‘é€DEVICE_ADDäº‹ä»¶çš„è®¾å¤‡ã€‚ å®Œæˆè¾“å…¥è®¾å¤‡çš„åŠ è½½ä¹‹åï¼Œé€šè¿‡getEvents()å‡½æ•°ä¾¿å¯ä»¥è¯»å–åˆ°æ­¤è®¾å¤‡æ‰€äº§ç”Ÿçš„è¾“å…¥äº‹ä»¶äº†ã€‚é™¤äº†åœ¨getEvents()å‡½æ•°ä¸­ä½¿ç”¨scanDevicesLockd()ä¸€æ¬¡æ€§åŠ è½½æ‰€æœ‰è¾“å…¥è®¾å¤‡ï¼Œå½“INotifyäº‹ä»¶å‘ŠçŸ¥æœ‰æ–°çš„è¾“å…¥è®¾å¤‡èŠ‚ç‚¹è¢«åˆ›å»ºæ—¶ï¼Œä¹Ÿä¼šé€šè¿‡opendDeviceLocked()å°†è®¾å¤‡åŠ è½½ï¼Œç¨åå†åšè®¨è®ºã€‚ ï¼ˆ2ï¼‰ã€è¾“å…¥è®¾å¤‡çš„å¸è½½è¾“å…¥è®¾å¤‡çš„å¸è½½ç”±closeDeviceLocked()å‡½æ•°å®Œæˆã€‚ç”±äºæ­¤å‡½æ•°çš„å·¥ä½œå†…å®¹ä¸openDeviceLocked()å‡½æ•°æ­£å¥½ç›¸åï¼Œå°±ä¸åˆ—å‡ºå…¶ä»£ç äº†ã€‚è®¾å¤‡çš„å¸è½½è¿‡ç¨‹ä¸ºï¼š Â· ä»Epollä¸­æ³¨é”€å¯¹æè¿°ç¬¦çš„ç›‘å¬ã€‚ Â· å…³é—­è®¾å¤‡èŠ‚ç‚¹çš„æè¿°ç¬¦ã€‚ Â· ä»mDeviceså­—å…¸ä¸­åˆ é™¤å¯¹åº”çš„Deviceå¯¹è±¡ã€‚ Â· å°†Deviceå¯¹è±¡æ·»åŠ åˆ°mClosingDevicesé“¾è¡¨ä¸­ï¼Œä¸mOpeningDevicesç±»ä¼¼ï¼Œè¿™ä¸ªé“¾è¡¨ä¿å­˜äº†åˆšåˆšè¢«å¸è½½ï¼Œä½†å°šæœªé€šè¿‡getEvents()å‡½æ•°å‘InputReaderå‘é€DEVICE_REMOVEDäº‹ä»¶çš„è®¾å¤‡ã€‚ åŒåŠ è½½è®¾å¤‡ä¸€æ ·ï¼Œåœ¨getEvents()å‡½æ•°ä¸­æœ‰æ ¹æ®éœ€è¦å¸è½½æ‰€æœ‰è¾“å…¥è®¾å¤‡çš„æ“ä½œï¼ˆæ¯”å¦‚å½“EventHubè¦æ±‚é‡æ–°åŠ è½½æ‰€æœ‰è®¾å¤‡æ—¶ï¼Œä¼šå…ˆå°†æ‰€æœ‰è®¾å¤‡å¸è½½ï¼‰ã€‚å¹¶ä¸”å½“INotifyäº‹ä»¶å‘ŠçŸ¥æœ‰è®¾å¤‡èŠ‚ç‚¹åˆ é™¤æ—¶ä¹Ÿä¼šè°ƒç”¨closeDeviceLocked()å°†è®¾å¤‡å¸è½½ã€‚ ï¼ˆ3ï¼‰ã€è®¾å¤‡å¢åˆ äº‹ä»¶åœ¨åˆ†æè®¾å¤‡çš„åŠ è½½ä¸å¸è½½æ—¶å‘ç°ï¼Œæ–°åŠ è½½çš„è®¾å¤‡ä¸æ–°å¸è½½çš„è®¾å¤‡ä¼šè¢«åˆ†åˆ«æ”¾å…¥mOpeningDevicesä¸mClosingDevicesé“¾è¡¨ä¹‹ä¸­ã€‚è¿™ä¸¤ä¸ªé“¾è¡¨å°†æ˜¯åœ¨getEvents()å‡½æ•°ä¸­å‘InputReaderå‘é€è®¾å¤‡å¢åˆ äº‹ä»¶çš„ä¾æ®ã€‚ å‚è€ƒgetEvents()å‡½æ•°çš„ç›¸å…³ä»£ç ï¼Œä»¥è®¾å¤‡å¸è½½äº‹ä»¶ä¸ºä¾‹çœ‹ä¸€ä¸‹è®¾å¤‡å¢åˆ äº‹ä»¶æ˜¯å¦‚ä½•äº§ç”Ÿçš„ï¼š [EventHub.cppâ€“&gt;EventHub::getEvents()] 1234567891011121314151617181920212223242526size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; // éå†mClosingDevicesé“¾è¡¨ï¼Œä¸ºæ¯ä¸€ä¸ªå·²å¸è½½çš„è®¾å¤‡ç”ŸæˆDEVICE_REMOVEDäº‹ä»¶ while (mClosingDevices) &#123; Device* device = mClosingDevices; mClosingDevices = device-&gt;next; /* åˆ†ægetEvents()å‡½æ•°çš„å·¥ä½œæ–¹å¼æ—¶ä»‹ç»è¿‡ï¼ŒeventæŒ‡é’ˆæŒ‡å‘bufferä¸­ä¸‹ä¸€ä¸ªå¯ç”¨äºå¡«å…… äº‹ä»¶çš„RawEventå¯¹è±¡ */ event-&gt;when = now; // è®¾ç½®äº§ç”Ÿäº‹ä»¶çš„äº‹ä»¶æˆ³ event-&gt;deviceId = device-&gt;id ==mBuiltInKeyboardId ? BUILT_IN_KEYBOARD_ID : device-&gt;id; event-&gt;type = DEVICE_REMOVED; // è®¾ç½®äº‹ä»¶çš„ç±»å‹ä¸ºDEVICE_REMOVED event += 1; // å°†eventæŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªå¯ç”¨äºå¡«å……äº‹ä»¶çš„RawEventå¯¹è±¡ delete device; // ç”ŸæˆDEVICE_REMOVEDäº‹ä»¶ä¹‹åï¼Œè¢«å¸è½½çš„Deviceå¯¹è±¡å°±ä¸å†éœ€è¦äº† mNeedToSendFinishedDeviceScan = true; // éšåå‘é€FINISHED_DEVICE_SCANäº‹ä»¶ /* å½“bufferå·²æ»¡åˆ™åœæ­¢ç»§ç»­ç”Ÿæˆäº‹ä»¶ï¼Œå°†å·²ç”Ÿæˆçš„äº‹ä»¶è¿”å›ç»™è°ƒç”¨è€…ã€‚å°šæœªç”Ÿæˆçš„äº‹ä»¶ å°†åœ¨ä¸‹æ¬¡getEvents()è°ƒç”¨æ—¶ç”Ÿæˆå¹¶è¿”å›ç»™è°ƒç”¨è€… */ if (--capacity == 0) &#123; break; &#125; &#125; // æ¥ä¸‹æ¥è¿›è¡ŒDEVICE_ADDEDäº‹ä»¶çš„ç”Ÿæˆï¼Œæ­¤è¿‡ç¨‹ä¸ DEVICE_REMOVEDäº‹ä»¶çš„ç”Ÿæˆä¸€è‡´ ......&#125;returnevent â€“ buffer;&#125; å¯ä»¥çœ‹åˆ°ï¼Œåœ¨ä¸€æ¬¡getEvents()è°ƒç”¨ä¸­ä¼šå°è¯•ä¸ºæ‰€æœ‰å°šæœªå‘é€å¢åˆ äº‹ä»¶çš„è¾“å…¥è®¾å¤‡ç”Ÿæˆå¯¹åº”çš„äº‹ä»¶è¿”å›ç»™è°ƒç”¨è€…ã€‚è¡¨ç¤ºè®¾å¤‡å¢åˆ äº‹ä»¶çš„RawEventå¯¹è±¡åŒ…å«ä¸‰ä¸ªä¿¡æ¯ï¼šäº§ç”Ÿäº‹ä»¶çš„äº‹ä»¶æˆ³ã€äº§ç”Ÿäº‹ä»¶çš„è®¾å¤‡Idï¼Œä»¥åŠäº‹ä»¶ç±»å‹ï¼ˆDEVICE_ADDEDæˆ–DEVICE_REMOVEDï¼‰ã€‚ å½“ç”Ÿæˆè®¾å¤‡å¢åˆ äº‹ä»¶æ—¶ï¼Œä¼šè®¾ç½®mNeedToSendFinishedDeviceSanä¸ºtrueï¼Œè¿™ä¸ªåŠ¨ä½œçš„æ„æ€æ˜¯å®Œæˆæ‰€æœ‰DEVICE_ADDED/REMOVEDäº‹ä»¶çš„ç”Ÿæˆä¹‹åï¼Œéœ€è¦å‘getEvents()çš„è°ƒç”¨è€…å‘é€ä¸€ä¸ªFINISHED_DEVICE_SCANäº‹ä»¶ï¼Œè¡¨ç¤ºè®¾å¤‡å¢åˆ äº‹ä»¶çš„ä¸ŠæŠ¥ç»“æŸã€‚è¿™ä¸ªäº‹ä»¶ä»…åŒ…æ‹¬æ—¶é—´æˆ³ä¸äº‹ä»¶ç±»å‹ä¸¤ä¸ªä¿¡æ¯ã€‚ ç»è¿‡ä»¥ä¸Šåˆ†æå¯çŸ¥ï¼ŒEventHubå¯ä»¥äº§ç”Ÿçš„è®¾å¤‡å¢åˆ äº‹ä»¶ä¸€å…±æœ‰ä¸‰ç§ï¼Œè€Œä¸”è¿™ä¸‰ç§äº‹ä»¶æ‹¥æœ‰å›ºå®šçš„ä¼˜å…ˆçº§ï¼ŒDEVICE_REMOVEDäº‹ä»¶çš„ä¼˜å…ˆçº§æœ€é«˜ï¼ŒDEVICE_ADDEDäº‹ä»¶æ¬¡ä¹‹ï¼ŒFINISHED_DEVICE_SCANäº‹ä»¶æœ€ä½ã€‚è€Œä¸”ï¼ŒgetEvents()å®Œæˆå½“å‰é«˜ä¼˜å…ˆçº§äº‹ä»¶çš„ç”Ÿæˆä¹‹å‰ï¼Œä¸ä¼šè¿›è¡Œä½ä¼˜å…ˆçº§äº‹ä»¶çš„ç”Ÿæˆã€‚å› æ­¤ï¼Œå½“å‘ç”Ÿè®¾å¤‡çš„åŠ è½½ä¸å¸è½½æ—¶ï¼ŒEventHubæ‰€ç”Ÿæˆçš„å®Œæ•´çš„è®¾å¤‡å¢åˆ äº‹ä»¶åºåˆ—å¦‚å›¾5-5æ‰€ç¤ºï¼Œå…¶ä¸­Rè¡¨ç¤ºDEVICE_REMOVEDï¼ŒAè¡¨ç¤ºDEVICE_ADDEDï¼ŒFè¡¨ç¤ºFINISHED_DEVICE_SCANã€‚ å›¾ï¼šè®¾å¤‡å¢åˆ äº‹ä»¶çš„å®Œæ•´åºåˆ— ç”±äºå‚æ•°bufferçš„å®¹é‡é™åˆ¶ï¼Œè¿™ä¸ªäº‹ä»¶åºåˆ—å¯èƒ½éœ€è¦é€šè¿‡å¤šæ¬¡getEvents()è°ƒç”¨æ‰èƒ½å®Œæ•´åœ°è¿”å›ç»™è°ƒç”¨è€…ã€‚å¦å¤–ï¼Œæ ¹æ®5.2.2èŠ‚çš„è®¨è®ºï¼Œè®¾å¤‡å¢åˆ äº‹ä»¶ç›¸å¯¹äºEpolläº‹ä»¶æ‹¥æœ‰è¾ƒé«˜çš„ä¼˜å…ˆçº§ï¼Œå› æ­¤ä»R1äº‹ä»¶å¼€å§‹ç”Ÿæˆåˆ°Fäº‹ä»¶ç”Ÿæˆä¹‹å‰ï¼ŒgetEvents()ä¸ä¼šå¤„ç†Epolläº‹ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸ä¼šç”ŸæˆåŸå§‹è¾“å…¥äº‹ä»¶ã€‚ æ€»ç»“ä¸€ä¸‹è®¾å¤‡å¢åˆ äº‹ä»¶çš„ç”ŸæˆåŸç†ï¼š Â· å½“å‘ç”Ÿè®¾å¤‡å¢åˆ æ—¶ï¼ŒaddDeviceLocked()å‡½æ•°ä¸closeDeviceLocked()å‡½æ•°ä¼šå°†ç›¸åº”çš„è®¾å¤‡æ”¾å…¥mOpeningDeviceså’ŒmClosingDevicesé“¾è¡¨ä¸­ã€‚ Â· getEvents()å‡½æ•°ä¼šæ ¹æ®mOpeningDeviceså’ŒmClosingDevicesä¸¤ä¸ªé“¾è¡¨ç”Ÿæˆå¯¹åº”DEVICE_ADDEDå’ŒDEVICE_REMOVEDäº‹ä»¶ï¼Œå…¶ä¸­åè€…çš„ç”Ÿæˆæ‹¥æœ‰é«˜ä¼˜å…ˆçº§ã€‚ Â· DEVICE_ADDEDå’ŒDEVICE_REMOVEDäº‹ä»¶éƒ½ç”Ÿæˆå®Œæ¯•åï¼ŒgetEvents()ä¼šç”ŸæˆFINISHED_DEVICE_SCANäº‹ä»¶ï¼Œæ ‡å¿—è®¾å¤‡å¢åˆ äº‹ä»¶åºåˆ—çš„ç»“æŸã€‚ ï¼ˆ4ï¼‰ã€é€šè¿‡INotifyåŠ¨æ€åœ°åŠ è½½ä¸å¸è½½è®¾å¤‡é€šè¿‡å‰æ–‡çš„ä»‹ç»çŸ¥é“äº†openDeviceLocked()å’ŒcloseDeviceLocked()å¯ä»¥åŠ è½½ä¸å¸è½½è¾“å…¥è®¾å¤‡ã€‚æ¥ä¸‹æ¥åˆ†æEventHubå¦‚ä½•é€šè¿‡INotifyè¿›è¡Œè®¾å¤‡çš„åŠ¨æ€åŠ è½½ä¸å¸è½½ã€‚åœ¨EventHubçš„æ„é€ å‡½æ•°ä¸­åˆ›å»ºäº†ä¸€ä¸ªåä¸ºmINotifyFdçš„INotifyå¯¹è±¡çš„æè¿°ç¬¦ï¼Œç”¨ä»¥ç›‘æ§/dev/inputä¸‹è®¾å¤‡èŠ‚ç‚¹çš„å¢åˆ ã€‚ä¹‹åå°†mINotifyFdçš„å¯è¯»äº‹ä»¶åŠ å…¥åˆ°Epollä¸­ã€‚äºæ˜¯å¯ä»¥ç¡®å®šåŠ¨æ€åŠ è½½ä¸å¸è½½è®¾å¤‡çš„å·¥ä½œæ–¹å¼ä¸ºï¼šé¦–å…ˆç­›é€‰epoll_wait()å‡½æ•°æ‰€å–å¾—çš„Epolläº‹ä»¶ï¼Œå¦‚æœEpolläº‹ä»¶è¡¨ç¤ºäº†mINotifyFdå¯è¯»ï¼Œä¾¿ä»mINotifyFdä¸­è¯»å–è®¾å¤‡èŠ‚ç‚¹çš„å¢åˆ äº‹ä»¶ï¼Œç„¶åé€šè¿‡æ‰§è¡ŒopenDeviceLocked()æˆ–closeDeviceLocked()è¿›è¡Œè®¾å¤‡çš„åŠ è½½ä¸å¸è½½ã€‚ çœ‹ä¸€ä¸‹getEvents()ä¸­ä¸INotifyç›¸å…³çš„ä»£ç ï¼š [EventHub.cppâ€“&gt;EventHub::getEvents()] 12345678910111213141516171819202122232425262728293031size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; ...... // è®¾å¤‡å¢åˆ äº‹ä»¶å¤„ç† while(mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; /* â‘  é€šè¿‡Epolläº‹ä»¶çš„dataå­—æ®µç¡®å®šæ­¤äº‹ä»¶è¡¨ç¤ºäº†mINotifyFdå¯è¯» æ³¨æ„EPOLL_ID_INOTIFYåœ¨EventHubçš„æ„é€ å‡½æ•°ä¸­ä½œä¸ºdataå­—æ®µå‘ Epollæ³¨å†ŒmINotifyFdçš„å¯è¯»äº‹ä»¶ */ if (eventItem.data.u32 == EPOLL_ID_INOTIFY) &#123; if (eventItem.events &amp; EPOLLIN) &#123; mPendingINotify = true; // æ ‡è®°INotifyäº‹ä»¶å¾…å¤„ç† &#125; else &#123; ...... &#125; continue; // ç»§ç»­å¤„ç†ä¸‹ä¸€æ¡Epolläº‹ä»¶ &#125; ...... // å…¶ä»–Epolläº‹ä»¶çš„å¤„ç† &#125; // å¦‚æœINotifyäº‹ä»¶å¾…å¤„ç† if(mPendingINotify &amp;&amp; mPendingEventIndex &gt;= mPendingEventCount) &#123; mPendingINotify = false; /* â‘¡ è°ƒç”¨readNotifyLocked()å‡½æ•°è¯»å–å¹¶å¤„ç†å­˜å‚¨åœ¨mINotifyFdä¸­çš„INotifyäº‹ä»¶ è¿™ä¸ªå‡½æ•°å°†å®Œæˆè®¾å¤‡çš„åŠ è½½ä¸å¸è½½ */ readNotifyLocked(); deviceChanged = true; &#125; //â‘¢ å¦‚æœå¤„ç†äº†INotifyäº‹ä»¶ï¼Œåˆ™è¿”å›åˆ°å¾ªç¯å¼€å§‹å¤„ï¼Œç”Ÿæˆè®¾å¤‡å¢åˆ äº‹ä»¶ if(deviceChanged) &#123; continue; &#125;&#125;&#125; getEvents()å‡½æ•°ä¸­ä¸INotifyç›¸å…³çš„ä»£ç å…±æœ‰ä¸‰å¤„ï¼š Â· è¯†åˆ«è¡¨ç¤ºmINotifyFdå¯è¯»çš„Epolläº‹ä»¶ï¼Œå¹¶é€šè¿‡è®¾ç½®mPendingINotifyä¸ºtrueä»¥æ ‡è®°æœ‰INotifyäº‹ä»¶å¾…å¤„ç†ã€‚getEvents()å¹¶æ²¡æœ‰ç«‹åˆ»å¤„ç†INotifyäº‹ä»¶ï¼Œå› ä¸ºæ­¤æ—¶è¿›è¡Œè®¾å¤‡çš„åŠ è½½ä¸å¸è½½æ˜¯ä¸å®‰å…¨çš„ã€‚å…¶ä»–Epolläº‹ä»¶å¯èƒ½åŒ…å«äº†æ¥è‡ªå³å°†è¢«å¸è½½çš„è®¾å¤‡çš„è¾“å…¥äº‹ä»¶ï¼Œå› æ­¤éœ€è¦å°†æ‰€æœ‰Epolläº‹ä»¶éƒ½å¤„ç†å®Œæ¯•åå†è¿›è¡ŒåŠ è½½ä¸å¸è½½æ“ä½œã€‚ Â· å½“epoll_wait()æ‰€è¿”å›çš„Epolläº‹ä»¶éƒ½å¤„ç†å®Œæ¯•åï¼Œè°ƒç”¨readNotifyLocked()å‡½æ•°è¯»å–mINotifyFdä¸­çš„äº‹ä»¶ï¼Œå¹¶è¿›è¡Œè®¾å¤‡çš„åŠ è½½ä¸å¸è½½æ“ä½œã€‚ Â· å®Œæˆè®¾å¤‡çš„åŠ¨æ€åŠ è½½ä¸å¸è½½åï¼Œéœ€è¦è¿”å›åˆ°å¾ªç¯æœ€å¼€å§‹å¤„ï¼Œä»¥ä¾¿è®¾å¤‡å¢åˆ äº‹ä»¶å¤„ç†ä»£ç ç”Ÿæˆè®¾å¤‡çš„å¢åˆ äº‹ä»¶ã€‚ å…¶ä¸­ç¬¬ä¸€éƒ¨åˆ†ä¸ç¬¬ä¸‰éƒ¨åˆ†æ¯”è¾ƒå®¹æ˜“ç†è§£ã€‚æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹readNotifyLocked()æ˜¯å¦‚ä½•å·¥ä½œçš„ã€‚ [EventHub.cppâ€“&gt;EventHub::readNotifyLocked()] 123456789101112131415161718status_t EventHub::readNotifyLocked() &#123; ...... // ä»mINotifyFdä¸­è¯»å–INotifyäº‹ä»¶åˆ—è¡¨ res =read(mINotifyFd, event_buf, sizeof(event_buf)); ...... // é€ä¸ªå¤„ç†åˆ—è¡¨ä¸­çš„äº‹ä»¶ while(res &gt;= (int)sizeof(*event)) &#123; strcpy(filename, event-&gt;name); // ä»äº‹ä»¶ä¸­è·å–è®¾å¤‡èŠ‚ç‚¹è·¯å¾„ if(event-&gt;mask &amp; IN_CREATE) &#123; openDeviceLocked(devname); // å¦‚æœäº‹ä»¶ç±»å‹ä¸ºIN_CREATEï¼Œåˆ™åŠ è½½å¯¹åº”è®¾å¤‡ &#125;else &#123; closeDeviceByPathLocked(devname); // å¦åˆ™å¸è½½å¯¹åº”è®¾å¤‡ &#125; ......// ç§»åŠ¨åˆ°åˆ—è¡¨ä¸­çš„ä¸‹ä¸€ä¸ªäº‹ä»¶ &#125; return0; &#125; ï¼ˆ5ï¼‰ã€EventHubè®¾å¤‡ç®¡ç†æ€»ç»“è‡³æ­¤ï¼ŒEventHubçš„è®¾å¤‡ç®¡ç†ç›¸å…³çš„çŸ¥è¯†ä¾¿è®¨è®ºå®Œæ¯•äº†ã€‚åœ¨è¿™é‡Œè¿›è¡Œä¸€ä¸‹æ€»ç»“ï¼š Â· EventHubé€šè¿‡Deviceç»“æ„ä½“æè¿°è¾“å…¥è®¾å¤‡çš„å„ç§ä¿¡æ¯ã€‚ Â· EventHubåœ¨getEvents()å‡½æ•°ä¸­è¿›è¡Œè®¾å¤‡çš„åŠ è½½ä¸å¸è½½æ“ä½œã€‚è®¾å¤‡çš„åŠ è½½ä¸å¸è½½åˆ†ä¸ºæŒ‰éœ€åŠ è½½æˆ–å¸è½½ä»¥åŠé€šè¿‡INotifyåŠ¨æ€åŠ è½½æˆ–å¸è½½ç‰¹å®šè®¾å¤‡ä¸¤ç§æ–¹å¼ã€‚ Â· getEvents()å‡½æ•°è¿›è¡Œäº†è®¾å¤‡çš„åŠ è½½ä¸å¸è½½æ“ä½œåï¼Œä¼šç”ŸæˆDEVICE_ADDEDã€DEVICE_REMOVEDä»¥åŠFINISHED_DEVICE_SCANä¸‰ç§è®¾å¤‡å¢åˆ äº‹ä»¶ï¼Œå¹¶ä¸”è®¾å¤‡å¢åˆ äº‹ä»¶æ‹¥æœ‰é«˜äºEpolläº‹ä»¶çš„ä¼˜å…ˆçº§ã€‚ 4ï¼åŸå§‹è¾“å…¥äº‹ä»¶çš„ç›‘å¬ä¸è¯»å– æœ¬èŠ‚å°†è®¨è®ºEventHubå¦ä¸€ä¸ªæ ¸å¿ƒçš„åŠŸèƒ½ï¼Œç›‘å¬ä¸è¯»å–åŸå§‹è¾“å…¥äº‹ä»¶ã€‚ å›å¿†ä¸€ä¸‹è¾“å…¥è®¾å¤‡çš„åŠ è½½è¿‡ç¨‹ï¼Œå½“è®¾å¤‡åŠ è½½æ—¶ï¼ŒopenDeviceLocked()ä¼šæ‰“å¼€è®¾å¤‡èŠ‚ç‚¹çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå¹¶å°†å…¶å¯è¯»äº‹ä»¶æ³¨å†Œè¿›Epollä¸­ã€‚äºæ˜¯å½“è®¾å¤‡çš„åŸå§‹è¾“å…¥äº‹ä»¶åˆ°æ¥æ—¶ï¼ŒgetEvents()å‡½æ•°å°†ä¼šè·å¾—ä¸€æ¡Epolläº‹ä»¶ï¼Œç„¶åæ ¹æ®æ­¤Epolläº‹ä»¶è¯»å–æ–‡ä»¶æè¿°ç¬¦ä¸­çš„åŸå§‹è¾“å…¥äº‹ä»¶ï¼Œå°†å…¶å¡«å……åˆ°RawEventsç»“æ„ä½“å¹¶æ”¾å…¥bufferä¸­è¢«è°ƒç”¨è€…å–èµ°ã€‚openDeviceLocked()æ³¨å†Œäº†è®¾å¤‡èŠ‚ç‚¹çš„EPOLLINå’ŒEPOLLHUPä¸¤ä¸ªäº‹ä»¶ï¼Œåˆ†åˆ«è¡¨ç¤ºå¯è¯»ä¸è¢«æŒ‚èµ·ï¼ˆä¸å¯ç”¨ï¼‰ï¼Œå› æ­¤getEvents()éœ€è¦åˆ†åˆ«å¤„ç†è¿™ä¸¤ç§äº‹ä»¶ã€‚ çœ‹ä¸€ä¸‹getEvents()å‡½æ•°ä¸­çš„ç›¸å…³ä»£ç ï¼š [EventHub.cppâ€“&gt;EventHub::getEvents()] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253size_t EventHub::getEvents(int timeoutMillis,RawEvent* buffer, size_t bufferSize) &#123;for (;;)&#123; ...... // è®¾å¤‡å¢åˆ äº‹ä»¶å¤„ç† while(mPendingEventIndex &lt; mPendingEventCount) &#123; const struct epoll_event&amp; eventItem = mPendingEventItems[mPendingEventIndex++]; ...... // INotifyä¸wakeFdçš„Epolläº‹ä»¶å¤„ç† /* â‘  é€šè¿‡Epollçš„data.u32å­—æ®µè·å–è®¾å¤‡Idï¼Œè¿›è€Œè·å–å¯¹åº”çš„Deviceå¯¹è±¡ã€‚å¦‚æœæ— æ³•æ‰¾åˆ° å¯¹åº”çš„Deviceå¯¹è±¡ï¼Œè¯´æ˜æ­¤Epolläº‹ä»¶å¹¶ä¸è¡¨ç¤ºåŸå§‹è¾“å…¥äº‹ä»¶çš„åˆ°æ¥ï¼Œå¿½ç•¥ä¹‹ */ ssize_t deviceIndex = mDevices.indexOfKey(eventItem.data.u32); Device* device = mDevices.valueAt(deviceIndex); ...... if (eventItem.events &amp; EPOLLIN) &#123; /* â‘¡ å¦‚æœEpolläº‹ä»¶ä¸ºEPOLLINï¼Œè¡¨ç¤ºè®¾å¤‡èŠ‚ç‚¹æœ‰åŸå§‹è¾“å…¥äº‹ä»¶å¯è¯»ã€‚æ­¤æ—¶å¯ä»¥ä»æè¿°ç¬¦ ä¸­è¯»å–ã€‚è¯»å–ç»“æœä½œä¸ºinput_eventç»“æ„ä½“å¹¶å­˜å‚¨åœ¨readBufferä¸­ï¼Œæ³¨æ„äº‹ä»¶çš„ä¸ªæ•° å—åˆ°capacityçš„é™åˆ¶*/ int32_t readSize = read(device-&gt;fd, readBuffer, sizeof(structinput_event) * capacity); if (......) &#123; ......// ä¸€äº›é”™è¯¯å¤„ç† &#125; else &#123; size_t count = size_t(readSize) / sizeof(struct input_event); /* â‘¡ å°†è¯»å–åˆ°çš„æ¯ä¸€ä¸ªinput_eventç»“æ„ä½“ä¸­çš„æ•°æ®è½¬æ¢ä¸ºä¸€ä¸ªRawEventå¯¹è±¡ï¼Œ å¹¶å­˜å‚¨åœ¨bufferå‚æ•°ä¸­ä»¥è¿”å›ç»™è°ƒç”¨è€… */ for (size_t i = 0; i &lt; count; i++) &#123; const structinput_event&amp; iev = readBuffer[i]; ...... event-&gt;when = now; event-&gt;deviceId =deviceId; event-&gt;type =iev.type; event-&gt;code =iev.code; event-&gt;value =iev.value; event += 1; // ç§»åŠ¨åˆ°bufferçš„ä¸‹ä¸€ä¸ªå¯ç”¨å…ƒç´  &#125; /* æ¥ä¸‹æ¥çš„ä¸€ä¸ªç»†èŠ‚éœ€è¦æ³¨æ„ï¼Œå› ä¸ºbufferçš„å®¹é‡é™åˆ¶ï¼Œå¯èƒ½æ— æ³•å®Œå…¨è¯»å–è®¾å¤‡èŠ‚ç‚¹ ä¸­å­˜å‚¨çš„åŸå§‹äº‹ä»¶ã€‚ä¸€æ—¦bufferæ»¡äº†åˆ™éœ€è¦ç«‹åˆ»è¿”å›ç»™è°ƒç”¨è€…ã€‚è®¾å¤‡èŠ‚ç‚¹ä¸­å‰©ä½™çš„ è¾“å…¥äº‹ä»¶å°†åœ¨ä¸‹æ¬¡getEvents()è°ƒç”¨æ—¶ç»§ç»­è¯»å–ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‰çš„Epolläº‹ä»¶ å¹¶æœªå¤„ç†å®Œæ¯•ã€‚mPendingEventIndex -= 1çš„ç›®çš„å°±æ˜¯ä½¿ä¸‹æ¬¡getEvents()è°ƒç”¨ èƒ½å¤Ÿç»§ç»­å¤„ç†è¿™ä¸ªEpolläº‹ä»¶ */ capacity -= count; if (capacity == 0) &#123; mPendingEventIndex -=1; break; &#125; &#125; &#125; else if (eventItem.events &amp; EPOLLHUP) &#123; deviceChanged = true; // å¦‚æœè®¾å¤‡èŠ‚ç‚¹çš„æ–‡ä»¶æè¿°ç¬¦è¢«æŒ‚èµ·åˆ™å¸è½½æ­¤è®¾å¤‡ closeDeviceLocked(device); &#125; else &#123; ...... &#125; &#125; ...... // è¯»å–å¹¶å¤„ç†INotifyäº‹ä»¶ ......// ç­‰å¾…æ–°çš„Epolläº‹ä»¶&#125;return event â€“ bufferï¼›&#125; getEvents()é€šè¿‡Epolläº‹ä»¶çš„data.u32å­—æ®µåœ¨mDevicesåˆ—è¡¨ä¸­æŸ¥æ‰¾å·²åŠ è½½çš„è®¾å¤‡ï¼Œå¹¶ä»è®¾å¤‡çš„æ–‡ä»¶æè¿°ç¬¦ä¸­è¯»å–åŸå§‹è¾“å…¥äº‹ä»¶åˆ—è¡¨ã€‚ä»æ–‡ä»¶æè¿°ç¬¦ä¸­è¯»å–çš„åŸå§‹è¾“å…¥äº‹ä»¶å­˜å‚¨åœ¨input_eventç»“æ„ä½“ä¸­ï¼Œè¿™ä¸ªç»“æ„ä½“çš„å››ä¸ªå­—æ®µå­˜å‚¨äº†äº‹ä»¶çš„äº‹ä»¶æˆ³ã€ç±»å‹ã€ä»£ç ä¸å€¼å››ä¸ªå…ƒç´ ã€‚ç„¶åé€ä¸€å°†input_eventçš„æ•°æ®è½¬å­˜åˆ°RawEventä¸­å¹¶ä¿å­˜è‡³bufferä»¥è¿”å›ç»™è°ƒç”¨è€…ã€‚ æ³¨æ„ä¸ºäº†å™è¿°ç®€å•ï¼Œä¸Šè¿°ä»£ç ä½¿ç”¨äº†è°ƒç”¨getEvents()çš„æ—¶é—´ä½œä¸ºè¾“å…¥äº‹ä»¶çš„æ—¶é—´æˆ³ã€‚ç”±äºè°ƒç”¨getEvents()å‡½æ•°çš„æ—¶æœºä¸ç”¨æˆ·æ“ä½œçš„æ—¶é—´å·®çš„å­˜åœ¨ï¼Œä¼šä½¿å¾—æ­¤æ—¶é—´æˆ³ä¸äº‹ä»¶çš„çœŸå®æ—¶é—´æœ‰æ‰€åå·®ã€‚ä»è®¾å¤‡èŠ‚ç‚¹ä¸­è¯»å–çš„input_eventä¸­ä¹ŸåŒ…å«äº†ä¸€ä¸ªæ—¶é—´æˆ³ï¼Œè¿™ä¸ªæ—¶é—´æˆ³æ¶ˆé™¤äº†getEvents()è°ƒç”¨æ‰€å¸¦æ¥çš„æ—¶é—´å·®ï¼Œå› æ­¤å¯ä»¥è·å¾—æ›´ç²¾ç¡®çš„æ—¶é—´æ§åˆ¶ã€‚å¯ä»¥é€šè¿‡æ‰“å¼€HAVE_POSIX_CLOCKSå®ä»¥ä½¿ç”¨input_eventä¸­çš„æ—¶é—´è€Œä¸æ˜¯å°†getEvents()è°ƒç”¨çš„æ—¶é—´ä½œä¸ºè¾“å…¥äº‹ä»¶çš„æ—¶é—´æˆ³ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äºEpolläº‹ä»¶çš„å¤„ç†ä¼˜å…ˆçº§ä½äºè®¾å¤‡å¢åˆ äº‹ä»¶ï¼Œå› æ­¤å½“å‘ç”Ÿè®¾å¤‡åŠ è½½ä¸å¸è½½åŠ¨ä½œæ—¶ï¼Œä¸ä¼šäº§ç”Ÿè®¾å¤‡è¾“å…¥äº‹ä»¶ã€‚å¦å¤–è¿˜éœ€æ³¨æ„ï¼Œåœ¨ä¸€ä¸ªç›‘å¬å‘¨æœŸä¸­ï¼ŒgetEvents()åœ¨å°†ä¸€ä¸ªè®¾å¤‡èŠ‚ç‚¹ä¸­çš„æ‰€æœ‰åŸå§‹è¾“å…¥äº‹ä»¶è¯»å–å®Œæ¯•ä¹‹å‰ï¼Œä¸ä¼šè¯»å–å…¶ä»–è®¾å¤‡èŠ‚ç‚¹ä¸­çš„äº‹ä»¶ã€‚ 5ã€EventHubæ€»ç»“æœ¬èŠ‚é’ˆå¯¹EventHubçš„è®¾å¤‡ç®¡ç†ä¸åŸå§‹è¾“å…¥äº‹ä»¶çš„ç›‘å¬è¯»å–ä¸¤ä¸ªæ ¸å¿ƒå†…å®¹ä»‹ç»äº†EventHubçš„å·¥ä½œåŸç†ã€‚EventHubä½œä¸ºç›´æ¥æ“ä½œè®¾å¤‡èŠ‚ç‚¹çš„è¾“å…¥ç³»ç»Ÿç»„ä»¶ï¼Œéšè—äº†INotifyä¸Epollä»¥åŠè®¾å¤‡èŠ‚ç‚¹è¯»å–ç­‰åº•å±‚æ“ä½œï¼Œé€šè¿‡ä¸€ä¸ªç®€å•çš„æ¥å£getEvents()å‘ä½¿ç”¨è€…æä¾›æŠ½å–è®¾å¤‡äº‹ä»¶ä¸åŸå§‹è¾“å…¥äº‹ä»¶çš„åŠŸèƒ½ã€‚EventHubçš„æ ¸å¿ƒåŠŸèƒ½éƒ½åœ¨getEvents()å‡½æ•°ä¸­å®Œæˆï¼Œå› æ­¤æ·±å…¥ç†è§£getEvents()çš„å·¥ä½œåŸç†å¯¹äºæ·±å…¥ç†è§£EventHubè‡³å…³é‡è¦ã€‚ getEvents()å‡½æ•°çš„æœ¬è´¨æ˜¯é€šè¿‡epoll_wait()è·å–Epolläº‹ä»¶åˆ°äº‹ä»¶æ± ï¼Œå¹¶å¯¹äº‹ä»¶æ± ä¸­çš„äº‹ä»¶è¿›è¡Œæ¶ˆè´¹çš„è¿‡ç¨‹ã€‚ä»epoll_wait()çš„è°ƒç”¨å¼€å§‹åˆ°äº‹ä»¶æ± ä¸­æœ€åä¸€ä¸ªäº‹ä»¶è¢«æ¶ˆè´¹å®Œæ¯•çš„è¿‡ç¨‹ç§°ä¹‹ä¸ºEventHubçš„ä¸€ä¸ªç›‘å¬å‘¨æœŸã€‚ç”±äºbufferå‚æ•°çš„å°ºå¯¸é™åˆ¶ï¼Œä¸€ä¸ªç›‘å¬å‘¨æœŸå¯èƒ½åŒ…å«å¤šä¸ªgetEvents()è°ƒç”¨ã€‚å‘¨æœŸä¸­çš„ç¬¬ä¸€ä¸ªgetEvents()è°ƒç”¨ä¸€å®šä¼šå› äº‹ä»¶æ± çš„æ¯ç«­è€Œç›´æ¥è¿›è¡Œepoll_wait()ï¼Œè€Œå‘¨æœŸä¸­çš„æœ€åä¸€ä¸ªgetEvents()ä¸€å®šä¼šå°†äº‹ä»¶æ± ä¸­çš„æœ€åä¸€æ¡äº‹ä»¶æ¶ˆè´¹å®Œæ¯•å¹¶å°†äº‹ä»¶è¿”å›ç»™è°ƒç”¨è€…ã€‚å‰æ–‡æ‰€è®¨è®ºçš„äº‹ä»¶ä¼˜å…ˆçº§éƒ½æ˜¯åœ¨åŒä¸€ä¸ªç›‘å¬å‘¨æœŸå†…è€Œè¨€çš„ã€‚ åœ¨æœ¬èŠ‚ä¸­å‡ºç°äº†å¾ˆå¤šç§äº‹ä»¶ï¼Œæœ‰åŸå§‹è¾“å…¥äº‹ä»¶ã€è®¾å¤‡å¢åˆ äº‹ä»¶ã€Epolläº‹ä»¶ã€INotifyäº‹ä»¶ç­‰ï¼Œå­˜å‚¨äº‹ä»¶çš„ç»“æ„ä½“æœ‰RawEventã€epoll_eventã€inotify_eventã€input_eventç­‰ã€‚å›¾5-6å¯ä»¥å¸®åŠ©è¯»è€…ç†æ¸…è¿™äº›äº‹ä»¶ä¹‹é—´çš„å…³ç³»ã€‚ å›¾ 5-6 EventHubçš„äº‹ä»¶å…³è” å¦å¤–ï¼ŒgetEvents()å‡½æ•°è¿”å›çš„äº‹ä»¶åˆ—è¡¨ä¾ç…§äº‹ä»¶çš„ä¼˜å…ˆçº§æ‹¥æœ‰ç‰¹å®šçš„é¡ºåºã€‚å¹¶ä¸”åœ¨ä¸€ä¸ªç›‘å¬å‘¨æœŸä¸­ï¼ŒåŒä¸€è¾“å…¥è®¾å¤‡çš„è¾“å…¥äº‹ä»¶åœ¨åˆ—è¡¨ä¸­æ˜¯ç›¸é‚»çš„ã€‚ è‡³æ­¤ï¼Œç›¸ä¿¡è¯»è€…å¯¹EventHubçš„å·¥ä½œåŸç†ï¼Œä»¥åŠEventHubçš„äº‹ä»¶ç›‘å¬ä¸è¯»å–æœºåˆ¶æœ‰äº†æ·±å…¥çš„äº†è§£ã€‚æ¥ä¸‹æ¥çš„å†…å®¹å°†è®¨è®ºEventHubæ‰€æä¾›çš„åŸå§‹è¾“å…¥äº‹ä»¶å¦‚ä½•è¢«åŠ å·¥ä¸ºAndroidè¾“å…¥äº‹ä»¶ï¼Œè¿™ä¸ªåŠ å·¥è€…å°±æ˜¯Readerå­ç³»ç»Ÿä¸­çš„å¦ä¸€å‘˜å¤§å°†ï¼šInputReaderã€‚ äº”ã€Input Readeræ ¹æ®ç¬¬å››èŠ‚çš„åˆ†æã€‚è¾“å…¥è®¾å¤‡æ‰«æå®Œæˆï¼Œå¹¶åŠ å…¥epollä¸­ï¼Œç›‘å¬äº‹ä»¶ã€‚ä»å‰é¢çš„getEventså‡½æ•°åˆ†æå¾—çŸ¥ï¼Œå½“æŒ‰é”®äº‹ä»¶å‘ç”Ÿåï¼ŒgetEventså‡½æ•°è¿”å›ã€‚ è¿™é‡Œå†è´´ä¸€ä¸‹Input å¤„ç†æ—¶é—´æµç¨‹å›¾ï¼Œç„¶åæŒ‰æ­¥éª¤è¯¦ç»†åˆ†æã€‚ ä»¥ä¸€æ¬¡é”®ç›˜æŒ‰é”®ä¸ºä¾‹ï¼Œå¾—åˆ°ä¸‹é¢çš„6ä¸ªäº‹ä»¶ 123456EventHub: /dev/input/event2 got: time=4383.680195, type=4, code=4, value=458792EventHub: /dev/input/event2 got: time=4383.680195, type=1, code=28, value=1EventHub: /dev/input/event2 got: time=4383.680195, type=0, code=0, value=0EventHub: /dev/input/event2 got: time=4383.760186, type=4, code=4, value=458792EventHub: /dev/input/event2 got: time=4383.760186, type=1, code=28, value=0EventHub: /dev/input/event2 got: time=4383.760186, type=0, code=0, value=0 ä¸Šé¢çš„typeæ˜¯linuxçš„è¾“å…¥ç³»ç»Ÿé‡Œçš„äº‹ä»¶ï¼Œå…·ä½“çš„å€¼å¯ä»¥æŸ¥çœ‹ æŸ¥çœ‹input.h 123456789101112131415/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_SYN 0x00 åŒæ­¥äº‹ä»¶#define EV_KEY 0x01 æŒ‰é”®äº‹ä»¶#define EV_REL 0x02 ç›¸å¯¹åæ ‡#define EV_ABS 0x03 ç»å¯¹åæ ‡/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_MSC 0x04 å…¶å®ƒ#define EV_SW 0x05 #define EV_LED 0x11 LED#define EV_SND 0x12 å£°éŸ³/* WARNING: DO NOT EDIT, AUTO-GENERATED CODE - SEE TOP FOR INSTRUCTIONS */#define EV_REP 0x14 Repeat#define EV_FF 0x15 åŠ›åé¦ˆ#define EV_PWR 0x16 ç”µæº#define EV_FF_STATUS 0x17 çŠ¶æ€ ä¸Šé¢6ä¸ªäº‹ä»¶ï¼Œåªæœ‰ä¸¤ä¸ªtypeä¸º1çš„äº‹ä»¶ï¼Œæ˜¯æˆ‘ä»¬éœ€è¦å¤„ç†çš„æŒ‰é”®äº‹ä»¶ï¼Œä¸€ä¸ªdownï¼Œä¸€ä¸ªup Step 1ã€ InputReader::loopOnce()è¿”å›åˆ°InputReaderçš„loopOnceå‡½æ•° 1234567891011121314[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputReader::loopOnce() &#123; size_t count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE); &#123; // acquire lock AutoMutex _l(mLock); mReaderIsAliveCondition.broadcast(); //å½“æœ‰æŒ‰é”®äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œcountå°†ä¸ä¸º0ï¼Œä»¥ä¸€æ¬¡æŒ‰é”®ä¸ºä¾‹ï¼Œè¿™é‡Œåº”è¯¥æ˜¯6ä¸ªäº‹ä»¶ if (count) &#123; processEventsLocked(mEventBuffer, count); &#125; &#125; // release lock &#125; å½“æœ‰æŒ‰é”®äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œcountå°†ä¸ä¸º0ï¼Œä¹‹åä¼šè°ƒç”¨processEventsLockedæ¥å¤„ç†RawEventã€‚ Step 2ã€InputReader.processEventsLocked()123456789101112131415[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputReader::processEventsLocked(const RawEvent* rawEvents, size_t count) &#123; for (const RawEvent* rawEvent = rawEvents; count;) &#123; int32_t type = rawEvent-&gt;type; size_t batchSize = 1; if (type &lt; EventHubInterface::FIRST_SYNTHETIC_EVENT) &#123; int32_t deviceId = rawEvent-&gt;deviceId; //ä¾æ¬¡å¤„ç†rawEvent processEventsForDeviceLocked(deviceId, rawEvent, batchSize); &#125; count -= batchSize; rawEvent += batchSize; &#125;&#125; è¯¥å‡½æ•°è°ƒç”¨processEventsForDeviceLockedä¾æ¬¡å¤„ç†rawEvent Step 3ã€InputReader.processEventsForDeviceLocked()123456789[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputReader::processEventsForDeviceLocked(int32_t deviceId, const RawEvent* rawEvents, size_t count) &#123; ssize_t deviceIndex = mDevices.indexOfKey(deviceId); InputDevice* device = mDevices.valueAt(deviceIndex); //è°ƒç”¨InputDeviceçš„processå‡½æ•° device-&gt;process(rawEvents, count);&#125; è¿™é‡Œæ ¹æ®deviceIdè·å–åˆ°InputDeviceï¼Œç„¶åè°ƒç”¨InputDeviceçš„processå‡½æ•° Step 4ã€InputDevice.process()1234567891011121314151617181920[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void InputDevice::process(const RawEvent* rawEvents, size_t count) &#123;size_t numMappers = mMappers.size();for (const RawEvent* rawEvent = rawEvents; count--; rawEvent++) &#123; if (mDropUntilNextSync) &#123; if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_REPORT) &#123; &#125; else if (rawEvent-&gt;type == EV_SYN &amp;&amp; rawEvent-&gt;code == SYN_DROPPED) &#123; &#125; else &#123; for (size_t i = 0; i &lt; numMappers; i++) &#123; InputMapper* mapper = mMappers[i]; // InputMapperæ˜¯åšä»€ä¹ˆçš„å‘¢ï¼Œå®ƒæ˜¯ç”¨äºè§£æåŸå§‹è¾“å…¥äº‹ä»¶çš„ã€‚æ¯”å¦‚back, homeç­‰VirtualKeyï¼Œ // ä¼ ä¸Šæ¥æ—¶æ˜¯ä¸ªTouchäº‹ä»¶ï¼Œè¿™é‡Œè¦æ ¹æ®åæ ‡è½¬åŒ–ä¸ºç›¸åº”çš„æŒ‰é”®äº‹ä»¶ã€‚å†æ¯”å¦‚å¤šç‚¹è§¦æ‘¸æ—¶ï¼Œéœ€è¦è®¡ç®— // æ¯ä¸ªè§¦æ‘¸ç‚¹åˆ†åˆ«å±äºå“ªæ¡è½¨è¿¹ï¼Œå®‰å“ç³»ç»Ÿä¸­æ¯ç§è¾“å…¥è®¾å¤‡éƒ½å¯¹åº”äº†ä¸€ç§Mapper,æ¯”å¦‚ // SwitchInputMapper, VibratorInputMapper,KeyBoardInputMapper mapper-&gt;process(rawEvent); &#125; &#125; &#125;&#125; è¿™é‡Œçš„mMappersæˆå‘˜å˜é‡ä¿å­˜äº†ä¸€ç³»åˆ—è¾“å…¥è®¾å¤‡äº‹ä»¶å¤„ç†å¯¹è±¡ï¼Œä¾‹å¦‚è´Ÿè´£å¤„ç†é”®ç›˜äº‹ä»¶çš„KeyboardKeyMapperå¯¹è±¡ä»¥åŠè´Ÿè´£å¤„ç†è§¦æ‘¸å±äº‹ä»¶çš„TouchInputMapperå¯¹è±¡ï¼Œ å®ƒä»¬æ˜¯åœ¨InputReaderç±»çš„æˆå‘˜å‡½æ•°createDeviceLockedä¸­åˆ›å»ºçš„ã€‚è¿™é‡ŒæŸ¥è¯¢æ¯ä¸€ä¸ªInputMapperå¯¹è±¡æ˜¯å¦è¦å¯¹å½“å‰å‘ç”Ÿçš„äº‹ä»¶è¿›è¡Œå¤„ç†ã€‚ç”±äºå‘ç”Ÿçš„æ˜¯é”®ç›˜äº‹ä»¶ï¼ŒçœŸæ­£ä¼šå¯¹è¯¥äº‹ä»¶è¿›è¡Œå¤„ç†çš„åªæœ‰KeyboardKeyMapperå¯¹è±¡ã€‚ Step 5ã€KeyboardInputMapper.process()123456789101112131415161718192021222324252627282930313233343536373839[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void KeyboardInputMapper::process(const RawEvent* rawEvent) &#123; switch (rawEvent-&gt;type) &#123; case EV_KEY: &#123; int32_t scanCode = rawEvent-&gt;code; int32_t usageCode = mCurrentHidUsage; mCurrentHidUsage = 0; if (isKeyboardOrGamepadKey(scanCode)) &#123; int32_t keyCode; uint32_t flags; // è°ƒç”¨EventHubä¸­çš„mapKeyå‡½æ•°è¿›è¡Œè½¬åŒ– // ä¼ å…¥å‚æ•° // scanCodeï¼šé©±åŠ¨ç¨‹åºä¸ŠæŠ¥çš„æ‰«æç ï¼›keyCodeï¼šè½¬åŒ–ä¹‹åçš„Androidä½¿ç”¨çš„æŒ‰é”®å€¼ if (getEventHub()-&gt;mapKey(getDeviceId(), scanCode, usageCode, &amp;keyCode, &amp;flags)) &#123; keyCode = AKEYCODE_UNKNOWN; flags = 0; &#125; //æ˜ å°„æˆåŠŸä¹‹åï¼Œå¤„ç†è¯¥æŒ‰é”® processKey(rawEvent-&gt;when, rawEvent-&gt;value != 0, keyCode, scanCode, flags); &#125; break; &#125; case EV_MSC: &#123; if (rawEvent-&gt;code == MSC_SCAN) &#123; mCurrentHidUsage = rawEvent-&gt;value; &#125; break; &#125; case EV_SYN: &#123; if (rawEvent-&gt;code == SYN_REPORT) &#123; mCurrentHidUsage = 0; &#125; &#125; &#125;&#125; å‡½æ•°é¦–å…ˆè°ƒç”¨isKeyboardOrGamepadKeyæ¥åˆ¤æ–­é”®ç›˜æ‰«æç æ˜¯å¦æ­£ç¡®ï¼Œå¦‚æœæ­£ç¡®åˆ™è°ƒç”¨processKeyæ¥è¿›ä¸€æ­¥å¤„ç† Step 6ã€KeyboardInputMapper.processKey()123456789101112131415[-&gt;frameworks/native/services/inputflinger/InputReader.cpp]void KeyboardInputMapper::processKey(nsecs_t when, bool down, int32_t keyCode, int32_t scanCode, uint32_t policyFlags) &#123; // æ ¹æ®æ‰«æç scanCodeã€æŒ‰é”®ç keyCodeã€newMetaStateã€downTimeæŒ‰ä¸‹çš„æ—¶é—´è¿›è¡Œå¤„ç† // NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, ...... NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP, AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime); // é€šçŸ¥Listenerå¤„ç†ï¼ŒDispatchçº¿ç¨‹ä¼šç›‘å¬è¯¥äº‹ä»¶ï¼Œå¹¶å¤„ç†ï¼Œä¸‹æ¬¡åšæ–‡ä¼šå…·ä½“åˆ†æ getListener()-&gt;notifyKey(&amp;args);&#125; è¿™ä¸ªå‡½æ•°é¦–å…ˆå¯¹æŒ‰é”®ä½œä¸€äº›å¤„ç†ï¼Œæ ¹æ®æ‰«æç scanCodeã€æŒ‰é”®ç keyCodeã€newMetaStateã€downTimeæŒ‰ä¸‹çš„æ—¶é—´è¿›è¡Œå¤„ç† æœ€åå‡½æ•°ä¼šè°ƒç”¨ï¼š 12345NotifyKeyArgs args(when, getDeviceId(), mSource, policyFlags, down ? AKEY_EVENT_ACTION_DOWN : AKEY_EVENT_ACTION_UP, AKEY_EVENT_FLAG_FROM_SYSTEM, keyCode, scanCode, newMetaState, downTime);getListener()-&gt;notifyKey(&amp;args); è¿™é‡ŒgetListeneræ˜¯InputReaderåˆå§‹åŒ–æ—¶ä¼ å…¥çš„å¯¹è±¡ï¼Œå³QueuedInputListenerï¼Œåˆ™ä¼šè°ƒç”¨QueuedInputListenerçš„notifyKeyå‡½æ•° 123void QueuedInputListener::notifyKey(const NotifyKeyArgs* args) &#123;mArgsQueue.push(new NotifyKeyArgs(*args));&#125; InputReaderçš„loopOnce()çš„ç»“å°¾ä¼šè°ƒç”¨QueuedInputListener::flush()ç»Ÿä¸€å›è°ƒç¼“å†²é˜Ÿåˆ—ä¸­å„å…ƒç´ çš„notify()æ¥å£ï¼š 123456789void QueuedInputListener::flush() &#123;size_t count = mArgsQueue.size();for (size_t i = 0; i &lt; count; i++) &#123; NotifyArgs* args = mArgsQueue[i]; args-&gt;notify(mInnerListener); delete args;&#125;mArgsQueue.clear();&#125; è¿›ä¸€æ­¥è°ƒç”¨ï¼š 123void NotifyConfigurationChangedArgs::notify(const sp&lt;InputListenerInterface&gt;&amp; listener) const &#123;listener-&gt;notifyConfigurationChanged(this);&#125; ä»¥æŒ‰é”®äº‹ä»¶ä¸ºä¾‹ï¼Œç”±äºInputDispatcher å®ç°äº†InputListenerInterfaceæ¥å£çš„notifyConfigurationChanged()å‡½æ•°ï¼Œæ‰€ä»¥æœ€åä¼šè°ƒç”¨åˆ°InputDispatcherçš„notifyKey()å‡½æ•°ä¸­ã€‚ Step 7ã€ InputDispatcher.notifyKey()12345678910111213141516171819202122232425262728293031[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::notifyKey(const NotifyKeyArgs* args) &#123;......// æ„é€ ä¸€ä¸ªKeyEventå¯¹è±¡KeyEvent event;event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, 0, args-&gt;downTime, args-&gt;eventTime);// è°ƒç”¨mPolicyçš„interceptKeyBeforeQueueingå‡½æ•°ï¼Œè¯¥å‡½æ•°æœ€åä¼šè°ƒç”¨åˆ°javaå±‚çš„PhoneWindowManagerServiceå‡½æ•°mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, /*byref*/ policyFlags);bool needWake;&#123; // acquire lock mLock.lock(); ...... //æ„é€ ä¸€ä¸ªKeyEntryå¯¹è±¡ï¼Œè°ƒç”¨enqueueInboundEventLockedå‡½æ•°å°†æŒ‰é”®äº‹ä»¶åŠ å…¥é˜Ÿåˆ— KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, repeatCount, args-&gt;downTime); needWake = enqueueInboundEventLocked(newEntry); mLock.unlock();&#125; // release lockif (needWake) &#123; mLooper-&gt;wake();&#125;&#125; è¯¥å‡½æ•°é¦–å…ˆè°ƒç”¨validateKeyEventæ¥åˆ¤æ–­æ˜¯å¦æ˜¯æœ‰æ•ˆæŒ‰é”®äº‹ä»¶ï¼Œå®é™…åˆ¤æ–­æ˜¯å¦æ˜¯UP/DOWNäº‹ä»¶ ç„¶åæ„é€ ä¸€ä¸ªKeyEventå¯¹è±¡ï¼Œè°ƒç”¨mPolicyçš„interceptKeyBeforeQueueingå‡½æ•°ï¼Œè¯¥å‡½æ•°æœ€åä¼šè°ƒç”¨åˆ°javaå±‚çš„PhoneWindowManagerServiceå‡½æ•° 123456KeyEvent event; event.initialize(args-&gt;deviceId, args-&gt;source, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, 0, args-&gt;downTime, args-&gt;eventTime); mPolicy-&gt;interceptKeyBeforeQueueing(&amp;event, /*byref*/ policyFlags); ä¹‹åä¼šè°ƒç”¨æ„é€ ä¸€ä¸ªKeyEntryå¯¹è±¡ï¼Œè°ƒç”¨enqueueInboundEventLockedå‡½æ•°å°†æŒ‰é”®äº‹ä»¶åŠ å…¥é˜Ÿåˆ—ï¼Œå¦‚æœè¿”å›trueï¼Œåˆ™è°ƒç”¨mLooper.wakeå‡½æ•°å”¤é†’ç­‰å¾…çš„InputDispatcherï¼Œè¿›è¡ŒæŒ‰é”®åˆ†å‘ã€‚ 123456KeyEntry* newEntry = new KeyEntry(args-&gt;eventTime, args-&gt;deviceId, args-&gt;source, policyFlags, args-&gt;action, flags, keyCode, args-&gt;scanCode, metaState, repeatCount, args-&gt;downTime);needWake = enqueueInboundEventLocked(newEntry); Step 8ã€InputDispatcher.enqueueInboundEventLocked()123456789101112131415161718192021222324252627[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]bool InputDispatcher::enqueueInboundEventLocked(EventEntry* entry) &#123; bool needWake = mInboundQueue.isEmpty(); mInboundQueue.enqueueAtTail(entry); traceInboundQueueLengthLocked(); switch (entry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; // ...... KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(entry); if (isAppSwitchKeyEventLocked(keyEntry)) &#123; if (keyEntry-&gt;action == AKEY_EVENT_ACTION_DOWN) &#123; mAppSwitchSawKeyDown = true; &#125; else if (keyEntry-&gt;action == AKEY_EVENT_ACTION_UP) &#123; if (mAppSwitchSawKeyDown) &#123; mAppSwitchDueTime = keyEntry-&gt;eventTime + APP_SWITCH_TIMEOUT; mAppSwitchSawKeyDown = false; needWake = true; &#125; &#125; &#125; break; &#125; &#125; return needWake;&#125; å°†EventEntryåŠ å…¥åˆ°mInboundQueueä¸­ï¼Œè¯¥å‡½æ•°ä¸¤ç§æƒ…å†µä¸‹ä¼šè¿”å›true,ä¸€æ˜¯å½“åŠ å…¥è¯¥é”®ç›˜äº‹ä»¶åˆ°mInboundQueueä¹‹å‰ï¼ŒmInboundQueueä¸ºç©ºï¼Œè¿™è¡¨ç¤ºInputDispatc herThreadçº¿ç¨‹æ­£åœ¨ç¡çœ ç­‰å¾…InputReaderThreadçº¿ç¨‹çš„å”¤é†’ï¼Œå› æ­¤ï¼Œå®ƒè¿”å›trueè¡¨ç¤ºè¦å”¤é†’InputDispatccherThreadçº¿ç¨‹ï¼›äºŒæ˜¯åŠ å…¥è¯¥é”®ç›˜äº‹ä»¶åˆ°mInboundQueueä¹‹å‰ï¼ŒmInboundQueueä¸ä¸ºç©ºï¼Œä½†æ˜¯æ­¤æ—¶ç”¨æˆ·æŒ‰ä¸‹çš„æ˜¯Homeé”®ç­‰éœ€è¦åˆ‡æ¢APPçš„æŒ‰é”®ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œåœ¨åˆ‡æ¢Appæ—¶ï¼Œæ–°çš„Appä¼šæŠŠå®ƒçš„é”®ç›˜æ¶ˆæ¯æ¥æ”¶é€šé“æ³¨å†Œåˆ°InputDispatcherä¸­å»ï¼Œå¹¶ä¸”ä¼šç­‰å¾…InputReaderçš„å”¤é†’ï¼Œå› æ­¤ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¹Ÿéœ€è¦è¿”å›trueï¼Œè¡¨ç¤ºè¦å”¤é†’InputDispatccherThreadçº¿ç¨‹ã€‚å¦‚æœä¸æ˜¯è¿™ä¸¤ç§æƒ…å†µï¼Œé‚£ä¹ˆå°±è¯´æ˜InputDispatccherThreadçº¿ç¨‹ç°åœ¨æ­£åœ¨å¤„ç†å‰é¢çš„é”®ç›˜äº‹ä»¶ï¼Œä¸éœ€è¦å”¤é†’å®ƒã€‚ è‡³æ­¤ï¼ŒInputDispatcherThreadè¢«å”¤é†’ï¼Œå¼€å§‹è¿›è¡ŒæŒ‰é”®åˆ†å‘ã€‚ æ€»ç»“ï¼šInputReaderThreadä¸æ–­è°ƒç”¨InputReaderçš„pollOnce()-&gt;getEvents()å‡½æ•°æ¥å¾—åˆ°äº‹ä»¶ï¼Œè¿™äº›äº‹ä»¶å¯ä»¥æ˜¯è¾“å…¥äº‹ä»¶ï¼Œä¹Ÿå¯ä»¥æ˜¯ç”±inotifyç›‘æµ‹åˆ°è®¾å¤‡å¢å‡å˜æ›´æ‰€è§¦å‘çš„äº‹ä»¶ã€‚ç¬¬ä¸€æ¬¡è¿›å…¥æ—¶ä¼šæ‰«æ/dev/inputç›®å½•å»ºç«‹è®¾å¤‡åˆ—è¡¨ï¼Œå­˜åœ¨mDeviceæˆå‘˜å˜é‡ä¸­(EventHubä¸­æœ‰è®¾å¤‡åˆ—è¡¨KeyedVector mDevicesï¼›å¯¹åº”çš„ï¼ŒInputReaderä¸­ä¹Ÿæœ‰è®¾å¤‡åˆ—è¡¨KeyedVector mDevicesã€‚è¿™é‡Œå…ˆæ·»åŠ åˆ°å‰è€…ï¼Œç„¶åä¼šåœ¨InputReader::addDeviceLocked()ä¸­æ·»åŠ åˆ°åè€…ã€‚)ï¼ŒåŒæ—¶å°†å¢åŠ çš„fdåŠ åˆ°epollçš„ç­‰å¾…é›†åˆä¸­ã€‚åœ¨æ¥ä¸‹æ¥çš„epoll_wait()ç­‰å¾…æ—¶ï¼Œå¦‚æœæœ‰äº‹ä»¶å°±ä¼šè¿”å›ï¼ŒåŒæ—¶è¿”å›å¯è¯»äº‹ä»¶æ•°é‡ã€‚åœ¨è¿™é‡Œï¼Œä»Input driverè¯»å‡ºçš„äº‹ä»¶ä»åŸå§‹çš„input_eventç»“æ„è½¬ä¸ºRawEventç»“æ„ï¼Œæ”¾åˆ°getEvents()çš„è¾“å‡ºå‚æ•°bufferä¸­ã€‚getEvents()è¿”å›åï¼ŒInputReaderè°ƒç”¨processEventsLocked()å¤„ç†äº‹ä»¶ï¼Œå¯¹äºè®¾å¤‡æ”¹å˜ï¼Œä¼šæ ¹æ®å®é™…æƒ…å†µè°ƒç”¨addDeviceLocked(), removeDeviceLocked()å’ŒhandleConfigurationChangedLocked()ã€‚å¯¹äºå…¶å®ƒè®¾å¤‡ä¸­æ¥çš„è¾“å…¥äº‹ä»¶ï¼Œä¼šè°ƒç”¨processEventsForDeviceLocked()è¿›ä¸€æ­¥å¤„ç†ã€‚å…¶ä¸­ä¼šæ ¹æ®å½“æ—¶æ³¨å†Œçš„InputMapperå¯¹äº‹ä»¶è¿›è¡Œå¤„ç†ï¼Œç„¶åå°†äº‹ä»¶å¤„ç†è¯·æ±‚æ”¾å…¥ç¼“å†²é˜Ÿåˆ—ï¼ˆQueuedInputListenerä¸­çš„mArgsQueueï¼‰ã€‚ InputMapperæ˜¯åšä»€ä¹ˆçš„å‘¢ï¼Œå®ƒæ˜¯ç”¨äºè§£æåŸå§‹è¾“å…¥äº‹ä»¶çš„ã€‚æ¯”å¦‚back, homeç­‰VirtualKeyï¼Œä¼ ä¸Šæ¥æ—¶æ˜¯ä¸ªTouchäº‹ä»¶ï¼Œè¿™é‡Œè¦æ ¹æ®åæ ‡è½¬åŒ–ä¸ºç›¸åº”çš„æŒ‰é”®äº‹ä»¶ã€‚å†æ¯”å¦‚å¤šç‚¹è§¦æ‘¸æ—¶ï¼Œéœ€è¦è®¡ç®—æ¯ä¸ªè§¦æ‘¸ç‚¹åˆ†åˆ«å±äºå“ªæ¡è½¨è¿¹ï¼Œè¿™æœ¬è´¨ä¸Šæ˜¯ä¸ªäºŒåˆ†å›¾åŒ¹é…é—®é¢˜ï¼Œè¿™ä¹Ÿæ˜¯åœ¨InputMapperä¸­å®Œæˆçš„ã€‚å›åˆ°æµç¨‹ä¸»çº¿ä¸Šï¼Œåœ¨InputReaderçš„loopOnce()çš„ç»“å°¾ä¼šè°ƒç”¨QueuedInputListener::flush()ç»Ÿä¸€å›è°ƒç¼“å†²é˜Ÿåˆ—ä¸­å„å…ƒç´ çš„notify()æ¥å£ã€‚ ä»¥æŒ‰é”®äº‹ä»¶ä¸ºä¾‹ï¼Œæœ€åä¼šè°ƒç”¨åˆ°InputDispatcherçš„notifyKey()å‡½æ•°ä¸­ã€‚è¿™é‡Œå…ˆå°†å‚æ•°å°è£…æˆKeyEventï¼š ç„¶åæŠŠå®ƒä½œä¸ºå‚æ•°è°ƒç”¨NativeInputManagerçš„interceptKeyBeforeQueueing()å‡½æ•°ã€‚é¡¾åæ€ä¹‰ï¼Œå°±æ˜¯åœ¨æ”¾åˆ°å¾…å¤„ç†é˜Ÿåˆ—å‰çœ‹çœ‹æ˜¯ä¸æ˜¯éœ€è¦ç³»ç»Ÿå¤„ç†çš„ç³»ç»ŸæŒ‰é”®ï¼Œå®ƒä¼šé€šè¿‡JNIè°ƒå›Javaä¸–ç•Œï¼Œæœ€ç»ˆè°ƒåˆ°PhoneWindowManagerçš„interceptKeyBeforeQueueing()ã€‚ç„¶åï¼ŒåŸºäºè¾“å…¥äº‹ä»¶ä¿¡æ¯åˆ›å»ºKeyEntryå¯¹è±¡ï¼Œè°ƒç”¨enqueueInboundEventLocked()å°†ä¹‹æ”¾å…¥é˜Ÿåˆ—ç­‰å¾…InputDiaptcherThreadçº¿ç¨‹æ‹¿å‡ºå¤„ç†ã€‚ å…­ã€Input DispatcherInputDisptacherçš„ä¸»è¦ä»»åŠ¡æ˜¯æŠŠå‰é¢æ”¶åˆ°çš„è¾“å…¥äº‹ä»¶å‘é€åˆ°PWMåŠAppç«¯çš„ç„¦ç‚¹çª—å£ã€‚å‰é¢æåˆ°InputReaderThreadä¸­æ”¶åˆ°äº‹ä»¶åä¼šè°ƒç”¨notifyKey()æ¥é€šçŸ¥InputDispatcherï¼Œä¹Ÿå°±æ˜¯æ”¾åœ¨mInboundQueueä¸­ï¼Œåœ¨InputDispatcherçš„dispatchOnce()å‡½æ•°ä¸­ï¼Œä¼šä»è¿™ä¸ªé˜Ÿåˆ—æ‹¿å‡ºå¤„ç†ã€‚ å…¶ä¸­dispatchOnceInnerLocked()ä¼šæ ¹æ®æ‹¿å‡ºçš„EventEntryç±»å‹è°ƒç”¨ç›¸åº”çš„å¤„ç†å‡½æ•°ï¼Œä»¥Keyäº‹ä»¶ä¸ºä¾‹ä¼šè°ƒç”¨dispatchKeyLocked() å®ƒä¼šæ‰¾åˆ°ç›®æ ‡çª—å£ï¼Œç„¶åé€šè¿‡ä¹‹å‰å’ŒAppé—´å»ºç«‹çš„è¿æ¥å‘é€äº‹ä»¶ã€‚å¦‚æœæ˜¯ä¸ªéœ€è¦ç³»ç»Ÿå¤„ç†çš„Keyäº‹ä»¶ï¼Œè¿™é‡Œä¼šå°è£…æˆCommandEntryæ’å…¥åˆ°mCommandQueueé˜Ÿåˆ—ä¸­ï¼Œåé¢çš„runCommandLockedInterruptible()å‡½æ•°ä¸­ä¼šè°ƒç”¨doInterceptKeyBeforeDispatchingLockedInterruptible()æ¥è®©PWMæœ‰æœºä¼šè¿›è¡Œå¤„ç†ã€‚æœ€ådispatchOnce()è°ƒç”¨pollOnce()ä»å’ŒAppçš„è¿æ¥ä¸Šæ¥æ”¶å¤„ç†å®Œæˆæ¶ˆæ¯ã€‚é‚£ä¹ˆï¼ŒInputDispatcheræ˜¯æ€ä¹ˆç¡®å®šè¦å¾€å“ªä¸ªçª—å£ä¸­å‘äº‹ä»¶å‘¢ï¼Ÿè¿™é‡Œçš„æˆå‘˜å˜é‡mFocusedWindowHandleæŒ‡ç¤ºäº†ç„¦ç‚¹çª—å£ï¼Œç„¶åfindFocusedWindowTargetsLocked()ä¼šè°ƒç”¨ä¸€ç³»åˆ—å‡½æ•°ï¼ˆhandleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()ç­‰ï¼‰æ£€æŸ¥mFocusedWindowHandleæ˜¯å¦èƒ½æ¥æ”¶è¾“å…¥äº‹ä»¶ã€‚å¦‚æœå¯ä»¥ï¼Œå°†ä¹‹ä»¥InputTargetçš„å½¢å¼åŠ åˆ°ç›®æ ‡çª—å£æ•°ç»„ä¸­ã€‚ç„¶åå°±ä¼šè°ƒç”¨dispatchEventLocked()è¿›è¡Œå‘é€ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªmFocusedWindowHandleæ˜¯å¦‚ä½•ç»´æŠ¤çš„å‘¢ï¼Ÿä¸ºäº†æ›´å¥½åœ°ç†è§£ï¼Œè¿™é‡Œå›å¤´åˆ†æä¸‹çª—å£è¿æ¥çš„ç®¡ç†åŠç„¦ç‚¹çª—å£çš„ç®¡ç†ã€‚ æ€»ä½“æµç¨‹å›¾ï¼š å†è´´ä¸€å¼ è¯¦ç»†çš„æ€»ä½“æµç¨‹å›¾ï¼Œç„¶åæ ¹æ®æ­¥éª¤è¯¦ç»†åˆ†æï¼› Step 1ã€InputDispatcher.dispatchOnce()1234567891011121314151617181920212223242526[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchOnce() &#123;nsecs_t nextWakeupTime = LONG_LONG_MAX;&#123; // acquire lock AutoMutex _l(mLock); mDispatcherIsAliveCondition.broadcast(); // Run a dispatch loop if there are no pending commands. // The dispatch loop might enqueue commands to run afterwards. if (!haveCommandsLocked()) &#123; dispatchOnceInnerLocked(&amp;nextWakeupTime); &#125; // Run all pending commands if there are any. // If any commands were run then force the next poll to wake up immediately. if (runCommandsLockedInterruptible()) &#123; nextWakeupTime = LONG_LONG_MIN; &#125;&#125; // release lock// Wait for callback or timeout or wake. (make sure we round up, not down)nsecs_t currentTime = now();int timeoutMillis = toMillisecondTimeoutDelay(currentTime, nextWakeupTime);mLooper-&gt;pollOnce(timeoutMillis);&#125; ä¸Šè¿°å‡½æ•°ä¸»è¦æ˜¯è°ƒç”¨dispatchOnceInnerLockedæ¥è¿›è¡Œä¸€æ¬¡æŒ‰é”®åˆ†å‘ï¼Œå½“æ²¡æœ‰æŒ‰é”®æ¶ˆæ¯æ—¶ä¼šèµ°åˆ°mLooper-&gt;pollOnce(timeoutMillis);è¿™ä¸ªå‡½æ•°ä¼šè¿›å…¥ç¡çœ çŠ¶æ€ï¼Œå½“æœ‰æŒ‰é”®æ¶ˆæ¯å‘ç”Ÿæ—¶è¯¥å‡½æ•°ä¼šè¿”å›ï¼Œç„¶åèµ°åˆ°dispatchOnceInnerLockedå‡½æ•°ã€‚ Step 2ã€InputDispatcher.dispatchOnceInnerLocked()1234567891011121314151617181920212223242526272829303132333435363738394041[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchOnceInnerLocked(nsecs_t* nextWakeupTime) &#123; nsecs_t currentTime = now(); ... // Ready to start a new event. // If we don't already have a pending event, go grab one. if (! mPendingEvent) &#123; //å½“InputReaderå¾€é˜Ÿåˆ—ä¸­æ’å…¥äº†ä¸€ä¸ªè¯»å–çš„é”®ç›˜æ¶ˆæ¯åï¼Œæ­¤å¤„çš„mInboundQueueå°±ä¸ä¸ºç©º if (mInboundQueue.isEmpty()) &#123; ... &#125; else &#123; // Inbound queue has at least one entry. mPendingEvent = mInboundQueue.dequeueAtHead(); ... &#125; ... &#125; ... switch (mPendingEvent-&gt;type) &#123; ... case EventEntry::TYPE_KEY: &#123; KeyEntry* typedEntry = static_cast&lt;KeyEntry*&gt;(mPendingEvent); ... done = dispatchKeyLocked(currentTime, typedEntry, &amp;dropReason, nextWakeupTime); break; &#125; ... &#125; if (done) &#123; if (dropReason != DROP_REASON_NOT_DROPPED) &#123; dropInboundEventLocked(mPendingEvent, dropReason); &#125; mLastDropReason = dropReason; releasePendingEventLocked(); *nextWakeupTime = LONG_LONG_MIN; // force next poll to wake up immediately &#125;&#125; ä»å‰æ–‡InputReaderè¯»å–é”®ç›˜æ¶ˆæ¯è¿‡ç¨‹åˆ†æ InputReaderè¯»å–åˆ°ä¸€ä¸ªæ¶ˆæ¯åä¼šè°ƒç”¨KeyboardInputMapperçš„processKeyï¼Œè¯¥å‡½æ•°ä¼šè°ƒç”¨InputDispatcherçš„notifyKeyå‡½æ•°ï¼Œç„¶åInputDispatcherä¼šè°ƒç”¨enqueueInboundEventLockedå‡½æ•°ï¼Œå°†EventEntryåŠ å…¥åˆ°mInboundQueueä¸­ï¼Œç„¶åè°ƒç”¨mLooper-&gt;wakeå‡½æ•°ä¼šå”¤é†’InputDispatcherThreadçº¿ç¨‹ï¼ŒInputDispatcherä¸­æŠŠé˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªäº‹ä»¶å–å‡ºæ¥ï¼Œå› ä¸ºè¿™é‡Œæ˜¯é”®ç›˜äº‹ä»¶ï¼Œæ‰€ä»¥mPendingEvent-&gt;typeæ˜¯EventEntry::TYPE_KEYï¼Œç„¶åè°ƒç”¨dispatchKeyLockedå‡½æ•° æƒ¯ä¾‹å…ˆè´´å‡ºåºåˆ—å›¾ï¼ŒæŒ‰æ­¥éª¤ä¸€æ­¥æ­¥ä»‹ç»ã€‚ Step 3ã€InputDispatcher.dispatchKeyLocked()12345678910111213141516171819202122232425262728293031[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp ]bool InputDispatcher::dispatchKeyLocked(nsecs_t currentTime, KeyEntry* entry, DropReason* dropReason, nsecs_t* nextWakeupTime) &#123; ... // Give the policy a chance to intercept the key. if (entry-&gt;interceptKeyResult == KeyEntry::INTERCEPT_KEY_RESULT_UNKNOWN) &#123; if (entry-&gt;policyFlags &amp; POLICY_FLAG_PASS_TO_USER) &#123; CommandEntry* commandEntry = postCommandLocked( &amp; InputDispatcher::doInterceptKeyBeforeDispatchingLockedInterruptible); if (mFocusedWindowHandle != NULL) &#123; commandEntry-&gt;inputWindowHandle = mFocusedWindowHandle; &#125; ...... &#125; else &#123; entry-&gt;interceptKeyResult = KeyEntry::INTERCEPT_KEY_RESULT_CONTINUE; &#125; &#125; ...... // Identify targets. Vector&lt;InputTarget&gt; inputTargets; int32_t injectionResult = findFocusedWindowTargetsLocked(currentTime, entry, inputTargets, nextWakeupTime); ...... setInjectionResultLocked(entry, injectionResult); ...... addMonitoringTargetsLocked(inputTargets); // Dispatch the key. dispatchEventLocked(currentTime, entry, inputTargets); return true;&#125; è¿™ä¸ªå‡½æ•°ä¸»è¦åšäº†ä¸‹é¢ä¸‰ä»¶äº‹ A. å¦‚æœæŒ‰é”®æ˜¯ç¬¬ä¸€æ¬¡åˆ†å‘ï¼Œåˆ™å°†å‘½ä»¤å°è£…ä¸ºCommandEntryåŠ å…¥é˜Ÿåˆ—ï¼Œåç»­æ‰§è¡ŒdoInterceptKeyBeforeDispatchingLockedInterruptibleï¼Œä»¥ç»™javaå±‚æ‹¦æˆªæŒ‰é”®çš„æœºä¼š B. æ‰¾åˆ°å½“å‰æ¿€æ´»çš„Windowçª—å£ï¼Œå¹¶å°†å…¶åŠ å…¥åˆ°Vectorä¸­ï¼ŒAndroid ANRå°±æ˜¯åœ¨findFocusedWindowTargetsLocked()æ£€æµ‹çš„ C. æ‰¾åˆ°éœ€è¦ä¸»åŠ¨ç›‘å¬æŒ‰é”®çš„InputChannel,å°è£…æˆInputTargetï¼ŒåŠ å…¥åˆ°Vectorä¸­ D. å°†æŒ‰é”®åˆ†å‘åˆ°ä¸Šé¢çš„Vectorä¸­çš„InputChannelä¸­ï¼Œè¿™é‡Œå­˜åœ¨å¤šä¸ª ä¸‹é¢å…ˆåˆ†æå¦‚æœå°†æŒ‰é”®åˆ†å‘ç»™InputChannel 123456789101112131415[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::dispatchEventLocked(nsecs_t currentTime, EventEntry* eventEntry, const Vector&lt;InputTarget&gt;&amp; inputTargets) &#123;......for (size_t i = 0; i &lt; inputTargets.size(); i++) &#123; const InputTarget&amp; inputTarget = inputTargets.itemAt(i); ssize_t connectionIndex = getConnectionIndexLocked(inputTarget.inputChannel); if (connectionIndex &gt;= 0) &#123; sp&lt;Connection&gt; connection = mConnectionsByFd.valueAt(connectionIndex); prepareDispatchCycleLocked(currentTime, connection, eventEntry, &amp;inputTarget); &#125; ...... &#125; &#125;&#125; Step 5ã€InputDispatcher.prepareDispatchCycleLocked()12345678[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::prepareDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; ... // Not splitting. Enqueue dispatch entries for the event as is. enqueueDispatchEntriesLocked(currentTime, connection, eventEntry, inputTarget); &#125; å‡½æ•°å‰é¢è¿˜æœ‰ä¸€äº›çŠ¶æ€æ£€æŸ¥ï¼Œè¿™é‡Œé»˜è®¤éƒ½æ˜¯é€šè¿‡çš„ã€‚æœ€åenqueueDispatchEntriesLockedå‡½æ•°è¿›è¡Œå°†connectionåˆ†è£…æˆDispatchEntryï¼ŒåŠ å…¥åˆ°connection-&gt;outboundQueueçš„é˜Ÿåˆ—ä¸­ Step 6. InputDispatcher::enqueueDispatchEntriesLocked()123456789101112131415161718[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::enqueueDispatchEntriesLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection, EventEntry* eventEntry, const InputTarget* inputTarget) &#123; bool wasEmpty = connection-&gt;outboundQueue.isEmpty(); // Enqueue dispatch entries for the requested modes. enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT); ...... enqueueDispatchEntryLocked(connection, eventEntry, inputTarget, InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER); // If the outbound queue was previously empty, start the dispatch cycle going. if (wasEmpty &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; startDispatchCycleLocked(currentTime, connection); &#125;&#125; è¿™ä¸ªå‡½æ•°é¦–å…ˆè·å–ä»¥å‰çš„connectionçš„outboundQueueæ˜¯å¦ä¸ºç©ºï¼Œç„¶åå°†è¯¥äº‹ä»¶è°ƒç”¨enqueueDispatchEntryLockedå°†äº‹ä»¶åŠ å…¥åˆ°outboundQueueä¸­ï¼Œå¦‚æœä»¥å‰ä¸ºç©ºï¼Œç°åœ¨ä¸ä¸ºç©ºï¼Œåˆ™è°ƒç”¨startDispatchCycleLockedå¼€å§‹åˆ†å‘ï¼Œå¦‚æœä»¥å‰çš„outboundQueueä¸ä¸ºç©ºï¼Œè¯´æ˜å½“å‰çš„Activityæ­£åœ¨å¤„ç†å‰é¢çš„æŒ‰é”®ï¼Œåˆ™ä¸éœ€è¦å†è°ƒç”¨startDispatchCycleLockedï¼Œå› ä¸ºåªè¦å¼€å§‹å¤„ç†ï¼Œä¼šç­‰åˆ°é˜Ÿåˆ—ä¸ºç©ºæ‰ä¼šåœæ­¢ã€‚ Step 7ã€InputDispatcher.startDispatchCycleLocked()12345678910111213141516171819202122232425262728293031323334353637[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::startDispatchCycleLocked(nsecs_t currentTime, const sp&lt;Connection&gt;&amp; connection) &#123; while (connection-&gt;status == Connection::STATUS_NORMAL &amp;&amp; !connection-&gt;outboundQueue.isEmpty()) &#123; DispatchEntry* dispatchEntry = connection-&gt;outboundQueue.head; dispatchEntry-&gt;deliveryTime = currentTime; // Publish the event. status_t status; EventEntry* eventEntry = dispatchEntry-&gt;eventEntry; switch (eventEntry-&gt;type) &#123; case EventEntry::TYPE_KEY: &#123; KeyEntry* keyEntry = static_cast&lt;KeyEntry*&gt;(eventEntry); // Publish the key event. status = connection-&gt;inputPublisher.publishKeyEvent(dispatchEntry-&gt;seq, keyEntry-&gt;deviceId, keyEntry-&gt;source, dispatchEntry-&gt;resolvedAction, dispatchEntry-&gt;resolvedFlags, keyEntry-&gt;keyCode, keyEntry-&gt;scanCode, keyEntry-&gt;metaState, keyEntry-&gt;repeatCount, keyEntry-&gt;downTime, keyEntry-&gt;eventTime); break; &#125; ...... &#125; ...... // Re-enqueue the event on the wait queue. connection-&gt;outboundQueue.dequeue(dispatchEntry); traceOutboundQueueLengthLocked(connection); connection-&gt;waitQueue.enqueueAtTail(dispatchEntry); traceWaitQueueLengthLocked(connection); &#125;//end of while&#125; è¯¥å‡½æ•°ä»outboundQueueä¸­å–å‡ºéœ€è¦å¤„ç†çš„é”®ç›˜äº‹ä»¶ï¼Œäº¤ç»™connectionçš„inputPublisherå»åˆ†å‘ï¼Œä¹‹åå°†äº‹ä»¶åŠ å…¥åˆ°connectionçš„waitQueueä¸­ã€‚åˆ†å‘äº‹ä»¶æ˜¯é€šè¿‡InputPublisherçš„publishKeyEventæ¥å®Œæˆçš„ã€‚ Step 8ã€InputPublisher.publishKeyEvent123456789101112131415[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputPublisher::publishKeyEvent( uint32_t seq,int32_t deviceId,int32_t source, int32_t action,int32_t flags,int32_t keyCode, int32_t scanCode,int32_t metaState,int32_t repeatCount, nsecs_t downTime,nsecs_t eventTime) &#123; InputMessage msg; msg.header.type = InputMessage::TYPE_KEY; ...... msg.body.key.eventTime = eventTime; return mChannel-&gt;sendMessage(&amp;msg);&#125; è¯¥å‡½æ•°ä¸»è¦æ˜¯å°†å„ä¸ªå‚æ•°å°è£…åˆ°InputMessageä¸­ï¼Œç„¶åäº¤ç»™mChannelå¯¹è±¡å»åˆ†å‘ mChannelå…¶å®æ˜¯socketpairçš„serverç«¯ï¼Œå…¶å®å°±æ˜¯åˆ›å»ºçš„æœåŠ¡å™¨InputChannelï¼Œå…¶åˆ›å»ºè¿‡ç¨‹ç¨åè¯¦ç»†åˆ†æã€‚ Step 9ã€InputChannel.sendMessage()12345678910[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputChannel::sendMessage(const InputMessage* msg) &#123; size_t msgLength = msg-&gt;size(); ssize_t nWrite; do &#123; nWrite = ::send(mFd, msg, msgLength, MSG_DONTWAIT | MSG_NOSIGNAL); &#125; while (nWrite == -1 &amp;&amp; errno == EINTR); return OK;&#125; è¯¥å‡½æ•°ä¸»è¦æ˜¯é€šè¿‡sendå‡½æ•°å¾€socketpairçš„serverç«¯å†™å…¥InputMessageå¯¹è±¡ï¼Œåº”ç”¨ç¨‹åºè¿™ä¸€ä¾§æ­£ç¡çœ åœ¨clientç«¯çš„fdä¸Šï¼Œæ­¤æ—¶clientç«¯å°±ä¼šæ”¶åˆ°è¯¥InputMessageï¼Œclientä¼šè¿›è¡ŒæŒ‰é”®æŒ‰é”®åˆ†å‘ï¼Œåº”ç”¨ç¨‹åºè¿™ä¸€ä¾§çš„æŒ‰é”®åˆ†å‘è¯·çœ‹ä¸‹ä¸€èŠ‚ã€‚ ä¸ƒã€Appæ³¨å†Œæ¶ˆæ¯ç›‘å¬è¿‡ç¨‹åˆ†ææ€»ä½“æµç¨‹å›¾ InputDispatcherä¼šæ‰¾åˆ°ç›®æ ‡çª—å£ï¼Œç„¶åé€šè¿‡ä¹‹å‰å’ŒAppé—´å»ºç«‹çš„è¿æ¥å‘é€äº‹ä»¶ã€‚å¦‚æœæ˜¯ä¸ªéœ€è¦ç³»ç»Ÿå¤„ç†çš„Keyäº‹ä»¶ï¼Œè¿™é‡Œä¼šå°è£…æˆCommandEntryæ’å…¥åˆ°mCommandQueueé˜Ÿåˆ—ä¸­ï¼Œåé¢çš„runCommandLockedInterruptible()å‡½æ•°ä¸­ä¼šè°ƒç”¨doInterceptKeyBeforeDispatchingLockedInterruptible()æ¥è®©PWMæœ‰æœºä¼šè¿›è¡Œå¤„ç†ã€‚æœ€ådispatchOnce()è°ƒç”¨pollOnce()ä»å’ŒAppçš„è¿æ¥ä¸Šæ¥æ”¶å¤„ç†å®Œæˆæ¶ˆæ¯ã€‚é‚£ä¹ˆï¼ŒInputDispatcheræ˜¯æ€ä¹ˆç¡®å®šè¦å¾€å“ªä¸ªçª—å£ä¸­å‘äº‹ä»¶å‘¢ï¼Ÿè¿™é‡Œçš„æˆå‘˜å˜é‡mFocusedWindowHandleæŒ‡ç¤ºäº†ç„¦ç‚¹çª—å£ï¼Œç„¶åfindFocusedWindowTargetsLocked()ä¼šè°ƒç”¨ä¸€ç³»åˆ—å‡½æ•°ï¼ˆhandleTargetsNotReadyLocked(), checkInjectionPermission(), checkWindowReadyForMoreInputLocked()ç­‰ï¼‰æ£€æŸ¥mFocusedWindowHandleæ˜¯å¦èƒ½æ¥æ”¶è¾“å…¥äº‹ä»¶ã€‚å¦‚æœå¯ä»¥ï¼Œå°†ä¹‹ä»¥InputTargetçš„å½¢å¼åŠ åˆ°ç›®æ ‡çª—å£æ•°ç»„ä¸­ã€‚ç„¶åå°±ä¼šè°ƒç”¨dispatchEventLocked()è¿›è¡Œå‘é€ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªmFocusedWindowHandleæ˜¯å¦‚ä½•ç»´æŠ¤çš„å‘¢ï¼Ÿä¸ºäº†æ›´å¥½åœ°ç†è§£ï¼Œè¿™é‡Œå›å¤´åˆ†æä¸‹çª—å£è¿æ¥çš„ç®¡ç†åŠç„¦ç‚¹çª—å£çš„ç®¡ç†ã€‚ åœ¨Appç«¯ï¼Œæ–°çš„é¡¶å±‚çª—å£éœ€è¦è¢«æ³¨å†Œåˆ°WMSä¸­ï¼Œè¿™æ˜¯åœ¨ViewRootImpl::setView()ä¸­åšçš„ã€‚ Step 1ã€ViewRootImpl.setView()1234567891011121314151617181920212223242526272829303132333435[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; // è°ƒç”¨requestLayoutæ¥é€šçŸ¥InputManagerServiceå½“å‰çš„çª—å£æ˜¯æ¿€æ´»çš„çª—å£ requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; // å¦‚æœè¯¥çª—å£æ²¡æœ‰æŒ‡å®šINPUT_FEATURE_NO_INPUT_CHANNELå±æ€§ï¼Œåˆ™åˆ›å»ºæ¶ˆæ¯æ¥æ”¶é€šé“InputChannel mInputChannel = new InputChannel(); &#125; try &#123; // é€šè¿‡binderè°ƒç”¨ï¼Œè°ƒç”¨serverç«¯çš„Sessionå¯¹è±¡æ¥è·ŸWindowManagerServiceé€šä¿¡ï¼Œè¯¥å‡½æ•°æœ€åä¼šè°ƒ // ç”¨åˆ°WindowManagerServiceçš„addWindowå‡½æ•°ï¼Œå‡½æ•°ä¸­ä¼šåˆ›å»ºä¸€å¯¹InputChannel(server/client)ï¼Œ // è¿™æ ·åœ¨å‡½æ•°è°ƒç”¨ç»“æŸåï¼ŒmInputChannelå°±å˜æˆäº†clientç«¯çš„å¯¹è±¡ã€‚åœ¨ // frameworks/base/core/java/android/view/IWindowSession.aidlçš„ // addToDisplayå‡½æ•°çš„å£°æ˜ä¸­ï¼ŒInputChannelæŒ‡å®šçš„æ•°æ®æµçš„æµå‘æ˜¯outï¼Œå› æ­¤ // WindowManagerServiceä¿®æ”¹äº†mInputChannel,å®¢æˆ·ç«¯å°±èƒ½æ‹¿åˆ°è¿™ä¸ªå¯¹è±¡çš„æ•°æ®äº†ã€‚ res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (Exception e) &#123; ... &#125; if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); // åˆå§‹åŒ–WindowInputEventReceiverï¼ŒæŒ‰é”®æ¶ˆæ¯ä¼šä»nativeå±‚ä¼ åˆ°è¯¥å¯¹è±¡çš„onInputEventå‡½æ•° // ä¸­ï¼ŒonInputEventå‡½æ•°æ˜¯æŒ‰é”®åœ¨åº”ç”¨ç«¯javaå±‚åˆ†å‘çš„èµ·å§‹ç«¯ã€‚ mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; &#125;&#125; è¿™ä¸ªå‡½æ•°ä¸æ³¨å†Œé”®ç›˜æ¶ˆæ¯é€šé“çš„ç›¸å…³ä¸»è¦æœ‰ä¸‰ä¸ªåŠŸèƒ½ï¼š ä¸€æ˜¯è°ƒç”¨requestLayoutå‡½æ•°æ¥é€šçŸ¥InputManagerServiceï¼Œè¿™ä¸ªActivityçª—å£æ˜¯å½“å‰è¢«æ¿€æ´»çš„çª—å£,åŒæ—¶å°†æ‰€æœ‰çš„çª—å£æ³¨å†Œåˆ°InputDispatcherä¸­ äºŒæ˜¯è°ƒç”¨mWindowSessionçš„addæˆå‘˜å‡½æ•°æ¥æŠŠé”®ç›˜æ¶ˆæ¯æ¥æ”¶é€šé“çš„serverç«¯æ³¨å†Œç«¯æ³¨å†Œåˆ°CPPå±‚çš„InputManagerServiceä¸­ï¼Œclientç«¯æ³¨å†Œåˆ°æœ¬åº”ç”¨ç¨‹åºçš„æ¶ˆæ¯å¾ªç¯Looperä¸­ï¼Œè¿™æ ·å½“InputManagerServiceç›‘æ§åˆ°æœ‰é”®ç›˜æ¶ˆæ¯çš„æ—¶å€™ï¼Œå°±ä¼šæ‰¾åˆ°å½“å‰è¢«æ¿€æ´»çš„çª—å£ï¼Œç„¶åæ‰¾åˆ°å…¶åœ¨InputManagerServiceä¸­å¯¹åº”çš„é”®ç›˜æ¶ˆæ¯æ¥æ”¶é€šé“(InputChannel)ï¼Œé€šè¿‡è¿™ä¸ªé€šé“åœ¨InputManagerServiceçš„serverç«¯æ¥é€šçŸ¥åº”ç”¨ç¨‹åºæ¶ˆæ¯å¾ªç¯çš„clientç«¯ï¼Œè¿™æ ·å°±æŠŠé”®ç›˜æ¶ˆæ¯åˆ†å‘ç»™å½“å‰æ¿€æ´»çš„Activityçª—å£äº† ä¸‰æ˜¯åº”ç”¨ç¨‹åºè¿™ä¸€ä¾§æ³¨å†Œæ¶ˆæ¯æ¥æ”¶é€šé“ Step 2ã€ViewRootImpl.requestLayout()12345678910[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125; &#125; è¿™é‡Œè°ƒç”¨äº†scheduleTraversalså‡½æ•°æ¥åšè¿›ä¸€æ­¥çš„æ“ä½œï¼Œè¯¥å‡½æ•°è°ƒç”¨mChoreographeræ¥postä¸€ä¸ªRunnableåˆ°Looperä¸­ï¼Œä¹‹åVsycnä¿¡å·åˆ°æ¥ä¼šæ‰§è¡ŒmTraversalRunnableä¸­çš„runæ–¹æ³•ï¼Œå³è°ƒç”¨doTraversalå‡½æ•° å‚è€ƒæ–‡æ¡£ï¼šã€Android 7.1.2(Android N) Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ã€‘ Step 3ã€ViewRootImpl.doTraversal()123456789[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); performTraversals(); &#125;&#125; è¯¥å‡½æ•°ä¸»è¦æ˜¯æ‰§è¡ŒperformTraversals()å‡½æ•°ï¼Œè¿›è€Œè°ƒç”¨relayoutWindowå‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°ä¸­åˆä¼šè°ƒç”¨mWindowSessionçš„relayoutè¿›å…¥åˆ°javaå±‚çš„WindowManagerServiceçš„relayoutWindowå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šè°ƒç”¨mInputMonitor.updateInputWindowsLw(true /force/);mInputMonitoræ˜¯InputMonitorå¯¹è±¡ã€‚ Step 4ã€InputMonitor.updateInputWindowsLw()123456789101112131415161718192021[-&gt;frameworks/base/services/core/java/com/android/server/wm/InputMonitor.java]public void updateInputWindowsLw(boolean force) &#123;boolean addInputConsumerHandle = mService.mInputConsumer != null;// Add all windows on the default display.final int numDisplays = mService.mDisplayContents.size();for (int displayNdx = 0; displayNdx &lt; numDisplays; ++displayNdx) &#123; WindowList windows = mService.mDisplayContents.valueAt(displayNdx).getWindowList(); for (int winNdx = windows.size() - 1; winNdx &gt;= 0; --winNdx) &#123; final WindowState child = windows.get(winNdx); final InputChannel inputChannel = child.mInputChannel; final InputWindowHandle inputWindowHandle = child.mInputWindowHandle; ...... addInputWindowHandleLw(inputWindowHandle, child, flags, type, isVisible, hasFocus, hasWallpaper); &#125;&#125;// Send windows to native code.mService.mInputManager.setInputWindows(mInputWindowHandles);&#125; è¿™ä¸ªå‡½æ•°å°†å½“å‰ç³»ç»Ÿä¸­å¸¦æœ‰InputChannelçš„Activityçª—å£éƒ½è®¾ç½®ä¸ºInputManagerServiceçš„è¾“å…¥çª—å£ï¼Œä½†æ˜¯åé¢æˆ‘ä»¬ä¼šçœ‹åˆ°ï¼Œåªæœ‰å½“å‰æ¿€æ´»çš„çª—å£æ‰ä¼šå“åº”é”®ç›˜æ¶ˆæ¯ã€‚ Step 5ã€InputManagerService.setInputWindows()12345[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]public void setInputWindows(InputWindowHandle[] windowHandles) &#123; nativeSetInputWindows(mPtr, windowHandles);&#125; è¿™ä¸ªå‡½æ•°è°ƒç”¨äº†æœ¬åœ°æ–¹æ³•nativeSetInputWindowsæ¥è¿›ä¸€æ­¥æ‰§è¡Œæ“ä½œ,mPtræ˜¯nativeå±‚NativeInputManagerå®ä¾‹ï¼Œåœ¨è°ƒç”¨InputManagerService.nativeInitå‡½æ•°æ—¶ä¼šåœ¨nativeå±‚æ„é€ NativeInputManagerå¯¹è±¡å¹¶å°†å…¶ä¿å­˜åœ¨mPträ¸­ã€‚nativeSetInputWindowsä¼šè°ƒç”¨NativeInputManagerçš„setInputWindowså‡½æ•° Step 6ã€NativeInputManager.setInputWindows()12345678910111213141516171819202122232425262728293031[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]void NativeInputManager::setInputWindows(JNIEnv* env, jobjectArray windowHandleObjArray) &#123; Vector&lt;sp&lt;InputWindowHandle&gt; &gt; windowHandles; if (windowHandleObjArray) &#123; jsize length = env-&gt;GetArrayLength(windowHandleObjArray); for (jsize i = 0; i &lt; length; i++) &#123; jobject windowHandleObj = env-&gt;GetObjectArrayElement(windowHandleObjArray, i); ...... sp&lt;InputWindowHandle&gt; windowHandle = android_server_InputWindowHandle_getHandle(env, windowHandleObj); if (windowHandle != NULL) &#123; windowHandles.push(windowHandle); &#125; env-&gt;DeleteLocalRef(windowHandleObj); &#125; &#125; mInputManager-&gt;getDispatcher()-&gt;setInputWindows(windowHandles); // Do this after the dispatcher has updated the window handle state. bool newPointerGesturesEnabled = true; size_t numWindows = windowHandles.size(); for (size_t i = 0; i &lt; numWindows; i++) &#123; const sp&lt;InputWindowHandle&gt;&amp; windowHandle = windowHandles.itemAt(i); const InputWindowInfo* windowInfo = windowHandle-&gt;getInfo(); if (windowInfo &amp;&amp; windowInfo-&gt;hasFocus &amp;&amp; (windowInfo-&gt;inputFeatures &amp; InputWindowInfo::INPUT_FEATURE_DISABLE_TOUCH_PAD_GESTURES)) &#123; newPointerGesturesEnabled = false; &#125; &#125;&#125; è¿™ä¸ªå‡½æ•°é¦–å…ˆå°†Javaå±‚çš„InputWindowHandleè½¬æ¢æˆC++å±‚çš„NativeInputWindowHandleï¼Œç„¶åæ”¾åœ¨windowHandleså‘é‡ä¸­ï¼Œæœ€åå°†è¿™äº›è¾“å…¥çª—å£è®¾ç½®åˆ°InputDispatcherä¸­å»ã€‚ Step 7ã€InputDispatcher.setInputWindows()123456789101112131415161718192021222324252627282930[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]void InputDispatcher::setInputWindows(const Vector&lt;sp&lt;InputWindowHandle&gt; &gt;&amp; inputWindowHandles) &#123; &#123; // acquire lock AutoMutex _l(mLock); Vector&lt;sp&lt;InputWindowHandle&gt; &gt; oldWindowHandles = mWindowHandles; mWindowHandles = inputWindowHandles; sp&lt;InputWindowHandle&gt; newFocusedWindowHandle; bool foundHoveredWindow = false; for (size_t i = 0; i &lt; mWindowHandles.size(); i++) &#123; const sp&lt;InputWindowHandle&gt;&amp; windowHandle = mWindowHandles.itemAt(i); if (!windowHandle-&gt;updateInfo() || windowHandle-&gt;getInputChannel() == NULL) &#123; mWindowHandles.removeAt(i--); continue; &#125; if (windowHandle-&gt;getInfo()-&gt;hasFocus) &#123; newFocusedWindowHandle = windowHandle; &#125; &#125; if (mFocusedWindowHandle != newFocusedWindowHandle) &#123; mFocusedWindowHandle = newFocusedWindowHandle; &#125; &#125; // release lock // Wake up poll loop since it may need to make new input dispatching choices. mLooper-&gt;wake();&#125; è¿™é‡ŒInputDispatcherçš„æˆå‘˜å˜é‡mFocusedWindowHandle å°±ä»£è¡¨å½“å‰æ¿€æ´»çš„çª—å£çš„ã€‚è¿™ä¸ªå‡½æ•°éå†inputWindowHandlesï¼Œè·å–è·å¾—ç„¦ç‚¹çš„çª—å£ï¼Œå¹¶èµ‹å€¼ç»™mFocusedWindowHandle è¿™æ ·ï¼ŒInputManagerServiceå°±æŠŠå½“å‰æ¿€æ´»çš„çª—å£ä¿å­˜åœ¨InputDispatcherä¸­äº†ï¼Œåé¢å°±å¯ä»¥æŠŠé”®ç›˜æ¶ˆæ¯åˆ†å‘ç»™å®ƒæ¥å¤„ç†ã€‚ Step 8ã€mWindowSession.addToDisplay()123456789101112if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; try &#123; res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; catch (Exception e) &#123; ... &#125; è¿™é‡Œä¼šè°ƒç”¨åˆ°WindowManagerServiceçš„addWindowæ¥å£ 1234567891011121314frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.javapublic int addWindow(Session session, IWindow client, int seq,WindowManager.LayoutParams attrs, int viewVisibility, int displayId,Rect outContentInsets, Rect outStableInsets, Rect outOutsets,InputChannel outInputChannel) &#123; ...... final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125; ...... &#125; æ¥ç€ä¼šè°ƒç”¨WindowStateçš„ openInputChannel()æ–¹æ³•ã€‚ 123456789101112131415161718192021frameworks/base/services/core/java/com/android/server/wm/WindowState.java void openInputChannel(InputChannel outInputChannel) &#123; String name = makeInputChannelName(); InputChannel[] inputChannels = InputChannel.openInputChannelPair(name); mInputChannel = inputChannels[0]; mClientChannel = inputChannels[1]; mInputWindowHandle.inputChannel = inputChannels[0]; if (outInputChannel != null) &#123; mClientChannel.transferTo(outInputChannel); mClientChannel.dispose(); mClientChannel = null; &#125; else &#123; // If the window died visible, we setup a dummy input channel, so that taps // can still detected by input monitor channel, and we can relaunch the app. // Create dummy event receiver that simply reports all events as handled. mDeadWindowEventReceiver = new DeadWindowEventReceiver(mClientChannel); &#125; mService.mInputManager.registerInputChannel(mInputChannel, mInputWindowHandle);&#125; è¿™é‡Œçš„outInputChannelå³ä¸ºå‰é¢åˆ›å»ºçš„InputChannelï¼Œå®ƒä¸ä¸ºNULLï¼Œå› æ­¤ï¼Œè¿™é‡Œä¼šé€šè¿‡InputChannel.openInputChannelPairå‡½æ•°æ¥åˆ›å»ºä¸€å¯¹è¾“å…¥é€šé“ï¼Œå…¶ä¸­ä¸€ä¸ªä½äºWindowManagerServiceä¸­ï¼Œå¦å¤–ä¸€ä¸ªé€šè¿‡outInputChannelå‚æ•°è¿”å›åˆ°åº”ç”¨ç¨‹åºä¸­ã€‚ WindowManagerServiceä¼šä¸ºæ¯ä¸ªçª—å£åˆ›å»ºä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œç„¶åå°†è¯¥InputChannelå¯¹çš„serviceç«¯ä¿å­˜åˆ°WindowStateä¸­ Step 10ã€InputChannel.openInputChannelPair()12345[-&gt;frameworks/base/core/java/android/view/InputChannel.java]public static InputChannel[] openInputChannelPair(String name) &#123; return nativeOpenInputChannelPair(name);&#125; è°ƒç”¨äº†nativeOpenInputChannelPairå‡½æ•°ï¼Œåœ¨nativeåˆ›å»ºä¸€ä¸ªInputChannelå¯¹ Step 11ã€InputChannel.nativeOpenInputChannelPair()1234567891011121314[-&gt;frameworks/base/core/jni/android_view_InputChannel.cpp]static jobjectArray android_view_InputChannel_nativeOpenInputChannelPair(JNIEnv* env, jclass clazz, jstring nameObj) &#123; const char* nameChars = env-&gt;GetStringUTFChars(nameObj, NULL); String8 name(nameChars); env-&gt;ReleaseStringUTFChars(nameObj, nameChars); sp&lt;InputChannel&gt; serverChannel; sp&lt;InputChannel&gt; clientChannel; status_t result = InputChannel::openInputChannelPair(name, serverChannel, clientChannel); ... return channelPair;&#125; nativeOpenInputChannelPairå‡½æ•°è°ƒç”¨InputChannelçš„openInputChannelPairå‡½æ•°åˆ›å»ºä¸€å¯¹InputChannel,è¯¥å¯¹è±¡æ˜¯Nativeå±‚çš„InputChannel,è·Ÿjavaå±‚æ˜¯ä¸€ä¸€å¯¹åº”çš„ã€‚ Step 12ã€InputChannel.openInputChannelPair()123456789101112131415161718192021222324252627282930[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputChannel::openInputChannelPair(const String8&amp; name, sp&lt;InputChannel&gt;&amp; outServerChannel, sp&lt;InputChannel&gt;&amp; outClientChannel) &#123; int sockets[2]; if (socketpair(AF_UNIX, SOCK_SEQPACKET, 0, sockets)) &#123; status_t result = -errno; ALOGE(\"channel '%s' ~ Could not create socket pair. errno=%d\", name.string(), errno); outServerChannel.clear(); outClientChannel.clear(); return result; &#125; int bufferSize = SOCKET_BUFFER_SIZE; //è®¾ç½®serverç«¯å’Œclientç«¯çš„æ¥æ”¶ç¼“å†²åŒºå’Œå‘é€ç¼“å†²åŒº setsockopt(sockets[0], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[0], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_SNDBUF, &amp;bufferSize, sizeof(bufferSize)); setsockopt(sockets[1], SOL_SOCKET, SO_RCVBUF, &amp;bufferSize, sizeof(bufferSize)); String8 serverChannelName = name; serverChannelName.append(\" (server)\"); outServerChannel = new InputChannel(serverChannelName, sockets[0]); String8 clientChannelName = name; clientChannelName.append(\" (client)\"); outClientChannel = new InputChannel(clientChannelName, sockets[1]); return OK;&#125; è¿™é‡Œè°ƒç”¨äº†socketpairç³»ç»Ÿè°ƒç”¨åˆ›å»ºäº†ä¸€å¯¹å·²ç»è¿æ¥çš„UNIXç§Ÿsocket,è¿™é‡Œå¯ä»¥æŠŠè¿™ä¸€å¯¹socketå½“æˆpipeè¿”å›çš„æ–‡ä»¶æè¿°ç¬¦ä¸€æ ·ä½¿ç”¨ï¼Œpipeè¿”å›çš„ç®¡é“æ˜¯å•å‘ç®¡é“ï¼Œå³åªèƒ½ä»ä¸€ç«¯å†™å…¥ï¼Œä¸€ç«¯è¯»å‡ºï¼Œä½†æ˜¯socketpairæ˜¯åˆ›å»ºçš„ç®¡é“æ˜¯å…¨åŒå·¥çš„ï¼Œå¯è¯»å¯å†™ã€‚ åˆ›å»ºå¥½äº†serverç«¯å’Œclientç«¯socketpairé€šé“åï¼Œåœ¨WindowState.openInputChannel()æ–¹æ³•ä¸­ï¼Œä¸€æ–¹é¢å®ƒæŠŠåˆšæ‰åˆ›å»ºçš„Clientç«¯çš„è¾“å…¥é€šé“é€šè¿‡outInputChannelå‚æ•°è¿”å›åˆ°åº”ç”¨ç¨‹åºä¸­ï¼š 1inputChannels[1].transferTo(outInputChannel); WindowSession.addToDisplay()é€šè¿‡Binderé€šä¿¡ä¸WMSé€šä¿¡ã€‚IWindowSession.javaä¸ºç¼–è¯‘Android 7.1.2æºç å¾—åˆ°ã€‚ åœ¨æ­¤çœ‹ä¸€ä¸‹é€šä¿¡è¯¦ç»†è¿‡ç¨‹,å¯ä»¥çœ‹åˆ°outInputChannelé€šè¿‡_arg8.writeToParcel()å†™å…¥ï¼Œç„¶åé€šè¿‡è·¨è¿›ç¨‹æ–¹å¼ä¼ è¾“ï¼ŒAppç«¯å°±å¯ä»¥å¾—åˆ°Clientç«¯çš„InputChannel äº†ã€‚ [-&gt;IWindowSession.java$ Stub] 12345678910111213141516 case TRANSACTION_addToDisplay:&#123;......android.view.InputChannel _arg8;_arg8 = new android.view.InputChannel();int _result = this.addToDisplay(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8);reply.writeNoException();reply.writeInt(_result);......if ((_arg8!=null)) &#123;reply.writeInt(1);_arg8.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE);&#125;......return true;&#125; [-&gt;IWindowSession.java$ Proxy] 123456789101112131415//android/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/view/IWindowSession.java@Override public int addToDisplay(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int viewVisibility, int layerStackId, android.graphics.Rect outContentInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.view.InputChannel outInputChannel) throws android.os.RemoteException&#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();......mRemote.transact(Stub.TRANSACTION_addToDisplay, _data, _reply, 0);_result = _reply.readInt();....if ((0!=_reply.readInt())) &#123;outInputChannel.readFromParcel(_reply);&#125;return _result;&#125; å¦å¤–è¿˜éœ€è¦æŠŠserverç«¯çš„InputChannelæ³¨å†Œåˆ°InputManagerServiceä¸­ï¼š 1mInputManager.registerInputChannel(win.mInputChannel, win.mInputWindowHandle); Step 13ã€InputManagerService.registerInputChannel()123456[-&gt;frameworks/base/services/core/java/com/android/server/input/InputManagerService.java]public void registerInputChannel(InputChannel inputChannel, InputWindowHandle inputWindowHandle) &#123; nativeRegisterInputChannel(mPtr, inputChannel, inputWindowHandle, false); &#125; é€šè¿‡è°ƒç”¨nativeRegisterInputChannelæ¥å°†InputChannelæ³¨å†Œåˆ°nativeå±‚ Step 14ã€InputManagerService.nativeRegisterInputChannel()123456789101112131415[-&gt;frameworks/base/services/core/jni/com_android_server_input_InputManagerService.cpp]static void nativeRegisterInputChannel(JNIEnv* env, jclass /* clazz */, jlong ptr, jobject inputChannelObj, jobject inputWindowHandleObj, jboolean monitor) &#123; NativeInputManager* im = reinterpret_cast&lt;NativeInputManager*&gt;(ptr); sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); sp&lt;InputWindowHandle&gt; inputWindowHandle = android_server_InputWindowHandle_getHandle(env, inputWindowHandleObj); status_t status = im-&gt;registerInputChannel( env, inputChannel, inputWindowHandle, monitor);&#125; æ ¹æ®javaå±‚çš„InputWindowHandleè·å¾—nativeå±‚çš„InputWindowHandleå¯¹è±¡ï¼Œæ ¹æ®javaå±‚çš„InputChannelè·å¾—nativeå±‚çš„InputChannelå¯¹è±¡ï¼Œç„¶åè°ƒç”¨NativeInputManagerçš„resgiterInputChannelï¼Œè¯¥å‡½æ•°åˆè°ƒç”¨äº†InputDispatcherçš„registerInputChannel Step 15ã€InputDispatcher.registerInputChannel()1234567891011121314151617181920212223[-&gt;frameworks/native/services/inputflinger/InputDispatcher.cpp]status_t InputDispatcher::registerInputChannel(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) &#123; &#123; // acquire lock AutoMutex _l(mLock); sp&lt;Connection&gt; connection = new Connection(inputChannel, inputWindowHandle, monitor); int fd = inputChannel-&gt;getFd(); mConnectionsByFd.add(fd, connection); if (monitor) &#123; mMonitoringChannels.push(inputChannel); &#125; mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); &#125; // release lock // Wake the looper because some connections have changed. mLooper-&gt;wake(); return OK;&#125; åˆ›å»ºConnectionï¼Œå¯ä»¥çœ‹åˆ°ç”¨inputChannelåˆå§‹åŒ–äº†inputPublisher(inputChannel)ï¼Œè¿™å°±æ˜¯ä¹‹å‰Input dispatcherå°èŠ‚ Step 8. InputPublisher.publishKeyEvent()æ–¹æ³•ä¸­çš„é‚£ä¸ªmChannelã€‚ 1234567// --- InputDispatcher::Connection ---InputDispatcher::Connection::Connection(const sp&lt;InputChannel&gt;&amp; inputChannel, const sp&lt;InputWindowHandle&gt;&amp; inputWindowHandle, bool monitor) : status(STATUS_NORMAL), inputChannel(inputChannel), inputWindowHandle(inputWindowHandle), monitor(monitor), inputPublisher(inputChannel), inputPublisherBlocked(false) &#123; &#125; å°†InputWindowHandle, InputChanelå°è£…æˆConnectionå¯¹è±¡ï¼Œç„¶åfdä½œä¸ºkeyï¼ŒConnectionä½œä¸ºValueï¼Œä¿å­˜åœ¨mConnectionsByFdä¸­ï¼Œå¦‚æœä¼ å…¥çš„monitoræ˜¯trueï¼Œåˆ™éœ€è¦å°†InputChannelæ”¾åˆ°mMonitoringChannelsä¸­,ä»ä¸Šé¢çš„InputManagerServiceçš„registerInputChannelå‡½æ•°é‡Œä¼ å…¥çš„monitoræ˜¯falseï¼Œæ‰€ä»¥è¿™é‡Œä¸åŠ å…¥åˆ°mMonitoringChannelsã€‚åŒæ—¶æŠŠfdåŠ å…¥åˆ°mLooperçš„ç›‘å¬ä¸­ï¼Œå¹¶æŒ‡å®šå½“è¯¥fdæœ‰å†…å®¹å¯è¯»æ—¶ï¼ŒLooperå°±ä¼šè°ƒç”¨handleReceiveCallbackå‡½æ•°ã€‚è‡³æ­¤serverç«¯çš„InputChannelæ³¨å†Œå®Œæˆï¼ŒInputDispatcherç¡çœ åœ¨ç›‘å¬çš„fdsä¸Šï¼Œå½“æœ‰æŒ‰é”®äº‹ä»¶å‘ç”Ÿæ—¶ï¼ŒInputDispatcherå°±ä¼šå¾€è¿™äº›fdå†™å…¥InputMessageå¯¹è±¡ï¼Œè¿›è€Œå›è°ƒhandleReceiveCallbackå‡½æ•°ã€‚ è‡³æ­¤ï¼Œserverç«¯çš„InputChannelå°±æ³¨å†Œå®Œæˆäº†ï¼Œå†å›åˆ°å‰é¢çš„WindowManagerService.addWindowä¸Šçš„ç¬¬äºŒæ­¥inputChannels[1].transferTo(outInputChannel);ï¼Œè¿™ä¸ªæ˜¯å°†åˆ›å»ºçš„ä¸€å¯¹InputChannelçš„clientç«¯å¤åˆ¶åˆ°ä¼ å…¥çš„å‚æ•°InputChannelä¸Šï¼Œå½“addWindowè¿”å›æ—¶ï¼Œå°±å›åˆ°ViewRootImpl.setView()æ–¹æ³•ä¸­ï¼Œæ‰§è¡Œåº”ç”¨ç¨‹åºè¿™ä¸€ä¾§çš„é”®ç›˜æ¶ˆæ¯æ¥æ”¶é€šé“ã€‚ 1234if (mInputChannel != null) &#123; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper());&#125; WindowInputEventReceiverç»§æ‰¿è‡ªInputEventReceiverç±»ã€‚ Step 16ã€InputEventReceiver()1234567891011[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]public InputEventReceiver(InputChannel inputChannel, Looper looper) &#123; mInputChannel = inputChannel; mMessageQueue = looper.getQueue(); mReceiverPtr = nativeInit(new WeakReference&lt;InputEventReceiver&gt;(this), inputChannel, mMessageQueue); mCloseGuard.open(\"dispose\");&#125; è°ƒç”¨äº†nativeInitæ‰§è¡Œnativeå±‚çš„åˆå§‹åŒ– Step 17.ã€InputEventReceiver.nativeInit()12345678910111213141516[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]static jlong nativeInit(JNIEnv* env, jclass clazz, jobject receiverWeak, jobject inputChannelObj, jobject messageQueueObj) &#123; sp&lt;InputChannel&gt; inputChannel = android_view_InputChannel_getInputChannel(env, inputChannelObj); sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj); sp&lt;NativeInputEventReceiver&gt; receiver = new NativeInputEventReceiver(env, receiverWeak, inputChannel, messageQueue); status_t status = receiver-&gt;initialize(); receiver-&gt;incStrong(gInputEventReceiverClassInfo.clazz); // retain a reference for the object return reinterpret_cast&lt;jlong&gt;(receiver.get());&#125; å‡½æ•°åˆ›å»ºäº†ä¸€ä¸ªNativeInputEventReceiverå¯¹è±¡ï¼Œå¹¶è°ƒç”¨å…¶initializeå‡½æ•° Step 18.ã€NativeInputEventReceiver.initialize()123456[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]status_t NativeInputEventReceiver::initialize() &#123; setFdEvents(ALOOPER_EVENT_INPUT); return OK;&#125; è°ƒç”¨setFdEventså‡½æ•° Step 19ã€NativeInputEventReceiver.setFdEvents()12345678910111213frameworks/base/core/jni/android_view_InputEventReceiver.cppvoid NativeInputEventReceiver::setFdEvents(int events) &#123; if (mFdEvents != events) &#123; mFdEvents = events; int fd = mInputConsumer.getChannel()-&gt;getFd(); if (events) &#123; mMessageQueue-&gt;getLooper()-&gt;addFd(fd, 0, events, this, NULL); &#125; else &#123; mMessageQueue-&gt;getLooper()-&gt;removeFd(fd); &#125; &#125;&#125; è¿™é‡Œè°ƒç”¨ä¼ å…¥çš„MessageQueueè·å–Looperå¯¹è±¡ï¼Œå¦‚æœeventsæ˜¯0ï¼Œåˆ™è¡¨ç¤ºè¦ç§»é™¤ç›‘å¬fdï¼Œå¦‚æœeventsä¸ä¸º0ï¼Œè¡¨ç¤ºè¦ç›‘å¬fdï¼Œè¿™ä¸ªfdæ˜¯å‰é¢WindowManagerServiceåˆ›å»ºçš„ä¸€å¯¹InputChannelçš„clientç«¯ï¼Œè¿™æ ·å½“Serverç«¯å†™å…¥äº‹ä»¶æ—¶ï¼Œclientç«¯çš„looperå°±èƒ½è¢«å”¤é†’ï¼Œå¹¶è°ƒç”¨handleEventå‡½æ•°ï¼ˆLooper::addFdå‡½æ•°å¯ä»¥æŒ‡å®šLooperCallbackå¯¹è±¡ï¼Œå½“fdå¯è¯»æ—¶ï¼Œä¼šè°ƒç”¨LooperCallbackçš„handleEventï¼Œè€ŒNativeInputEventReceiverç»§æ‰¿è‡ªLooperCallbackï¼Œæ‰€ä»¥è¿™é‡Œä¼šè°ƒç”¨NativeInputEventReceiverçš„handleEventå‡½æ•°ï¼‰ è´´ä¸Šäº‹ä»¶å¤„ç†åºåˆ—å›¾ã€‚ Step 20ã€NativeInputEventReceiver.handleEvent()12345678910[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]int NativeInputEventReceiver::handleEvent(int receiveFd, int events, void* data) &#123; if (events &amp; ALOOPER_EVENT_INPUT) &#123; JNIEnv* env = AndroidRuntime::getJNIEnv(); status_t status = consumeEvents(env, false /*consumeBatches*/, -1, NULL); mMessageQueue-&gt;raiseAndClearException(env, \"handleReceiveCallback\"); return status == OK || status == NO_MEMORY ? 1 : 0; &#125;&#125; è¯¥å‡½æ•°è°ƒç”¨consumeEventså‡½æ•°æ¥å¤„ç†æ¥æ”¶ä¸€ä¸ªæŒ‰é”®äº‹ä»¶ Step 21ã€NativeInputEventReceiver.consumeEvents()12345678910111213141516171819202122232425262728293031323334[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]status_t NativeInputEventReceiver::consumeEvents(JNIEnv* env, bool consumeBatches, nsecs_t frameTime, bool* outConsumedBatch) &#123; ...... ScopedLocalRef&lt;jobject&gt; receiverObj(env, NULL); bool skipCallbacks = false; for (;;) &#123; uint32_t seq; InputEvent* inputEvent; // å¤„ç†æ¥æ”¶ä¸€ä¸ªæŒ‰é”®äº‹ä»¶ status_t status = mInputConsumer.consume(&amp;mInputEventFactory, consumeBatches, frameTime, &amp;seq, &amp;inputEvent); if (!skipCallbacks) &#123; jobject inputEventObj; switch (inputEvent-&gt;getType()) &#123; case AINPUT_EVENT_TYPE_KEY: inputEventObj = android_view_KeyEvent_fromNative(env, static_cast&lt;KeyEvent*&gt;(inputEvent)); break; &#125; if (inputEventObj) &#123; env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); env-&gt;DeleteLocalRef(inputEventObj); &#125; &#125; if (skipCallbacks) &#123; mInputConsumer.sendFinishedSignal(seq, false); &#125; &#125;&#125; å‡½æ•°é¦–å…ˆè°ƒç”¨mInputConsumer.consumeæ¥æ”¶ä¸€ä¸ªInputEventå¯¹è±¡,mInputConsumeråœ¨NativeInputEventReceiveræ„é€ å‡½æ•°ä¸­åˆå§‹åŒ– Step 22ã€InputConsumer.consume()12345678910111213141516171819202122232425262728293031323334353637383940414243[-&gt;frameworks/native/libs/input/InputTransport.cpp]status_t InputConsumer::consume(InputEventFactoryInterface* factory, bool consumeBatches, nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) &#123; *outSeq = 0; *outEvent = NULL; // Fetch the next input message. // Loop until an event can be returned or no additional events are received. while (!*outEvent) &#123; if (mMsgDeferred) &#123; // mMsg contains a valid input message from the previous call to consume // that has not yet been processed. mMsgDeferred = false; &#125; else &#123; // Receive a fresh message. status_t result = mChannel-&gt;receiveMessage(&amp;mMsg); if (result) &#123; // Consume the next batched event unless batches are being held for later. if (consumeBatches || result != WOULD_BLOCK) &#123; result = consumeBatch(factory, frameTime, outSeq, outEvent); if (*outEvent) &#123; break; &#125; &#125; return result; &#125; &#125; switch (mMsg.header.type) &#123; case InputMessage::TYPE_KEY: &#123; KeyEvent* keyEvent = factory-&gt;createKeyEvent(); if (!keyEvent) return NO_MEMORY; initializeKeyEvent(keyEvent, &amp;mMsg); *outSeq = mMsg.body.key.seq; *outEvent = keyEvent; break; &#125; &#125; return OK;&#125; å‡½æ•°é¦–å…ˆè°ƒç”¨InputChannelçš„receiveMessageå‡½æ•°æ¥æ”¶InputMessageå¯¹è±¡ï¼Œç„¶åæ ¹æ®InputMessageå¯¹è±¡è°ƒç”¨initializeKeyEventæ¥æ„é€ KeyEventå¯¹è±¡ã€‚æ‹¿åˆ°å¯KeyEventå¯¹è±¡åï¼Œå†å¯¹åˆ°consumeEventsä¸­è°ƒç”¨javaå±‚çš„InputEventReceiver.javaçš„dispatchInputEventå‡½æ•° 12env-&gt;CallVoidMethod(receiverObj.get(), gInputEventReceiverClassInfo.dispatchInputEvent, seq, inputEventObj); Step 23ã€InputEventReceiver.dispatchInputEvent()12345678[-&gt;frameworks/base/core/java/android/view/InputEventReceiver.java]// Called from native code.SuppressWarnings(\"unused\")private void dispatchInputEvent(int seq, InputEvent event) &#123; mSeqMap.put(event.getSequenceNumber(), seq); onInputEvent(event);&#125; è¿›è€Œè°ƒç”¨onInputEventå‡½æ•°ã€‚è‡³æ­¤æŒ‰é”®å°±å¼€å§‹äº†javaå±‚çš„åˆ†å‘(ä¸‹ä¸€èŠ‚è¯¦ç»†ä»‹ç»)ã€‚ å›åˆ°ä¸»çº¿ï¼Œæ•…äº‹æ¥æ²¡è®²å®Œã€‚å½“Appè¿™ç«¯å¤„ç†å®Œè¾“å…¥äº‹ä»¶è°ƒç”¨ViewRootImpl.finishInputEvent() 12345678910 [-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java] private void finishInputEvent(QueuedInputEvent q) &#123; ...... if (q.mReceiver != null) &#123; boolean handled = (q.mFlags &amp; QueuedInputEvent.FLAG_FINISHED_HANDLED) != 0; q.mReceiver.finishInputEvent(q.mEvent, handled); &#125;...... recycleQueuedInputEvent(q);&#125; Javaå±‚InputEventReceiver.nativeFinishInputEvent() é€šè¿‡JNI è°ƒç”¨android_view_InputEventReceiver.finishInputEvent() 12345678[-&gt;frameworks/base/core/jni/android_view_InputEventReceiver.cpp]status_t NativeInputEventReceiver::finishInputEvent(uint32_t seq, bool handled) &#123; if (kDebugDispatchCycle) &#123; ALOGD(\"channel '%s' ~ Finished input event.\", getInputChannelName()); &#125; status_t status = mInputConsumer.sendFinishedSignal(seq, handled); &#125; å±‚å±‚è·³è½¬æœ€åä¼šè°ƒç”¨åˆ°InputConsumer.sendUnchainedFinishedSignal()å‘é€ä¸€ä¸ªInputMessage::TYPE_FINISHEDæ¶ˆæ¯ã€‚ 123456789[-&gt;/frameworks/native/libs/input/InputTransport.cpp]status_t InputConsumer::sendUnchainedFinishedSignal(uint32_t seq, bool handled) &#123;InputMessage msg;msg.header.type = InputMessage::TYPE_FINISHED;msg.body.finished.seq = seq;msg.body.finished.handled = handled;return mChannel-&gt;sendMessage(&amp;msg);&#125; åœ¨InputDispatcher.registerInputChannel()ä¸­æ·»åŠ äº†ä¸€ä¸ª handleReceiveCallbackå›è°ƒã€‚ 1mLooper-&gt;addFd(fd, 0, ALOOPER_EVENT_INPUT, handleReceiveCallback, this); ç„¶åé€šè¿‡å’ŒIMSä¸­InputDispacherçš„é€šä¿¡ç®¡é“InputChannelå‘äº†å¤„ç†å®Œæˆé€šçŸ¥ã€‚é‚£InputDispatcherè¿™è¾¹æ”¶åˆ°åå¦‚ä½•å¤„ç†å‘¢ï¼Ÿ ç”±å‰é¢åˆ†æ InputDispatcherä¼šè°ƒç”¨handleReceiveCallback()æ¥å¤„ç†TYPE_FINISHEDä¿¡å·ã€‚è¿™é‡Œå…ˆæ˜¯å¾€Commandé˜Ÿåˆ—é‡Œæ”¾ä¸€ä¸ªå¤„ç†äº‹åŠ¡æ‰§è¡ŒdoDispatchCycleFinishedLockedInterruptible()ï¼Œåé¢åœ¨runCommandsLockedInterruptible()ä¸­ä¼šå–å‡ºæ‰§è¡Œã€‚åœ¨doDispatchCycleFinishedLockedInterruptible()å‡½æ•°ä¸­ï¼Œä¼šå…ˆè°ƒç”¨afterKeyEventLockedInterruptible()ã€‚Androidä¸­å¯ä»¥å®šä¹‰ä¸€äº›Fallbacké”®ï¼Œå³å¦‚æœä¸€ä¸ªKeyäº‹ä»¶Appæ²¡æœ‰å¤„ç†ï¼Œå¯ä»¥Fallbackæˆå¦å¤–é»˜è®¤çš„Keyäº‹ä»¶ï¼Œè¿™æ˜¯åœ¨è¿™é‡Œçš„dispatchUnhandledKey()å‡½æ•°ä¸­è¿›è¡Œå¤„ç†çš„ã€‚æ¥ç€InputDispatcherä¼šå°†è¯¥æ”¶åˆ°å®Œæˆä¿¡å·çš„äº‹ä»¶é¡¹ä»ç­‰å¾…é˜Ÿåˆ—ä¸­ç§»é™¤ã€‚åŒæ—¶ç”±äºä¸Šä¸€ä¸ªäº‹ä»¶å·²è¢«Appå¤„ç†å®Œï¼Œå°±å¯ä»¥è°ƒç”¨startDispatchCycleLocked()æ¥è¿›è¡Œä¸‹ä¸€è½®äº‹ä»¶çš„å¤„ç†äº†ã€‚ 12345678[-&gt;/frameworks/native/services/inputflinger/InputDispatcher.cpp]if (dispatchEntry == connection-&gt;findWaitQueueEntry(seq)) &#123; connection-&gt;waitQueue.dequeue(dispatchEntry); ... &#125; // Start the next dispatch cycle for this connection. startDispatchCycleLocked(now(), connection); startDispatchCycleLockedå‡½æ•°ä¼šæ£€æŸ¥ç›¸åº”è¿æ¥çš„è¾“å‡ºç¼“å†²ä¸­(connection-&gt;outboundQueue)æ˜¯å¦æœ‰äº‹ä»¶è¦å‘é€çš„ï¼Œæœ‰çš„è¯ä¼šé€šè¿‡InputChannelå‘é€å‡ºå»ã€‚ æ€»ç»“ï¼š 8ã€Android Inputå­ç³»ç»Ÿä¹‹javaå±‚æŒ‰é”®ä¼ é€’Androidå¼€å‘ä¸­åœ¨è‡ªå®šä¹‰Activityä»¥åŠViewæ—¶ç»å¸¸ä¼šé‡å†™onKeyDown,onKeyUp,dispatchKeyEventï¼ŒåŒæ—¶Viewè¿˜æœ‰setOnKeyListenerç­‰ï¼Œå½“ä¸€ä¸ªæŒ‰é”®äº‹ä»¶å‘ç”Ÿæ—¶ï¼Œè¿™äº›æ–¹æ³•å°†ä¼šè¢«å›è°ƒï¼Œä½†æ˜¯åˆ°åº•å“ªä¸ªå…ˆå›è°ƒï¼Œå“ªä¸ªåå›è°ƒå‘¢ï¼Œä¸€ç›´ä¸æ˜¯ç‰¹åˆ«æ¸…æ¥šï¼ŒåªçŸ¥é“ä¸ªå¤§æ¦‚ï¼Œä¸‹é¢å°†è¯¦ç»†è®²è¿°æŒ‰é”®åœ¨javaå±‚çš„åˆ†å‘è¿‡ç¨‹ï¼Œå…¶ä¸­é‡ç‚¹å…³æ³¨æŒ‰é”®äº‹ä»¶åœ¨Viewå±‚æ¬¡ä¸­çš„åˆ†å‘ javaå±‚çš„æŒ‰é”®åˆ†å‘ä»ViewRootImpl.javaçš„WindowInputEventReceiverä¸­çš„onInputEventå¼€å§‹ï¼Œä»å‰é¢çš„åº”ç”¨ç¨‹åºæ³¨å†Œæ¶ˆæ¯ç›‘å¬è¿‡ç¨‹åˆ†æå’ŒInput Dispatcheråˆ†æï¼ŒInputDispatcheråœ¨å¤„ç†æŒ‰é”®äº‹ä»¶æ—¶ï¼Œä¼šé€šè¿‡InputChannel::sendMessageå‡½æ•°å°†æŒ‰é”®æ¶ˆæ¯ä»serverç«¯å†™å…¥ï¼Œè¿™é‡Œçš„InputChannelæ˜¯å½“å‰è·å–ç„¦ç‚¹çš„çª—å£çš„InputChannelå¯¹çš„serverç«¯ï¼Œè¿™æ ·åº”ç”¨ç¨‹åºç«¯å°±å¯ä»¥æ”¶åˆ°è¯¥æ¶ˆæ¯ï¼Œç„¶åè°ƒç”¨NativeInputEventReceiverçš„handleEvent,æœ€åè°ƒç”¨åˆ°InputEventReceiverçš„onInputEventå‡½æ•°ï¼ˆå…·ä½“çš„å¯ä»¥çœ‹åº”ç”¨ç¨‹åºæ³¨å†Œæ¶ˆæ¯ç›‘å¬è¿‡ç¨‹åˆ†æ çš„Step20-Step23ï¼‰ åºåˆ—å›¾ï¼š Step 1ã€WindowInputEventReceiver.onInputEvent()12345678910111213[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]final class WindowInputEventReceiver extends InputEventReceiver &#123; public WindowInputEventReceiver(InputChannel inputChannel, Looper looper) &#123; super(inputChannel, looper); &#125; @Override public void onInputEvent(InputEvent event) &#123; enqueueInputEvent(event, this, 0, true); &#125; ...&#125; è¿™é‡Œåªåˆ—å‡ºéƒ¨åˆ†ä»£ç ï¼Œå½“ä¸€ä¸ªæŒ‰é”®æŒ‰ä¸‹æ—¶onInputEventæ–¹æ³•å°±ä¼šè¢«å›è°ƒï¼Œå…¶ä¸­è°ƒç”¨äº†ViewRootImpl::enqueueInputEvent(event, this, 0, true); Step 2ã€ViewRootImpl.enqueueInputEvent()12345678910111213[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]void enqueueInputEvent(InputEvent event, InputEventReceiver receiver, int flags, boolean processImmediately) &#123; // ä»é˜Ÿåˆ—ä¸­è·å–ä¸€ä¸ªQueuedInputEventï¼Œè¿™é‡Œçš„flagsä¼ å…¥çš„æ˜¯0 QueuedInputEvent q = obtainQueuedInputEvent(event, receiver, flags); ... if (processImmediately) &#123; doProcessInputEvents();//è¿™é‡Œä¼ å…¥çš„processImmediatelyæ˜¯trueï¼Œæ‰€ä»¥è°ƒç”¨doProcessInputEvents &#125; else &#123; scheduleProcessInputEvents(); &#125;&#125; ä»å‰é¢çš„å‚æ•°å¯çŸ¥ï¼Œè¿™é‡Œè¡¨ç¤ºè¦ç«‹å³å¤„ç†ï¼Œæ‰€ä»¥è°ƒç”¨doProcessInputEventså‡½æ•°. Step 3ã€ViewRootImpl.doProcessInputEvents()1234567891011121314151617frameworks/base/core/java/android/view/ViewRootImpl.javavoid doProcessInputEvents() &#123; // Deliver all pending input events in the queue. while (mPendingInputEventHead != null) &#123; QueuedInputEvent q = mPendingInputEventHead; mPendingInputEventHead = q.mNext; if (mPendingInputEventHead == null) &#123; mPendingInputEventTail = null; &#125; q.mNext = null; mPendingInputEventCount -= 1; ... // åˆ†å‘æŒ‰é”®äº‹ä»¶ deliverInputEvent(q); &#125;&#125; åœ¨deliverInputEventå‡½æ•°ä¸­å®é™…åšæŒ‰é”®çš„åˆ†å‘ Step 4ã€ViewRootImpl.deliverInputEvent()1234567891011121314151617181920212223[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]private void deliverInputEvent(QueuedInputEvent q) &#123; Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, \"deliverInputEvent\", q.mEvent.getSequenceNumber()); if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onInputEvent(q.mEvent, 0); &#125; InputStage stage; if (q.shouldSendToSynthesizer()) &#123; stage = mSyntheticInputStage; &#125; else &#123; //é€‰æ‹©è´£ä»»é“¾çš„æ¨¡å¼çš„å…¥å£ï¼Œå¦‚æœInputEventéœ€è¦è·³è¿‡IMEå¤„ç†ï¼Œåˆ™ä»mFirstPostImeInputStageï¼ˆEarlyPostImeInputStageï¼‰å¼€å§‹,å¦åˆ™ä»mFirstInputStage(NativePreImeInputStage)å¼€å§‹åˆ†å‘ stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; &#125; if (stage != null) &#123; stage.deliver(q); &#125; else &#123; finishInputEvent(q); &#125;&#125; è¿™é‡Œè°ƒç”¨äº†InputStageçš„deliveræ–¹æ³•åˆ†å‘ï¼Œè¿™é‡Œçš„InputStageä»£è¡¨äº†è¾“å…¥äº‹ä»¶çš„å¤„ç†é˜¶æ®µï¼Œæ˜¯ä¸€ç§è´£ä»»é“¾æ¨¡å¼ InputStageå°†è¾“å…¥äº‹ä»¶çš„å¤„ç†åˆ†æˆè‹¥å¹²ä¸ªé˜¶æ®µï¼ˆStageï¼‰, å¦‚æœå½“å‰æœ‰è¾“å…¥æ³•çª—å£ï¼Œåˆ™äº‹ä»¶å¤„ç†ä» NativePreIme å¼€å§‹ï¼Œå¦åˆ™çš„è¯ï¼Œä»EarlyPostIme å¼€å§‹ã€‚äº‹ä»¶ä¼šä¾æ¬¡ç»è¿‡æ¯ä¸ªStageï¼Œå¦‚æœè¯¥äº‹ä»¶æ²¡æœ‰è¢«æ ‡è¯†ä¸º â€œFinishedâ€ï¼Œ è¯¥Stageå°±ä¼šå¤„ç†å®ƒï¼Œç„¶åè¿”å›å¤„ç†ç»“æœï¼ŒForward æˆ– Finishï¼Œ Forward è¿è¡Œä¸‹ä¸€Stageç»§ç»­å¤„ç†ï¼Œè€ŒFinishedäº‹ä»¶å°†ä¼šç®€å•çš„Forwardåˆ°ä¸‹ä¸€çº§ï¼Œç›´åˆ°æœ€åä¸€çº§ Synthetic InputStageã€‚æµç¨‹å›¾å’Œæ¯ä¸ªé˜¶æ®µå®Œæˆçš„äº‹æƒ…å¦‚ä¸‹å›¾æ‰€ç¤º è´£ä»»é“¾æ¨¡å¼ï¼š è´£ä»»é“¾æ¨¡å¼ï¼ˆChain of Responsibilityï¼‰çš„ç›®æ ‡æ˜¯ä½¿å¤šä¸ªå¯¹è±¡éƒ½æœ‰æœºä¼šå¤„ç†è¯·æ±‚ï¼Œä»è€Œé¿å…è¯·æ±‚çš„å‘é€è€…å’Œæ¥æ”¶è€…ä¹‹é—´çš„è€¦åˆå…³ç³»ã€‚å°†è¿™äº›å¯¹è±¡è¿æˆä¸€æ¡é“¾ï¼Œå¹¶æ²¿ç€è¿™æ¡é“¾ä¼ é€’è¯·æ±‚ï¼Œç›´åˆ°æœ‰ä¸€ä¸ªå¯¹è±¡å¤„ç†å®ƒä¸ºæ­¢ã€‚ æŒ‰é”®åˆ†å‘ï¼š åœ¨ViewRootImplçš„setViewå‡½æ•°ä¸­ä¼šæ„é€ ä¸€ä¸ªå¦‚å›¾æ‰€ç¤ºçš„InputStageçš„é“¾ï¼ŒæŒ‰é”®ä¼šä»å…¥å£é˜¶æ®µï¼Œè¿›å…¥è´£ä»»é“¾ï¼Œé¡ºåºå¤„ç†ï¼Œå…¥å£é˜¶æ®µæ ¹æ®QueuedInputEventçš„çŠ¶æ€æ¥å†³å®šã€‚q.shouldSendToSynthesizer() è¿™é‡Œä¸€èˆ¬æ˜¯falseï¼Œå› æ­¤ä¸»è¦çœ‹stage = q.shouldSkipIme() ? mFirstPostImeInputStage : mFirstInputStage; è¿™é‡Œçš„shouldSkipImeå…¶å®æ˜¯ä¸€ä¸ªflagåœ¨æ„é€ QueuedInputEventæ—¶ä¼ å…¥çš„ï¼Œä»å‰é¢çš„onInputEventè°ƒç”¨çš„enqueueInputEvent(event, this, 0, true);å¯çŸ¥ï¼Œè¿™é‡Œä¼ å…¥çš„flagsæ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°0ï¼Œé‚£è¿™é‡Œçš„shouldSkipImeå°±æ˜¯falseï¼Œé‚£ä¹ˆæŒ‰é”®ä¼šä»mFirstPostImeInputStage å¼€å§‹åˆ†å‘ï¼Œå°±æ˜¯å›¾ä¸­çš„NativePreImeInputStageåˆ†å‘ã€‚ ä¸‹é¢åªä»è·Ÿæœ¬æ–‡å‰é¢æåˆ°çš„Activityï¼ŒViewçš„æŒ‰é”®åˆ†å‘æµç¨‹ç›¸å…³çš„InputStageï¼ˆViewPostImeInputStageï¼‰å¼€å§‹åˆ†æ Step 5ã€ViewPostImeInputStage.processKeyEvent()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[-&gt;frameworks/base/core/java/android/view/ViewRootImpl.java]private int processKeyEvent(QueuedInputEvent q) &#123; final KeyEvent event = (KeyEvent)q.mEvent; ... // Deliver the key to the view hierarchy. // è°ƒç”¨æˆå‘˜å˜é‡mViewçš„dispatchKeyEventå‡½æ•°ï¼Œè¿™é‡ŒmViewæ˜¯PhoneWindow.DecorViewå¯¹è±¡ if (mView.dispatchKeyEvent(event)) &#123; return FINISH_HANDLED; &#125; ... // å¦‚æœæŒ‰é”®æ˜¯å››å‘é”®æˆ–è€…æ˜¯TABé”®ï¼Œåˆ™ç§»åŠ¨ç„¦ç‚¹ // Handle automatic focus changes. if (event.getAction() == KeyEvent.ACTION_DOWN) &#123; int direction = 0; switch (event.getKeyCode()) &#123; case KeyEvent.KEYCODE_DPAD_LEFT: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_LEFT; &#125; break; ...... case KeyEvent.KEYCODE_TAB: if (event.hasNoModifiers()) &#123; direction = View.FOCUS_FORWARD; &#125; else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) &#123; direction = View.FOCUS_BACKWARD; &#125; break; &#125; if (direction != 0) &#123; View focused = mView.findFocus(); if (focused != null) &#123; View v = focused.focusSearch(direction); if (v != null &amp;&amp; v != focused) &#123; ...... focused.getFocusedRect(mTempRect); if (mView instanceof ViewGroup) &#123; ((ViewGroup) mView).offsetDescendantRectToMyCoords( focused, mTempRect); ((ViewGroup) mView).offsetRectIntoDescendantCoords( v, mTempRect); &#125; if (v.requestFocus(direction, mTempRect)) &#123; playSoundEffect(SoundEffectConstants .getContantForFocusDirection(direction)); return FINISH_HANDLED; &#125; &#125; // Give the focused view a last chance to handle the dpad key. if (mView.dispatchUnhandledMove(focused, direction)) &#123; return FINISH_HANDLED; &#125; &#125; else &#123; // find the best view to give focus to in this non-touch-mode with no-focus View v = focusSearch(null, direction); if (v != null &amp;&amp; v.requestFocus(direction)) &#123; return FINISH_HANDLED; &#125; &#125; &#125; &#125; return FORWARD;&#125; ä¸Šè¿°ä¸»è¦åˆ†ä¸¤æ­¥ï¼š ç¬¬ä¸€æ­¥æ˜¯è°ƒç”¨PhoneWindow.DecorViewçš„dispatchKeyEventå‡½æ•°ï¼ŒDecorViewæ˜¯Viewå±‚æ¬¡ç»“æ„çš„æ ¹èŠ‚ç‚¹ï¼ŒæŒ‰é”®ä»æ ¹èŠ‚ç‚¹å¼€å§‹æ ¹æ®Focuse viewçš„pathè‡ªä¸Šè€Œä¸‹çš„åˆ†å‘ã€‚ ç¬¬äºŒæ­¥æ˜¯åˆ¤æ–­æŒ‰é”®æ˜¯å¦æ˜¯å››å‘é”®ï¼Œæˆ–è€…æ˜¯TABé”®ï¼Œå¦‚æœæ˜¯åˆ™éœ€è¦ç§»åŠ¨ç„¦ç‚¹ Step 6ã€mView.dispatchKeyEvent()1234567891011121314public boolean dispatchKeyEvent(KeyEvent event) &#123; ... if (!isDestroyed()) &#123; final Callback cb = getCallback(); final boolean handled = cb != null &amp;&amp; mFeatureId &lt; 0 ? cb.dispatchKeyEvent(event) : super.dispatchKeyEvent(event); if (handled) &#123; return true; &#125; &#125; return isDown ? PhoneWindow.this.onKeyDown(mFeatureId, event.getKeyCode(), event) : PhoneWindow.this.onKeyUp(mFeatureId, event.getKeyCode(), event);&#125; ä¸»è¦çš„åˆ†å‘åœ¨ä¸‹é¢å¼€å§‹ï¼Œå¦‚æœcbä¸ä¸ºç©ºå¹¶ä¸”mFeatureIdå°äº0ï¼Œåˆ™è°ƒç”¨cb.dispatchKeyEventå¼€å§‹åˆ†å‘ï¼Œå¦åˆ™ä¼šè°ƒç”¨DecorViewçš„çˆ¶ç±»ï¼ˆViewï¼‰çš„dispatchKeyEventå‡½æ•°ã€‚cbæ˜¯Window.Callbackç±»å‹ï¼ŒActivityå®ç°äº†Window.Callbackæ¥å£ï¼Œåœ¨attachå‡½æ•°ä¸­ï¼Œä¼šè°ƒç”¨Window.setCallbackå‡½æ•°å°†è‡ªå·±æ³¨å†Œè¿›PhoneWindowä¸­ï¼Œæ‰€ä»¥cbä¸ä¸ºç©ºã€‚åœ¨PhoneWindowåˆå§‹åŒ–æ—¶ä¼šè°ƒç”¨installDecorå‡½æ•°ç”ŸæˆDecorViewå¯¹è±¡ï¼Œè¯¥å‡½æ•°ä¸­ä¼ å…¥çš„mFeatureIdæ˜¯-1ï¼Œæ‰€ä»¥mFeatureIdä¹Ÿå°äº0ã€‚å› æ­¤æ­¤å¤„ä¼šè°ƒç”¨Activityçš„dispatchKeyEventå‡½æ•°ï¼Œå¼€å§‹åœ¨Viewä¸­åˆ†å‘æŒ‰é”®ã€‚ ä¸‹é¢æ¥åˆ†ææŒ‰é”®åœ¨Viewçš„å±‚æ¬¡ç»“æ„ä¸­æ˜¯å¦‚ä½•åˆ†å‘çš„ DecorViewçš„æŒ‰é”®åˆ†å‘ æ¥ä¸‹æ¥æ¥çœ‹è¿™é‡Œå…ˆçœ‹çœ‹Activity(Callback)çš„dispatchKeyEventå®ç°ï¼š Step 7ã€Activity.dispatchKeyEvent()1234567891011121314151617[frameworks/base/core/java/android/app/Activity.java]public boolean dispatchKeyEvent(KeyEvent event) &#123; //è°ƒç”¨è‡ªå®šä¹‰çš„onUserInteraction onUserInteraction(); Window win = getWindow(); //è°ƒç”¨PhoneWindowçš„superDispatchKeyEvent,å®é™…è°ƒç”¨DecorViewçš„superDispatchKeyEventï¼Œä»DecorViewå¼€å§‹ä»é¡¶å±‚Viewå¾€å­è§†å›¾ä¼ é€’ if (win.superDispatchKeyEvent(event)) &#123; return true; &#125; View decor = mDecor; if (decor == null) decor = win.getDecorView(); //åˆ°è¿™é‡Œå¦‚æœviewå±‚æ¬¡ç»“æ„æ²¡æœ‰è¿”å›trueåˆ™äº¤ç»™KeyEventæœ¬èº«çš„dispatchæ–¹æ³•ï¼ŒActivityçš„onKeyDown/onKeyUp/onKeyMultipleå°±ä¼šè¢«è§¦å‘ return event.dispatch(this, decor != null ? decor.getKeyDispatcherState() : null, this);&#125; æ¥ç€çœ‹ä¸‹PhoneWindowçš„superDispatchKeyEvent Step 8ã€PhoneWindow.superDispatchKeyEvent()12345678910111213141516171819202122&lt;!-- PhoneWindow.java --&gt;Overridepublic boolean superDispatchKeyEvent(KeyEvent event) &#123; return mDecor.superDispatchKeyEvent(event);&#125;&lt;!-- PhoneWindow.DecorView --&gt;public boolean superDispatchKeyEvent(KeyEvent event) &#123; // Give priority to closing action modes if applicable. if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) &#123; final int action = event.getAction(); // Back cancels action modes first. if (mPrimaryActionMode != null) &#123; if (action == KeyEvent.ACTION_UP) &#123; mPrimaryActionMode.finish(); &#125; return true; &#125; &#125; //è¿›å…¥Viewçš„å±‚æ¬¡ç»“æ„ï¼Œè°ƒç”¨ViewGroup.dispatchKeyEvent return super.dispatchKeyEvent(event);&#125; å†çœ‹ViewGroupçš„dispatchKeyEventå‡½æ•° Step 9ã€ViewGroup.dispatchKeyEvent()1234567891011121314151617181920[-&gt;frameworks/base/core/java/android/view/ViewGroup.java]public boolean dispatchKeyEvent(KeyEvent event) &#123; ... if ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) &#123; //å¦‚æœæ­¤ViewGroupæ˜¯focusedå¹¶ä¸”å…·ä½“çš„å¤§å°è¢«è®¾ç½®äº†ï¼ˆæœ‰è¾¹ç•Œï¼‰ï¼Œåˆ™äº¤ç»™å®ƒå¤„ç†ï¼Œå³è°ƒç”¨Viewçš„å®ç° if (super.dispatchKeyEvent(event)) &#123; return true; &#125; &#125; else if (mFocused != null &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS) == PFLAG_HAS_BOUNDS) &#123; //å¦åˆ™ï¼Œå¦‚æœæ­¤ViewGroupä¸­æœ‰focusedçš„childï¼Œä¸”childæœ‰å…·ä½“çš„å¤§å°ï¼Œåˆ™äº¤ç»™mFocusedå¤„ç† if (mFocused.dispatchKeyEvent(event)) &#123; return true; &#125; &#125; ... return false;&#125; è¿™é‡Œå¯ä»¥çœ‹å‡ºå¦‚æœViewGroupæ»¡è¶³æ¡ä»¶ï¼Œåˆ™ä¼˜å…ˆå¤„ç†äº‹ä»¶è€Œä¸å‘ç»™å­è§†å›¾å»å¤„ç†ã€‚ ä¸‹é¢çœ‹ä¸‹Viewçš„dispatchKeyEventå®ç° Step 10ã€View.dispatchKeyEvent()1234567891011121314151617181920[-&gt;frameworks/base/core/java/android/view/View.java]public boolean dispatchKeyEvent(KeyEvent event) &#123; ... // Give any attached key listener a first crack at the event. //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; //è°ƒç”¨onKeyListenerï¼Œå¦‚æœæ³¨å†Œäº†OnKeyListener,å¹¶ä¸”Viewå±äºEnableçŠ¶æ€ï¼Œåˆ™è§¦å‘ if (li != null &amp;&amp; li.mOnKeyListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) &#123; return true; &#125; //è°ƒç”¨KeyEvent.dispatchæ–¹æ³•ï¼Œå¹¶å°†viewä½œä¸ºå‚æ•°ä¼ é€’è¿›å»ï¼Œå®é™…ä¼šå›è°ƒViewçš„onKeyUp/onKeyDownç­‰æ–¹æ³• if (event.dispatch(this, mAttachInfo != null ? mAttachInfo.mKeyDispatchState : null, this)) &#123; return true; &#125; ... return false;&#125; Step 11ã€View.onKeyDown/View.onKeyUp123456789101112131415161718192021222324252627282930313233343536373839404142[-&gt;frameworks/base/core/java/android/view/View.java]public boolean onKeyDown(int keyCode, KeyEvent event) &#123; boolean result = false; //å¤„ç†KEYCODE_DPAD_CENTERã€KEYCODE_ENTERæŒ‰é”® if (KeyEvent.isConfirmKey(keyCode)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //disabledçš„viewç›´æ¥è¿”å›trueï¼Œä¸å†ç»§ç»­åˆ†å‘,å³Activityçš„onKeyDownå’ŒonKeyUpæ— æ³•æ”¶åˆ°KEYCODE_DPAD_CENTERã€KEYCODE_ENTERäº‹ä»¶ return true; &#125; // Long clickable items don't necessarily have to be clickable if (((mViewFlags &amp; CLICKABLE) == CLICKABLE || (mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &amp;&amp; (event.getRepeatCount() == 0)) &#123;// clickableæˆ–è€…long_clickableä¸”æ˜¯ç¬¬ä¸€æ¬¡downäº‹ä»¶ setPressed(true);// æ ‡è®°pressedï¼Œä½ å¯èƒ½è®¾ç½®äº†Viewä¸åŒçš„backgroundï¼Œè¿™æ—¶å€™å°±ä¼šæœ‰æ‰€ä½“ç°ï¼ˆæ¯”å¦‚é«˜äº®æ•ˆæœï¼‰ checkForLongClick(0); return true; &#125; &#125; return result;&#125;public boolean onKeyUp(int keyCode, KeyEvent event) &#123; //å¤„ç†KEYCODE_DPAD_CENTERã€KEYCODE_ENTERæŒ‰é”® if (KeyEvent.isConfirmKey(keyCode)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == DISABLED) &#123; //disabledçš„viewç›´æ¥è¿”å›trueï¼Œä¸å†ç»§ç»­åˆ†å‘,å³Activityçš„onKeyDownå’ŒonKeyUpæ— æ³•æ”¶åˆ°KEYCODE_DPAD_CENTERã€KEYCODE_ENTERäº‹ä»¶ return true; &#125; if ((mViewFlags &amp; CLICKABLE) == CLICKABLE &amp;&amp; isPressed()) &#123; setPressed(false); if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); return performClick(); &#125; &#125; &#125; return false;&#125; Step 12ã€Activity.onKeyDown/onKeyUp12345678910111213141516171819202122232425262728[-&gt;frameworks/base/core/java/android/app/Activity.java]public boolean onKeyDown(int keyCode, KeyEvent event) &#123; //å¦‚æœæ˜¯backé”®åˆ™å¯åŠ¨è¿½è¸ª if (keyCode == KeyEvent.KEYCODE_BACK) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) &#123; event.startTracking(); &#125; else &#123; onBackPressed(); &#125; return true; &#125; ...&#125;public boolean onKeyUp(int keyCode, KeyEvent event) &#123; if (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.ECLAIR) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.isTracking() &amp;&amp; !event.isCanceled()) &#123; //å¦‚æœæ˜¯backé”®å¹¶ä¸”æ­£åœ¨è¿½è¸ªè¯¥Eventï¼Œåˆ™è°ƒç”¨onBackPressed onBackPressed(); return true; &#125; &#125; return false;&#125; è€ŒAndroidå¸¸è§Touchäº‹ä»¶æ˜¯é€šè¿‡dispatchPointerEvent(MotionEvent event)åˆ†å‘çš„ï¼Œä¸»è¦è·Ÿåº•å±‚ä¼ ä¸Šæ¥çš„ è¾“å…¥äº‹ä»¶ç›¸å…³ï¼Œä¸åŒç±»å‹äº‹ä»¶åˆ†åˆ«å¤„ç†ã€‚ å…·ä½“Touchäº‹ä»¶åˆ†å‘æœºåˆ¶å¯å‚è€ƒåšå®¢ï¼š Androidäº‹ä»¶åˆ†å‘æœºåˆ¶å®Œå…¨è§£æï¼Œå¸¦ä½ ä»æºç çš„è§’åº¦å½»åº•ç†è§£(ä¸Š) Androidäº‹ä»¶åˆ†å‘æœºåˆ¶å®Œå…¨è§£æï¼Œå¸¦ä½ ä»æºç çš„è§’åº¦å½»åº•ç†è§£(ä¸‹) Androidè§¦æ‘¸å±äº‹ä»¶æ´¾å‘æœºåˆ¶è¯¦è§£ä¸æºç åˆ†æä¸€(Viewç¯‡) Androidè§¦æ‘¸å±äº‹ä»¶æ´¾å‘æœºåˆ¶è¯¦è§£ä¸æºç åˆ†æäºŒ(ViewGroupç¯‡) Androidè§¦æ‘¸å±äº‹ä»¶æ´¾å‘æœºåˆ¶è¯¦è§£ä¸æºç åˆ†æä¸‰(Activityç¯‡) Android Deeper(00) - Touchäº‹ä»¶åˆ†å‘å“åº”æœºåˆ¶ ä¹ã€æ€»ç»“ï¼šå†è´´ä¸€ä¸‹Input systemæ€»ä½“æ¡†æ¶å›¾ï¼š ï¼ˆä¸€ï¼‰ã€IMSåˆå§‹åŒ–&amp;&amp; IMSä¸Appå»ºç«‹é€šä¿¡ï¼š SystemServeråˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œåˆ›å»ºInputManagerServiceï¼ŒIMSç¬¬ä¸€ä»¶äº‹æƒ…å°±æ˜¯åˆå§‹åŒ–Nativeå±‚ï¼ŒåŒ…æ‹¬EventHub, InputReader å’Œ InputDispatcher IMSä»¥åŠå…¶ä»–çš„System Service åˆå§‹åŒ–å®Œæˆä¹‹åï¼Œåº”ç”¨ç¨‹åºå°±å¼€å§‹å¯åŠ¨ã€‚å¦‚æœä¸€ä¸ªåº”ç”¨ç¨‹åºæœ‰Activityï¼ˆåªæœ‰Activitèƒ½å¤Ÿæ¥å—ç”¨æˆ·è¾“å…¥ï¼‰ï¼Œå®ƒè¦å°†è‡ªå·±çš„Window(ViewRootImpl)é€šè¿‡setView()æ³¨å†Œåˆ°WindowManagerService ä¸­ ç”¨æˆ·è¾“å…¥çš„æ•æ‰å’Œå¤„ç†å‘ç”Ÿåœ¨ä¸åŒçš„è¿›ç¨‹é‡Œï¼ˆç”Ÿäº§è€…ï¼šInput Reader å’Œ Input Dispatcher åœ¨System Server è¿›ç¨‹é‡Œï¼Œè€Œæ¶ˆè´¹è€…ï¼Œåº”ç”¨ç¨‹åºè¿è¡Œåœ¨è‡ªå·±çš„è¿›ç¨‹é‡Œï¼‰ï¼Œå› æ­¤ç”¨æˆ·è¾“å…¥äº‹ä»¶ï¼ˆEvent)çš„ä¼ é€’éœ€è¦è·¨è¿›ç¨‹ã€‚åœ¨è¿™é‡Œï¼ŒAndroidä½¿ç”¨äº†Socket + Binderæ¥å®Œæˆã€‚OpenInputChannelPair ç”Ÿæˆäº†ä¸¤ä¸ªSocketçš„FDï¼Œ ä»£è¡¨ä¸€ä¸ªåŒå‘é€šé“çš„ä¸¤ç«¯ï¼Œå‘ä¸€ç«¯å†™å…¥æ•°æ®ï¼Œå¦å¤–ä¸€ç«¯ä¾¿å¯ä»¥è¯»å‡ºï¼Œåä¹‹ä¾ç„¶ï¼Œå¦‚æœä¸€ç«¯æ²¡æœ‰å†™å…¥æ•°æ®ï¼Œå¦å¤–ä¸€ç«¯å»è¯»ï¼Œåˆ™é™·å…¥é˜»å¡ç­‰å¾…ã€‚OpenInputChannelPair() å‘ç”Ÿåœ¨WindowManager Service.addWindow()ä¸­ é€šè¿‡RegisterInputChannel, WindowManagerService å°†åˆšåˆšåˆ›å»ºçš„ä¸€ä¸ªSocket FDï¼Œå°è£…åœ¨InputWindowHandle(ä»£è¡¨ä¸€ä¸ªWindowState) é‡Œä¼ ç»™InputManagerService InputManagerService é€šè¿‡JNIï¼ˆNativeInputManagerï¼‰æœ€ç»ˆè°ƒç”¨åˆ°äº†InputDispatcher çš„ RegisterInputChannel()æ–¹æ³•ï¼Œè¿™é‡Œï¼Œä¸€ä¸ªConnection å¯¹è±¡è¢«åˆ›å»ºå‡ºæ¥ï¼Œä»£è¡¨ä¸è¿œç«¯æŸä¸ªçª—å£(InputWindowHandle)çš„ä¸€æ¡ç”¨æˆ·è¾“å…¥æ•°æ®é€šé“ã€‚ä¸€ä¸ªDispatcherå¯èƒ½æœ‰å¤šä¸ªConnectionï¼ˆå¤šä¸ªWindowï¼‰åŒæ—¶å­˜åœ¨ã€‚ä¸ºäº†ç›‘å¬æ¥è‡ªäºWindowçš„æ¶ˆæ¯ï¼ŒInputDispatcher é€šè¿‡AddFd å°†è¿™äº›ä¸ªFD åŠ å…¥åˆ°Looperä¸­ï¼Œè¿™æ ·ï¼Œåªè¦æŸä¸ªWindowåœ¨Socketçš„å¦ä¸€ç«¯å†™å…¥æ•°æ®ï¼ŒLooperå°±ä¼šé©¬ä¸Šä»ç¡çœ ä¸­é†’æ¥ï¼Œè¿›è¡Œå¤„ç†ã€‚ åˆ°è¿™é‡Œï¼ŒViewRootImpl mWindowSession.addToDisplayè¿”å›ï¼ŒWMS å°†SocketPairçš„å¦å¤–ä¸€ä¸ªFD æ”¾åœ¨è¿”å›å‚æ•° OutputChannel é‡Œï¼Œå³è¿”å›ç»™APPè¿›ç¨‹ã€‚ æ¥ç€ViewRootImpl åˆ›å»ºäº†WindowInputEventReceiver ç”¨äºæ¥å—InputDispatchor ä¼ è¿‡æ¥çš„äº‹ä»¶ï¼ŒAppè¿›ç¨‹åŒæ ·é€šè¿‡AddFd() å°†è¯»ç«¯çš„Socket FD åŠ å…¥åˆ°Looperä¸­ï¼Œè¿™æ ·ä¸€æ—¦InputDispatchorå‘é€Eventï¼ŒLooperå°±ä¼šç«‹å³é†’æ¥å¤„ç†ã€‚ ï¼ˆäºŒï¼‰ã€Eventhub å’Œ Input Reader NativeInputManagerçš„æ„é€ å‡½æ•°é‡Œç¬¬ä¸€ä»¶äº‹æƒ…å°±æ˜¯åˆ›å»ºä¸€ä¸ªEventHubå¯¹è±¡ï¼ŒEventHubæ„é€ å‡½æ•°é‡Œä¸»è¦ç”Ÿæˆå¹¶åˆå§‹åŒ–å‡ ä¸ªæ§åˆ¶çš„FD mINotifyFd: ç”¨æ¥ç›‘æ§â€â€/dev/inputâ€ç›®å½•ä¸‹æ˜¯å¦æœ‰æ–‡ä»¶ç”Ÿæˆï¼Œæœ‰çš„è¯è¯´æ˜æœ‰æ–°çš„è¾“å…¥è®¾å¤‡æ¥å…¥ï¼ŒEventHubå°†ä»epool_waitä¸­å”¤é†’ï¼Œæ¥æ‰“å¼€æ–°åŠ å…¥çš„è®¾å¤‡ mWakeReaderFDï¼Œ mWakeWriterFDï¼š ä¸€ä¸ªPipeçš„ä¸¤ç«¯ï¼Œå½“å¾€mWakeWriteFD å†™å…¥æ•°æ®çš„æ—¶å€™ï¼Œç­‰å¾…åœ¨mWakeReaderFDçš„çº¿ç¨‹è¢«å”¤é†’ï¼Œè¿™é‡Œç”¨æ¥ç»™ä¸Šå±‚åº”ç”¨æä¾›å”¤é†’ç­‰å¾…çº¿ç¨‹ï¼Œæ¯”å¦‚è¯´ï¼Œå½“ä¸Šå±‚åº”ç”¨æ”¹å˜è¾“å…¥å±æ€§éœ€è¦EventHubè¿›è¡Œç›¸åº”æ›´æ–°æ—¶ mEpollFDï¼Œç”¨äºepoll_wait()çš„é˜»å¡ç­‰å¾…ï¼Œè¿™é‡Œé€šè¿‡epoll_ctrl(EPOLL_ADD_FD, fd) å¯ä»¥ç­‰å¾…å¤šä¸ªfdçš„äº‹ä»¶ï¼ŒåŒ…æ‹¬ä¸Šé¢æåˆ°çš„mINotifyFD, mWakeReaderFD, ä»¥åŠè¾“å…¥è®¾å¤‡çš„FDã€‚ InputManagerServiceå¯åŠ¨InputReader çº¿ç¨‹ï¼Œè¿›å…¥æ— é™çš„å¾ªç¯ï¼Œæ¯æ¬¡å¾ªç¯è°ƒç”¨loopOnce(). ç¬¬ä¸€æ¬¡å¾ªç¯ï¼Œä¼šä¸»åŠ¨æ‰«æ â€œ/dev/input/â€œ ç›®å½•ï¼Œå¹¶æ‰“å¼€ä¸‹é¢çš„æ‰€æœ‰æ–‡ä»¶ï¼Œé€šè¿‡ioctl()ä»åº•å±‚é©±åŠ¨è·å–è®¾å¤‡ä¿¡æ¯ï¼Œå¹¶åˆ¤æ–­å®ƒçš„è®¾å¤‡ç±»å‹ã€‚è¿™é‡Œå¤„ç†çš„è®¾å¤‡ç±»å‹æœ‰ï¼šINPUT_DEVICE_CLASS_KEYBOARDï¼Œ INPUT_DEVICE_CLASS_TOUCHï¼Œ INPUT_DEVICE_CLASS_DPADï¼ŒINPUT_DEVICE_CLASS_JOYSTICK ç­‰ã€‚ æ‰¾åˆ°æ¯ä¸ªè®¾å¤‡å¯¹åº”çš„é”®å€¼æ˜ å°„æ–‡ä»¶ï¼Œè¯»å–å¹¶ç”Ÿäº§ä¸€ä¸ªKeyMap å¯¹è±¡ã€‚ä¸€èˆ¬æ¥è¯´ï¼Œè®¾å¤‡å¯¹åº”çš„é”®å€¼æ˜ å°„æ–‡ä»¶æ˜¯ â€œ/system/usr/keylayout/Generic.klâ€. å°†åˆšæ‰æ‰«æåˆ°çš„/dev/input ä¸‹æ‰€æœ‰æ–‡ä»¶çš„FD åŠ åˆ°epoolç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œè°ƒç”¨epool_wait() å¼€å§‹ç­‰å¾…äº‹ä»¶çš„å‘ç”Ÿã€‚ æŸä¸ªæ—¶é—´å‘ç”Ÿï¼Œå¯èƒ½æ˜¯ç”¨æˆ·æŒ‰é”®è¾“å…¥ï¼Œä¹Ÿå¯èƒ½æ˜¯æŸä¸ªè®¾å¤‡æ’å…¥ï¼Œäº¦æˆ–ç”¨æˆ·è°ƒæ•´äº†è®¾å¤‡å±æ€§ï¼Œepoll_wait() è¿”å›ï¼Œå°†å‘ç”Ÿçš„Event å­˜æ”¾åœ¨mPendingEventItems é‡Œã€‚å¦‚æœè¿™æ˜¯ä¸€ä¸ªç”¨æˆ·è¾“å…¥ï¼Œç³»ç»Ÿè°ƒç”¨Read() ä»é©±åŠ¨è¯»åˆ°è¿™ä¸ªæŒ‰é”®çš„ä¿¡æ¯ï¼Œå­˜æ”¾åœ¨rawEventsé‡Œã€‚ EventHub-&gt;getEvents() è¿”å›,ä»£è¡¨æœ‰æ–°çš„inputäº‹ä»¶åˆ°æ¥ï¼Œè¿›å…¥InputReaderçš„processEventLockedå‡½æ•°ã€‚ é€šè¿‡rawEvent æ‰¾åˆ°äº§ç”Ÿæ—¶é—´çš„Deviceï¼Œå†æ‰¾åˆ°è¿™ä¸ªDeviceå¯¹åº”çš„InputMapperå¯¹è±¡ï¼Œæœ€ç»ˆç”Ÿæˆä¸€ä¸ªNotifyArgså¯¹è±¡ï¼Œå°†å…¶æ”¾åˆ°NotifyArgsçš„é˜Ÿåˆ—ä¸­ã€‚ è°ƒç”¨NotifyArgsé‡Œé¢çš„Notify()æ–¹æ³•ï¼Œæœ€ç»ˆè°ƒç”¨åˆ°InputDispatchor å¯¹åº”çš„Notifyæ¥å£ï¼ˆæ¯”å¦‚NotifyKey) å°†æ¥ä¸‹æ¥çš„å¤„ç†äº¤ç»™InputDispatchorï¼ŒEventHub å’Œ InputReader å·¥ä½œç»“æŸï¼Œä½†é©¬ä¸Šåˆå¼€å§‹æ–°çš„ä¸€è½®ç­‰å¾…ï¼Œé‡å¤6ï½9çš„å¾ªç¯ã€‚ ï¼ˆä¸‰ï¼‰ã€Input Dispatcher æ¥ä¸ŠèŠ‚çš„æœ€åä¸€æ­¥ï¼ŒNotifyKey() çš„å®ç°åœ¨Input Dispatcher å†…éƒ¨ï¼Œä»–é¦–å…ˆåšç®€å•çš„æ ¡éªŒï¼Œå¯¹äºæŒ‰é”®äº‹ä»¶ï¼Œåªæœ‰Action æ˜¯ AKEY_EVENT_ACTION_DOWN å’Œ AKEY_EVENT_ACTION_UPï¼Œå³æŒ‰ä¸‹å’Œå¼¹èµ·è¿™ä¸¤ä¸ªEventåˆ«æ¥å—ã€‚ Input Reader ä¼ ç»™Input Dispatherçš„æ•°æ®ç±»å‹æ˜¯ NotifyKeyArgsï¼Œ åè€…åœ¨è¿™é‡Œå°†å…¶è½¬æ¢ä¸º KeyEvent, ç„¶åäº¤ç”± Policy æ¥è¿›è¡Œç¬¬ä¸€æ­¥çš„è§£æå’Œè¿‡æ»¤ï¼ŒinterceptKeyBeforeDispatching(), å¯¹äºæ‰‹æœºäº§å“ï¼Œè¿™ä¸ªå·¥ä½œæ˜¯åœ¨PhoneWindowManager é‡Œå®Œæˆï¼Œï¼ˆä¸åŒç±»å‹çš„äº§å“å¯ä»¥å®šä¹‰ä¸åŒçš„WindowManager, æ¯”å¦‚GoogleTV é‡Œç”¨åˆ°çš„æ˜¯TVWindowManager)ã€‚KeyEvent åœ¨è¿™é‡Œå°†ä¼šè¢«åˆ†ä¸ºä¸‰ç±»ï¼š System Key: æ¯”å¦‚è¯´ éŸ³é‡é”®ï¼ŒPoweré”®ï¼Œä»¥åŠä¸€äº›ç‰¹æ®Šçš„ç»„åˆé”®ï¼Œå¦‚ç”¨äºæˆªå±çš„éŸ³é‡+Powerï¼Œç­‰ç­‰ã€‚éƒ¨åˆ†System Key ä¼šåœ¨è¿™é‡Œç«‹å³å¤„ç†ï¼Œæ¯”å¦‚è¯´ç”µè¯é”®ï¼Œä½†æœ‰ä¸€äº›ä¼šæ”¾åˆ°åé¢å»åšå¤„ç†ï¼Œæ¯”å¦‚è¯´éŸ³é‡é”®ï¼Œä½†ä¸ç®¡æ€æ ·ï¼Œè¿™äº›é”®ä¸ä¼šä¼ ç»™åº”ç”¨ç¨‹åºï¼Œæ‰€ä»¥ç§°ä¸ºç³»ç»Ÿé”®ã€‚ Global Keyï¼šæœ€ç»ˆäº§å“ä¸­å¯èƒ½ä¼šæœ‰ä¸€äº›ç‰¹æ®Šçš„æŒ‰é”®ï¼Œå®ƒä¸å±äºæŸä¸ªç‰¹å®šçš„åº”ç”¨ï¼Œåœ¨æ‰€æœ‰åº”ç”¨ä¸­çš„è¡Œä¸ºéƒ½æ˜¯ä¸€æ ·ï¼Œä½†ä¹Ÿä¸åŒ…å«åœ¨Andrioidçš„ç³»ç»Ÿé”®ä¸­ï¼Œæ¯”å¦‚è¯´GoogleTV é‡Œä¼šæœ‰ä¸€ä¸ªâ€TVâ€ æŒ‰é”®ï¼ŒæŒ‰å®ƒä¼šç›´æ¥å‘¼èµ·â€TVâ€åº”ç”¨ç„¶åæ”¶çœ‹ç”µè§†ç›´æ’­ï¼Œè¿™ç±»æŒ‰é”®åœ¨Androidå®šä¹‰ä¸ºGlobal Key. User Keyï¼šé™¤æ­¤ä¹‹å¤–çš„æŒ‰é”®å°±æ˜¯User Key, å®ƒæœ€ç»ˆä¼šä¼ é€’åˆ°å½“å‰çš„åº”ç”¨çª—å£ã€‚ æ­¤æ—¶ï¼ŒInputDispather è¿˜åœ¨Looperä¸­ç¡çœ ç­‰å¾…ï¼ŒmLooper-&gt;wake();å°†å…¶å”¤é†’ï¼Œç„¶åè¿›å…¥Input Dispatcher çº¿ç¨‹ã€‚ InputDispatcher å¤§éƒ¨åˆ†çš„å·¥ä½œåœ¨ dispatcherOnce é‡Œå®Œæˆã€‚é¦–å…ˆä»mInBoundQueue ä¸­è¯»å‡ºé˜Ÿåˆ—å¤´éƒ¨çš„äº‹ä»¶ mPendingEvent, ç„¶åè°ƒç”¨ pokeUserActivityLocked()ã€‚ pokeçš„è‹±æ–‡æ„æ€æ˜¯â€æ“ä¸€ä¸‹, æ…ä¸€ä¸‹â€ï¼Œ è¿™ä¸ªå‡½æ•°çš„ç›®çš„ä¹Ÿå°±æ˜¯â€æ…ä¸€ä¸‹â€PowerManagerService æé†’å®ƒâ€åˆ«ç¡çœ å•Šï¼Œæˆ‘è¿˜æ´»ç€å‘¢â€ï¼Œæœ€ç»ˆè°ƒç”¨åˆ°PowerManagerService çš„ updatePowerStateLocked()ï¼Œé˜²æ­¢æ‰‹æœºè¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸Šè¿°åŠ¨ä½œä¸ä¼šé©¬ä¸Šæ‰§è¡Œï¼Œè€Œæ˜¯å­˜å‚¨åœ¨å‘½ä»¤é˜Ÿåˆ—ï¼ŒmCommandQueueé‡Œï¼Œè¿™é‡Œé¢çš„å‘½ä»¤ä¼šåœ¨åé¢ä¾æ¬¡è¢«æ‰§è¡Œã€‚ æ¥ä¸‹æ¥æ˜¯dispatchOnceInnerLocked()-&gt;dispatchKeyLocked() ç¬¬ä¸€æ¬¡è¿›å»è¿™ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œå…ˆæ£€æŸ¥Eventæ˜¯å¦å·²ç»è¿‡å¤„ç†ï¼ˆdoInterceptKeyBeforeDispatchingLockedInterruptible), å¦‚æœæ²¡æœ‰ï¼Œåˆ™ç”Ÿæˆä¸€ä¸ªå‘½ä»¤ï¼ŒåŒæ ·æ”¾å…¥mCommandQueueé‡Œã€‚ runCommandsLockedInterruptible() ä¾æ¬¡æ‰§è¡ŒmCommandQueue é‡Œçš„å‘½ä»¤ï¼Œå‰é¢è¯´è¿‡ï¼ŒpokeUserActivity ä¼šè°ƒç”¨PowerManagerService çš„ updatePowerStateLocked(), è€Œ interceptKeyBeforeDispatching() åˆ™æœ€ç»ˆè°ƒç”¨åˆ°PhoneWindowManagerçš„åŒåå‡½æ•°ã€‚æˆ‘ä»¬åœ¨interceptBeforeQueuing é‡Œé¢æåˆ°çš„ä¸€äº›ç³»ç»ŸæŒ‰é”®åœ¨è¿™ä¸ªè¢«æ‰§è¡Œï¼Œæ¯”å¦‚ HOME/MENU/SEARCH ç­‰ã€‚ å‘½ä»¤è¿è¡Œå®Œä¹‹åï¼Œé€€å‡º dispatchOnceï¼Œ ç„¶åè°ƒç”¨pollOnce è¿›å…¥ä¸‹ä¸€è½®ç­‰å¾…ã€‚ä½†è¿™é‡Œä¸ä¼šè¢«é˜»å¡ï¼Œå› ä¸ºtimeoutå€¼è¢«è®¾æˆäº†0. ç¬¬äºŒæ¬¡è¿›å…¥dispatchKeyLocked(), è¿™æ˜¯Eventçš„çŠ¶æ€å·²ç»è®¾ä¸ºâ€å·²å¤„ç†â€ï¼Œè¿™æ—¶å€™æ‰çœŸæ­£è¿›å…¥äº†å‘å°„é˜¶æ®µã€‚ æ¥ä¸‹æ¥è°ƒç”¨ findFocusedWindowTargetLocked() è·å–å½“å‰çš„ç„¦ç‚¹çª—å£ï¼Œè¿™é‡Œé¢ä¼šåšä¸€ä»¶éå¸¸é‡è¦çš„äº‹æƒ…ï¼Œå°±æ˜¯æ£€æµ‹ç›®æ ‡åº”ç”¨æ˜¯å¦æœ‰ANRå‘ç”Ÿï¼Œå¦‚æœä¸‹è¯‰æ¡ä»¶æ»¡è¶³ï¼Œåˆ™è¯´æ˜å¯èƒ½å‘ç”Ÿäº†ANRï¼š ç›®æ ‡åº”ç”¨ä¸ä¼šç©ºï¼Œè€Œç›®æ ‡çª—å£ä¸ºç©ºã€‚è¯´æ˜åº”ç”¨ç¨‹åºåœ¨å¯åŠ¨è¿‡ç¨‹ä¸­å‡ºç°äº†é—®é¢˜ã€‚ ç›®æ ‡ Activity çš„çŠ¶æ€æ˜¯Pauseï¼Œå³ä¸å†æ˜¯Focusedçš„åº”ç”¨ã€‚ ç›®æ ‡çª—å£è¿˜åœ¨å¤„ç†ä¸Šä¸€ä¸ªäº‹ä»¶ã€‚è¿™ä¸ªæˆ‘ä»¬ä¸‹é¢ä¼šè¯´åˆ°ã€‚ å¦‚æœç›®æ ‡çª—å£å¤„äºæ­£å¸¸çŠ¶æ€ï¼Œè°ƒç”¨dispatchEventLocked() è¿›å…¥çœŸæ­£çš„å‘é€ç¨‹åºã€‚ ç„¶åè°ƒç”¨prepareDispatchCycleLocked() ,è¿™é‡Œäº‹ä»¶æ¢äº†ä¸€ä»¶é©¬ç”²ï¼Œä»EventEntry å˜æˆ DispatchEntry, å¹¶é€äººmOutBoundQueueã€‚ç„¶åè°ƒç”¨startDispatchCycleLocked() å¼€å§‹å‘é€ã€‚ æœ€ç»ˆçš„å‘é€å‘ç”Ÿåœ¨InputChannelçš„sendMessage()ã€‚è¿™é‡Œå°±ç”¨åˆ°äº†æˆ‘ä»¬å‰é¢æåˆ°çš„SocketPair, ä¸€æ—¦sendMessage() æ‰§è¡Œï¼Œç›®æ ‡çª—å£æ‰€åœ¨è¿›ç¨‹çš„Looperçº¿ç¨‹å°±ä¼šè¢«å”¤é†’ï¼Œç„¶åè¯»å–é”®å€¼å¹¶è¿›è¡Œå¤„ç†ã€‚ ä¹–ä¹–ï¼Œè¿˜æ²¡èµ°å®Œå•Šï¼Ÿæ˜¯çš„ï¼Œå·¥ä½œè¿˜å·®æœ€åä¸€æ­¥ï¼ŒInput Dispatcherç»™è¿™ä¸ªçª—å£å‘é€ä¸‹ä¸€ä¸ªå‘½ä»¤ä¹‹å‰ï¼Œå¿…é¡»ç­‰å¾…è¯¥çª—å£çš„å›å¤ï¼Œå¦‚æœè¶…è¿‡5sæ²¡æœ‰æ”¶åˆ°ï¼Œå°±ä¼šé€šè¿‡Input Manager Service å‘Activity Manager æ±‡æŠ¥ï¼Œåè€…ä¼šå¼¹å‡ºæˆ‘ä»¬ç†ŸçŸ¥çš„ â€œApplication No Responseâ€ çª—å£ã€‚æ‰€ä»¥ï¼Œäº‹ä»¶ä¼šæ”¾å…¥mWaitQueueè¿›è¡Œæš‚å­˜ã€‚å¦‚æœçª—å£ä¸€åˆ‡æ­£å¸¸ï¼Œå®ŒæˆæŒ‰é”®å¤„ç†åå®ƒä¼šè°ƒç”¨InputConsumerçš„sendFinishedSignal() å¾€SocketPair é‡Œå†™å…¥å®Œæˆä¿¡å·ï¼ŒInput Dispatcher ä» Loopä¸­é†’æ¥ï¼Œå¹¶ä»Socketä¸­è¯»å–è¯¥ä¿¡å·ï¼Œç„¶åä»mWaitQueue é‡Œæ¸…é™¤è¯¥äº‹ä»¶æ ‡å¿—å…¶å¤„ç†å®Œæ¯•ã€‚ ï¼ˆå››ï¼‰ã€Key Processingç•¥ã€è¯·å‚è€ƒï¼š å›¾è§£Android - Android GUI ç³»ç»Ÿ (5) - Androidçš„Event Input System - æ¼«å¤©å°˜æ²™ - åšå®¢å›­ å‚è€ƒæ–‡æ¡£(ç‰¹åˆ«æ„Ÿè°¢)ï¼šéŸ¦ä¸œå±±ç¬¬4æœŸAndroidé©±åŠ¨æ·±åº¦å¼€å‘è§†é¢‘æºç -GitHubéŸ¦ä¸œå±±ç¬¬4æœŸAndroidé©±åŠ¨æ·±åº¦å¼€å‘è§†é¢‘-è¾“å…¥ç³»ç»Ÿ-100ask.orgAndroidè¾“å…¥å­ç³»ç»Ÿ-ChenWeiaiYanYanã€Šæ·±å…¥ç†è§£Android å·IIIã€‹ç¬¬äº”ç«  æ·±å…¥ç†è§£Androidè¾“å…¥ç³»ç»Ÿ - CSDNåšå®¢å›¾è§£Android - Android GUI ç³»ç»Ÿ (5) - Androidçš„Event Input System - æ¼«å¤©å°˜æ²™ - åšå®¢å›­Android 5.0(Lollipop)äº‹ä»¶è¾“å…¥ç³»ç»Ÿ(Input System) - ä¸–äº‹éš¾æ–™ï¼Œä¿æŒä½è°ƒ - CSDNåšå®¢ã€Androidã€‘Androidè¾“å…¥å­ç³»ç»Ÿ - Leo.cheng - åšå®¢å›­Android(Linux) è¾“å…¥å­ç³»ç»Ÿè§£æ | Andy.Leeâ€™s BlogINPUTäº‹ä»¶çš„è¯»å–å’Œåˆ†å‘ï¼šINPUTREADERã€INPUTDISPATCHERAndroid è§¦æ‘¸äº‹ä»¶åˆ†å‘æœºåˆ¶æ·±å…¥ç†è§£Androidä¹‹Touchäº‹ä»¶çš„åˆ†å‘","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Activity - Window åŠ è½½æ˜¾ç¤ºæµç¨‹ï¼ˆAMS && WMSï¼‰åˆ†æ","slug":"Android-7-1-2-Android-N-Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹","date":"2017-10-31T16:00:00.000Z","updated":"2018-04-19T14:29:48.415Z","comments":true,"path":"2017/11/01/Android-7-1-2-Android-N-Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹/","link":"","permalink":"http://zhoujinjian.cc/2017/11/01/Android-7-1-2-Android-N-Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹/","excerpt":"Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹æ¦‚è¿°ï¼š Androidç³»ç»Ÿä¸­å›¾å½¢ç³»ç»Ÿæ˜¯ç›¸å½“å¤æ‚çš„ï¼ŒåŒ…æ‹¬WindowManagerï¼ŒSurfaceFlinger,Open GL,GPUç­‰æ¨¡å—ã€‚ å…¶ä¸­SurfaceFlingerä½œä¸ºè´Ÿè´£ç»˜åˆ¶åº”ç”¨UIçš„æ ¸å¿ƒï¼Œä»åå­—å¯ä»¥çœ‹å‡ºå…¶åŠŸèƒ½æ˜¯å°†æ‰€æœ‰Surfaceåˆæˆå·¥ä½œã€‚ ä¸è®ºä½¿ç”¨ä»€ä¹ˆæ¸²æŸ“API, æ‰€æœ‰çš„ä¸œè¥¿æœ€ç»ˆéƒ½æ˜¯æ¸²æŸ“åˆ°â€surfaceâ€. surfaceä»£è¡¨BufferQueueçš„ç”Ÿäº§è€…ç«¯, å¹¶ä¸” ç”±SurfaceFlingeræ‰€æ¶ˆè´¹, è¿™ä¾¿æ˜¯åŸºæœ¬çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼. Androidå¹³å°æ‰€åˆ›å»ºçš„Windowéƒ½ç”±surfaceæ‰€æ”¯æŒ, æ‰€æœ‰å¯è§çš„surfaceæ¸²æŸ“åˆ°æ˜¾ç¤ºè®¾å¤‡éƒ½æ˜¯é€šè¿‡SurfaceFlingeræ¥å®Œæˆçš„. æœ¬æ–‡è¯¦ç»†åˆ†æAndroid WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ï¼Œå¹¶é€šè¿‡SurfaceFlingeræ¸²æŸ“åˆæˆè¾“å‡ºåˆ°å±å¹•çš„è¿‡ç¨‹ã€‚","text":"Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹æ¦‚è¿°ï¼š Androidç³»ç»Ÿä¸­å›¾å½¢ç³»ç»Ÿæ˜¯ç›¸å½“å¤æ‚çš„ï¼ŒåŒ…æ‹¬WindowManagerï¼ŒSurfaceFlinger,Open GL,GPUç­‰æ¨¡å—ã€‚ å…¶ä¸­SurfaceFlingerä½œä¸ºè´Ÿè´£ç»˜åˆ¶åº”ç”¨UIçš„æ ¸å¿ƒï¼Œä»åå­—å¯ä»¥çœ‹å‡ºå…¶åŠŸèƒ½æ˜¯å°†æ‰€æœ‰Surfaceåˆæˆå·¥ä½œã€‚ ä¸è®ºä½¿ç”¨ä»€ä¹ˆæ¸²æŸ“API, æ‰€æœ‰çš„ä¸œè¥¿æœ€ç»ˆéƒ½æ˜¯æ¸²æŸ“åˆ°â€surfaceâ€. surfaceä»£è¡¨BufferQueueçš„ç”Ÿäº§è€…ç«¯, å¹¶ä¸” ç”±SurfaceFlingeræ‰€æ¶ˆè´¹, è¿™ä¾¿æ˜¯åŸºæœ¬çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼. Androidå¹³å°æ‰€åˆ›å»ºçš„Windowéƒ½ç”±surfaceæ‰€æ”¯æŒ, æ‰€æœ‰å¯è§çš„surfaceæ¸²æŸ“åˆ°æ˜¾ç¤ºè®¾å¤‡éƒ½æ˜¯é€šè¿‡SurfaceFlingeræ¥å®Œæˆçš„. æœ¬æ–‡è¯¦ç»†åˆ†æAndroid WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ï¼Œå¹¶é€šè¿‡SurfaceFlingeræ¸²æŸ“åˆæˆè¾“å‡ºåˆ°å±å¹•çš„è¿‡ç¨‹ã€‚ ä¸€ã€Activityå¯åŠ¨æµç¨‹æ¦‚è¿°åŸºäºAndroid 7.1.2çš„æºç å‰–æï¼Œ åˆ†æActivity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ï¼Œç›¸å…³æºç ï¼š frameworks/base/core/java/android/app/â— Activity.javaâ— ActivityThread.javaâ— Instrumentation.java frameworks/base/core/jni/â— android_view_DisplayEventReceiver.cppâ— android_view_SurfaceControl.cppâ— android_view_Surface.cppâ— android_view_SurfaceSession.cpp frameworks/native/include/gui/â— SurfaceComposerClient.cppâ— SurfaceComposerClient.h frameworks/native/services/surfaceflinger/â— SurfaceFlinger.cppâ— Client.cpp frameworks/base/core/java/android/view/â— WindowManagerImpl.javaâ— ViewManager.javaâ— WindowManagerGlobal.javaâ— ViewRootImpl.javaâ— Choreographer.javaâ— IWindowSession.aidlâ— DisplayEventReceiver.javaâ— SurfaceControl.javaâ— Surface.javaâ— SurfaceSession.java frameworks/base/core/java/com/android/internal/policy/â— PhoneWindow.java frameworks/base/services/core/java/com/android/server/wm/â— WindowManagerService.javaâ— Session.javaâ— WindowState.javaâ— WindowStateAnimator.javaâ— WindowSurfaceController.java åšå®¢åŸå›¾é“¾æ¥åœ¨å‰é¢æ–‡ç« ï¼ˆAndroid 7.1.2(Android N) Activityå¯åŠ¨æµç¨‹åˆ†æï¼‰ä¸­è¯¦ç»†åˆ†æäº†Activityå¯åŠ¨æµç¨‹ï¼Œè¿™é‡Œå›é¡¾ä¸€ä¸‹æ€»ä½“æµç¨‹ã€‚ Activityå¯åŠ¨æµç¨‹å›¾ï¼š å¯åŠ¨æµç¨‹ï¼š â— ç‚¹å‡»æ¡Œé¢Appå›¾æ ‡ï¼ŒLauncherè¿›ç¨‹é‡‡ç”¨Binder IPCå‘system_serverè¿›ç¨‹å‘èµ·startActivityè¯·æ±‚ï¼›â— system_serverè¿›ç¨‹æ¥æ”¶åˆ°è¯·æ±‚åï¼Œå‘zygoteè¿›ç¨‹å‘é€åˆ›å»ºè¿›ç¨‹çš„è¯·æ±‚ï¼›â— Zygoteè¿›ç¨‹forkå‡ºæ–°çš„å­è¿›ç¨‹ï¼Œå³Appè¿›ç¨‹ï¼›â— Appè¿›ç¨‹ï¼Œé€šè¿‡Binder IPCå‘sytem_serverè¿›ç¨‹å‘èµ·attachApplicationè¯·æ±‚ï¼›â— system_serverè¿›ç¨‹åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œè¿›è¡Œä¸€ç³»åˆ—å‡†å¤‡å·¥ä½œåï¼Œå†é€šè¿‡binder IPCå‘Appè¿›ç¨‹å‘é€scheduleLaunchActivityè¯·æ±‚ï¼›â— Appè¿›ç¨‹çš„binderçº¿ç¨‹ï¼ˆApplicationThreadï¼‰åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œé€šè¿‡handlerå‘ä¸»çº¿ç¨‹å‘é€LAUNCH_ACTIVITYæ¶ˆæ¯ï¼›â— ä¸»çº¿ç¨‹åœ¨æ”¶åˆ°Messageåï¼Œé€šè¿‡å‘å°„æœºåˆ¶åˆ›å»ºç›®æ ‡Activityï¼Œå¹¶å›è°ƒActivity.onCreate()ç­‰æ–¹æ³•ã€‚ Appæ­£å¼å¯åŠ¨åï¼Œå¼€å§‹è¿›å…¥Activityç”Ÿå‘½å‘¨æœŸï¼Œæ‰§è¡Œå®ŒonCreate/onStart/onResumeæ–¹æ³•ï¼ŒUIæ¸²æŸ“ç»“æŸåä¾¿å¯ä»¥çœ‹åˆ°Appçš„ä¸»ç•Œé¢ï¼Œ æ¥ä¸‹æ¥åˆ†æUIæ¸²æŸ“æµç¨‹ã€‚ äºŒã€WindowåŠ è½½æ˜¾ç¤ºæµç¨‹2.1ã€ActivityThread.handleLaunchActivity()æ¥ç€ä»ActivityThreadçš„handleLaunchActivityæ–¹æ³•ï¼š [-&gt;ActivityThread.java] 12345678910111213141516 private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason)&#123; ...... // Initialize before creating the activity WindowManagerGlobal.initialize(); //åˆ›å»ºActivity Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; ...... //å¯åŠ¨Activity handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... &#125;&#125; åº”ç”¨ç¨‹åºè¿›ç¨‹é€šè¿‡performLaunchActivityå‡½æ•°å°†å³å°†è¦å¯åŠ¨çš„ActivityåŠ è½½åˆ°å½“å‰è¿›ç¨‹ç©ºé—´æ¥ï¼ŒåŒæ—¶ä¸ºå¯åŠ¨Activityåšå‡†å¤‡ã€‚ [ActivityThread.java #performLaunchActivity()] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //é€šè¿‡Activityæ‰€åœ¨çš„åº”ç”¨ç¨‹åºä¿¡æ¯åŠè¯¥Activityå¯¹åº”çš„CompatibilityInfoä¿¡æ¯ä»PMSæœåŠ¡ä¸­æŸ¥è¯¢å½“å‰Activityçš„åŒ…ä¿¡æ¯ ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; //è·å–å½“å‰Activityçš„ç»„ä»¶ä¿¡æ¯ ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; //packageNameä¸ºå¯åŠ¨Activityçš„åŒ…åï¼ŒtargetActivityä¸ºActivityçš„ç±»å if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //é€šè¿‡ç±»åå°„æ–¹å¼åŠ è½½å³å°†å¯åŠ¨çš„Activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; ...... try &#123; //é€šè¿‡å•ä¾‹æ¨¡å¼ä¸ºåº”ç”¨ç¨‹åºè¿›ç¨‹åˆ›å»ºApplicationå¯¹è±¡ Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; //ä¸ºå½“å‰Activityåˆ›å»ºä¸Šä¸‹æ–‡å¯¹è±¡ContextImpl Context appContext = createBaseContextForActivity(r, activity); ...... //å°†å½“å‰å¯åŠ¨çš„Activityå’Œä¸Šä¸‹æ–‡ContextImplã€Applicationç»‘å®š activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... //å°†Activityä¿å­˜åˆ°ActivityClientRecordä¸­ï¼ŒActivityClientRecordä¸ºActivityåœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­çš„æè¿°ç¬¦ r.activity = activity; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... //ç”Ÿå‘½å‘¨æœŸonStartã€onresume if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; //ActivityThreadçš„æˆå‘˜å˜é‡mActivitiesä¿å­˜äº†å½“å‰åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­çš„æ‰€æœ‰Activityçš„æè¿°ç¬¦ mActivities.put(r.token, r); ...... return activity;&#125; åœ¨è¯¥å‡½æ•°ä¸­ï¼Œé¦–å…ˆé€šè¿‡PMSæœåŠ¡æŸ¥æ‰¾åˆ°å³å°†å¯åŠ¨çš„Activityçš„åŒ…åä¿¡æ¯ï¼Œç„¶åé€šè¿‡ç±»åå°„æ–¹å¼åˆ›å»ºä¸€ä¸ªè¯¥Activityå®ä¾‹ï¼ŒåŒæ—¶ä¸ºåº”ç”¨ç¨‹åºå¯åŠ¨çš„æ¯ä¸€ä¸ªActivityåˆ›å»ºä¸€ä¸ªLoadedApkå®ä¾‹å¯¹è±¡ï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­åˆ›å»ºçš„æ‰€æœ‰LoadedApkå¯¹è±¡ä¿å­˜åœ¨ActivityThreadçš„æˆå‘˜å˜é‡mPackagesä¸­ã€‚æ¥ç€é€šè¿‡LoadedApkå¯¹è±¡çš„makeApplicationå‡½æ•°ï¼Œä½¿ç”¨å•ä¾‹æ¨¡å¼åˆ›å»ºApplicationå¯¹è±¡ï¼Œå› æ­¤åœ¨androidåº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­æœ‰ä¸”åªæœ‰ä¸€ä¸ªApplicationå®ä¾‹ã€‚ç„¶åä¸ºå½“å‰å¯åŠ¨çš„Activityåˆ›å»ºä¸€ä¸ªContextImplä¸Šä¸‹æ–‡å¯¹è±¡ï¼Œå¹¶åˆå§‹åŒ–è¯¥ä¸Šä¸‹æ–‡ï¼Œåˆ°æ­¤æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œå¯åŠ¨ä¸€ä¸ªActivityéœ€è¦ä»¥ä¸‹å¯¹è±¡ï¼š 1) Activityå¯¹è±¡ï¼Œéœ€è¦å¯åŠ¨çš„Activityï¼› 2) LoadedApkå¯¹è±¡ï¼Œæ¯ä¸ªå¯åŠ¨çš„Activityéƒ½æ‹¥æœ‰å±äºè‡ªèº«çš„LoadedApkå¯¹è±¡ï¼› 3) ContextImplå¯¹è±¡ï¼Œæ¯ä¸ªå¯åŠ¨çš„Activityéƒ½æ‹¥æœ‰å±äºè‡ªèº«çš„ContextImplå¯¹è±¡ï¼› 4) Applicationå¯¹è±¡ï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­æœ‰ä¸”åªæœ‰ä¸€ä¸ªå®ä¾‹ï¼Œå’ŒActivityæ˜¯ä¸€å¯¹å¤šçš„å…³ç³»ï¼› 2.2ã€Activityå¯¹è±¡Attachè¿‡ç¨‹Activityæ‰€éœ€è¦çš„å¯¹è±¡éƒ½åˆ›å»ºå¥½äº†ï¼Œå°±éœ€è¦å°†Activityå’ŒApplicationå¯¹è±¡ã€ContextImplå¯¹è±¡ç»‘å®šåœ¨ä¸€èµ·ã€‚ å‚æ•°ï¼š contextï¼šActivityçš„ä¸Šä¸‹æ–‡å¯¹è±¡ï¼Œå°±æ˜¯å‰é¢åˆ›å»ºçš„ContextImplå¯¹è±¡ï¼› aThreadï¼šActivityè¿è¡Œæ‰€åœ¨çš„ä¸»çº¿ç¨‹æè¿°ç¬¦ActivityThreadï¼› instrï¼šç”¨äºç›‘æ§Activityè¿è¡ŒçŠ¶æ€çš„Instrumentationå¯¹è±¡ï¼› tokenï¼šç”¨äºå’ŒAMSæœåŠ¡é€šä¿¡çš„IApplicationToken.Proxyä»£ç†å¯¹è±¡ï¼› applicationï¼šActivityè¿è¡Œæ‰€åœ¨è¿›ç¨‹çš„Applicationå¯¹è±¡ï¼› parentï¼šå¯åŠ¨å½“å‰Activityçš„Activityï¼› [-&gt;Activity.java] 1234567891011121314151617181920212223242526272829 final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; //å°†ä¸Šä¸‹æ–‡å¯¹è±¡ContextImplä¿å­˜åˆ°Activityçš„æˆå‘˜å˜é‡ä¸­ attachBaseContext(context); ...... mWindow = new PhoneWindow(this, window); ...... //è®°å½•åº”ç”¨ç¨‹åºçš„UIçº¿ç¨‹ mUiThread = Thread.currentThread(); //è®°å½•åº”ç”¨ç¨‹åºçš„ActivityThreadå¯¹è±¡ mMainThread = aThread; ...... //ä¸ºActivityæ‰€åœ¨çš„çª—å£åˆ›å»ºçª—å£ç®¡ç†å™¨ mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) &#123; mWindow.setContainer(mParent.getWindow()); &#125; mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;&#125; åœ¨è¯¥attachå‡½æ•°ä¸­ä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š 1) æ ¹æ®å‚æ•°åˆå§‹åŒ–Activityçš„æˆå‘˜å˜é‡ï¼› 2) ä¸ºActivityåˆ›å»ºçª—å£Windowå¯¹è±¡ï¼› 3) ä¸ºWindowåˆ›å»ºçª—å£ç®¡ç†å™¨ï¼› 2.3ã€Activityè§†å›¾å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹-Activity.setContentView() ActivityThread.performLaunchActivity()â€“&gt; Instrumentation.callActivityOnCreate()â€”â€”&gt;Activity.performCreate()â€”â€”&gt;Activity.onCreate()â€“&gt;Activity.performStart()â€”â€”&gt;Instrumentation.callActivityOnStart()â€”â€”&gt;Activity.onStart() 1234 public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; getWindow()å‡½æ•°å¾—åˆ°å‰é¢åˆ›å»ºçš„çª—å£å¯¹è±¡PhoneWindowï¼Œé€šè¿‡PhoneWindowæ¥è®¾ç½®Activityçš„è§†å›¾ã€‚ [-&gt;PhoneWindow.java] 1234567891011121314151617181920 public void setContentView(View view, ViewGroup.LayoutParams params) &#123; ...... //å¦‚æœçª—å£é¡¶çº§è§†å›¾å¯¹è±¡ä¸ºç©ºï¼Œåˆ™åˆ›å»ºçª—å£è§†å›¾å¯¹è±¡ if (mContentParent == null) &#123; installDecor(); &#125; ...... if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; ...... &#125; else &#123;//åŠ è½½å¸ƒå±€æ–‡ä»¶ï¼Œå¹¶å°†å¸ƒå±€æ–‡ä»¶ä¸­çš„æ‰€æœ‰è§†å›¾å¯¹è±¡æ·»åŠ åˆ°mContentParentå®¹å™¨ä¸­,PhoneWindowçš„æˆå‘˜å˜é‡mContentParentçš„ç±»å‹ä¸ºViewGroupï¼Œæ˜¯çª—å£å†…å®¹å­˜æ”¾çš„åœ°æ–¹ mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; mContentParentExplicitlySet = true;&#125; Activity.onCreate()ä¼šè°ƒç”¨setContentView(),æ•´ä¸ªè¿‡ç¨‹ä¸»è¦æ˜¯Activityçš„å¸ƒå±€æ–‡ä»¶æˆ–Viewæ·»åŠ è‡³çª—å£é‡Œï¼Œ è¯¦ç»†è¿‡ç¨‹ä¸å†èµ˜è¿°ï¼Œè¯¦ç»†åŠ è½½è¿‡ç¨‹è¯·å‚è€ƒï¼š Androidåº”ç”¨setContentViewä¸LayoutInflateråŠ è½½è§£ææœºåˆ¶æºç åˆ†æ é‡ç‚¹æ¦‚æ‹¬ä¸ºï¼š 1234â— åˆ›å»ºä¸€ä¸ªDecorViewçš„å¯¹è±¡mDecorï¼Œè¯¥mDecorå¯¹è±¡å°†ä½œä¸ºæ•´ä¸ªåº”ç”¨çª—å£çš„æ ¹è§†å›¾ã€‚â— ä¾æ®Featureç­‰style themeåˆ›å»ºä¸åŒçš„çª—å£ä¿®é¥°å¸ƒå±€æ–‡ä»¶ï¼Œå¹¶ä¸”é€šè¿‡findViewByIdè·å–Activityå¸ƒå±€æ–‡ä»¶è¯¥å­˜æ”¾çš„åœ°æ–¹ï¼ˆçª—å£ä¿®é¥°å¸ƒå±€æ–‡ä»¶ä¸­idä¸ºcontentçš„FrameLayoutï¼‰ã€‚â— å°†Activityçš„å¸ƒå±€æ–‡ä»¶æ·»åŠ è‡³idä¸ºcontentçš„FrameLayoutå†…ã€‚â— å½“setContentViewè®¾ç½®æ˜¾ç¤ºOKä»¥åä¼šå›è°ƒActivityçš„onContentChangedæ–¹æ³•ã€‚Activityçš„å„ç§Viewçš„findViewById()æ–¹æ³•ç­‰éƒ½å¯ä»¥æ”¾åˆ°è¯¥æ–¹æ³•ä¸­ï¼Œç³»ç»Ÿä¼šå¸®å¿™å›è°ƒã€‚ 2.4ã€ActivityThread.handleResumeActivity()å›åˆ°æˆ‘ä»¬åˆšåˆšçš„handleLaunchActivity()æ–¹æ³•ï¼Œåœ¨è°ƒç”¨å®ŒperformLaunchActivity()æ–¹æ³•ä¹‹åï¼Œå…¶æœ‰æ‰ç”¨äº†handleResumeActivity()æ³•ã€‚ performLaunchActivity()æ–¹æ³•å®Œæˆäº†ä¸¤ä»¶äº‹ï¼š 1) Activityçª—å£å¯¹è±¡çš„åˆ›å»ºï¼Œé€šè¿‡attachå‡½æ•°æ¥å®Œæˆï¼› 2) Activityè§†å›¾å¯¹è±¡çš„åˆ›å»ºï¼Œé€šè¿‡setContentViewå‡½æ•°æ¥å®Œæˆï¼› è¿™äº›å‡†å¤‡å·¥ä½œå®Œæˆåï¼Œå°±å¯ä»¥æ˜¾ç¤ºè¯¥Activityäº†ï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹é€šè¿‡è°ƒç”¨handleResumeActivityå‡½æ•°æ¥å¯åŠ¨Activityçš„æ˜¾ç¤ºè¿‡ç¨‹ã€‚ [-&gt;ActivityThread.java] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... // r = performResumeActivity(token, clearHide, reason); ...... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //è·å¾—ä¸ºå½“å‰Activityåˆ›å»ºçš„çª—å£PhoneWindowå¯¹è±¡ r.window = r.activity.getWindow(); //è·å–ä¸ºçª—å£åˆ›å»ºçš„è§†å›¾DecorViewå¯¹è±¡ View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //åœ¨attachå‡½æ•°ä¸­å°±ä¸ºå½“å‰Activityåˆ›å»ºäº†WindowManagerå¯¹è±¡ ViewManager wm = a.getWindowManager(); //å¾—åˆ°è¯¥è§†å›¾å¯¹è±¡çš„å¸ƒå±€å‚æ•° WindowManager.LayoutParams l = r.window.getAttributes(); //å°†è§†å›¾å¯¹è±¡ä¿å­˜åˆ°Activityçš„æˆå‘˜å˜é‡mDecorä¸­ a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; ...... if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; //å°†åˆ›å»ºçš„è§†å›¾å¯¹è±¡DecorViewæ·»åŠ åˆ°Activityçš„çª—å£ç®¡ç†å™¨ä¸­ wm.addView(decor, l); &#125; ...... if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; if (!r.onlyLocalRequest) &#123; //onStop()...... Looper.myQueue().addIdleHandler(new Idler()); &#125; r.onlyLocalRequest = false; if (reallyResume) &#123; try &#123; ActivityManagerNative.getDefault().activityResumed(token); &#125; &#125; ...... &#125;&#125; æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨å‰é¢çš„performLaunchActivityå‡½æ•°ä¸­å®ŒæˆActivityçš„åˆ›å»ºåï¼Œä¼šå°†å½“å‰å½“å‰åˆ›å»ºçš„Activityåœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ç«¯çš„æè¿°ç¬¦ActivityClientRecordä»¥é”®å€¼å¯¹çš„å½¢å¼ä¿å­˜åˆ°ActivityThreadçš„æˆå‘˜å˜é‡mActivitiesä¸­ï¼šmActivities.put(r.token, r)ï¼Œr.tokenå°±æ˜¯Activityçš„èº«ä»½è¯ï¼Œå³æ˜¯IApplicationToken.Proxyä»£ç†å¯¹è±¡ï¼Œä¹Ÿç”¨äºä¸AMSé€šä¿¡ã€‚ä¸Šé¢çš„å‡½æ•°é¦–å…ˆé€šè¿‡performResumeActivityä»mActivitieså˜é‡ä¸­å–å‡ºActivityçš„åº”ç”¨ç¨‹åºç«¯æè¿°ç¬¦ActivityClientRecordï¼Œç„¶åå–å‡ºå‰é¢ä¸ºActivityåˆ›å»ºçš„è§†å›¾å¯¹è±¡DecorViewå’Œçª—å£ç®¡ç†å™¨WindowManagerï¼Œæœ€åå°†è§†å›¾å¯¹è±¡æ·»åŠ åˆ°çª—å£ç®¡ç†å™¨ä¸­ã€‚ ViewManager.addView()çœŸæ­£å®ç°çš„çš„åœ°æ–¹åœ¨WindowManagerImpl.javaä¸­ã€‚ 123456public interface ViewManager&#123;public void addView(View view, ViewGroup.LayoutParams params);public void updateViewLayout(View view, ViewGroup.LayoutParams params);public void removeView(View view);&#125; [-&gt;WindowManagerImpl.java] 12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; ...... mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125; [-&gt;WindowManagerGlobal.java] 123456789101112131415161718 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; ...... ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; ...... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; try &#123; root.setView(view, wparams, panelParentView); &#125; ......&#125; 2.5ã€ViewRootImpl()æ„é€ è¿‡ç¨‹ï¼š[ViewRootImpl.java # ViewRootImpl()] 1234567891011121314151617181920 final W mWindow; final Surface mSurface = new Surface(); final ViewRootHandler mHandler = new ViewRootHandler(); ...... public ViewRootImpl(Context context, Display display) &#123; mContext = context; mWindowSession = WindowManagerGlobal.getWindowSession();//IWindowSessionçš„ä»£ç†å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨äºå’ŒWMSé€šä¿¡ã€‚ mDisplay = display; ...... mWindow = new W(this);//åˆ›å»ºäº†ä¸€ä¸ªWæœ¬åœ°Binderå¯¹è±¡ï¼Œç”¨äºWMSé€šçŸ¥åº”ç”¨ç¨‹åºè¿›ç¨‹ ...... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); ...... mViewConfiguration = ViewConfiguration.get(context); mDensity = context.getResources().getDisplayMetrics().densityDpi; mNoncompatDensity = context.getResources().getDisplayMetrics().noncompatDensityDpi; mFallbackEventHandler = new PhoneFallbackEventHandler(context); mChoreographer = Choreographer.getInstance();//Choreographerå¯¹è±¡ ......&#125; åœ¨ViewRootImplçš„æ„é€ å‡½æ•°ä¸­åˆå§‹åŒ–äº†ä¸€äº›æˆå‘˜å˜é‡ï¼ŒViewRootImplåˆ›å»ºäº†ä»¥ä¸‹å‡ ä¸ªä¸»è¦å¯¹è±¡ï¼š (1) é€šè¿‡WindowManagerGlobal.getWindowSession()å¾—åˆ°IWindowSessionçš„ä»£ç†å¯¹è±¡ï¼Œè¯¥å¯¹è±¡ç”¨äºå’ŒWMSé€šä¿¡ã€‚ (2) åˆ›å»ºäº†ä¸€ä¸ªWæœ¬åœ°Binderå¯¹è±¡ï¼Œç”¨äºWMSé€šçŸ¥åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ (3) é‡‡ç”¨å•ä¾‹æ¨¡å¼åˆ›å»ºäº†ä¸€ä¸ªChoreographerå¯¹è±¡ï¼Œç”¨äºç»Ÿä¸€è°ƒåº¦çª—å£ç»˜å›¾ã€‚ (4) åˆ›å»ºViewRootHandlerå¯¹è±¡ï¼Œç”¨äºå¤„ç†å½“å‰è§†å›¾æ¶ˆæ¯ã€‚ (5) æ„é€ ä¸€ä¸ªAttachInfoå¯¹è±¡ï¼› (6) åˆ›å»ºSurfaceå¯¹è±¡ï¼Œç”¨äºç»˜åˆ¶å½“å‰è§†å›¾ï¼Œå½“ç„¶è¯¥Surfaceå¯¹è±¡çš„çœŸæ­£åˆ›å»ºæ˜¯ç”±WMSæ¥å®Œæˆçš„ï¼Œåªä¸è¿‡æ˜¯WMSä¼ é€’ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹çš„ã€‚ 2.6ã€IWindowSessionä»£ç†è·å–è¿‡ç¨‹[-&gt;WindowManagerGlobal.java] 12345678910111213141516171819202122232425 private static IWindowSession sWindowSession; public static IWindowSession getWindowSession() &#123; synchronized (WindowManagerGlobal.class) &#123; if (sWindowSession == null) &#123; try &#123; //è·å–è¾“å…¥æ³•ç®¡ç†å™¨ InputMethodManager imm = InputMethodManager.getInstance(); //è·å–çª—å£ç®¡ç†å™¨ IWindowManager windowManager = getWindowManagerService(); //å¾—åˆ°IWindowSessionä»£ç†å¯¹è±¡ sWindowSession = windowManager.openSession( new IWindowSessionCallback.Stub() &#123; @Override public void onAnimatorScaleChanged(float scale) &#123; ValueAnimator.setDurationScale(scale); &#125; &#125;, imm.getClient(), imm.getInputContext()); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125; &#125; return sWindowSession; &#125;&#125; ä»¥ä¸Šå‡½æ•°é€šè¿‡WMSçš„openSessionå‡½æ•°åˆ›å»ºåº”ç”¨ç¨‹åºä¸WMSä¹‹é—´çš„è¿æ¥é€šé“ï¼Œå³è·å–IWindowSessionä»£ç†å¯¹è±¡ï¼Œå¹¶å°†è¯¥ä»£ç†å¯¹è±¡ä¿å­˜åˆ°ViewRootImplçš„é™æ€æˆå‘˜å˜é‡sWindowSessionä¸­,å› æ­¤åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­æœ‰ä¸”åªæœ‰ä¸€ä¸ªIWindowSessionä»£ç†å¯¹è±¡ã€‚ [-&gt;WindowManagerService.java] 12345678@Overridepublic IWindowSession openSession(IWindowSessionCallback callback, IInputMethodClient client, IInputContext inputContext) &#123; if (client == null) throw new IllegalArgumentException(\"null client\"); if (inputContext == null) throw new IllegalArgumentException(\"null inputContext\"); Session session = new Session(this, callback, client, inputContext); return session;&#125; åœ¨WMSæœåŠ¡ç«¯æ„é€ äº†ä¸€ä¸ªSessionå®ä¾‹å¯¹è±¡ã€‚ViewRootImpl æ˜¯ä¸€å¾ˆé‡è¦çš„ç±»ï¼Œç±»ä¼¼ ActivityThread è´Ÿè´£è·ŸAmSé€šä¿¡ä¸€æ ·ï¼ŒViewRootImpl çš„ä¸€ä¸ªé‡è¦èŒè´£å°±æ˜¯è·Ÿ WmS é€šä¿¡ï¼Œå®ƒé€šé™æ€å˜é‡ sWindowSessionï¼ˆIWindowSessionå®ä¾‹ï¼‰ä¸ WmS è¿›è¡Œé€šä¿¡ã€‚æ¯ä¸ªåº”ç”¨è¿›ç¨‹ï¼Œä»…æœ‰ä¸€ä¸ª sWindowSession å¯¹è±¡ï¼Œå®ƒå¯¹åº”äº† WmS ä¸­çš„ Session å­ç±»ï¼ŒWmS ä¸ºæ¯ä¸€ä¸ªåº”ç”¨è¿›ç¨‹åˆ†é…ä¸€ä¸ª Session å¯¹è±¡ã€‚WindowState ç±»æœ‰ä¸€ä¸ª IWindow mClient å‚æ•°ï¼Œæ˜¯åœ¨æ„é€ æ–¹æ³•ä¸­èµ‹å€¼çš„ï¼Œæ˜¯ç”± Session è°ƒç”¨ addWindow ä¼ é€’è¿‡æ¥äº†ï¼Œå¯¹åº”äº† ViewRootImpl ä¸­çš„ W ç±»çš„å®ä¾‹ã€‚ 2.7ã€AttachInfoæ„é€ è¿‡ç¨‹12345678910 AttachInfo(IWindowSession session, IWindow window, Display display, ViewRootImpl viewRootImpl, Handler handler, Callbacks effectPlayer) &#123; mSession = session;//IWindowSessionä»£ç†å¯¹è±¡ï¼Œç”¨äºä¸WMSé€šä¿¡ mWindow = window;//Wå¯¹è±¡ mWindowToken = window.asBinder();//Wæœ¬åœ°Binderå¯¹è±¡ mDisplay = display; mViewRootImpl = viewRootImpl;//ViewRootImplå®ä¾‹ mHandler = handler;//ViewRootHandlerå¯¹è±¡ mRootCallbacks = effectPlayer;&#125; 2.8ã€åˆ›å»ºChoreographerå¯¹è±¡[-&gt;Choreographer.java] 123456789101112131415 // Thread local storage for the choreographer.private static final ThreadLocal&lt;Choreographer&gt; sThreadInstance = new ThreadLocal&lt;Choreographer&gt;() &#123; @Override protected Choreographer initialValue() &#123; Looper looper = Looper.myLooper(); if (looper == null) &#123; throw new IllegalStateException(\"The current thread must have a looper!\"); &#125; return new Choreographer(looper); &#125;&#125;;public static Choreographer getInstance() &#123; return sThreadInstance.get();&#125; ä¸ºè°ƒç”¨çº¿ç¨‹åˆ›å»ºä¸€ä¸ªChoreographerå®ä¾‹ï¼Œè°ƒç”¨çº¿ç¨‹å¿…é¡»å…·å¤‡æ¶ˆæ¯å¾ªç¯åŠŸèƒ½ï¼Œå› ä¸ºViewRootImplå¯¹è±¡çš„æ„é€ æ˜¯åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹çš„UIä¸»çº¿ç¨‹ä¸­æ‰§è¡Œçš„ï¼Œå› æ­¤åˆ›å»ºçš„Choreographerå¯¹è±¡å°†ä½¿ç”¨UIçº¿ç¨‹æ¶ˆæ¯é˜Ÿåˆ—ã€‚ [-&gt;Choreographer.java] 12345678910111213141516 private Choreographer(Looper looper) &#123; mLooper = looper; //åˆ›å»ºæ¶ˆæ¯å¤„ç†Handler mHandler = new FrameHandler(looper); //å¦‚æœç³»ç»Ÿä½¿ç”¨äº†Vsyncæœºåˆ¶ï¼Œåˆ™æ³¨å†Œä¸€ä¸ªFrameDisplayEventReceiveræ¥æ”¶å™¨ mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null; mLastFrameTimeNanos = Long.MIN_VALUE; //å±å¹•åˆ·æ–°å‘¨æœŸ mFrameIntervalNanos = (long)(1000000000 / getRefreshRate()); //åˆ›å»ºå›è°ƒæ•°ç»„ mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1]; //åˆå§‹åŒ–æ•°ç»„ for (int i = 0; i &lt;= CALLBACK_LAST; i++) &#123; mCallbackQueues[i] = new CallbackQueue(); &#125;&#125; FrameDisplayEventReceiverè¯¦ç»†è¿‡ç¨‹ä»¥åå†Android 7.1.2(Android N) Choreographeræœºåˆ¶å®ç°è¿‡ç¨‹åˆ†æã€‚ 2.9ã€è§†å›¾Viewæ·»åŠ è¿‡ç¨‹çª—å£ç®¡ç†å™¨WindowManagerImplä¸ºå½“å‰æ·»åŠ çš„çª—å£åˆ›å»ºå¥½å„ç§å¯¹è±¡åï¼Œè°ƒç”¨ViewRootImplçš„setViewå‡½æ•°å‘WMSæœåŠ¡æ·»åŠ ä¸€ä¸ªçª—å£å¯¹è±¡ã€‚ [-&gt;ViewRootImpl.java] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; ////å°†DecorViewä¿å­˜åˆ°ViewRootImplçš„æˆå‘˜å˜é‡mViewä¸­ mView = view; ...... mSoftInputMode = attrs.softInputMode; mWindowAttributesChanged = true; mWindowAttributesChangesFlag = WindowManager.LayoutParams.EVERYTHING_CHANGED; //åŒæ—¶å°†DecorViewä¿å­˜åˆ°mAttachInfoä¸­ mAttachInfo.mRootView = view; mAttachInfo.mScalingRequired = mTranslator != null; mAttachInfo.mApplicationScale = mTranslator == null ? 1.0f : mTranslator.applicationScale; if (panelParentView != null) &#123; mAttachInfo.mPanelParentWindowToken = panelParentView.getApplicationWindowToken(); &#125; mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ //1ï¼‰åœ¨æ·»åŠ çª—å£å‰è¿›è¡ŒUIå¸ƒå±€ requestLayout(); if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) &#123; mInputChannel = new InputChannel(); &#125; mForceDecorViewVisibility = (mWindowAttributes.privateFlags &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0; try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //2)å°†çª—å£æ·»åŠ åˆ°WMSæœåŠ¡ä¸­ï¼ŒmWindowä¸ºWæœ¬åœ°Binderå¯¹è±¡ï¼Œé€šè¿‡Binderä¼ è¾“åˆ°WMSæœåŠ¡ç«¯åï¼Œå˜ä¸ºIWindowä»£ç†å¯¹è±¡ res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); &#125; ...... //3)å»ºç«‹çª—å£æ¶ˆæ¯é€šé“ if (mInputChannel != null) &#123; if (mInputQueueCallback != null) &#123; mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); &#125; mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); &#125; ...... &#125; &#125;&#125; é€šè¿‡å‰é¢çš„åˆ†æå¯ä»¥çŸ¥é“ï¼Œç”¨æˆ·è‡ªå®šä¹‰çš„UIä½œä¸ºä¸€ä¸ªå­Viewè¢«æ·»åŠ åˆ°DecorViewä¸­ï¼Œç„¶åå°†é¡¶çº§è§†å›¾DecorViewæ·»åŠ åˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹çš„çª—å£ç®¡ç†å™¨ä¸­ï¼Œçª—å£ç®¡ç†å™¨é¦–å…ˆä¸ºå½“å‰æ·»åŠ çš„Viewåˆ›å»ºä¸€ä¸ªViewRootImplå¯¹è±¡ã€ä¸€ä¸ªå¸ƒå±€å‚æ•°å¯¹è±¡ViewGroup.LayoutParamsï¼Œç„¶åå°†è¿™ä¸‰ä¸ªå¯¹è±¡åˆ†åˆ«ä¿å­˜åˆ°å½“å‰åº”ç”¨ç¨‹åºè¿›ç¨‹çš„çª—å£ç®¡ç†å™¨WindowManagerImplä¸­ï¼Œæœ€åé€šè¿‡ViewRootImplå¯¹è±¡å°†å½“å‰è§†å›¾å¯¹è±¡æ³¨å†Œåˆ°WMSæœåŠ¡ä¸­ã€‚ ViewRootImplçš„setViewå‡½æ•°å‘WMSæœåŠ¡æ·»åŠ ä¸€ä¸ªçª—å£å¯¹è±¡è¿‡ç¨‹ï¼š (1) requestLayout()åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­è¿›è¡Œçª—å£UIå¸ƒå±€ï¼› (2) WindowSession.addToDisplay()å‘WMSæœåŠ¡æ³¨å†Œä¸€ä¸ªçª—å£å¯¹è±¡ï¼› (3) æ³¨å†Œåº”ç”¨ç¨‹åºè¿›ç¨‹ç«¯çš„æ¶ˆæ¯æ¥æ”¶é€šé“ï¼› (1)ã€requestLayout()åœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­è¿›è¡Œçª—å£UIå¸ƒå±€ï¼›2.10ã€çª—å£UIå¸ƒå±€è¿‡ç¨‹requestLayoutå‡½æ•°è°ƒç”¨é‡Œé¢ä½¿ç”¨äº†Hanlderçš„ä¸€ä¸ªå°æ‰‹æ®µï¼Œé‚£å°±æ˜¯åˆ©ç”¨postSyncBarrieræ·»åŠ äº†ä¸€ä¸ªBarrierï¼ˆæŒ¡æ¿ï¼‰ï¼Œè¿™ä¸ªæŒ¡æ¿çš„ä½œç”¨æ˜¯é˜»å¡æ™®é€šçš„åŒæ­¥æ¶ˆæ¯çš„æ‰§è¡Œï¼Œåœ¨æŒ¡æ¿è¢«æ’¤é”€ä¹‹å‰ï¼Œåªä¼šæ‰§è¡Œå¼‚æ­¥æ¶ˆæ¯ï¼Œè€ŒrequestLayoutå…ˆæ·»åŠ äº†ä¸€ä¸ªæŒ¡æ¿Barrierï¼Œä¹‹åè‡ªå·±æ’å…¥äº†ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡mTraversalRunnableï¼Œå…¶ä¸»è¦ä½œç”¨å°±æ˜¯ä¿è¯mTraversalRunnableåœ¨æ‰€æœ‰åŒæ­¥Messageä¹‹å‰è¢«æ‰§è¡Œï¼Œä¿è¯Viewç»˜åˆ¶çš„æœ€é«˜ä¼˜å…ˆçº§ã€‚å…·ä½“å®ç°å¦‚ä¸‹ï¼š 123456789101112131415161718192021@Overridepublic void requestLayout() &#123; if (!mHandlingLayoutInLayoutRequest) &#123; checkThread(); mLayoutRequested = true; scheduleTraversals(); &#125;&#125; void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); &#125;&#125; 2.10.1ã€æ·»åŠ å›è°ƒè¿‡ç¨‹[-&gt;Choreographer.java] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void postCallback(int callbackType, Runnable action, Object token) &#123; postCallbackDelayed(callbackType, action, token, 0);&#125;public void postCallbackDelayed(int callbackType, Runnable action, Object token, long delayMillis) &#123; ...... postCallbackDelayedInternal(callbackType, action, token, delayMillis);&#125;private void postCallbackDelayedInternal(int callbackType, Object action, Object token, long delayMillis) &#123; ...... synchronized (mLock) &#123; final long now = SystemClock.uptimeMillis(); final long dueTime = now + delayMillis; //å°†è¦æ‰§è¡Œçš„å›è°ƒå°è£…æˆCallbackRecordå¯¹è±¡ï¼Œä¿å­˜åˆ°mCallbackQueuesæ•°ç»„ä¸­ mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token); if (dueTime &lt;= now) &#123; scheduleFrameLocked(now); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action); msg.arg1 = callbackType; msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, dueTime); &#125; &#125;&#125; private void scheduleFrameLocked(long now) &#123; if (!mFrameScheduled) &#123; mFrameScheduled = true; if (USE_VSYNC) &#123; if (isRunningOnLooperThreadLocked()) &#123; scheduleVsyncLocked(); &#125; else &#123; Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC); msg.setAsynchronous(true); mHandler.sendMessageAtFrontOfQueue(msg); &#125; &#125; else &#123; final long nextFrameTime = Math.max( mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now); Message msg = mHandler.obtainMessage(MSG_DO_FRAME); msg.setAsynchronous(true); mHandler.sendMessageAtTime(msg, nextFrameTime); &#125; &#125;&#125; æ¶ˆæ¯å¤„ç†ï¼š 12345678910111213141516171819202122232425 private final class FrameHandler extends Handler &#123; public FrameHandler(Looper looper) &#123; super(looper); &#125; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_DO_SCHEDULE_VSYNC: doScheduleVsync(); break; &#125; &#125;&#125; void doScheduleVsync() &#123; synchronized (mLock) &#123; if (mFrameScheduled) &#123; scheduleVsyncLocked(); &#125; &#125;&#125;private void scheduleVsyncLocked() &#123; //ç”³è¯·Vsyncä¿¡å· mDisplayEventReceiver.scheduleVsync(); &#125; åœ¨è¯¥å‡½æ•°ä¸­è€ƒè™‘äº†ä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯ç³»ç»Ÿæ²¡æœ‰ä½¿ç”¨Vsyncæœºåˆ¶ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œé¦–å…ˆæ ¹æ®å±å¹•åˆ·æ–°é¢‘ç‡è®¡ç®—ä¸‹ä¸€æ¬¡åˆ·æ–°æ—¶é—´ï¼Œé€šè¿‡å¼‚æ­¥æ¶ˆæ¯æ–¹å¼å»¶æ—¶æ‰§è¡ŒdoFrame()å‡½æ•°å®ç°å±å¹•åˆ·æ–°ã€‚å¦‚æœç³»ç»Ÿä½¿ç”¨äº†Vsyncæœºåˆ¶ï¼Œå¹¶ä¸”å½“å‰çº¿ç¨‹å…·å¤‡æ¶ˆæ¯å¾ªç¯ï¼Œåˆ™ç›´æ¥è¯·æ±‚Vsyncä¿¡å·ï¼Œå¦åˆ™å°±é€šè¿‡ä¸»çº¿ç¨‹æ¥è¯·æ±‚Vsyncä¿¡å·ã€‚ 2.10.2ã€Vsyncè¯·æ±‚è¿‡ç¨‹æˆ‘ä»¬çŸ¥é“åœ¨Choreographeræ„é€ å‡½æ•°ä¸­ï¼Œæ„é€ äº†ä¸€ä¸ªFrameDisplayEventReceiverå¯¹è±¡ï¼Œç”¨äºè¯·æ±‚å¹¶æ¥æ”¶Vsyncä¿¡å·ï¼ŒVsyncä¿¡å·è¯·æ±‚è¿‡ç¨‹å¦‚ä¸‹ï¼š 1234private void scheduleVsyncLocked() &#123; //ç”³è¯·Vsyncä¿¡å· mDisplayEventReceiver.scheduleVsync(); &#125; [-&gt;DisplayEventReceiver.java] 12345678public void scheduleVsync() &#123; if (mReceiverPtr == 0) &#123; Log.w(TAG, \"Attempted to schedule a vertical sync pulse but the display event \" + \"receiver has already been disposed.\"); &#125; else &#123; nativeScheduleVsync(mReceiverPtr); &#125;&#125; [-&gt;android_view_DisplayEventReceiver.cpp ] 12345678910static void nativeScheduleVsync(JNIEnv* env, jclass clazz, jlong receiverPtr) &#123;sp&lt;NativeDisplayEventReceiver&gt; receiver = reinterpret_cast&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);status_t status = receiver-&gt;scheduleVsync();if (status) &#123; String8 message; message.appendFormat(\"Failed to schedule next vertical sync pulse. status=%d\", status); jniThrowRuntimeException(env, message.string());&#125;&#125; VSyncè¯·æ±‚è¿‡ç¨‹åˆè½¬äº¤ç»™äº†DisplayEventReceiverï¼š [-&gt;DisplayEventReceiver.cpp] 1234567status_t DisplayEventReceiver::requestNextVsync() &#123;if (mEventConnection != NULL) &#123; mEventConnection-&gt;requestNextVsync(); return NO_ERROR;&#125;return NO_INIT;&#125; è¿™é‡Œåˆé€šè¿‡IDisplayEventConnectionæ¥å£æ¥è¯·æ±‚Vsyncä¿¡å·ï¼ŒIDisplayEventConnectionå®ç°äº†Binderé€šä¿¡æ¡†æ¶ï¼Œå¯ä»¥è·¨è¿›ç¨‹è°ƒç”¨ï¼Œå› ä¸ºVsyncä¿¡å·è¯·æ±‚è¿›ç¨‹å’ŒVsyncäº§ç”Ÿè¿›ç¨‹æœ‰å¯èƒ½ä¸åœ¨åŒä¸€ä¸ªè¿›ç¨‹ç©ºé—´ï¼Œå› æ­¤è¿™é‡Œå°±å€ŸåŠ©IDisplayEventConnectionæ¥å£æ¥å®ç°ã€‚ä¸‹é¢é€šè¿‡å›¾æ¥æ¢³ç†Vsyncè¯·æ±‚çš„è°ƒç”¨æµç¨‹ï¼š éœ€è¦è¯´æ˜çš„æ˜¯/Vsync/ä¹‹é—´çš„ä»£ç æ­¤æ—¶å…¶å®è¿˜æœªæ‰§è¡Œï¼Œcall requestNextVsync()æ¥å‘Šè¯‰ç³»ç»Ÿæˆ‘è¦åœ¨ä¸‹ä¸€ä¸ªVSYNCéœ€è¦è¢«trigger. ç»§ç»­ViewRootImplçš„setViewå‡½æ•°ä¸­çš„WindowSession.addToDisplay()ã€‚ (2) ã€mWindowSession.addToDisplay()å‘WMSæœåŠ¡æ³¨å†Œä¸€ä¸ªçª—å£å¯¹è±¡ï¼›[Session.java] 1234567@Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);&#125; [WindowManagerService.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990 public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) &#123; ...... boolean reportNewConfig = false; WindowState attachedWindow = null; long origId; final int callingUid = Binder.getCallingUid(); final int type = attrs.type; synchronized(mWindowMap) &#123; ...... final DisplayContent displayContent = getDisplayContentLocked(displayId); ...... boolean addToken = false; WindowToken token = mTokenMap.get(attrs.token); AppWindowToken atoken = null; boolean addToastWindowRequiresToken = false; ...... WindowState win = new WindowState(this, session, client, token, attachedWindow, appOp[0], seq, attrs, viewVisibility, displayContent); return WindowManagerGlobal.ADD_APP_EXITING; &#125; ...... mPolicy.adjustWindowParamsLw(win.mAttrs); win.setShowToOwnerOnlyLocked(mPolicy.checkShowToOwnerOnly(attrs)); res = mPolicy.prepareAddWindowLw(win, attrs); ...... final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) &#123; win.openInputChannel(outInputChannel); &#125; ...... if (addToken) &#123; mTokenMap.put(attrs.token, token); &#125; win.attach(); mWindowMap.put(client.asBinder(), win); ...... &#125; boolean imMayMove = true; if (type == TYPE_INPUT_METHOD) &#123; win.mGivenInsetsPending = true; mInputMethodWindow = win; addInputMethodWindowToListLocked(win); imMayMove = false; &#125; else if (type == TYPE_INPUT_METHOD_DIALOG) &#123; mInputMethodDialogs.add(win); addWindowToListInOrderLocked(win, true); moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true)); imMayMove = false; &#125; else &#123; addWindowToListInOrderLocked(win, true); if (type == TYPE_WALLPAPER) &#123; mWallpaperControllerLocked.clearLastWallpaperTimeoutTime(); displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; else if (mWallpaperControllerLocked.isBelowWallpaperTarget(win)) &#123; displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER; &#125; &#125; ...... mInputMonitor.setUpdateInputWindowsNeededLw(); boolean focusChanged = false; if (win.canReceiveKeys()) &#123; focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS, false /*updateInputWindows*/); if (focusChanged) &#123; imMayMove = false; &#125; &#125; ...... mLayersController.assignLayersLocked(displayContent.getWindowList()); // Don't do layout here, the window must call // relayout to be displayed, so we'll do it there. if (focusChanged) &#123; mInputMonitor.setInputFocusLw(mCurrentFocus, false /*updateInputWindows*/); &#125; mInputMonitor.updateInputWindowsLw(false /*force*/); ...... &#125; if (reportNewConfig) &#123; sendNewConfiguration(); &#125; return res;&#125; æˆ‘ä»¬çŸ¥é“å½“åº”ç”¨ç¨‹åºè¿›ç¨‹æ·»åŠ ä¸€ä¸ªDecorViewåˆ°çª—å£ç®¡ç†å™¨æ—¶ï¼Œä¼šä¸ºå½“å‰æ·»åŠ çš„çª—å£åˆ›å»ºViewRootImplå¯¹è±¡ï¼ŒåŒæ—¶æ„é€ äº†ä¸€ä¸ªWæœ¬åœ°Binderå¯¹è±¡ï¼Œæ— è®ºæ˜¯çª—å£è§†å›¾å¯¹è±¡DecorViewè¿˜æ˜¯ViewRootImplå¯¹è±¡ï¼Œéƒ½åªæ˜¯å­˜åœ¨äºåº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­ï¼Œåœ¨æ·»åŠ çª—å£è¿‡ç¨‹ä¸­ä»…ä»…å°†è¯¥çª—å£çš„Wå¯¹è±¡ä¼ é€’ç»™WMSæœåŠ¡ï¼Œç»è¿‡Binderä¼ è¾“åï¼Œåˆ°è¾¾WMSæœåŠ¡ç«¯è¿›ç¨‹åå˜ä¸ºIWindow.Proxyä»£ç†å¯¹è±¡ï¼Œå› æ­¤è¯¥å‡½æ•°çš„å‚æ•°clientçš„ç±»å‹ä¸ºIWindow.Proxyã€‚å‚æ•°attrsçš„ç±»å‹ä¸ºWindowManager.LayoutParamsï¼Œåœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹å¯åŠ¨Activityæ—¶ï¼ŒhandleResumeActivity()å‡½æ•°é€šè¿‡WindowManager.LayoutParams l = r.window.getAttributes();æ¥å¾—åˆ°åº”ç”¨ç¨‹åºçª—å£å¸ƒå±€å‚æ•°ï¼Œç”±äºWindowManager.LayoutParamså®ç°äº†Parcelableæ¥å£ï¼Œå› æ­¤WindowManager.LayoutParamså¯¹è±¡å¯ä»¥è·¨è¿›ç¨‹ä¼ è¾“ï¼ŒWMSæœåŠ¡çš„addWindowå‡½æ•°ä¸­çš„attrså‚æ•°å°±æ˜¯åº”ç”¨ç¨‹åºè¿›ç¨‹å‘é€è¿‡æ¥çš„çª—å£å¸ƒå±€å‚æ•°ã€‚åœ¨WindowManagerImplçš„addViewå‡½æ•°ä¸­ä¸ºçª—å£å¸ƒå±€å‚æ•°è®¾ç½®äº†ç›¸åº”çš„tokenï¼Œå¦‚æœæ˜¯åº”ç”¨ç¨‹åºçª—å£ï¼Œåˆ™å¸ƒå±€å‚æ•°çš„tokenè®¾ä¸ºWæœ¬åœ°Binderå¯¹è±¡ã€‚å¦‚æœä¸æ˜¯åº”ç”¨ç¨‹åºçª—å£ï¼ŒåŒæ—¶å½“å‰çª—å£æ²¡æœ‰çˆ¶çª—å£ï¼Œåˆ™è®¾ç½®tokenä¸ºå½“å‰çª—å£çš„IApplicationToken.Proxyä»£ç†å¯¹è±¡ï¼Œå¦åˆ™è®¾ç½®ä¸ºçˆ¶çª—å£çš„IApplicationToken.Proxyä»£ç†å¯¹è±¡ï¼Œç”±äºåº”ç”¨ç¨‹åºå’ŒWMSåˆ†å±äºä¸¤ä¸ªä¸åŒçš„è¿›ç¨‹ç©ºé—´ï¼Œå› æ­¤ç»è¿‡Binderä¼ è¾“åï¼Œå¸ƒå±€å‚æ•°çš„ä»¤ç‰Œattrs.tokenå°±è½¬å˜ä¸ºIWindow.Proxyæˆ–è€…Tokenã€‚ä»¥ä¸Šå‡½æ•°é¦–å…ˆæ ¹æ®å¸ƒå±€å‚æ•°çš„tokenç­‰ä¿¡æ¯æ„é€ ä¸€ä¸ªWindowTokenå¯¹è±¡ï¼Œç„¶ååœ¨æ„é€ ä¸€ä¸ªWindowStateå¯¹è±¡ï¼Œå¹¶å°†æ·»åŠ çš„çª—å£ä¿¡æ¯è®°å½•åˆ°mTokenMapå’ŒmWindowMapå“ˆå¸Œè¡¨ä¸­ã€‚ åœ¨WMSæœåŠ¡ç«¯åˆ›å»ºäº†æ‰€éœ€å¯¹è±¡åï¼Œæ¥ç€è°ƒç”¨äº†WindowStateçš„attach()æ¥è¿›ä¸€æ­¥å®Œæˆçª—å£æ·»åŠ ã€‚ [WindowState.java] 123456void attach() &#123; if (WindowManagerService.localLOGV) Slog.v( TAG, \"Attaching \" + this + \" token=\" + mToken + \", list=\" + mToken.windows); mSession.windowAddedLocked();&#125; [Session.java] 1234567891011121314 void windowAddedLocked() &#123; if (mSurfaceSession == null) &#123; if (WindowManagerService.localLOGV) Slog.v( TAG_WM, \"First window added to \" + this + \", creating SurfaceSession\"); mSurfaceSession = new SurfaceSession(); if (SHOW_TRANSACTIONS) Slog.i( TAG_WM, \" NEW SURFACE SESSION \" + mSurfaceSession); mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) &#123; mService.dispatchNewAnimatorScaleLocked(this); &#125; &#125; mNumWindow++;&#125; SurfaceSessionå»ºç«‹è¿‡ç¨‹SurfaceSessionå¯¹è±¡æ‰¿æ‹…äº†åº”ç”¨ç¨‹åºä¸SurfaceFlingerä¹‹é—´çš„é€šä¿¡è¿‡ç¨‹ï¼Œæ¯ä¸€ä¸ªéœ€è¦ä¸SurfaceFlingerè¿›ç¨‹äº¤äº’çš„åº”ç”¨ç¨‹åºç«¯éƒ½éœ€è¦åˆ›å»ºä¸€ä¸ªSurfaceSessionå¯¹è±¡ã€‚ å®¢æˆ·ç«¯è¯·æ±‚ [SurfaceSession.java] 123public SurfaceSession() &#123; mNativeClient = nativeCreate();&#125; Javaå±‚çš„SurfaceSessionå¯¹è±¡æ„é€ è¿‡ç¨‹ä¼šé€šè¿‡JNIåœ¨nativeå±‚åˆ›å»ºä¸€ä¸ªSurfaceComposerClientå¯¹è±¡ã€‚ [android_view_SurfaceSession.cpp] 12345static jlong nativeCreate(JNIEnv* env, jclass clazz) &#123;SurfaceComposerClient* client = new SurfaceComposerClient();client-&gt;incStrong((void*)nativeCreate);return reinterpret_cast&lt;jlong&gt;(client);&#125; Javaå±‚çš„SurfaceSessionå¯¹è±¡ä¸C++å±‚çš„SurfaceComposerClientå¯¹è±¡ä¹‹é—´æ˜¯ä¸€å¯¹ä¸€å…³ç³»ã€‚ [SurfaceComposerClient.cpp] 12345678910111213SurfaceComposerClient::SurfaceComposerClient(): mStatus(NO_INIT), mComposer(Composer::getInstance())&#123;&#125;void SurfaceComposerClient::onFirstRef() &#123;//å¾—åˆ°SurfaceFlingerçš„ä»£ç†å¯¹è±¡BpSurfaceComposer sp&lt;ISurfaceComposer&gt; sm(ComposerService::getComposerService());if (sm != 0) &#123; sp&lt;ISurfaceComposerClient&gt; conn = sm-&gt;createConnection(); if (conn != 0) &#123; mClient = conn; mStatus = NO_ERROR; &#125;&#125;&#125; SurfaceComposerClientç»§æ‰¿äºRefBaseç±»ï¼Œå½“ç¬¬ä¸€æ¬¡è¢«å¼ºå¼•ç”¨æ—¶ï¼ŒonFirstRefå‡½æ•°è¢«å›è°ƒï¼Œåœ¨è¯¥å‡½æ•°ä¸­SurfaceComposerClientä¼šè¯·æ±‚SurfaceFlingerä¸ºå½“å‰åº”ç”¨ç¨‹åºåˆ›å»ºä¸€ä¸ªClientå¯¹è±¡ï¼Œä¸“é—¨æ¥æ”¶è¯¥åº”ç”¨ç¨‹åºçš„è¯·æ±‚ï¼Œåœ¨SurfaceFlingerç«¯åˆ›å»ºå¥½Clientæœ¬åœ°Binderå¯¹è±¡åï¼Œå°†è¯¥Binderä»£ç†å¯¹è±¡è¿”å›ç»™åº”ç”¨ç¨‹åºç«¯ï¼Œå¹¶ä¿å­˜åœ¨SurfaceComposerClientçš„æˆå‘˜å˜é‡mClientä¸­ã€‚ æœåŠ¡ç«¯å¤„ç† åœ¨SurfaceFlingeræœåŠ¡ç«¯ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºäº¤äº’çš„Clientå¯¹è±¡ [SurfaceFlinger.cpp] 12345678910sp&lt;ISurfaceComposerClient&gt; SurfaceFlinger::createConnection()&#123;sp&lt;ISurfaceComposerClient&gt; bclient;sp&lt;Client&gt; client(new Client(this));status_t err = client-&gt;initCheck();if (err == NO_ERROR) &#123; bclient = client;&#125;return bclient;&#125; /**************Vsync**************/ Vsyncä¿¡å·å¤„ç†ä»¥ä¸Šæ˜¯è¯·æ±‚è¿‡ç¨‹ï¼ŒFrameDisplayEventReceiverå¯¹è±¡ç”¨äºè¯·æ±‚å¹¶æ¥æ”¶Vsyncä¿¡å·ï¼Œå½“Vsyncä¿¡å·åˆ°æ¥æ—¶ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è°ƒç”¨å…¶onVsync()å‡½æ•°ï¼Œåé¢ä¼šå›è°ƒåˆ°FrameDisplayEventReceiver.runæ–¹æ³•ï¼ˆWhy â€œåŒæ­¥åˆ†å‰²æ â€ï¼Ÿå†åˆ†æï¼‰ï¼Œå†å›è°ƒå‡½æ•°ä¸­æ‰§è¡ŒdoFrame()å®ç°å±å¹•åˆ·æ–°ã€‚ å½“VSYNCä¿¡å·åˆ°è¾¾æ—¶ï¼ŒChoreographer doFrame()å‡½æ•°è¢«è°ƒç”¨ [-&gt;Choreographer.java] 1234567891011121314151617181920212223242526272829303132333435363738void doFrame(long frameTimeNanos, int frame) &#123; final long startNanos; ...... long intendedFrameTimeNanos = frameTimeNanos; //ä¿å­˜èµ·å§‹æ—¶é—´ startNanos = System.nanoTime(); //ç”±äºVsyncäº‹ä»¶å¤„ç†é‡‡ç”¨çš„æ˜¯å¼‚æ­¥æ–¹å¼ï¼Œå› æ­¤è¿™é‡Œè®¡ç®—æ¶ˆæ¯å‘é€ä¸å‡½æ•°è°ƒç”¨å¼€å§‹ä¹‹é—´æ‰€èŠ±è´¹çš„æ—¶é—´ final long jitterNanos = startNanos - frameTimeNanos; //è®¡ç®—å‡½æ•°è°ƒç”¨æœŸé—´æ‰€é”™è¿‡çš„å¸§æ•° if (jitterNanos &gt;= mFrameIntervalNanos) &#123; final long skippedFrames = jitterNanos / mFrameIntervalNanos; if (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123; Log.i(TAG, \"Skipped \" + skippedFrames + \" frames! \" + \"The application may be doing too much work on its main thread.\"); &#125; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos; frameTimeNanos = startNanos - lastFrameOffset; &#125; //å¦‚æœframeTimeNanoså°äºä¸€ä¸ªå±å¹•åˆ·æ–°å‘¨æœŸï¼Œåˆ™é‡æ–°è¯·æ±‚VSyncä¿¡å· if (frameTimeNanos &lt; mLastFrameTimeNanos) &#123; scheduleVsyncLocked(); return; &#125; mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos); mFrameScheduled = false; mLastFrameTimeNanos = frameTimeNanos; &#125; try &#123; //åˆ†åˆ«å›è°ƒCALLBACK_INPUTã€CALLBACK_ANIMATIONã€CALLBACK_TRAVERSALã€CALLBACK_COMMITäº‹ä»¶ doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos); doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos); &#125;&#125; Choreographerç±»ä¸­åˆ†åˆ«å®šä¹‰äº†CallbackRecordã€CallbackQueueå†…éƒ¨ç±»ï¼ŒCallbackQueueæ˜¯ä¸€ä¸ªæŒ‰æ—¶é—´å…ˆåé¡ºåºä¿å­˜CallbackRecordçš„å•å‘å¾ªç¯é“¾è¡¨ã€‚ åœ¨Choreographerä¸­å®šä¹‰äº†ä¸‰ä¸ªCallbackQueueé˜Ÿåˆ—ï¼Œç”¨æ•°ç»„mCallbackQueuesè¡¨ç¤ºï¼Œç”¨äºåˆ†åˆ«ä¿å­˜CALLBACK_INPUTã€CALLBACK_ANIMATIONã€CALLBACK_TRAVERSALè¿™ä¸‰ç§ç±»å‹çš„Callbackï¼Œå½“è°ƒç”¨Choreographerç±»çš„postCallback()å‡½æ•°æ—¶ï¼Œå°±æ˜¯å¾€æŒ‡å®šç±»å‹çš„CallbackQueueé˜Ÿåˆ—ä¸­é€šè¿‡addCallbackLocked()å‡½æ•°æ·»åŠ ä¸€ä¸ªCallbackRecordé¡¹ï¼šé¦–å…ˆæ„é€ ä¸€ä¸ªCallbackRecordå¯¹è±¡ï¼Œç„¶åæŒ‰æ—¶é—´å…ˆåé¡ºåºæ’å…¥åˆ°CallbackQueueé“¾è¡¨ä¸­ã€‚ä»ä»£ç æ³¨é‡Šä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“CALLBACK_INPUTæ˜¯æŒ‡è¾“å…¥å›è°ƒï¼Œè¯¥å›è°ƒä¼˜å…ˆçº§æœ€é«˜ï¼Œé¦–å…ˆå¾—åˆ°æ‰§è¡Œï¼Œè€ŒCALLBACK_TRAVERSALæ˜¯æŒ‡å¤„ç†å¸ƒå±€å’Œç»˜å›¾çš„å›è°ƒï¼Œåªæœ‰åœ¨æ‰€æœ‰å¼‚æ­¥æ¶ˆæ¯éƒ½æ‰§è¡Œå®Œåæ‰å¾—åˆ°æ‰§è¡Œï¼ŒCALLBACK_ANIMATIONæ˜¯æŒ‡åŠ¨ç”»å›è°ƒï¼Œæ¯”CALLBACK_TRAVERSALä¼˜å…ˆæ‰§è¡Œï¼Œä»doFrame()å‡½æ•°ä¸­çš„doCallbacksè°ƒç”¨å°±èƒ½å°è¯è¿™ç‚¹ã€‚ å½“Vsyncäº‹ä»¶åˆ°æ¥æ—¶ï¼Œé¡ºåºæ‰§è¡ŒCALLBACK_INPUTã€CALLBACK_ANIMATIONã€CALLBACK_TRAVERSAL å’ŒCALLBACK_COMMIT å¯¹åº”CallbackQueueé˜Ÿåˆ—ä¸­æ³¨å†Œçš„å›è°ƒã€‚ [-&gt;Choreographer.java] 12345678910111213141516171819202122232425262728293031323334353637 void doCallbacks(int callbackType, long frameTimeNanos) &#123; CallbackRecord callbacks; synchronized (mLock) &#123; final long now = System.nanoTime(); //ä»æŒ‡å®šç±»å‹çš„CallbackQueueé˜Ÿåˆ—ä¸­æŸ¥æ‰¾æ‰§è¡Œæ—¶é—´åˆ°çš„CallbackRecord callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked( now / TimeUtils.NANOS_PER_MS); ...... if (callbackType == Choreographer.CALLBACK_COMMIT) &#123; final long jitterNanos = now - frameTimeNanos; if (jitterNanos &gt;= 2 * mFrameIntervalNanos) &#123; final long lastFrameOffset = jitterNanos % mFrameIntervalNanos + mFrameIntervalNanos; mDebugPrintNextFrameTimeDelta = true; &#125; frameTimeNanos = now - lastFrameOffset; mLastFrameTimeNanos = frameTimeNanos; &#125; &#125; &#125; try &#123; for (CallbackRecord c = callbacks; c != null; c = c.next) &#123; //ç”±äºCallbackQueuesæ˜¯æŒ‰æ—¶é—´å…ˆåé¡ºåºæ’åºçš„ï¼Œå› æ­¤éå†æ‰§è¡Œæ‰€æœ‰æ—¶é—´åˆ°çš„CallbackRecord c.run(frameTimeNanos); &#125; &#125; finally &#123; synchronized (mLock) &#123; mCallbacksRunning = false; do &#123; final CallbackRecord next = callbacks.next; recycleCallbackLocked(callbacks); callbacks = next; &#125; while (callbacks != null); &#125; &#125;&#125; æˆ‘ä»¬çŸ¥é“Choreographerå¯¹å¤–æä¾›äº†ä¸¤ä¸ªæ¥å£å‡½æ•°ç”¨äºæ³¨å†ŒæŒ‡å®šçš„Callbackï¼ŒpostCallback()ç”¨äºæ³¨å†ŒRunnableå¯¹è±¡ï¼Œè€ŒpostFrameCallback()å‡½æ•°ç”¨äºæ³¨å†ŒFrameCallbackå¯¹è±¡ï¼Œæ— è®ºæ³¨å†Œçš„æ˜¯Runnableå¯¹è±¡è¿˜æ˜¯FrameCallbackå¯¹è±¡ï¼Œåœ¨CallbackRecordå¯¹è±¡ä¸­ç»Ÿä¸€è£…ç®±ä¸ºObjectç±»å‹ã€‚åœ¨æ‰§è¡Œå…¶å›è°ƒå‡½æ•°æ—¶ï¼Œå°±éœ€è¦åŒºåˆ«è¿™ä¸¤ç§å¯¹è±¡ç±»å‹ï¼Œå¦‚æœæ³¨å†Œçš„æ˜¯Runnableå¯¹è±¡ï¼Œåˆ™è°ƒç”¨å…¶run()å‡½æ•°ï¼Œå¦‚æœæ³¨å†Œçš„æ˜¯FrameCallbackå¯¹è±¡ï¼Œåˆ™è°ƒç”¨å®ƒçš„doFrame()å‡½æ•°ã€‚ 2.11ã€è§†å›¾Viewæ·»åŠ è¿‡ç¨‹ å…³äºChoreographerçš„postCallback()ç”¨æ³•åœ¨å‰é¢è¿›è¡Œäº†è¯¦ç»†çš„ä»‹ç»ï¼Œå½“Vsyncäº‹ä»¶åˆ°æ¥æ—¶ï¼ŒmTraversalRunnableå¯¹è±¡çš„run()å‡½æ•°å°†è¢«è°ƒç”¨ã€‚ mTraversalRunnableå¯¹è±¡çš„ç±»å‹ä¸ºTraversalRunnableï¼Œè¯¥ç±»å®ç°äº†Runnableæ¥å£ï¼Œåœ¨å…¶run()å‡½æ•°ä¸­è°ƒç”¨äº†doTraversal()å‡½æ•°æ¥å®Œæˆçª—å£å¸ƒå±€ã€‚ [-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324 final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125;&#125;final TraversalRunnable mTraversalRunnable = new TraversalRunnable();void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing(\"ViewAncestor\"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125;&#125; performTraversalså‡½æ•°ç›¸å½“å¤æ‚ï¼Œå…¶ä¸»è¦å®ç°ä»¥ä¸‹å‡ ä¸ªé‡è¦æ­¥éª¤ï¼š 1.æ‰§è¡Œçª—å£æµ‹é‡ï¼› 2.æ‰§è¡Œçª—å£æ³¨å†Œï¼› 3.æ‰§è¡Œçª—å£å¸ƒå±€ï¼› 4.æ‰§è¡Œçª—å£ç»˜å›¾ï¼› [-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143 private void performTraversals() &#123; ...... final View host = mView; mIsInTraversal = true; mWillDrawSoon = true; boolean windowSizeMayChange = false; boolean newSurface = false; boolean surfaceChanged = false; WindowManager.LayoutParams lp = mWindowAttributes; int desiredWindowWidth; int desiredWindowHeight; final int viewVisibility = getHostVisibility(); final boolean viewVisibilityChanged = !mFirst &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded); final boolean viewUserVisibilityChanged = !mFirst &amp;&amp; ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE)); WindowManager.LayoutParams params = null; if (mWindowAttributesChanged) &#123; mWindowAttributesChanged = false; surfaceChanged = true; params = lp; &#125; ...... /****************æ‰§è¡Œçª—å£æµ‹é‡******************/ boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw); if (layoutRequested) &#123; windowSizeMayChange |= measureHierarchy(host, lp, res, desiredWindowWidth, desiredWindowHeight); &#125; ...... /****************å‘WMSæœåŠ¡æ·»åŠ çª—å£******************/ if (mFirst || windowShouldResize || insetsChanged || viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123; ...... try &#123; ...... relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... &#125; catch (RemoteException e) &#123; &#125; ...... if (!mStopped || mReportNextDraw) &#123; ...... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...... &#125; &#125; &#125; else &#123; ...... &#125; /****************æ‰§è¡Œçª—å£å¸ƒå±€******************/ final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw); boolean triggerGlobalLayoutListener = didLayout || mAttachInfo.mRecomputeGlobalAttributes; if (didLayout) &#123; performLayout(lp, mWidth, mHeight); ...... &#125; /****************æŸ¥æ‰¾çª—å£ç„¦ç‚¹******************/ if (mFirst) &#123; ...... if (mView != null) &#123; if (!mView.hasFocus()) &#123; mView.requestFocus(View.FOCUS_FORWARD); &#125; else &#123;&#125; &#125; &#125; final boolean changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible; final boolean hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible; final boolean regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus; if (regainedFocus) &#123; mLostWindowFocus = false; &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123; mLostWindowFocus = true; &#125; if (changedVisibility || regainedFocus) &#123; // Toasts are presented as notifications - don't present them as windows as well boolean isToast = (mWindowAttributes == null) ? false : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST); if (!isToast) &#123; host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED); &#125; &#125; mFirst = false; mWillDrawSoon = false; mNewSurfaceNeeded = false; mActivityRelaunched = false; mViewVisibility = viewVisibility; mHadWindowFocus = hasWindowFocus; if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123; final boolean imTarget = WindowManager.LayoutParams .mayUseInputMethod(mWindowAttributes.flags); if (imTarget != mLastWasImTarget) &#123; mLastWasImTarget = imTarget; InputMethodManager imm = InputMethodManager.peekInstance(); if (imm != null &amp;&amp; imTarget) &#123; imm.onPreWindowFocus(mView, hasWindowFocus); imm.onPostWindowFocus(mView, mView.findFocus(), mWindowAttributes.softInputMode, !mHasHadWindowFocus, mWindowAttributes.flags); &#125; &#125; &#125; // Remember if we must report the next draw. if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123; mReportNextDraw = true; &#125; /****************æ‰§è¡Œçª—å£ç»˜åˆ¶******************/ boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible; if (!cancelDraw &amp;&amp; !newSurface) &#123; if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).startChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; performDraw(); &#125; else &#123; if (isViewVisible) &#123; // Try again scheduleTraversals(); &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123; for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123; mPendingTransitions.get(i).endChangingAnimations(); &#125; mPendingTransitions.clear(); &#125; &#125; mIsInTraversal = false;&#125; 1ã€æ‰§è¡Œçª—å£æµ‹é‡performMeasure()[-&gt;ViewRootImpl.java] 12345678 private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125; 2ã€æ‰§è¡Œçª—å£æ³¨å†ŒrelayoutWindowï¼›[-&gt;ViewRootImpl.java] 12345678910111213141516 private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException &#123; ...... int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;&#125; è¿™é‡Œé€šè¿‡å‰é¢è·å–çš„IWindowSessionä»£ç†å¯¹è±¡è¯·æ±‚WMSæœåŠ¡æ‰§è¡Œçª—å£å¸ƒå±€ï¼ŒmSurfaceæ˜¯ViewRootImplçš„æˆå‘˜å˜é‡ [-&gt;ViewRootImpl.java] 1final Surface mSurface = new Surface(); [-&gt;Surface.java] 123456/** * Create an empty surface, which will later be filled in by readFromParcel(). * @hide */public Surface() &#123;&#125; è¯¥Surfaceæ„é€ å‡½æ•°ä»…ä»…åˆ›å»ºäº†ä¸€ä¸ªç©ºSurfaceå¯¹è±¡ï¼Œå¹¶æ²¡æœ‰å¯¹è¯¥Surfaceè¿›ç¨‹nativeå±‚çš„åˆå§‹åŒ–ï¼Œåˆ°æ­¤æˆ‘ä»¬çŸ¥é“åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸ºæ¯ä¸ªçª—å£å¯¹è±¡éƒ½åˆ›å»ºäº†ä¸€ä¸ªSurfaceå¯¹è±¡ã€‚å¹¶ä¸”å°†è¯¥Surfaceé€šè¿‡è·¨è¿›ç¨‹æ–¹å¼ä¼ è¾“ç»™WMSæœåŠ¡è¿›ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œåœ¨Androidç³»ç»Ÿä¸­ï¼Œå¦‚æœä¸€ä¸ªå¯¹è±¡éœ€è¦åœ¨ä¸åŒè¿›ç¨‹é—´ä¼ è¾“ï¼Œå¿…é¡»å®ç°Parcelableæ¥å£ï¼ŒSurfaceç±»æ­£å¥½å®ç°äº†Parcelableæ¥å£ã€‚ViewRootImplé€šè¿‡IWindowSessionæ¥å£è¯·æ±‚WMSçš„å®Œæ•´è¿‡ç¨‹å¦‚ä¸‹ï¼š [-&gt;IWindowSession.java$ Proxy] 123456789101112131415161718192021/** This file is auto-generated. DO NOT MODIFY* * Original file: frameworks/base/core/java/android/view/IWindowSession.aidl*/@Override public int relayout(android.view.IWindow window, int seq, android.view.WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, android.graphics.Rect outFrame, android.graphics.Rect outOverscanInsets, android.graphics.Rect outContentInsets, android.graphics.Rect outVisibleInsets, android.graphics.Rect outStableInsets, android.graphics.Rect outOutsets, android.graphics.Rect outBackdropFrame, android.content.res.Configuration outConfig, android.view.Surface outSurface) throws android.os.RemoteException &#123;android.os.Parcel _data = android.os.Parcel.obtain();android.os.Parcel _reply = android.os.Parcel.obtain();int _result;try &#123; ...... mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0); ...... if ((0 != _reply.readInt())) &#123; outSurface.readFromParcel(_reply); &#125;&#125; finally &#123; ......&#125;return _result;&#125; ä»è¯¥å‡½æ•°çš„å®ç°å¯ä»¥çœ‹å‡ºï¼Œåº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­åˆ›å»ºçš„Surfaceå¯¹è±¡å¹¶æ²¡æœ‰ä¼ é€’åˆ°WMSæœåŠ¡è¿›ç¨‹ï¼Œåªæ˜¯è¯»å–WMSæœåŠ¡è¿›ç¨‹è¿”å›æ¥çš„Surfaceã€‚é‚£ä¹ˆWMSæœåŠ¡è¿›ç¨‹æ˜¯å¦‚ä½•å“åº”åº”ç”¨ç¨‹åºè¿›ç¨‹å¸ƒå±€è¯·æ±‚çš„å‘¢ï¼Ÿ [-&gt;IWindowSession.java$ Stub] 1234567891011121314151617181920@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException&#123;switch (code)&#123;case TRANSACTION_relayout: &#123; ...... android.view.Surface _arg15; _arg15 = new android.view.Surface(); int _result = this.relayout(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11, _arg12, _arg13, _arg14, _arg15); reply.writeNoException(); reply.writeInt(_result); ...... if ((_arg15!=null)) &#123; reply.writeInt(1); _arg15.writeToParcel(reply, android.os.Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; return true; &#125;&#125; è¯¥å‡½æ•°å¯ä»¥çœ‹å‡ºï¼ŒWMSæœåŠ¡åœ¨å“åº”åº”ç”¨ç¨‹åºè¿›ç¨‹è¯·æ±‚æ·»åŠ çª—å£æ—¶ï¼Œé¦–å…ˆåœ¨å½“å‰è¿›ç¨‹ç©ºé—´åˆ›å»ºä¸€ä¸ªSurfaceå¯¹è±¡ï¼Œç„¶åè°ƒç”¨Sessionçš„relayout()å‡½æ•°è¿›ä¸€æ­¥å®Œæˆçª—å£æ·»åŠ è¿‡ç¨‹ï¼Œæœ€åå°†WMSæœåŠ¡ä¸­åˆ›å»ºçš„Surfaceè¿”å›ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåœ¨åº”ç”¨ç¨‹åºè¿›ç¨‹å’ŒWMSæœåŠ¡è¿›ç¨‹åˆ†åˆ«åˆ›å»ºäº†ä¸€ä¸ªSurfaceå¯¹è±¡ï¼Œä½†æ˜¯ä»–ä»¬è°ƒç”¨çš„éƒ½æ˜¯Surfaceçš„æ— å‚æ„é€ å‡½æ•°ï¼Œåœ¨è¯¥æ„é€ å‡½æ•°ä¸­å¹¶æœªçœŸæ­£åˆå§‹åŒ–nativeå±‚çš„Surfaceï¼Œé‚£nativeå±‚çš„Surfaceæ˜¯åœ¨é‚£é‡Œåˆ›å»ºçš„å‘¢ï¼Ÿ [-&gt;Session.java] 1234567891011 public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, outConfig, outSurface); return res;&#125; [-&gt;WindowManagerService.java] 1234567891011121314151617181920212223242526 public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, Configuration outConfig, Surface outSurface) &#123; int result = 0; ...... if (viewVisibility == View.VISIBLE &amp;&amp; (win.mAppToken == null || !win.mAppToken.clientHidden)) &#123; result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges, oldVisibility); try &#123; result = createSurfaceControl(outSurface, result, win, winAnimator); &#125; catch (Exception e) &#123; ...... return 0; &#125; ...... &#125; else &#123; ...... &#125; ...... return result;&#125; [-&gt;WindowManagerService.java] 12345678910111213 private int createSurfaceControl(Surface outSurface, int result, WindowState win, WindowStateAnimator winAnimator) &#123; if (!win.mHasSurface) &#123; result |= RELAYOUT_RES_SURFACE_CHANGED; &#125; WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(); if (surfaceController != null) &#123; surfaceController.getSurface(outSurface); &#125; else &#123; outSurface.release(); &#125; return result;&#125; [-&gt;WindowSurfaceController.java] 123 void getSurface(Surface outSurface) &#123; outSurface.copyFrom(mSurfaceControl);&#125; [-&gt;WindowStateAnimator.java] 123456789101112 WindowSurfaceController createSurfaceLocked() &#123; ...... try &#123; ...... mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession, attrs.getTitle().toString(), width, height, format, flags, this); w.setHasSurface(true); &#125; ...... return mSurfaceController;&#125; [-&gt;WindowSurfaceController.java] 123456789101112131415public WindowSurfaceController(SurfaceSession s, String name, int w, int h, int format, int flags, WindowStateAnimator animator) &#123; mAnimator = animator; mSurfaceW = w; mSurfaceH = h; ...... if (animator.mWin.isChildWindow() &amp;&amp; animator.mWin.mSubLayer &lt; 0 &amp;&amp; animator.mWin.mAppToken != null) &#123; ...... &#125; else &#123; mSurfaceControl = new SurfaceControl( s, name, w, h, format, flags); &#125;&#125; 2.12ã€Surfaceåˆ›å»ºè¿‡ç¨‹[-&gt;SurfaceControl.java] 1234567 public SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags) throws OutOfResourcesException &#123; ...... mNativeObject = nativeCreate(session, name, w, h, format, flags); ......&#125; [-&gt;android_view_SurfaceControl.cpp] 12345678910111213static jlong nativeCreate(JNIEnv* env, jclass clazz, jobject sessionObj, jstring nameStr, jint w, jint h, jint format, jint flags) &#123;ScopedUtfChars name(env, nameStr);sp&lt;SurfaceComposerClient&gt; client(android_view_SurfaceSession_getClient(env, sessionObj));sp&lt;SurfaceControl&gt; surface = client-&gt;createSurface( String8(name.c_str()), w, h, format, flags);if (surface == NULL) &#123; jniThrowException(env, OutOfResourcesException, NULL); return 0;&#125;surface-&gt;incStrong((void *)nativeCreate);return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; è¯¥å‡½æ•°é¦–å…ˆå¾—åˆ°å‰é¢åˆ›å»ºå¥½çš„SurfaceComposerClientå¯¹è±¡ï¼Œé€šè¿‡è¯¥å¯¹è±¡å‘SurfaceFlingerç«¯çš„Clientå¯¹è±¡å‘é€åˆ›å»ºSurfaceçš„è¯·æ±‚ï¼Œæœ€åå¾—åˆ°ä¸€ä¸ªSurfaceControlå¯¹è±¡ã€‚ [-&gt;SurfaceComposerClient.cpp] 1234567891011121314151617181920sp&lt;SurfaceControl&gt; SurfaceComposerClient::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) &#123;sp&lt;SurfaceControl&gt; sur;if (mStatus == NO_ERROR) &#123; sp&lt;IBinder&gt; handle; sp&lt;IGraphicBufferProducer&gt; gbp; status_t err = mClient-&gt;createSurface(name, w, h, format, flags, &amp;handle, &amp;gbp); ALOGE_IF(err, \"SurfaceComposerClient::createSurface error %s\", strerror(-err)); if (err == NO_ERROR) &#123; sur = new SurfaceControl(this, handle, gbp); &#125;&#125;return sur;&#125; SurfaceComposerClientå°†Surfaceåˆ›å»ºè¯·æ±‚è½¬äº¤ç»™ä¿å­˜åœ¨å…¶æˆå‘˜å˜é‡ä¸­çš„Bp SurfaceComposerClientå¯¹è±¡æ¥å®Œæˆï¼Œåœ¨SurfaceFlingerç«¯çš„Clientæœ¬åœ°å¯¹è±¡ä¼šè¿”å›ä¸€ä¸ªISurfaceä»£ç†å¯¹è±¡ç»™åº”ç”¨ç¨‹åºï¼Œé€šè¿‡è¯¥ä»£ç†å¯¹è±¡ä¸ºåº”ç”¨ç¨‹åºå½“å‰åˆ›å»ºçš„Surfaceåˆ›å»ºä¸€ä¸ªSurfaceControlå¯¹è±¡ã€‚ [ISurfaceComposerClient.cpp] 1234567891011 virtual status_t createSurface(const String8&amp; name, uint32_t width, uint32_t height, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) &#123; Parcel data, reply; ...... remote()-&gt;transact(CREATE_SURFACE, data, &amp;reply); *handle = reply.readStrongBinder(); *gbp = interface_cast&lt;IGraphicBufferProducer&gt;(reply.readStrongBinder()); return reply.readInt32();&#125; [Client.cpp] MessageCreateSurfaceæ¶ˆæ¯æ˜¯ä¸“é—¨ä¸ºåº”ç”¨ç¨‹åºè¯·æ±‚åˆ›å»ºSurfaceè€Œå®šä¹‰çš„ä¸€ç§æ¶ˆæ¯ç±»å‹ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 status_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; /* * createSurface must be called from the GL thread so that it can * have access to the GL context. */ class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), result(NO_ERROR), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult(); &#125;Clientå°†åº”ç”¨ç¨‹åºåˆ›å»ºSurfaceçš„è¯·æ±‚è½¬æ¢ä¸ºå¼‚æ­¥æ¶ˆæ¯æŠ•é€’åˆ°SurfaceFlingerçš„æ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œå°†åˆ›å»ºSurfaceçš„ä»»åŠ¡è½¬äº¤ç»™SurfaceFlingerã€‚[-&gt;SurfaceFlinger.cpp] status_t SurfaceFlinger::createLayer( const String8&amp; name, const sp&lt;Client&gt;&amp; client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; //ALOGD(\"createLayer for (%d x %d), name=%s\", w, h, name.string()); ...... status_t result = NO_ERROR; sp&lt;Layer&gt; layer; ////æ ¹æ®flagsåˆ›å»ºä¸åŒç±»å‹çš„layer switch (flags &amp; ISurfaceComposerClient::eFXSurfaceMask) &#123; case ISurfaceComposerClient::eFXSurfaceNormal: result = createNormalLayer(client, name, w, h, flags, format, handle, gbp, &amp;layer); break; case ISurfaceComposerClient::eFXSurfaceDim: result = createDimLayer(client, name, w, h, flags, handle, gbp, &amp;layer); break; default: result = BAD_VALUE; break; &#125; if (result != NO_ERROR) &#123; return result; &#125; //å°†åˆ›å»ºå¥½çš„Layerå¯¹è±¡ä¿å­˜åœ¨Clientä¸­ result = addClientLayer(client, *handle, *gbp, layer); if (result != NO_ERROR) &#123; return result; &#125; setTransactionFlags(eTransactionNeeded); return result; &#125; SurfaceFlingeræ ¹æ®æ ‡å¿—ä½åˆ›å»ºå¯¹åº”ç±»å‹çš„Surfaceï¼Œå½“å‰ç³»ç»Ÿå®šä¹‰äº†2ç§ç±»å‹çš„Layer: [-&gt;ISurfaceComposerClient.h] 12eFXSurfaceNormal = 0x00000000,eFXSurfaceDim = 0x00020000, [-&gt;SurfaceFlinger.cpp] 123456789101112131415161718192021222324status_t SurfaceFlinger::createNormalLayer(const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags, PixelFormat&amp; format, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp, sp&lt;Layer&gt;* outLayer)&#123;// initialize the surfacesswitch (format) &#123;case PIXEL_FORMAT_TRANSPARENT:case PIXEL_FORMAT_TRANSLUCENT: format = PIXEL_FORMAT_RGBA_8888; break;case PIXEL_FORMAT_OPAQUE: format = PIXEL_FORMAT_RGBX_8888; break;&#125;//åœ¨SurfaceFlingerç«¯ä¸ºåº”ç”¨ç¨‹åºçš„Surfaceåˆ›å»ºå¯¹åº”çš„Layerå¯¹è±¡ *outLayer = new Layer(this, client, name, w, h, flags);status_t err = (*outLayer)-&gt;setBuffers(w, h, format, flags);if (err == NO_ERROR) &#123; *handle = (*outLayer)-&gt;getHandle(); *gbp = (*outLayer)-&gt;getProducer();&#125;ALOGE_IF(err, \"createNormalLayer() failed (%s)\", strerror(-err));return err;&#125; åœ¨SurfaceFlingeræœåŠ¡ç«¯ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºçš„Surfaceåˆ›å»ºå¯¹åº”çš„Layerå¯¹è±¡ã€‚åº”ç”¨ç¨‹åºè¯·æ±‚åˆ›å»ºSurfaceè¿‡ç¨‹å¦‚ä¸‹ï¼š ç¬¬ä¸€æ¬¡å¼ºå¼•ç”¨Layerå¯¹è±¡æ—¶ï¼ŒonFirstRef()å‡½æ•°è¢«å›è°ƒ [Layer.cpp] 123456789101112131415161718192021void Layer::onFirstRef() &#123;// Creates a custom BufferQueue for SurfaceFlingerConsumer to usesp&lt;IGraphicBufferProducer&gt; producer;sp&lt;IGraphicBufferConsumer&gt; consumer;//åˆ›å»ºBufferQueueå¯¹è±¡BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);mProducer = new MonitoredProducer(producer, mFlinger);mSurfaceFlingerConsumer = new SurfaceFlingerConsumer(consumer, mTextureName, this);mSurfaceFlingerConsumer-&gt;setConsumerUsageBits(getEffectiveUsage(0));mSurfaceFlingerConsumer-&gt;setContentsChangedListener(this);mSurfaceFlingerConsumer-&gt;setName(mName);#ifdef TARGET_DISABLE_TRIPLE_BUFFERING#warning \"disabling triple buffering\"#elsemProducer-&gt;setMaxDequeuedBufferCount(2);#endifconst sp&lt;const DisplayDevice&gt; hw(mFlinger-&gt;getDefaultDisplayDevice());updateTransformHint(hw);&#125; æ ¹æ®bufferå¯ç”¨ç›‘å¬å™¨çš„æ³¨å†Œè¿‡ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œå½“ç”Ÿäº§è€…ä¹Ÿå°±æ˜¯åº”ç”¨ç¨‹åºå¡«å……å¥½å›¾å½¢bufferæ•°æ®åï¼Œé€šè¿‡å›è°ƒæ–¹å¼é€šçŸ¥æ¶ˆè´¹è€…çš„ BufferQueueæ„é€ è¿‡ç¨‹[-&gt;BufferQueue.cpp] 1234567891011void BufferQueue::createBufferQueue(sp&lt;IGraphicBufferProducer&gt;* outProducer, sp&lt;IGraphicBufferConsumer&gt;* outConsumer, const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) &#123;......sp&lt;BufferQueueCore&gt; core(new BufferQueueCore(allocator));sp&lt;IGraphicBufferProducer&gt; producer(new BufferQueueProducer(core));sp&lt;IGraphicBufferConsumer&gt; consumer(new BufferQueueConsumer(core));*outProducer = producer;*outConsumer = consumer;&#125; [-&gt;BufferQueueCore.cpp] æ‰€ä»¥æ ¸å¿ƒéƒ½æ˜¯è¿™ä¸ªBufferQueueCoreï¼Œä»–æ˜¯ç®¡ç†å›¾å½¢ç¼“å†²åŒºçš„ä¸­æ¢ã€‚è¿™é‡Œä¸¾ä¸€ä¸ªSurfaceTextureçš„ä¾‹å­ï¼Œæ¥çœ‹çœ‹ä»–ä»¬ä¹‹é—´çš„å…³ç³»ï¼š 123456789101112131415161718192021BufferQueueCore::BufferQueueCore(const sp&lt;IGraphicBufferAlloc&gt;&amp; allocator) :mAllocator(allocator),......&#123;if (allocator == NULL) &#123; sp&lt;ISurfaceComposer&gt; composer(ComposerService::getComposerService()); mAllocator = composer-&gt;createGraphicBufferAlloc(); if (mAllocator == NULL) &#123; BQ_LOGE(\"createGraphicBufferAlloc failed\"); &#125;&#125;int numStartingBuffers = getMaxBufferCountLocked();for (int s = 0; s &lt; numStartingBuffers; s++) &#123; mFreeSlots.insert(s);&#125;for (int s = numStartingBuffers; s &lt; BufferQueueDefs::NUM_BUFFER_SLOTS; s++) &#123; mUnusedSlots.push_front(s);&#125;&#125; BufferQueueCoreç±»ä¸­å®šä¹‰äº†ä¸€ä¸ª64é¡¹çš„æ•°æ®mSlotsï¼Œæ˜¯ä¸€ä¸ªå®¹é‡å¤§å°ä¸º64çš„æ•°ç»„ï¼Œå› æ­¤BufferQueueCoreå¯ä»¥ç®¡ç†æœ€å¤š64å—çš„GraphicBufferã€‚ [-&gt;ISurfaceComposer.cpp] 1234567 virtual sp&lt;IGraphicBufferAlloc&gt; createGraphicBufferAlloc()&#123; Parcel data, reply; data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor()); remote()-&gt;transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &amp;reply); return interface_cast&lt;IGraphicBufferAlloc&gt;(reply.readStrongBinder());&#125; [-&gt;SurfaceFlinger.cpp] 12345sp&lt;IGraphicBufferAlloc&gt; SurfaceFlinger::createGraphicBufferAlloc()&#123;sp&lt;GraphicBufferAlloc&gt; gba(new GraphicBufferAlloc());return gba;&#125; GraphicBufferAllocæ„é€ è¿‡ç¨‹[-&gt;GraphicBufferAlloc.cpp] 123456789sp&lt;GraphicBuffer&gt; GraphicBufferAlloc::createGraphicBuffer(uint32_t width, uint32_t height, PixelFormat format, uint32_t usage, std::string requestorName, status_t* error) &#123;sp&lt;GraphicBuffer&gt; graphicBuffer(new GraphicBuffer( width, height, format, usage, std::move(requestorName)));status_t err = graphicBuffer-&gt;initCheck();......return graphicBuffer;&#125; å›¾å½¢ç¼“å†²åŒºåˆ›å»ºè¿‡ç¨‹[-&gt;GraphicBuffer.cpp] 1234567891011121314GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat, uint32_t inUsage, std::string requestorName): BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()), mInitCheck(NO_ERROR), mId(getUniqueId()), mGenerationNumber(0) &#123;width =height =stride =format =usage = 0;handle = NULL;mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage, std::move(requestorName)); &#125; æ ¹æ®å›¾å½¢bufferçš„å®½é«˜ã€æ ¼å¼ç­‰ä¿¡æ¯ä¸ºå›¾å½¢ç¼“å†²åŒºåˆ†é…å­˜å‚¨ç©ºé—´ã€‚ ä½¿ç”¨GraphicBufferAllocatorå¯¹è±¡æ¥ä¸ºå›¾å½¢ç¼“å†²åŒºåˆ†é…å†…å­˜ç©ºé—´ï¼ŒGraphicBufferAllocatoræ˜¯å¯¹Grallocæ¨¡å—ä¸­çš„gpuè®¾å¤‡çš„å°è£…ç±»ã€‚å…³äºGraphicBufferAllocatorå†…å­˜åˆ†é…è¿‡ç¨‹è¯·æŸ¥çœ‹Androidå›¾å½¢ç¼“å†²åŒºåˆ†é…è¿‡ç¨‹æºç åˆ†æå›¾å½¢ç¼“å†²åŒºåˆ†é…å®Œæˆåï¼Œè¿˜ä¼šæ˜ å°„åˆ°SurfaceFlingeræœåŠ¡è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚ Androidå›¾å½¢ç¼“å†²åŒºåˆ†é…è¿‡ç¨‹æºç åˆ†æ[-&gt;Layer.cpp] 123456789101112131415Layer::Layer(SurfaceFlinger* flinger, const sp&lt;Client&gt;&amp; client, const String8&amp; name, uint32_t w, uint32_t h, uint32_t flags): contentDirty(false), sequence(uint32_t(android_atomic_inc(&amp;sSequence))), mFlinger(flinger), mTextureName(-1U), mPremultipliedAlpha(true), mName(\"unnamed\"), mFormat(PIXEL_FORMAT_NONE), ......&#123;mCurrentCrop.makeInvalid();mFlinger-&gt;getRenderEngine().genTextures(1, &amp;mTextureName);mTexture.init(Texture::TEXTURE_EXTERNAL, mTextureName);......&#125; åˆ°æ­¤æ‰ç®—çœŸæ­£åˆ›å»ºäº†ä¸€ä¸ªå¯ç”¨äºç»˜å›¾çš„Surface (Layer)ï¼Œä»ä¸Šé¢çš„åˆ†ææˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œåœ¨WMSæœåŠ¡è¿›ç¨‹ç«¯ï¼Œå…¶å®åˆ›å»ºäº†ä¸¤ä¸ªJavaå±‚çš„Surfaceå¯¹è±¡ï¼Œç¬¬ä¸€ä¸ªSurfaceä½¿ç”¨äº†æ— å‚æ„é€ å‡½æ•°ï¼Œä»…ä»…æ„é€ ä¸€ä¸ªSurfaceå¯¹è±¡è€Œå·²ï¼Œè€Œç¬¬äºŒä¸ªSurfaceå´ä½¿ç”¨äº†æœ‰å‚æ„é€ å‡½æ•°ï¼Œå‚æ•°æŒ‡å®šäº†å›¾è±¡å®½é«˜ç­‰ä¿¡æ¯ï¼Œè¿™ä¸ªJavaå±‚Surfaceå¯¹è±¡è¿˜ä¼šåœ¨nativeå±‚è¯·æ±‚SurfaceFlingeråˆ›å»ºä¸€ä¸ªçœŸæ­£èƒ½ç”¨äºç»˜åˆ¶å›¾è±¡çš„nativeå±‚Surfaceã€‚æœ€åé€šè¿‡æµ…æ‹·è´çš„æ–¹å¼å°†ç¬¬äºŒä¸ªSurfaceå¤åˆ¶åˆ°ç¬¬ä¸€ä¸ªSurfaceä¸­ï¼Œæœ€åé€šè¿‡writeToParcelæ–¹å¼å†™å›åˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ 12345678910111213 public void copyFrom(SurfaceControl other) &#123; ...... long surfaceControlPtr = other.mNativeObject; ...... long newNativeObject = nativeCreateFromSurfaceControl(surfaceControlPtr); synchronized (mLock) &#123; if (mNativeObject != 0) &#123; nativeRelease(mNativeObject); &#125; setNativeObjectLocked(newNativeObject); &#125;&#125; [android_view_Surface.cpp] 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; 2å·Surfaceå¼•ç”¨åˆ°äº†3å·Surfaceçš„SurfaceControlå¯¹è±¡åï¼Œé€šè¿‡writeToParcel()å‡½æ•°å†™ä¼šåˆ°åº”ç”¨ç¨‹åºè¿›ç¨‹ã€‚ [Surface.java] 12345678910111213141516 @Overridepublic void writeToParcel(Parcel dest, int flags) &#123; if (dest == null) &#123; throw new IllegalArgumentException(\"dest must not be null\"); &#125; synchronized (mLock) &#123; // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp dest.writeString(mName); dest.writeInt(mIsSingleBuffered ? 1 : 0); nativeWriteToParcel(mNativeObject, dest); &#125; if ((flags &amp; Parcelable.PARCELABLE_WRITE_RETURN_VALUE) != 0) &#123; release(); &#125;&#125; [android_view_Surface.cpp] 12345678910111213141516static void nativeWriteToParcel(JNIEnv* env, jclass clazz, jlong nativeObject, jobject parcelObj) &#123;Parcel* parcel = parcelForJavaObject(env, parcelObj);if (parcel == NULL) &#123; doThrowNPE(env); return;&#125;sp&lt;Surface&gt; self(reinterpret_cast&lt;Surface *&gt;(nativeObject));android::view::Surface surfaceShim;if (self != nullptr) &#123; surfaceShim.graphicBufferProducer = self-&gt;getIGraphicBufferProducer();&#125;// Calling code in Surface.java has already written the name of the Surface// to the ParcelsurfaceShim.writeToParcel(parcel, /*nameAlreadyWritten*/true);&#125; åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­çš„1å·SurfaceæŒ‰ç›¸åé¡ºåºè¯»å–WMSæœåŠ¡ç«¯è¿”å›è¿‡æ¥çš„Binderå¯¹è±¡ç­‰æ•°æ®ï¼Œå¹¶æ„é€ ä¸€ä¸ªnativeå±‚çš„Surfaceå¯¹è±¡ã€‚ 1234567891011121314151617 public void readFromParcel(Parcel source) &#123; if (source == null) &#123; throw new IllegalArgumentException(\"source must not be null\"); &#125; synchronized (mLock) &#123; // nativeReadFromParcel() will either return mNativeObject, or // create a new native Surface and return it after reducing // the reference count on mNativeObject. Either way, it is // not necessary to call nativeRelease() here. // NOTE: This must be kept synchronized with the native parceling code // in frameworks/native/libs/Surface.cpp mName = source.readString(); mIsSingleBuffered = source.readInt() != 0; setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source)); &#125;&#125; åº”ç”¨ç¨‹åºè¿›ç¨‹ä¸­çš„1å·SurfaceæŒ‰ç›¸åé¡ºåºè¯»å–WMSæœåŠ¡ç«¯è¿”å›è¿‡æ¥çš„Binderå¯¹è±¡ç­‰æ•°æ®ï¼Œå¹¶æ„é€ ä¸€ä¸ªnativeå±‚çš„Surfaceå¯¹è±¡ã€‚ 123456789101112131415static jlong nativeCreateFromSurfaceControl(JNIEnv* env, jclass clazz, jlong surfaceControlNativeObj) &#123;/* * This is used by the WindowManagerService just after constructing * a Surface and is necessary for returning the Surface reference to * the caller. At this point, we should only have a SurfaceControl. */sp&lt;SurfaceControl&gt; ctrl(reinterpret_cast&lt;SurfaceControl *&gt;(surfaceControlNativeObj));sp&lt;Surface&gt; surface(ctrl-&gt;getSurface());if (surface != NULL) &#123; surface-&gt;incStrong(&amp;sRefBaseOwner);&#125;return reinterpret_cast&lt;jlong&gt;(surface.get());&#125; æ¯ä¸ªActivityå¯ä»¥æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªSurfaceï¼Œé»˜è®¤æƒ…å†µä¸‹ä¸€ä¸ªActivityåªæœ‰ä¸€ä¸ªSurfaceï¼Œå½“Activityä¸­ä½¿ç”¨SurfaceViewæ—¶ï¼Œå°±å­˜åœ¨å¤šä¸ªSurfaceã€‚Activityé»˜è®¤surfaceæ˜¯åœ¨relayoutWindowè¿‡ç¨‹ä¸­ç”±WMSæœåŠ¡åˆ›å»ºçš„ï¼Œç„¶åå›ä¼ ç»™åº”ç”¨ç¨‹åºè¿›ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“ä¸€ä¸ªSurfaceå…¶å®å°±æ˜¯åº”ç”¨ç¨‹åºç«¯çš„æœ¬åœ°çª—å£ï¼Œå…³äºSurfaceçš„åˆå§‹åŒ–è¿‡ç¨‹è¿™é‡Œå°±ä¸åœ¨ä»‹ç»ã€‚ åº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceåˆ›å»ºè¿‡ç¨‹ä»å‰é¢åˆ†æå¯çŸ¥ï¼ŒSurfaceFlingeråœ¨å¤„ç†åº”ç”¨ç¨‹åºè¯·æ±‚åˆ›å»ºSurfaceä¸­ï¼Œåœ¨SurfaceFlingeræœåŠ¡ç«¯ä»…ä»…åˆ›å»ºäº†Layerå¯¹è±¡ï¼Œé‚£ä¹ˆåº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceåœ¨ä»€ä¹ˆæ—¶å€™ã€ä»€ä¹ˆåœ°æ–¹åˆ›å»ºå‘¢ï¼Ÿ ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºå¥½äº†Layerå¯¹è±¡å¹¶è¿”å›ISurfaceçš„ä»£ç†å¯¹è±¡ç»™åº”ç”¨ç¨‹åºï¼Œåº”ç”¨ç¨‹åºé€šè¿‡è¯¥ä»£ç†å¯¹è±¡åˆ›å»ºäº†ä¸€ä¸ªSurfaceControlå¯¹è±¡ï¼ŒJavaå±‚Surfaceéœ€è¦é€šè¿‡android_view_Surface.cppä¸­çš„JNIå‡½æ•°æ¥æ“ä½œnativeå±‚çš„Surfaceï¼Œåœ¨æ“ä½œnativeå±‚Surfaceå‰ï¼Œé¦–å…ˆéœ€è¦è·å–åˆ°nativeçš„Surfaceï¼Œåº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceå°±æ˜¯åœ¨è¿™ä¸ªæ—¶å€™åˆ›å»ºçš„ã€‚ [-&gt;SurfaceControl.cpp] 12345678910sp&lt;Surface&gt; SurfaceControl::getSurface() const&#123;Mutex::Autolock _l(mLock);if (mSurfaceData == 0) &#123; // This surface is always consumed by SurfaceFlinger, so the // producerControlledByApp value doesn't matter; using false. mSurfaceData = new Surface(mGraphicBufferProducer, false);&#125;return mSurfaceData;&#125; [Surface.cpp] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Surface::Surface( const sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer, bool controlledByApp): mGraphicBufferProducer(bufferProducer), mCrop(Rect::EMPTY_RECT), mGenerationNumber(0), mSharedBufferMode(false), mAutoRefresh(false), mSharedBufferSlot(BufferItem::INVALID_BUFFER_SLOT), mSharedBufferHasBeenQueued(false), mNextFrameNumber(1) &#123;// Initialize the ANativeWindow function pointers.ANativeWindow::setSwapInterval = hook_setSwapInterval;ANativeWindow::dequeueBuffer = hook_dequeueBuffer;ANativeWindow::cancelBuffer = hook_cancelBuffer;ANativeWindow::queueBuffer = hook_queueBuffer;ANativeWindow::query = hook_query;ANativeWindow::perform = hook_perform;ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;ANativeWindow::cancelBuffer_DEPRECATED = hook_cancelBuffer_DEPRECATED;ANativeWindow::lockBuffer_DEPRECATED = hook_lockBuffer_DEPRECATED;ANativeWindow::queueBuffer_DEPRECATED = hook_queueBuffer_DEPRECATED;const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) = 0;const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) = 1;mReqWidth = 0;mReqHeight = 0;mReqFormat = 0;mReqUsage = 0;mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;mDataSpace = HAL_DATASPACE_UNKNOWN;mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;mTransform = 0;mStickyTransform = 0;mDefaultWidth = 0;mDefaultHeight = 0;mUserWidth = 0;mUserHeight = 0;mTransformHint = 0;mConsumerRunningBehind = false;mConnectedToCpu = false;mProducerControlledByApp = controlledByApp;mSwapIntervalZero = false;&#125; åœ¨åˆ›å»ºå®Œåº”ç”¨ç¨‹åºæœ¬åœ°çª—å£Surfaceåï¼Œæƒ³è¦åœ¨è¯¥Surfaceä¸Šç»˜å›¾ï¼Œé¦–å…ˆéœ€è¦ä¸ºè¯¥Surfaceåˆ†é…å›¾å½¢bufferã€‚æˆ‘ä»¬å‰é¢ä»‹ç»äº†Androidåº”ç”¨ç¨‹åºå›¾å½¢ç¼“å†²åŒºçš„åˆ†é…éƒ½æ˜¯ç”±SurfaceFlingeræœåŠ¡è¿›ç¨‹æ¥å®Œæˆï¼Œåœ¨è¯·æ±‚åˆ›å»ºSurfaceæ—¶ï¼Œåœ¨æœåŠ¡ç«¯åˆ›å»ºäº†ä¸€ä¸ªBufferQueueæœ¬åœ°Binderå¯¹è±¡ï¼Œè¯¥å¯¹è±¡è´Ÿè´£ç®¡ç†åº”ç”¨ç¨‹åºä¸€ä¸ªæœ¬åœ°çª—å£Surfaceçš„å›¾å½¢ç¼“å†²åŒºã€‚ 3ã€æ‰§è¡Œçª—å£å¸ƒå±€performLayout()[-&gt;ViewRootImpl.java] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) &#123; // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = validLayoutRequesters.get(i); Log.w(\"View\", \"requestLayout() improperly called by \" + view + \" during layout: running second layout pass\"); view.requestLayout(); &#125; measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) &#123; final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() &#123; @Override public void run() &#123; int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = finalRequesters.get(i); view.requestLayout(); &#125; &#125; &#125;);&#125; &#125; &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; mInLayout = false;&#125; 4.æ‰§è¡Œçª—å£ç»˜åˆ¶performDraw()12345678910111213[-&gt;ViewRootImpl.java] private void performDraw() &#123; ...... try &#123; draw(fullRedrawNeeded); &#125; finally &#123; mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; ...... &#125; &#125; Androidæ˜¯æ€æ ·å°†Viewç”»å‡ºæ¥çš„ï¼Ÿ [-&gt;ViewRootImpl.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 private void draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ...... mAttachInfo.mTreeObserver.dispatchOnDraw(); int xOffset = -mCanvasOffsetX; int yOffset = -mCanvasOffsetY + curScrollY; final WindowManager.LayoutParams params = mWindowAttributes; final Rect surfaceInsets = params != null ? params.surfaceInsets : null; if (surfaceInsets != null) &#123; xOffset -= surfaceInsets.left; yOffset -= surfaceInsets.top; // Offset dirty rect for surface insets. dirty.offset(surfaceInsets.left, surfaceInsets.right); &#125; boolean accessibilityFocusDirty = false; final Drawable drawable = mAttachInfo.mAccessibilityFocusDrawable; if (drawable != null) &#123; final Rect bounds = mAttachInfo.mTmpInvalRect; final boolean hasFocus = getAccessibilityFocusedRect(bounds); if (!hasFocus) &#123; bounds.setEmpty(); &#125; if (!bounds.equals(drawable.getBounds())) &#123; accessibilityFocusDirty = true; &#125; &#125; mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123; // If accessibility focus moved, always invalidate the root. boolean invalidateRoot = accessibilityFocusDirty || mInvalidateRootRequested; mInvalidateRootRequested = false; // Draw with hardware renderer. mIsAnimating = false; if (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123; mHardwareYOffset = yOffset; mHardwareXOffset = xOffset; invalidateRoot = true; &#125; if (invalidateRoot) &#123; mAttachInfo.mHardwareRenderer.invalidateRoot(); &#125; ...... if (updated) &#123; requestDrawWindow(); &#125; mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this); &#125; else &#123; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; !mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp; mAttachInfo.mHardwareRenderer.isRequested()) &#123; try &#123; mAttachInfo.mHardwareRenderer.initializeIfNeeded( mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets); &#125; catch (OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return; &#125; mFullRedrawNeeded = true; scheduleTraversals(); return; &#125; if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123; return; &#125; &#125; &#125; if (animating) &#123; mFullRedrawNeeded = true; scheduleTraversals(); &#125;&#125; å…³äºç»˜åˆ¶è¿™ä¸ªæµç¨‹å¾ˆå¤æ‚ï¼Œæˆ‘ä»¬åç»­ç« èŠ‚å†åˆ†æã€‚ å‚è€ƒåšå®¢ï¼šAndroidåº”ç”¨ç¨‹åºUIç¡¬ä»¶åŠ é€Ÿæ¸²æŸ“æŠ€æœ¯ç®€è¦ä»‹ç»å’Œå­¦ä¹ è®¡åˆ’ è¿™é‡Œæˆ‘ä»¬å› ä¸ºè¦åˆ†æSurfaceæœºåˆ¶ï¼Œæ‰€ä»¥åªåˆ†æViewRootImplçš„drawæµç¨‹ã€‚ï¼ˆå¦‚æœå¼€å¯äº†ç¡¬ä»¶åŠ é€ŸåŠŸèƒ½ï¼Œåˆ™ä¼šä½¿ç”¨hwuiç¡¬ä»¶ç»˜åˆ¶åŠŸèƒ½ï¼Œè¿™é‡Œæˆ‘ä»¬å¿½ç•¥è¿™ä¸ªï¼Œä½¿ç”¨é»˜è®¤çš„è½¯ä»¶ç»˜åˆ¶æµç¨‹drawSoftwareï¼‰ã€‚ [-&gt;ViewRootImpl.java] 1234567891011121314151617181920212223242526272829303132 private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; ...... canvas = mSurface.lockCanvas(dirty); ...... &#125; ...... try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125;...... &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; ...... return false; &#125; &#125; return true;&#125; å…ˆçœ‹çœ‹Surfaceçš„lockCanvasæ–¹æ³•ï¼š [-&gt;Surface.java] 1234567891011//mCanvas å˜é‡ç›´æ¥èµ‹å€¼private final Canvas mCanvas = new CompatibleCanvas();public Canvas lockCanvas(Rect inOutDirty) throws Surface.OutOfResourcesException, IllegalArgumentException &#123;synchronized (mLock) &#123; checkNotReleasedLocked(); ...... mLockedObject = nativeLockCanvas(mNativeObject, mCanvas, inOutDirty); return mCanvas;&#125;&#125; [-&gt;android_view_Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263static jlong nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) &#123; //è·å–javaå±‚çš„Surfaceä¿å­˜çš„longå‹å¥æŸ„sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; doThrowIAE(env); return 0;&#125;Rect dirtyRect(Rect::EMPTY_RECT);Rect* dirtyRectPtr = NULL;//è·å–javaå±‚dirty Rectçš„ä½ç½®å¤§å°ä¿¡æ¯if (dirtyRectObj) &#123; dirtyRect.left = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.left); dirtyRect.top = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.top); dirtyRect.right = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.right); dirtyRect.bottom = env-&gt;GetIntField(dirtyRectObj, gRectClassInfo.bottom); dirtyRectPtr = &amp;dirtyRect;&#125;ANativeWindow_Buffer outBuffer; //è°ƒç”¨Surfaceçš„lockæ–¹æ³•,å°†ç”³è¯·çš„å›¾å½¢ç¼“å†²åŒºèµ‹ç»™outBufferstatus_t err = surface-&gt;lock(&amp;outBuffer, dirtyRectPtr);......SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height, convertPixelFormat(outBuffer.format), outBuffer.format == PIXEL_FORMAT_RGBX_8888 ? kOpaque_SkAlphaType : kPremul_SkAlphaType);SkBitmap bitmap;//åˆ›å»ºä¸€ä¸ªSkBitmap//å›¾å½¢ç¼“å†²åŒºæ¯ä¸€è¡Œåƒç´ å¤§å°ssize_t bpr = outBuffer.stride * bytesPerPixel(outBuffer.format);bitmap.setInfo(info, bpr);if (outBuffer.width &gt; 0 &amp;&amp; outBuffer.height &gt; 0) &#123; bitmap.setPixels(outBuffer.bits);&#125; else &#123; // be safe with an empty bitmap. bitmap.setPixels(NULL);&#125;Canvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(bitmap);if (dirtyRectPtr) &#123; nativeCanvas-&gt;clipRect(dirtyRect.left, dirtyRect.top, dirtyRect.right, dirtyRect.bottom);&#125;if (dirtyRectObj) &#123; env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.left, dirtyRect.left); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.top, dirtyRect.top); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.right, dirtyRect.right); env-&gt;SetIntField(dirtyRectObj, gRectClassInfo.bottom, dirtyRect.bottom);&#125;......sp&lt;Surface&gt; lockedSurface(surface);lockedSurface-&gt;incStrong(&amp;sRefBaseOwner);return (jlong) lockedSurface.get();&#125; 12345è¿™æ®µä»£ç é€»è¾‘ä¸»è¦å¦‚ä¸‹ï¼š 1ï¼‰è·å–javaå±‚dirty çš„Rectå¤§å°å’Œä½ç½®ä¿¡æ¯ï¼› 2ï¼‰è°ƒç”¨Surfaceçš„lockæ–¹æ³•,å°†ç”³è¯·çš„å›¾å½¢ç¼“å†²åŒºèµ‹ç»™outBufferï¼› 3ï¼‰åˆ›å»ºä¸€ä¸ªSkbitmapï¼Œå¡«å……å®ƒç”¨æ¥ä¿å­˜ç”³è¯·çš„å›¾å½¢ç¼“å†²åŒºï¼Œå¹¶èµ‹å€¼ç»™Javaå±‚çš„Canvaså¯¹è±¡ï¼› 4ï¼‰å°†å‰ªè£ä½ç½®å¤§å°ä¿¡æ¯èµ‹ç»™javaå±‚Canvaså¯¹è±¡ã€‚ unlockCanvasAndPost()Surfaceç»˜åˆ¶å®Œæ¯•åï¼ŒunlockCanvasAndPostæ“ä½œã€‚ [-&gt;android_view_Surface.cpp] 1234567891011121314151617static void nativeUnlockCanvasAndPost(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj) &#123;sp&lt;Surface&gt; surface(reinterpret_cast&lt;Surface *&gt;(nativeObject));if (!isSurfaceValid(surface)) &#123; return;&#125;// detach the canvas from the surfaceCanvas* nativeCanvas = GraphicsJNI::getNativeCanvas(env, canvasObj);nativeCanvas-&gt;setBitmap(SkBitmap());// unlock surfacestatus_t err = surface-&gt;unlockAndPost();if (err &lt; 0) &#123; doThrowIAE(env);&#125;&#125; Surfaceç®¡ç†å›¾å½¢ç¼“å†²åŒºæˆ‘ä»¬ä¸Šè¾¹åˆ†æåˆ°äº†ç”³è¯·å›¾å½¢ç¼“å†²åŒºï¼Œç”¨åˆ°äº†Surfaceçš„lockå‡½æ•°ï¼Œæˆ‘ä»¬ç»§ç»­æŸ¥çœ‹ã€‚ [-&gt;Surface.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384status_t Surface::lock( ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds) &#123;......ANativeWindowBuffer* out;int fenceFd = -1;//è°ƒç”¨dequeueBufferå‡½æ•°ï¼Œç”³è¯·å›¾å½¢ç¼“å†²åŒºstatus_t err = dequeueBuffer(&amp;out, &amp;fenceFd);ALOGE_IF(err, \"dequeueBuffer failed (%s)\", strerror(-err));if (err == NO_ERROR) &#123; //è·å–å›¾å½¢ç¼“å†²åŒºåŒºåŸŸå¤§å°,èµ‹ç»™åå¤‡ç¼“å†²åŒºå˜é‡backBuffer sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out)); const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height); Region newDirtyRegion; if (inOutDirtyBounds) &#123; //å¦‚æœä¸Šå±‚æŒ‡å®šä¹åˆ·æ–°è„çŸ©å½¢åŒºåŸŸï¼Œåˆ™ç”¨è¿™ä¸ªåŒºåŸŸå’Œç¼“å†²åŒºåŒºåŸŸæ±‚äº¤é›†ï¼Œ //ç„¶åå°†äº¤é›†çš„ç»“æœè®¾ç»™éœ€è¦å»åˆ·æ–°çš„æ–°åŒºåŸŸ newDirtyRegion.set(static_cast&lt;Rect const&amp;&gt;(*inOutDirtyBounds)); newDirtyRegion.andSelf(bounds); &#125; else &#123; /å¦‚æœä¸Šå±‚æ²¡æœ‰æŒ‡å®šè„çŸ©å½¢åŒºåŸŸï¼Œæ‰€ä»¥åˆ·æ–°æ•´ä¸ªå›¾å½¢ç¼“å†²åŒº newDirtyRegion.set(bounds); &#125; // figure out if we can copy the frontbuffer back //ä¸Šä¸€æ¬¡ç»˜åˆ¶çš„ä¿¡æ¯ä¿å­˜åœ¨mPostedBufferä¸­ï¼Œè€Œè¿™ä¸ªmPostedBufferåˆ™è¦åœ¨unLockAndPostå‡½æ•°ä¸­è®¾ç½® int backBufferSlot(getSlotFromBufferLocked(backBuffer.get())); const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer); const bool canCopyBack = (frontBuffer != 0 &amp;&amp; backBuffer-&gt;width == frontBuffer-&gt;width &amp;&amp; backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp; backBuffer-&gt;format == frontBuffer-&gt;format); if (canCopyBack) &#123; Mutex::Autolock lock(mMutex); Region oldDirtyRegion; if(mSlots[backBufferSlot].dirtyRegion.isEmpty()) &#123; oldDirtyRegion.set(bounds); &#125; else &#123; for(int i = 0 ; i &lt; NUM_BUFFER_SLOTS; i++ ) &#123; if(i != backBufferSlot &amp;&amp; !mSlots[i].dirtyRegion.isEmpty()) oldDirtyRegion.orSelf(mSlots[i].dirtyRegion); &#125; &#125; const Region copyback(oldDirtyRegion.subtract(newDirtyRegion)); if (!copyback.isEmpty()) //è¿™é‡ŒæŠŠmPostedBufferä¸­çš„æ—§æ•°æ®æ‹·è´åˆ°BackBufferä¸­ã€‚ //åç»­çš„ç»˜ç”»åªè¦æ›´æ–°è„åŒºåŸŸå°±å¯ä»¥äº†ï¼Œè¿™ä¼šèŠ‚çº¦ä¸å°‘èµ„æº copyBlt(backBuffer, frontBuffer, copyback); &#125; else &#123; // if we can't copy-back anything, modify the user's dirty // region to make sure they redraw the whole buffer //å¦‚æœä¸¤æ¬¡å›¾å½¢ç¼“å†²åŒºå¤§å°ä¸ä¸€è‡´ï¼Œæˆ‘ä»¬å°±è¦ä¿®æ”¹ç”¨æˆ·æŒ‡å®šçš„dirtyåŒºåŸŸå¤§å°ä¸ºæ•´ä¸ªç¼“å†²åŒºå¤§å°ï¼Œ //ç„¶åå»æ›´æ–°æ•´ä¸ªç¼“å†²åŒº newDirtyRegion.set(bounds); Mutex::Autolock lock(mMutex); for (size_t i=0 ; i&lt;NUM_BUFFER_SLOTS ; i++) &#123; mSlots[i].dirtyRegion.clear(); &#125; &#125; &#123; // scope for the lock Mutex::Autolock lock(mMutex); //å°†æ–°çš„dirtyèµ‹ç»™è¿™ä¸ªbufferslot mSlots[backBufferSlot].dirtyRegion = newDirtyRegion; &#125; if (inOutDirtyBounds) &#123; *inOutDirtyBounds = newDirtyRegion.getBounds(); &#125; void* vaddr; //lockå’Œunlockåˆ†åˆ«ç”¨æ¥é”å®šå’Œè§£é”ä¸€ä¸ªæŒ‡å®šçš„å›¾å½¢ç¼“å†²åŒºï¼Œåœ¨è®¿é—®ä¸€å—å›¾å½¢ç¼“å†²åŒºçš„æ—¶å€™ï¼Œ //ä¾‹å¦‚ï¼Œå‘ä¸€å—å›¾å½¢ç¼“å†²å†™å…¥å†…å®¹çš„æ—¶å€™ï¼Œéœ€è¦å°†è¯¥å›¾å½¢ç¼“å†²åŒºé”å®šï¼Œç”¨æ¥é¿å…è®¿é—®å†²çª, //é”å®šä¹‹åï¼Œå°±å¯ä»¥è·å¾—ç”±å‚æ•°å‚æ•°lã€tã€wå’Œhæ‰€åœˆå®šçš„ä¸€å—ç¼“å†²åŒºçš„èµ·å§‹åœ°å€ï¼Œä¿å­˜åœ¨è¾“å‡ºå‚æ•°vaddrä¸­ status_t res = backBuffer-&gt;lockAsync( GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN, newDirtyRegion.bounds(), &amp;vaddr, fenceFd); ......&#125;return err;&#125; Surfaceçš„lockå‡½æ•°ç”¨æ¥ç”³è¯·å›¾å½¢ç¼“å†²åŒºå’Œä¸€äº›æ“ä½œï¼Œæ–¹æ³•ä¸é•¿ï¼Œå¤§æ¦‚å·¥ä½œæœ‰ï¼š 1ï¼‰è°ƒç”¨connectå‡½æ•°å®Œæˆä¸€äº›åˆå§‹åŒ–ï¼› 2ï¼‰è°ƒç”¨dequeueBufferå‡½æ•°ï¼Œç”³è¯·å›¾å½¢ç¼“å†²åŒºï¼› 3ï¼‰è®¡ç®—éœ€è¦ç»˜åˆ¶çš„æ–°çš„dirtyåŒºåŸŸï¼Œæ—§çš„åŒºåŸŸåŸæ ·copyæ•°æ®ã€‚ [-&gt;BufferQueueProducer.cpp] 123456789101112131415161718192021222324252627int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) &#123;uint32_t reqWidth;uint32_t reqHeight;PixelFormat reqFormat;uint32_t reqUsage;&#123; ......//ç”³è¯·å›¾å½¢ç¼“å†²åŒºstatus_t result = mGraphicBufferProducer-&gt;dequeueBuffer(&amp;buf, &amp;fence, reqWidth, reqHeight, reqFormat, reqUsage);......//æ ¹æ®indexè·å–ç¼“å†²åŒºsp&lt;GraphicBuffer&gt;&amp; gbuf(mSlots[buf].buffer);......if ((result &amp; IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION) || gbuf == 0) &#123; //ç”±äºç”³è¯·çš„å†…å­˜æ˜¯åœ¨surfaceflingerè¿›ç¨‹ä¸­ï¼Œ //BufferQueueä¸­çš„å›¾å½¢ç¼“å†²åŒºä¹Ÿæ˜¯é€šè¿‡åŒ¿åå…±äº«å†…å­˜å’Œbinderä¼ é€’æè¿°ç¬¦æ˜ å°„è¿‡å»çš„ï¼Œ //Surfaceé€šè¿‡è°ƒç”¨requestBufferå°†å›¾å½¢ç¼“å†²åŒºæ˜ å°„åˆ°Surfaceæ‰€åœ¨è¿›ç¨‹ result = mGraphicBufferProducer-&gt;requestBuffer(buf, &amp;gbuf); ......&#125;......//è·å–è¿™ä¸ªè¿™ä¸ªbufferå¯¹è±¡çš„æŒ‡é’ˆå†…å®¹*buffer = gbuf.get();......return OK;&#125; [-&gt;BufferQueueProducer.cpp] 12345678910status_t BufferQueueProducer::requestBuffer(int slot, sp&lt;GraphicBuffer&gt;* buf) &#123;ATRACE_CALL();Mutex::Autolock lock(mCore-&gt;mMutex);......mSlots[slot].mRequestBufferCalled = true;*buf = mSlots[slot].mGraphicBuffer;return NO_ERROR;&#125; è¿™ä¸ªæ¯”è¾ƒç®€å•ï¼Œè¿˜æ˜¯å¾ˆå¥½ç†è§£çš„é¢ï¼Œå°±æ˜¯æ ¹æ®æŒ‡å®šindexå–å‡ºmSlotsä¸­çš„slotä¸­çš„bufferã€‚ å›¾å½¢ç¼“å†²åŒºå…¥é˜Ÿæˆ‘ä»¬å‰é¢è®²äº†ï¼Œçœç•¥äº†ç¬¬äºŒæ­¥ç»˜åˆ¶æµç¨‹ï¼Œå› æ­¤æˆ‘ä»¬è¿™é‡Œåˆ†æç¬¬ä¸‰éƒ¨ï¼Œç»˜åˆ¶å®Œæ¯•åå†queueBufferã€‚ åŒæ ·ï¼Œè°ƒç”¨äº†Surfaceçš„unlockCanvasAndPostå‡½æ•°ï¼Œæˆ‘ä»¬æŸ¥çœ‹å®ƒçš„å®ç°ï¼š [-&gt;Surface.cpp] 123456789101112131415status_t Surface::unlockAndPost()&#123;......int fd = -1;//è§£é”å›¾å½¢ç¼“å†²åŒºï¼Œå’Œå‰é¢çš„lockAsyncæˆå¯¹å‡ºç°status_t err = mLockedBuffer-&gt;unlockAsync(&amp;fd);//queueBufferå»å½’è¿˜å›¾å½¢ç¼“å†²åŒºerr = queueBuffer(mLockedBuffer.get(), fd);mPostedBuffer = mLockedBuffer;mLockedBuffer = 0;return err;&#125; è¿™é‡Œä¹Ÿæ¯”è¾ƒç®€å•ï¼Œæ ¸å¿ƒä¹Ÿæ˜¯åˆ†ä¸¤æ­¥ï¼š 1ï¼‰è§£é”å›¾å½¢ç¼“å†²åŒºï¼Œå’Œå‰é¢çš„lockAsyncæˆå¯¹å‡ºç°ï¼› 2ï¼‰queueBufferå»å½’è¿˜å›¾å½¢ç¼“å†²åŒºï¼› æ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯é‡ç‚¹åˆ†æç¬¬äºŒæ­¥ï¼ŒæŸ¥çœ‹queueBufferçš„å®ç°ï¼š [-&gt;Surface.cpp] 1234567int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) &#123;......status_t err = mGraphicBufferProducer-&gt;queueBuffer(i, input, &amp;output);mLastQueueDuration = systemTime() - now;......return err;&#125; è°ƒç”¨BufferQueueProducerçš„queueBufferå½’è¿˜ç¼“å†²åŒºï¼Œå°†ç»˜åˆ¶åçš„å›¾å½¢ç¼“å†²åŒºqueueå›å»ã€‚ [-&gt;BufferQueueProducer.cpp] 1234567891011121314151617181920status_t BufferQueueProducer::queueBuffer(int slot, const QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;......&#123; // scope for the lock Mutex::Autolock lock(mCallbackMutex); while (callbackTicket != mCurrentCallbackTicket) &#123; mCallbackCondition.wait(mCallbackMutex); &#125; if (frameAvailableListener != NULL) &#123; frameAvailableListener-&gt;onFrameAvailable(item); &#125; else if (frameReplacedListener != NULL) &#123; frameReplacedListener-&gt;onFrameReplaced(item); &#125; ......&#125;......return NO_ERROR;&#125; æ€»ç»“ï¼š 1ï¼‰ä»ä¼ å…¥çš„QueueBufferInput ï¼Œè§£æå¡«å……ä¸€äº›å˜é‡ï¼› 2ï¼‰æ”¹å˜å…¥é˜ŸSlotçš„çŠ¶æ€ä¸ºQUEUEDï¼Œæ¯æ¬¡æ¨è¿›æ¥ï¼ŒmFrameCounteréƒ½åŠ 1ã€‚è¿™é‡Œçš„slotï¼Œä¸Šä¸€ç¯‡è®²åˆ†é…ç¼“å†²åŒºè¿”å›æœ€è€çš„FREEçŠ¶æ€bufferï¼Œå°±æ˜¯ç”¨è¿™ä¸ªmFrameCounteræœ€å°å€¼åˆ¤æ–­ï¼Œå°±æ˜¯ä¸Šä¸€ç¯‡LRUç®—æ³•çš„åˆ¤æ–­ï¼› 3ï¼‰åˆ›å»ºä¸€ä¸ªBufferItemæ¥æè¿°GraphicBufferï¼Œç”¨mSlots[slot]ä¸­çš„slotå¡«å……BufferItemï¼› 4ï¼‰å°†BufferItemå¡è¿›mCoreçš„mQueueé˜Ÿåˆ—ï¼Œä¾ç…§æŒ‡å®šè§„åˆ™ï¼› 5ï¼‰ç„¶åé€šçŸ¥SurfaceFlingerå»æ¶ˆè´¹ã€‚ ä¸Šè¿°lockCanvaså’ŒunlockCanvasAndPostå¯ä»¥ç”¨ä¸‹å›¾æ¥æ€»ç»“ä¸€ä¸‹ï¼š é€šçŸ¥SFæ¶ˆè´¹åˆæˆ å½“ç»˜åˆ¶å®Œæ¯•çš„GraphicBufferå…¥é˜Ÿä¹‹åï¼Œä¼šé€šçŸ¥SurfaceFlingerå»æ¶ˆè´¹ï¼Œå°±æ˜¯BufferQueueProducerçš„queueBufferå‡½æ•°çš„æœ€åå‡ è¡Œï¼Œlistener-&gt;onFrameAvailable()ã€‚ listeneræœ€ç»ˆé€šè¿‡å›è°ƒï¼Œä¼šå›åˆ°Layerå½“ä¸­ï¼Œæ‰€ä»¥æœ€ç»ˆè°ƒç”¨Layerçš„onFrameAvailableæ¥å£ï¼Œæˆ‘ä»¬çœ‹çœ‹å®ƒçš„å®ç°ï¼š [Layer.cpp] 123456789101112void Layer::onFrameAvailable(const BufferItem&amp; item) &#123;// Add this buffer from our internal queue tracker&#123; // Autolock scope ...... mQueueItems.push_back(item); android_atomic_inc(&amp;mQueuedFrames); // Wake up any pending callbacks mLastFrameNumberReceived = item.mFrameNumber; mQueueItemCondition.broadcast();&#125;mFlinger-&gt;signalLayerUpdate();&#125; è¿™é‡Œåˆè°ƒç”¨SurfaceFlingerçš„signalLayerUpdateå‡½æ•°ï¼Œç»§ç»­æŸ¥çœ‹ï¼š [SurfaceFlinger.cpp] 123void SurfaceFlinger::signalLayerUpdate() &#123;mEventQueue.invalidate();&#125; è¿™é‡Œåˆè°ƒç”¨MessageQueueçš„invalidateå‡½æ•°ï¼š [MessageQueue.cpp] 123void MessageQueue::invalidate() &#123;mEvents-&gt;requestNextVsync();&#125; è´´ä¸€ä¸‹SurfaceFlingerçš„åˆå§‹åŒ–è¯·æ±‚vsyncä¿¡å·æµç¨‹å›¾ï¼š æœ€ç»ˆç»“æœä¼šèµ°åˆ°SurfaceFlingerçš„vsyncä¿¡å·æ¥æ”¶é€»è¾‘ï¼Œå³SurfaceFlingerçš„onMessageReceivedå‡½æ•°ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930void SurfaceFlinger::onMessageReceived(int32_t what) &#123;ATRACE_CALL();switch (what) &#123; case MessageQueue::INVALIDATE: &#123; bool frameMissed = !mHadClientComposition &amp;&amp; mPreviousPresentFence != Fence::NO_FENCE &amp;&amp; mPreviousPresentFence-&gt;getSignalTime() == INT64_MAX; ATRACE_INT(\"FrameMissed\", static_cast&lt;int&gt;(frameMissed)); if (mPropagateBackpressure &amp;&amp; frameMissed) &#123; signalLayerUpdate(); break; &#125; bool refreshNeeded = handleMessageTransaction(); refreshNeeded |= handleMessageInvalidate(); refreshNeeded |= mRepaintEverything; if (refreshNeeded) &#123; // Signal a refresh if a transaction modified the window state, // a new buffer was latched, or if HWC has requested a full // repaint signalRefresh(); &#125; break; &#125; case MessageQueue::REFRESH: &#123; handleMessageRefresh(); break; &#125;&#125;&#125; SurfaceFlingeræ”¶åˆ°äº†VSyncä¿¡å·åï¼Œè°ƒç”¨äº†handleMessageRefreshå‡½æ•° [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627void SurfaceFlinger::handleMessageRefresh() &#123;ATRACE_CALL();nsecs_t refreshStartTime = systemTime(SYSTEM_TIME_MONOTONIC);preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime);mPreviousPresentFence = mHwc-&gt;getRetireFence(HWC_DISPLAY_PRIMARY);mHadClientComposition = false;for (size_t displayId = 0; displayId &lt; mDisplays.size(); ++displayId) &#123; const sp&lt;DisplayDevice&gt;&amp; displayDevice = mDisplays[displayId]; mHadClientComposition = mHadClientComposition || mHwc-&gt;hasClientComposition(displayDevice-&gt;getHwcDisplayId());&#125;// Release any buffers which were replaced this framefor (auto&amp; layer : mLayersWithQueuedFrames) &#123; layer-&gt;releasePendingBuffer();&#125;mLayersWithQueuedFrames.clear();&#125; æˆ‘ä»¬ä¸»è¦çœ‹ä¸‹ä¸‹é¢å‡ ä¸ªå‡½æ•°ã€‚ [SurfaceFlinger.cpp] 123456preComposition();rebuildLayerStacks();setUpHWComposer();doDebugFlashRegions();doComposition();postComposition(refreshStartTime); ä¸€ã€preComposition()å‡½æ•°æˆ‘ä»¬å…ˆæ¥çœ‹ç¬¬ä¸€ä¸ªå‡½æ•°preComposition() [SurfaceFlinger.cpp] 1234567891011121314void SurfaceFlinger::preComposition()&#123;bool needExtraInvalidate = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);const size_t count = layers.size();for (size_t i=0 ; i&lt;count ; i++) &#123; if (layers[i]-&gt;onPreComposition()) &#123; needExtraInvalidate = true; &#125;&#125;if (needExtraInvalidate) &#123; signalLayerUpdate();&#125;&#125; ä¸Šé¢å‡½æ•°å…ˆæ˜¯è°ƒç”¨äº†mDrawingStateçš„layersSortedByZæ¥å¾—åˆ°ä¸Šæ¬¡ç»˜å›¾çš„Layerå±‚åˆ—è¡¨ã€‚å¹¶ä¸æ˜¯æ‰€æœ‰çš„Layeréƒ½ä¼šå‚ä¸å±å¹•å›¾åƒçš„ç»˜åˆ¶ï¼Œå› æ­¤SurfaceFlingerç”¨stateå¯¹è±¡æ¥è®°å½•å‚ä¸ç»˜åˆ¶çš„Layerå¯¹è±¡ã€‚ è®°å¾—æˆ‘ä»¬ä¹‹å‰åˆ†æè¿‡createLayerå‡½æ•°æ¥åˆ›å»ºLayerï¼Œåˆ›å»ºä¹‹åä¼šè°ƒç”¨addClientLayerå‡½æ•°ã€‚ [SurfaceFlinger.cpp] 1234567891011121314151617181920status_t SurfaceFlinger::addClientLayer(const sp&lt;Client&gt;&amp; client, const sp&lt;IBinder&gt;&amp; handle, const sp&lt;IGraphicBufferProducer&gt;&amp; gbc, const sp&lt;Layer&gt;&amp; lbc) &#123;// add this layer to the current state list&#123; Mutex::Autolock _l(mStateLock); if (mCurrentState.layersSortedByZ.size() &gt;= MAX_LAYERS) &#123; return NO_MEMORY; &#125; mCurrentState.layersSortedByZ.add(lbc); mGraphicBufferProducerList.add(IInterface::asBinder(gbc));&#125;// attach this layer to the clientclient-&gt;attachLayer(handle, lbc);return NO_ERROR;&#125; æˆ‘ä»¬æ¥çœ‹ä¸‹addClientLayerå‡½æ•°ï¼Œè¿™é‡Œä¼šæŠŠLayerå¯¹è±¡æ”¾åœ¨mCurrentStateçš„layersSortedByZå¯¹è±¡ä¸­ã€‚è€ŒmDrawingStateå’ŒmCurrentStateä»€ä¹ˆå…³ç³»å‘¢ï¼Ÿåœ¨åé¢æˆ‘ä»¬ä¼šä»‹ç»ï¼ŒmDrawingStateä»£è¡¨ä¸Šä¸€æ¬¡ç»˜å›¾æ—¶çš„çŠ¶æ€ï¼Œå¤„ç†å®Œä¹‹åä¼šæŠŠmCurrentStateèµ‹ç»™mDrawingStateã€‚ å›åˆ°preCompositionå‡½æ•°ï¼Œéå†æ‰€æœ‰çš„Layerå¯¹è±¡ï¼Œè°ƒç”¨å…¶onPreCompositionå‡½æ•°æ¥æ£€æµ‹Layerå±‚ä¸­çš„å›¾åƒæ˜¯å¦æœ‰å˜åŒ–ã€‚ 1.1ã€æ¯ä¸ªLayerçš„onFrameAvailableå‡½æ•°onPreCompositionå‡½æ•°æ¥æ ¹æ®mQueuedFramesæ¥åˆ¤æ–­å›¾åƒæ˜¯å¦å‘ç”Ÿäº†å˜åŒ–ï¼Œæˆ–è€…æ˜¯mSidebandStreamChangedã€mAutoRefreshã€‚ [Layer.cpp] 1234bool Layer::onPreComposition() &#123;mRefreshPending = false;return mQueuedFrames &gt; 0 || mSidebandStreamChanged || mAutoRefresh;&#125; å½“Layeræ‰€å¯¹åº”çš„Surfaceæ›´æ–°å›¾åƒåï¼Œå®ƒæ‰€å¯¹åº”çš„Layerå¯¹è±¡çš„onFrameAvailableå‡½æ•°ä¼šè¢«è°ƒç”¨æ¥é€šçŸ¥è¿™ç§å˜åŒ–ã€‚ åœ¨SurfaceFlingerçš„preCompositionå‡½æ•°ä¸­å½“æœ‰Layerçš„å›¾åƒæ”¹å˜äº†ï¼Œæœ€åä¹Ÿä¼šè°ƒç”¨SurfaceFlingerçš„signalLayerUpdateå‡½æ•°ã€‚ SurfaceFlinger::signalLayerUpdateæ˜¯è°ƒç”¨äº†MessageQueueçš„invalidateå‡½æ•° æœ€åå¤„ç†è¿˜æ˜¯è°ƒç”¨äº†SurfaceFlingerçš„onMessageReceivedå‡½æ•°ã€‚çœ‹çœ‹SurfaceFlingerçš„onMessageReceivedå‡½æ•°å¯¹NVALIDATEçš„å¤„ç† handleMessageInvalidateå‡½æ•°ä¸­è°ƒç”¨äº†handlePageFlipå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å°†ä¼šå¤„ç†Layerä¸­çš„ç¼“å†²åŒºï¼ŒæŠŠæ›´æ–°è¿‡çš„å›¾åƒç¼“å†²åŒºåˆ‡æ¢åˆ°å‰å°ï¼Œç­‰å¾…VSyncä¿¡å·æ›´æ–°åˆ°FrameBufferã€‚ 1.2ã€ç»˜åˆ¶æµç¨‹å…·ä½“å®Œæ•´çš„ç»˜åˆ¶æµç¨‹å¦‚å›¾ã€‚ äºŒã€handleTransaction handPageFlipæ›´æ–°Layerå¯¹è±¡åœ¨ä¸Šä¸€èŠ‚ä¸­çš„ç»˜å›¾çš„æµç¨‹ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†handleTransactionå’ŒhandPageFlipè¿™ä¸¤ä¸ªå‡½æ•°é€šå¸¸æ˜¯åœ¨ç”¨æˆ·è¿›ç¨‹æ›´æ–°Surfaceå›¾åƒæ—¶ä¼šè°ƒç”¨ï¼Œæ¥æ›´æ–°Layerå¯¹è±¡ã€‚è¿™èŠ‚å°±ä¸»è¦è®²è§£è¿™ä¸¤ä¸ªå‡½æ•°ã€‚ 2.1ã€handleTransactionå‡½æ•°handleTransactionå‡½æ•°çš„å‚æ•°æ˜¯transactionFlagsï¼Œä¸è¿‡å‡½æ•°ä¸­æ²¡æœ‰ä½¿ç”¨è¿™ä¸ªå‚æ•°ï¼Œè€Œæ˜¯é€šè¿‡getTransactionFlags(eTransactionMask)æ¥é‡æ–°å¯¹transactionFlagsèµ‹å€¼ï¼Œç„¶åä½¿ç”¨å®ƒä½œä¸ºå‚æ•°æ¥è°ƒç”¨å‡½æ•° handleTransactionLockedã€‚ [SurfaceFlinger.cpp] 123456789101112131415void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)&#123;ATRACE_CALL();Mutex::Autolock _l(mStateLock);const nsecs_t now = systemTime();mDebugInTransaction = now;transactionFlags = getTransactionFlags(eTransactionMask);handleTransactionLocked(transactionFlags);mLastTransactionTime = systemTime() - now;mDebugInTransaction = 0;invalidateHwcGeometry();&#125; getTransactionFlagså‡½æ•°çš„å‚æ•°æ˜¯eTransactionMaskåªæ˜¯å±è”½å…¶ä»–ä½ã€‚ handleTransactionLockedå‡½æ•°ä¼šè°ƒç”¨æ¯ä¸ªLayerç±»çš„doTransactionå‡½æ•°ï¼Œåœ¨åˆ†æhandleTransactionLockedå‡½æ•°ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆçœ‹çœ‹Layerç±» çš„doTransactionå‡½æ•°ã€‚ 2.2ã€Layerçš„doTransactionå‡½æ•°ä¸‹é¢æ˜¯Layerçš„doTransactionå‡½æ•°ä»£ç  [Layer.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475uint32_t Layer::doTransaction(uint32_t flags) &#123;ATRACE_CALL();pushPendingState();//ä¸Šæ¬¡ç»˜åˆ¶çš„Stateå¯¹è±¡ Layer::State c = getCurrentState();//å½“å‰ä½¿ç”¨çš„Stateå¯¹è±¡const Layer::State&amp; s(getDrawingState());const bool sizeChanged = (c.requested.w != s.requested.w) || (c.requested.h != s.requested.h);if (sizeChanged) &#123; // the size changed, we need to ask our client to request a new buffer //å¦‚æœLayerçš„å°ºå¯¸å‘ç”Ÿå˜åŒ–ï¼Œå°±è¦æ”¹å˜Surfaceçš„ç¼“å†²åŒºçš„å°ºå¯¸ // record the new size, form this point on, when the client request // a buffer, it'll get the new size. mSurfaceFlingerConsumer-&gt;setDefaultBufferSize( c.requested.w, c.requested.h);&#125;const bool resizePending = (c.requested.w != c.active.w) || (c.requested.h != c.active.h);if (!isFixedSize()) &#123; if (resizePending &amp;&amp; mSidebandStream == NULL) &#123; //å¦‚æœLayerä¸æ˜¯å›ºå®šå°ºå¯¸çš„ç±»å‹ï¼Œæ¯”è¾ƒå®ƒçš„å®é™…å¤§å°å’Œè¦æ±‚çš„æ”¹å˜å¤§å° flags |= eDontUpdateGeometryState; &#125;&#125;//å¦‚æœæ²¡æœ‰eDontUpdateGeometryStateæ ‡å¿—ï¼Œæ›´æ–°activeçš„å€¼ä¸ºrequest if (flags &amp; eDontUpdateGeometryState) &#123;&#125; else &#123; Layer::State&amp; editCurrentState(getCurrentState()); if (mFreezePositionUpdates) &#123; float tx = c.active.transform.tx(); float ty = c.active.transform.ty(); c.active = c.requested; c.active.transform.set(tx, ty); editCurrentState.active = c.active; &#125; else &#123; editCurrentState.active = editCurrentState.requested; c.active = c.requested; &#125;&#125;// å¦‚æœå½“å‰stateçš„activeå’Œä»¥å‰çš„Stateçš„activeä¸ç­‰ï¼Œè®¾ç½®æ›´æ–°æ ‡å¿— if (s.active != c.active) &#123; // invalidate and recompute the visible regions if needed flags |= Layer::eVisibleRegion;&#125;//å¦‚æœå½“å‰stateçš„sequenceå’Œä»¥å‰stateçš„sequenceä¸ç­‰ï¼Œè®¾ç½®æ›´æ–°æ ‡å¿—if (c.sequence != s.sequence) &#123; // invalidate and recompute the visible regions if needed flags |= eVisibleRegion; this-&gt;contentDirty = true; // we may use linear filtering, if the matrix scales us const uint8_t type = c.active.transform.getType(); mNeedsFiltering = (!c.active.transform.preserveRects() || (type &gt;= Transform::SCALE));&#125;// If the layer is hidden, signal and clear out all local sync points so// that transactions for layers depending on this layer's frames becoming// visible are not blockedif (c.flags &amp; layer_state_t::eLayerHidden) &#123; Mutex::Autolock lock(mLocalSyncPointMutex); for (auto&amp; point : mLocalSyncPoints) &#123; point-&gt;setFrameAvailable(); &#125; mLocalSyncPoints.clear();&#125;// Commit the transactioncommitTransaction(c);return flags;&#125; Layerç±»ä¸­çš„ä¸¤ä¸ªç±»å‹ä¸ºLayer::Stateçš„æˆå‘˜å˜é‡mDrawingStateã€mCurrentStateï¼Œè¿™é‡Œä¸ºä»€ä¹ˆè¦ä¸¤ä¸ªå¯¹è±¡å‘¢ï¼ŸLayerå¯¹è±¡åœ¨ç»˜åˆ¶å›¾å½¢æ—¶ï¼Œä½¿ç”¨çš„æ˜¯mDrawingStateå˜é‡ï¼Œç”¨æˆ·è°ƒç”¨æ¥å£è®¾ç½®Layerå¯¹è±¡å±æ€§æ˜¯ï¼Œè®¾ç½®çš„å€¼ä¿å­˜åœ¨mCurrentStateå¯¹è±¡ä¸­ï¼Œè¿™æ ·å°±ä¸ä¼šå› ä¸ºç”¨æˆ·çš„æ“ä½œè€Œå¹²æ‰°Layerå¯¹è±¡çš„ç»˜åˆ¶äº†ã€‚ Layerçš„doTransactionå‡½æ•°æ®ä½ æ˜¯æ¯”è¾ƒè¿™ä¸¤ä¸ªå˜é‡ï¼Œå¦‚æœæœ‰ä¸åŒçš„åœ°æ–¹ï¼Œè¯´æ˜åœ¨ä¸Šæ¬¡ç»˜åˆ¶ä»¥åï¼Œç”¨æˆ·æ”¹å˜çš„Layerçš„è®¾ç½®ï¼Œè¦æŠŠè¿™ç§å˜åŒ–é€šè¿‡flagsè¿”å›ã€‚ Stateçš„ç»“æ„ä¸­æœ‰ä¸¤ä¸ªGeometryå­—æ®µï¼Œactiveå’Œrequestedã€‚ä»–ä»¬è¡¨ç¤ºlayerçš„å°ºå¯¸ï¼Œå…¶ä¸­requestedä¿å­˜æ˜¯ç”¨æˆ·è®¾ç½®çš„å°ºå¯¸ï¼Œè€Œactiveä¿å­˜çš„å€¼é€šè¿‡è®¡ç®—åçš„å®é™…å°ºå¯¸ã€‚ Stateä¸­çš„zå­—æ®µçš„å€¼å°±æ˜¯Layeråœ¨æ˜¾ç¤ºè½´çš„ä½ç½®ï¼Œå€¼è¶Šå°ä½ç½®è¶Šé ä¸‹ã€‚ layerStackå­—æ®µæ˜¯ç”¨æˆ·æŒ‡å®šçš„ä¸€ä¸ªå€¼ï¼Œç”¨æˆ·å¯ä»¥ç»™DisplayDeviceä¹ŸæŒ‡å®šä¸€ä¸ªlayerStackå€¼ï¼Œåªæœ‰Layerå¯¹è±¡å’ŒDisplayDeviceå¯¹è±¡çš„layerStackç›¸ç­‰ï¼Œè¿™ä¸ªLayeræ‰èƒ½åœ¨è¿™ä¸ªæ˜¾ç¤ºè®¾å¤‡ä¸Šè¾“å‡ºï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯å¯ä»¥è®©æ˜¾ç¤ºè®¾å¤‡åªæ˜¾ç¤ºæŸä¸ªSurfaceçš„å†…å®¹ã€‚ä¾‹å¦‚ï¼Œå¯ä»¥è®©HDMIæ˜¾ç¤ºè®¾å¤‡åªæ˜¾ç¤ºæ‰‹æœºä¸Šæ’­æ”¾è§†é¢‘çš„Surfaceçª—å£ï¼Œä½†ä¸æ˜¾ç¤ºActivityçª—å£ã€‚ sequenceå­—æ®µæ˜¯ä¸ªåºåˆ—å€¼ï¼Œæ¯å½“ç”¨æˆ·è°ƒç”¨äº†Layerçš„æ¥å£ï¼Œä¾‹å¦‚setAlphaã€setSizeæˆ–è€…setLayerç­‰æ”¹å˜Layerå¯¹è±¡å±æ€§çš„å“ˆæ•°ï¼Œè¿™ä¸ªå€¼éƒ½ä¼šåŠ 1ã€‚å› æ­¤åœ¨doTransactionå‡½æ•°ä¸­èƒ½é€šè¿‡æ¯”è¾ƒsequenceå€¼æ¥åˆ¤æ–­Layerçš„å±æ€§å€¼æœ‰æ²¡æœ‰å˜åŒ–ã€‚ doTransactionå‡½æ•°æœ€åä¼šè°ƒç”¨commitTransactionå‡½æ•°ï¼Œå°±æ˜¯æŠŠmCurrentStateèµ‹å€¼ç»™mDrawingState [Layer.cpp] 123void Layer::commitTransaction(const State&amp; stateToCommit) &#123;mDrawingState = stateToCommit;&#125; 2.3ã€handleTransactionLockedå‡½æ•°ä¸‹é¢æˆ‘ä»¬æ¥åˆ†æhandleTransactionLockedå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æ¯”è¾ƒé•¿ï¼Œæˆ‘ä»¬åˆ†æ®µåˆ†æ 2.3.1 å¤„ç†Layerçš„äº‹åŠ¡ [SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123;const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);const size_t count = currentLayers.size();// Notify all layers of available framesfor (size_t i = 0; i &lt; count; ++i) &#123; currentLayers[i]-&gt;notifyAvailableFrames();&#125;if (transactionFlags &amp; eTraversalNeeded) &#123; for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) continue; const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125;&#125; åœ¨SurfaceFlingerä¸­ä¹Ÿæœ‰ä¸¤ä¸ªç±»å‹ä¸ºStateçš„å˜é‡mCurrentStateå’ŒmDrawingStateï¼Œä½†æ˜¯å’ŒLayerä¸­çš„ä¸è¦æ··èµ·æ¥ã€‚å®ƒçš„åå­—ç›¸åŒè€Œå·² 1234 struct State &#123; LayerVector layersSortedByZ; DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays;&#125;; ç»“æ„layersSortedByZå­—æ®µä¿å­˜æ‰€æœ‰å‚ä¸ç»˜åˆ¶çš„Layerå¯¹è±¡ï¼Œè€Œå­—æ®µdisplaysä¿å­˜çš„æ˜¯æ‰€æœ‰è¾“å‡ºè®¾å¤‡çš„DisplayDeviceStateå¯¹è±¡ è¿™é‡Œç”¨ä¸¤ä¸ªå˜é‡çš„ç›®çš„æ˜¯å’ŒLayerä¸­ä½¿ç”¨ä¸¤ä¸ªå˜é‡æ˜¯ä¸€æ ·çš„ã€‚ ä¸Šé¢ä»£ç æ ¹æ®eTraversalNeededæ ‡å¿—æ¥å†³å®šæ˜¯å¦è¦æ£€æŸ¥æ‰€æœ‰çš„Layerå¯¹è±¡ã€‚å¦‚æœæŸä¸ªLayerå¯¹è±¡ä¸­æœ‰eTransactionNeededæ ‡å¿—ï¼Œå°†è°ƒç”¨å®ƒçš„doTransactionå‡½æ•°ã€‚Layerçš„doTransactionå‡½æ•°è¿”å›çš„flagså¦‚æœæœ‰eVisibleRegionï¼Œè¯´æ˜è¿™ä¸ªLayeréœ€è¦æ›´æ–°ï¼Œå°±æŠŠmVisibleRegionsDirtyè®¾ç½®ä¸ºtrue 2.3.2ã€å¤„ç†æ˜¾ç¤ºè®¾å¤‡çš„å˜åŒ–123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172 if (transactionFlags &amp; eDisplayTransactionNeeded) &#123; // here we take advantage of Vector's copy-on-write semantics to // improve performance by skipping the transaction entirely when // know that the lists are identical const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; curr(mCurrentState.displays); const KeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt;&amp; draw(mDrawingState.displays); if (!curr.isIdenticalTo(draw)) &#123; mVisibleRegionsDirty = true; const size_t cc = curr.size(); size_t dc = draw.size(); // find the displays that were removed // (ie: in drawing state but not in current state) // also handle displays that changed // (ie: displays that are in both lists) for (size_t i=0 ; i&lt;dc ; i++) &#123; const ssize_t j = curr.indexOfKey(draw.keyAt(i)); if (j &lt; 0) &#123; // in drawing state but not in current state if (!draw[i].isMainDisplay()) &#123; // Call makeCurrent() on the primary display so we can // be sure that nothing associated with this display // is current. const sp&lt;const DisplayDevice&gt; defaultDisplay(getDefaultDisplayDevice()); defaultDisplay-&gt;makeCurrent(mEGLDisplay, mEGLContext); sp&lt;DisplayDevice&gt; hw(getDisplayDevice(draw.keyAt(i))); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); if (draw[i].type &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) mEventThread-&gt;onHotplugReceived(draw[i].type, false); mDisplays.removeItem(draw.keyAt(i)); &#125; else &#123; ALOGW(\"trying to remove the main display\"); &#125; &#125; else &#123; // this display is in both lists. see if something changed. const DisplayDeviceState&amp; state(curr[j]); const wp&lt;IBinder&gt;&amp; display(curr.keyAt(j)); const sp&lt;IBinder&gt; state_binder = IInterface::asBinder(state.surface); const sp&lt;IBinder&gt; draw_binder = IInterface::asBinder(draw[i].surface); if (state_binder != draw_binder) &#123; // changing the surface is like destroying and // recreating the DisplayDevice, so we just remove it // from the drawing state, so that it get re-added // below. sp&lt;DisplayDevice&gt; hw(getDisplayDevice(display)); if (hw != NULL) hw-&gt;disconnect(getHwComposer()); mDisplays.removeItem(display); mDrawingState.displays.removeItemsAt(i); dc--; i--; // at this point we must loop to the next item continue; &#125; const sp&lt;DisplayDevice&gt; disp(getDisplayDevice(display)); if (disp != NULL) &#123; if (state.layerStack != draw[i].layerStack) &#123; disp-&gt;setLayerStack(state.layerStack); &#125; if ((state.orientation != draw[i].orientation) || (state.viewport != draw[i].viewport) || (state.frame != draw[i].frame)) &#123; disp-&gt;setProjection(state.orientation, state.viewport, state.frame); &#125; if (state.width != draw[i].width || state.height != draw[i].height) &#123; disp-&gt;setDisplaySize(state.width, state.height); &#125; &#125; &#125; &#125; // find displays that were added // (ie: in current state but not in drawing state) for (size_t i=0 ; i&lt;cc ; i++) &#123; if (draw.indexOfKey(curr.keyAt(i)) &lt; 0) &#123; const DisplayDeviceState&amp; state(curr[i]); sp&lt;DisplaySurface&gt; dispSurface; sp&lt;IGraphicBufferProducer&gt; producer; sp&lt;IGraphicBufferProducer&gt; bqProducer; sp&lt;IGraphicBufferConsumer&gt; bqConsumer; BufferQueue::createBufferQueue(&amp;bqProducer, &amp;bqConsumer, new GraphicBufferAlloc()); int32_t hwcDisplayId = -1; if (state.isVirtualDisplay()) &#123; // Virtual displays without a surface are dormant: // they have external state (layer stack, projection, // etc.) but no internal state (i.e. a DisplayDevice). if (state.surface != NULL) &#123; int width = 0; DisplayUtils* displayUtils = DisplayUtils::getInstance(); int status = state.surface-&gt;query( NATIVE_WINDOW_WIDTH, &amp;width); ALOGE_IF(status != NO_ERROR, \"Unable to query width (%d)\", status); int height = 0; status = state.surface-&gt;query( NATIVE_WINDOW_HEIGHT, &amp;height); ALOGE_IF(status != NO_ERROR, \"Unable to query height (%d)\", status); if (MAX_VIRTUAL_DISPLAY_DIMENSION == 0 || (width &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION &amp;&amp; height &lt;= MAX_VIRTUAL_DISPLAY_DIMENSION)) &#123; int usage = 0; status = state.surface-&gt;query( NATIVE_WINDOW_CONSUMER_USAGE_BITS, &amp;usage); ALOGW_IF(status != NO_ERROR, \"Unable to query usage (%d)\", status); if ( (status == NO_ERROR) &amp;&amp; displayUtils-&gt;canAllocateHwcDisplayIdForVDS(usage)) &#123; hwcDisplayId = allocateHwcDisplayId(state.type); &#125; &#125; displayUtils-&gt;initVDSInstance(mHwc, hwcDisplayId, state.surface, dispSurface, producer, bqProducer, bqConsumer, state.displayName, state.isSecure, state.type); &#125; &#125; else &#123; ALOGE_IF(state.surface!=NULL, \"adding a supported display, but rendering \" \"surface is provided (%p), ignoring it\", state.surface.get()); hwcDisplayId = allocateHwcDisplayId(state.type); // for supported (by hwc) displays we provide our // own rendering surface dispSurface = new FramebufferSurface(*mHwc, state.type, bqConsumer); producer = bqProducer; &#125; const wp&lt;IBinder&gt;&amp; display(curr.keyAt(i)); if (dispSurface != NULL &amp;&amp; producer != NULL) &#123; sp&lt;DisplayDevice&gt; hw = new DisplayDevice(this, state.type, hwcDisplayId, mHwc-&gt;getFormat(hwcDisplayId), state.isSecure, display, dispSurface, producer, mRenderEngine-&gt;getEGLConfig()); hw-&gt;setLayerStack(state.layerStack); hw-&gt;setProjection(state.orientation, state.viewport, state.frame); hw-&gt;setDisplayName(state.displayName); // When a new display device is added update the active // config by querying HWC otherwise the default config // (config 0) will be used. if (hwcDisplayId &gt;= DisplayDevice::DISPLAY_PRIMARY &amp;&amp; hwcDisplayId &lt; DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES) &#123; int activeConfig = mHwc-&gt;getActiveConfig(hwcDisplayId); if (activeConfig &gt;= 0) &#123; hw-&gt;setActiveConfig(activeConfig); &#125; &#125; mDisplays.add(display, hw); if (state.isVirtualDisplay()) &#123; if (hwcDisplayId &gt;= 0) &#123; mHwc-&gt;setVirtualDisplayProperties(hwcDisplayId, hw-&gt;getWidth(), hw-&gt;getHeight(), hw-&gt;getFormat()); &#125; &#125; else &#123; mEventThread-&gt;onHotplugReceived(state.type, true); &#125; &#125; &#125; &#125; &#125;&#125; è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯å¤„ç†æ˜¾ç¤ºè®¾å¤‡çš„å˜åŒ–ï¼Œåˆ†æˆ3ç§æƒ…å†µï¼š 1.æ˜¾ç¤ºè®¾å¤‡å‡å°‘äº†ï¼Œéœ€è¦æŠŠæ˜¾ç¤ºè®¾å¤‡å¯¹åº”çš„DisplayDeviceç§»é™¤ 2.æ˜¾ç¤ºè®¾å¤‡å‘ç”Ÿäº†å˜åŒ–ï¼Œä¾‹å¦‚ç”¨æˆ·è®¾ç½®äº†Surfaceã€é‡æ–°è®¾ç½®äº†layerStackã€æ—‹è½¬äº†å±å¹•ç­‰ï¼Œè¿™å°±éœ€è¦é‡æ–°è®¾ç½®æ˜¾ç¤ºå¯¹è±¡çš„å±æ€§ 3.æ˜¾ç¤ºè®¾å¤‡å¢åŠ äº†ï¼Œåˆ›å»ºæ–°çš„DisplayDeviceåŠ å…¥ç³»ç»Ÿä¸­ã€‚ 2.3.3ã€è®¾ç½®TransfromHit12345678910111213141516171819202122232425262728293031323334353637383940 if (transactionFlags &amp; (eTraversalNeeded|eDisplayTransactionNeeded)) &#123; ...... sp&lt;const DisplayDevice&gt; disp; uint32_t currentlayerStack = 0; for (size_t i=0; i&lt;count; i++) &#123; // NOTE: we rely on the fact that layers are sorted by // layerStack first (so we don't have to traverse the list // of displays for every layer). const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); uint32_t layerStack = layer-&gt;getDrawingState().layerStack; if (i==0 || currentlayerStack != layerStack) &#123; currentlayerStack = layerStack; // figure out if this layerstack is mirrored // (more than one display) if so, pick the default display, // if not, pick the only display it's on. disp.clear(); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); if (hw-&gt;getLayerStack() == currentlayerStack) &#123; if (disp == NULL) &#123; disp = hw; &#125; else &#123; disp = NULL; break; &#125; &#125; &#125; &#125; if (disp == NULL) &#123; // NOTE: TEMPORARY FIX ONLY. Real fix should cause layers to // redraw after transform hint changes. See bug 8508397. // could be null when this layer is using a layerStack // that is not visible on any display. Also can occur at // screen off/on times. disp = getDefaultDisplayDevice(); &#125; layer-&gt;updateTransformHint(disp); &#125;&#125; è¿™æ®µä»£ç çš„ä½œç”¨æ˜¯æ ¹æ®æ¯ç§æ˜¾ç¤ºè®¾å¤‡çš„ä¸åŒï¼Œè®¾ç½®å’Œæ˜¾ç¤ºè®¾å¤‡å…³è”åœ¨ä¸€èµ·çš„Layerï¼ˆä¸»è¦çœ‹Layerçš„layerStackæ˜¯å¦å’ŒDisplayDeviceçš„layerStackï¼‰çš„TransformHintï¼ˆä¸»è¦æŒ‡è®¾å¤‡çš„æ˜¾ç¤ºæ–¹å‘orientationï¼‰ã€‚ 2.3.4ã€å¤„ç†Layerå¢åŠ æƒ…å†µ123456789101112131415161718192021222324252627282930/* * Perform our own transaction if needed */const LayerVector&amp; layers(mDrawingState.layersSortedByZ);if (currentLayers.size() &gt; layers.size()) &#123; // layers have been added mVisibleRegionsDirty = true;&#125;// some layers might have been removed, so// we need to update the regions they're exposing.if (mLayersRemoved) &#123; mLayersRemoved = false; mVisibleRegionsDirty = true; const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (currentLayers.indexOf(layer) &lt; 0) &#123; // this layer is not visible anymore // TODO: we could traverse the tree from front to back and // compute the actual visible region // TODO: we could cache the transformed region const Layer::State&amp; s(layer-&gt;getDrawingState()); Region visibleReg = s.active.transform.transform( Region(Rect(s.active.w, s.active.h))); invalidateLayerStack(s.layerStack, visibleReg); &#125; &#125;&#125; è¿™æ®µä»£ç å¤„ç†Layerçš„å¢åŠ æƒ…å†µï¼Œå¦‚æœLayerå¢åŠ äº†ï¼Œéœ€è¦é‡æ–°è®¡ç®—è®¾å¤‡çš„æ›´æ–°åŒºåŸŸï¼Œå› æ­¤æŠŠmVisibleRegionsDirtyè®¾ä¸ºtrueï¼Œå¦‚æœLayeråˆ é™¤äº†ï¼Œéœ€è¦æŠŠLayerçš„å¯è§åŒºåŸŸåŠ å…¥åˆ°ç³»ç»Ÿéœ€è¦æ›´æ–°çš„åŒºåŸŸä¸­ã€‚ 2.3.5ã€è®¾ç½®mDrawingState123 commitTransaction();updateCursorAsync();&#125; è°ƒç”¨commitTransactionå’ŒupdateCursorAsyncå‡½æ•° commitTransactionå‡½æ•°ä½œç”¨æ˜¯æŠŠmDrawingStateçš„å€¼è®¾ç½®æˆmCurrentStateçš„å€¼ã€‚è€ŒupdateCursorAsyncå‡½æ•°ä¼šæ›´æ–°æ‰€æœ‰æ˜¾ç¤ºè®¾å¤‡ä¸­å…‰æ ‡çš„ä½ç½®ã€‚ 2.3.6 å°ç»“ handleTransactionå‡½æ•°çš„ä½œç”¨çš„å°±æ˜¯å¤„ç†ç³»ç»Ÿåœ¨ä¸¤æ¬¡åˆ·æ–°æœŸé—´çš„å„ç§å˜åŒ–ã€‚SurfaceFlingeræ¨¡å—ä¸­ä¸ç®¡æ˜¯SurfaceFlingerç±»è¿˜æ˜¯Layerç±»ï¼Œéƒ½é‡‡ç”¨äº†åŒç¼“å†²çš„æ–¹å¼æ¥ä¿å­˜ä»–ä»¬çš„å±æ€§ï¼Œè¿™æ ·çš„å¥½å¤„æ˜¯åˆšæ”¹å˜SurfaceFlingerå¯¹è±¡æˆ–è€…Layerç±»å¯¹è±¡çš„å±æ€§æ˜¯ï¼Œä¸éœ€è¦ä¸Šé”ï¼Œå¤§å¤§çš„æé«˜äº†ç³»ç»Ÿæ•ˆç‡ã€‚åªæœ‰åœ¨æœ€åçš„å›¾åƒè¾“å‡ºæ˜¯ï¼Œæ‰è¿›è¡Œä¸€æ¬¡ä¸Šé”ï¼Œå¹¶è¿›è¡Œå†…å­˜çš„å±æ€§å˜åŒ–å¤„ç†ã€‚æ­£å› æ­¤ï¼Œåº”ç”¨è¿›ç¨‹å¿…é¡»æ”¶åˆ°VSyncä¿¡å·æ‰å¼€å§‹æ”¹å˜Surfaceçš„å†…å®¹ã€‚ 2.4ã€handlePageFlipå‡½æ•°handlePageFlipå‡½æ•°ä»£ç å¦‚ä¸‹ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool SurfaceFlinger::handlePageFlip()&#123;Region dirtyRegion;bool visibleRegions = false;const LayerVector&amp; layers(mDrawingState.layersSortedByZ);bool frameQueued = false;// Store the set of layers that need updates. This set must not change as// buffers are being latched, as this could result in a deadlock.// Example: Two producers share the same command stream and:// 1.) Layer 0 is latched// 2.) Layer 0 gets a new frame// 2.) Layer 1 gets a new frame// 3.) Layer 1 is latched.// Display is now waiting on Layer 1's frame, which is behind layer 0's// second frame. But layer 0's second frame could be waiting on display.Vector&lt;Layer*&gt; layersWithQueuedFrames;for (size_t i = 0, count = layers.size(); i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); if (layer-&gt;hasQueuedFrame()) &#123; frameQueued = true; if (layer-&gt;shouldPresentNow(mPrimaryDispSync)) &#123; layersWithQueuedFrames.push_back(layer.get()); &#125; else &#123; layer-&gt;useEmptyDamage(); &#125; &#125; else &#123; layer-&gt;useEmptyDamage(); &#125;&#125;for (size_t i = 0, count = layersWithQueuedFrames.size() ; i&lt;count ; i++) &#123; Layer* layer = layersWithQueuedFrames[i]; const Region dirty(layer-&gt;latchBuffer(visibleRegions)); layer-&gt;useSurfaceDamage(); const Layer::State&amp; s(layer-&gt;getDrawingState()); invalidateLayerStack(s.layerStack, dirty);&#125;mVisibleRegionsDirty |= visibleRegions;// If we will need to wake up at some time in the future to deal with a// queued frame that shouldn't be displayed during this vsync period, wake// up during the next vsync period to check again.if (frameQueued &amp;&amp; layersWithQueuedFrames.empty()) &#123; signalLayerUpdate();&#125;// Only continue with the refresh if there is actually new work to doreturn !layersWithQueuedFrames.empty();&#125; handlePageFlipå‡½æ•°å…ˆè°ƒç”¨æ¯ä¸ªLayerå¯¹è±¡çš„hasQueuedFrameå‡½æ•°ï¼Œç¡®å®šè¿™ä¸ªLayerå¯¹è±¡æ˜¯å¦æœ‰éœ€è¦æ›´æ–°çš„å›¾å±‚ï¼Œç„¶åæŠŠéœ€è¦æ›´æ–°çš„Layerå¯¹è±¡æ”¾åˆ°layersWithQueuedFramesä¸­ã€‚ æˆ‘ä»¬å…ˆæ¥çœ‹Layerçš„hasQueuedFrameæ–¹æ³•å°±æ˜¯çœ‹å…¶mQueuedFramesæ˜¯å¦å¤§äº0 å’ŒmSidebandStreamChangedã€‚å‰é¢å°èŠ‚åˆ†æåªè¦Surfaceæœ‰æ•°æ®å†™å…¥ï¼Œå°±ä¼šè°ƒç”¨Layerçš„onFrameAvailableå‡½æ•°ï¼Œç„¶åmQueuedFrameså€¼åŠ 1. ç»§ç»­çœ‹handlePageFlipå‡½æ•°ï¼Œæ¥ç€è°ƒç”¨éœ€è¦æ›´æ–°çš„Layerå¯¹è±¡çš„latchBufferå‡½æ•°ï¼Œç„¶åæ ¹æ®è¿”å›çš„æ›´æ–°åŒºåŸŸè°ƒç”¨invalidateLayerStackå‡½æ•°æ¥è®¾ç½®æ›´æ–°è®¾å¤‡å¯¹è±¡çš„æ›´æ–°åŒºåŸŸã€‚ ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹latchBufferå‡½æ•° LatchBufferå‡½æ•°è°ƒç”¨updateTextImageæ¥å¾—åˆ°éœ€è¦çš„å›¾åƒã€‚è¿™é‡Œå‚æ•°ræ˜¯Rejectå¯¹è±¡ï¼Œå…¶ä½œç”¨æ˜¯åˆ¤æ–­åœ¨ç¼“å†²åŒºçš„å°ºå¯¸æ˜¯å¦ç¬¦åˆè¦æ±‚ã€‚è°ƒç”¨updateTextImageå‡½æ•°å¦‚æœå¾—åˆ°çš„ç»“æœæ˜¯PRESENT_LATER,è¡¨ç¤ºæ¨è¿Ÿå¤„ç†ï¼Œç„¶åè°ƒç”¨signalLayerUpdateå‡½æ•°æ¥å‘é€invalidateæ¶ˆæ¯ï¼Œè¿™æ¬¡ç»˜åˆ¶è¿‡ç¨‹å°±ä¸å¤„ç†è¿™ä¸ªSurfaceçš„å›¾åƒäº†ã€‚ å¦‚æœä¸éœ€è¦æ¨è¿Ÿå¤„ç†ï¼ŒæŠŠmQueuedFramesçš„å€¼å‡1. æœ€åLatchBufferå‡½æ•°è°ƒç”¨mSurfaceFlingerConsumerçš„getCurrentBufferæ¥å–å›å½“å‰çš„å›¾åƒç¼“å†²åŒºæŒ‡é’ˆï¼Œä¿å­˜åœ¨mActiveBufferä¸­ã€‚ 2.5 å°ç»“è¿™æ ·ç»è¿‡handleTransaction handlePageFlipä¸¤ä¸ªå‡½æ•°å¤„ç†ï¼ŒSurfaceFlingerä¸­æ— è®ºæ˜¯Layerå±æ€§çš„å˜åŒ–è¿˜æ˜¯å›¾åƒçš„å˜åŒ–éƒ½å¤„ç†å¥½äº†ï¼Œåªç­‰VSyncä¿¡å·åˆ°æ¥å°±å¯ä»¥è¾“å‡ºäº†ã€‚ ä¸‰ã€rebuildLayerStackså‡½æ•°å‰é¢ä»‹ç»ï¼ŒVSyncä¿¡å·åˆ°æ¥åï¼Œå…ˆæ˜¯è°ƒç”¨äº†rebuildLayerStackså‡½æ•° 123456789101112131415161718192021222324252627282930313233343536373839404142434445void SurfaceFlinger::rebuildLayerStacks() &#123;updateExtendedMode();// rebuild the visible layer list per screenif (CC_UNLIKELY(mVisibleRegionsDirty)) &#123; ATRACE_CALL(); mVisibleRegionsDirty = false; invalidateHwcGeometry(); //è®¡ç®—æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡ä¸Šå¯è§çš„Layer const LayerVector&amp; layers(mDrawingState.layersSortedByZ); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; Region opaqueRegion; Region dirtyRegion; Vector&lt; sp&lt;Layer&gt; &gt; layersSortedByZ; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); const Transform&amp; tr(hw-&gt;getTransform()); const Rect bounds(hw-&gt;getBounds()); if (hw-&gt;isDisplayOn()) &#123; //è®¡ç®—æ¯ä¸ªlayerçš„å¯è§åŒºåŸŸï¼Œç¡®å®šè®¾å¤‡éœ€è¦é‡æ–°ç»˜åˆ¶çš„åŒºåŸŸ computeVisibleRegions(hw-&gt;getHwcDisplayId(), layers, hw-&gt;getLayerStack(), dirtyRegion, opaqueRegion); const size_t count = layers.size(); for (size_t i=0 ; i&lt;count ; i++) &#123; const sp&lt;Layer&gt;&amp; layer(layers[i]); &#123; //åªéœ€è¦å’Œæ˜¾ç¤ºè®¾å¤‡çš„LayerStackç›¸åŒçš„layer Region drawRegion(tr.transform( layer-&gt;visibleNonTransparentRegion)); drawRegion.andSelf(bounds); if (!drawRegion.isEmpty()) &#123; //å¦‚æœLayerçš„æ˜¾ç¤ºåŒºåŸŸå’Œæ˜¾ç¤ºè®¾å¤‡çš„çª—å£æœ‰äº¤é›† //æŠŠLayeråŠ å…¥åˆ—è¡¨ä¸­ layersSortedByZ.add(layer); &#125; &#125; &#125; &#125; //è®¾ç½®æ˜¾ç¤ºè®¾å¤‡çš„å¯è§Layeråˆ—è¡¨ hw-&gt;setVisibleLayersSortedByZ(layersSortedByZ); hw-&gt;undefinedRegion.set(bounds); hw-&gt;undefinedRegion.subtractSelf(tr.transform(opaqueRegion)); hw-&gt;dirtyRegion.orSelf(dirtyRegion); &#125;&#125;&#125; rebuildLayerStackså‡½æ•°çš„ä½œç”¨æ˜¯é‡å»ºæ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡çš„å¯è§layerå¯¹è±¡åˆ—è¡¨ã€‚å¯¹äºæŒ‰æ˜¾ç¤ºè½´ï¼ˆZè½´ï¼‰æ’åˆ—çš„Layerå¯¹è±¡ï¼Œæ’åœ¨æœ€å‰é¢çš„å½“ç„¶ä¼šä¼˜å…ˆæ˜¾ç¤ºï¼Œä½†æ˜¯Layerå›¾åƒå¯èƒ½æœ‰é€æ˜åŸŸï¼Œä¹Ÿå¯èƒ½æœ‰å°ºå¯¸æ²¡æœ‰è¦†ç›–æ•´ä¸ªå±å¹•ï¼Œå› æ­¤ä¸‹é¢çš„layerä¹Ÿæœ‰æ˜¾ç¤ºçš„æœºä¼šã€‚rebuildLayerStackså‡½æ•°å¯¹æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡ï¼Œå…ˆè®¡ç®—å’Œæ˜¾ç¤ºè®¾å¤‡å…·æœ‰ç›¸åŒlayerStackå€¼çš„Layerå¯¹è±¡åœ¨è¯¥æ˜¾ç¤ºè®¾å¤‡ä¸Šçš„å¯è§åŒºåŸŸã€‚ç„¶åå°†å¯è§åŒºåŸŸå’Œæ˜¾ç¤ºè®¾å¤‡çš„çª—å£åŒºåŸŸæœ‰äº¤é›†çš„layerç»„æˆä¸€ä¸ªæ–°çš„åˆ—è¡¨ï¼Œæœ€åæŠŠè¿™ä¸ªåˆ—è¡¨è®¾ç½®åˆ°æ˜¾ç¤ºè®¾å¤‡å¯¹è±¡ä¸­ã€‚ computeVisibleRegionså‡½æ•°é¦–å…ˆè®¡ç®—æ¯ä¸ªLayeråœ¨è®¾å¤‡ä¸Šçš„å¯è§åŒºåŸŸvisibleRegionã€‚è®¡ç®—æ–¹æ³•å°±æ˜¯ç”¨æ•´ä¸ªLayerçš„åŒºåŸŸå‡å»ä¸Šå±‚æ‰€æœ‰ä¸é€æ˜åŒºåŸŸaboveOpaqueLayersã€‚è€Œä¸Šå±‚æ‰€æœ‰ä¸é€æ˜åŒºåŸŸå€¼æ˜¯ä¸€ä¸ªé€å±‚ç´¯è®¡çš„è¿‡ç¨‹ï¼Œæ¯å±‚éƒ½éœ€è¦æŠŠè‡ªå·±çš„ä¸é€æ˜åŒºåŸŸç´¯åŠ åˆ°aboveOpaqueLayersä¸­ã€‚ è€Œæ¯å±‚çš„ä¸é€æ˜åŒºåŸŸçš„è®¡ç®—æ–¹æ³•ï¼šå¦‚æœLayerçš„alphaçš„å€¼ä¸º255ï¼Œå¹¶ä¸”layerçš„isOpaqueå‡½æ•°ä¸ºtrueï¼Œåˆ™æœ¬å±‚çš„ä¸é€æ˜åŒºåŸŸç­‰äºLayeræ‰€åœ¨åŒºåŸŸï¼Œå¦åˆ™ä¸º0.è¿™æ ·ä¸€å±‚å±‚ç®—ä¸‹æ¥ï¼Œå°±å¾ˆå®¹æ˜“å¾—åˆ°æ¯å±‚çš„å¯è§åŒºåŸŸå¤§å°äº†ã€‚ å…¶æ¬¡ï¼Œè®¡ç®—æ•´ä¸ªæ˜¾ç¤ºè®¾å¤‡éœ€è¦æ›´æ–°çš„åŒºåŸŸoutDirtyRegionã€‚outDirtyRegionçš„å€¼ä¹Ÿæ˜¯ç´¯è®¡æ‰€æœ‰å±‚çš„éœ€è¦é‡å›çš„åŒºåŸŸå¾—åˆ°çš„ã€‚å¦‚æœLayerä¸­çš„æ˜¾ç¤ºå†…å®¹å‘ç”Ÿäº†å˜åŒ–ï¼Œåˆ™æ•´ä¸ªå¯è§åŒºåŸŸvisibleRegionéƒ½éœ€è¦æ›´æ–°ï¼ŒåŒæ—¶è¿˜è¦åŒ…æ‹¬ä¸Šä¸€æ¬¡çš„å¯è§åŒºåŸŸï¼Œç„¶ååœ¨å»æ‰è¢«ä¸Šå±‚è¦†ç›–åçš„åŒºåŸŸå¾—åˆ°çš„å°±æ˜¯Layeréœ€è¦æ›´æ–°çš„åŒºåŸŸã€‚å¦‚æœLayeræ˜¾ç¤ºçš„å†…å®¹æ²¡æœ‰å˜åŒ–ï¼Œä½†æ˜¯è€ƒè™‘åˆ°çª—å£å¤§å°çš„å˜åŒ–æˆ–è€…ä¸Šå±‚çª—å£çš„å˜åŒ–ï¼Œå› æ­¤Layerä¸­è¿˜æ˜¯æœ‰åŒºåŸŸå¯ä»¥éœ€è¦é‡ç»˜çš„åœ°æ–¹ã€‚è¿™ç§æƒ…å†µä¸‹æœ€ç®€å•çš„ç®—æ³•æ˜¯ç”¨Layerè®¡ç®—å‡ºå¯è§åŒºåŸŸå‡å»ä»¥å‰çš„å¯è§åŒºåŸŸå°±å¯ä»¥äº†ã€‚ä½†æ˜¯åœ¨computeVisibleRegionså‡½æ•°è¿˜å¼•å…¥äº†è¢«è¦†ç›–åŒºåŸŸï¼Œé€šå¸¸è¢«è¦†ç›–åŒºåŸŸå’Œå¯è§åŒºåŸŸå¹¶ä¸é‡å¤ï¼Œå› æ­¤å‡½æ•°ä¸­è®¡ç®—æš´éœ²åŒºåŸŸæ˜¯ç”¨å¯è§åŒºåŸŸå‡å»è¢«è¦†ç›–åŒºåŸŸçš„ã€‚ å››ã€setUpHWComposerå‡½æ•°setUpHWComposerå‡½æ•°çš„ä½œç”¨æ˜¯æ›´æ–°HWComposerå¯¹è±¡ä¸­å›¾å±‚å¯¹è±¡åˆ—è¡¨ä»¥åŠå›¾å±‚å±æ€§ã€‚ [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102void SurfaceFlinger::setUpHWComposer() &#123;for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; bool dirty = !mDisplays[dpy]-&gt;getDirtyRegion(false).isEmpty(); bool empty = mDisplays[dpy]-&gt;getVisibleLayersSortedByZ().size() == 0; bool wasEmpty = !mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers; ...... bool mustRecompose = dirty &amp;&amp; !(empty &amp;&amp; wasEmpty); ...... mDisplays[dpy]-&gt;beginFrame(mustRecompose); if (mustRecompose) &#123; mDisplays[dpy]-&gt;lastCompositionHadVisibleLayers = !empty; &#125;&#125;//å¾—åˆ°ç³»ç»ŸHWComposerå¯¹è±¡ HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; // build the h/w work list if (CC_UNLIKELY(mHwWorkListDirty)) &#123; mHwWorkListDirty = false; for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); //æ ¹æ®Layeræ•°é‡åœ¨HWComposerä¸­åˆ›å»ºhwc_layer_list_tåˆ—è¡¨ if (hwc.createWorkList(id, count) == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); layer-&gt;setGeometry(hw, *cur); if (mDebugDisableHWC || mDebugRegion || mDaltonize || mHasColorMatrix) &#123; cur-&gt;setSkip(true); &#125; &#125; &#125; &#125; &#125; &#125; // set the per-frame data for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; bool freezeSurfacePresent = false; isfreezeSurfacePresent(freezeSurfacePresent, hw, id); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; /* * update the per-frame h/w composer data for each layer * and build the transparent region of the FB */ const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); //å°†Layerçš„mActiveBufferè®¾ç½®åˆ°HWComposerä¸­ layer-&gt;setPerFrameData(hw, *cur); setOrientationEventControl(freezeSurfacePresent,id); &#125; &#125; &#125; // If possible, attempt to use the cursor overlay on each display. for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;= 0) &#123; const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers( hw-&gt;getVisibleLayersSortedByZ()); const size_t count = currentLayers.size(); HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i=0 ; cur!=end &amp;&amp; i&lt;count ; ++i, ++cur) &#123; const sp&lt;Layer&gt;&amp; layer(currentLayers[i]); if (layer-&gt;isPotentialCursor()) &#123; cur-&gt;setIsCursorLayerHint(); break; &#125; &#125; &#125; &#125; dumpDrawCycle(true); status_t err = hwc.prepare(); ALOGE_IF(err, \"HWComposer::prepare failed (%s)\", strerror(-err)); for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); hw-&gt;prepareFrame(hwc); &#125;&#125;&#125; HWComposerä¸­æœ‰ä¸€ä¸ªç±»å‹ä¸ºDisplayDataç»“æ„çš„æ•°ç»„mDisplayDataï¼Œå®ƒç»´æŠ¤ç€æ¯ä¸ªæ˜¾ç¤ºè®¾å¤‡çš„ä¿¡æ¯ã€‚DisplayDataç»“æ„ä¸­æœ‰ä¸€ä¸ªç±»å‹ä¸ºhwc_display_contents_lå­—æ®µlistï¼Œè¿™ä¸ªå­—æ®µåˆæœ‰ä¸€ä¸ªhwc_layer_lç±»å‹çš„æ•°ç»„hwLayersï¼Œè®°å½•è¯¥æ˜¾ç¤ºè®¾å¤‡æ‰€æœ‰éœ€è¦è¾“å‡ºçš„Layerä¿¡æ¯ã€‚ setUpHWComposerå‡½æ•°è°ƒç”¨HWComposerçš„createWorkListå‡½æ•°å°±æ˜¯æ ¹æ®æ¯ç§æ˜¾ç¤ºè®¾å¤‡çš„Layeræ•°é‡ï¼Œåˆ›å»ºå’Œåˆå§‹åŒ–hwc_display_contents_lå¯¹è±¡å’Œhwc_layer_læ•°ç»„ åˆ›å»ºå®ŒHWComposerä¸­çš„åˆ—è¡¨åï¼Œæ¥ä¸‹æ¥æ˜¯å¯¹æ¯ä¸ªLayerå¯¹è±¡è°ƒç”¨å®ƒçš„setPerFrameDataå‡½æ•°ï¼Œå‚æ•°æ˜¯HWComposerå’ŒHWCLayerInterfaceã€‚setPerFrameDataå‡½æ•°å°†Layerå¯¹è±¡çš„å½“å‰å›¾åƒç¼“å†²åŒºmActiveBufferè®¾ç½®åˆ°HWCLayerInterfaceå¯¹è±¡å¯¹åº”çš„hwc_layer_lå¯¹è±¡ä¸­ã€‚ HWComposerç±»ä¸­é™¤äº†å‰é¢ä»‹ç»çš„Grallocè¿˜ç®¡ç†ç€Composeræ¨¡å—ï¼Œè¿™ä¸ªæ¨¡å—å®ç°äº†ç¡¬ä»¶çš„å›¾åƒåˆæˆåŠŸèƒ½ã€‚setUpHWComposerå‡½æ•°æ¥ä¸‹æ¥è°ƒç”¨HWComposerç±»çš„prepareå‡½æ•°ï¼Œè€Œprepareå‡½æ•°ä¼šè°ƒç”¨Composeræ¨¡å—çš„prepareæ¥å£ã€‚æœ€ååˆ°å„ä¸ªå‚å®¶çš„å®ç°hwc_prepareå‡½æ•°å°†æ¯ç§HWComposerä¸­çš„æ‰€æœ‰å›¾å±‚çš„ç±»å‹éƒ½è®¾ç½®ä¸ºHWC_FRAMEBUFFERå°±ç»“æŸäº†ã€‚ äº”ã€åˆæˆæ‰€æœ‰å±‚çš„å›¾åƒ ï¼ˆdoComposition()å‡½æ•°ï¼‰doCompositionå‡½æ•°æ˜¯åˆæˆæ‰€æœ‰å±‚çš„å›¾åƒï¼Œä»£ç å¦‚ä¸‹ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021void SurfaceFlinger::doComposition() &#123;ATRACE_CALL();const bool repaintEverything = android_atomic_and(0, &amp;mRepaintEverything);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; const sp&lt;DisplayDevice&gt;&amp; hw(mDisplays[dpy]); if (hw-&gt;isDisplayOn()) &#123; // transform the dirty region into this screen's coordinate space const Region dirtyRegion(hw-&gt;getDirtyRegion(repaintEverything)); // repaint the framebuffer (if needed) doDisplayComposition(hw, dirtyRegion); hw-&gt;dirtyRegion.clear(); hw-&gt;flip(hw-&gt;swapRegion); hw-&gt;swapRegion.clear(); &#125; // inform the h/w that we're done compositing hw-&gt;compositionComplete();&#125;postFramebuffer();&#125; doCompositionå‡½æ•°é’ˆå¯¹æ¯ç§æ˜¾ç¤ºè®¾å¤‡è°ƒç”¨doDisplayCompositionå‡½æ•°æ¥åˆæˆï¼Œåˆæˆåè°ƒç”¨postFramebufferå‡½æ•°ï¼Œæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹doDisplayCompositionå‡½æ•° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950void SurfaceFlinger::doDisplayComposition(const sp&lt;const DisplayDevice&gt;&amp; hw, const Region&amp; inDirtyRegion) &#123;// We only need to actually compose the display if:// 1) It is being handled by hardware composer, which may need this to// keep its virtual display state machine in sync, or// 2) There is work to be done (the dirty region isn't empty)bool isHwcDisplay = hw-&gt;getHwcDisplayId() &gt;= 0;if (!isHwcDisplay &amp;&amp; inDirtyRegion.isEmpty()) &#123; ALOGV(\"Skipping display composition\"); return;&#125;ALOGV(\"doDisplayComposition\");Region dirtyRegion(inDirtyRegion);// compute the invalid region//swapRegionè®¾ç½®ä¸ºéœ€è¦æ›´æ–°çš„åŒºåŸŸ hw-&gt;swapRegion.orSelf(dirtyRegion);uint32_t flags = hw-&gt;getFlags();//è·å¾—æ˜¾ç¤ºè®¾å¤‡æ”¯æŒçš„æ›´æ–°æ–¹å¼æ ‡å¿— if (flags &amp; DisplayDevice::SWAP_RECTANGLE) &#123; // we can redraw only what's dirty, but since SWAP_RECTANGLE only // takes a rectangle, we must make sure to update that whole // rectangle in that case dirtyRegion.set(hw-&gt;swapRegion.bounds());&#125; else &#123; if (flags &amp; DisplayDevice::PARTIAL_UPDATES) &#123;//æ”¯æŒéƒ¨åˆ†æ›´æ–° // We need to redraw the rectangle that will be updated // (pushed to the framebuffer). // This is needed because PARTIAL_UPDATES only takes one // rectangle instead of a region (see DisplayDevice::flip()) //å°†æ›´æ–°åŒºåŸŸè°ƒæ•´ä¸ºæ•´ä¸ªçª—å£å¤§å° dirtyRegion.set(hw-&gt;swapRegion.bounds()); &#125; else &#123; // we need to redraw everything (the whole screen) dirtyRegion.set(hw-&gt;bounds()); hw-&gt;swapRegion = dirtyRegion; &#125;&#125;//åˆæˆ if (!doComposeSurfaces(hw, dirtyRegion)) return;// update the swap region and clear the dirty regionhw-&gt;swapRegion.orSelf(dirtyRegion);//æ²¡æœ‰ç¡¬ä»¶composerçš„æƒ…å†µï¼Œè¾“å‡ºå›¾åƒ// swap buffers (presentation)hw-&gt;swapBuffers(getHwComposer());&#125; doDisplayCompositionå‡½æ•°æ ¹æ®æ˜¾ç¤ºè®¾å¤‡æ”¯æŒçš„æ›´æ–°æ–¹å¼ï¼Œé‡æ–°è®¾ç½®éœ€è¦æ›´æ–°åŒºåŸŸçš„å¤§å°ã€‚ çœŸæ­£çš„åˆæˆå·¥ä½œæ˜¯åœ¨doComposerSurfaceså‡½æ•°ä¸­å®Œæˆï¼Œè¿™ä¸ªå‡½æ•°åœ¨layerçš„ç±»å‹ä¸ºHWC_FRAMEBUFFER,æˆ–è€…ä¸æ”¯æŒç¡¬ä»¶çš„composerçš„æƒ…å†µä¸‹ï¼Œè°ƒç”¨layerçš„drawå‡½æ•°æ¥ä¸€å±‚ä¸€å±‚ä½åˆæˆæœ€åçš„å›¾åƒã€‚ åˆæˆå®Œåï¼ŒdoDisplayCompositionå‡½æ•°è°ƒç”¨äº†hwçš„swapBufferså‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°å‰é¢ä»‹ç»è¿‡äº†ï¼Œå®ƒå°†åœ¨ç³»ç»Ÿä¸æ”¯æŒç¡¬ä»¶çš„composeræƒ…å†µä¸‹è°ƒç”¨eglSwapBuffersæ¥è¾“å‡ºå›¾åƒåˆ°æ˜¾ç¤ºè®¾å¤‡ã€‚ å…­ã€postFramebufferå‡½æ•°ä¸Šä¸€èŠ‚çš„doCompositionå‡½æ•°æœ€åè°ƒç”¨äº†postFramebufferå‡½æ•°ï¼Œä»£ç å¦‚ä¸‹ï¼š [SurfaceFlinger.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051void SurfaceFlinger::postFramebuffer()&#123;ATRACE_CALL();const nsecs_t now = systemTime();mDebugInSwapBuffers = now;HWComposer&amp; hwc(getHwComposer());if (hwc.initCheck() == NO_ERROR) &#123; if (!hwc.supportsFramebufferTarget()) &#123; // EGL spec says: // \"surface must be bound to the calling thread's current context, // for the current rendering API.\" getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext); &#125; hwc.commit();&#125;// make the default display current because the VirtualDisplayDevice code cannot// deal with dequeueBuffer() being called outside of the composition loop; however// the code below can call glFlush() which is allowed (and does in some case) call// dequeueBuffer().getDefaultDisplayDevice()-&gt;makeCurrent(mEGLDisplay, mEGLContext);for (size_t dpy=0 ; dpy&lt;mDisplays.size() ; dpy++) &#123; sp&lt;const DisplayDevice&gt; hw(mDisplays[dpy]); const Vector&lt; sp&lt;Layer&gt; &gt;&amp; currentLayers(hw-&gt;getVisibleLayersSortedByZ()); hw-&gt;onSwapBuffersCompleted(hwc); const size_t count = currentLayers.size(); int32_t id = hw-&gt;getHwcDisplayId(); if (id &gt;=0 &amp;&amp; hwc.initCheck() == NO_ERROR) &#123; HWComposer::LayerListIterator cur = hwc.begin(id); const HWComposer::LayerListIterator end = hwc.end(id); for (size_t i = 0; cur != end &amp;&amp; i &lt; count; ++i, ++cur) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, &amp;*cur); &#125; &#125; else &#123; for (size_t i = 0; i &lt; count; i++) &#123; currentLayers[i]-&gt;onLayerDisplayed(hw, NULL); &#125; &#125;&#125;mLastSwapBufferTime = systemTime() - now;mDebugInSwapBuffers = 0;uint32_t flipCount = getDefaultDisplayDevice()-&gt;getPageFlipCount();if (flipCount % LOG_FRAME_STATS_PERIOD == 0) &#123; logFrameStats();&#125;&#125; postFramebufferå…ˆåˆ¤æ–­ç³»ç»Ÿæ˜¯å¦æ”¯æŒcomposerï¼Œå¦‚æœä¸æ”¯æŒï¼Œæˆ‘ä»¬çŸ¥é“å›¾åƒå·²ç»åœ¨doCompositionå‡½æ•°æ—¶è°ƒç”¨hw-&gt;swapBuffersè¾“å‡ºäº†ï¼Œå°±è¿”å›äº†ã€‚å¦‚æœæ”¯æŒç¡¬ä»¶composerï¼ŒpostFramebufferå‡½æ•°å°†è°ƒç”¨HWComposerçš„commitå‡½æ•°ç»§ç»­æ‰§è¡Œã€‚ [HWComposer.cpp] 12345678910111213141516171819202122232425262728293031323334353637status_t HWComposer::commit() &#123;int err = NO_ERROR;if (mHwc) &#123; if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) &#123; // On version 1.0, the OpenGL ES target surface is communicated // by the (dpy, sur) fields and we are guaranteed to have only // a single display. mLists[0]-&gt;dpy = eglGetCurrentDisplay(); mLists[0]-&gt;sur = eglGetCurrentSurface(EGL_DRAW); &#125; for (size_t i=VIRTUAL_DISPLAY_ID_BASE; i&lt;mNumDisplays; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); if (disp.outbufHandle) &#123; mLists[i]-&gt;outbuf = disp.outbufHandle; mLists[i]-&gt;outbufAcquireFenceFd = disp.outbufAcquireFence-&gt;dup(); &#125; &#125; err = mHwc-&gt;set(mHwc, mNumDisplays, mLists); for (size_t i=0 ; i&lt;mNumDisplays ; i++) &#123; DisplayData&amp; disp(mDisplayData[i]); disp.lastDisplayFence = disp.lastRetireFence; disp.lastRetireFence = Fence::NO_FENCE; if (disp.list) &#123; if (disp.list-&gt;retireFenceFd != -1) &#123; disp.lastRetireFence = new Fence(disp.list-&gt;retireFenceFd); disp.list-&gt;retireFenceFd = -1; &#125; disp.list-&gt;flags &amp;= ~HWC_GEOMETRY_CHANGED; &#125; &#125;&#125;return (status_t)err;&#125; /**************Vsync**************/ å‚è€ƒæ–‡æ¡£ï¼ˆç‰¹åˆ«æ„Ÿè°¢ï¼‰ï¼šAndroid6.0 æ˜¾ç¤ºç³»ç»Ÿï¼ˆå…­ï¼‰ å›¾åƒçš„è¾“å‡ºè¿‡ç¨‹ - kc58236582çš„åšå®¢ - CSDNåšå®¢startActivityå¯åŠ¨è¿‡ç¨‹åˆ†ææµ…æAndroidçš„çª—å£ - DEV CLUBAndroidæºç è§£æä¹‹ï¼ˆåå››ï¼‰â€“&gt;Activityå¯åŠ¨æµç¨‹Androidåº”ç”¨setContentViewä¸LayoutInflateråŠ è½½è§£ææœºåˆ¶æºç åˆ†æAndroidåº”ç”¨ç¨‹åºçª—å£è®¾è®¡æ¡†æ¶ä»‹ç» - æ·±å…¥å‰–æAndroidç³»ç»Ÿ - CSDNåšå®¢Androidæ˜¾ç¤ºç³»ç»Ÿè®¾è®¡æ¡†æ¶ä»‹ç» - æ·±å…¥å‰–æAndroidç³»ç»Ÿ - CSDNåšå®¢å›¾è§£Android - Android GUI ç³»ç»Ÿ (2) - çª—å£ç®¡ç† (View, Canvas, Window Manager) - æ¼«å¤©å°˜æ²™ - åšå®¢å›­Android SurfaceFlinger å­¦ä¹ ä¹‹è·¯(äº”)â€”-VSync å·¥ä½œåŸç† | April is your lieAndroid graphics å­¦ä¹ ï¼ç”Ÿäº§è€…ã€æ¶ˆè´¹è€…ã€BufferQueueä»‹ç» - armwindçš„ä¸“æ  - CSDNåšå®¢ Graphics DEMO BingoAndroid å›¾å½¢ç³»ç»Ÿæ¦‚è¿°","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Activity å¯åŠ¨æµç¨‹ ï¼ˆAMSï¼‰åˆ†æ","slug":"Android-7-1-2-Android-N-Activityå¯åŠ¨æµç¨‹åˆ†æ","date":"2017-09-30T16:00:00.000Z","updated":"2018-04-19T14:29:42.809Z","comments":true,"path":"2017/10/01/Android-7-1-2-Android-N-Activityå¯åŠ¨æµç¨‹åˆ†æ/","link":"","permalink":"http://zhoujinjian.cc/2017/10/01/Android-7-1-2-Android-N-Activityå¯åŠ¨æµç¨‹åˆ†æ/","excerpt":"Activityå¯åŠ¨æµç¨‹æ¦‚è¿°ï¼šâ— ç‚¹å‡»æ¡Œé¢Appå›¾æ ‡ï¼ŒLauncherè¿›ç¨‹é‡‡ç”¨Binder IPCå‘system_serverè¿›ç¨‹å‘èµ·startActivityè¯·æ±‚ï¼›â— system_serverè¿›ç¨‹æ¥æ”¶åˆ°è¯·æ±‚åï¼Œå‘zygoteè¿›ç¨‹å‘é€åˆ›å»ºè¿›ç¨‹çš„è¯·æ±‚ï¼›â— Zygoteè¿›ç¨‹forkå‡ºæ–°çš„å­è¿›ç¨‹ï¼Œå³Appè¿›ç¨‹ï¼›â— Appè¿›ç¨‹ï¼Œé€šè¿‡Binder IPCå‘sytem_serverè¿›ç¨‹å‘èµ·attachApplicationè¯·æ±‚ï¼›â— system_serverè¿›ç¨‹åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œè¿›è¡Œä¸€ç³»åˆ—å‡†å¤‡å·¥ä½œåï¼Œå†é€šè¿‡binder IPCå‘Appè¿›ç¨‹å‘é€scheduleLaunchActivityè¯·æ±‚ï¼›â— Appè¿›ç¨‹çš„binderçº¿ç¨‹ï¼ˆApplicationThreadï¼‰åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œé€šè¿‡handlerå‘ä¸»çº¿ç¨‹å‘é€LAUNCH_ACTIVITYæ¶ˆæ¯ï¼›â— ä¸»çº¿ç¨‹åœ¨æ”¶åˆ°Messageåï¼Œé€šè¿‡å‘å°„æœºåˆ¶åˆ›å»ºç›®æ ‡Activityï¼Œå¹¶å›è°ƒActivity.onCreate()ç­‰æ–¹æ³•ã€‚","text":"Activityå¯åŠ¨æµç¨‹æ¦‚è¿°ï¼šâ— ç‚¹å‡»æ¡Œé¢Appå›¾æ ‡ï¼ŒLauncherè¿›ç¨‹é‡‡ç”¨Binder IPCå‘system_serverè¿›ç¨‹å‘èµ·startActivityè¯·æ±‚ï¼›â— system_serverè¿›ç¨‹æ¥æ”¶åˆ°è¯·æ±‚åï¼Œå‘zygoteè¿›ç¨‹å‘é€åˆ›å»ºè¿›ç¨‹çš„è¯·æ±‚ï¼›â— Zygoteè¿›ç¨‹forkå‡ºæ–°çš„å­è¿›ç¨‹ï¼Œå³Appè¿›ç¨‹ï¼›â— Appè¿›ç¨‹ï¼Œé€šè¿‡Binder IPCå‘sytem_serverè¿›ç¨‹å‘èµ·attachApplicationè¯·æ±‚ï¼›â— system_serverè¿›ç¨‹åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œè¿›è¡Œä¸€ç³»åˆ—å‡†å¤‡å·¥ä½œåï¼Œå†é€šè¿‡binder IPCå‘Appè¿›ç¨‹å‘é€scheduleLaunchActivityè¯·æ±‚ï¼›â— Appè¿›ç¨‹çš„binderçº¿ç¨‹ï¼ˆApplicationThreadï¼‰åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œé€šè¿‡handlerå‘ä¸»çº¿ç¨‹å‘é€LAUNCH_ACTIVITYæ¶ˆæ¯ï¼›â— ä¸»çº¿ç¨‹åœ¨æ”¶åˆ°Messageåï¼Œé€šè¿‡å‘å°„æœºåˆ¶åˆ›å»ºç›®æ ‡Activityï¼Œå¹¶å›è°ƒActivity.onCreate()ç­‰æ–¹æ³•ã€‚ ä¸€ã€æ¦‚è¿°åŸºäºAndroid 7.1.2çš„æºç å‰–æï¼Œ åˆ†æAndroid Activityå¯åŠ¨æµç¨‹ï¼Œç›¸å…³æºç ï¼š frameworks/base/services/core/java/com/android/server/am/â— ActivityManagerService.javaâ— ActivityStackSupervisor.javaâ— ActivityStack.javaâ— ActivityRecord.javaâ— ProcessRecord.javaâ— TaskRecord.java frameworks/base/services/core/java/com/android/server/pm/â— PackageManagerService.java frameworks/base/core/java/android/os/â— Process.java frameworks/base/core/java/android/app/â— IActivityManager.javaâ— ActivityManagerNative.java (å†…å«AMP)â— ActivityManager.javaâ— Activity.javaâ— ActivityThread.javaâ— Instrumentation.javaâ— IApplicationThread.javaâ— ApplicationThreadNative.java (å†…å«ATP)â— ActivityThread.java (å†…å«ApplicationThread)â— ContextImpl.java åšå®¢åŸå›¾é“¾æ¥ ä¸»è¦å¯¹è±¡åŠŸèƒ½ä»‹ç»ï¼šâ— ActivityManagerServiceï¼Œç®€ç§°AMSï¼ŒæœåŠ¡ç«¯å¯¹è±¡ï¼Œè´Ÿè´£ç³»ç»Ÿä¸­æ‰€æœ‰Activityçš„ç”Ÿå‘½å‘¨æœŸã€‚â— ActivityManagerNativeç»§æ‰¿Javaçš„Binderç±»ï¼ŒåŒæ—¶å®ç°äº†IActivityManageræ¥å£ï¼Œå³ActivityManagerNativeå°†ä½œä¸ºBinderé€šä¿¡çš„æœåŠ¡ç«¯ä¸ºç”¨æˆ·æä¾›æ”¯æŒã€‚â— ActivityManagerProxyï¼šåœ¨ActivityManagerNativeç±»ä¸­å®šä¹‰äº†å†…éƒ¨ç±»ActivityManagerProxyï¼Œè¯¥ç±»åŒæ ·å®ç°äº†IActivityManageræ¥å£ï¼Œå°†ä½œä¸ºå®¢æˆ·ç«¯ä½¿ç”¨çš„æœåŠ¡ç«¯ä»£ç†ã€‚â— ActivityThreadï¼ŒAppçš„çœŸæ­£å…¥å£ã€‚å½“å¼€å¯Appä¹‹åï¼Œä¼šè°ƒç”¨main()å¼€å§‹è¿è¡Œï¼Œå¼€å¯æ¶ˆæ¯å¾ªç¯é˜Ÿåˆ—ï¼Œè¿™å°±æ˜¯ä¼ è¯´ä¸­çš„UIçº¿ç¨‹æˆ–è€…å«ä¸»çº¿ç¨‹ã€‚ä¸ActivityManagerServicesé…åˆï¼Œä¸€èµ·å®ŒæˆActivityçš„ç®¡ç†å·¥ä½œâ— ApplicationThreadï¼Œç”¨æ¥å®ç°ActivityManagerServiceä¸ActivityThreadä¹‹é—´çš„äº¤äº’ã€‚åœ¨ActivityManagerServiceéœ€è¦ç®¡ç†ç›¸å…³Applicationä¸­çš„Activityçš„ç”Ÿå‘½å‘¨æœŸæ—¶ï¼Œé€šè¿‡ApplicationThreadçš„ä»£ç†å¯¹è±¡ä¸ActivityThreadé€šè®¯ã€‚â— ApplicationThreadProxyï¼Œæ˜¯ApplicationThreadåœ¨æœåŠ¡å™¨ç«¯çš„ä»£ç†ï¼Œè´Ÿè´£å’Œå®¢æˆ·ç«¯çš„ApplicationThreadé€šè®¯ã€‚AMSå°±æ˜¯é€šè¿‡è¯¥ä»£ç†ä¸ActivityThreadè¿›è¡Œé€šä¿¡çš„ã€‚â— Instrumentationï¼Œæ¯ä¸€ä¸ªåº”ç”¨ç¨‹åºåªæœ‰ä¸€ä¸ªInstrumentationå¯¹è±¡ï¼Œæ¯ä¸ªActivityå†…éƒ½æœ‰ä¸€ä¸ªå¯¹è¯¥å¯¹è±¡çš„å¼•ç”¨ã€‚Instrumentationå¯ä»¥ç†è§£ä¸ºåº”ç”¨è¿›ç¨‹çš„ç®¡å®¶ï¼ŒActivityThreadè¦åˆ›å»ºæˆ–æš‚åœæŸä¸ªActivityæ—¶ï¼Œéƒ½éœ€è¦é€šè¿‡Instrumentationæ¥è¿›è¡Œå…·ä½“çš„æ“ä½œã€‚â— ActivityStackï¼ŒActivityåœ¨AMSçš„æ ˆç®¡ç†ï¼Œç”¨æ¥è®°å½•å·²ç»å¯åŠ¨çš„Activityçš„å…ˆåå…³ç³»ï¼ŒçŠ¶æ€ä¿¡æ¯ç­‰ã€‚é€šè¿‡ActivityStackå†³å®šæ˜¯å¦éœ€è¦å¯åŠ¨æ–°çš„è¿›ç¨‹ã€‚â— ActivityRecordï¼ŒActivityStackçš„ç®¡ç†å¯¹è±¡ï¼Œæ¯ä¸ªActivityåœ¨AMSå¯¹åº”ä¸€ä¸ªActivityRecordï¼Œæ¥è®°å½•Activityçš„çŠ¶æ€ä»¥åŠå…¶ä»–çš„ç®¡ç†ä¿¡æ¯ã€‚å…¶å®å°±æ˜¯æœåŠ¡å™¨ç«¯çš„Activityå¯¹è±¡çš„æ˜ åƒã€‚â— TaskRecordï¼ŒAMSæŠ½è±¡å‡ºæ¥çš„ä¸€ä¸ªâ€ä»»åŠ¡â€çš„æ¦‚å¿µï¼Œæ˜¯è®°å½•ActivityRecordçš„æ ˆï¼Œä¸€ä¸ªâ€Taskâ€åŒ…å«è‹¥å¹²ä¸ªActivityRecordã€‚AMSç”¨TaskRecordç¡®ä¿Activityå¯åŠ¨å’Œé€€å‡ºçš„é¡ºåºã€‚å¦‚æœä½ æ¸…æ¥šActivityçš„4ç§launchModeï¼Œé‚£ä¹ˆå¯¹è¿™ä¸ªæ¦‚å¿µåº”è¯¥ä¸é™Œç”Ÿã€‚ ç›¸å…³ç±»çš„ç±»å›¾ï¼šï¼ˆ1ï¼‰IActivityManagerç›¸å…³ç±»ï¼ˆ2ï¼‰IApplicationThreadç›¸å…³ç±»ï¼ˆ3ï¼‰ActivityManagerServiceç›¸å…³ç±» 1.1ã€Taskå’ŒStackAndroidç³»ç»Ÿä¸­çš„æ¯ä¸€ä¸ªActivityéƒ½ä½äºä¸€ä¸ªTaskä¸­ã€‚ä¸€ä¸ªTaskå¯ä»¥åŒ…å«å¤šä¸ªActivityï¼ŒåŒä¸€ä¸ªActivityä¹Ÿå¯èƒ½æœ‰å¤šä¸ªå®ä¾‹ã€‚ åœ¨AndroidManifest.xmlä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡android:launchModeæ¥æ§åˆ¶Activityåœ¨Taskä¸­çš„å®ä¾‹ã€‚ å¦å¤–ï¼Œåœ¨startActivityçš„æ—¶å€™ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡setFlag æ¥æ§åˆ¶å¯åŠ¨çš„Activityåœ¨Taskä¸­çš„å®ä¾‹ã€‚ Taskç®¡ç†çš„æ„ä¹‰è¿˜åœ¨äºè¿‘æœŸä»»åŠ¡åˆ—è¡¨ä»¥åŠBackæ ˆã€‚ å½“ä½ é€šè¿‡å¤šä»»åŠ¡é”®ï¼ˆæœ‰äº›è®¾å¤‡ä¸Šæ˜¯é•¿æŒ‰Homeé”®ï¼Œæœ‰äº›è®¾å¤‡ä¸Šæ˜¯ä¸“é—¨æä¾›çš„å¤šä»»åŠ¡é”®ï¼‰è°ƒå‡ºå¤šä»»åŠ¡æ—¶ï¼Œå…¶å®å°±æ˜¯ä»ActivityManagerServiceè·å–äº†æœ€è¿‘å¯åŠ¨çš„Taskåˆ—è¡¨ã€‚ Backæ ˆç®¡ç†äº†å½“ä½ åœ¨Activityä¸Šç‚¹å‡»Backé”®ï¼Œå½“å‰Activityé”€æ¯ååº”è¯¥è·³è½¬åˆ°å“ªä¸€ä¸ªActivityçš„é€»è¾‘ã€‚å…³äºTaskå’ŒBackæ ˆï¼Œè¯·å‚è§è¿™é‡Œï¼šTasks and Back Stackã€‚ å…¶å®åœ¨ActivityManagerServiceä¸WindowManagerServiceå†…éƒ¨ç®¡ç†ä¸­ï¼Œåœ¨Taskä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€å±‚å®¹å™¨ï¼Œè¿™ä¸ªå®¹å™¨åº”ç”¨å¼€å‘è€…å’Œç”¨æˆ·å¯èƒ½éƒ½ä¸ä¼šæ„Ÿè§‰åˆ°æˆ–è€…ç”¨åˆ°ï¼Œä½†å®ƒå´éå¸¸é‡è¦ï¼Œé‚£å°±æ˜¯Stackã€‚ ä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†çœ‹åˆ°ï¼ŒAndroidç³»ç»Ÿä¸­çš„å¤šçª—å£ç®¡ç†ï¼Œå°±æ˜¯å»ºç«‹åœ¨Stackçš„æ•°æ®ç»“æ„ä¸Šçš„ã€‚ ä¸€ä¸ªStackä¸­åŒ…å«äº†å¤šä¸ªTaskï¼Œä¸€ä¸ªTaskä¸­åŒ…å«äº†å¤šä¸ªActivityï¼ˆWindowï¼‰ï¼Œä¸‹å›¾æè¿°äº†å®ƒä»¬çš„å…³ç³»ï¼š å¦å¤–è¿˜æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒActivityManagerServiceå’ŒWindowManagerServiceä¸­çš„Taskå’ŒStackç»“æ„æ˜¯ä¸€ä¸€å¯¹åº”çš„ï¼Œå¯¹åº”å…³ç³»å¯¹äºå¦‚ä¸‹ï¼š ActivityStack &lt;â€“&gt; TaskStack TaskRecord &lt;â€“&gt; Task å³ï¼ŒActivityManagerServiceä¸­çš„æ¯ä¸€ä¸ªActivityStackæˆ–è€…TaskRecordåœ¨WindowManagerServiceä¸­éƒ½æœ‰å¯¹åº”çš„TaskStackå’ŒTaskï¼Œè¿™ä¸¤ç±»å¯¹è±¡éƒ½æœ‰å”¯ä¸€çš„idï¼ˆidæ˜¯intç±»å‹ï¼‰ï¼Œå®ƒä»¬é€šè¿‡idè¿›è¡Œå…³è”ã€‚ 1.2ã€å°ç»“ï¼š ç”¨æˆ·ä»Launcherç¨‹åºç‚¹å‡»åº”ç”¨å›¾æ ‡å¯å¯åŠ¨åº”ç”¨çš„å…¥å£Activityï¼ŒActivityå¯åŠ¨æ—¶éœ€è¦å¤šä¸ªè¿›ç¨‹ä¹‹é—´çš„äº¤äº’ï¼ŒAndroidç³»ç»Ÿä¸­æœ‰ä¸€ä¸ªzygoteè¿›ç¨‹ä¸“ç”¨äºå­µåŒ–Androidæ¡†æ¶å±‚å’Œåº”ç”¨å±‚ç¨‹åºçš„è¿›ç¨‹ã€‚è¿˜æœ‰ä¸€ä¸ªsystem_serverè¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹é‡Œè¿è¡Œäº†å¾ˆå¤šbinder serviceï¼Œä¾‹å¦‚ActivityManagerServiceï¼ŒPackageManagerServiceï¼ŒWindowManagerServiceï¼Œè¿™äº›binder serviceåˆ†åˆ«è¿è¡Œåœ¨ä¸åŒçš„çº¿ç¨‹ä¸­ï¼Œå…¶ä¸­ActivityManagerServiceè´Ÿè´£ç®¡ç†Activityæ ˆï¼Œåº”ç”¨è¿›ç¨‹ï¼Œtaskã€‚ ç”¨æˆ·åœ¨Launcherç¨‹åºé‡Œç‚¹å‡»åº”ç”¨å›¾æ ‡æ—¶ï¼Œä¼šé€šçŸ¥ActivityManagerServiceå¯åŠ¨åº”ç”¨çš„å…¥å£Activityï¼ŒActivityManagerServiceå‘ç°è¿™ä¸ªåº”ç”¨è¿˜æœªå¯åŠ¨ï¼Œåˆ™ä¼šé€šçŸ¥Zygoteè¿›ç¨‹å­µåŒ–å‡ºåº”ç”¨è¿›ç¨‹ï¼Œç„¶ååœ¨è¿™ä¸ªåº”ç”¨è¿›ç¨‹é‡Œæ‰§è¡ŒActivityThreadçš„mainæ–¹æ³•ã€‚åº”ç”¨è¿›ç¨‹æ¥ä¸‹æ¥é€šçŸ¥ActivityManagerServiceåº”ç”¨è¿›ç¨‹å·²å¯åŠ¨ï¼ŒActivityManagerServiceä¿å­˜åº”ç”¨è¿›ç¨‹çš„ä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œè¿™æ ·ActivityManagerServiceå¯ä»¥é€šè¿‡è¿™ä¸ªä»£ç†å¯¹è±¡æ§åˆ¶åº”ç”¨è¿›ç¨‹ï¼Œç„¶åActivityManagerServiceé€šçŸ¥åº”ç”¨è¿›ç¨‹åˆ›å»ºå…¥å£Activityçš„å®ä¾‹ï¼Œå¹¶æ‰§è¡Œå®ƒçš„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ã€‚ æ€»ä½“å¯åŠ¨æµç¨‹å›¾ï¼š äºŒã€ å¼€å§‹è¯·æ±‚æ‰§è¡Œå¯åŠ¨Activity Activity.startActivity()Activity.startActivityForResult()Instrumentation.execStartActivity()ActivityManagerProxy.startActivity()ActivityManagerNative.onTransact()ActivityManagerService.startActivity() 2.1ã€Activity.startActivity()ä»Launcherå¯åŠ¨åº”ç”¨çš„æ—¶å€™ï¼Œç»è¿‡è°ƒç”¨ä¼šæ‰§è¡ŒActivityä¸­çš„startActivityã€‚ 12345678910111213141516[-&gt; Activity.java]......@Overridepublic void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;......@Overridepublic void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; ...... startActivityForResult(intent, -1); &#125;&#125; 2.2ã€Activity.startActivityForResult()1234567891011[-&gt; Activity.java] @Overridepublic void startActivityForResult( String who, Intent intent, int requestCode, @Nullable Bundle options) &#123; ...... Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, who, intent, requestCode, options); ......&#125; å¯ä»¥å‘ç°execStartActivityæ–¹æ³•ä¼ é€’çš„å‡ ä¸ªå‚æ•°ï¼š thisï¼Œä¸ºå¯åŠ¨Activityçš„å¯¹è±¡ï¼› contextThreadï¼Œä¸ºBinderå¯¹è±¡ï¼Œæ˜¯ä¸»è¿›ç¨‹çš„contextå¯¹è±¡ï¼› tokenï¼Œä¹Ÿæ˜¯ä¸€ä¸ªBinderå¯¹è±¡ï¼ŒæŒ‡å‘äº†æœåŠ¡ç«¯ä¸€ä¸ªActivityRecordå¯¹è±¡ï¼› targetï¼Œä¸ºå¯åŠ¨çš„Activityï¼› intentï¼Œå¯åŠ¨çš„Intentå¯¹è±¡ï¼› requestCodeï¼Œè¯·æ±‚ç ï¼› optionsï¼Œå‚æ•°ï¼› 2.3ã€Instrumentation.execStartActivity()1234567891011121314151617[-&gt; Instrumentation.java] ......public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ...... try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(who); int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; ......&#125; å…³äº ActivityManagerNative.getDefault()è¿”å›çš„æ˜¯? 1234567 [-&gt;ActivityManagerNative.java]/** * Retrieve the system's default/global activity manager. */static public IActivityManager getDefault() &#123; return gDefault.get();&#125; ç›´æ¥è¿”å›çš„æ˜¯gDefault.get()ï¼Œé‚£ä¹ˆgDefaultåˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ 1234567891011121314 [-&gt;ActivityManagerNative.java] private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService(\"activity\"); if (false) &#123; Log.v(\"ActivityManager\", \"default service binder = \" + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v(\"ActivityManager\", \"default service = \" + am); &#125; return am; &#125;&#125;; å¯ä»¥å‘ç°å¯åŠ¨è¿‡asInterface()æ–¹æ³•åˆ›å»ºï¼Œç„¶åæˆ‘ä»¬ç»§ç»­çœ‹ä¸€ä¸‹asInterfaceæ–¹æ³•çš„å®ç°ï¼š 123456789101112 static public IActivityManager asInterface(IBinder obj) &#123; if (obj == null) &#123; return null; &#125; IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor); if (in != null) &#123; return in; &#125; return new ActivityManagerProxy(obj);&#125; æœ€åç›´æ¥è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œ æ­¤å¤„startActivity()çš„å…±æœ‰10ä¸ªå‚æ•°, ä¸‹é¢è¯´è¯´æ¯ä¸ªå‚æ•°ä¼ é€’AMP.startActivity()æ¯ä¸€é¡¹çš„å¯¹åº”å€¼: caller: å½“å‰åº”ç”¨çš„ApplicationThreadå¯¹è±¡mAppThread; callingPackage: è°ƒç”¨å½“å‰ContextImpl.getBasePackageName(),è·å–å½“å‰Activityæ‰€åœ¨åŒ…å; intent: è¿™ä¾¿æ˜¯å¯åŠ¨Activityæ—¶,ä¼ é€’è¿‡æ¥çš„å‚æ•°; resolvedType: è°ƒç”¨intent.resolveTypeIfNeededè€Œè·å–; resultTo: æ¥è‡ªäºå½“å‰Activity.mToken resultWho: æ¥è‡ªäºå½“å‰Activity.mEmbeddedID requestCode = -1; startFlags = 0; profilerInfo = null; options = null; å¥½å§ï¼Œæœ€åç›´æ¥è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œè€Œç»§æ‰¿ä¸IActivityManagerï¼Œåˆ°äº†è¿™é‡Œå°±å¼•å‡ºäº†æˆ‘ä»¬androidç³»ç»Ÿä¸­å¾ˆé‡è¦çš„ä¸€ä¸ªæ¦‚å¿µï¼šBinderæœºåˆ¶ã€‚æˆ‘ä»¬çŸ¥é“åº”ç”¨è¿›ç¨‹ä¸SystemServerè¿›ç¨‹å±äºä¸¤ä¸ªä¸åŒçš„è¿›ç¨‹ï¼Œè¿›ç¨‹ä¹‹é—´éœ€è¦é€šè®¯ï¼Œandroidç³»ç»Ÿé‡‡å–äº†è‡ªèº«è®¾è®¡çš„Binderæœºåˆ¶ï¼Œè¿™é‡Œçš„å’ŒActivityManagerNativeéƒ½æ˜¯ç»§æ‰¿ä¸IActivityManagerçš„è€ŒSystemServerè¿›ç¨‹ä¸­çš„ActivityManagerServiceå¯¹è±¡åˆ™ç»§æ‰¿ä¸ActivityManagerNativeã€‚ç®€å•çš„è¡¨ç¤ºï¼š Binderæ¥å£ â€“&gt; ActivityManagerNative/ â€“&gt; ActivityManagerServiceï¼› è¿™æ ·ï¼ŒActivityManagerNativeä¸ç›¸å½“äºä¸€ä¸ªBinderçš„å®¢æˆ·ç«¯è€ŒActivityManagerServiceç›¸å½“äºBinderçš„æœåŠ¡ç«¯ï¼Œè¿™æ ·å½“ActivityManagerNativeè°ƒç”¨æ¥å£æ–¹æ³•çš„æ—¶å€™åº•å±‚é€šè¿‡Binder driverå°±ä¼šå°†è¯·æ±‚æ•°æ®ä¸è¯·æ±‚ä¼ é€’ç»™serverç«¯ï¼Œå¹¶åœ¨serverç«¯æ‰§è¡Œå…·ä½“çš„æ¥å£é€»è¾‘ã€‚éœ€è¦æ³¨æ„çš„æ˜¯Binderæœºåˆ¶æ˜¯å•å‘çš„ï¼Œæ˜¯å¼‚æ­¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´åªèƒ½é€šè¿‡clientç«¯å‘serverç«¯ä¼ é€’æ•°æ®ä¸è¯·æ±‚è€Œä¸ç”¨ç­‰å¾…æœåŠ¡ç«¯çš„è¿”å›ï¼Œä¹Ÿæ— æ³•è¿”å›ï¼Œé‚£å¦‚æœSystemServerè¿›ç¨‹æƒ³å‘åº”ç”¨è¿›ç¨‹ä¼ é€’æ•°æ®æ€ä¹ˆåŠï¼Ÿè¿™æ—¶å€™å°±éœ€è¦é‡æ–°å®šä¹‰ä¸€ä¸ªBinderè¯·æ±‚ä»¥SystemServerä¸ºclientç«¯ï¼Œä»¥åº”ç”¨è¿›ç¨‹ä¸ºserverç«¯ï¼Œè¿™æ ·å°±æ˜¯å®ç°äº†ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´çš„åŒå‘é€šè®¯ã€‚ å¥½äº†ï¼Œè¯´äº†è¿™ä¹ˆå¤šæˆ‘ä»¬çŸ¥é“è¿™é‡Œçš„ActivityManagerNativeæ˜¯ActivityManagerServiceåœ¨åº”ç”¨è¿›ç¨‹çš„ä¸€ä¸ªclientå°±å¥½äº†ï¼Œé€šè¿‡å®ƒå°±å¯ä»¥æ»´å•Šç”¨ActivityManagerServiceçš„æ–¹æ³•äº†ã€‚ 2.4ã€ActivityManagerProxy.startActivity()ActivityManagerNative.getDefault()æ–¹æ³•ä¼šè¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œé‚£ä¹ˆæˆ‘ä»¬çœ‹ä¸€ä¸‹å¯¹è±¡çš„startActivityæ–¹æ³•ï¼š 12345678910111213[-&gt; ActivityManagerNative.java :: ActivityManagerProxy]class ActivityManagerProxy implements IActivityManager&#123;... public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; ...... mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); ......&#125;...&#125; 2.5ã€ActivityManagerNative.onTransact()1234567891011121314[-&gt; ActivityManagerNative.java] @Overridepublic boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; ...... int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); ...... &#125; ...... &#125; è¿™é‡Œå°±æ¶‰åŠåˆ°äº†å…·ä½“çš„Binderæ•°æ®ä¼ è¾“æœºåˆ¶äº†ï¼Œæˆ‘ä»¬ä¸åšè¿‡å¤šçš„åˆ†æï¼ŒçŸ¥é“é€šè¿‡æ•°æ®ä¼ è¾“ä¹‹åå°±ä¼šè°ƒç”¨SystemServerè¿›ç¨‹çš„ActivityManagerServiceçš„startActivityå°±å¥½äº†ã€‚ ä»¥ä¸Šå…¶å®éƒ½æ˜¯å‘ç”Ÿåœ¨åº”ç”¨è¿›ç¨‹ä¸­ï¼Œä¸‹é¢å¼€å§‹è°ƒç”¨çš„ActivityManagerServiceçš„æ‰§è¡Œæ—¶å‘ç”Ÿåœ¨SystemServerè¿›ç¨‹ã€‚ ä¸‰ã€ ActivityManagerServiceæ¥æ”¶å¯åŠ¨Activityçš„è¯·æ±‚ ActivityManagerService.startActivity()ActivityStarter.startActivityMayWait()ActivityStarter.startActivityLocked()ActivityStarter.startActivityUnchecked()ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() ActivityStack.resumeTopActivityUncheckedLocked()ActivityStack.resumeTopActivityInnerLocked()â€“&gt;ActivityStackSupervisor.pauseBackStacks() [if (mResumedActivity != null)] â€“&gt;ActivityStackSupervisor.startSpecificActivityLocked() [if (mResumedActivity == null)] 3.1ã€ActivityManagerService.startActivity() 12345678910111213141516171819202122232425262728293031323334[-&gt; ActivityManagerService.java] public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());&#125; @Overridepublic final int startActivityAsCaller(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity, int userId) &#123; ...... try &#123; int ret = mActivityStarter.startActivityMayWait(null, targetUid, targetPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, ignoreTargetSecurity, userId, null, null); return ret; &#125; ......&#125;final int startActivity(Intent intent, ActivityStackSupervisor.ActivityContainer container) &#123; enforceNotIsolatedCaller(\"ActivityContainer.startActivity\"); final int userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), mStackSupervisor.mCurrentUser, false, ActivityManagerService.ALLOW_FULL_ONLY, \"ActivityContainer\", null); ...... return mActivityStarter.startActivityMayWait(null, -1, null, intent, mimeType, null, null, null, null, 0, 0, null, null, null, null, false, userId, container, null);&#125; å¯ä»¥çœ‹åˆ°è¿™é‡Œåªæ˜¯è¿›è¡Œäº†ä¸€äº›å…³äºuseridçš„é€»è¾‘åˆ¤æ–­ï¼Œç„¶åå°±è°ƒç”¨mStackSupervisor.startActivityMayWaitæ–¹æ³•ï¼Œæ­¤å¤„mStackSupervisorçš„æ•°æ®ç±»å‹ä¸ºActivityStackSupervisorã€‚ å½“ç¨‹åºè¿è¡Œåˆ°è¿™é‡Œæ—¶, ASS.startActivityMayWaitçš„å„ä¸ªå‚æ•°å–å€¼å¦‚ä¸‹: caller = ApplicationThreadProxy, ç”¨äºè·Ÿè°ƒç”¨è€…è¿›ç¨‹ApplicationThreadè¿›è¡Œé€šä¿¡çš„binderä»£ç†ç±». callingUid = -1; callingPackage = ContextImpl.getBasePackageName(),è·å–è°ƒç”¨è€…Activityæ‰€åœ¨åŒ…å intent: è¿™æ˜¯å¯åŠ¨Activityæ—¶ä¼ é€’è¿‡æ¥çš„å‚æ•°; resolvedType = intent.resolveTypeIfNeeded voiceSession = null; voiceInteractor = null; resultTo = Activity.mToken, å…¶ä¸­Activityæ˜¯æŒ‡è°ƒç”¨è€…æ‰€åœ¨Activity, mTokenå¯¹è±¡ä¿å­˜è‡ªå·±æ‰€å¤„çš„ActivityRecordä¿¡æ¯ resultWho = Activity.mEmbeddedID, å…¶ä¸­Activityæ˜¯æŒ‡è°ƒç”¨è€…æ‰€åœ¨Activity requestCode = -1; startFlags = 0; profilerInfo = null; outResult = null; config = null; options = null; ignoreTargetSecurity = false; userId = AMS.handleIncomingUser, å½“è°ƒç”¨è€…userIdè·Ÿå½“å‰å¤„äºåŒä¸€ä¸ªuserId,åˆ™ç›´æ¥è¿”å›è¯¥userId;å½“ä¸ç›¸ç­‰æ—¶åˆ™æ ¹æ®è°ƒç”¨è€…userIdæ¥å†³å®šæ˜¯å¦éœ€è¦å°†callingUserIdè½¬æ¢ä¸ºmCurrentUserId. iContainer = null; inTask = null; ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•çš„å…·ä½“å®ç°ï¼š 3.2ã€ActivityStarter.startActivityMayWait()1234567891011121314151617181920212223242526272829303132333435[-&gt;ActivityStarter.java]final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, IActivityManager.WaitResult outResult, Configuration config, Bundle bOptions, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ...... // Save a copy in case ephemeral needs it final Intent ephemeralIntent = new Intent(intent); // Don't modify the client's object! intent = new Intent(intent); ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId); ...... // Collect information about the target of the Intent. ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo); ActivityOptions options = ActivityOptions.fromBundle(bOptions); ActivityStackSupervisor.ActivityContainer container = (ActivityStackSupervisor.ActivityContainer)iContainer; ...... final ActivityRecord[] outRecord = new ActivityRecord[1]; int res = startActivityLocked(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, outRecord, container, inTask); ...... return res; &#125;&#125; è¯¥è¿‡ç¨‹ä¸»è¦åŠŸèƒ½ï¼šé€šè¿‡resolveActivityæ¥è·å–ActivityInfoä¿¡æ¯, ç„¶åå†è¿›å…¥ASS.startActivityLocked().å…ˆæ¥çœ‹çœ‹ 3.2.1ã€ActivityStackSupervisor.resolveActivity()1234567891011121314151617181920[-&gt;ActivityStackSupervisor.java] ResolveInfo resolveIntent(Intent intent, String resolvedType, int userId) &#123; return resolveIntent(intent, resolvedType, userId, 0);&#125;ResolveInfo resolveIntent(Intent intent, String resolvedType, int userId, int flags) &#123; try &#123; return AppGlobals.getPackageManager().resolveIntent(intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | flags | ActivityManagerService.STOCK_PM_FLAGS, userId); &#125; catch (RemoteException e) &#123; &#125; return null;&#125;ActivityInfo resolveActivity(Intent intent, String resolvedType, int startFlags, ProfilerInfo profilerInfo, int userId) &#123; final ResolveInfo rInfo = resolveIntent(intent, resolvedType, userId); return resolveActivity(intent, rInfo, startFlags, profilerInfo);&#125; 3.2.2ã€PackageManagerService.resolveIntent()AppGlobals.getPackageManager()ç»è¿‡å‡½æ•°å±‚å±‚è°ƒç”¨ï¼Œè·å–çš„æ˜¯ApplicationPackageManagerå¯¹è±¡ã€‚ç»è¿‡binder IPCè°ƒç”¨ï¼Œæœ€ç»ˆä¼šè°ƒç”¨PackageManagerServiceå¯¹è±¡ã€‚æ•…æ­¤æ—¶è°ƒç”¨æ–¹æ³•ä¸ºPMS.resolveIntent(). 12345678910111213141516171819202122232425262728293031323334353637383940[-&gt; PackageManagerService.java] @Overridepublic ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) &#123; try &#123; ...... final List&lt;ResolveInfo&gt; query = queryIntentActivitiesInternal(intent, resolvedType, flags, userId); ...... final ResolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags, query, userId); return bestChoice; &#125; ......&#125; private @NonNull List&lt;ResolveInfo&gt; queryIntentActivitiesInternal(Intent intent, String resolvedType, int flags, int userId) &#123; ...... ComponentName comp = intent.getComponent(); if (comp == null) &#123; if (intent.getSelector() != null) &#123; intent = intent.getSelector(); comp = intent.getComponent(); &#125; &#125; if (comp != null) &#123; final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); final ActivityInfo ai = getActivityInfo(comp, flags, userId); if (ai != null) &#123; final ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; list.add(ri); &#125; return list; &#125; ......&#125; ActivityStackSupervisor.resolveActivity()æ–¹æ³•çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯æ‰¾åˆ°ç›¸åº”çš„Activityç»„ä»¶ï¼Œå¹¶ä¿å­˜åˆ°intentå¯¹è±¡ã€‚ 3.3ã€ActivityStarter.startActivityLocked()ç»§ç»­ActivityStarter.startActivityMayWait()ä¸ªæ–¹æ³•ä¸­æ‰§è¡Œäº†å¯åŠ¨Activityçš„ä¸€äº›å…¶ä»–é€»è¾‘åˆ¤æ–­ï¼Œåœ¨ç»è¿‡åˆ¤æ–­é€»è¾‘ä¹‹åè°ƒç”¨startActivityLockedæ–¹æ³•ï¼š 1234567891011121314151617181920212223242526272829[-&gt;ActivityStarter.java] final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) &#123; ...... ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; ...... ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); ...... try &#123; mService.mWindowManager.deferSurfaceLayout(); err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); &#125; ...... return err;&#125; è¿™ä¸ªæ–¹æ³•ä¸­ä¸»è¦æ„é€ äº†ActivityManagerServiceç«¯çš„Activityå¯¹è±¡â€“&gt;ActivityRecordï¼Œå¹¶æ ¹æ®Activityçš„å¯åŠ¨æ¨¡å¼æ‰§è¡Œäº†ç›¸å…³é€»è¾‘ã€‚ç„¶åè°ƒç”¨äº†startActivityUncheckedLockedæ–¹æ³•ï¼š 3.4ã€ActivityStarter.startActivityUnchecked()12345678910111213141516171819202122232425262728293031323334353637[-&gt;ActivityStarter.java] private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) &#123; ...... boolean newTask = false; ...... mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions); if (mDoResume) &#123; if (!mLaunchTaskBehind) &#123; // ...... mService.setFocusedActivityLocked(mStartActivity, \"startedActivity\"); &#125; final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) &#123; // ...... mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); // ....... mWindowManager.executeAppTransition(); &#125; else &#123; //3.6 ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); &#125; &#125; else &#123; mTargetStack.addRecentActivityLocked(mStartActivity); &#125; mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack); mSupervisor.handleNonResizableTaskIfNeeded( mStartActivity.task, preferredLaunchStackId, mTargetStack.mStackId); return START_SUCCESS;&#125; æ‰¾åˆ°æˆ–åˆ›å»ºæ–°çš„Activitæ‰€å±äºçš„Taskå¯¹è±¡ï¼Œä¹‹åè°ƒç”¨ActivityStack.startActivityLocked() 3.4.1ã€ActivityStack.startActivityLocked()1234567891011121314151617181920212223[-&gt; ActivityStack.java] final void startActivityLocked(ActivityRecord r, boolean newTask, boolean keepCurTransition, ActivityOptions options) &#123; ...... &#125; else &#123; // If this is the first activity, don't do any fancy animations, // because there is nothing for it to animate on top of. addConfigOverride(r, task); ...... &#125; ......&#125; void addConfigOverride(ActivityRecord r, TaskRecord task) &#123; final Rect bounds = task.updateOverrideConfigurationFromLaunchBounds(); // TODO: VI deal with activity mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind, bounds, task.mOverrideConfig, task.mResizeMode, r.isAlwaysFocusable(), task.isHomeTask(), r.appInfo.targetSdkVersion, r.mRotationAnimationHint); r.taskConfigOverride = task.mOverrideConfig;&#125; 3.5ã€ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()123456789101112 [-&gt;ActivityStackSupervisor.java] boolean resumeFocusedStackTopActivityLocked( ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) &#123; if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) &#123; return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions); &#125; final ActivityRecord r = mFocusedStack.topRunningActivityLocked(); if (r == null || r.state != RESUMED) &#123; mFocusedStack.resumeTopActivityUncheckedLocked(null, null); &#125; return false;&#125; 3.6ã€ActivityStack.resumeTopActivityUncheckedLocked()inResumeTopActivityç”¨äºä¿è¯æ¯æ¬¡åªæœ‰ä¸€ä¸ªActivityæ‰§è¡ŒresumeTopActivityLocked()æ“ä½œ. 123456789101112131415161718192021[-&gt;ActivityStack.java] boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 3.7ã€ActivityStack.resumeTopActivityInnerLocked()è¯´æ˜ï¼šå¯åŠ¨ä¸€ä¸ªæ–°Activityæ—¶ï¼Œå¦‚æœç•Œé¢è¿˜å­˜åœ¨å…¶å®ƒçš„Activityï¼Œé‚£ä¹ˆå¿…é¡»å…ˆä¸­æ–­å…¶å®ƒçš„Activityã€‚ å› æ­¤ï¼Œé™¤äº†ç¬¬ä¸€ä¸ªå¯åŠ¨çš„Homeç•Œé¢å¯¹åº”çš„Activityå¤–ï¼Œå…¶å®ƒçš„Activityå‡éœ€è¦è¿›è¡Œæ­¤æ“ä½œï¼Œå½“ç³»ç»Ÿå¯åŠ¨ç¬¬ä¸€ä¸ªActivityï¼Œå³Homeæ—¶ï¼ŒmResumedActivityçš„å€¼æ‰ä¼šä¸ºnullã€‚ ç»è¿‡ä¸€ç³»åˆ—å¤„ç†é€»è¾‘ä¹‹åæœ€ç»ˆè°ƒç”¨äº†startPausingLockedæ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä½œç”¨å°±æ˜¯è®©ç³»ç»Ÿä¸­æ ˆä¸­çš„Activityæ‰§è¡ŒonPauseæ–¹æ³•ã€‚ 12345678910111213141516 [-&gt;ActivityStack.java] private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) &#123; ...... // We need to start pausing the current activity so the top one can be resumed... final boolean dontWaitForPause = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0; boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause); if (mResumedActivity != null) &#123; pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause); &#125; ...... else &#123; ...... mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125;&#125; 3.8ã€ActivityStackSupervisor.pauseBackStacks()æš‚åœæ‰€æœ‰å¤„äºåå°æ ˆçš„æ‰€æœ‰Activityã€‚ 12345678910111213141516 [-&gt;ActivityStackSupervisor.java] boolean pauseBackStacks(boolean userLeaving, ActivityRecord resuming, boolean dontWait) &#123; boolean someActivityPaused = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack) &amp;&amp; stack.mResumedActivity != null) &#123; ...... someActivityPaused |= stack.startPausingLocked(userLeaving, false, resuming, dontWait); &#125; &#125; &#125; return someActivityPaused;&#125; å››ã€æ‰§è¡Œæ ˆé¡¶Activityçš„onPauseæ–¹æ³• ActivityStack.startPausingLocked()ActivityThread.schedulePauseActivity()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()â€“&gt; -&gt;ActivityThread.handlePauseActivity()â€“&gt;ActivityThread.performPauseActivity()â€”-&gt;ActivityThread.performPauseActivityIfNeeded()â€”-&gt; Instrumentation.callActivityOnPause()â€”-&gt; Activity.performPause()â€”-&gt; Activity.onPause()â€“&gt;ActivityManagerService.activityPaused()â€”-&gt;ActivityStack.activityPausedLocked()â€”-&gt;ActivityStack.completePauseLocked()â€”-&gt;ActivityStackSupervisor.resumeFocusedStackTopActivityLocked() â€”-&gt;ActivityStack.resumeTopActivityUncheckedLocked()â€”-&gt;ActivityStack.resumeTopActivityInnerLocked()â€”-&gt;ActivityStackSupervisor.startSpecificActivityLocked() 4.1ã€ActivityStack.startPausingLocked()123456789101112 [-&gt;ActivityStack.java] final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, ActivityRecord resuming, boolean dontWait) &#123; ...... try &#123; ...... mService.updateUsageStats(prev, false); prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125; ......&#125; å¯ä»¥çœ‹åˆ°è¿™é‡Œæ‰§è¡Œäº†pre.app.thread.schedulePauseActivityæ–¹æ³•ï¼Œé€šè¿‡åˆ†æä¸éš¾å‘ç°è¿™é‡Œçš„threadæ˜¯ä¸€ä¸ªIApplicationThreadç±»å‹çš„å¯¹è±¡ï¼Œè€Œåœ¨ActivityThreadä¸­ä¹Ÿå®šä¹‰äº†ä¸€ä¸ªApplicationThreadçš„ç±»ï¼Œå…¶ç»§æ‰¿äº†IApplicationThreadï¼Œå¹¶ä¸”éƒ½æ˜¯Binderå¯¹è±¡ï¼Œä¸éš¾çœ‹å‡ºè¿™é‡Œçš„IAppcationæ˜¯ä¸€ä¸ªBinderçš„clientç«¯è€ŒActivityThreadä¸­çš„ApplicationThreadæ˜¯ä¸€ä¸ªBinderå¯¹è±¡çš„serverç«¯ï¼Œæ‰€ä»¥é€šè¿‡è¿™é‡Œçš„thread.schedulePauseActivityå®é™…ä¸Šè°ƒç”¨çš„å°±æ˜¯ApplicationThreadçš„schedulePauseActivityæ–¹æ³•ã€‚ è¿™é‡Œçš„ApplicationThreadå¯ä»¥å’ŒActivityManagerNativeå¯¹äºä¸€ä¸‹ï¼š é€šè¿‡ActivityManagerNative â€“&gt; ActivityManagerServiceå®ç°äº†åº”ç”¨è¿›ç¨‹ä¸SystemServerè¿›ç¨‹çš„é€šè®¯ é€šè¿‡AppicationThread &lt;â€“ IApplicationThreadå®ç°äº†SystemServerè¿›ç¨‹ä¸åº”ç”¨è¿›ç¨‹çš„é€šè®¯ ç„¶åæˆ‘ä»¬ç»§ç»­çœ‹ä¸€ä¸‹ActivityThreadä¸­schedulePauseActivityçš„å…·ä½“å®ç°ï¼š 4.2ã€ActivityThread.schedulePauseActivity()12345678910111213 [-&gt;ActivityThread.java] public final void schedulePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport) &#123; int seq = getLifecycleSeq(); if (DEBUG_ORDER) Slog.d(TAG, \"pauseActivity \" + ActivityThread.this + \" operation received seq: \" + seq); sendMessage( finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY, token, (userLeaving ? USER_LEAVING : 0) | (dontReport ? DONT_REPORT : 0), configChanges, seq);&#125; 4.3ã€ActivityThread.sendMessage()12345 [-&gt;ActivityThread.java] private void sendMessage(int what, Object obj, int arg1, int arg2, int seq) &#123; ...... mH.sendMessage(msg);&#125; æœ€ç»ˆè°ƒç”¨äº†mHçš„sendMessageæ–¹æ³•ï¼ŒmHæ˜¯åœ¨ActivityThreadä¸­å®šä¹‰çš„ä¸€ä¸ªHandlerå¯¹è±¡ï¼Œä¸»è¦å¤„ç†SystemServerè¿›ç¨‹çš„æ¶ˆæ¯ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å…¶handleMessgeæ–¹æ³•çš„å®ç°ï¼š 4.4ã€[ActivityThread.handleMessage() : mH]12345678910111213[-&gt;ActivityThread.java : mH] public void handleMessage(Message msg) &#123; switch (msg.what) &#123; ...... case PAUSE_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); SomeArgs args = (SomeArgs) msg.obj; handlePauseActivity((IBinder) args.arg1, false, (args.argi1 &amp; USER_LEAVING) != 0, args.argi2, (args.argi1 &amp; DONT_REPORT) != 0, args.argi3); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; å¯ä»¥å‘ç°å…¶è°ƒç”¨äº†handlePauseActivityæ–¹æ³•ï¼š 4.5ã€ActivityThread.handlePauseActivity()123456789101112131415161718[-&gt;ActivityThread.java]private void handlePauseActivity(IBinder token, boolean finished, boolean userLeaving, int configChanges, boolean dontReport, int seq) &#123; ActivityClientRecord r = mActivities.get(token); ...... performPauseActivity(token, finished, r.isPreHoneycomb(), \"handlePauseActivity\"); ...... // Tell the activity manager we have paused. if (!dontReport) &#123; try &#123; ActivityManagerNative.getDefault().activityPaused(token); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; &#125; mSomeActivitiesChanged = true; &#125;&#125; ç„¶ååœ¨æ–¹æ³•ä½“å†…éƒ¨é€šè¿‡è°ƒç”¨performPauseActivityæ–¹æ³•æ¥å®ç°å¯¹æ ˆé¡¶Activityçš„onPauseç”Ÿå‘½å‘¨æœŸæ–¹æ³•çš„å›è°ƒï¼Œå¯ä»¥å…·ä½“çœ‹ä¸€ä¸‹ä»–çš„å®ç°ï¼š 4.6ã€ActivityThread.performPauseActivity()123456789101112131415 [-&gt;ActivityThread.java] final Bundle performPauseActivity(ActivityClientRecord r, boolean finished, boolean saveState, String reason) &#123; ...... performPauseActivityIfNeeded(r, reason); ......&#125;private void performPauseActivityIfNeeded(ActivityClientRecord r, String reason) &#123; ...... try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); ......&#125; è¿™æ ·å›åˆ°äº†mInstrumentationçš„callActivityOnPuaseæ–¹æ³•ï¼š 4.7ã€Instrumentation.callActivityOnPuase()1234 [-&gt;Instrumentation.java]public void callActivityOnPause(Activity activity) &#123; activity.performPause();&#125; åŸæ¥æœ€ç»ˆå›è°ƒåˆ°äº†Activityçš„performPauseæ–¹æ³•ï¼š 4.7ã€Activity.performPause()123456789101112131415[-&gt;Activity.java] final void performPause() &#123; mDoReportFullyDrawn = false; mFragments.dispatchPause(); mCalled = false; onPause(); mResumed = false; if (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onPause()\"); &#125; mResumed = false;&#125; ç»ˆäºï¼Œå¤ªä¸å®¹æ˜“äº†ï¼Œå›è°ƒåˆ°äº†Activityçš„onPauseæ–¹æ³•ï¼Œå“ˆå“ˆï¼ŒActivityç”Ÿå‘½å‘¨æœŸä¸­çš„ç¬¬ä¸€ä¸ªç”Ÿå‘½å‘¨æœŸæ–¹æ³•ç»ˆäºè¢«æˆ‘ä»¬æ‰¾åˆ°äº†ã€‚ã€‚ã€‚ã€‚ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åœ¨å¯åŠ¨ä¸€ä¸ªActivityçš„æ—¶å€™æœ€å…ˆè¢«æ‰§è¡Œçš„æ˜¯æ ˆé¡¶çš„Activityçš„onPauseæ–¹æ³•ã€‚è®°ä½è¿™ç‚¹å§ï¼Œé¢è¯•çš„æ—¶å€™ç»å¸¸ä¼šé—®åˆ°ç±»ä¼¼çš„é—®é¢˜ã€‚ ç„¶åå›åˆ°æˆ‘ä»¬çš„handlePauseActivityæ–¹æ³•ï¼Œåœ¨è¯¥æ–¹æ³•çš„æœ€åé¢æ‰§è¡Œäº†ActivityManagerNative.getDefault().activityPaused(token);æ–¹æ³•ï¼Œè¿™æ˜¯åº”ç”¨è¿›ç¨‹å‘Šè¯‰æœåŠ¡è¿›ç¨‹ï¼Œæ ˆé¡¶Activityå·²ç»æ‰§è¡Œå®ŒæˆonPauseæ–¹æ³•äº†ï¼Œé€šè¿‡å‰é¢æˆ‘ä»¬çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“è¿™å¥è¯æœ€ç»ˆä¼šè¢«ActivityManagerServiceçš„activityPausedæ–¹æ³•æ‰§è¡Œã€‚ 123456789101112 [-&gt;ActivityManagerService.java] @Overridepublic final void activityPaused(IBinder token) &#123; final long origId = Binder.clearCallingIdentity(); synchronized(this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; stack.activityPausedLocked(token, false); &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; ä»¥å‘ç°ï¼Œè¯¥æ–¹æ³•å†…éƒ¨ä¼šè°ƒç”¨ActivityStackçš„activityPausedLockedæ–¹æ³•ï¼Œå¥½å§ï¼Œçœ‹ä¸€ä¸‹activityPausedLockedæ–¹æ³•çš„å®ç°ï¼Œç„¶åæ‰§è¡Œäº†completePauseLockedæ–¹æ³•ï¼š 1234567891011121314151617181920 private void completePauseLocked(boolean resumeNext, ActivityRecord resuming) &#123; ...... if (resumeNext) &#123; final ActivityStack topStack = mStackSupervisor.getFocusedStack(); if (!mService.isSleepingOrShuttingDownLocked()) &#123; mStackSupervisor.resumeFocusedStackTopActivityLocked(topStack, prev, null); &#125; else &#123; mStackSupervisor.checkReadyForSleepLocked(); ActivityRecord top = topStack.topRunningActivityLocked(); if (top == null || (prev != null &amp;&amp; top != prev)) &#123; // If there are no more activities available to run, do resume anyway to start // something. Also if the top activity on the stack is not the just paused // activity, we need to go ahead and resume it to ensure we complete an // in-flight app switch. mStackSupervisor.resumeFocusedStackTopActivityLocked(); &#125; &#125; &#125; ......&#125; ç»è¿‡äº†ä¸€ç³»åˆ—çš„é€»è¾‘ä¹‹åï¼Œåˆè°ƒç”¨äº†resumeTopActivitiesLockedæ–¹æ³•ï¼Œåˆå›åˆ°äº†ç¬¬ä¸‰æ­¥ä¸­è§£æçš„æ–¹æ³•ä¸­äº†ï¼Œè¿™æ ·ç»è¿‡ ActivityStackSupervisor.resumeFocusedStackTopActivityLocked()â€“&gt; ActivityStack.resumeTopActivityUncheckedLocked()â€“&gt; ActivityStack.resumeTopActivityInnerLocked()â€“&gt; ActivityStackSupervisor.startSpecificActivityLocked() å¥½å§ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹startSpecificActivityLockedçš„å…·ä½“å®ç°ï¼š 1234567891011121314151617181920212223242526 [-&gt;ActivityStack.java] void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; ...... realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, \"Exception when starting activity \" + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, \"activity\", r.intent.getComponent(), false, false, true);&#125; å¯ä»¥å‘ç°åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œé¦–å…ˆä¼šåˆ¤æ–­ä¸€ä¸‹éœ€è¦å¯åŠ¨çš„Activityæ‰€éœ€è¦çš„åº”ç”¨è¿›ç¨‹æ˜¯å¦å·²ç»å¯åŠ¨ï¼Œè‹¥å¯åŠ¨çš„è¯ï¼Œåˆ™ç›´æ¥è°ƒç”¨realStartAtivityLockedæ–¹æ³•ï¼Œå¦åˆ™è°ƒç”¨startProcessLockedæ–¹æ³•ï¼Œç”¨äºå¯åŠ¨åº”ç”¨è¿›ç¨‹ã€‚ è¿™æ ·å…³äºå¯åŠ¨Activityæ—¶çš„ç¬¬ä¸‰æ­¥éª¤å°±å·²ç»æ‰§è¡Œå®Œæˆäº†ï¼Œè¿™é‡Œä¸»è¦æ˜¯å®ç°äº†å¯¹æ ˆé¡¶Activityæ‰§è¡ŒonPause æ–¹æ³•ï¼Œè€Œè¿™ä¸ªæ–¹æ³•é¦–å…ˆåˆ¤æ–­éœ€è¦å¯åŠ¨çš„Activityæ‰€å±çš„è¿›ç¨‹æ˜¯å¦å·²ç»å¯åŠ¨ï¼Œè‹¥å·²ç»å¯åŠ¨åˆ™ç›´æ¥è°ƒç”¨å¯åŠ¨Activityçš„æ–¹æ³•ï¼Œå¦åˆ™å°†å…ˆå¯åŠ¨Activityçš„åº”ç”¨è¿›ç¨‹ï¼Œç„¶ååœ¨å¯åŠ¨è¯¥Activityã€‚ äº”ã€åˆ›å»ºActivityæ‰€å±çš„åº”ç”¨è¿›ç¨‹ ActivityManagerService.startProcessLocked()-&gt; Process.start()-&gt; åˆ›å»ºè¿›ç¨‹ Process.startViaZygote()-&gt; åˆ›å»ºè¿›ç¨‹ Process.zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote)-&gt; åˆ›å»ºè¿›ç¨‹ ActivityThread.main()ActivityThread.attach()ActivityManagerProxy.attachApplication()ActivityManagerNative.onTransact()ActivityManagerService.attachApplication()ActivityManagerService.attachApplicationLocked() ApplicationThreadNative.ApplicationThreadProxy.bindApplication()ApplicationThreadNative.onTransact()ActivityThread.ApplicationThread.bindApplication()ActivityThread.sendMessage()ActivityThread.H.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleBindApplication() 5.1ã€ActivityManagerService.startProcessLocked()123456789101112131415161718192021222324 [-&gt;ActivityManagerService.java] private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr) &#123; startProcessLocked(app, hostingType, hostingNameStr, null /* abiOverride */, null /* entryPoint */, null /* entryPointArgs */);&#125;private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) &#123; ...... // Start the process. It will either succeed and return a result containing // the PID of the new process, or else throw a RuntimeException. boolean isActivityProcess = (entryPoint == null); if (entryPoint == null) entryPoint = \"android.app.ActivityThread\"; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"Start proc: \" + app.processName); checkTime(startTime, \"startProcess: asking zygote to start proc\"); Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); checkTime(startTime, \"startProcess: returned from zygote!\"); ...... &#125; å¯ä»¥å‘ç°å…¶ç»è¿‡ä¸€ç³»åˆ—çš„åˆå§‹åŒ–æ“ä½œä¹‹åè°ƒç”¨äº†Process.startæ–¹æ³•ï¼Œå¹¶ä¸”ä¼ å…¥äº†å¯åŠ¨çš„ç±»åâ€android.app.ActivityThreadâ€: 5.2ã€Process.start()12345678910111213141516171819202122 [-&gt;Process.java] public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) &#123; try &#123; return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); &#125; catch (ZygoteStartFailedEx ex) &#123; Log.e(LOG_TAG, \"Starting VM process through Zygote failed\"); throw new RuntimeException( \"Starting VM process through Zygote failed\", ex); &#125;&#125; ç„¶åè°ƒç”¨äº†startViaZygoteæ–¹æ³•ï¼š 5.3ã€Process.startViaZygote()12345678910111213141516171819 [-&gt;Process.java] private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx &#123; synchronized(Process.class) &#123; ...... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote); &#125;&#125; ç»§ç»­æŸ¥çœ‹ä¸€ä¸‹zygoteSendArgsAndGetResultæ–¹æ³•çš„å®ç°ï¼š 5.4ã€Process.zygoteSendArgsAndGetResult()12345678910111213141516171819 [-&gt;Process.java] private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx &#123; ...... // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. //ç­‰å¾…socketæœåŠ¡ç«¯ï¼ˆå³zygoteï¼‰è¿”å›æ–°åˆ›å»ºçš„è¿›ç¨‹pid; result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); ...... return result; ......&#125; è¿™ä¸ªæ–¹æ³•çš„ä¸»è¦åŠŸèƒ½æ˜¯é€šè¿‡socketé€šé“å‘Zygoteè¿›ç¨‹å‘é€ä¸€ä¸ªå‚æ•°åˆ—è¡¨ï¼Œç„¶åè¿›å…¥é˜»å¡ç­‰å¾…çŠ¶æ€ï¼Œç›´åˆ°è¿œç«¯çš„socketæœåŠ¡ç«¯å‘é€å›æ¥æ–°åˆ›å»ºçš„è¿›ç¨‹pidæ‰è¿”å›ã€‚ 5.5ã€Process.openZygoteSocketIfNeeded()12345678910111213141516171819202122232425262728293031 [-&gt;Process.java] private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123; if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123; try &#123; //å‘ä¸»zygoteå‘èµ·connect()æ“ä½œ primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to primary zygote\", ioe); &#125; &#125; if (primaryZygoteState.matches(abi)) &#123; return primaryZygoteState; &#125; // The primary zygote didn't match. Try the secondary. if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123; try &#123; //å½“ä¸»zygoteæ²¡èƒ½åŒ¹é…æˆåŠŸï¼Œåˆ™é‡‡ç”¨ç¬¬äºŒä¸ªzygoteï¼Œå‘èµ·connect()æ“ä½œ secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET); &#125; catch (IOException ioe) &#123; throw new ZygoteStartFailedEx(\"Error connecting to secondary zygote\", ioe); &#125; &#125; if (secondaryZygoteState.matches(abi)) &#123; return secondaryZygoteState; &#125; throw new ZygoteStartFailedEx(\"Unsupported zygote ABI: \" + abi);&#125; openZygoteSocketIfNeeded(abi)æ–¹æ³•æ˜¯æ ¹æ®å½“å‰çš„abiæ¥é€‰æ‹©ä¸zygoteè¿˜æ˜¯zygote64æ¥è¿›è¡Œé€šä¿¡ã€‚ æ—¢ç„¶system_serverè¿›ç¨‹çš„zygoteSendArgsAndGetResult()æ–¹æ³•é€šè¿‡socketå‘Zygoteè¿›ç¨‹å‘é€æ¶ˆæ¯ï¼Œè¿™æ˜¯ä¾¿ä¼šå”¤é†’Zygoteè¿›ç¨‹ï¼Œæ¥å“åº”socketå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼ˆå³system_serverç«¯) å…·ä½“è¯¦ç»†è¿‡ç¨‹å¯å‚è€ƒå¤§ç¥åšå®¢ç†è§£Androidè¿›ç¨‹åˆ›å»ºæµç¨‹ å’Œ Androidå››å¤§ç»„ä»¶ä¸è¿›ç¨‹å¯åŠ¨çš„å…³ç³» å¤§ç¥æ˜¯åŸºäºAndroid Mï¼Œä¹‹åæˆ‘ä¼šè·Ÿç€å¤§ç¥çš„è„šæ­¥ç«™åœ¨å·¨äººçš„è‚©è†€ä¸Šï¼Œå®ŒæˆAndroid Nè¿›ç¨‹åˆ›å»ºæµç¨‹ï¼Œä¼°è®¡å˜åŒ–ä¸å¤§åŠ æ·±è‡ªå·±ç†è§£ã€‚ è¿›ç¨‹åˆ›å»ºæµç¨‹å›¾ï¼š æ€»ç»“ï¼š å¯ä»¥å‘ç°å…¶æœ€ç»ˆè°ƒç”¨äº†Zygoteå¹¶é€šè¿‡socketé€šä¿¡çš„æ–¹å¼è®©Zygoteè¿›ç¨‹forké™¤äº†ä¸€ä¸ªæ–°çš„è¿›ç¨‹ï¼Œå¹¶æ ¹æ®æˆ‘ä»¬åˆšåˆšä¼ é€’çš„â€android.app.ActivityThreadâ€å­—ç¬¦ä¸²ï¼Œåå°„å‡ºè¯¥å¯¹è±¡å¹¶æ‰§è¡ŒActivityThreadçš„mainæ–¹æ³•ã€‚è¿™æ ·æˆ‘ä»¬æ‰€è¦å¯åŠ¨çš„åº”ç”¨è¿›ç¨‹è¿™æ—¶å€™å…¶å®å·²ç»å¯åŠ¨äº†ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰æ‰§è¡Œç›¸åº”çš„åˆå§‹åŒ–æ“ä½œã€‚ æˆ‘ä»¬å¹³æ—¶App-Crashå¸¸è§çš„logå°±æ˜¯ä»ActivityThread.main()æŠ›å‡ºå¼‚å¸¸çš„,å¯å‚è€ƒæ–‡æ¡£ï¼šAndroid 7.1.2(Android N) Androidç³»ç»Ÿå¯åŠ¨æµç¨‹ã€‚ java.lang.RuntimeException: Unable to start activity ComponentInfo{â€¦â€¦} at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726) at android.app.ActivityThread.-wrap12(ActivityThread.java) at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1477) 1234567&gt; at android.os.Handler.dispatchMessage(Handler.java:102)&gt; at android.os.Looper.loop(Looper.java:154)&gt; at android.app.ActivityThread.main(ActivityThread.java:6119)&gt; at java.lang.reflect.Method.invoke(Native Method)&gt; at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:892)&gt; at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:782)&gt; ä¸ºä»€ä¹ˆæˆ‘ä»¬å¹³æ—¶éƒ½å°†ActivityThreadç§°ä¹‹ä¸ºuiçº¿ç¨‹æˆ–è€…æ˜¯ä¸»çº¿ç¨‹ï¼Œè¿™é‡Œå¯ä»¥çœ‹å‡ºï¼Œåº”ç”¨è¿›ç¨‹è¢«åˆ›å»ºä¹‹åé¦–å…ˆæ‰§è¡Œçš„æ˜¯ActivityThreadçš„mainæ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ActivityThreadæˆä¸ºä¸»çº¿ç¨‹ã€‚ å¥½äº†ï¼Œè¿™æ—¶å€™æˆ‘ä»¬çœ‹ä¸€ä¸‹ActivityThreadçš„mainæ–¹æ³•çš„å®ç°é€»è¾‘ã€‚ 5.6ã€ActivityThread.main()123456789101112131415161718192021222324252627 [-&gt;ActivityThread.java] public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); ...... Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125;&#125; åœ¨mainæ–¹æ³•ä¸­ä¸»è¦æ‰§è¡Œäº†ä¸€äº›åˆå§‹åŒ–çš„é€»è¾‘ï¼Œå¹¶ä¸”åˆ›å»ºäº†ä¸€ä¸ªUIçº¿ç¨‹æ¶ˆæ¯é˜Ÿåˆ—ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨ä¸»çº¿ç¨‹ä¸­éšæ„çš„åˆ›å»ºHandlerè€Œä¸ä¼šæŠ¥é”™çš„åŸå› ï¼Œè¿™é‡Œæå‡ºä¸€ä¸ªé—®é¢˜ï¼Œå¤§å®¶å¯ä»¥æ€è€ƒä¸€ä¸‹ï¼šå­çº¿ç¨‹å¯ä»¥åˆ›å»ºHandlerä¹ˆï¼Ÿå¯ä»¥çš„è¯åº”è¯¥æ€ä¹ˆåšï¼Ÿ ç„¶åæ‰§è¡Œäº†ActivityThreadçš„attachæ–¹æ³•ï¼Œè¿™é‡Œæˆ‘ä»¬çœ‹ä¸€ä¸‹attachæ–¹æ³•æ‰§è¡Œäº†é‚£äº›é€»è¾‘æ“ä½œã€‚ 5.7ã€ActivityThread.attach()12345678910111213141516 private void attach(boolean system) &#123; ...... //æ­¤æ—¶è¿›ç¨‹åè¿˜æ˜¯\"&lt;pre-initialized&gt;\" android.ddm.DdmHandleAppName.setAppName(\"&lt;pre-initialized&gt;\", UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); //åˆ›å»ºå¯¹è±¡ final IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; //è°ƒç”¨åŸºäºIActivityManageræ¥å£çš„Binderé€šé“ mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; throw ex.rethrowFromSystemServer(); &#125; ......&#125; 5.8ã€ActivityManagerProxy .attachApplication()1234567891011[-&gt; ActivityManagerNative.java::ActivityManagerProxy]public void attachApplication(IApplicationThread app) throws RemoteException&#123;Parcel data = Parcel.obtain();Parcel reply = Parcel.obtain();data.writeInterfaceToken(IActivityManager.descriptor);data.writeStrongBinder(app.asBinder());mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);reply.readException();data.recycle();reply.recycle();&#125; 5.9ã€ActivityManagerNative.onTransact()123456789101112131415161718[-&gt; ActivityManagerNative.java]public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;switch (code) &#123;... case ATTACH_APPLICATION_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); //è·å–ApplicationThreadçš„binderä»£ç†ç±» ApplicationThreadProxy IApplicationThread app = ApplicationThreadNative.asInterface( data.readStrongBinder()); if (app != null) &#123; attachApplication(app); //æ­¤å¤„æ˜¯ActivityManagerServiceç±»ä¸­çš„æ–¹æ³• &#125; reply.writeNoException(); return true;&#125;&#125;&#125; åˆšåˆšæˆ‘ä»¬å·²ç»åˆ†æè¿‡å¯¹è±¡æ˜¯ActivityManagerServiceçš„Binder clientï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨äº†attachApplicationå®é™…ä¸Šå°±æ˜¯é€šè¿‡Binderæœºåˆ¶è°ƒç”¨äº†ActivityManagerServiceçš„attachApplicationï¼Œå…·ä½“è°ƒç”¨çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹ActivityManagerServiceæ˜¯å¦‚ä½•å®ç°çš„ï¼š 5.10ã€ActivityManagerService.attachApplication()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 [-&gt;ActivityManagerService.java] @Overridepublic final void attachApplication(IApplicationThread thread) &#123; synchronized (this) &#123; int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); //æ­¤å¤„çš„threadä¾¿æ˜¯ApplicationThreadProxyå¯¹è±¡,ç”¨äºè·Ÿå‰é¢é€šè¿‡Process.start()æ‰€åˆ›å»ºçš„è¿›ç¨‹ä¸­ApplicationThreadå¯¹è±¡è¿›è¡Œé€šä¿¡. attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); &#125;&#125; private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; // æ ¹æ®pidè·å–ProcessRecord ProcessRecord app; if (pid != MY_PID &amp;&amp; pid &gt;= 0) &#123; synchronized (mPidsSelfLocked) &#123; app = mPidsSelfLocked.get(pid); &#125; &#125; ...... //è·å–åº”ç”¨appInfo ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info; app.compat = compatibilityInfoForPackageLocked(appInfo); if (profileFd != null) &#123; profileFd = profileFd.dup(); &#125; ...... //ç»‘å®šåº”ç”¨ thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, null); &#125; ...... // See if the top visible activity is waiting to run in this process... if (normalMode) &#123; try &#123; if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; catch (Exception e) &#123; Slog.wtf(TAG, \"Exception thrown launching activities in \" + app, e); badApp = true; &#125; &#125; ...... return true;&#125; ä¸‹é¢,å†æ¥è¯´è¯´thread.bindApplicationçš„è¿‡ç¨‹. 5.11ã€ApplicationThreadProxy.bindApplication()123456789101112131415161718[-&gt; ApplicationThreadNative.java ::ApplicationThreadProxy]class ApplicationThreadProxy implements IApplicationThread &#123;... @Overridepublic final void bindApplication(String packageName, ApplicationInfo info, List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo, Bundle testArgs, IInstrumentationWatcher testWatcher, IUiAutomationConnection uiAutomationConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean restrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) throws RemoteException &#123; ...... mRemote.transact(BIND_APPLICATION_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125;...&#125; 5.12ã€ApplicationThreadNative.onTransact()12345678910111213141516[-&gt; ApplicationThreadNative.java]public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;switch (code) &#123;... case BIND_APPLICATION_TRANSACTION: &#123; ...... bindApplication(packageName, info, providers, testName, profilerInfo, testArgs, testWatcher, uiAutomationConnection, testMode, enableBinderTracking, trackAllocation, restrictedBackupMode, persistent, config, compatInfo, services, coreSettings); return true; &#125;...&#125; 5.13ã€ApplicationThread.bindApplication()[-&gt; ActivityThread.java ::ApplicationThread] 1234567891011121314151617181920 public final void bindApplication(String processName, ApplicationInfo appInfo, List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName, ProfilerInfo profilerInfo, Bundle instrumentationArgs, IInstrumentationWatcher instrumentationWatcher, IUiAutomationConnection instrumentationUiConnection, int debugMode, boolean enableBinderTracking, boolean trackAllocation, boolean isRestrictedBackupMode, boolean persistent, Configuration config, CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings) &#123; if (services != null) &#123; // Setup the service cache in the ServiceManager ServiceManager.initServiceCache(services); &#125; setCoreSettings(coreSettings); AppBindData data = new AppBindData(); ...... sendMessage(H.BIND_APPLICATION, data);&#125; 5.14ã€ActivityThread.handleBindApplication()å½“ä¸»çº¿ç¨‹æ”¶åˆ°H.BIND_APPLICATION,åˆ™è°ƒç”¨handleBindApplication 12345678910111213141516171819202122232425262728293031323334353637383940414243 [-&gt; ActivityThread.java ::H] private void handleBindApplication(AppBindData data) &#123; ...... mBoundApplication = data; mConfiguration = new Configuration(data.config); mCompatConfiguration = new Configuration(data.config); //è®¾ç½®è¿›ç¨‹å, ä¹Ÿå°±æ˜¯è¯´è¿›ç¨‹åæ˜¯åœ¨è¿›ç¨‹çœŸæ­£åˆ›å»ºä»¥åçš„BIND_APPLICATIONè¿‡ç¨‹ä¸­æ‰å–å // send up app name; do this *before* waiting for debugger Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName, UserHandle.myUserId()); ...... è·å–LoadedApkå¯¹è±¡ data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo); ...... //åˆ›å»ºContextImplä¸Šä¸‹æ–‡ final ContextImpl appContext = ContextImpl.createAppContext(this, data.info); updateLocaleListFromAppContext(appContext, mResourcesManager.getConfiguration().getLocales()); ...... try &#123; // If the app is being launched for full backup or restore, bring it up in // a restricted environment with the base application class. // æ­¤å¤„data.infoæ˜¯æŒ‡LoadedApk, é€šè¿‡åå°„åˆ›å»ºç›®æ ‡åº”ç”¨Applicationå¯¹è±¡ Application app = data.info.makeApplication(data.restrictedBackupMode, null); mInitialApplication = app; ...... // Do this after providers, since instrumentation tests generally start their // test thread at this point, and we don't want that racing. try &#123; mInstrumentation.onCreate(data.instrumentationArgs); &#125; ...... try &#123; mInstrumentation.callApplicationOnCreate(app); &#125; ......&#125; åœ¨handleBindApplication()çš„è¿‡ç¨‹ä¸­,ä¼šåŒæ—¶è®¾ç½®ä»¥ä¸‹ä¸¤ä¸ªå€¼: LoadedApk.mApplication AT.mInitialApplication å›¾ç¤ºæ€»ç»“ï¼š å…­ã€æ‰§è¡Œå¯åŠ¨Acitivity ActivityStackSupervisor.attachApplicationLocked()ActivityStackSupervisor.realStartActivityLocked()IApplicationThread.scheduleLaunchActivity()ActivityThread.ApplicationThread.scheduleLaunchActivity()ActivityThread.sendMessage()ActivityThread.H.handleMessage()ActivityThread.handleLauncherActivity()ActivityThread.performLauncherActivity()Instrumentation.callActivityOnCreate()-&gt; Activity.performCreate() Activity.onCreate() åœ¨ç¬¬äº”èŠ‚AMS.startProcessLocked()æ•´ä¸ªè¿‡ç¨‹ï¼Œåˆ›å»ºå®Œæ–°è¿›ç¨‹åä¼šåœ¨æ–°è¿›ç¨‹ä¸­è°ƒç”¨AMP.attachApplication ï¼Œè¯¥æ–¹æ³•ç»è¿‡binder ipcåè°ƒç”¨åˆ°AMS.attachApplicationLockedã€‚è¯¥æ–¹æ³•æ‰§è¡Œäº†ä¸€ç³»åˆ—çš„åˆå§‹åŒ–æ“ä½œï¼Œåœ¨æ‰§è¡Œå®ŒbindApplication()ä¹‹åè¿›å…¥ActivityStackSupervisor.attachApplicationLocked()ï¼Œè¿™æ ·æˆ‘ä»¬æ•´ä¸ªåº”ç”¨è¿›ç¨‹å·²ç»å¯åŠ¨èµ·æ¥äº†ã€‚ç»ˆäºå¯ä»¥å¼€å§‹activityçš„å¯åŠ¨é€»è¾‘äº†ã€‚ å…³ç³»å›¾ï¼šActivityThreadç®€ä»‹ é¦–å…ˆçœ‹ä¸€ä¸‹attachApplicationLockedæ–¹æ³•çš„å®ç°ï¼š 6.1ã€ActivityStackSupervisor.attachApplicationLocked()1234567891011121314151617181920212223242526272829 [-&gt;ActivityStackSupervisor.java] boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack)) &#123; continue; &#125; ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; ...... &#125; &#125; &#125; &#125; if (!didSomething) &#123; ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); &#125; return didSomething;&#125; å¯ä»¥å‘ç°å…¶å†…éƒ¨è°ƒç”¨äº†realStartActivityLockedæ–¹æ³•ï¼Œé€šè¿‡åå­—å¯ä»¥çŸ¥é“è¿™ä¸ªæ–¹æ³•åº”è¯¥å°±æ˜¯ç”¨æ¥å¯åŠ¨Activityçš„ï¼Œçœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•çš„å®ç°é€»è¾‘ï¼š 6.2ã€ActivityStackSupervisor.realStartActivityLocked()12345678910111213141516 [-&gt;ActivityStackSupervisor.java] final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; ...... app.forceProcessStateUpTo(mService.mTopProcessState); app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...... return true;&#125; å¯ä»¥å‘ç°ä¸ç¬¬å››èŠ‚æ‰§è¡Œæ ˆé¡¶Activity onPauseæ—¶ç±»ä¼¼ï¼Œè¿™é‡Œä¹Ÿæ˜¯é€šè¿‡è°ƒç”¨IApplicationThreadçš„æ–¹æ³•å®ç°çš„ï¼Œè¿™é‡Œè°ƒç”¨çš„æ˜¯scheduleLaunchActivityæ–¹æ³•ï¼Œæ‰€ä»¥çœŸæ­£æ‰§è¡Œçš„æ˜¯ActivityThreadä¸­çš„scheduleLaunchActivityã€‚ 6.3ã€ApplicationThread.scheduleLaunchActivity()1234567891011121314151617[-&gt; ActivityThread.java :ApplicationThread] public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); ...... updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 6.4ã€H.handleMessage12345678910111213[-&gt; ActivityThread.java ::H] public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\"); &#125; break; ...... &#125; 6.5ã€ActivityThread.handleLaunchActivity()ActivityThreadæ¥æ”¶åˆ°SystemServerè¿›ç¨‹çš„æ¶ˆæ¯ä¹‹åä¼šé€šè¿‡å…¶å†…éƒ¨çš„Handlerå¯¹è±¡åˆ†å‘æ¶ˆæ¯ï¼Œç»è¿‡ä¸€ç³»åˆ—çš„åˆ†å‘ä¹‹åè°ƒç”¨äº†ActivityThreadçš„handleLaunchActivityæ–¹æ³•ï¼š 1234567891011121314151617[-&gt; ActivityThread.java] private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ...... // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); &#125; ......&#125; å¯ä»¥å‘ç°è¿™é‡Œè°ƒç”¨äº†performLauncherActivityï¼Œçœ‹åå­—åº”è¯¥å°±æ˜¯æ‰§è¡ŒActivityçš„å¯åŠ¨æ“ä½œäº†â€¦â€¦ 6.6ã€ActivityThread.performLaunchActivity()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[-&gt; ActivityThread.java] private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; ...... try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); ...... activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); ...... activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ...... //ç”Ÿå‘½å‘¨æœŸonStartã€onresume if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; ...... return activity;&#125; å¯ä»¥å‘ç°è¿™é‡Œæˆ‘ä»¬éœ€è¦çš„Activityå¯¹è±¡ç»ˆäºæ˜¯åˆ›å»ºå‡ºæ¥äº†ï¼Œç„¶ååœ¨ä»£ç ä¸­å…¶è°ƒç”¨Instrumentationçš„callActivityOnCreateæ–¹æ³•ã€‚ 6.7ã€Instrumentation.callActivityOnCreate()1234567 [-&gt;Instrumentation.java] public void callActivityOnCreate(Activity activity, Bundle icicle, PersistableBundle persistentState) &#123; prePerformCreate(activity); activity.performCreate(icicle, persistentState); postPerformCreate(activity);&#125; ç„¶åæ‰§è¡Œactivityçš„performCreateæ–¹æ³•â€¦â€¦ 6.8ã€Activity.performCreate()123456 final void performCreate(Bundle icicle, PersistableBundle persistentState) &#123; restoreHasCurrentPermissionRequest(icicle); onCreate(icicle, persistentState); mActivityTransitionState.readState(icicle); performCreateCommon();&#125; ç®€è¦è¯´æ˜å‰©ä½™ç”Ÿå‘½å‘¨æœŸï¼š å›åˆ°æˆ‘ä»¬çš„performLaunchActivityæ–¹æ³•ï¼Œå…¶åœ¨è°ƒç”¨äº†mInstrumentation.callActivityOnCreateæ–¹æ³•ä¹‹ååˆè°ƒç”¨äº†activity.performStart()æ–¹æ³•ï¼Œçœ‹ä¸€ä¸‹ä»–çš„å®ç°æ–¹å¼ï¼š 123456789101112131415161718[-&gt;Activity.java]final void performStart() &#123; mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions()); mFragments.noteStateNotSaved(); mCalled = false; mFragments.execPendingActions(); mInstrumentation.callActivityOnStart(this); if (!mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + mComponent.toShortString() + \" did not call through to super.onStart()\"); &#125; mFragments.dispatchStart(); mFragments.reportLoaderStart(); ...... mActivityTransitionState.enterReady(this);&#125; è¿˜æ˜¯é€šè¿‡Instrumentationè°ƒç”¨callActivityOnStartæ–¹æ³•ï¼š 12345[-&gt;Instrumentation.java]public void callActivityOnStart(Activity activity) &#123; activity.onStart();&#125; ç„¶åæ˜¯ç›´æ¥è°ƒç”¨activityçš„onStartæ–¹æ³•ï¼Œç¬¬ä¸‰ä¸ªç”Ÿå‘½å‘¨æœŸæ–¹æ³•å‡ºç°äº†ï¼ŒO(âˆ©_âˆ©)O è¿˜æ˜¯å›åˆ°æˆ‘ä»¬åˆšåˆšçš„handleLaunchActivityæ–¹æ³•ï¼Œåœ¨è°ƒç”¨å®ŒperformLaunchActivityæ–¹æ³•ä¹‹åï¼Œå…¶æœ‰åŠç”¨äº†handleResumeActivityæ–¹æ³•ï¼Œå¥½å§ï¼Œçœ‹åå­—åº”è¯¥æ˜¯å›è°ƒActivityçš„onResumeæ–¹æ³•çš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152[-&gt; ActivityThread.java] final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123; ActivityClientRecord r = mActivities.get(token); ...... // TODO Push resumeArgs into the activity for consideration r = performResumeActivity(token, clearHide, reason); ..... if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) &#123; a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity // in addView-&gt;ViewRootImpl#setView. If we are instead reusing // the decor view we have to notify the view root that the // callbacks may have changed. ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) &#123; impl.notifyChildRebuilt(); &#125; &#125; if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; // If the window has already been added, but during resume // we started another activity, then don't yet make the // window visible. &#125; else if (!willBeVisible) &#123; if (localLOGV) Slog.v( TAG, \"Launch \" + r + \" mStartedActivity set\"); r.hideForNow = true; &#125; if (!r.onlyLocalRequest) &#123; r.nextIdle = mNewActivities; mNewActivities = r; if (localLOGV) Slog.v( TAG, \"Scheduling idle handler for \" + r); //çº¿ç¨‹ç©ºé—²ï¼Œä¹Ÿå°±æ˜¯activityåˆ›å»ºå®Œæ¯•ä¹‹åï¼Œå®ƒä¼šæ‰§è¡ŒqueueIdleé‡Œé¢çš„ä»£ç ã€‚ Looper.myQueue().addIdleHandler(new Idler()); &#125; &#125; å¯ä»¥å‘ç°å…¶resumeActivityçš„é€»è¾‘è°ƒç”¨åˆ°äº†performResumeActivityæ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹performResumeActivityæ˜¯å¦‚ä½•å®ç°çš„ã€‚ 1234567891011121314151617181920212223242526272829[-&gt; ActivityThread.java] public final ActivityClientRecord performResumeActivity(IBinder token, boolean clearHide, String reason) &#123; ActivityClientRecord r = mActivities.get(token); if (localLOGV) Slog.v(TAG, \"Performing resume of \" + r + \" finished=\" + r.activity.mFinished); if (r != null &amp;&amp; !r.activity.mFinished) &#123; ... try &#123; ...... r.activity.performResume(); for (int i = mRelaunchingActivities.size() - 1; i &gt;= 0; i--) &#123; final ActivityClientRecord relaunching = mRelaunchingActivities.get(i); if (relaunching.token == r.token &amp;&amp; relaunching.onlyLocalRequest &amp;&amp; relaunching.startsNotResumed) &#123; relaunching.startsNotResumed = false; &#125; &#125; EventLog.writeEvent(LOG_AM_ON_RESUME_CALLED, UserHandle.myUserId(), r.activity.getComponentName().getClassName(), reason); r.paused = false; r.stopped = false; r.state = null; r.persistentState = null; &#125; ...... &#125; return r; &#125; åœ¨æ–¹æ³•ä½“ä¸­ï¼Œæœ€ç»ˆè°ƒç”¨äº†r.activity.performResume()æ–¹æ³•ï¼Œå¥½å§ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯Activityä¸­å®šä¹‰çš„æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦åœ¨Activityä¸­æŸ¥çœ‹è¿™ä¸ªæ–¹æ³•çš„å…·ä½“å®ç°ï¼š 12345678[-&gt; Activity.java]final void performResume() &#123; performRestart(); ... mInstrumentation.callActivityOnResume(this); ... &#125; å¯ä»¥çœ‹åˆ°ç¬¬ä¸€ä¸ªåˆ†æ”¯èµ°äº†performRestart()ï¼Œè¿™ä¸ªæ–¹æ³•å³æ—¶onRestart()ç”Ÿå‘½å‘¨æœŸã€‚ 12345678910111213141516171819202122 final void performRestart() &#123; ... mInstrumentation.callActivityOnRestart(this); performStart();&#125; final void performRestart() &#123; mFragments.noteStateNotSaved(); if (mToken != null &amp;&amp; mParent == null) &#123; // No need to check mStopped, the roots will check if they were actually stopped. WindowManagerGlobal.getInstance().setStoppedState(mToken, false /* stopped */); &#125; if (mStopped) &#123; mStopped = false; ...... mCalled = false; mInstrumentation.callActivityOnRestart(this); ...... performStart(); &#125; &#125; å¯ä»¥çœ‹åˆ°é¦–å…ˆåˆ¤æ–­å½“å‰activityæ˜¯å¦ä¸ºStoppedçŠ¶æ€ï¼Œæ˜¯æ‰ä¼šèµ°OnRestart()-&gt;Onstart()ç”Ÿå‘½å‘¨æœŸã€‚ ç»§ç»­çœ‹ä¸‹performResume()ç¬¬äºŒä¸ªåˆ†æ”¯ï¼Œåˆæ˜¯ç†Ÿæ‚‰çš„å‘³é“ï¼Œé€šè¿‡Instrumentationæ¥è°ƒç”¨äº†callActivityOnResumeæ–¹æ³•ã€‚ã€‚ã€‚ 12345678910111213141516[-&gt;Instrumentation.java]public void callActivityOnResume(Activity activity) &#123; activity.mResumed = true; activity.onResume(); if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); am.match(activity, activity, activity.getIntent()); &#125; &#125; &#125; &#125; O(âˆ©_âˆ©)Oï¼Œç¬¬å››ä¸ªç”Ÿå‘½å‘¨æœŸæ–¹æ³•å‡ºç°äº†ï¼ŒonResumeæ–¹æ³•ã€‚ã€‚ã€‚ ç»ˆäºå›è°ƒonResumeæ–¹æ³•äº†ï¼Œè¿™æ—¶å€™æˆ‘ä»¬çš„ç•Œé¢åº”è¯¥å·²ç»å±•ç¤ºå‡ºæ¥äº†ï¼Œç…§ç†æ¥è¯´æˆ‘ä»¬çš„Activityåº”è¯¥å·²ç»å¯åŠ¨å®Œæˆäº†ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰ã€‚ æœ‰ä¸€ä¸ªé—®é¢˜ï¼ŒActivity a å¯åŠ¨ Activity b ä¼šè§¦å‘é‚£äº›ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ï¼Ÿ ä½ å¯èƒ½ä¼šå›ç­”ï¼Ÿbçš„onCreate onStartæ–¹æ³•ï¼ŒonResumeæ–¹æ³• açš„onPauseæ–¹æ³•å’ŒonStopæ–¹æ³•ï¼ŒonStopæ–¹æ³•è¿˜æ²¡å›è°ƒï¼ŒO(âˆ©_âˆ©)Oï¼Œå¯¹äº†ç¼ºå°‘çš„å°±æ˜¯å¯¹onStopæ–¹æ³•çš„å›è°ƒã€‚ ä¸ƒã€æ ˆé¡¶Activityæ‰§è¡ŒonStopæ–¹æ³• Looper.myQueue().addIdleHandler(new Idler())-&gt; Idler.queueIdle()ActivityManagerNative.getDefault().activityIdle()ActivityManagerService.activityIdle()ActivityStackSupervisor.activityIdleInternalLocked()ActivityStack.stopActivityLocked()IApplicationThread.scheduleStopActivity()ActivityThread.scheduleStopActivity()-&gt; ActivityThread.sendMessage()ActivityThread.H.sendMessage()-&gt; ActivityThread.H.handleMessage()ActivityThread.handleStopActivity()ActivityThread.performStopActivityInner()ActivityThread.callCallActivityOnSaveInstanceState()Instrumentation.callActivityOnSaveInstanceState()Activity.performSaveInstanceState()-&gt; Activity.onSaveInstanceState()Activity.performStop()-&gt; Instrumentation.callActivityOnStop()Activity.onStop() å›åˆ°æˆ‘ä»¬çš„handleResumeActivityæ–¹æ³•ï¼Œåœ¨æ–¹æ³•ä½“æœ€åæœ‰è¿™æ ·çš„ä¸€ä»£ç ï¼š 1Looper.myQueue().addIdleHandler(new Idler()); è¿™æ®µä»£ç æ˜¯å¼‚æ­¥æ¶ˆæ¯æœºåˆ¶ç›¸å…³çš„ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹ä¸€ä¸‹Idlerå¯¹è±¡çš„å…·ä½“å®ç°ï¼š 1234567891011121314151617181920212223242526private class Idler implements MessageQueue.IdleHandler &#123; @Override public final boolean queueIdle() &#123; ActivityClientRecord a = mNewActivities; ..... if (a != null) &#123; mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do &#123; ...... if (a.activity != null &amp;&amp; !a.activity.mFinished) &#123; try &#123; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; &#125; catch (RemoteException ex) &#123; // Ignore &#125; &#125; prev = a; a = a.nextIdle; prev.nextIdle = null; &#125; while (a != null); &#125; &#125; &#125; è¿™æ ·å½“Messagequeueæ‰§è¡Œaddæ–¹æ³•ä¹‹åå°±ä¼šå›è°ƒå…¶queueIdle()æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨æ–¹æ³•ä½“ä¸­å…¶è°ƒç”¨äº†ActivityManagerNative.getDefault().activityIdle()ï¼Œå¥½å§ï¼Œç†Ÿæ‚‰äº†Binderæœºåˆ¶ä»¥åæˆ‘ä»¬çŸ¥é“è¿™æ®µä»£ç ä¼šæ‰§è¡Œåˆ°ActivityManagerServiceçš„activityIdleæ–¹æ³•ï¼š 123456789101112131415161718192021@Overridepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) &#123; final long origId = Binder.clearCallingIdentity(); synchronized (this) &#123; ActivityStack stack = ActivityRecord.getStackLocked(token); if (stack != null) &#123; ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) &#123; if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) &#123; try &#123; mProfileFd.close(); &#125; catch (IOException e) &#123; &#125; clearProfilerLocked(); &#125; &#125; &#125; &#125; Binder.restoreCallingIdentity(origId);&#125; ç„¶ååœ¨activityIdleæ–¹æ³•ä¸­åˆè°ƒç”¨äº†ActivityStackSupervisor.activityIdleInternalLockedæ–¹æ³•ï¼š 12345678910111213141516171819[-&gt;ActivityStackSupervisor.java]final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123; ... for (int i = 0; i &lt; NS; i++) &#123; r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) &#123; if (r.finishing) &#123; stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); &#125; else &#123; stack.stopActivityLocked(r); &#125; &#125; &#125; ... return r; &#125; å¯ä»¥å‘ç°åœ¨å…¶ä¸­åˆè°ƒç”¨äº†ActivityStack.stopActivityLockedæ–¹æ³•ï¼š 12345678final void stopActivityLocked(ActivityRecord r) &#123; if ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != 0 || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != 0) &#123; ... r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ... &#125; &#125; å¥½å§ï¼Œåˆæ˜¯ç›¸åŒçš„é€»è¾‘é€šè¿‡IApplicationThread.scheduleStopActivity,æœ€ç»ˆè°ƒç”¨äº†ActivityThread.scheduleStopActivity()æ–¹æ³•ã€‚ã€‚ã€‚ã€‚ 123456public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) &#123; sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges); &#125; ç„¶åæ‰§è¡ŒsendMessageæ–¹æ³•ï¼Œæœ€ç»ˆæ‰§è¡ŒHï¼ˆHandlerï¼‰çš„sendMessageæ–¹æ³•ï¼Œå¹¶è¢«Hçš„handleMessgeæ–¹æ³•æ¥æ”¶æ‰§è¡ŒhandleStopActivityæ–¹æ³•ã€‚ã€‚ã€‚ 123456private void handleStopActivity(IBinder token, boolean show, int configChanges) &#123; ... performStopActivityInner(r, info, show, true); ... &#125; ç„¶åæˆ‘ä»¬çœ‹ä¸€ä¸‹performStopActivityInnerçš„å®ç°é€»è¾‘ï¼š 123456789101112131415[-&gt;ActivityThread.java]private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState) &#123; ... if (!keepShown) &#123; try &#123; r.activity.performStop(); &#125; catch (Exception e) &#123; ...... &#125; r.stopped = true; &#125; &#125; &#125; æˆ‘ä»¬çœ‹ä¸€ä¸‹performStopActivityInnerä¸­è°ƒç”¨åˆ°çš„Activityæ–¹æ³•çš„performStopæ–¹æ³• 1234567891011final void performStop() &#123; if (!mStopped) &#123; ...... mFragments.dispatchStop(); mCalled = false; mInstrumentation.callActivityOnStop(this); ...... mStopped = true; &#125; mResumed = false; &#125; è¿˜æ˜¯é€šè¿‡Instrumentationæ¥å®ç°çš„ï¼Œè°ƒç”¨äº†å®ƒçš„callActivityOnStopæ–¹æ³•ã€‚ã€‚ 123public void callActivityOnStop(Activity activity) &#123; activity.onStop(); &#125; ç”Ÿå‘½å‘¨æœŸæ–¹æ³•onStop()å‡ºæ¥äº†ã€‚ æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹Activity çš„ç”Ÿå‘½å‘¨æœŸï¼š protected void onCreate();protected void onRestart();protected void onStart();protected void onResume();protected void onPause();protected void onStop();protected void onDestory(); å‰é¢æˆ‘ä»¬åˆ†æäº†onCreate()ã€onStart()ã€onRestart() ã€onResume()ã€onPause()ã€onStop()ã€‚ Activity é”€æ¯æ—¶çš„ onDestroy() å›è°ƒéƒ½ä¸å‰é¢çš„è¿‡ç¨‹å¤§åŒå°å¼‚ï¼Œè¿™é‡Œå°±åªåˆ—ä¸¾ç›¸åº”çš„æ–¹æ³•æ ˆï¼Œä¸å†ç»§ç»­æè¿°ã€‚ Activity.finish()ActivityManagerNative.getDefault().finishActivity()ActivityManagerService.finishActivity()ActivityStack.requestFinishActivityLocked()ActivityStack.finishActivityLocked()ActivityStack.startPausingLocked()å‚è€ƒï¼šAndroidæºç è§£æä¹‹ï¼ˆåäº”ï¼‰â€“&gt;Activityé”€æ¯æµç¨‹ å¯åŠ¨æµç¨‹ï¼š 1ã€ç‚¹å‡»æ¡Œé¢Appå›¾æ ‡ï¼ŒLauncherè¿›ç¨‹é‡‡ç”¨Binder IPCå‘system_serverè¿›ç¨‹å‘èµ·startActivityè¯·æ±‚ï¼›2ã€system_serverè¿›ç¨‹æ¥æ”¶åˆ°è¯·æ±‚åï¼Œå‘zygoteè¿›ç¨‹å‘é€åˆ›å»ºè¿›ç¨‹çš„è¯·æ±‚ï¼›3ã€Zygoteè¿›ç¨‹forkå‡ºæ–°çš„å­è¿›ç¨‹ï¼Œå³Appè¿›ç¨‹ï¼›4ã€Appè¿›ç¨‹ï¼Œé€šè¿‡Binder IPCå‘sytem_serverè¿›ç¨‹å‘èµ·attachApplicationè¯·æ±‚ï¼›5ã€system_serverè¿›ç¨‹åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œè¿›è¡Œä¸€ç³»åˆ—å‡†å¤‡å·¥ä½œåï¼Œå†é€šè¿‡binder IPCå‘Appè¿›ç¨‹å‘é€scheduleLaunchActivityè¯·æ±‚ï¼›6ã€Appè¿›ç¨‹çš„binderçº¿ç¨‹ï¼ˆApplicationThreadï¼‰åœ¨æ”¶åˆ°è¯·æ±‚åï¼Œé€šè¿‡handlerå‘ä¸»çº¿ç¨‹å‘é€LAUNCH_ACTIVITYæ¶ˆæ¯ï¼›7ã€ä¸»çº¿ç¨‹åœ¨æ”¶åˆ°Messageåï¼Œé€šè¿‡å‘å°„æœºåˆ¶åˆ›å»ºç›®æ ‡Activityï¼Œå¹¶å›è°ƒActivity.onCreate()ç­‰æ–¹æ³•ã€‚ åˆ°æ­¤ï¼ŒAppä¾¿æ­£å¼å¯åŠ¨ï¼Œå¼€å§‹è¿›å…¥Activityç”Ÿå‘½å‘¨æœŸï¼Œæ‰§è¡Œå®ŒonCreate/onStart/onResumeæ–¹æ³•ï¼ŒUIæ¸²æŸ“ç»“æŸåä¾¿å¯ä»¥çœ‹åˆ°Appçš„ä¸»ç•Œé¢ã€‚ å¯åŠ¨Activityè¾ƒä¸ºå¤æ‚ï¼Œåç»­ä»‹ç»çª—å£åŠ è½½æ¸²æŸ“è¿‡ç¨‹ï¼Œå¯å‚è€ƒæ–‡æ¡£ï¼šã€Android 7.1.2 (Android N) Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹åˆ†æã€‘ å‚è€ƒæ–‡æ¡£(ç‰¹åˆ«æ„Ÿè°¢)ï¼šAndroidæºç è§£æä¹‹ï¼ˆåå››ï¼‰â€“&gt;Activityå¯åŠ¨æµç¨‹Android Activityå¯åŠ¨è¿‡ç¨‹åˆ†æAndroidæºç è§£æä¹‹ï¼ˆåäº”ï¼‰â€“&gt;Activityé”€æ¯æµç¨‹å‡¯å­å“¥å¸¦ä½ å­¦Frameworkâ€“Activityå¯åŠ¨è¿‡ç¨‹å…¨è§£ææ·±å…¥ç†è§£Activityå¯åŠ¨æµç¨‹(ä¸€)â€“Activityå¯åŠ¨çš„æ¦‚è¦æµç¨‹Android 7.0 ActivityManagerService å¯åŠ¨Activityçš„è¿‡ç¨‹ ç³»åˆ—Activityç”Ÿå‘½å‘¨æœŸçš„å›è°ƒï¼Œä½ åº”è¯¥çŸ¥é“å¾—æ›´å¤šï¼â€“Androidæºç å‰–æï¼ˆä¸Šï¼‰Activityç”Ÿå‘½å‘¨æœŸçš„å›è°ƒï¼Œä½ åº”è¯¥çŸ¥é“å¾—æ›´å¤šï¼â€“Androidæºç å‰–æï¼ˆä¸‹ï¼‰","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Android ç³»ç»Ÿå¯åŠ¨æµç¨‹ åˆ†æ","slug":"Android-7-1-2-Android-N-Androidç³»ç»Ÿå¯åŠ¨æµç¨‹","date":"2017-08-31T16:00:00.000Z","updated":"2018-04-19T14:29:28.620Z","comments":true,"path":"2017/09/01/Android-7-1-2-Android-N-Androidç³»ç»Ÿå¯åŠ¨æµç¨‹/","link":"","permalink":"http://zhoujinjian.cc/2017/09/01/Android-7-1-2-Android-N-Androidç³»ç»Ÿå¯åŠ¨æµç¨‹/","excerpt":"","text":"æºç ï¼šsystem/core/rootdir/ init.rc init.zygote64.rc system/core/init/ init.cpp init_parser.cpp signal_handler.cpp frameworks/base/cmds/app_process/ App_main.cpp frameworks/base/core/jni/ AndroidRuntime.cpp frameworks/base/core/java/com/android/internal/os/ ZygoteInit.java Zygote.java ZygoteConnection.java frameworks/base/core/java/com/android/internal/os/ ZygoteInit.java RuntimeInit.java Zygote.java frameworks/base/core/services/java/com/android/server/ SystemServer.java frameworks/base/core/jni/ com_android_internal_os_Zygote.cpp AndroidRuntime.cpp frameworks/base/services/java/com/android/server/ SystemServer.java frameworks/base/services/core/java/com/android/server/ SystemServiceManager.java ServiceThread.java am/ActivityManagerService.java frameworks/base/core/java/android/app/ ActivityThread.java LoadedApk.java ContextImpl.java frameworks/base/core/java/android/app/ ActivityThread.java LoadedApk.java ContextImpl.java frameworks/base/services/java/com/android/server/ SystemServer.java frameworks/base/services/core/java/com/android/server/ SystemServiceManager.java ServiceThread.java pm/Installer.java am/ActivityManagerService.java åšå®¢åŸå›¾é“¾æ¥ä¸€ã€Androidæ¦‚è¿°Androidç³»ç»Ÿéå¸¸åºå¤§ï¼Œåº•å±‚æ˜¯é‡‡ç”¨Linuxä½œä¸ºåŸºåº•ï¼Œä¸Šå±‚é‡‡ç”¨å¸¦æœ‰è™šæ‹Ÿæœºçš„Javaå±‚ï¼Œé€šè¿‡é€šè¿‡JNIæŠ€æœ¯ï¼Œå°†ä¸Šä¸‹æ‰“é€šï¼Œèä¸ºä¸€ä½“ã€‚ä¸‹å›¾æ˜¯Googleæä¾›çš„ä¸€å¼ ç»å…¸çš„4å±‚æ¶æ„å›¾ï¼Œä»ä¸‹å¾€ä¸Šï¼Œä¾æ¬¡åˆ†ä¸ºLinuxå†…æ ¸ï¼Œç³»ç»Ÿåº“å’ŒAndroid Runtimeï¼Œåº”ç”¨æ¡†æ¶å±‚ï¼Œåº”ç”¨ç¨‹åºå±‚è¿™4å±‚æ¶æ„ï¼Œæ¯ä¸€å±‚éƒ½åŒ…å«å¤§é‡çš„å­æ¨¡å—æˆ–å­ç³»ç»Ÿã€‚ äºŒã€ç³»ç»Ÿå¯åŠ¨Googleæä¾›çš„4å±‚æ¶æ„å›¾ï¼Œæ˜¯éå¸¸ç»å…¸ï¼Œä½†åªæ˜¯å¦‚å’ç –èˆ¬çš„æ–¹å¼ï¼Œç®€å•åœ°åˆ†å±‚ï¼Œè€Œä¸è¶³è¡¨è¾¾Androidæ•´ä¸ªç³»ç»Ÿçš„å¯åŠ¨è¿‡ç¨‹ï¼Œç¯ç¯ç›¸æ‰£çš„è¿æ¥å…³ç³»ï¼Œæœ¬æ–‡æ›´å¤šçš„æ˜¯ä»¥è¿›ç¨‹çš„è§†è§’ï¼Œä»¥åˆ†å±‚çš„æ¶æ„æ¥è¯ é‡ŠAndroidç³»ç»Ÿçš„å…¨è²Œã€‚ ç³»ç»Ÿå¯åŠ¨æ¶æ„å›¾ ä¸‰ã€è®¾å¤‡å¯åŠ¨è¿‡ç¨‹3.1ã€Bootloaderå¼•å¯¼Boot ROM: å½“æ‰‹æœºå¤„äºå…³æœºçŠ¶æ€æ—¶ï¼Œé•¿æŒ‰Poweré”®å¼€æœºï¼Œå¼•å¯¼èŠ¯ç‰‡å¼€å§‹ä»å›ºåŒ–åœ¨ROMé‡Œçš„é¢„è®¾å‡ºä»£ç å¼€å§‹æ‰§è¡Œï¼Œç„¶ååŠ è½½å¼•å¯¼ç¨‹åºåˆ°RAMï¼› Boot Loaderï¼šè¿™æ˜¯å¯åŠ¨Androidç³»ç»Ÿä¹‹å‰çš„å¼•å¯¼ç¨‹åºï¼Œä¸»è¦æ˜¯æ£€æŸ¥RAMï¼Œåˆå§‹åŒ–ç¡¬ä»¶è®¾å¤‡ï¼ˆå¦‚CPUã€å†…å­˜ã€Flashç­‰ï¼‰å¹¶ä¸”é€šè¿‡å»ºç«‹å†…å­˜ç©ºé—´æ˜ å°„ï¼Œä¸ºè£…è½½Linuxå†…æ ¸å‡†å¤‡åˆé€‚çš„ç¯å¢ƒã€‚ä¸€æ—¦Linuxå†…æ ¸è£…è½½å®Œæ¯•ï¼ŒBootloaderå°†ä¼šä»å†…å­˜ä¸­æ¸…é™¤æ‰ã€‚ å¦‚æœç”¨æˆ·åœ¨Bootloaderè¿è¡ŒæœŸé—´ï¼ŒæŒ‰ä¸‹é¢„å®šä¹‰çš„ç»„åˆå¥ï¼Œå¯ä»¥è¿›å…¥ç³»ç»Ÿçš„æ›´æ–°æ¨¡å—ã€‚Androidçš„ä¸‹è½½æ›´æ–°å¯ä»¥é€‰æ‹©è¿›å…¥Fastbootæ¨¡å¼æˆ–è€…Recoveryæ¨¡å¼ã€‚ Fastbootæ˜¯Androidè®¾è®¡çš„ä¸€å¥—é€šè¿‡USBæ¥æ›´æ–°æ‰‹æœºåˆ†åŒºæ˜ åƒçš„åè®®ï¼Œæ–¹ä¾¿å¼€å‘äººå‘˜èƒ½å¿«é€Ÿæ›´æ–°æŒ‡å®šçš„æ‰‹æœºåˆ†åŒºã€‚ä½†æ˜¯ä¸€èˆ¬çš„é›¶å”®æœºä¸Šå¾€å¾€å»æ‰äº†Fastbootï¼ŒGoogleé”€å”®çš„å¼€å‘æœºåˆ™å¸¦æœ‰Fastbootæ¨¡å—ã€‚ Recoveryæ¨¡å¼æ˜¯Androidç‰¹æœ‰çš„å‡çº§ç³»ç»Ÿã€‚åˆ©ç”¨Recoveryæ¨¡å¼ï¼Œæ‰‹æœºå¯ä»¥è¿›è¡Œæ¢å¤å‡ºå‚è®¾ç½®æˆ–è¿›è¡ŒOTAã€è¡¥ä¸å’Œå›ºä»¶å‡çº§ã€‚è¿›å…¥Recoveryæ¨¡å¼å®é™…ä¸Šæ˜¯å¯åŠ¨äº†ä¸€ä¸ªæ–‡æœ¬æ¨¡å¼çš„Linuxã€‚ 3.2ã€è£…è½½å’Œå¯åŠ¨Linuxå†…æ ¸åˆ°è¿™é‡Œæ‰åˆšåˆšå¼€å§‹è¿›å…¥Androidç³»ç»Ÿ. å¯åŠ¨Kernelçš„0å·è¿›ç¨‹ï¼šåˆå§‹åŒ–è¿›ç¨‹ç®¡ç†ã€å†…å­˜ç®¡ç†ï¼ŒåŠ è½½Display,Camera Driverï¼ŒBinder Driverç­‰ç›¸å…³å·¥ä½œï¼› å¯åŠ¨kthreaddè¿›ç¨‹ï¼ˆpid=2ï¼‰ï¼šæ˜¯Linuxç³»ç»Ÿçš„å†…æ ¸è¿›ç¨‹ï¼Œä¼šåˆ›å»ºå†…æ ¸å·¥ä½œçº¿ç¨‹kworkderï¼Œè½¯ä¸­æ–­çº¿ç¨‹ksoftirqdï¼Œthermalç­‰å†…æ ¸å®ˆæŠ¤è¿›ç¨‹ã€‚kthreaddè¿›ç¨‹æ˜¯æ‰€æœ‰å†…æ ¸è¿›ç¨‹çš„é¼»ç¥–ã€‚ Androidçš„boot.imgå­˜æ”¾çš„å°±æ˜¯Linuxå†…æ ¸å’Œä¸€ä¸ªæ ¹æ–‡ä»¶ç³»ç»Ÿã€‚Bootloaderä¼šæŠŠboot.imgæ˜ åƒè£…è½½è¿›å†…å­˜ã€‚ç„¶åLinuxå†…æ ¸ä¼šæ‰§è¡Œæ•´ä¸ªç³»ç»Ÿçš„åˆå§‹åŒ–ï¼Œå®Œæˆåè£…è½½æ ¹æ–‡ä»¶ç³»ç»Ÿï¼Œæœ€åå¯åŠ¨Initè¿›ç¨‹ã€‚ 3.3ã€å¯åŠ¨Initè¿›ç¨‹Linuxå†…æ ¸åŠ è½½å®Œæ¯•åï¼Œä¼šé¦–å…ˆå¯åŠ¨Initè¿›ç¨‹ï¼ŒInitè¿›ç¨‹æ˜¯ç³»ç»Ÿçš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ã€‚åœ¨Initè¿›ç¨‹çš„å¯åŠ¨è¿‡ç¨‹ä¸­ï¼Œä¼šè§£æLinuxçš„é…ç½®è„šæœ¬init.rcæ–‡ä»¶ï¼Œæ ¹æ®init.rcæ–‡ä»¶çš„å†…å®¹ï¼ŒInitè¿›ç¨‹ä¼šè£…è½½Androidçš„æ–‡ä»¶ç³»ç»Ÿã€åˆ›å»ºç³»ç»Ÿç›®å½•ã€‚åˆå§‹ åŒ–å±æ€§ç³»ç»Ÿã€å¯åŠ¨Androidç³»ç»Ÿé‡è¦çš„å®ˆæŠ¤è¿›ç¨‹ï¼Œè¿™äº›è¿›ç¨‹åŒ…æ‹¬USBå®ˆæŠ¤è¿›ç¨‹ã€adbå®ˆæŠ¤è¿›ç¨‹ã€voldå®ˆæŠ¤è¿›ç¨‹ã€rildå®ˆæŠ¤è¿›ç¨‹ã€‚ å¯åŠ¨initè¿›ç¨‹(pid=1),æ˜¯Linuxç³»ç»Ÿçš„ç”¨æˆ·è¿›ç¨‹ï¼Œinitè¿›ç¨‹æ˜¯æ‰€æœ‰ç”¨æˆ·è¿›ç¨‹çš„é¼»ç¥–ã€‚ initè¿›ç¨‹å¯åŠ¨Media Server(å¤šåª’ä½“æœåŠ¡)ã€servicemanager(binderæœåŠ¡ç®¡å®¶)ã€bootanim(å¼€æœºåŠ¨ç”»)ç­‰é‡è¦æœåŠ¡ initè¿›ç¨‹è¿˜ä¼šå­µåŒ–å‡ºinstalldã€ueventdã€adbdã€ç­‰ç”¨æˆ·å®ˆæŠ¤è¿›ç¨‹ï¼› initè¿›ç¨‹å­µåŒ–å‡ºZygoteè¿›ç¨‹ï¼ŒZygoteè¿›ç¨‹æ˜¯Androidç³»ç»Ÿçš„é¦–ä¸ªJavaè¿›ç¨‹ï¼ŒZygoteæ˜¯æ‰€æœ‰Javaè¿›ç¨‹çš„çˆ¶è¿›ç¨‹ï¼ŒZygoteè¿›ç¨‹æœ¬èº«æ˜¯ç”±initè¿›ç¨‹å­µåŒ–è€Œæ¥çš„ã€‚ Android 7.0 init.rcçš„ä¸€ç‚¹æ”¹å˜ - å“ˆå“ˆçš„ä¸ªäººä¸“æ  - CSDNåšå®¢ 12345678910111213/system/core/rootdir/init.rc.....service ueventd /sbin/ueventdclass corecriticalseclabel u:r:ueventd:s0service healthd /sbin/healthdclass corecriticalseclabel u:r:healthd:s0group root system wakelock...... 3.4ã€å¯åŠ¨Zygoteè¿›ç¨‹initè¿›ç¨‹åˆå§‹åŒ–ç»“æŸæ—¶ï¼Œä¼šå¯åŠ¨Zygoteè¿›ç¨‹ã€‚Zygoteè¿›ç¨‹è´Ÿè´£forkå‡ºåº”ç”¨è¿›ç¨‹ï¼Œæ˜¯æ‰€æœ‰åº”ç”¨è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ã€‚Zygoteè¿›ç¨‹åˆå§‹åŒ–æ—¶ä¼šåˆ›å»ºDalivikè™šæ‹Ÿæœºã€é¢„è£…ç³»ç»Ÿçš„èµ„æºæ–‡ä»¶å’ŒJavaç±»ã€‚æ‰€æœ‰ä»Zygoteè¿›ç¨‹forkå‡ºçš„ç”¨æˆ·è¿›ç¨‹å°†ç»§æ‰¿å’Œå…±äº«è¿™äº›é¢„åŠ è½½çš„èµ„æºï¼Œä¸ç”¨æµªè´¹æ—¶é—´é‡æ–°åŠ è½½ï¼ŒåŠ å¿«äº†åº”ç”¨ç¨‹åºçš„å¯åŠ¨è¿‡ç¨‹ã€‚å¯åŠ¨ç»“æŸåï¼ŒZygoteè¿›ç¨‹ä¹Ÿå°†å˜æˆå®ˆæŠ¤è¿›ç¨‹ï¼Œè´Ÿè´£å“åº”å’Œå¯åŠ¨APKåº”ç”¨ç¨‹åºçš„è¯·æ±‚ï¼š 1234567891011/system/core/rootdir/init.zygote64.rcservice zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-serverclass mainsocket zygote stream 660 root systemonrestart write /sys/android_power/request_state wakeonrestart write /sys/power/state ononrestart restart audioserveronrestart restart cameraserveronrestart restart mediaonrestart restart netdwritepid /dev/cpuset/foreground/tasks 3.5ã€å¯åŠ¨SystemServerSystemServeræ˜¯Zygoteè¿›ç¨‹forkå‡ºçš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œä¹Ÿæ˜¯æ•´ä¸ªAndroidç³»ç»Ÿçš„æ ¸å¿ƒè¿›ç¨‹ã€‚åœ¨SystemServerä¸­è¿è¡Œç€ç³»ç»Ÿå¤§éƒ¨åˆ†çš„BinderæœåŠ¡ï¼ŒSystemServeré¦–å…ˆå¯åŠ¨æœ¬åœ°æœåŠ¡SensorServiceï¼›æ¥ç€å¯åŠ¨ActivityManagerServiceã€WindowManagerServiceã€PackageManagerServiceåœ¨å†…çš„æ‰€æœ‰JavaæœåŠ¡ã€‚ Zygoteè¿›ç¨‹forkå‡ºSystem Serverè¿›ç¨‹ï¼ŒSystem Serveræ˜¯Zygoteå­µåŒ–çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œåœ°ä½éå¸¸é‡è¦ï¼› System Serverè¿›ç¨‹ï¼šè´Ÿè´£å¯åŠ¨å’Œç®¡ç†æ•´ä¸ªJava frameworkï¼ŒåŒ…å«ActivityManagerï¼ŒPowerManagerç­‰æœåŠ¡ã€‚ Media Serverè¿›ç¨‹ï¼šè´Ÿè´£å¯åŠ¨å’Œç®¡ç†æ•´ä¸ªC++ frameworkï¼ŒåŒ…å«AudioFlingerï¼ŒCamera Serviceç­‰æœåŠ¡ã€‚ 12/frameworks/base/services/java/com/android/server/SystemServer.javaSystemServer().run() 3.6ã€å¯åŠ¨ActivityManagerService3.7ã€å¯åŠ¨Launcher(Activity)SystemServeråŠ è½½å®Œæ‰€æœ‰çš„JavaæœåŠ¡åï¼Œæœ€åä¼šè°ƒç”¨ActivityManagerServiceçš„SystemReady()æ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•çš„æ‰§è¡Œä¸­ï¼Œä¼šå‘å‡ºIntentâ€android.intent.category.HOMEâ€ã€‚å‡¡æ˜¯å“åº”è¿™ä¸ªIntentçš„APKéƒ½ä¼šè¿è¡Œèµ·æ¥ï¼ŒLauncheråº”ç”¨å°±æ˜¯Androidç³»ç»Ÿé»˜è®¤çš„æ¡Œé¢åº”ç”¨ï¼Œä¸€èˆ¬åªæœ‰å®ƒä¼šå“åº”è¿™ä¸ªIntentï¼Œå› æ­¤ï¼Œç³»ç»Ÿå¼€æœºåï¼Œç¬¬ä¸€ä¸ªè¿è¡Œçš„åº”ç”¨å°±æ˜¯Launcherã€‚ Zygoteè¿›ç¨‹å­µåŒ–å‡ºçš„ç¬¬ä¸€ä¸ªAppè¿›ç¨‹æ˜¯Launcherï¼› 12/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.javastartHomeActivityLocked(mCurrentUserId, \"systemReady\"); å››ã€è®¾å¤‡å¯åŠ¨è¿‡ç¨‹è¯¦ç»†åˆ†æï¼ˆ1ï¼‰ã€å¯åŠ¨Initè¿›ç¨‹æ¦‚è¿°ï¼š initæ˜¯Linuxç³»ç»Ÿä¸­ç”¨æˆ·ç©ºé—´çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œè¿›ç¨‹å·ä¸º1ã€‚Kernelå¯åŠ¨åï¼Œåœ¨ç”¨æˆ·ç©ºé—´ï¼Œå¯åŠ¨initè¿›ç¨‹ï¼Œå¹¶è°ƒç”¨initä¸­çš„main()æ–¹æ³•æ‰§è¡Œinitè¿›ç¨‹çš„èŒè´£ã€‚å¯¹äºinitè¿›ç¨‹çš„åŠŸèƒ½åˆ†ä¸º4éƒ¨åˆ†ï¼š åˆ†æå’Œè¿è¡Œæ‰€æœ‰çš„init.rcæ–‡ä»¶; ç”Ÿæˆè®¾å¤‡é©±åŠ¨èŠ‚ç‚¹; ï¼ˆé€šè¿‡rcæ–‡ä»¶åˆ›å»ºï¼‰ å¤„ç†å­è¿›ç¨‹çš„ç»ˆæ­¢(signalæ–¹å¼); æä¾›å±æ€§æœåŠ¡ã€‚ æ¥ä¸‹æ¥ä»main()æ–¹æ³•è¯´èµ·ã€‚ 4.1.1ã€main()[-&gt; init.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168int main(int argc, char** argv) &#123;if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv);&#125;if (!strcmp(basename(argv[0]), \"watchdogd\")) &#123; return watchdogd_main(argc, argv);&#125;// Clear the umask.//è®¾ç½®æ–‡ä»¶å±æ€§0777umask(0);add_environment(\"PATH\", _PATH_DEFPATH);bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.//åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿç›®å½•å¹¶æŒ‚è½½ç›¸å…³çš„æ–‡ä»¶ç³»ç»Ÿif (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); #define MAKE_STR(x) __STRING(x) mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125;// We must have some place other than / to create the device nodes for// kmsg and null, otherwise we won't be able to remount / read-only// later on. Now that tmpfs is mounted on /dev, we can actually talk// to the outside world.//å±è”½æ ‡å‡†çš„è¾“å…¥è¾“å‡ºopen_devnull_stdio(); //åˆå§‹åŒ–kernel logï¼Œä½äºè®¾å¤‡èŠ‚ç‚¹/dev/kmsgklog_init(); //è®¾ç½®è¾“å‡ºçš„logçº§åˆ«klog_set_level(KLOG_NOTICE_LEVEL); // è¾“å‡ºinitå¯åŠ¨é˜¶æ®µçš„logNOTICE(\"init %s started!\\n\", is_first_stage ? \"first stage\" : \"second stage\");if (!is_first_stage) &#123; // Indicate that booting is in progress to background fw loaders, etc. close(open(\"/dev/.booting\", O_WRONLY | O_CREAT | O_CLOEXEC, 0000)); //åˆ›å»ºä¸€å—å…±äº«çš„å†…å­˜ç©ºé—´ï¼Œç”¨äºå±æ€§æœåŠ¡ property_init(); // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. process_kernel_dt(); process_kernel_cmdline(); // Propagate the kernel variables to internal variables // used by init as well as the current required properties. export_kernel_boot_props();&#125;// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123; if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.NOTICE(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon(\"/property_contexts\");restorecon_recursive(\"/sys\");epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125;//åˆå§‹åŒ–å­è¿›ç¨‹é€€å‡ºçš„ä¿¡å·å¤„ç†è¿‡ç¨‹signal_handler_init();property_load_boot_defaults();export_oem_lock_status();start_property_service();const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map);Parser&amp; parser = Parser::GetInstance();parser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;());parser.ParseConfig(\"/init.rc\");ActionManager&amp; am = ActionManager::GetInstance();am.QueueEventTrigger(\"early-init\");// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...am.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");// ... so that we can start queuing up actions that require stuff from /dev.am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");am.QueueBuiltinAction(set_mmap_rnd_bits_action, \"set_mmap_rnd_bits\");am.QueueBuiltinAction(keychord_init_action, \"keychord_init\");am.QueueBuiltinAction(console_init_action, \"console_init\");// Trigger all the boot actions to get us started.am.QueueEventTrigger(\"init\");// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random// wasn't ready immediately after wait_for_coldboot_doneam.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");// Don't mount filesystems or start core system services in charger mode.std::string bootmode = property_get(\"ro.bootmode\");if (bootmode == \"charger\") &#123; am.QueueEventTrigger(\"charger\");&#125; else &#123; am.QueueEventTrigger(\"late-init\");&#125;// Run all property triggers based on current state of the properties.am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\");while (true) &#123; if (!waiting_for_exec) &#123; am.ExecuteOneCommand(); restart_processes(); &#125; int timeout = -1; if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; if (am.HasMoreCommands()) &#123; timeout = 0; &#125; bootchart_sample(&amp;timeout); epoll_event ev; int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; ((void (*)()) ev.data.ptr)(); &#125;&#125;return 0;&#125; 4.1.2ã€åˆ›å»ºæ–‡ä»¶ç³»ç»Ÿç›®å½•å¹¶æŒ‚è½½ç›¸å…³çš„æ–‡ä»¶ç³»ç»Ÿæ­¤æ—¶androidçš„logç³»ç»Ÿè¿˜æ²¡æœ‰å¯åŠ¨ï¼Œé‡‡ç”¨kernelçš„logç³»ç»Ÿï¼Œæ‰“å¼€çš„è®¾å¤‡èŠ‚ç‚¹/dev/kmsgï¼Œ é‚£ä¹ˆå¯é€šè¿‡cat /dev/kmsgæ¥è·å–å†…æ ¸logã€‚ æ¥ä¸‹æ¥ï¼Œè®¾ç½®logçš„è¾“å‡ºçº§åˆ«ä¸ºKLOG_NOTICE_LEVEL(5)ï¼Œå½“logçº§åˆ«å°äº5æ—¶åˆ™ä¼šè¾“å‡ºåˆ°kernel logï¼Œ é»˜è®¤å€¼ä¸º3. 123456789101112131415add_environment(\"PATH\", _PATH_DEFPATH);bool is_first_stage = (argc == 1) || (strcmp(argv[1], \"--second-stage\") != 0);// Get the basic filesystem setup we need put together in the initramdisk// on / and then we'll let the rc file figure out the rest.if (is_first_stage) &#123; mount(\"tmpfs\", \"/dev\", \"tmpfs\", MS_NOSUID, \"mode=0755\"); mkdir(\"/dev/pts\", 0755); mkdir(\"/dev/socket\", 0755); mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, NULL); #define MAKE_STR(x) __STRING(x) mount(\"proc\", \"/proc\", \"proc\", 0, \"hidepid=2,gid=\" MAKE_STR(AID_READPROC)); mount(\"sysfs\", \"/sys\", \"sysfs\", 0, NULL);&#125; è¯¥éƒ¨åˆ†ä¸»è¦ç”¨äºåˆ›å»ºå’ŒæŒ‚è½½å¯åŠ¨æ‰€éœ€çš„æ–‡ä»¶ç›®å½•ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ç¼–è¯‘Androidç³»ç»Ÿæºç æ—¶ï¼Œåœ¨ç”Ÿæˆçš„æ ¹æ–‡ä»¶ç³»ç»Ÿä¸­ï¼Œå¹¶ä¸å­˜åœ¨è¿™äº›ç›®å½•ï¼Œå®ƒä»¬æ˜¯ç³»ç»Ÿè¿è¡Œæ—¶çš„ç›®å½•ï¼Œå³å½“ç³»ç»Ÿç»ˆæ­¢æ—¶ï¼Œå°±ä¼šæ¶ˆå¤±ã€‚ åœ¨initåˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼ŒAndroidåˆ†åˆ«æŒ‚è½½äº†tmpfsï¼Œdevptsï¼Œprocï¼Œsysfsè¿™4ç±»æ–‡ä»¶ç³»ç»Ÿã€‚ tmpfsæ˜¯ä¸€ç§è™šæ‹Ÿå†…å­˜æ–‡ä»¶ç³»ç»Ÿï¼Œå®ƒä¼šå°†æ‰€æœ‰çš„æ–‡ä»¶å­˜å‚¨åœ¨è™šæ‹Ÿå†…å­˜ä¸­ï¼Œå¦‚æœä½ å°†tmpfsæ–‡ä»¶ç³»ç»Ÿå¸è½½åï¼Œé‚£ä¹ˆå…¶ä¸‹çš„æ‰€æœ‰çš„å†…å®¹å°†ä¸å¤å­˜åœ¨ã€‚ tmpfsæ—¢å¯ä»¥ä½¿ç”¨RAMï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨äº¤æ¢åˆ†åŒºï¼Œä¼šæ ¹æ®ä½ çš„å®é™…éœ€è¦è€Œæ”¹å˜å¤§å°ã€‚tmpfsçš„é€Ÿåº¦éå¸¸æƒŠäººï¼Œæ¯•ç«Ÿå®ƒæ˜¯é©»ç•™åœ¨RAMä¸­çš„ï¼Œå³ä½¿ç”¨äº†äº¤æ¢åˆ†åŒºï¼Œæ€§èƒ½ä»ç„¶éå¸¸å“è¶Šã€‚ ç”±äºtmpfsæ˜¯é©»ç•™åœ¨RAMçš„ï¼Œå› æ­¤å®ƒçš„å†…å®¹æ˜¯ä¸æŒä¹…çš„ã€‚æ–­ç”µåï¼Œtmpfsçš„å†…å®¹å°±æ¶ˆå¤±äº†ï¼Œè¿™ä¹Ÿæ˜¯è¢«ç§°ä½œtmpfsçš„æ ¹æœ¬åŸå› ã€‚ devptsæ–‡ä»¶ç³»ç»Ÿä¸ºä¼ªç»ˆç«¯æä¾›äº†ä¸€ä¸ªæ ‡å‡†æ¥å£ï¼Œå®ƒçš„æ ‡å‡†æŒ‚æ¥ç‚¹æ˜¯/dev/ ptsã€‚åªè¦ptyçš„ä¸»å¤åˆè®¾å¤‡/dev/ptmxè¢«æ‰“å¼€ï¼Œå°±ä¼šåœ¨/dev/ptsä¸‹åŠ¨æ€çš„åˆ›å»ºä¸€ä¸ªæ–°çš„ptyè®¾å¤‡æ–‡ä»¶ã€‚ procæ–‡ä»¶ç³»ç»Ÿæ˜¯ä¸€ä¸ªéå¸¸é‡è¦çš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿï¼Œå®ƒå¯ä»¥çœ‹ä½œæ˜¯å†…æ ¸å†…éƒ¨æ•°æ®ç»“æ„çš„æ¥å£ï¼Œé€šè¿‡å®ƒæˆ‘ä»¬å¯ä»¥è·å¾—ç³»ç»Ÿçš„ä¿¡æ¯ï¼ŒåŒæ—¶ä¹Ÿèƒ½å¤Ÿåœ¨è¿è¡Œæ—¶ä¿®æ”¹ç‰¹å®šçš„å†…æ ¸å‚æ•°ã€‚ ä¸procæ–‡ä»¶ç³»ç»Ÿç±»ä¼¼ï¼Œsysfsæ–‡ä»¶ç³»ç»Ÿä¹Ÿæ˜¯ä¸€ä¸ªä¸å æœ‰ä»»ä½•ç£ç›˜ç©ºé—´çš„è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿã€‚å®ƒé€šå¸¸è¢«æŒ‚æ¥åœ¨/sysç›®å½•ä¸‹ã€‚sysfsæ–‡ä»¶ç³»ç»Ÿæ˜¯Linux2.6å†…æ ¸å¼•å…¥çš„ï¼Œå®ƒæŠŠè¿æ¥åœ¨ç³»ç»Ÿä¸Šçš„è®¾å¤‡å’Œæ€»çº¿ç»„ç»‡æˆä¸ºä¸€ä¸ªåˆ†çº§çš„æ–‡ä»¶ï¼Œä½¿å¾—å®ƒä»¬å¯ä»¥åœ¨ç”¨æˆ·ç©ºé—´å­˜å–ã€‚ 4.1.4ã€å±è”½æ ‡å‡†çš„è¾“å…¥è¾“å‡º[-&gt; init.cpp] 12345678910111213141516171819202122232425void open_devnull_stdio(void)&#123;// Try to avoid the mknod() call if we can. Since SELinux makes// a /dev/null replacement available for free, let's use it.int fd = open(\"/sys/fs/selinux/null\", O_RDWR);if (fd == -1) &#123; // OOPS, /sys/fs/selinux/null isn't available, likely because // /sys/fs/selinux isn't mounted. Fall back to mknod. static const char *name = \"/dev/__null__\"; if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 3) == 0) &#123; fd = open(name, O_RDWR); unlink(name); &#125; if (fd == -1) &#123; exit(1); &#125;&#125;dup2(fd, 0);dup2(fd, 1);dup2(fd, 2);if (fd &gt; 2) &#123; close(fd);&#125;&#125; å‰æ–‡ç”Ÿæˆ/devç›®å½•åï¼Œinitè¿›ç¨‹å°†è°ƒç”¨open_devnull_stdioå‡½æ•°ï¼Œå±è”½æ ‡å‡†çš„è¾“å…¥è¾“å‡ºã€‚ open_devnull_stdioå‡½æ•°ä¼šåœ¨/devç›®å½•ä¸‹ç”Ÿæˆnullè®¾å¤‡èŠ‚ç‚¹æ–‡ä»¶ï¼Œå¹¶å°†æ ‡å‡†è¾“å…¥ã€æ ‡å‡†è¾“å‡ºã€æ ‡å‡†é”™è¯¯è¾“å‡ºå…¨éƒ¨é‡å®šå‘åˆ°nullè®¾å¤‡ä¸­ã€‚ open_devnull_stdioå‡½æ•°å®šä¹‰äºsystem/core/init/util.cppä¸­ã€‚ è¿™é‡Œéœ€è¦è¯´æ˜çš„æ˜¯ï¼Œdup2å‡½æ•°çš„ä½œç”¨æ˜¯ç”¨æ¥å¤åˆ¶ä¸€ä¸ªæ–‡ä»¶çš„æè¿°ç¬¦ï¼Œé€šå¸¸ç”¨æ¥é‡å®šå‘è¿›ç¨‹çš„stdinã€stdoutå’Œstderrã€‚å®ƒçš„å‡½æ•°åŸå½¢æ˜¯ï¼š int dup2(int oldfd, int targetfd) è¯¥å‡½æ•°æ‰§è¡Œåï¼Œtargetfdå°†å˜æˆoldfdçš„å¤åˆ¶å“ã€‚ å› æ­¤ä¸Šè¿°è¿‡ç¨‹å…¶å®å°±æ˜¯ï¼šåˆ›å»ºå‡ºnullè®¾å¤‡åï¼Œå°†0ã€1ã€2ç»‘å®šåˆ°nullè®¾å¤‡ä¸Šã€‚å› æ­¤initè¿›ç¨‹è°ƒç”¨open_devnull_stdioå‡½æ•°åï¼Œé€šè¿‡æ ‡å‡†çš„è¾“å…¥è¾“å‡ºæ— æ³•è¾“å‡ºä¿¡æ¯ã€‚ 4.1.5ã€åˆå§‹åŒ–å†…æ ¸logç³»ç»Ÿæˆ‘ä»¬ç»§ç»­å›åˆ°initè¿›ç¨‹çš„mainå‡½æ•°ï¼Œinitè¿›ç¨‹é€šè¿‡klog_initå‡½æ•°ï¼Œæä¾›è¾“å‡ºlogä¿¡æ¯çš„è®¾å¤‡ã€‚ [-&gt; init.cpp] 1234567891011121314151617klog_init();klog_set_level(KLOG_NOTICE_LEVEL);void klog_init(void) &#123;if (klog_fd &gt;= 0) return; /* Already initialized */klog_fd = open(\"/dev/kmsg\", O_WRONLY | O_CLOEXEC);if (klog_fd &gt;= 0) &#123; return;&#125;static const char* name = \"/dev/__kmsg__\";if (mknod(name, S_IFCHR | 0600, (1 &lt;&lt; 8) | 11) == 0) &#123; klog_fd = open(name, O_WRONLY | O_CLOEXEC); unlink(name);&#125;&#125; klog_initå‡½æ•°å®šä¹‰äºsystem/core/libcutils/klog.cä¸­ã€‚é€šè¿‡klog_initå‡½æ•°ï¼Œinitè¿›ç¨‹ç”Ÿæˆkmsgè®¾å¤‡èŠ‚ç‚¹æ–‡ä»¶ã€‚è¯¥è®¾å¤‡å¯ä»¥è°ƒç”¨å†…æ ¸ä¿¡æ¯è¾“å‡ºå‡½æ•°printkï¼Œä»¥è¾“å‡ºlogä¿¡æ¯ã€‚ 4.1.6ã€åˆå§‹åŒ–å±æ€§åŸŸ12345if (!is_first_stage) &#123;.......property_init();.......&#125; è°ƒç”¨property_initåˆå§‹åŒ–å±æ€§åŸŸã€‚åœ¨Androidå¹³å°ä¸­ï¼Œä¸ºäº†è®©è¿è¡Œä¸­çš„æ‰€æœ‰è¿›ç¨‹å…±äº«ç³»ç»Ÿè¿è¡Œæ—¶æ‰€éœ€è¦çš„å„ç§è®¾ç½®å€¼ï¼Œç³»ç»Ÿå¼€è¾Ÿäº†å±æ€§å­˜å‚¨åŒºåŸŸï¼Œå¹¶æä¾›äº†è®¿é—®è¯¥åŒºåŸŸçš„APIã€‚ è¿™é‡Œå­˜åœ¨ä¸€ä¸ªé—®é¢˜æ˜¯ï¼Œåœ¨initè¿›ç¨‹ä¸­æœ‰éƒ¨åˆ†ä»£ç å—ä»¥is_first_stageæ ‡å¿—è¿›è¡ŒåŒºåˆ†ï¼Œå†³å®šæ˜¯å¦éœ€è¦è¿›è¡Œåˆå§‹åŒ–ã€‚ is_first_stageçš„å€¼ï¼Œç”±initè¿›ç¨‹mainå‡½æ•°çš„å…¥å£å‚æ•°å†³å®šï¼Œä¹‹å‰ä¸å¤ªæ˜ç™½å…·ä½“çš„å«ä¹‰ã€‚ åæ¥å†™åšå®¢åï¼Œæœ‰æœ‹å‹ç•™è¨€ï¼Œåœ¨å¼•å…¥selinuxæœºåˆ¶åï¼Œæœ‰äº›æ“ä½œå¿…é¡»è¦åœ¨å†…æ ¸æ€æ‰èƒ½å®Œæˆï¼› ä½†initè¿›ç¨‹ä½œä¸ºandroidçš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œåˆæ˜¯è¿è¡Œåœ¨ç”¨æˆ·æ€çš„ã€‚ äºæ˜¯ï¼Œæœ€ç»ˆè®¾è®¡ä¸ºç”¨is_first_stageè¿›è¡ŒåŒºåˆ†initè¿›ç¨‹çš„è¿è¡ŒçŠ¶æ€ã€‚initè¿›ç¨‹åœ¨è¿è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œä¼šå®Œæˆä»å†…æ ¸æ€åˆ°ç”¨æˆ·æ€çš„åˆ‡æ¢ã€‚ 123456void property_init() &#123;if (__system_property_area_init()) &#123; ERROR(\"Failed to initialize property area\\n\"); exit(1);&#125;&#125; property_initå‡½æ•°å®šä¹‰äºsystem/core/init/property_service.cppä¸­ï¼Œå¦‚ä¸Šé¢ä»£ç æ‰€ç¤ºï¼Œæœ€ç»ˆè°ƒç”¨_system_property_area_initå‡½æ•°åˆå§‹åŒ–å±æ€§åŸŸã€‚ 4.1.7ã€å®ŒæˆSELinuxç›¸å…³å·¥ä½œ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// Set up SELinux, including loading the SELinux policy if we're in the kernel domain.selinux_initialize(is_first_stage);static void selinux_initialize(bool in_kernel_domain) &#123;Timer t;selinux_callback cb;//ç”¨äºæ‰“å°logçš„å›è°ƒå‡½æ•°cb.func_log = selinux_klog_callback;selinux_set_callback(SELINUX_CB_LOG, cb);//ç”¨äºæ£€æŸ¥æƒé™çš„å›è°ƒå‡½æ•°cb.func_audit = audit_callback;selinux_set_callback(SELINUX_CB_AUDIT, cb);if (in_kernel_domain) &#123; //å†…æ ¸æ€å¤„ç†æµç¨‹ INFO(\"Loading SELinux policy...\\n\"); //ç”¨äºåŠ è½½sepolicyæ–‡ä»¶ã€‚è¯¥å‡½æ•°æœ€ç»ˆå°†sepolicyæ–‡ä»¶ä¼ é€’ç»™kernelï¼Œè¿™æ ·kernelå°±æœ‰äº†å®‰å…¨ç­–ç•¥é…ç½®æ–‡ä»¶ï¼Œåç»­çš„MACæ‰èƒ½å¼€å±•èµ·æ¥ã€‚ if (selinux_android_load_policy() &lt; 0) &#123; ERROR(\"failed to load policy: %s\\n\", strerror(errno)); security_failure(); &#125; //å†…æ ¸ä¸­è¯»å–çš„ä¿¡æ¯ bool kernel_enforcing = (security_getenforce() == 1); //å‘½ä»¤è¡Œä¸­å¾—åˆ°çš„æ•°æ® bool is_enforcing = selinux_is_enforcing(); if (kernel_enforcing != is_enforcing) &#123; //ç”¨äºè®¾ç½®selinuxçš„å·¥ä½œæ¨¡å¼ã€‚selinuxæœ‰ä¸¤ç§å·¥ä½œæ¨¡å¼ï¼š //1ã€â€permissiveâ€ï¼Œæ‰€æœ‰çš„æ“ä½œéƒ½è¢«å…è®¸ï¼ˆå³æ²¡æœ‰MACï¼‰ï¼Œä½†æ˜¯å¦‚æœè¿åæƒé™çš„è¯ï¼Œä¼šè®°å½•æ—¥å¿— //2ã€â€enforcingâ€ï¼Œæ‰€æœ‰æ“ä½œéƒ½ä¼šè¿›è¡Œæƒé™æ£€æŸ¥ã€‚åœ¨ä¸€èˆ¬çš„ç»ˆç«¯ä¸­ï¼Œåº”è¯¥å·¥ä½œäºenforingæ¨¡å¼ if (security_setenforce(is_enforcing)) &#123; ERROR(\"security_setenforce(%s) failed: %s\\n\", is_enforcing ? \"true\" : \"false\", strerror(errno)); //å°†é‡å¯è¿›å…¥recovery mode security_failure(); &#125; &#125; if (write_file(\"/sys/fs/selinux/checkreqprot\", \"0\") == -1) &#123; security_failure(); &#125; NOTICE(\"(Initializing SELinux %s took %.2fs.)\\n\", is_enforcing ? \"enforcing\" : \"non-enforcing\", t.duration());&#125; else &#123; selinux_init_all_handles();&#125;&#125; initè¿›ç¨‹è¿›ç¨‹è°ƒç”¨selinux_initializeå¯åŠ¨SELinuxã€‚ä»æ³¨é‡Šæ¥çœ‹ï¼Œinitè¿›ç¨‹çš„è¿è¡Œç¡®å®æ˜¯åŒºåˆ†ç”¨æˆ·æ€å’Œå†…æ ¸æ€çš„ã€‚ 4.1.8ã€é‡æ–°è®¾ç½®å±æ€§1234567891011121314151617181920212223242526// If we're in the kernel domain, re-exec init to transition to the init domain now// that the SELinux policy has been loaded.if (is_first_stage) &#123;//æŒ‰selinux policyè¦æ±‚ï¼Œé‡æ–°è®¾ç½®initæ–‡ä»¶å±æ€§ if (restorecon(\"/init\") == -1) &#123; ERROR(\"restorecon failed: %s\\n\", strerror(errno)); security_failure(); &#125; char* path = argv[0]; char* args[] = &#123; path, const_cast&lt;char*&gt;(\"--second-stage\"), nullptr &#125;; //è¿™é‡Œå°±æ˜¯å‰é¢æ‰€è¯´çš„ï¼Œå¯åŠ¨ç”¨æˆ·æ€çš„initè¿›ç¨‹ï¼Œå³second-stage if (execv(path, args) == -1) &#123; ERROR(\"execv(\\\"%s\\\") failed: %s\\n\", path, strerror(errno)); security_failure(); &#125;&#125;// These directories were necessarily created before initial policy load// and therefore need their security context restored to the proper value.// This must happen before /dev is populated by ueventd.NOTICE(\"Running restorecon...\\n\");restorecon(\"/dev\");restorecon(\"/dev/socket\");restorecon(\"/dev/__properties__\");restorecon(\"/property_contexts\");restorecon_recursive(\"/sys\"); ä¸Šè¿°æ–‡ä»¶èŠ‚ç‚¹åœ¨åŠ è½½Sepolicyä¹‹å‰å·²ç»è¢«åˆ›å»ºäº†ï¼Œå› æ­¤åœ¨åŠ è½½å®ŒSepolicyåï¼Œéœ€è¦é‡æ–°è®¾ç½®ç›¸å…³çš„å±æ€§ã€‚ 4.1.9ã€åˆ›å»ºepollå¥æŸ„å¦‚ä¸‹é¢ä»£ç æ‰€ç¤ºï¼Œinitè¿›ç¨‹è°ƒç”¨epoll_create1åˆ›å»ºepollå¥æŸ„ã€‚ 12345epoll_fd = epoll_create1(EPOLL_CLOEXEC);if (epoll_fd == -1) &#123; ERROR(\"epoll_create1 failed: %s\\n\", strerror(errno)); exit(1);&#125; åœ¨linuxçš„ç½‘ç»œç¼–ç¨‹ä¸­ï¼Œå¾ˆé•¿çš„æ—¶é—´éƒ½åœ¨ä½¿ç”¨selectæ¥åšäº‹ä»¶è§¦å‘ã€‚åœ¨linuxæ–°çš„å†…æ ¸ä¸­ï¼Œæœ‰äº†ä¸€ç§æ›¿æ¢å®ƒçš„æœºåˆ¶ï¼Œå°±æ˜¯epollã€‚ç›¸æ¯”äºselectï¼Œepollæœ€å¤§çš„å¥½å¤„åœ¨äºå®ƒä¸ä¼šéšç€ç›‘å¬fdæ•°ç›®çš„å¢é•¿è€Œé™ä½æ•ˆç‡ã€‚å› ä¸ºåœ¨å†…æ ¸ä¸­çš„selectå®ç°ä¸­ï¼Œå®ƒæ˜¯é‡‡ç”¨è½®è¯¢æ¥å¤„ç†çš„ï¼Œè½®è¯¢çš„fdæ•°ç›®è¶Šå¤šï¼Œè‡ªç„¶è€—æ—¶è¶Šå¤šã€‚ epollæœºåˆ¶ä¸€èˆ¬ä½¿ç”¨epoll_create(int size)å‡½æ•°åˆ›å»ºepollå¥æŸ„ï¼Œsizeç”¨æ¥å‘Šè¯‰å†…æ ¸è¿™ä¸ªå¥æŸ„å¯ç›‘å¬çš„fdçš„æ•°ç›®ã€‚æ³¨æ„è¿™ä¸ªå‚æ•°ä¸åŒäºselect()ä¸­çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œåœ¨selectä¸­éœ€ç»™å‡ºæœ€å¤§ç›‘å¬æ•°åŠ 1çš„å€¼ã€‚ æ­¤å¤–ï¼Œå½“åˆ›å»ºå¥½epollå¥æŸ„åï¼Œå®ƒå°±ä¼šå ç”¨ä¸€ä¸ªfdå€¼ï¼Œåœ¨linuxä¸‹å¦‚æœæŸ¥çœ‹/proc/è¿›ç¨‹id/fd/ï¼Œèƒ½å¤Ÿçœ‹åˆ°åˆ›å»ºå‡ºçš„fdï¼Œå› æ­¤åœ¨ä½¿ç”¨å®Œepollåï¼Œå¿…é¡»è°ƒç”¨close()å…³é—­ï¼Œå¦åˆ™å¯èƒ½å¯¼è‡´fdè¢«è€—å°½ã€‚ ä¸Šè¿°ä»£ç ä½¿ç”¨çš„epoll_create1(EPOLLCLOEXEC)æ¥åˆ›å»ºepollå¥æŸ„ï¼Œè¯¥æ ‡å¿—ä½è¡¨ç¤ºç”Ÿæˆçš„epoll fdå…·æœ‰â€æ‰§è¡Œåå…³é—­â€ç‰¹æ€§ã€‚ 4.1.10ã€è£…è½½å­è¿›ç¨‹ä¿¡å·å¤„ç†å™¨12345678910111213141516171819202122232425void signal_handler_init() &#123;// Create a signalling mechanism for SIGCHLD.int s[2];//åˆ©ç”¨socketpairåˆ›å»ºå‡ºå·²ç»è¿æ¥çš„ä¸¤ä¸ªsocketï¼Œåˆ†åˆ«ä½œä¸ºä¿¡å·çš„è¯»ã€å†™ç«¯if (socketpair(AF_UNIX, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, 0, s) == -1) &#123; ERROR(\"socketpair failed: %s\\n\", strerror(errno)); exit(1);&#125;signal_write_fd = s[0];signal_read_fd = s[1];// Write to signal_write_fd if we catch SIGCHLD.struct sigaction act;memset(&amp;act, 0, sizeof(act));//ä¿¡å·å¤„ç†å™¨ä¸ºSIGCHLD_handlerï¼Œå…¶è¢«å­˜åœ¨sigactionç»“æ„ä½“ä¸­ï¼Œè´Ÿè´£å¤„ç†SIGCHLDæ¶ˆæ¯act.sa_handler = SIGCHLD_handler;act.sa_flags = SA_NOCLDSTOP;//è°ƒç”¨ä¿¡å·å®‰è£…å‡½æ•°sigactionï¼Œå°†ç›‘å¬çš„ä¿¡å·åŠå¯¹åº”çš„ä¿¡å·å¤„ç†å™¨æ³¨å†Œåˆ°å†…æ ¸ä¸­sigaction(SIGCHLD, &amp;act, 0);//ç›¸å¯¹äº6.0çš„ä»£ç ï¼Œè¿›ä¸€æ­¥ä½œäº†å°è£…ï¼Œç”¨äºç»ˆæ­¢å‡ºç°é—®é¢˜çš„å­è¿›ç¨‹ï¼Œè¯¦ç»†ä»£ç äºåæ–‡åˆ†æã€‚ServiceManager::GetInstance().ReapAnyOutstandingChildren();register_epoll_handler(signal_read_fd, handle_signal);&#125; Linuxè¿›ç¨‹é€šè¿‡äº’ç›¸å‘é€æ¥æ”¶æ¶ˆæ¯æ¥å®ç°è¿›ç¨‹é—´çš„é€šä¿¡ï¼Œè¿™äº›æ¶ˆæ¯è¢«ç§°ä¸ºâ€ä¿¡å·â€ã€‚æ¯ä¸ªè¿›ç¨‹åœ¨å¤„ç†å…¶å®ƒè¿›ç¨‹å‘é€çš„ä¿¡å·æ—¶éƒ½è¦æ³¨å†Œå¤„ç†è€…ï¼Œå¤„ç†è€…è¢«ç§°ä¸ºä¿¡å·å¤„ç†å™¨ã€‚ æ³¨æ„åˆ°sigactionç»“æ„ä½“çš„sa_flagsä¸ºSA_NOCLDSTOPã€‚ç”±äºç³»ç»Ÿé»˜è®¤åœ¨å­è¿›ç¨‹æš‚åœæ—¶ä¹Ÿä¼šå‘é€ä¿¡å·SIGCHLDï¼Œinitéœ€è¦å¿½ç•¥å­è¿›ç¨‹åœ¨æš‚åœæ—¶å‘å‡ºçš„SIGCHLDä¿¡å·ï¼Œå› æ­¤å°†act.sa_flags ç½®ä¸ºSA_NOCLDSTOPï¼Œè¯¥æ ‡å¿—ä½è¡¨ç¤ºä»…å½“è¿›ç¨‹ç»ˆæ­¢æ—¶æ‰æ¥å—SIGCHLDä¿¡å·ã€‚ æˆ‘ä»¬æ¥çœ‹çœ‹SIGCHLD_handlerçš„å…·ä½“å·¥ä½œã€‚ 12345static void SIGCHLD_handler(int) &#123;if (TEMP_FAILURE_RETRY(write(signal_write_fd, \"1\", 1)) == -1) &#123; ERROR(\"write(signal_write_fd) failed: %s\\n\", strerror(errno));&#125;&#125; ä»ä¸Šé¢ä»£ç æˆ‘ä»¬çŸ¥é“ï¼Œinitè¿›ç¨‹æ˜¯æ‰€æœ‰è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ï¼Œå½“å…¶å­è¿›ç¨‹ç»ˆæ­¢äº§ç”ŸSIGCHLDä¿¡å·æ—¶ï¼ŒSIGCHLD_handlerå¯¹signal_write_fdæ‰§è¡Œå†™æ“ä½œã€‚ç”±äºsocketpairçš„ç»‘å®šå…³ç³»ï¼Œè¿™å°†è§¦å‘ä¿¡å·å¯¹åº”çš„signal_read_fdæ”¶åˆ°æ•°æ®ã€‚ åœ¨è£…è½½ä¿¡å·ç›‘å¬å™¨çš„æœ€åï¼Œsignal_handler_initè°ƒç”¨register_epoll_handlerï¼Œå…¶ä»£ç å¦‚ä¸‹æ‰€ç¤ºï¼Œä¼ å…¥å‚æ•°åˆ†åˆ«ä¸ºsignal_read_fdå’Œhandle_signalã€‚ 123456789void register_epoll_handler(int fd, void (*fn)()) &#123;epoll_event ev;ev.events = EPOLLIN;ev.data.ptr = reinterpret_cast&lt;void*&gt;(fn);//epoll_fdå¢åŠ ä¸€ä¸ªç›‘å¬å¯¹è±¡fd,fdä¸Šæœ‰æ•°æ®åˆ°æ¥æ—¶ï¼Œè°ƒç”¨fnå¤„ç†if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;ev) == -1) &#123; ERROR(\"epoll_ctl failed: %s\\n\", strerror(errno));&#125;&#125; æ ¹æ®ä»£ç ï¼Œæˆ‘ä»¬çŸ¥é“ï¼šå½“epollå¥æŸ„ç›‘å¬åˆ°signal_read_fdä¸­æœ‰æ•°æ®å¯è¯»æ—¶ï¼Œå°†è°ƒç”¨handle_signalè¿›è¡Œå¤„ç†ã€‚ è‡³æ­¤ï¼Œç»“åˆä¸Šæ–‡æˆ‘ä»¬çŸ¥é“ï¼šå½“initè¿›ç¨‹è°ƒç”¨signal_handler_initåï¼Œä¸€æ—¦æ”¶åˆ°å­è¿›ç¨‹ç»ˆæ­¢å¸¦æ¥çš„SIGCHLDæ¶ˆæ¯åï¼Œå°†åˆ©ç”¨ä¿¡å·å¤„ç†è€…SIGCHLD_handlerå‘signal_write_fdå†™å…¥ä¿¡æ¯ï¼› epollå¥æŸ„ç›‘å¬åˆ°signal_read_fdæ”¶æ¶ˆæ¯åï¼Œå°†è°ƒç”¨handle_signalè¿›è¡Œå¤„ç†ã€‚æ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 1234567static void handle_signal() &#123;// Clear outstanding requests.char buf[32];read(signal_read_fd, buf, sizeof(buf));ServiceManager::GetInstance().ReapAnyOutstandingChildren();&#125; ä»ä»£ç ä¸­å¯ä»¥çœ‹å‡ºï¼Œhandle_signalåªæ˜¯æ¸…ç©ºsignal_read_fdä¸­çš„æ•°æ®ï¼Œç„¶åè°ƒç”¨ServiceManager::GetInstance().ReapAnyOutstandingChildren()ã€‚ ServiceManagerå®šä¹‰äºsystem/core/init/service.cppä¸­ï¼Œæ˜¯ä¸€ä¸ªå•ä¾‹å¯¹è±¡ï¼š 1234567891011121314............//C++ä¸­é»˜è®¤æ˜¯privateå±æ€§ServiceManager::ServiceManager() &#123;&#125;ServiceManager&amp; ServiceManager::GetInstance() &#123;static ServiceManager instance;return instance;&#125;void ServiceManager::ReapAnyOutstandingChildren() &#123;while (ReapOneProcess()) &#123;&#125;&#125;............ ReapAnyOutstandingChildrenå‡½æ•°å®é™…ä¸Šè°ƒç”¨äº†ReapOneProcessã€‚ æˆ‘ä»¬ç»“åˆä»£ç ï¼Œçœ‹çœ‹ReapOneProcessçš„å…·ä½“å·¥ä½œã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798bool ServiceManager::ReapOneProcess() &#123;int status;//ç”¨waitpidå‡½æ•°è·å–çŠ¶æ€å‘ç”Ÿå˜åŒ–çš„å­è¿›ç¨‹pid//waitpidçš„æ ‡è®°ä¸ºWNOHANGï¼Œå³éé˜»å¡ï¼Œè¿”å›ä¸ºæ­£å€¼å°±è¯´æ˜æœ‰è¿›ç¨‹æŒ‚æ‰äº†pid_t pid = TEMP_FAILURE_RETRY(waitpid(-1, &amp;status, WNOHANG));if (pid == 0) &#123; return false;&#125; else if (pid == -1) &#123; ERROR(\"waitpid failed: %s\\n\", strerror(errno)); return false;&#125;//åˆ©ç”¨FindServiceByPidå‡½æ•°ï¼Œæ‰¾åˆ°pidå¯¹åº”çš„æœåŠ¡ã€‚//FindServiceByPidä¸»è¦é€šè¿‡è½®è¯¢è§£æinit.rcç”Ÿæˆçš„service_listï¼Œæ‰¾åˆ°pidä¸å‚æ•°ä¸€è‡´çš„srvcã€‚Service* svc = FindServiceByPid(pid);//è¾“å‡ºæœåŠ¡ç»“æŸçš„åŸå› .........if (!svc) &#123; return true;&#125;//ç»“æŸæœåŠ¡ï¼Œç›¸å¯¹äº6.0ä½œäº†è¿›ä¸€æ­¥çš„å°è£…if (svc-&gt;Reap()) &#123; waiting_for_exec = false; //ç§»é™¤æœåŠ¡å¯¹åº”çš„ä¿¡æ¯ RemoveService(*svc);&#125;return true;&#125;bool Service::Reap() &#123;//æ¸…ç†æœªæºå¸¦SVC_ONESHOT æˆ– æºå¸¦äº†SVC_RESTARTæ ‡å¿—çš„srvcçš„å­è¿›ç¨‹if (!(flags_ &amp; SVC_ONESHOT) || (flags_ &amp; SVC_RESTART)) &#123; NOTICE(\"Service '%s' (pid %d) killing any children in process group\\n\", name_.c_str(), pid_); kill(-pid_, SIGKILL);&#125;//æ¸…é™¤srvcä¸­åˆ›å»ºå‡ºçš„socketfor (const auto&amp; si : sockets_) &#123; std::string tmp = StringPrintf(ANDROID_SOCKET_DIR \"/%s\", si.name.c_str()); unlink(tmp.c_str());&#125;if (flags_ &amp; SVC_EXEC) &#123; INFO(\"SVC_EXEC pid %d finished...\\n\", pid_); return true;&#125;pid_ = 0;flags_ &amp;= (~SVC_RUNNING);//å¯¹äºæºå¸¦äº†SVC_ONESHOTå¹¶ä¸”æœªæºå¸¦SVC_RESTARTçš„srvcï¼Œå°†è¿™ç±»æœåŠ¡çš„æ ‡å¿—ç½®ä¸ºSVC_DISABLEDï¼Œä¸å†å¯åŠ¨if ((flags_ &amp; SVC_ONESHOT) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123; flags_ |= SVC_DISABLED;&#125;// Disabled and reset processes do not get restarted automatically.if (flags_ &amp; (SVC_DISABLED | SVC_RESET)) &#123; svc-&gt;NotifyStateChange(\"stopped\"); return true;&#125;time_t now = gettime();//æœªæºå¸¦SVC_RESTARTçš„å…³é”®æœåŠ¡ï¼Œåœ¨è§„å®šçš„é—´éš”å†…ï¼Œcrashå­—æ•°è¿‡å¤šæ—¶ï¼Œä¼šå¯¼è‡´æ•´æœºé‡å¯ï¼›if ((flags_ &amp; SVC_CRITICAL) &amp;&amp; !(flags_ &amp; SVC_RESTART)) &#123; if (time_crashed_ + CRITICAL_CRASH_WINDOW &gt;= now) &#123; if (++nr_crashed_ &gt; CRITICAL_CRASH_THRESHOLD) &#123; .......... android_reboot(ANDROID_RB_RESTART2, 0, \"recovery\"); return true; &#125; &#125; else &#123; time_crashed_ = now; nr_crashed_ = 1; &#125;&#125;//å°†å¾…é‡å¯srvcçš„æ ‡å¿—ä½ç½®ä¸ºSVC_RESTARTINGï¼ˆinitè¿›ç¨‹å°†æ ¹æ®è¯¥æ ‡å¿—ä½ï¼Œé‡å¯æœåŠ¡ï¼‰flags_ &amp;= (~SVC_RESTART);flags_ |= SVC_RESTARTING;// Execute all onrestart commands for this service.//é‡å¯åœ¨init.rcæ–‡ä»¶ä¸­å¸¦æœ‰onrestarté€‰é¡¹çš„æœåŠ¡ï¼Œç›¸å¯¹äº6.0ï¼Œæ­¤å¤„ä¹Ÿå¢åŠ äº†å°è£…æ€§onrestart_.ExecuteAllCommands();svc-&gt;NotifyStateChange(\"restarting\");return true;&#125;void Action::ExecuteAllCommands() const &#123;for (const auto&amp; c : commands_) &#123; ExecuteCommand(c);&#125;&#125;void Action::ExecuteCommand(const Command&amp; command) const &#123;Timer t;//æœåŠ¡é‡å¯æ—¶ï¼Œå°†æ‰§è¡Œå¯¹åº”çš„é€‰é¡¹int result = command.InvokeFunc();//æ‰“å°log........&#125; waitpidçš„å‡½æ•°åŸå‹ä¸º: 1pid_t waitpid(pid_t pid, int *status, int options) å…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°pidä¸ºé¢„ç­‰å¾…çš„å­è¿›ç¨‹çš„è¯†åˆ«ç ï¼Œpid=-1è¡¨ç¤ºç­‰å¾…ä»»ä½•å­è¿›ç¨‹æ˜¯å¦å‘å‡ºSIGCHLDã€‚ç¬¬äºŒä¸ªå‚æ•°statusï¼Œç”¨äºè¿”å›å­è¿›ç¨‹çš„ç»“æŸçŠ¶æ€ã€‚ç¬¬ä¸‰ä¸ªå‚æ•°å†³å®šwaitpidå‡½æ•°æ˜¯å¦å¤„äºé˜»å¡å¤„ç†æ–¹å¼ï¼ŒWNOHANGè¡¨ç¤ºè‹¥pidæŒ‡å®šçš„å­è¿›ç¨‹æ²¡æœ‰ç»“æŸï¼Œåˆ™waitpid()å‡½æ•°è¿”å›0ï¼Œä¸äºˆç­‰å¾…ï¼›è‹¥å­è¿›ç¨‹ç»“æŸï¼Œåˆ™è¿”å›å­è¿›ç¨‹çš„pidã€‚waitpidå¦‚æœå‡ºé”™ï¼Œåˆ™è¿”å›-1ã€‚ æ€»ç»“ä¸€ä¸‹ï¼šæ•´ä¸ªsignal_handler_initå…¶å®å°±æ˜¯ä¸ºäº†é‡å¯å­è¿›ç¨‹ç”¨çš„ï¼Œä¸Šè¿°è¿‡ç¨‹å…¶å®æœ€ç»ˆå¯ä»¥ç®€åŒ–ä¸ºä¸‹å›¾ï¼š 4.1.11ã€è®¾ç½®é»˜è®¤ç³»ç»Ÿå±æ€§1property_load_boot_defaults(); æ¥ä¸‹æ¥ï¼Œè¿›ç¨‹è°ƒç”¨property_load_boot_defaultsè¿›è¡Œé»˜è®¤å±æ€§é…ç½®ç›¸å…³çš„å·¥ä½œã€‚ 12void property_load_boot_defaults() &#123;load_properties_from_file(PROP_PATH_RAMDISK_DEFAULT, NULL); å¦‚ä»£ç æ‰€ç¤ºï¼Œproperty_load_boot_defaultså®é™…ä¸Šå°±æ˜¯è°ƒç”¨load_properties_from_fileè§£æé…ç½®æ–‡ä»¶ï¼›ç„¶åæ ¹æ®è§£æçš„ç»“æœï¼Œè®¾ç½®ç³»ç»Ÿå±æ€§ã€‚è¯¥éƒ¨åˆ†åŠŸèƒ½è¾ƒä¸ºå•ä¸€ï¼Œä¸å†æ·±å…¥åˆ†æã€‚ 4.1.12ã€é…ç½®å±æ€§çš„æœåŠ¡ç«¯12345678910111213start_property_service();void start_property_service() &#123;//åˆ›å»ºäº†ä¸€ä¸ªéé˜»å¡socketproperty_set_fd = create_socket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK, 0666, 0, 0, NULL);if (property_set_fd == -1) &#123; ERROR(\"start_property_service socket creation failed: %s\\n\", strerror(errno)); exit(1);&#125;//è°ƒç”¨listenå‡½æ•°ç›‘å¬property_set_fdï¼Œ äºæ˜¯è¯¥socketå˜æˆä¸€ä¸ªserverlisten(property_set_fd, 8);//ç›‘å¬server socketä¸Šæ˜¯å¦æœ‰æ•°æ®åˆ°æ¥register_epoll_handler(property_set_fd, handle_property_set_fd);&#125; æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨create_socketå‡½æ•°è¿”å›å¥—æ¥å­—property_set_fdæ—¶ï¼Œproperty_set_fdæ˜¯ä¸€ä¸ªä¸»åŠ¨è¿æ¥çš„å¥—æ¥å­—ã€‚æ­¤æ—¶ï¼Œç³»ç»Ÿå‡è®¾ç”¨æˆ·ä¼šå¯¹è¿™ä¸ªå¥—æ¥å­—è°ƒç”¨connectå‡½æ•°ï¼ŒæœŸå¾…å®ƒä¸»åŠ¨ä¸å…¶å®ƒè¿›ç¨‹è¿æ¥ã€‚ ç”±äºåœ¨æœåŠ¡å™¨ç¼–ç¨‹ä¸­ï¼Œç”¨æˆ·å¸Œæœ›è¿™ä¸ªå¥—æ¥å­—å¯ä»¥æ¥å—å¤–æ¥çš„è¿æ¥è¯·æ±‚ï¼Œä¹Ÿå°±æ˜¯è¢«åŠ¨ç­‰å¾…ç”¨æˆ·æ¥è¿æ¥ï¼Œäºæ˜¯éœ€è¦è°ƒç”¨listenå‡½æ•°ä½¿ç”¨ä¸»åŠ¨è¿æ¥å¥—æ¥å­—å˜ä¸ºè¢«è¿æ¥å¥—æ¥å­—ï¼Œä½¿å¾—ä¸€ä¸ªè¿›ç¨‹å¯ä»¥æ¥å—å…¶å®ƒè¿›ç¨‹çš„è¯·æ±‚ï¼Œä»è€Œæˆä¸ºä¸€ä¸ªæœåŠ¡å™¨è¿›ç¨‹ã€‚ å› æ­¤ï¼Œè°ƒç”¨listenåï¼Œinitè¿›ç¨‹æˆä¸ºä¸€ä¸ªæœåŠ¡è¿›ç¨‹ï¼Œå…¶å®ƒè¿›ç¨‹å¯ä»¥é€šè¿‡property_set_fdè¿æ¥initè¿›ç¨‹ï¼Œæäº¤è®¾ç½®ç³»ç»Ÿå±æ€§çš„ç”³è¯·ã€‚ listenå‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œæ¶‰åŠåˆ°ä¸€äº›ç½‘ç»œçš„ç»†èŠ‚ã€‚ åœ¨è¿›ç¨‹å¤„ç†ä¸€ä¸ªè¿æ¥è¯·æ±‚çš„æ—¶å€™ï¼Œå¯èƒ½è¿˜å­˜åœ¨å…¶å®ƒçš„è¿æ¥è¯·æ±‚ã€‚å› ä¸ºTCPè¿æ¥æ˜¯ä¸€ä¸ªè¿‡ç¨‹ï¼Œæ‰€ä»¥å¯èƒ½å­˜åœ¨ä¸€ç§åŠè¿æ¥çš„çŠ¶æ€ã€‚æœ‰æ—¶ç”±äºåŒæ—¶å°è¯•è¿æ¥çš„ç”¨æˆ·è¿‡å¤šï¼Œä½¿å¾—æœåŠ¡å™¨è¿›ç¨‹æ— æ³•å¿«é€Ÿåœ°å®Œæˆè¿æ¥è¯·æ±‚ã€‚ å› æ­¤ï¼Œå†…æ ¸ä¼šåœ¨è‡ªå·±çš„è¿›ç¨‹ç©ºé—´é‡Œç»´æŠ¤ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä»¥è·Ÿè¸ªé‚£äº›å·²å®Œæˆè¿æ¥ä½†æœåŠ¡å™¨è¿›ç¨‹è¿˜æ²¡æœ‰æ¥æ‰‹å¤„ç†çš„ç”¨æˆ·ï¼Œæˆ–æ­£åœ¨è¿›è¡Œçš„è¿æ¥çš„ç”¨æˆ·ã€‚è¿™æ ·çš„ä¸€ä¸ªé˜Ÿåˆ—ä¸å¯èƒ½ä»»æ„å¤§ï¼Œæ‰€ä»¥å¿…é¡»æœ‰ä¸€ä¸ªä¸Šé™ã€‚listençš„ç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯å‘Šè¯‰å†…æ ¸ä½¿ç”¨è¿™ä¸ªæ•°å€¼ä½œä¸ºä¸Šé™ã€‚å› æ­¤ï¼Œinitè¿›ç¨‹ä½œä¸ºç³»ç»Ÿå±æ€§è®¾ç½®çš„æœåŠ¡å™¨ï¼Œæœ€å¤šå¯ä»¥åŒæ—¶ä¸º8ä¸ªè¯•å›¾è®¾ç½®å±æ€§çš„ç”¨æˆ·æä¾›æœåŠ¡ã€‚ åœ¨å¯åŠ¨é…ç½®å±æ€§æœåŠ¡çš„æœ€åï¼Œè°ƒç”¨å‡½æ•°register_epoll_handlerã€‚æ ¹æ®ä¸Šæ–‡æ‰€è¿°ï¼Œæˆ‘ä»¬çŸ¥é“è¯¥å‡½æ•°å°†åˆ©ç”¨ä¹‹å‰åˆ›å»ºå‡ºçš„epollå¥æŸ„ç›‘å¬property_set_fdã€‚å½“property_set_fdä¸­æœ‰æ•°æ®åˆ°æ¥æ—¶ï¼Œinitè¿›ç¨‹å°†åˆ©ç”¨handle_property_set_fdå‡½æ•°è¿›è¡Œå¤„ç†ã€‚ 12345678910111213static void handle_property_set_fd() &#123; .......... if ((s = accept(property_set_fd, (struct sockaddr *) &amp;addr, &amp;addr_size)) &lt; 0) &#123; return; &#125; ........ r = TEMP_FAILURE_RETRY(recv(s, &amp;msg, sizeof(msg), MSG_DONTWAIT)); ......... switch(msg.cmd) &#123; ......... &#125; .........&#125; handle_propery_set_fdå‡½æ•°å®é™…ä¸Šæ˜¯è°ƒç”¨acceptå‡½æ•°ç›‘å¬è¿æ¥è¯·æ±‚ï¼Œæ¥æ”¶property_set_fdä¸­åˆ°æ¥çš„æ•°æ®ï¼Œç„¶ååˆ©ç”¨recvå‡½æ•°æ¥å—åˆ°æ¥çš„æ•°æ®ï¼Œæœ€åæ ¹æ®åˆ°æ¥æ•°æ®çš„ç±»å‹ï¼Œè¿›è¡Œè®¾ç½®ç³»ç»Ÿå±æ€§ç­‰ç›¸å…³æ“ä½œï¼Œåœ¨æ­¤ä¸åšæ·±å…¥åˆ†æã€‚ åœ¨è¿™ä¸€éƒ¨åˆ†çš„æœ€åï¼Œæˆ‘ä»¬ç®€å•ä¸¾ä¾‹ä»‹ç»ä¸€ä¸‹ï¼Œç³»ç»Ÿå±æ€§æ”¹å˜çš„ä¸€äº›ç”¨é€”ã€‚ åœ¨init.rcä¸­å®šä¹‰äº†ä¸€äº›ä¸å±æ€§ç›¸å…³çš„è§¦å‘å™¨ã€‚å½“æŸä¸ªæ¡ä»¶ç›¸å…³çš„å±æ€§è¢«æ”¹å˜æ—¶ï¼Œä¸è¯¥æ¡ä»¶ç›¸å…³çš„è§¦å‘å™¨å°±ä¼šè¢«è§¦å‘ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œå¦‚ä¸‹é¢ä»£ç æ‰€ç¤ºï¼Œdebuggableå±æ€§å˜ä¸º1æ—¶ï¼Œå°†æ‰§è¡Œå¯åŠ¨consoleè¿›ç¨‹ç­‰æ“ä½œã€‚ 12345on property:ro.debuggable=1# Give writes to anyone for the trace folder on debug builds.# The folder is used to store method traces.chmod 0773 /data/misc/tracestart console æ€»ç»“ä¸€ä¸‹ï¼Œå…¶å®ƒè¿›ç¨‹ä¿®æ”¹ç³»ç»Ÿå±æ€§æ—¶ï¼Œå¤§è‡´çš„æµç¨‹å¦‚ä¸‹å›¾æ‰€ç¤ºï¼šå…¶å®ƒçš„è¿›ç¨‹åƒinitè¿›ç¨‹å‘é€è¯·æ±‚åï¼Œç”±initè¿›ç¨‹æ£€æŸ¥æƒé™åï¼Œä¿®æ”¹å…±äº«å†…å­˜åŒºã€‚ 4.1.12ã€è§£æinit.rcæ–‡ä»¶å…³äºè§£æinit.rcçš„ä»£ç ï¼ŒAndroid 7.0ç›¸å¯¹äº6.0ï¼Œä½œäº†å·¨å¤§çš„ä¿®æ”¹ã€‚ 1234567891011121314//è¿™é‡Œå°†Actionçš„function_map_æ›¿æ¢ä¸ºBuiltinFunctionMap//ä¸‹æ–‡å°†é€šè¿‡BuiltinFuntionMapçš„mapæ–¹æ³•ï¼Œè·å–keywordå¯¹åº”çš„å¤„ç†å‡½æ•°const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map);//æ„é€ å‡ºè§£ææ–‡ä»¶ç”¨çš„parserå¯¹è±¡Parser&amp; parser = Parser::GetInstance();//ä¸ºä¸€äº›ç±»å‹çš„å…³é”®å­—ï¼Œåˆ›å»ºç‰¹å®šçš„parserparser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;());//å¼€å§‹å®é™…çš„è§£æè¿‡ç¨‹parser.ParseConfig(\"/init.rc\");........ åœ¨è§£æinit.rcæ–‡ä»¶çš„è¿‡ç¨‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥ç®€å•ä»‹ç»ä¸€ä¸‹init.rcæ–‡ä»¶ã€‚ init.rcæ–‡ä»¶æ˜¯åœ¨initè¿›ç¨‹å¯åŠ¨åæ‰§è¡Œçš„å¯åŠ¨è„šæœ¬ï¼Œæ–‡ä»¶ä¸­è®°å½•ç€initè¿›ç¨‹éœ€æ‰§è¡Œçš„æ“ä½œã€‚åœ¨Androidç³»ç»Ÿä¸­ï¼Œä½¿ç”¨init.rcå’Œinit.{ hardware }.rcä¸¤ä¸ªæ–‡ä»¶ã€‚ å…¶ä¸­init.rcæ–‡ä»¶åœ¨Androidç³»ç»Ÿè¿è¡Œè¿‡ç¨‹ä¸­ç”¨äºé€šç”¨çš„ç¯å¢ƒè®¾ç½®ä¸è¿›ç¨‹ç›¸å…³çš„å®šä¹‰ï¼Œinit.{hardware}.rcï¼ˆä¾‹å¦‚ï¼Œé«˜é€šæœ‰init.qcom.rcï¼ŒMTKæœ‰init.mediatek.rcï¼‰ç”¨äºå®šä¹‰Androidåœ¨ä¸åŒå¹³å°ä¸‹çš„ç‰¹å®šè¿›ç¨‹å’Œç¯å¢ƒè®¾ç½®ç­‰ã€‚ æ­¤å¤„è§£æå‡½æ•°ä¼ å…¥çš„å‚æ•°ä¸ºâ€/init.rcâ€ï¼Œè§£æçš„æ˜¯è¿è¡Œæ—¶ä¸initè¿›ç¨‹åŒåœ¨æ ¹ç›®å½•ä¸‹çš„init.rcæ–‡ä»¶ã€‚è¯¥æ–‡ä»¶åœ¨ç¼–è¯‘å‰ï¼Œå®šä¹‰äºsystem/core/rootdir/init.rcä¸­ï¼ˆä¸å¹³å°ç›¸å…³çš„rcæ–‡ä»¶ä¸åœ¨è¿™é‡ŒåŠ è½½ï¼‰ã€‚ init.rcæ–‡ä»¶å¤§è‡´åˆ†ä¸ºä¸¤å¤§éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ˜¯ä»¥â€onâ€å…³é”®å­—å¼€å¤´çš„åŠ¨ä½œåˆ—è¡¨ï¼ˆaction listï¼‰ï¼š 12345on early-init # Set init and its forked children's oom_adj. write /proc/1/oom_score_adj -1000 ......... start ueventd å¦ä¸€éƒ¨åˆ†æ˜¯ä»¥â€serviceâ€å…³é”®å­—å¼€å¤´çš„æœåŠ¡åˆ—è¡¨ï¼ˆservice listï¼‰ï¼š 1234service ueventd /sbin/ueventd class core critical seclabel u:r:ueventd:s0 å€ŸåŠ©ç³»ç»Ÿç¯å¢ƒå˜é‡æˆ–Linuxå‘½ä»¤ï¼ŒåŠ¨ä½œåˆ—è¡¨ç”¨äºåˆ›å»ºæ‰€éœ€ç›®å½•ï¼Œä»¥åŠä¸ºæŸäº›ç‰¹å®šæ–‡ä»¶æŒ‡å®šæƒé™ï¼Œè€ŒæœåŠ¡åˆ—è¡¨ç”¨æ¥è®°å½•initè¿›ç¨‹éœ€è¦å¯åŠ¨çš„ä¸€äº›å­è¿›ç¨‹ã€‚å¦‚ä¸Šé¢ä»£ç æ‰€ç¤ºï¼Œserviceå…³é”®å­—åçš„ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºæœåŠ¡ï¼ˆå­è¿›ç¨‹ï¼‰çš„åç§°ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²è¡¨ç¤ºæœåŠ¡çš„æ‰§è¡Œè·¯å¾„ã€‚ æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬ä»ParseConfigå‡½æ•°å…¥æ‰‹ï¼Œé€æ­¥åˆ†ææ•´ä¸ªè§£æè¿‡ç¨‹(å‡½æ•°å®šä¹‰äºsystem/core/init/ init_parser.cppä¸­)ï¼š 123456789101112131415161718192021222324bool Parser::ParseConfig(const std::string&amp; path) &#123; if (is_dir(path.c_str())) &#123; //ä¼ å…¥å‚æ•°ä¸ºç›®å½•åœ°å€ return ParseConfigDir(path); &#125; //ä¼ å…¥å‚æ•°ä¸ºæ–‡ä»¶åœ°å€ return ParseConfigFile(path);&#125;bool Parser::ParseConfigDir(const std::string&amp; path) &#123; ........... std::unique_ptr&lt;DIR, int(*)(DIR*)&gt; config_dir(opendir(path.c_str()), closedir); .......... //çœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œå…¶å®å°±æ˜¯é€’å½’ç›®å½• while ((current_file = readdir(config_dir.get()))) &#123; std::string current_path = android::base::StringPrintf(\"%s/%s\", path.c_str(), current_file-&gt;d_name); if (current_file-&gt;d_type == DT_REG) &#123; //æœ€ç»ˆè¿˜æ˜¯é ParseConfigFileæ¥è§£æå®é™…çš„æ–‡ä»¶ if (!ParseConfigFile(current_path)) &#123; ............. &#125; &#125; &#125;&#125; ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œè§£æinit.rcæ–‡ä»¶çš„å‡½æ•°æ˜¯ParseConfigFileï¼š 123456789101112bool Parser::ParseConfigFile(const std::string&amp; path) &#123; ........ std::string data; //è¯»å–è·¯å¾„æŒ‡å®šæ–‡ä»¶ä¸­çš„å†…å®¹ï¼Œä¿å­˜ä¸ºå­—ç¬¦ä¸²å½¢å¼ if (!read_file(path.c_str(), &amp;data)) &#123; return false; &#125; ......... //è§£æè·å–çš„å­—ç¬¦ä¸² ParseData(path, data); .........&#125; ParseDataå‡½æ•°å®šä¹‰äºsystem/core/init/init_parser.cppä¸­ï¼Œæ ¹æ®å…³é”®å­—è§£æå‡ºæœåŠ¡å’ŒåŠ¨ä½œã€‚åŠ¨ä½œä¸æœåŠ¡ä¼šä»¥é“¾è¡¨èŠ‚ç‚¹çš„å½¢å¼æ³¨å†Œåˆ°service_listä¸action_listä¸­ï¼Œservice_listä¸action_listæ˜¯initè¿›ç¨‹ä¸­å£°æ˜çš„å…¨å±€ç»“æ„ä½“ï¼Œå…¶ä¸­çš„å…³é”®ä»£ç ä¸‹æ‰€ç¤ºã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void Parser::ParseData(const std::string&amp; filename, const std::string&amp; data) &#123;.......parse_state state;.......std::vector&lt;std::string&gt; args;for (;;) &#123; //next_tokenä»¥è¡Œä¸ºå•ä½åˆ†å‰²å‚æ•°ä¼ é€’è¿‡æ¥çš„å­—ç¬¦ä¸² //æœ€å…ˆèµ°åˆ°T_TEXTåˆ†æ”¯ switch (next_token(&amp;state)) &#123; case T_EOF: if (section_parser) &#123; //EOF,è§£æç»“æŸ section_parser-&gt;EndSection(); &#125; return; case T_NEWLINE: state.line++; if (args.empty()) &#123; break; &#125; //åœ¨å‰æ–‡åˆ›å»ºparseræ—¶ï¼Œæˆ‘ä»¬ä¸ºserviceï¼Œonï¼Œimportå®šä¹‰äº†å¯¹åº”çš„parser //è¿™é‡Œå°±æ˜¯æ ¹æ®ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰å¯¹åº”çš„parser if (section_parsers_.count(args[0])) &#123; if (section_parser) &#123; //ç»“æŸä¸Šä¸€ä¸ªparserçš„å·¥ä½œï¼Œå°†æ„é€ å‡ºçš„å¯¹è±¡åŠ å…¥åˆ°å¯¹åº”çš„service_listä¸action_listä¸­ section_parser-&gt;EndSection(); &#125; //è·å–å‚æ•°å¯¹åº”çš„parser section_parser = section_parsers_[args[0]].get(); std::string ret_err; //è°ƒç”¨å®é™…parserçš„ParseSectionå‡½æ•° if (!section_parser-&gt;ParseSection(args, &amp;ret_err)) &#123; parse_error(&amp;state, \"%s\\n\", ret_err.c_str()); section_parser = nullptr; &#125; &#125; else if (section_parser) &#123; std::string ret_err; //å¦‚æœç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯serviceï¼Œonï¼Œimport //åˆ™è°ƒç”¨å‰ä¸€ä¸ªparserçš„ParseLineSectionå‡½æ•° //è¿™é‡Œç›¸å½“äºè§£æä¸€ä¸ªå‚æ•°å—çš„å­é¡¹ if (!section_parser-&gt;ParseLineSection(args, state.filename, state.line, &amp;ret_err)) &#123; parse_error(&amp;state, \"%s\\n\", ret_err.c_str()); &#125; &#125; //æ¸…ç©ºæœ¬æ¬¡è§£æçš„æ•°æ® args.clear(); break; case T_TEXT: //å°†æœ¬æ¬¡è§£æçš„å†…å®¹å†™å…¥åˆ°argsä¸­ args.emplace_back(state.text); break; &#125;&#125;&#125; è¿™é‡Œçš„è§£æçœ‹èµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œåœ¨6.0ä»¥å‰çš„ç‰ˆæœ¬ä¸­ï¼Œæ•´ä¸ªè§£ææ˜¯é¢å‘è¿‡ç¨‹çš„ã€‚initè¿›ç¨‹ç»Ÿä¸€è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ¥è¿›è¡Œè§£æï¼Œç„¶ååœ¨è¯¥å‡½æ•°ä¸­åˆ©ç”¨switch-caseçš„å½¢å¼ï¼Œæ ¹æ®è§£æçš„å†…å®¹è¿›è¡Œç›¸åº”çš„å¤„ç†ã€‚ åœ¨Android 7.0ä¸­ï¼Œä¸ºäº†æ›´å¥½åœ°å°è£…åŠé¢å‘å¯¹è±¡ï¼Œå¯¹äºä¸åŒçš„å…³é”®å­—å®šä¹‰äº†ä¸åŒçš„parserå¯¹è±¡ï¼Œæ¯ä¸ªå¯¹è±¡é€šè¿‡å¤šæ€å®ç°è‡ªå·±çš„è§£ææ“ä½œã€‚ æˆ‘ä»¬ç°åœ¨å›å¿†ä¸€ä¸‹initè¿›ç¨‹mainå‡½æ•°ä¸­ï¼Œåˆ›å»ºparserçš„ä»£ç ï¼š 123456...........Parser&amp; parser = Parser::GetInstance();parser.AddSectionParser(\"service\",std::make_unique&lt;ServiceParser&gt;());parser.AddSectionParser(\"on\", std::make_unique&lt;ActionParser&gt;());parser.AddSectionParser(\"import\", std::make_unique&lt;ImportParser&gt;());........... çœ‹çœ‹ä¸‰ä¸ªParserçš„å®šä¹‰ï¼š 123class ServiceParser : public SectionParser &#123;......&#125;class ActionParser : public SectionParser &#123;......&#125;class ImportParser : public SectionParser &#123;.......&#125; å¯ä»¥çœ‹åˆ°ä¸‰ä¸ªParserå‡æ˜¯ç»§æ‰¿SectionParserï¼Œå…·ä½“çš„å®ç°å„æœ‰ä¸åŒï¼Œæˆ‘ä»¬ä»¥æ¯”è¾ƒå¸¸ç”¨çš„ServiceParserå’ŒActionParserä¸ºä¾‹ï¼Œçœ‹çœ‹è§£æçš„ç»“æœå¦‚ä½•å¤„ç†ã€‚ 4.1.12..1 ServiceParserServiceParserå®šä¹‰äºsystem/core/init/service.cppä¸­ã€‚ä»å‰é¢çš„ä»£ç ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œè§£æä¸€ä¸ªserviceå—ï¼Œé¦–å…ˆéœ€è¦è°ƒç”¨ParseSectionå‡½æ•°ï¼Œæ¥ç€åˆ©ç”¨ParseLineSectionå¤„ç†å­å—ï¼Œè§£æå®Œæ‰€æœ‰æ•°æ®åï¼Œè°ƒç”¨EndSectionã€‚ å› æ­¤ï¼Œæˆ‘ä»¬ç€é‡çœ‹çœ‹ServiceParserçš„è¿™ä¸‰ä¸ªå‡½æ•°ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 bool ServiceParser::ParseSection(.....) &#123; ....... const std::string&amp; name = args[1]; ....... std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end()); //ä¸»è¦æ ¹æ®å‚æ•°ï¼Œæ„é€ å‡ºä¸€ä¸ªserviceå¯¹è±¡ service_ = std::make_unique&lt;Service&gt;(name, \"default\", str_args); return true;&#125;//æ³¨æ„è¿™é‡Œå·²ç»åœ¨è§£æå­é¡¹äº†bool ServiceParser::ParseLineSection(......) const &#123; //è°ƒç”¨serviceå¯¹è±¡çš„HandleLine return service_ ? service_-&gt;HandleLine(args, err) : false;&#125;bool Service::HandleLine(.....) &#123; ........ //OptionHandlerMapç»§æ‰¿è‡ªkeywordMap&lt;OptionHandler&gt; static const OptionHandlerMap handler_map; //æ ¹æ®å­é¡¹çš„å†…å®¹ï¼Œæ‰¾åˆ°å¯¹åº”çš„handlerå‡½æ•° //FindFunctionå®šä¹‰ä¸keywordæ¨¡å—ä¸­,FindFunctionæ–¹æ³•åˆ©ç”¨å­ç±»ç”Ÿæˆå¯¹åº”çš„mapä¸­ï¼Œç„¶åé€šè¿‡é€šç”¨çš„æŸ¥æ‰¾æ–¹æ³•ï¼Œå³æ¯”è¾ƒé”®å€¼æ‰¾åˆ°å¯¹åº”çš„å¤„ç†å‡½æ•° auto handler = handler_map.FindFunction(args[0], args.size() - 1, err); if (!handler) &#123; return false; &#125; //è°ƒç”¨handlerå‡½æ•° return (this-&gt;*handler)(args, err);&#125;class Service::OptionHandlerMap : public KeywordMap&lt;OptionHandler&gt; &#123; ........... Service::OptionHandlerMap::Map&amp; Service::OptionHandlerMap::map() const &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); static const Map option_handlers = &#123; &#123;\"class\", &#123;1, 1, &amp;Service::HandleClass&#125;&#125;, &#123;\"console\", &#123;0, 0, &amp;Service::HandleConsole&#125;&#125;, &#123;\"critical\", &#123;0, 0, &amp;Service::HandleCritical&#125;&#125;, &#123;\"disabled\", &#123;0, 0, &amp;Service::HandleDisabled&#125;&#125;, &#123;\"group\", &#123;1, NR_SVC_SUPP_GIDS + 1, &amp;Service::HandleGroup&#125;&#125;, &#123;\"ioprio\", &#123;2, 2, &amp;Service::HandleIoprio&#125;&#125;, &#123;\"keycodes\", &#123;1, kMax, &amp;Service::HandleKeycodes&#125;&#125;, &#123;\"oneshot\", &#123;0, 0, &amp;Service::HandleOneshot&#125;&#125;, &#123;\"onrestart\", &#123;1, kMax, &amp;Service::HandleOnrestart&#125;&#125;, &#123;\"seclabel\", &#123;1, 1, &amp;Service::HandleSeclabel&#125;&#125;, &#123;\"setenv\", &#123;2, 2, &amp;Service::HandleSetenv&#125;&#125;, &#123;\"socket\", &#123;3, 6, &amp;Service::HandleSocket&#125;&#125;, &#123;\"user\", &#123;1, 1, &amp;Service::HandleUser&#125;&#125;, &#123;\"writepid\", &#123;1, kMax, &amp;Service::HandleWritepid&#125;&#125;, &#125;; return option_handlers;&#125;//ä»¥classå¯¹åº”çš„å¤„ç†å‡½æ•°ä¸ºä¾‹ï¼Œå¯ä»¥çœ‹å‡ºå…¶å®å°±æ˜¯å¡«å……serviceå¯¹è±¡å¯¹åº”çš„åŸŸbool Service::HandleClass(const std::vector&lt;std::string&gt;&amp; args, std::string* err) &#123; classname_ = args[1]; return true;&#125;//æ³¨æ„æ­¤æ—¶serviceå¯¹è±¡å·²ç»å¤„ç†å®Œæ¯•void ServiceParser::EndSection() &#123; if (service_) &#123; ServiceManager::GetInstance().AddService(std::move(service_)); &#125;&#125;void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) &#123; Service* old_service = FindServiceByName(service-&gt;name()); if (old_service) &#123; ERROR(\"ignored duplicate definition of service '%s'\", service-&gt;name().c_str()); return; &#125; //å°†serviceå¯¹è±¡åŠ å…¥åˆ°services_é‡Œ //7.0é‡Œï¼Œservices_å·²ç»æ˜¯ä¸ªvectoräº† services_.emplace_back(std::move(service));&#125; ä»ä¸Šé¢çš„ä¸€ç³»åˆ—ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºServiceParserå…¶å®å°±æ˜¯ï¼šé¦–å…ˆæ ¹æ®ç¬¬ä¸€è¡Œçš„åå­—å’Œå‚æ•°åˆ›å»ºå‡ºserviceå¯¹è±¡ï¼Œç„¶åæ ¹æ®é€‰é¡¹åŸŸçš„å†…å®¹å¡«å……serviceå¯¹è±¡ï¼Œæœ€åå°†åˆ›å»ºå‡ºçš„serviceå¯¹è±¡åŠ å…¥åˆ°vectorç±»å‹çš„serviceé“¾è¡¨ä¸­ã€‚ 4.1.12.2 ActionParserActionParserå®šä¹‰äºsystem/core/init/action.cppä¸­ã€‚Actionçš„è§£æè¿‡ç¨‹ï¼Œå…¶å®ä¸Serviceä¸€æ ·ï¼Œä¹Ÿæ˜¯å…ˆåè°ƒç”¨ParseSectionï¼Œ ParseLineSectionå’ŒEndSectionã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051bool ActionParser::ParseSection(....) &#123; ........ //åˆ›å»ºå‡ºæ–°çš„actionå¯¹è±¡ auto action = std::make_unique&lt;Action&gt;(false); //æ ¹æ®å‚æ•°ï¼Œå¡«å……actionçš„triggeråŸŸï¼Œä¸è¯¦ç»†åˆ†æäº† if (!action-&gt;InitTriggers(triggers, err)) &#123; return false; &#125; .........&#125;bool ActionParser::ParseLineSection(.......) const &#123; //æ„é€ Actionå¯¹è±¡çš„commandåŸŸ return action_ ? action_-&gt;AddCommand(args, filename, line, err) : false;&#125;bool Action::AddCommand(.....) &#123; ........ //æ‰¾å‡ºactionå¯¹åº”çš„æ‰§è¡Œå‡½æ•° auto function = function_map_-&gt;FindFunction(args[0], args.size() - 1, err); ........ //åˆ©ç”¨æ‰€æœ‰ä¿¡æ¯æ„é€ å‡ºcommandï¼ŒåŠ å…¥åˆ°actionå¯¹è±¡ä¸­ AddCommand(function, args, filename, line); return true;&#125;void Action::AddCommand(......) &#123; commands_.emplace_back(f, args, filename, line);&#125;void ActionParser::EndSection() &#123; if (action_ &amp;&amp; action_-&gt;NumCommands() &gt; 0) &#123; ActionManager::GetInstance().AddAction(std::move(action_)); &#125;&#125;void ActionManager::AddAction(.....) &#123; ........ auto old_action_it = std::find_if(actions_.begin(), actions_.end(), [&amp;action] (std::unique_ptr&lt;Action&gt;&amp; a) &#123; return action-&gt;TriggersEqual(*a); &#125;); if (old_action_it != actions_.end()) &#123; (*old_action_it)-&gt;CombineAction(*action); &#125; else &#123; //åŠ å…¥åˆ°actioné“¾è¡¨ä¸­ï¼Œç±»å‹ä¹Ÿæ˜¯vectorï¼Œå…¶ä¸­è£…çš„æ˜¯æŒ‡é’ˆ actions_.emplace_back(std::move(action)); &#125;&#125; ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼ŒåŠ è½½actionå—çš„é€»è¾‘å’Œserviceä¸€æ ·ï¼Œä¸åŒçš„æ˜¯éœ€è¦å¡«å……triggerå’ŒcommandåŸŸã€‚å½“ç„¶ï¼Œæœ€åè§£æå‡ºçš„actionä¹Ÿéœ€è¦åŠ å…¥åˆ°actioné“¾è¡¨ä¸­ã€‚ è¿™é‡Œæœ€åè¿˜å‰©ä¸‹ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å“ªé‡Œå®šä¹‰äº†Actionä¸­commandå¯¹åº”å¤„ç†å‡½æ•°ï¼Ÿ å®é™…ä¸Šï¼Œå‰æ–‡å·²ç»å‡ºç°äº†è¿‡äº†ï¼Œåœ¨init.cppçš„mainå‡½æ•°ä¸­ï¼š 1234.......const BuiltinFunctionMap function_map;Action::set_function_map(&amp;function_map);....... å› æ­¤ï¼ŒActionä¸­è°ƒç”¨functionmap-&gt;FindFunctionæ—¶ï¼Œå®é™…ä¸Šè°ƒç”¨çš„æ˜¯BuiltinFunctionMapçš„FindFunctionå‡½æ•°ã€‚æˆ‘ä»¬å·²ç»çŸ¥é“FindFunctionæ˜¯keywordå®šä¹‰çš„é€šç”¨å‡½æ•°ï¼Œé‡ç‚¹æ˜¯é‡æ„çš„mapå‡½æ•°ã€‚æˆ‘ä»¬çœ‹çœ‹system/core/init/builtins.cppï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546BuiltinFunctionMap::Map&amp; BuiltinFunctionMap::map() const &#123; constexpr std::size_t kMax = std::numeric_limits&lt;std::size_t&gt;::max(); static const Map builtin_functions = &#123; &#123;\"bootchart_init\", &#123;0, 0, do_bootchart_init&#125;&#125;, &#123;\"chmod\", &#123;2, 2, do_chmod&#125;&#125;, &#123;\"chown\", &#123;2, 3, do_chown&#125;&#125;, &#123;\"class_reset\", &#123;1, 1, do_class_reset&#125;&#125;, &#123;\"class_start\", &#123;1, 1, do_class_start&#125;&#125;, &#123;\"class_stop\", &#123;1, 1, do_class_stop&#125;&#125;, &#123;\"copy\", &#123;2, 2, do_copy&#125;&#125;, &#123;\"domainname\", &#123;1, 1, do_domainname&#125;&#125;, &#123;\"enable\", &#123;1, 1, do_enable&#125;&#125;, &#123;\"exec\", &#123;1, kMax, do_exec&#125;&#125;, &#123;\"export\", &#123;2, 2, do_export&#125;&#125;, &#123;\"hostname\", &#123;1, 1, do_hostname&#125;&#125;, &#123;\"ifup\", &#123;1, 1, do_ifup&#125;&#125;, &#123;\"init_user0\", &#123;0, 0, do_init_user0&#125;&#125;, &#123;\"insmod\", &#123;1, kMax, do_insmod&#125;&#125;, &#123;\"installkey\", &#123;1, 1, do_installkey&#125;&#125;, &#123;\"load_persist_props\", &#123;0, 0, do_load_persist_props&#125;&#125;, &#123;\"load_system_props\", &#123;0, 0, do_load_system_props&#125;&#125;, &#123;\"loglevel\", &#123;1, 1, do_loglevel&#125;&#125;, &#123;\"mkdir\", &#123;1, 4, do_mkdir&#125;&#125;, &#123;\"mount_all\", &#123;1, kMax, do_mount_all&#125;&#125;, &#123;\"mount\", &#123;3, kMax, do_mount&#125;&#125;, &#123;\"powerctl\", &#123;1, 1, do_powerctl&#125;&#125;, &#123;\"restart\", &#123;1, 1, do_restart&#125;&#125;, &#123;\"restorecon\", &#123;1, kMax, do_restorecon&#125;&#125;, &#123;\"restorecon_recursive\", &#123;1, kMax, do_restorecon_recursive&#125;&#125;, &#123;\"rm\", &#123;1, 1, do_rm&#125;&#125;, &#123;\"rmdir\", &#123;1, 1, do_rmdir&#125;&#125;, &#123;\"setprop\", &#123;2, 2, do_setprop&#125;&#125;, &#123;\"setrlimit\", &#123;3, 3, do_setrlimit&#125;&#125;, &#123;\"start\", &#123;1, 1, do_start&#125;&#125;, &#123;\"stop\", &#123;1, 1, do_stop&#125;&#125;, &#123;\"swapon_all\", &#123;1, 1, do_swapon_all&#125;&#125;, &#123;\"symlink\", &#123;2, 2, do_symlink&#125;&#125;, &#123;\"sysclktz\", &#123;1, 1, do_sysclktz&#125;&#125;, &#123;\"trigger\", &#123;1, 1, do_trigger&#125;&#125;, &#123;\"verity_load_state\", &#123;0, 0, do_verity_load_state&#125;&#125;, &#123;\"verity_update_state\", &#123;0, 0, do_verity_update_state&#125;&#125;, &#123;\"wait\", &#123;1, 2, do_wait&#125;&#125;, &#123;\"write\", &#123;2, 2, do_write&#125;&#125;, &#125;; return builtin_functions;&#125; ä¸Šè¿°ä»£ç çš„ç¬¬å››é¡¹å°±æ˜¯Actionæ¯ä¸ªcommandå¯¹åº”çš„æ‰§è¡Œå‡½æ•°ã€‚ 4.1.13ã€å‘æ‰§è¡Œé˜Ÿåˆ—ä¸­æ·»åŠ å…¶å®ƒactionä»‹ç»å®Œinitè¿›ç¨‹è§£æinit.rcæ–‡ä»¶çš„è¿‡ç¨‹åï¼Œæˆ‘ä»¬ç»§ç»­å°†è§†è§’æ‹‰å›åˆ°initè¿›ç¨‹çš„mainå‡½æ•°ï¼š 1234567891011121314151617181920212223242526272829ActionManager&amp; am = ActionManager::GetInstance();am.QueueEventTrigger(\"early-init\");// Queue an action that waits for coldboot done so we know ueventd has set up all of /dev...m.QueueBuiltinAction(wait_for_coldboot_done_action, \"wait_for_coldboot_done\");// ... so that we can start queuing up actions that require stuff from /dev.am.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");am.QueueBuiltinAction(set_mmap_rnd_bits_action, \"set_mmap_rnd_bits\");am.QueueBuiltinAction(keychord_init_action, \"keychord_init\");am.QueueBuiltinAction(console_init_action, \"console_init\");// Trigger all the boot actions to get us started.am.QueueEventTrigger(\"init\");// Repeat mix_hwrng_into_linux_rng in case /dev/hw_random or /dev/random// wasn't ready immediately after wait_for_coldboot_doneam.QueueBuiltinAction(mix_hwrng_into_linux_rng_action, \"mix_hwrng_into_linux_rng\");// Don't mount filesystems or start core system services in charger mode.std::string bootmode = property_get(\"ro.bootmode\");if (bootmode == \"charger\") &#123; am.QueueEventTrigger(\"charger\");&#125; else &#123; am.QueueEventTrigger(\"late-init\");&#125;// Run all property triggers based on current state of the properties. am.QueueBuiltinAction(queue_property_triggers_action, \"queue_property_triggers\"); ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œæ¥ä¸‹æ¥initè¿›ç¨‹ä¸­è°ƒç”¨äº†å¤§é‡çš„QueueEventTriggerå’ŒQueueBuiltinActionå‡½æ•°ã€‚ 123void ActionManager::QueueEventTrigger(const std::string&amp; trigger) &#123; trigger_queue_.push(std::make_unique&lt;EventTrigger&gt;(trigger));&#125; å¤„QueueEventTriggerå‡½æ•°å°±æ˜¯åˆ©ç”¨å‚æ•°æ„é€ EventTriggerï¼Œç„¶ååŠ å…¥åˆ°triggerqueueä¸­ã€‚åç»­initè¿›ç¨‹å¤„ç†triggeräº‹ä»¶æ—¶ï¼Œå°†ä¼šè§¦å‘ç›¸åº”çš„æ“ä½œã€‚æ ¹æ®å‰æ–‡çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“å®é™…ä¸Šå°±æ˜¯å°†action_listä¸­ï¼Œå¯¹åº”triggerä¸ç¬¬ä¸€ä¸ªå‚æ•°åŒ¹é…çš„actionï¼ŒåŠ å…¥åˆ°è¿è¡Œé˜Ÿåˆ—action_queueä¸­ã€‚ 12345678910111213141516void ActionManager::QueueBuiltinAction(BuiltinFunction func, const std::string&amp; name) &#123; //åˆ›å»ºaction auto action = std::make_unique&lt;Action&gt;(true); std::vector&lt;std::string&gt; name_vector&#123;name&#125;; //ä¿è¯å”¯ä¸€æ€§ if (!action-&gt;InitSingleTrigger(name)) &#123; return; &#125; //åˆ›å»ºactionçš„cmdï¼ŒæŒ‡å®šæ‰§è¡Œå‡½æ•°å’Œå‚æ•° action-&gt;AddCommand(func, name_vector); trigger_queue_.push(std::make_unique&lt;BuiltinTrigger&gt;(action.get())); actions_.emplace_back(std::move(action));&#125; QueueBuiltinActionå‡½æ•°ä¸­æ„é€ æ–°çš„actionåŠ å…¥åˆ°actions_ä¸­ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä½œä¸ºæ–°å»ºactionæºå¸¦cmdçš„æ‰§è¡Œå‡½æ•°ï¼›ç¬¬äºŒä¸ªå‚æ•°æ—¢ä½œä¸ºactionçš„trigger nameï¼Œä¹Ÿä½œä¸ºactionæºå¸¦cmdçš„å‚æ•°ã€‚ 4.1.14ã€å¤„ç†æ·»åŠ åˆ°è¿è¡Œé˜Ÿåˆ—çš„äº‹ä»¶12345678910111213141516171819202122232425262728293031323334353637while (true) &#123; //åˆ¤æ–­æ˜¯å¦æœ‰äº‹ä»¶éœ€è¦å¤„ç† if (!waiting_for_exec) &#123; //ä¾æ¬¡æ‰§è¡Œæ¯ä¸ªactionä¸­æºå¸¦commandå¯¹åº”çš„æ‰§è¡Œå‡½æ•° am.ExecuteOneCommand(); //é‡å¯ä¸€äº›æŒ‚æ‰çš„è¿›ç¨‹ restart_processes(); &#125; //ä»¥ä¸‹å†³å®štimeoutçš„æ—¶é—´ï¼Œå°†å½±å“whileå¾ªç¯çš„é—´éš” int timeout = -1; //æœ‰è¿›ç¨‹éœ€è¦é‡å¯æ—¶ï¼Œç­‰å¾…è¯¥è¿›ç¨‹é‡å¯ if (process_needs_restart) &#123; timeout = (process_needs_restart - gettime()) * 1000; if (timeout &lt; 0) timeout = 0; &#125; //æœ‰actionå¾…å¤„ç†ï¼Œä¸ç­‰å¾… if (am.HasMoreCommands()) &#123; timeout = 0; &#125; //bootchart_sampleåº”è¯¥æ˜¯è¿›è¡Œæ€§èƒ½æ•°æ®é‡‡æ · bootchart_sample(&amp;timeout); epoll_event ev; //æ²¡æœ‰äº‹ä»¶åˆ°æ¥çš„è¯ï¼Œæœ€å¤šé˜»å¡timeoutæ—¶é—´ int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, timeout)); if (nr == -1) &#123; ERROR(\"epoll_wait failed: %s\\n\", strerror(errno)); &#125; else if (nr == 1) &#123; //æœ‰äº‹ä»¶åˆ°æ¥ï¼Œæ‰§è¡Œå¯¹åº”å¤„ç†å‡½æ•° //æ ¹æ®ä¸Šæ–‡çŸ¥é“ï¼Œepollå¥æŸ„ï¼ˆå³epoll_fdï¼‰ä¸»è¦ç›‘å¬å­è¿›ç¨‹ç»“æŸï¼ŒåŠå…¶å®ƒè¿›ç¨‹è®¾ç½®ç³»ç»Ÿå±æ€§çš„è¯·æ±‚ã€‚ ((void (*)()) ev.data.ptr)(); &#125;&#125; ä»ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºï¼Œinitè¿›ç¨‹å°†æ‰€æœ‰éœ€è¦æ“ä½œçš„actionåŠ å…¥è¿è¡Œé˜Ÿåˆ—åï¼Œ è¿›å…¥æ— é™å¾ªç¯è¿‡ç¨‹ï¼Œä¸æ–­å¤„ç†è¿è¡Œé˜Ÿåˆ—ä¸­çš„äº‹ä»¶ï¼ŒåŒæ—¶è¿›è¡Œé‡å¯serviceç­‰æ“ä½œã€‚ ExecuteOneCommandä¸­çš„ä¸»è¦éƒ¨åˆ†å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void ActionManager::ExecuteOneCommand() &#123; // Loop through the trigger queue until we have an action to execute //å½“æœ‰å¯æ‰§è¡Œactionæˆ–trigger queueä¸ºç©ºæ—¶ç»“æŸ while (current_executing_actions_.empty() &amp;&amp; !trigger_queue_.empty()) &#123; //è½®è¯¢actionsé“¾è¡¨ for (const auto&amp; action : actions_) &#123; //ä¾æ¬¡æŸ¥æ‰¾triggerè¡¨ if (trigger_queue_.front()-&gt;CheckTriggers(*action)) &#123; //å½“actionä¸triggerå¯¹åº”æ—¶ï¼Œå°±å¯ä»¥æ‰§è¡Œå½“å‰action //ä¸€ä¸ªtriggerå¯ä»¥å¯¹åº”å¤šä¸ªactionï¼Œå‡åŠ å…¥current_executing_actions_ current_executing_actions_.emplace(action.get()); &#125; &#125; //trigger eventå‡ºé˜Ÿ trigger_queue_.pop(); &#125; if (current_executing_actions_.empty()) &#123; return; &#125; //æ¯æ¬¡åªæ‰§è¡Œä¸€ä¸ªactionï¼Œä¸‹æ¬¡initè¿›ç¨‹whileå¾ªç¯æ—¶ï¼Œè·³è¿‡ä¸Šé¢çš„whileå¾ªç¯ï¼Œæ¥ç€æ‰§è¡Œ auto action = current_executing_actions_.front(); if (current_command_ == 0) &#123; std::string trigger_name = action-&gt;BuildTriggersString(); INFO(\"processing action (%s)\\n\", trigger_name.c_str()); &#125; //å®é™…çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œæ­¤å¤„ä»…å¤„ç†å½“å‰actionä¸­çš„ä¸€ä¸ªcmd action-&gt;ExecuteOneCommand(current_command_); //é€‚å½“åœ°æ¸…ç†å·¥ä½œï¼Œæ³¨æ„åªæœ‰å½“å‰actionä¸­æ‰€æœ‰çš„commandå‡æ‰§è¡Œå®Œæ¯•åï¼Œæ‰ä¼šå°†è¯¥actionä»current_executing_actions_ç§»é™¤ // If this was the last command in the current action, then remove // the action from the executing list. // If this action was oneshot, then also remove it from actions_. ++current_command_; if (current_command_ == action-&gt;NumCommands()) &#123; current_executing_actions_.pop(); current_command_ = 0; if (action-&gt;oneshot()) &#123; auto eraser = [&amp;action] (std::unique_ptr&lt;Action&gt;&amp; a) &#123; return a.get() == action; &#125;; actions_.erase(std::remove_if(actions_.begin(), actions_.end(), eraser)); &#125; &#125;&#125; 123456void Action::ExecuteCommand(const Command&amp; command) const &#123; Timer t; //æ‰§è¡Œè¯¥commandå¯¹åº”çš„å¤„ç†å‡½æ•° int result = command.InvokeFunc(); ........&#125; ä»ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå½“whileå¾ªç¯ä¸æ–­è°ƒç”¨ExecuteOneCommandå‡½æ•°æ—¶ï¼Œå°†æŒ‰ç…§triggerè¡¨çš„é¡ºåºï¼Œä¾æ¬¡å–å‡ºactioné“¾è¡¨ä¸­ä¸triggeråŒ¹é…çš„actionã€‚ æ¯æ¬¡å‡æ‰§è¡Œä¸€ä¸ªactionä¸­çš„ä¸€ä¸ªcommandå¯¹åº”å‡½æ•°ï¼ˆä¸€ä¸ªactionå¯èƒ½æºå¸¦å¤šä¸ªcommandï¼‰ã€‚ å½“ä¸€ä¸ªactionæ‰€æœ‰çš„commandå‡æ‰§è¡Œå®Œæ¯•åï¼Œå†æ‰§è¡Œä¸‹ä¸€ä¸ªactionã€‚ å½“ä¸€ä¸ªtriggerå¯¹åº”çš„actionå‡æ‰§è¡Œå®Œæ¯•åï¼Œå†æ‰§è¡Œä¸‹ä¸€ä¸ªtriggerå¯¹åº”actionã€‚ restart_processeså‡½æ•°è´Ÿè´£æŒ‰éœ€é‡å¯serviceï¼Œä»£ç å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ 12345678static void restart_processes() &#123; process_needs_restart = 0; ServiceManager::GetInstance().ForEachServiceWithFlags( SVC_RESTARTING, [] (Service* s) &#123; s-&gt;RestartIfNeeded(process_needs_restart); &#125;);&#125; ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œè¯¥å‡½æ•°è½®è¯¢serviceå¯¹åº”çš„é“¾è¡¨ï¼Œå¯¹äºæœ‰SVC_RESTARINGæ ‡å¿—çš„serviceæ‰§è¡ŒRestartIfNeededï¼ˆå¦‚ä¸Šæ–‡æ‰€è¿°ï¼Œå½“å­è¿›ç¨‹ç»ˆæ­¢æ—¶ï¼Œinitè¿›ç¨‹ä¼šå°†å¯è¢«é‡å¯è¿›ç¨‹çš„æœåŠ¡æ ‡å¿—ä½ç½®ä¸ºSVC_RESTARTINGï¼‰ã€‚ å¦‚ä¸‹é¢ä»£ç æ‰€ç¤ºï¼Œrestart_service_if_neededå¯ä»¥é‡æ–°å¯åŠ¨æœåŠ¡ã€‚ 12345678910111213141516171819void Service::RestartIfNeeded(time_t&amp; process_needs_restart)(struct service *svc)&#123; time_t next_start_time = svc-&gt;time_started + 5; //ä¸¤æ¬¡æœåŠ¡å¯åŠ¨æ—¶é—´çš„é—´éš”è¦å¤§äº5s if (next_start_time &lt;= gettime()) &#123; svc-&gt;flags &amp;= (~SVC_RESTARTING); //æ»¡è¶³æ—¶é—´é—´éš”çš„è¦æ±‚åï¼Œé‡å¯æœåŠ¡ //Startå°†ä¼šé‡æ–°forkæœåŠ¡è¿›ç¨‹ï¼Œå¹¶åšç›¸åº”çš„é…ç½® Start(svc, NULL); return; &#125; //æ›´æ–°mainå‡½æ•°ä¸­ï¼Œwhileå¾ªç¯éœ€è¦ç­‰å¾…çš„æ—¶é—´ if ((next_start_time &lt; process_needs_restart) || (process_needs_restart == 0)) &#123; process_needs_restart = next_start_time; &#125;&#125; æŸ¥é˜…èµ„æ–™å‘ç°ï¼šBootchart æ˜¯ä¸€ä¸ªèƒ½å¯¹ GNU/Linux boot è¿‡ç¨‹è¿›è¡Œæ€§èƒ½åˆ†æå¹¶æŠŠç»“æœç›´è§‚åŒ–çš„å·¥å…·ã€‚å®ƒåœ¨ boot è¿‡ç¨‹ä¸­æœé›†èµ„æºåˆ©ç”¨æƒ…å†µåŠè¿›ç¨‹ä¿¡æ¯ç„¶åä»¥PNG, SVGæˆ–EPSæ ¼å¼æ¥æ˜¾ç¤ºç»“æœã€‚BootChart åŒ…å«æ•°æ®æ”¶é›†å·¥å…·å’Œå›¾åƒäº§ç”Ÿå·¥å…·ã€‚æ•°æ®æ”¶é›†å·¥å…·åœ¨åŸå§‹çš„BootChartä¸­æ˜¯ç‹¬ç«‹çš„shellç¨‹åºï¼Œä½†åœ¨Androidä¸­ï¼Œæ•°æ®æ”¶é›†å·¥å…·è¢«é›†æˆåˆ°äº†init ç¨‹åºä¸­ã€‚èµ„æ–™ä¸ä»£ç åŸºæœ¬å»åˆã€‚ ï¼ˆ2ï¼‰ã€å¯åŠ¨Zygoteè¿›ç¨‹4.2.1ã€æ¦‚è¿°Zygoteæ˜¯ç”±initè¿›ç¨‹é€šè¿‡è§£æinit.zygote.rcæ–‡ä»¶è€Œåˆ›å»ºçš„ï¼Œzygoteæ‰€å¯¹åº”çš„å¯æ‰§è¡Œç¨‹åºapp_processï¼Œæ‰€å¯¹åº”çš„æºæ–‡ä»¶æ˜¯App_main.cppï¼Œè¿›ç¨‹åä¸ºzygoteã€‚ 12345678910111213141516service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote class main socket zygote stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media onrestart restart netd writepid /dev/cpuset/foreground/tasksservice zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote --socket-name=zygote_secondary class main socket zygote_secondary stream 660 root system onrestart restart zygote writepid /dev/cpuset/foreground/tasks Zygoteè¿›ç¨‹èƒ½å¤Ÿé‡å¯çš„åœ°æ–¹: servicemanagerè¿›ç¨‹è¢«æ€; (onresart) surfaceflingerè¿›ç¨‹è¢«æ€; (onresart) Zygoteè¿›ç¨‹è‡ªå·±è¢«æ€; (oneshot=false) system_serverè¿›ç¨‹è¢«æ€; (waitpid) ä»App_main()å¼€å§‹ï¼ŒZygoteå¯åŠ¨è¿‡ç¨‹çš„å‡½æ•°è°ƒç”¨ç±»å¤§è‡´æµç¨‹å¦‚ä¸‹ï¼š 4.2.2ã€Zygoteå¯åŠ¨è¿‡ç¨‹4.2.2.1ã€App_main.main()[-&gt; App_main.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113int main(int argc, char* const argv[])&#123; if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) &lt; 0) &#123; // Older kernels don't understand PR_SET_NO_NEW_PRIVS and return // EINVAL. Don't die on such kernels. if (errno != EINVAL) &#123; LOG_ALWAYS_FATAL(\"PR_SET_NO_NEW_PRIVS failed: %s\", strerror(errno)); return 12; &#125; &#125; //ä¼ åˆ°çš„å‚æ•°argvä¸ºâ€œ-Xzygote /system/bin --zygote --start-system-serverâ€ AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] //å¿½ç•¥ç¬¬ä¸€ä¸ªå‚æ•° argc--; argv++; int i; for (i = 0; i &lt; argc; i++) &#123; if (argv[i][0] != '-') &#123; break; &#125; if (argv[i][1] == '-' &amp;&amp; argv[i][2] == 0) &#123; ++i; // Skip --. break; &#125; runtime.addOption(strdup(argv[i])); &#125; // Parse runtime arguments. Stop at first unrecognized option. //å‚æ•°è§£æ bool zygote = false; bool startSystemServer = false; bool application = false; String8 niceName; String8 className; ++i; // Skip unused \"parent dir\" argument. while (i &lt; argc) &#123; const char* arg = argv[i++]; if (strcmp(arg, \"--zygote\") == 0) &#123; zygote = true; niceName = ZYGOTE_NICE_NAME; &#125; else if (strcmp(arg, \"--start-system-server\") == 0) &#123; startSystemServer = true; &#125; else if (strcmp(arg, \"--application\") == 0) &#123; application = true; &#125; else if (strncmp(arg, \"--nice-name=\", 12) == 0) &#123; niceName.setTo(arg + 12); &#125; else if (strncmp(arg, \"--\", 2) != 0) &#123; className.setTo(arg); break; &#125; else &#123; --i; break; &#125; &#125; Vector&lt;String8&gt; args; if (!className.isEmpty()) &#123; // We're not in zygote mode, the only argument we need to pass // to RuntimeInit is the application argument. // // The Remainder of args get passed to startup class main(). Make // copies of them before we overwrite them with the process name. // è¿è¡Œapplicationæˆ–toolç¨‹åº args.add(application ? String8(\"application\") : String8(\"tool\")); runtime.setClassNameAndArgs(className, argc - i, argv + i); &#125; else &#123; // We're in zygote mode. //è¿›å…¥zygoteæ¨¡å¼ï¼Œåˆ›å»º /data/dalvik-cacheè·¯å¾„ maybeCreateDalvikCache(); if (startSystemServer) &#123; args.add(String8(\"start-system-server\")); &#125; char prop[PROP_VALUE_MAX]; if (property_get(ABI_LIST_PROPERTY, prop, NULL) == 0) &#123; LOG_ALWAYS_FATAL(\"app_process: Unable to determine ABI list from property %s.\", ABI_LIST_PROPERTY); return 11; &#125; String8 abiFlag(\"--abi-list=\"); abiFlag.append(prop); args.add(abiFlag); // In zygote mode, pass all remaining arguments to the zygote // main() method. for (; i &lt; argc; ++i) &#123; args.add(String8(argv[i])); &#125; &#125; //è®¾ç½®è¿›ç¨‹å if (!niceName.isEmpty()) &#123; runtime.setArgv0(niceName.string()); set_process_name(niceName.string()); &#125; if (zygote) &#123; // å¯åŠ¨AppRuntime runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; //æ²¡æœ‰æŒ‡å®šç±»åæˆ–zygoteï¼Œå‚æ•°é”™è¯¯ fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125; 4.2.2.2ã€AndroidRuntime.start()[-&gt; AndroidRuntime.cpp] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123;ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid());static const String8 startSystemServer(\"start-system-server\");/* * 'startSystemServer == true' means runtime is obsolete and not run from * init.rc anymore, so we print out the boot start event here. */for (size_t i = 0; i &lt; options.size(); ++i) &#123; if (options[i] == startSystemServer) &#123; /* track our progress through the boot sequence */ const int LOG_BOOT_PROGRESS_START = 3000; LOG_EVENT_LONG(LOG_BOOT_PROGRESS_START, ns2ms(systemTime(SYSTEM_TIME_MONOTONIC))); &#125;&#125;const char* rootDir = getenv(\"ANDROID_ROOT\");if (rootDir == NULL) &#123; rootDir = \"/system\"; if (!hasDir(\"/system\")) &#123; LOG_FATAL(\"No root directory specified, and /android does not exist.\"); return; &#125; setenv(\"ANDROID_ROOT\", rootDir, 1);&#125;//const char* kernelHack = getenv(\"LD_ASSUME_KERNEL\");//ALOGD(\"Found LD_ASSUME_KERNEL='%s'\\n\", kernelHack);/* start the virtual machine */JniInvocation jni_invocation;jni_invocation.Init(NULL);JNIEnv* env;// è™šæ‹Ÿæœºåˆ›å»ºif (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return;&#125;onVmCreated(env);/* * Register android functions. */ // JNIæ–¹æ³•æ³¨å†Œif (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return;&#125;/* * We want to call main() with a String array with arguments in it. * At present we have two arguments, the class name and an option string. * Create an array to hold them. */jclass stringClass;jobjectArray strArray;jstring classNameStr;//ç­‰ä»· strArray= new String[options.size() + 1];stringClass = env-&gt;FindClass(\"java/lang/String\");assert(stringClass != NULL);strArray = env-&gt;NewObjectArray(options.size() + 1, stringClass, NULL);assert(strArray != NULL);//ç­‰ä»· strArray[0] = \"com.android.internal.os.ZygoteInit\"classNameStr = env-&gt;NewStringUTF(className);assert(classNameStr != NULL);env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);//ç­‰ä»· strArray[1] = \"start-system-server\"ï¼›// strArray[2] = \"--abi-list=xxx\"ï¼›//å…¶ä¸­xxxä¸ºç³»ç»Ÿå“åº”çš„cpuæ¶æ„ç±»å‹ï¼Œæ¯”å¦‚arm64-v8a.for (size_t i = 0; i &lt; options.size(); ++i) &#123; jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string()); assert(optionsStr != NULL); env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);&#125;/* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ //å°†\"com.android.internal.os.ZygoteInit\"è½¬æ¢ä¸º\"com/android/internal/os/ZygoteInit\"char* slashClassName = toSlashClassName(className);jclass startClass = env-&gt;FindClass(slashClassName);if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */&#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; // è°ƒç”¨ZygoteInit.main()æ–¹æ³• env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); #if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env); #endif &#125;&#125;free(slashClassName);ALOGD(\"Shutting down VM\\n\");if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(\"Warning: unable to detach main thread\\n\");if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(\"Warning: VM did not shut down cleanly\\n\"); &#125; 4.2.2.3ã€AndroidRuntime.startVm()[â€“&gt; AndroidRuntime.cpp] 12345678910111213141516171819202122232425262728293031323334353637383940414243int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)&#123;// JNIæ£€æµ‹åŠŸèƒ½ï¼Œç”¨äºnativeå±‚è°ƒç”¨jniå‡½æ•°æ—¶è¿›è¡Œå¸¸è§„æ£€æµ‹ï¼Œæ¯”è¾ƒå¼±å­—ç¬¦ä¸²æ ¼å¼æ˜¯å¦ç¬¦åˆè¦æ±‚ï¼Œèµ„æºæ˜¯å¦æ­£ç¡®é‡Šæ”¾ã€‚è¯¥åŠŸèƒ½ä¸€èˆ¬ç”¨äºæ—©æœŸç³»ç»Ÿè°ƒè¯•æˆ–æ‰‹æœºEngç‰ˆï¼Œå¯¹äºUserç‰ˆå¾€å¾€ä¸ä¼šå¼€å¯ï¼Œå¼•ç”¨è¯¥åŠŸèƒ½æ¯”è¾ƒæ¶ˆè€—ç³»ç»ŸCPUèµ„æºï¼Œé™ä½ç³»ç»Ÿæ€§èƒ½ã€‚ bool checkJni = false;property_get(\"dalvik.vm.checkjni\", propBuf, \"\");if (strcmp(propBuf, \"true\") == 0) &#123; checkJni = true;&#125; else if (strcmp(propBuf, \"false\") != 0) &#123; /* property is neither true nor false; fall back on kernel parameter */ property_get(\"ro.kernel.android.checkjni\", propBuf, \"\"); if (propBuf[0] == '1') &#123; checkJni = true; &#125;&#125;ALOGD(\"CheckJNI is %s\\n\", checkJni ? \"ON\" : \"OFF\");if (checkJni) &#123; addOption(\"-Xcheck:jni\")&#125;...... //è™šæ‹Ÿæœºäº§ç”Ÿçš„traceæ–‡ä»¶ï¼Œä¸»è¦ç”¨äºåˆ†æç³»ç»Ÿé—®é¢˜ï¼Œè·¯å¾„é»˜è®¤ä¸º/data/anr/traces.txtparseRuntimeOption(\"dalvik.vm.stack-trace-file\", stackTraceFileBuf, \"-Xstacktracefile:\");//å¯¹äºä¸åŒçš„è½¯ç¡¬ä»¶ç¯å¢ƒï¼Œè¿™äº›å‚æ•°å¾€å¾€éœ€è¦è°ƒæ•´ã€ä¼˜åŒ–ï¼Œä»è€Œä½¿ç³»ç»Ÿè¾¾åˆ°æœ€ä½³æ€§èƒ½parseRuntimeOption(\"dalvik.vm.heapstartsize\", heapstartsizeOptsBuf, \"-Xms\", \"4m\");parseRuntimeOption(\"dalvik.vm.heapsize\", heapsizeOptsBuf, \"-Xmx\", \"16m\");parseRuntimeOption(\"dalvik.vm.heapgrowthlimit\", heapgrowthlimitOptsBuf, \"-XX:HeapGrowthLimit=\");parseRuntimeOption(\"dalvik.vm.heapminfree\", heapminfreeOptsBuf, \"-XX:HeapMinFree=\");parseRuntimeOption(\"dalvik.vm.heapmaxfree\", heapmaxfreeOptsBuf, \"-XX:HeapMaxFree=\");parseRuntimeOption(\"dalvik.vm.heaptargetutilization\", heaptargetutilizationOptsBuf, \"-XX:HeapTargetUtilization=\");...//preloaded-classesæ–‡ä»¶å†…å®¹æ˜¯ç”±WritePreloadedClassFile.javaç”Ÿæˆçš„ï¼Œ//åœ¨ZygoteInitç±»ä¸­ä¼šé¢„åŠ è½½å·¥ä½œå°†å…¶ä¸­çš„classesæå‰åŠ è½½åˆ°å†…å­˜ï¼Œä»¥æé«˜ç³»ç»Ÿæ€§èƒ½if (!hasFile(\"/system/etc/preloaded-classes\")) &#123; return -1;&#125;//åˆå§‹åŒ–è™šæ‹Ÿæœºif (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1;&#125;&#125; åˆ›å»ºJavaè™šæ‹Ÿæœºæ–¹æ³•çš„ä¸»è¦ç¯‡å¹…æ˜¯å…³äºè™šæ‹Ÿæœºå‚æ•°çš„è®¾ç½®ï¼Œä¸‹é¢åªåˆ—ä¸¾éƒ¨åˆ†åœ¨è°ƒè¯•ä¼˜åŒ–è¿‡ç¨‹ä¸­å¸¸ç”¨å‚æ•°ã€‚ 4.2.2.4ã€AndroidRuntime.startReg()1234567891011121314int AndroidRuntime::startReg(JNIEnv* env)&#123; //è®¾ç½®çº¿ç¨‹åˆ›å»ºæ–¹æ³•ä¸ºjavaCreateThreadEtc androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); env-&gt;PushLocalFrame(200); //è¿›ç¨‹NIæ–¹æ³•çš„æ³¨å†Œ if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) &lt; 0) &#123; env-&gt;PopLocalFrame(NULL); return -1; &#125; env-&gt;PopLocalFrame(NULL); return 0;&#125; 4.2.2.4.1ã€Threads.androidSetCreateThreadFunc()[-&gt; Threads.cpp] 1234void androidSetCreateThreadFunc(android_create_thread_fn func)&#123; gCreateThreadFn = func;&#125; è™šæ‹Ÿæœºå¯åŠ¨åstartReg()è¿‡ç¨‹ï¼Œä¼šè®¾ç½®çº¿ç¨‹åˆ›å»ºå‡½æ•°æŒ‡é’ˆgCreateThreadFnæŒ‡å‘javaCreateThreadEtc. 4.2.2.4.2ã€register_jni_procs()123456789static int register_jni_procs(const RegJNIRec array[], size_t count, JNIEnv* env)&#123; for (size_t i = 0; i &lt; count; i++) &#123; if (array[i].mProc(env) &lt; 0) &#123; return -1; &#125; &#125; return 0;&#125; 4.2.2.4.3ã€gRegJNI.mProc12345static const RegJNIRec gRegJNI[] = &#123; REG_JNI(register_com_android_internal_os_RuntimeInit), REG_JNI(register_android_os_Binder)ï¼Œ ...&#125;ï¼›* array[i]æ˜¯æŒ‡gRegJNIæ•°ç»„, è¯¥æ•°ç»„æœ‰100å¤šä¸ªæˆå‘˜ã€‚å…¶ä¸­æ¯ä¸€é¡¹æˆå‘˜éƒ½æ˜¯é€šè¿‡REG_JNIå®å®šä¹‰çš„ï¼š 1234#define REG_JNI(name) &#123; name &#125;struct RegJNIRec &#123; int (*mProc)(JNIEnv*);&#125;; å¯è§ï¼Œè°ƒç”¨mProcï¼Œå°±ç­‰ä»·äºè°ƒç”¨å…¶å‚æ•°åæ‰€æŒ‡å‘çš„å‡½æ•°ã€‚ ä¾‹å¦‚REG_JNI(register_com_android_internal_os_RuntimeInit).mProcä¹Ÿå°±æ˜¯æŒ‡è¿›å…¥register_com_android_internal_os_RuntimeInitæ–¹æ³•ï¼Œæ¥ä¸‹æ¥å°±ç»§ç»­ä»¥æ­¤ä¸ºä¾‹æ¥è¯´æ˜ï¼š 12345int register_com_android_internal_os_RuntimeInit(JNIEnv* env)&#123; return jniRegisterNativeMethods(env, \"com/android/internal/os/RuntimeInit\", gMethods, NELEM(gMethods));&#125; //gMethodsï¼šjavaå±‚æ–¹æ³•åä¸jniå±‚çš„æ–¹æ³•çš„ä¸€ä¸€æ˜ å°„å…³ç³» 12345678static JNINativeMethod gMethods[] = &#123; &#123; \"nativeFinishInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit &#125;, &#123; \"nativeZygoteInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeZygoteInit &#125;, &#123; \"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup &#125;,&#125;; 4.2.2.5ã€è¿›å…¥Javaå±‚AndroidRuntime.start()æ‰§è¡Œåˆ°æœ€åé€šè¿‡åå°„è°ƒç”¨åˆ°ZygoteInit.main(),è§ä¸‹æ–‡: 4.2.2.5.1ã€ZygoteInit.main()12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String argv[]) &#123;try &#123;Init\"); //å¼€å¯DDMSåŠŸèƒ½ RuntimeInit.enableDdms(); SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = \"zygote\"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if (\"start-system-server\".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(\"Unknown command line argument: \" + argv[i]); &#125; &#125; ...... //ä¸ºZygoteæ³¨å†Œsocket registerZygoteSocket(socketName); preload();// é¢„åŠ è½½ç±»å’Œèµ„æº SamplingProfilerIntegration.writeZygoteSnapshot(); gcAndFinalize();//GCæ“ä½œ Zygote.nativeUnmountStorageOnInit(); ZygoteHooks.stopZygoteNoThreadCreation(); if (startSystemServer) &#123;//å¯åŠ¨system_server startSystemServer(abiList, socketName); &#125; runSelectLoop(abiList);//è¿›å…¥å¾ªç¯æ¨¡å¼ closeServerSocket();&#125; catch (MethodAndArgsCaller caller) &#123; caller.run();&#125; catch (Throwable ex) &#123; closeServerSocket(); throw ex;&#125;&#125; åœ¨å¼‚å¸¸æ•è·åè°ƒç”¨çš„æ–¹æ³•caller.run()ï¼Œä¼šåœ¨åç»­çš„system_serveræ–‡ç« ä¼šè®²åˆ°ã€‚ 4.2.2.5.2ã€ZygoteInit.registerZygoteSocket()1234567891011121314151617181920private static void registerZygoteSocket(String socketName) &#123;if (sServerSocket == null) &#123; int fileDesc; final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName; try &#123; String env = System.getenv(fullSocketName); fileDesc = Integer.parseInt(env); &#125; catch (RuntimeException ex) &#123; ... &#125; try &#123; FileDescriptor fd = new FileDescriptor(); fd.setInt$(fileDesc); //è®¾ç½®æ–‡ä»¶æè¿°ç¬¦ sServerSocket = new LocalServerSocket(fd); //åˆ›å»ºSocketçš„æœ¬åœ°æœåŠ¡ç«¯ &#125; catch (IOException ex) &#123; ... &#125;&#125;&#125; 4.2.2.5.2ã€ZygoteInit.preload()1234567891011121314151617181920static void preload() &#123; //é¢„åŠ è½½ä½äº/system/etc/preloaded-classesæ–‡ä»¶ä¸­çš„ç±» preloadClasses(); //é¢„åŠ è½½èµ„æºï¼ŒåŒ…å«drawableå’Œcolorèµ„æº preloadResources(); //é¢„åŠ è½½OpenGL preloadOpenGL(); //é€šè¿‡System.loadLibrary()æ–¹æ³•ï¼Œ //é¢„åŠ è½½\"android\",\"compiler_rt\",\"jnigraphics\"è¿™3ä¸ªå…±äº«åº“ preloadSharedLibraries(); //é¢„åŠ è½½ æ–‡æœ¬è¿æ¥ç¬¦èµ„æº preloadTextResources(); //ä»…ç”¨äºzygoteè¿›ç¨‹ï¼Œç”¨äºå†…å­˜å…±äº«çš„è¿›ç¨‹ WebViewFactory.prepareWebViewInZygote();&#125; æ‰§è¡ŒZygoteè¿›ç¨‹çš„åˆå§‹åŒ–,å¯¹äºç±»åŠ è½½ï¼Œé‡‡ç”¨åå°„æœºåˆ¶Class.forName()æ–¹æ³•æ¥åŠ è½½ã€‚å¯¹äºèµ„æºåŠ è½½ï¼Œä¸»è¦æ˜¯ com.android.internal.R.array.preloaded_drawableså’Œcom.android.internal.R.array.preloaded_color_state_listsï¼Œåœ¨åº”ç”¨ç¨‹åºä¸­ä»¥com.android.internal.R.xxxå¼€å¤´çš„èµ„æºï¼Œä¾¿æ˜¯æ­¤æ—¶ç”±ZygoteåŠ è½½åˆ°å†…å­˜çš„ã€‚ zygoteè¿›ç¨‹å†…åŠ è½½äº†preload()æ–¹æ³•ä¸­çš„æ‰€æœ‰èµ„æºï¼Œå½“éœ€è¦forkæ–°è¿›ç¨‹æ—¶ï¼Œé‡‡ç”¨copy on writeæŠ€æœ¯ï¼Œå¦‚ä¸‹ï¼š 4.2.2.5.3ã€ZygoteInit.startSystemServer()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; long capabilities = posixCapabilitiesAsBits( OsConstants.CAP_BLOCK_SUSPEND, OsConstants.CAP_KILL, OsConstants.CAP_NET_ADMIN, OsConstants.CAP_NET_BIND_SERVICE, OsConstants.CAP_NET_BROADCAST, OsConstants.CAP_NET_RAW, OsConstants.CAP_SYS_MODULE, OsConstants.CAP_SYS_NICE, OsConstants.CAP_SYS_RESOURCE, OsConstants.CAP_SYS_TIME, OsConstants.CAP_SYS_TTY_CONFIG ); //å‚æ•°å‡†å¤‡ String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; //ç”¨äºè§£æå‚æ•°ï¼Œç”Ÿæˆç›®æ ‡æ ¼å¼ parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); // forkå­è¿›ç¨‹ï¼Œç”¨äºè¿è¡Œsystem_server pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; //è¿›å…¥å­è¿›ç¨‹system_server if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // å®Œæˆsystem_serverè¿›ç¨‹å‰©ä½™çš„å·¥ä½œ handleSystemServerProcess(parsedArgs); &#125; return true;&#125; å‡†å¤‡å‚æ•°å¹¶forkæ–°è¿›ç¨‹ï¼Œä»ä¸Šé¢å¯ä»¥çœ‹å‡ºsystem serverè¿›ç¨‹å‚æ•°ä¿¡æ¯ä¸ºuid=1000,gid=1000,è¿›ç¨‹åä¸ºsytem_serverï¼Œä»zygoteè¿›ç¨‹forkæ–°è¿›ç¨‹åï¼Œéœ€è¦å…³é—­zygoteåŸæœ‰çš„socketã€‚å¦å¤–ï¼Œå¯¹äºæœ‰ä¸¤ä¸ªzygoteè¿›ç¨‹æƒ…å†µï¼Œéœ€ç­‰å¾…ç¬¬2ä¸ªzygoteåˆ›å»ºå®Œæˆã€‚ 4.2.2.5.4ã€ZygoteInit.runSelectLoop()1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); //sServerSocketæ˜¯socketé€šä¿¡ä¸­çš„æœåŠ¡ç«¯ï¼Œå³zygoteè¿›ç¨‹ã€‚ä¿å­˜åˆ°fds[0] fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; //å¤„ç†è½®è¯¢çŠ¶æ€ï¼Œå½“pollFdsæœ‰äº‹ä»¶åˆ°æ¥åˆ™å¾€ä¸‹æ‰§è¡Œï¼Œå¦åˆ™é˜»å¡åœ¨è¿™é‡Œ Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; ... &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; //é‡‡ç”¨I/Oå¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œå½“æ¥æ”¶åˆ°å®¢æˆ·ç«¯å‘å‡ºè¿æ¥è¯·æ±‚ æˆ–è€…æ•°æ®å¤„ç†è¯·æ±‚åˆ°æ¥ï¼Œåˆ™å¾€ä¸‹æ‰§è¡Œï¼› // å¦åˆ™è¿›å…¥continueï¼Œè·³å‡ºæœ¬æ¬¡å¾ªç¯ã€‚ if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; //å³fds[0]ï¼Œä»£è¡¨çš„æ˜¯sServerSocketï¼Œåˆ™æ„å‘³ç€æœ‰å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚ï¼› // åˆ™åˆ›å»ºZygoteConnectionå¯¹è±¡,å¹¶æ·»åŠ åˆ°fdsã€‚ ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); //æ·»åŠ åˆ°fds. &#125; else &#123; //i&gt;0ï¼Œåˆ™ä»£è¡¨é€šè¿‡socketæ¥æ”¶æ¥è‡ªå¯¹ç«¯çš„æ•°æ®ï¼Œå¹¶æ‰§è¡Œç›¸åº”æ“ä½œ boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); //å¤„ç†å®Œåˆ™ä»fdsä¸­ç§»é™¤è¯¥æ–‡ä»¶æè¿°ç¬¦ &#125; &#125; &#125; &#125;&#125; Zygoteé‡‡ç”¨é«˜æ•ˆçš„I/Oå¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œä¿è¯åœ¨æ²¡æœ‰å®¢æˆ·ç«¯è¿æ¥è¯·æ±‚æˆ–æ•°æ®å¤„ç†æ—¶ä¼‘çœ ï¼Œå¦åˆ™å“åº”å®¢æˆ·ç«¯çš„è¯·æ±‚ã€‚ 4.2.2.5.4ã€ZygoteConnection.runOnce()123456789101112131415161718192021222324252627282930313233343536373839404142434445boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123;String args[];Arguments parsedArgs = null;FileDescriptor[] descriptors;try &#123; //è¯»å–socketå®¢æˆ·ç«¯å‘é€è¿‡æ¥çš„å‚æ•°åˆ—è¡¨ args = readArgumentList(); descriptors = mSocket.getAncillaryFileDescriptors();&#125; catch (IOException ex) &#123; ... return true;&#125;...try &#123; //å°†binderå®¢æˆ·ç«¯ä¼ é€’è¿‡æ¥çš„å‚æ•°ï¼Œè§£ææˆArgumentså¯¹è±¡æ ¼å¼ parsedArgs = new Arguments(args); ... pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir);&#125; catch (Exception e) &#123; ...&#125;try &#123; if (pid == 0) &#123; //å­è¿›ç¨‹æ‰§è¡Œ IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; //è¿›å…¥å­è¿›ç¨‹æµç¨‹ handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); return true; &#125; else &#123; //çˆ¶è¿›ç¨‹æ‰§è¡Œ IoUtils.closeQuietly(childPipeFd); childPipeFd = null; return handleParentProc(pid, descriptors, serverPipeFd, parsedArgs); &#125;&#125; finally &#123; IoUtils.closeQuietly(childPipeFd); IoUtils.closeQuietly(serverPipeFd);&#125; 4.2.2.6ã€æ€»ç»“Zygoteå¯åŠ¨è¿‡ç¨‹çš„è°ƒç”¨æµç¨‹å›¾ï¼š 1ã€è§£æinit.zygote.rcä¸­çš„å‚æ•°ï¼Œåˆ›å»ºAppRuntimeå¹¶è°ƒç”¨AppRuntime.start()æ–¹æ³•ï¼›2ã€ è°ƒç”¨AndroidRuntimeçš„startVM()æ–¹æ³•åˆ›å»ºè™šæ‹Ÿæœºï¼Œå†è°ƒç”¨startReg()æ³¨å†ŒJNIå‡½æ•°ï¼›3ã€é€šè¿‡JNIæ–¹å¼è°ƒç”¨ZygoteInit.main()ï¼Œç¬¬ä¸€æ¬¡è¿›å…¥Javaä¸–ç•Œï¼›4ã€registerZygoteSocket()å»ºç«‹socketé€šé“ï¼Œzygoteä½œä¸ºé€šä¿¡çš„æœåŠ¡ç«¯ï¼Œç”¨äºå“åº”å®¢æˆ·ç«¯è¯·æ±‚ï¼›5ã€preload()é¢„åŠ è½½é€šç”¨ç±»ã€drawableå’Œcolorèµ„æºã€openGLä»¥åŠå…±äº«åº“ä»¥åŠWebViewï¼Œç”¨äºæé«˜appå¯åŠ¨æ•ˆç‡ï¼›6ã€zygoteå®Œæ¯•å¤§éƒ¨åˆ†å·¥ä½œï¼Œæ¥ä¸‹æ¥å†é€šè¿‡startSystemServer()ï¼Œforkå¾—åŠ›å¸®æ‰‹system_serverè¿›ç¨‹ï¼Œä¹Ÿæ˜¯ä¸Šå±‚frameworkçš„è¿è¡Œè½½ä½“ã€‚7ã€ zygoteåŠŸæˆèº«é€€ï¼Œè°ƒç”¨runSelectLoop()ï¼Œéšæ—¶å¾…å‘½ï¼Œå½“æ¥æ”¶åˆ°è¯·æ±‚åˆ›å»ºæ–°è¿›ç¨‹è¯·æ±‚æ—¶ç«‹å³å”¤é†’å¹¶æ‰§è¡Œç›¸åº”å·¥ä½œã€‚ ï¼ˆ3ï¼‰ã€å¯åŠ¨SystemServerä¸Šç¯‡4.3.1ã€å¯åŠ¨æµç¨‹SystemServerçš„åœ¨Androidä½“ç³»ä¸­æ‰€å¤„çš„åœ°ä½ï¼ŒSystemServerç”±Zygote forkç”Ÿæˆçš„ï¼Œè¿›ç¨‹åä¸ºsystem_serverï¼Œè¯¥è¿›ç¨‹æ‰¿è½½ç€frameworkçš„æ ¸å¿ƒæœåŠ¡ã€‚ Androidç³»ç»Ÿå¯åŠ¨-zygoteç¯‡ä¸­è®²åˆ°Zygoteå¯åŠ¨è¿‡ç¨‹ä¸­ä¼šè°ƒç”¨startSystemServer()ï¼Œå¯çŸ¥startSystemServer()å‡½æ•°æ˜¯system_serverå¯åŠ¨æµç¨‹çš„èµ·ç‚¹ï¼Œ å¯åŠ¨æµç¨‹å›¾å¦‚ä¸‹ï¼š 4.3.2ã€ZygoteInit.startSystemServer()1234567891011121314151617181920212223242526272829303132333435363738394041424344private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; ... //å‚æ•°å‡†å¤‡ String args[] = &#123; \"--setuid=1000\", \"--setgid=1000\", \"--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1032,3001,3002,3003,3006,3007\", \"--capabilities=\" + capabilities + \",\" + capabilities, \"--nice-name=system_server\", \"--runtime-args\", \"com.android.server.SystemServer\", &#125;; ZygoteConnection.Arguments parsedArgs = null; int pid; try &#123; //ç”¨äºè§£æå‚æ•°ï¼Œç”Ÿæˆç›®æ ‡æ ¼å¼ parsedArgs = new ZygoteConnection.Arguments(args); ZygoteConnection.applyDebuggerSystemProperty(parsedArgs); ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs); // forkå­è¿›ç¨‹ï¼Œè¯¥è¿›ç¨‹æ˜¯system_serverè¿›ç¨‹ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); &#125; catch (IllegalArgumentException ex) &#123; throw new RuntimeException(ex); &#125; //è¿›å…¥å­è¿›ç¨‹system_server if (pid == 0) &#123; if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; // å®Œæˆsystem_serverè¿›ç¨‹å‰©ä½™çš„å·¥ä½œ handleSystemServerProcess(parsedArgs); &#125; return true;&#125; å‡†å¤‡å‚æ•°å¹¶forkæ–°è¿›ç¨‹ï¼Œä»ä¸Šé¢å¯ä»¥çœ‹å‡ºsystem serverè¿›ç¨‹å‚æ•°ä¿¡æ¯ä¸ºuid=1000,gid=1000,è¿›ç¨‹åä¸ºsytem_serverï¼Œä»zygoteè¿›ç¨‹forkæ–°è¿›ç¨‹åï¼Œéœ€è¦å…³é—­zygoteåŸæœ‰çš„socketã€‚å¦å¤–ï¼Œå¯¹äºæœ‰ä¸¤ä¸ªzygoteè¿›ç¨‹æƒ…å†µï¼Œéœ€ç­‰å¾…ç¬¬2ä¸ªzygoteåˆ›å»ºå®Œæˆã€‚ 4.3.3ã€Zygote. forkSystemServer()123456789101112public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags, int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) &#123; VM_HOOKS.preFork(); // è°ƒç”¨nativeæ–¹æ³•fork system_serverè¿›ç¨‹ int pid = nativeForkSystemServer( uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities); if (pid == 0) &#123; Trace.setTracingEnabled(true); &#125; VM_HOOKS.postForkCommon(); return pid;&#125; nativeForkSystemServer()æ–¹æ³•åœ¨AndroidRuntime.cppä¸­æ³¨å†Œçš„ï¼Œè°ƒç”¨com_android_internal_os_Zygote.cppä¸­çš„register_com_android_internal_os_Zygote()æ–¹æ³•å»ºç«‹nativeæ–¹æ³•çš„æ˜ å°„å…³ç³»ï¼Œæ‰€ä»¥æ¥ä¸‹æ¥è¿›å…¥å¦‚ä¸‹æ–¹æ³•ã€‚ 4.3.4ã€com_android_internal_os_Zygote.nativeForkSystemServer()123456789101112131415161718192021static jint com_android_internal_os_Zygote_nativeForkSystemServer( JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids, jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities, jlong effectiveCapabilities) &#123; //forkå­è¿›ç¨‹ï¼Œ pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags, rlimits, permittedCapabilities, effectiveCapabilities, MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL, NULL, NULL); if (pid &gt; 0) &#123; // zygoteè¿›ç¨‹ï¼Œæ£€æµ‹system_serverè¿›ç¨‹æ˜¯å¦åˆ›å»º gSystemServerPid = pid; int status; if (waitpid(pid, &amp;status, WNOHANG) == pid) &#123; //å½“system_serverè¿›ç¨‹æ­»äº¡åï¼Œé‡å¯zygoteè¿›ç¨‹ RuntimeAbort(env); &#125; &#125; return pid;&#125; å½“system_serverè¿›ç¨‹åˆ›å»ºå¤±è´¥æ—¶ï¼Œå°†ä¼šé‡å¯zygoteè¿›ç¨‹ã€‚è¿™é‡Œéœ€è¦æ³¨æ„ï¼Œå¯¹äºAndroid 5.0ä»¥ä¸Šç³»ç»Ÿï¼Œæœ‰ä¸¤ä¸ªzygoteè¿›ç¨‹ï¼Œåˆ†åˆ«æ˜¯zygoteã€zygote64ä¸¤ä¸ªè¿›ç¨‹ï¼Œsystem_serverçš„çˆ¶è¿›ç¨‹ï¼Œä¸€èˆ¬æ¥è¯´64ä½ç³»ç»Ÿå…¶çˆ¶è¿›ç¨‹æ˜¯zygote64è¿›ç¨‹ å½“kill system_serverè¿›ç¨‹åï¼Œåªé‡å¯zygote64å’Œsystem_serverï¼Œä¸é‡å¯zygote; å½“kill zygote64è¿›ç¨‹åï¼Œåªé‡å¯zygote64å’Œsystem_serverï¼Œä¹Ÿä¸é‡å¯zygoteï¼› å½“kill zygoteè¿›ç¨‹ï¼Œåˆ™é‡å¯zygoteã€zygote64ä»¥åŠsystem_serverã€‚ 4.3.5ã€com_android_internal_os_Zygote.ForkAndSpecializeCommon()12345678910111213141516171819202122232425262728293031323334353637383940414243444546static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids, jint debug_flags, jobjectArray javaRlimits, jlong permittedCapabilities, jlong effectiveCapabilities, jint mount_external, jstring java_se_info, jstring java_se_name, bool is_system_server, jintArray fdsToClose, jstring instructionSet, jstring dataDir) &#123; SetSigChldHandler(); //è®¾ç½®å­è¿›ç¨‹çš„signalä¿¡å·å¤„ç†å‡½æ•° pid_t pid = fork(); //forkå­è¿›ç¨‹ if (pid == 0) &#123; //è¿›å…¥å­è¿›ç¨‹ DetachDescriptors(env, fdsToClose); //å…³é—­å¹¶æ¸…é™¤æ–‡ä»¶æè¿°ç¬¦ if (!is_system_server) &#123; //å¯¹äºésystem_serverå­è¿›ç¨‹ï¼Œåˆ™åˆ›å»ºè¿›ç¨‹ç»„ int rc = createProcessGroup(uid, getpid()); &#125; SetGids(env, javaGids); //è®¾ç½®è®¾ç½®group SetRLimits(env, javaRlimits); //è®¾ç½®èµ„æºlimit int rc = setresgid(gid, gid, gid); rc = setresuid(uid, uid, uid); SetCapabilities(env, permittedCapabilities, effectiveCapabilities); SetSchedulerPolicy(env); //è®¾ç½®è°ƒåº¦ç­–ç•¥ //selinuxä¸Šä¸‹æ–‡ rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str); if (se_info_c_str == NULL &amp;&amp; is_system_server) &#123; se_name_c_str = \"system_server\"; &#125; if (se_info_c_str != NULL) &#123; SetThreadName(se_name_c_str); //è®¾ç½®çº¿ç¨‹åä¸ºsystem_serverï¼Œæ–¹ä¾¿è°ƒè¯• &#125; UnsetSigChldHandler(); //è®¾ç½®å­è¿›ç¨‹çš„signalä¿¡å·å¤„ç†å‡½æ•°ä¸ºé»˜è®¤å‡½æ•° //ç­‰ä»·äºè°ƒç”¨zygote.callPostForkChildHooks() env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags, is_system_server ? NULL : instructionSet); ... &#125; else if (pid &gt; 0) &#123; //è¿›å…¥çˆ¶è¿›ç¨‹ï¼Œå³zygoteè¿›ç¨‹ &#125; return pid;&#125; fork()åˆ›å»ºæ–°è¿›ç¨‹ï¼Œé‡‡ç”¨copy on writeæ–¹å¼ï¼Œè¿™æ˜¯linuxåˆ›å»ºè¿›ç¨‹çš„æ ‡å‡†æ–¹æ³•ï¼Œä¼šæœ‰ä¸¤æ¬¡return,å¯¹äºpid==0ä¸ºå­è¿›ç¨‹çš„è¿”å›ï¼Œå¯¹äºpid&gt;0ä¸ºçˆ¶è¿›ç¨‹çš„è¿”å›ã€‚ åˆ°æ­¤system_serverè¿›ç¨‹å·²å®Œæˆäº†åˆ›å»ºçš„æ‰€æœ‰å·¥ä½œï¼Œæ¥ä¸‹æ¥å¼€å§‹äº†system_serverè¿›ç¨‹çš„çœŸæ­£å·¥ä½œã€‚åœ¨å‰é¢startSystemServer()æ–¹æ³•ä¸­ï¼Œzygoteè¿›ç¨‹æ‰§è¡Œå®ŒforkSystemServer()åï¼Œæ–°åˆ›å»ºå‡ºæ¥çš„system_serverè¿›ç¨‹ä¾¿è¿›å…¥handleSystemServerProcess()æ–¹æ³•ã€‚ 4.3.5ã€ZygoteInit.handleSystemServerProcess()123456789101112131415161718192021222324252627282930313233343536373839404142434445private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; closeServerSocket(); //å…³é—­çˆ¶è¿›ç¨‹zygoteå¤åˆ¶è€Œæ¥çš„Socket Os.umask(S_IRWXG | S_IRWXO); if (parsedArgs.niceName != null) &#123; Process.setArgV0(parsedArgs.niceName); //è®¾ç½®å½“å‰è¿›ç¨‹åä¸º\"system_server\" &#125; final String systemServerClasspath = Os.getenv(\"SYSTEMSERVERCLASSPATH\"); if (systemServerClasspath != null) &#123; //æ‰§è¡Œdexä¼˜åŒ–æ“ä½œ performSystemServerDexOpt(systemServerClasspath); &#125; if (parsedArgs.invokeWith != null) &#123; String[] args = parsedArgs.remainingArgs; if (systemServerClasspath != null) &#123; String[] amendedArgs = new String[args.length + 2]; amendedArgs[0] = \"-cp\"; amendedArgs[1] = systemServerClasspath; System.arraycopy(parsedArgs.remainingArgs, 0, amendedArgs, 2, parsedArgs.remainingArgs.length); &#125; //å¯åŠ¨åº”ç”¨è¿›ç¨‹ WrapperInit.execApplication(parsedArgs.invokeWith, parsedArgs.niceName, parsedArgs.targetSdkVersion, VMRuntime.getCurrentInstructionSet(), null, args); &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; åˆ›å»ºç±»åŠ è½½å™¨ï¼Œå¹¶èµ‹äºˆå½“å‰çº¿ç¨‹ cl = new PathClassLoader(systemServerClasspath, ClassLoader.getSystemClassLoader()); Thread.currentThread().setContextClassLoader(cl); &#125; //system_serveræ•…è¿›å…¥æ­¤åˆ†æ”¯ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; /* should never reach here */&#125; æ­¤å¤„systemServerClasspathç¯å¢ƒå˜é‡ä¸»è¦æœ‰/system/framework/ç›®å½•ä¸‹çš„services.jarï¼Œethernet-service.jar, wifi-service.jarè¿™3ä¸ªæ–‡ä»¶ 4.3.6ã€ZygoteInit.performSystemServerDexOpt()123456789101112131415161718192021222324private static void performSystemServerDexOpt(String classPath) &#123; final String[] classPathElements = classPath.split(\":\"); //åˆ›å»ºä¸€ä¸ªä¸installdçš„å»ºç«‹socketè¿æ¥ final InstallerConnection installer = new InstallerConnection(); //æ‰§è¡Œpingæ“ä½œï¼Œç›´åˆ°ä¸installdæœåŠ¡ç«¯è¿é€šä¸ºæ­¢ installer.waitForConnection(); final String instructionSet = VMRuntime.getRuntime().vmInstructionSet(); try &#123; for (String classPathElement : classPathElements) &#123; final int dexoptNeeded = DexFile.getDexOptNeeded( classPathElement, \"*\", instructionSet, false /* defer */); if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) &#123; //ä»¥systemæƒé™ï¼Œæ‰§è¡Œdexæ–‡ä»¶ä¼˜åŒ– installer.dexopt(classPathElement, Process.SYSTEM_UID, false, instructionSet, dexoptNeeded); &#125; &#125; &#125; catch (IOException ioe) &#123; throw new RuntimeException(\"Error starting system_server\", ioe); &#125; finally &#123; installer.disconnect(); //æ–­å¼€ä¸installdçš„socketè¿æ¥ &#125;&#125; å°†classPathå­—ç¬¦ä¸²ä¸­çš„apkï¼Œåˆ†åˆ«è¿›è¡Œdexä¼˜åŒ–æ“ä½œã€‚çœŸæ­£æ‰§è¡Œä¼˜åŒ–å·¥ä½œé€šè¿‡socketé€šä¿¡å°†ç›¸åº”çš„å‘½ä»¤å‚æ•°ï¼Œå‘é€ç»™installdæ¥å®Œæˆã€‚ 4.3.7ã€RuntimeInit.zygoteInit()12345678910public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); //é‡å®šå‘logè¾“å‡º commonInit(); // é€šç”¨çš„ä¸€äº›åˆå§‹åŒ– nativeZygoteInit(); // zygoteåˆå§‹åŒ– applicationInit(targetSdkVersion, argv, classLoader); // åº”ç”¨åˆå§‹åŒ–&#125; 4.3.8ã€RuntimeInit.commonInit()123456789101112131415161718192021222324private static final void commonInit() &#123; // è®¾ç½®é»˜è®¤çš„æœªæ•æ‰å¼‚å¸¸å¤„ç†æ–¹æ³• Thread.setDefaultUncaughtExceptionHandler(new UncaughtHandler()); // è®¾ç½®å¸‚åŒºï¼Œä¸­å›½æ—¶åŒºä¸º\"Asia/Shanghai\" TimezoneGetter.setInstance(new TimezoneGetter() &#123; @Override public String getId() &#123; return SystemProperties.get(\"persist.sys.timezone\"); &#125; &#125;); TimeZone.setDefault(null); //é‡ç½®logé…ç½® LogManager.getLogManager().reset(); new AndroidConfig(); // è®¾ç½®é»˜è®¤çš„HTTP User-agentæ ¼å¼,ç”¨äº HttpURLConnectionã€‚ String userAgent = getDefaultUserAgent(); System.setProperty(\"http.agent\", userAgent); // è®¾ç½®socketçš„tagï¼Œç”¨äºç½‘ç»œæµé‡ç»Ÿè®¡ NetworkManagementSocketTagger.install();&#125; é»˜è®¤çš„HTTP User-agentæ ¼å¼ï¼Œä¾‹å¦‚ï¼š â€œDalvik/1.1.0 (Linux; U; Android 6.0.1ï¼›LenovoX3c70 Build/LMY47V)â€. 4.3.9ã€AndroidRuntime.nativeZygoteInit()nativeZygoteInit()æ–¹æ³•åœ¨AndroidRuntime.cppä¸­ï¼Œè¿›è¡Œäº†jniæ˜ å°„ï¼Œå¯¹åº”ä¸‹é¢çš„æ–¹æ³•ã€‚ 12345static void com_android_internal_os_RuntimeInit_nativeZygoteInit(JNIEnv* env, jobject clazz)&#123; //æ­¤å¤„çš„gCurRuntimeä¸ºAppRuntimeï¼Œæ˜¯åœ¨AndroidRuntime.cppä¸­å®šä¹‰çš„ gCurRuntime-&gt;onZygoteInit();&#125; 1234567[â€“&gt;app_main.cpp]virtual void onZygoteInit()&#123; sp&lt;ProcessState&gt; proc = ProcessState::self(); proc-&gt;startThreadPool(); //å¯åŠ¨æ–°binderçº¿ç¨‹&#125; ProcessState::self()æ˜¯å•ä¾‹æ¨¡å¼ï¼Œä¸»è¦å·¥ä½œæ˜¯è°ƒç”¨open()æ‰“å¼€/dev/binderé©±åŠ¨è®¾å¤‡ï¼Œå†åˆ©ç”¨mmap()æ˜ å°„å†…æ ¸çš„åœ°å€ç©ºé—´ï¼Œå°†Binderé©±åŠ¨çš„fdèµ‹å€¼ProcessStateå¯¹è±¡ä¸­çš„å˜é‡mDriverFDï¼Œç”¨äºäº¤äº’æ“ä½œã€‚startThreadPool()æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„binderçº¿ç¨‹ï¼Œä¸æ–­è¿›è¡ŒtalkWithDriver()ï¼Œåœ¨binderç³»åˆ—æ–‡ç« ä¸­çš„æ³¨å†ŒæœåŠ¡(addService)è¯¦ç»†è¿™ä¸¤ä¸ªæ–¹æ³•çš„æ‰§è¡ŒåŸç†ã€‚ 4.3.10ã€RuntimeInit.applicationInit()123456789101112131415161718192021private static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; //trueä»£è¡¨åº”ç”¨ç¨‹åºé€€å‡ºæ—¶ä¸è°ƒç”¨AppRuntime.onExit()ï¼Œå¦åˆ™ä¼šåœ¨é€€å‡ºå‰è°ƒç”¨ nativeSetExitWithoutCleanup(true); //è®¾ç½®è™šæ‹Ÿæœºçš„å†…å­˜åˆ©ç”¨ç‡å‚æ•°å€¼ä¸º0.75 VMRuntime.getRuntime().setTargetHeapUtilization(0.75f); VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion); final Arguments args; try &#123; args = new Arguments(argv); //è§£æå‚æ•° &#125; catch (IllegalArgumentException ex) &#123; return; &#125; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //è°ƒç”¨startClassçš„staticæ–¹æ³• main() invokeStaticMain(args.startClass, args.startArgs, classLoader);&#125; åœ¨startSystemServer()æ–¹æ³•ä¸­é€šè¿‡ç¡¬ç¼–ç åˆå§‹åŒ–å‚æ•°ï¼Œå¯çŸ¥æ­¤å¤„args.startClassä¸ºâ€com.android.server.SystemServerâ€ã€‚ 4.3.11ã€RuntimeInit.invokeStaticMain()12345678910111213141516171819202122private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; Class&lt;?&gt; cl = Class.forName(className, true, classLoader); ... Method m; try &#123; m = cl.getMethod(\"main\", new Class[] &#123; String[].class &#125;); &#125; catch (NoSuchMethodException ex) &#123; ... &#125; catch (SecurityException ex) &#123; ... &#125; int modifiers = m.getModifiers(); if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123; ... &#125; //é€šè¿‡æŠ›å‡ºå¼‚å¸¸ï¼Œå›åˆ°ZygoteInit.main()ã€‚è¿™æ ·åšå¥½å¤„æ˜¯èƒ½æ¸…ç©ºæ ˆå¸§ï¼Œæé«˜æ ˆå¸§åˆ©ç”¨ç‡ã€‚ throw new ZygoteInit.MethodAndArgsCaller(m, argv);&#125; 4.3.12ã€MethodAndArgsCaller.run()åœ¨Zygoteä¸­é—ç•™äº†ä¸€ä¸ªé—®é¢˜æ²¡æœ‰è®²è§£ï¼Œå¦‚ä¸‹ï¼š [â€“&gt;ZygoteInit.java] 1234567891011public static void main(String argv[]) &#123; try &#123; startSystemServer(abiList, socketName);//å¯åŠ¨system_server .... &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); &#125; catch (RuntimeException ex) &#123; closeServerSocket(); throw ex; &#125;&#125; ç°åœ¨å·²ç»å¾ˆæ˜æ˜¾äº†ï¼Œæ˜¯invokeStaticMain()æ–¹æ³•ä¸­æŠ›å‡ºçš„å¼‚å¸¸MethodAndArgsCallerï¼Œä»è€Œè¿›å…¥caller.run()æ–¹æ³•ã€‚ [â€“&gt;ZygoteInit.java] 1234567891011121314151617181920public static class MethodAndArgsCaller extends Exception implements Runnable &#123; public void run() &#123; try &#123; //æ ¹æ®ä¼ é€’è¿‡æ¥çš„å‚æ•°ï¼Œå¯çŸ¥æ­¤å¤„é€šè¿‡åå°„æœºåˆ¶è°ƒç”¨çš„æ˜¯SystemServer.main()æ–¹æ³• mMethod.invoke(null, new Object[] &#123; mArgs &#125;); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException(ex); &#125; catch (InvocationTargetException ex) &#123; Throwable cause = ex.getCause(); if (cause instanceof RuntimeException) &#123; throw (RuntimeException) cause; &#125; else if (cause instanceof Error) &#123; throw (Error) cause; &#125; throw new RuntimeException(ex); &#125; &#125;&#125; åˆ°æ­¤ï¼Œæ€»ç®—æ˜¯è¿›å…¥åˆ°äº†SystemServerç±»çš„main()æ–¹æ³•ï¼Œ åœ¨æ–‡ç« Androidç³»ç»Ÿå¯åŠ¨-SystemServerä¸‹ç¯‡ä¸­ä¼šç´§æ¥ç€è¿™é‡Œå¼€å§‹è®²è¿°ã€‚ ï¼ˆ4ï¼‰ã€å¯åŠ¨SystemServerä¸‹ç¯‡ä¸Šç¯‡æ–‡ç« Androidç³»ç»Ÿå¯åŠ¨-systemServerä¸Šç¯‡ ä»Zygoteä¸€è·¯å¯åŠ¨åˆ°SystemServerçš„è¿‡ç¨‹ã€‚ ç®€å•å›é¡¾ä¸‹ï¼Œåœ¨RuntimeInit.javaä¸­invokeStaticMainæ–¹æ³•é€šè¿‡åˆ›å»ºå¹¶æŠ›å‡ºå¼‚å¸¸ZygoteInit.MethodAndArgsCallerï¼Œåœ¨ZygoteInit.javaä¸­çš„main()æ–¹æ³•ä¼šæ•æ‰è¯¥å¼‚å¸¸ï¼Œå¹¶è°ƒç”¨caller.run()ï¼Œå†é€šè¿‡åå°„ä¾¿ä¼šè°ƒç”¨åˆ°SystemServer.main()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦æ‰§è¡Œæµç¨‹ï¼š 1234567SystemServer.main SystemServer.run createSystemContext startBootstrapServices(); startCoreServices(); startOtherServices(); Looper.loop(); æ¥ä¸‹æ¥ï¼Œä»å…¶mainæ–¹æ³•è¯´èµ·ã€‚ 4.4.1ã€SystemServer.main()1234567public final class SystemServer &#123; ... public static void main(String[] args) &#123; //å…ˆåˆå§‹åŒ–SystemServerå¯¹è±¡ï¼Œå†è°ƒç”¨å¯¹è±¡çš„run()æ–¹æ³• new SystemServer().run(); &#125;&#125; 4.4.2ã€SystemServer.run()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private void run() &#123; //å½“ç³»ç»Ÿæ—¶é—´æ¯”1970å¹´æ›´æ—©ï¼Œå°±è®¾ç½®å½“å‰ç³»ç»Ÿæ—¶é—´ä¸º1970å¹´ if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) &#123; SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); &#125; //å˜æ›´è™šæ‹Ÿæœºçš„åº“æ–‡ä»¶ï¼Œå¯¹äºAndroid 6.0é»˜è®¤é‡‡ç”¨çš„æ˜¯libart.so SystemProperties.set(\"persist.sys.dalvik.vm.lib.2\", VMRuntime.getRuntime().vmLibrary()); if (SamplingProfilerIntegration.isEnabled()) &#123; ... &#125; //æ¸…é™¤vmå†…å­˜å¢é•¿ä¸Šé™ï¼Œç”±äºå¯åŠ¨è¿‡ç¨‹éœ€è¦è¾ƒå¤šçš„è™šæ‹Ÿæœºå†…å­˜ç©ºé—´ VMRuntime.getRuntime().clearGrowthLimit(); //è®¾ç½®å†…å­˜çš„å¯èƒ½æœ‰æ•ˆä½¿ç”¨ç‡ä¸º0.8 VMRuntime.getRuntime().setTargetHeapUtilization(0.8f); // é’ˆå¯¹éƒ¨åˆ†è®¾å¤‡ä¾èµ–äºè¿è¡Œæ—¶å°±äº§ç”ŸæŒ‡çº¹ä¿¡æ¯ï¼Œå› æ­¤éœ€è¦åœ¨å¼€æœºå®Œæˆå‰å·²ç»å®šä¹‰ Build.ensureFingerprintProperty(); //è®¿é—®ç¯å¢ƒå˜é‡å‰ï¼Œéœ€è¦æ˜ç¡®åœ°æŒ‡å®šç”¨æˆ· Environment.setUserRequired(true); //ç¡®ä¿å½“å‰ç³»ç»Ÿè¿›ç¨‹çš„binderè°ƒç”¨ï¼Œæ€»æ˜¯è¿è¡Œåœ¨å‰å°ä¼˜å…ˆçº§(foreground priority) BinderInternal.disableBackgroundScheduling(true); android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); // ä¸»çº¿ç¨‹looperå°±åœ¨å½“å‰çº¿ç¨‹è¿è¡Œ Looper.prepareMainLooper(); //åŠ è½½android_servers.soåº“ï¼Œè¯¥åº“åŒ…å«çš„æºç åœ¨frameworks/base/services/ç›®å½•ä¸‹ System.loadLibrary(\"android_servers\"); //æ£€æµ‹ä¸Šæ¬¡å…³æœºè¿‡ç¨‹æ˜¯å¦å¤±è´¥ï¼Œè¯¥æ–¹æ³•å¯èƒ½ä¸ä¼šè¿”å› performPendingShutdown(); //åˆå§‹åŒ–ç³»ç»Ÿä¸Šä¸‹æ–‡ createSystemContext(); //åˆ›å»ºç³»ç»ŸæœåŠ¡ç®¡ç† mSystemServiceManager = new SystemServiceManager(mSystemContext); //å°†mSystemServiceManageræ·»åŠ åˆ°æœ¬åœ°æœåŠ¡çš„æˆå‘˜sLocalServiceObjects LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); //å¯åŠ¨å„ç§ç³»ç»ŸæœåŠ¡ try &#123; startBootstrapServices(); // å¯åŠ¨å¼•å¯¼æœåŠ¡ startCoreServices(); // å¯åŠ¨æ ¸å¿ƒæœåŠ¡ startOtherServices(); // å¯åŠ¨å…¶ä»–æœåŠ¡ &#125; catch (Throwable ex) &#123; Slog.e(\"System\", \"************ Failure starting system services\", ex); throw ex; &#125; //ç”¨äºdebugç‰ˆæœ¬ï¼Œå°†logäº‹ä»¶ä¸æ–­å¾ªç¯åœ°è¾“å‡ºåˆ°dropboxï¼ˆç”¨äºåˆ†æï¼‰ if (StrictMode.conditionallyEnableDebugLogging()) &#123; Slog.i(TAG, \"Enabled StrictMode for system server main thread.\"); &#125; //ä¸€ç›´å¾ªç¯æ‰§è¡Œ Looper.loop(); throw new RuntimeException(\"Main thread loop unexpectedly exited\");&#125; LocalServicesé€šè¿‡ç”¨é™æ€Mapå˜é‡sLocalServiceObjectsï¼Œæ¥ä¿å­˜ä»¥æœåŠ¡ç±»åä¸ºkeyï¼Œä»¥å…·ä½“æœåŠ¡å¯¹è±¡ä¸ºvalueçš„Mapç»“æ„ã€‚ 4.4.3ã€SystemServer.performPendingShutdown()12345678910111213141516private void performPendingShutdown() &#123; final String shutdownAction = SystemProperties.get( ShutdownThread.SHUTDOWN_ACTION_PROPERTY, \"\"); if (shutdownAction != null &amp;&amp; shutdownAction.length() &gt; 0) &#123; boolean reboot = (shutdownAction.charAt(0) == '1'); final String reason; if (shutdownAction.length() &gt; 1) &#123; reason = shutdownAction.substring(1, shutdownAction.length()); &#125; else &#123; reason = null; &#125; // å½“\"sys.shutdown.requested\"å€¼ä¸ä¸ºç©º,åˆ™ä¼šé‡å¯æˆ–è€…å…³æœº ShutdownThread.rebootOrShutdown(null, reboot, reason); &#125;&#125; 4.4.4ã€SystemServer.createSystemContext()1234567private void createSystemContext() &#123; //åˆ›å»ºsystem_serverè¿›ç¨‹çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ ActivityThread activityThread = ActivityThread.systemMain(); mSystemContext = activityThread.getSystemContext(); //è®¾ç½®ä¸»é¢˜ mSystemContext.setTheme(android.R.style.Theme_DeviceDefault_Light_DarkActionBar);&#125; ç†è§£Applicationåˆ›å»ºè¿‡ç¨‹å·²ä»‹ç»è¿‡createSystemContext()è¿‡ç¨‹ï¼Œ è¯¥è¿‡ç¨‹ä¼šåˆ›å»ºå¯¹è±¡æœ‰ActivityThreadï¼ŒInstrumentation, ContextImplï¼ŒLoadedApkï¼ŒApplicationã€‚ 4.4.5ã€SystemServer.startBootstrapServices()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void startBootstrapServices() &#123; //é˜»å¡ç­‰å¾…ä¸installdå»ºç«‹socketé€šé“ Installer installer = mSystemServiceManager.startService(Installer.class); //å¯åŠ¨æœåŠ¡ActivityManagerService mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); //å¯åŠ¨æœåŠ¡PowerManagerService mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); //åˆå§‹åŒ–power management mActivityManagerService.initPowerManagement(); //å¯åŠ¨æœåŠ¡LightsService mSystemServiceManager.startService(LightsService.class); //å¯åŠ¨æœåŠ¡DisplayManagerService mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); //Phase100: åœ¨åˆå§‹åŒ–package managerä¹‹å‰ï¼Œéœ€è¦é»˜è®¤çš„æ˜¾ç¤º. mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); //å½“è®¾å¤‡æ­£åœ¨åŠ å¯†æ—¶ï¼Œä»…è¿è¡Œæ ¸å¿ƒ String cryptState = SystemProperties.get(\"vold.decrypt\"); if (ENCRYPTING_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; else if (ENCRYPTED_STATE.equals(cryptState)) &#123; mOnlyCore = true; &#125; //å¯åŠ¨æœåŠ¡PackageManagerService mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); //å¯åŠ¨æœåŠ¡UserManagerServiceï¼Œæ–°å»ºç›®å½•/data/user/ ServiceManager.addService(Context.USER_SERVICE, UserManagerService.getInstance()); AttributeCache.init(mSystemContext); //è®¾ç½®AMS mActivityManagerService.setSystemProcess(); //å¯åŠ¨ä¼ æ„Ÿå™¨æœåŠ¡ startSensorService();&#125; è¯¥æ–¹æ³•æ‰€åˆ›å»ºçš„æœåŠ¡ï¼šActivityManagerService, PowerManagerService, LightsService, DisplayManagerServiceï¼Œ PackageManagerServiceï¼Œ UserManagerServiceï¼Œ sensoræœåŠ¡. 4.4.5ã€SystemServer.startCoreServices()1234567891011121314private void startCoreServices() &#123; //å¯åŠ¨æœåŠ¡BatteryServiceï¼Œç”¨äºç»Ÿè®¡ç”µæ± ç”µé‡ï¼Œéœ€è¦LightService. mSystemServiceManager.startService(BatteryService.class); //å¯åŠ¨æœåŠ¡UsageStatsServiceï¼Œç”¨äºç»Ÿè®¡åº”ç”¨ä½¿ç”¨æƒ…å†µ mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); mPackageManagerService.getUsageStatsIfNoPackageUsageInfo(); //å¯åŠ¨æœåŠ¡WebViewUpdateService mSystemServiceManager.startService(WebViewUpdateService.class);&#125; å¯åŠ¨æœåŠ¡BatteryServiceï¼ŒUsageStatsServiceï¼ŒWebViewUpdateServiceã€‚ 4.4.6 SystemServer.startOtherServices()è¯¥æ–¹æ³•æ¯”è¾ƒé•¿ï¼Œæœ‰è¿‘åƒè¡Œä»£ç ï¼Œé€»è¾‘å¾ˆç®€å•ï¼Œä¸»è¦æ˜¯å¯åŠ¨ä¸€ç³»åˆ—çš„æœåŠ¡ï¼Œè¿™é‡Œå°±ä¸å…·ä½“åˆ—ä¸¾æºç äº†ï¼Œåœ¨ç¬¬å››èŠ‚ç›´æ¥å¯¹å…¶ä¸­çš„æœåŠ¡è¿›è¡Œä¸€ä¸ªç®€å•åˆ†ç±»ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142private void startOtherServices() &#123; ... SystemConfig.getInstance(); mContentResolver = context.getContentResolver(); // resolver ... mActivityManagerService.installSystemProviders(); //provider mSystemServiceManager.startService(AlarmManagerService.class); // alarm // watchdog watchdog.init(context, mActivityManagerService); inputManager = new InputManagerService(context); // input wm = WindowManagerService.main(...); // window inputManager.start(); //å¯åŠ¨input mDisplayManagerService.windowManagerAndInputReady(); ... mSystemServiceManager.startService(MOUNT_SERVICE_CLASS); // mount mPackageManagerService.performBootDexOpt(); // dexoptæ“ä½œ ActivityManagerNative.getDefault().showBootMessage(...); //æ˜¾ç¤ºå¯åŠ¨ç•Œé¢ ... statusBar = new StatusBarManagerService(context, wm); //statusBar //dropbox ServiceManager.addService(Context.DROPBOX_SERVICE, new DropBoxManagerService(context, new File(\"/data/system/dropbox\"))); mSystemServiceManager.startService(JobSchedulerService.class); //JobScheduler lockSettings.systemReady(); //lockSettings //phase480 å’Œphase500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... // å‡†å¤‡å¥½window, power, package, displayæœåŠ¡ wm.systemReady(); mPowerManagerService.systemReady(...); mPackageManagerService.systemReady(); mDisplayManagerService.systemReady(...); //é‡å¤´æˆ mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; ... &#125; &#125;); &#125; 4.4.7ã€æœåŠ¡å¯åŠ¨é˜¶æ®µSystemServiceManagerçš„startBootPhase()è´¯ç©¿system_serverè¿›ç¨‹çš„æ•´ä¸ªå¯åŠ¨è¿‡ç¨‹ï¼š å…¶ä¸­PHASE_BOOT_COMPLETED=1000ï¼Œè¯¥é˜¶æ®µæ˜¯å‘ç”Ÿåœ¨Bootå®Œæˆå’Œhomeåº”ç”¨å¯åŠ¨å®Œæ¯•ã€‚ç³»ç»ŸæœåŠ¡æ›´å€¾å‘äºç›‘å¬è¯¥é˜¶æ®µï¼Œè€Œä¸æ˜¯æ³¨å†Œå¹¿æ’­ACTION_BOOT_COMPLETEDï¼Œä»è€Œé™ä½ç³»ç»Ÿå»¶è¿Ÿã€‚ å„ä¸ªå¯åŠ¨é˜¶æ®µæ‰€åœ¨æºç çš„å¤§è‡´ä½ç½®ï¼š 123456789101112131415161718192021222324252627282930313233public final class SystemServer &#123;private void startBootstrapServices() &#123; ... //phase100 mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); ...&#125;private void startCoreServices() &#123; ...&#125;private void startOtherServices() &#123; ... //phase480 &amp;&amp; 500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; //phase550 mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //phase600 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); &#125; &#125;&#125;&#125; æ¥ä¸‹æ¥å†è¯´è¯´ç®€å•æ¯ä¸ªé˜¶æ®µçš„å¤§æ¦‚å®Œæˆçš„å·¥ä½œï¼š 4.4.7.1ã€Phase0åˆ›å»ºå››å¤§å¼•å¯¼æœåŠ¡: 1234ActivityManagerServicePowerManagerServiceLightsServiceDisplayManagerService 4.4.7.1.2ã€Phase100è¿›å…¥é˜¶æ®µPHASE_WAIT_FOR_DEFAULT_DISPLAY=100å›è°ƒæœåŠ¡ 123onBootPhase(100)DisplayManagerService ç„¶ååˆ›å»ºå¤§é‡æœåŠ¡ä¸‹é¢åˆ—ä¸¾éƒ¨åˆ†: 12345678PackageManagerServiceWindowManagerServiceInputManagerServiceNetworkManagerServiceDropBoxManagerServiceFingerprintServiceLauncherAppsServiceâ€¦ 4.4.7.1.3ã€Phase480è¿›å…¥é˜¶æ®µPHASE_LOCK_SETTINGS_READY=480å›è°ƒæœåŠ¡ 123onBootPhase(480)DevicePolicyManagerService é˜¶æ®µ480åé©¬ä¸Šå°±è¿›å…¥é˜¶æ®µ500. 4.4.7.1.4ã€Phase500PHASE_SYSTEM_SERVICES_READY=500ï¼Œè¿›å…¥è¯¥é˜¶æ®µæœåŠ¡èƒ½å®‰å…¨åœ°è°ƒç”¨æ ¸å¿ƒç³»ç»ŸæœåŠ¡. 1234567891011121314151617onBootPhase(500)AlarmManagerServiceJobSchedulerServiceNotificationManagerServiceBackupManagerServiceUsageStatsServiceDeviceIdleControllerTrustManagerServiceUiModeManagerServiceBluetoothServiceBluetoothManagerServiceEthernetServiceWifiP2pServiceWifiScanningServiceWifiServiceRttService å„å¤§æœåŠ¡æ‰§è¡ŒsystemReady(): 1234WindowManagerService.systemReady():PowerManagerService.systemReady():PackageManagerService.systemReady():DisplayManagerService.systemReady(): æ¥ä¸‹æ¥å°±ç»ªAMS.systemReadyæ–¹æ³•. 4.4.7.1.5ã€Phase550PHASE_ACTIVITY_MANAGER_READY=550ï¼Œ AMS.mSystemReady=true, å·²å‡†å¤‡å°±ç»ª,è¿›å…¥è¯¥é˜¶æ®µæœåŠ¡èƒ½å¹¿æ’­Intent;ä½†æ˜¯system_serverä¸»çº¿ç¨‹å¹¶æ²¡æœ‰å°±ç»ª. 12345678onBootPhase(550)MountServiceTelecomLoaderServiceUsbServiceWebViewUpdateServiceDockObserverBatteryService æ¥ä¸‹æ¥æ‰§è¡Œ: (AMSå¯åŠ¨native crashç›‘æ§, åŠ è½½WebViewï¼Œå¯åŠ¨SystemUIç­‰),å¦‚ä¸‹ 12345678910mActivityManagerService.startObservingNativeCrashes();WebViewFactory.prepareWebViewInSystemServer();startSystemUi(context);networkScoreF.systemReady();networkManagementF.systemReady();networkStatsF.systemReady();networkPolicyF.systemReady();connectivityF.systemReady();audioServiceF.systemReady();Watchdog.getInstance().start(); 4.4.7.1.6ã€Phase600PHASE_THIRD_PARTY_APPS_CAN_START=600 onBootPhase(600) JobSchedulerServiceNotificationManagerServiceBackupManagerServiceAppWidgetServiceGestureLauncherServiceDreamManagerServiceTrustManagerServiceVoiceInteractionManagerService æ¥ä¸‹æ¥,å„ç§æœåŠ¡çš„systemRunningè¿‡ç¨‹: WallpaperManagerServiceã€InputMethodManagerServiceã€LocationManagerServiceã€CountryDetectorServiceã€NetworkTimeUpdateServiceã€CommonTimeManagementServiceã€TextServicesManagerServiceã€AssetAtlasServiceã€InputManagerServiceã€TelephonyRegistryã€MediaRouterServiceã€MmsServiceBrokerè¿™äº›æœåŠ¡ä¾æ¬¡æ‰§è¡Œå…¶systemRunning()æ–¹æ³•ã€‚ 4.4.7.1.7ã€Phase1000åœ¨ç»è¿‡ä¸€ç³»åˆ—æµç¨‹ï¼Œå†è°ƒç”¨AMS.finishBooting()æ—¶ï¼Œåˆ™è¿›å…¥é˜¶æ®µPhase1000ã€‚ åˆ°æ­¤ï¼Œç³»ç»ŸæœåŠ¡å¯åŠ¨é˜¶æ®µå®Œæˆå°±ç»ªï¼Œsystem_serverè¿›ç¨‹å¯åŠ¨å®Œæˆåˆ™è¿›å…¥Looper.loop()çŠ¶æ€ï¼Œéšæ—¶å¾…å‘½ï¼Œç­‰å¾…æ¶ˆæ¯é˜Ÿåˆ—MessageQueueä¸­çš„æ¶ˆæ¯åˆ°æ¥ï¼Œåˆ™é©¬ä¸Šè¿›å…¥æ‰§è¡ŒçŠ¶æ€ã€‚ 4.4.8ã€æœåŠ¡ç±»åˆ«system_serverè¿›ç¨‹ï¼Œä»æºç è§’åº¦åˆ’åˆ†ä¸ºå¼•å¯¼æœåŠ¡ã€æ ¸å¿ƒæœåŠ¡ã€å…¶ä»–æœåŠ¡3ç±»ã€‚ ä»¥ä¸‹è¿™äº›ç³»ç»ŸæœåŠ¡çš„æ³¨å†Œè¿‡ç¨‹, è§Androidç³»ç»ŸæœåŠ¡çš„æ³¨å†Œæ–¹å¼ å¼•å¯¼æœåŠ¡(7ä¸ª)ï¼šActivityManagerServiceã€PowerManagerServiceã€LightsServiceã€DisplayManagerServiceã€PackageManagerServiceã€UserManagerServiceã€SensorServiceï¼› æ ¸å¿ƒæœåŠ¡(3ä¸ª)ï¼šBatteryServiceã€UsageStatsServiceã€WebViewUpdateServiceï¼› å…¶ä»–æœåŠ¡(70ä¸ª+)ï¼šAlarmManagerServiceã€VibratorServiceç­‰ã€‚ åˆè®¡æ€»å¤§çº¦80ä¸ªç³»ç»ŸæœåŠ¡ï¼š ActivityManagerService PackageManagerService WindowManagerService PowerManagerService BatteryService BatteryStatsService DreamManagerService DropBoxManagerService SamplingProfilerService UsageStatsService DiskStatsService DeviceStorageMonitorService SchedulingPolicyService AlarmManagerService DeviceIdleController ThermalObserver JobSchedulerService AccessibilityManagerService DisplayManagerService LightsService GraphicsStatsService StatusBarManagerService NotificationManagerService WallpaperManagerService UiModeManagerService AppWidgetService LauncherAppsService TextServicesManagerService ContentService LockSettingsService InputMethodManagerService InputManagerService MountService FingerprintService TvInputManagerService DockObserver NetworkManagementService NetworkScoreService NetworkStatsService NetworkPolicyManagerService ConnectivityService BluetoothService WifiP2pService WifiService WifiScanningService AudioService MediaRouterService VoiceInteractionManagerService MediaProjectionManagerService MediaSessionServiceDevicePolicyManagerService PrintManagerService BackupManagerService UserManagerService AccountManagerService TrustManagerService SensorService LocationManagerService VibratorService CountryDetectorService GestureLauncherService PersistentDataBlockService EthernetService WebViewUpdateService ClipboardService TelephonyRegistry TelecomLoaderService NsdService UpdateLockService SerialService SearchManagerService CommonTimeManagementService AssetAtlasService ConsumerIrService MidiServiceCameraService TwilightService RestrictionsManagerService MmsServiceBroker RttService UsbService Serviceç±»åˆ«ä¼—å¤šï¼Œå…¶ä¸­è¡¨ä¸­åŠ ç²—é¡¹æ˜¯æŒ‡åšä¸»æŒ‘é€‰çš„è¾ƒé‡è¦æˆ–è€…è¾ƒå¸¸è§çš„Serviceï¼Œå¹¶ä¸”åœ¨æœ¬åšå®¢ä¸­å·²ç»å±•å¼€æˆ–è€…è®¡åˆ’å±•å¼€è®²è§£çš„Serviceï¼Œå½“ç„¶å¦‚æœæœ‰ç²¾åŠ›ä¼šè®²è§£æ›´å¤šserviceï¼Œåç»­å†æ›´æ–°ã€‚ ï¼ˆ5ï¼‰ã€å¯åŠ¨ActivityManagerService4.5.1ã€æ¦‚è¿°ActivityManagerService(AMS)æ˜¯Androidä¸­æœ€æ ¸å¿ƒçš„æœåŠ¡ï¼Œä¸»è¦è´Ÿè´£ç³»ç»Ÿä¸­å››å¤§ç»„ä»¶çš„å¯åŠ¨ã€åˆ‡æ¢ã€è°ƒåº¦åŠåº”ç”¨ç¨‹åºçš„ç®¡ç†å’Œè°ƒåº¦ç­‰å·¥ä½œã€‚ AMSé€šä¿¡ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š 4.5.2ã€SystemServer.startBootstrapServices()1234567891011121314151617private void startBootstrapServices() &#123;...//å¯åŠ¨AMSæœåŠ¡mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService();//è®¾ç½®AMSçš„ç³»ç»ŸæœåŠ¡ç®¡ç†å™¨mActivityManagerService.setSystemServiceManager(mSystemServiceManager);//è®¾ç½®AMSçš„APPå®‰è£…å™¨mActivityManagerService.setInstaller(installer);//åˆå§‹åŒ–AMSç›¸å…³çš„PMSmActivityManagerService.initPowerManagement();...//è®¾ç½®SystemServermActivityManagerService.setSystemProcess();&#125; 4.5.3ã€å¯åŠ¨AMSæœåŠ¡SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) åŠŸèƒ½ä¸»è¦ï¼š åˆ›å»ºActivityManagerService.Lifecycleå¯¹è±¡ï¼› è°ƒç”¨Lifecycle.onStart()æ–¹æ³•ã€‚ 4.5.4ã€å¯åŠ¨AMSæœåŠ¡4.5.4.1 AMS.Lifecycle [-&gt; ActivityManagerService.java] 123456789101112131415161718public static final class Lifecycle extends SystemService &#123;private final ActivityManagerService mService;public Lifecycle(Context context) &#123; super(context); //åˆ›å»ºActivityManagerService mService = new ActivityManagerService(context);&#125;@Overridepublic void onStart() &#123; mService.start(); &#125;public ActivityManagerService getService() &#123; return mService;&#125;&#125; è¯¥è¿‡ç¨‹ï¼šåˆ›å»ºAMSå†…éƒ¨ç±»çš„Lifecycleï¼Œå·²ç»åˆ›å»ºAMSå¯¹è±¡ï¼Œå¹¶è°ƒç”¨AMS.start(); 4.5.4.2 AMSåˆ›å»º 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public ActivityManagerService(Context systemContext) &#123;mContext = systemContext;mFactoryTest = FactoryTest.getMode();//é»˜è®¤ä¸ºFACTORY_TEST_OFFmSystemThread = ActivityThread.currentActivityThread();//åˆ›å»ºåä¸º\"ActivityManager\"çš„å‰å°çº¿ç¨‹ï¼Œå¹¶è·å–mHandlermHandlerThread = new ServiceThread(TAG, android.os.Process.THREAD_PRIORITY_FOREGROUND, false);mHandlerThread.start();mHandler = new MainHandler(mHandlerThread.getLooper());//é€šè¿‡UiThreadç±»ï¼Œåˆ›å»ºåä¸º\"android.ui\"çš„çº¿ç¨‹mUiHandler = new UiHandler();//å‰å°å¹¿æ’­æ¥æ”¶å™¨ï¼Œåœ¨è¿è¡Œè¶…è¿‡10så°†æ”¾å¼ƒæ‰§è¡ŒmFgBroadcastQueue = new BroadcastQueue(this, mHandler, \"foreground\", BROADCAST_FG_TIMEOUT, false);//åå°å¹¿æ’­æ¥æ”¶å™¨ï¼Œåœ¨è¿è¡Œè¶…è¿‡60så°†æ”¾å¼ƒæ‰§è¡ŒmBgBroadcastQueue = new BroadcastQueue(this, mHandler, \"background\", BROADCAST_BG_TIMEOUT, true);mBroadcastQueues[0] = mFgBroadcastQueue;mBroadcastQueues[1] = mBgBroadcastQueue;//åˆ›å»ºActiveServicesï¼Œå…¶ä¸­éä½å†…å­˜æ‰‹æœºmMaxStartingBackgroundä¸º8mServices = new ActiveServices(this);mProviderMap = new ProviderMap(this);//åˆ›å»ºç›®å½•/data/systemFile dataDir = Environment.getDataDirectory();File systemDir = new File(dataDir, \"system\");systemDir.mkdirs();//åˆ›å»ºæœåŠ¡BatteryStatsServicemBatteryStatsService = new BatteryStatsService(systemDir, mHandler);mBatteryStatsService.getActiveStatistics().readLocked();...//åˆ›å»ºè¿›ç¨‹ç»Ÿè®¡æœåŠ¡ï¼Œä¿¡æ¯ä¿å­˜åœ¨ç›®å½•/data/system/procstatsï¼ŒmProcessStats = new ProcessStatsService(this, new File(systemDir, \"procstats\"));mAppOpsService = new AppOpsService(new File(systemDir, \"appops.xml\"), mHandler);mGrantFile = new AtomicFile(new File(systemDir, \"urigrants.xml\"));// User 0æ˜¯ç¬¬ä¸€ä¸ªï¼Œä¹Ÿæ˜¯å”¯ä¸€çš„ä¸€ä¸ªå¼€æœºè¿‡ç¨‹ä¸­è¿è¡Œçš„ç”¨æˆ·mStartedUsers.put(UserHandle.USER_OWNER, new UserState(UserHandle.OWNER, true));mUserLru.add(UserHandle.USER_OWNER);updateStartedUserArrayLocked();...//CPUä½¿ç”¨æƒ…å†µçš„è¿½è¸ªå™¨æ‰§è¡Œåˆå§‹åŒ–mProcessCpuTracker.init();...mRecentTasks = new RecentTasks(this);// åˆ›å»ºActivityStackSupervisorå¯¹è±¡mStackSupervisor = new ActivityStackSupervisor(this, mRecentTasks);mTaskPersister = new TaskPersister(systemDir, mStackSupervisor, mRecentTasks);//åˆ›å»ºåä¸º\"CpuTracker\"çš„çº¿ç¨‹mProcessCpuThread = new Thread(\"CpuTracker\") &#123; public void run() &#123; while (true) &#123; try &#123; try &#123; synchronized(this) &#123; final long now = SystemClock.uptimeMillis(); long nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now; long nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now; if (nextWriteDelay &lt; nextCpuDelay) &#123; nextCpuDelay = nextWriteDelay; &#125; if (nextCpuDelay &gt; 0) &#123; mProcessCpuMutexFree.set(true); this.wait(nextCpuDelay); &#125; &#125; &#125; catch (InterruptedException e) &#123; &#125; updateCpuStatsNow(); //æ›´æ–°CPUçŠ¶æ€ &#125; catch (Exception e) &#123; &#125; &#125; &#125;&#125;;...&#125; 4.5.4.3ã€AMSçš„startå‡½æ•° 123456789101112private void start() &#123; //å®Œæˆç»Ÿè®¡å‰çš„å¤ä½å·¥ä½œ Process.removeAllProcessGroups(); //å¼€å§‹ç›‘æ§è¿›ç¨‹çš„CPUä½¿ç”¨æƒ…å†µ mProcessCpuThread.start(); //æ³¨å†ŒæœåŠ¡ mBatteryStatsService.publish(mContext); mAppOpsService.publish(mContext); Slog.d(\"AppOps\", \"AppOpsService published\"); LocalServices.addService(ActivityManagerInternal.class, new LocalService()); AMSçš„startå‡½æ•°æ¯”è¾ƒç®€å•ï¼Œä¸»è¦æ˜¯ï¼š 1ã€å¯åŠ¨CPUç›‘æ§çº¿ç¨‹ã€‚è¯¥çº¿ç¨‹å°†ä¼šå¼€å§‹ç»Ÿè®¡ä¸åŒè¿›ç¨‹ä½¿ç”¨CPUçš„æƒ…å†µã€‚ 2ã€å‘å¸ƒä¸€äº›æœåŠ¡ï¼Œå¦‚BatteryStatsServiceã€AppOpsService(æƒé™ç®¡ç†ç›¸å…³)å’Œæœ¬åœ°å®ç°çš„ç»§æ‰¿ActivityManagerInternalçš„æœåŠ¡ã€‚ 4.5.5 AMS.setSystemProcess() 123456789101112131415161718192021222324252627282930313233public void setSystemProcess() &#123; try &#123; ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true); ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); ServiceManager.addService(\"meminfo\", new MemBinder(this)); ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this)); ServiceManager.addService(\"dbinfo\", new DbBinder(this)); if (MONITOR_CPU_USAGE) &#123; ServiceManager.addService(\"cpuinfo\", new CpuBinder(this)); &#125; ServiceManager.addService(\"permission\", new PermissionController(this)); ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( \"android\", STOCK_PM_FLAGS); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) &#123; //åˆ›å»ºProcessRecordå¯¹è±¡ ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; //è®¾ç½®ä¸ºpersistentè¿›ç¨‹ app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) &#123; mPidsSelfLocked.put(app.pid, app); &#125; updateLruProcessLocked(app, false, null);//ç»´æŠ¤è¿›ç¨‹lru updateOomAdjLocked(); //æ›´æ–°adj &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException(\"\", e); &#125;&#125; è¯¥æ–¹æ³•ä¸»è¦å·¥ä½œæ˜¯æ³¨å†Œå„ç§æœåŠ¡ã€‚ 4.5.5.1 AT.installSystemApplicationInfo() 12345678public void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; synchronized (this) &#123; // getSystemContext().installSystemApplicationInfo(info, classLoader); //åˆ›å»ºç”¨äºæ€§èƒ½ç»Ÿè®¡çš„Profilerå¯¹è±¡ mProfiler = new Profiler(); &#125;&#125; è¯¥æ–¹æ³•è°ƒç”¨ContextImplçš„nstallSystemApplicationInfo()æ–¹æ³•ï¼Œæœ€ç»ˆè°ƒç”¨LoadedApkçš„installSystemApplicationInfoï¼ŒåŠ è½½åä¸ºâ€androidâ€çš„package 4.5.5.2 installSystemApplicationInfo() [-&gt; LoadedApk.java] 12345void installSystemApplicationInfo(ApplicationInfo info, ClassLoader classLoader) &#123; assert info.packageName.equals(\"android\"); mApplicationInfo = info; //å°†åŒ…åä¸º\"android\"çš„åº”ç”¨ä¿¡æ¯ä¿å­˜åˆ°mApplicationInfo mClassLoader = classLoader;&#125; 4.5.6 startOtherServices() 123456789101112131415161718192021222324private void startOtherServices() &#123; ... //å®‰è£…ç³»ç»ŸProvider mActivityManagerService.installSystemProviders(); ... //phase480 &amp;&amp; 500 mSystemServiceManager.startBootPhase(SystemService.PHASE_LOCK_SETTINGS_READY); mSystemServiceManager.startBootPhase(SystemService.PHASE_SYSTEM_SERVICES_READY); ... mActivityManagerService.systemReady(new Runnable() &#123; public void run() &#123; //phase550 mSystemServiceManager.startBootPhase( SystemService.PHASE_ACTIVITY_MANAGER_READY); ... //phase600 mSystemServiceManager.startBootPhase( SystemService.PHASE_THIRD_PARTY_APPS_CAN_START); ... &#125; &#125;&#125; 4.5.6.1 AMS.installSystemProviders() 1234567891011121314151617181920212223public final void installSystemProviders() &#123; List&lt;ProviderInfo&gt; providers; synchronized (this) &#123; ProcessRecord app = mProcessNames.get(\"system\", Process.SYSTEM_UID); providers = generateApplicationProvidersLocked(app); if (providers != null) &#123; for (int i=providers.size()-1; i&gt;=0; i--) &#123; ProviderInfo pi = (ProviderInfo)providers.get(i); //ç§»é™¤éç³»ç»Ÿçš„provider if ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == 0) &#123; providers.remove(i); &#125; &#125; &#125; &#125; if (providers != null) &#123; //å®‰è£…æ‰€æœ‰çš„ç³»ç»Ÿprovider mSystemThread.installSystemProviders(providers); &#125; // åˆ›å»ºæ ¸å¿ƒSettings Observerï¼Œç”¨äºç›‘æ§Settingsçš„æ”¹å˜ã€‚ mCoreSettingsObserver = new CoreSettingsObserver(this);&#125; 4.5.7ã€AMS.systemReady()4.5.7.1ã€é˜¶æ®µä¸€123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void systemReady(final Runnable goingCallback) &#123; synchronized(this) &#123; .......... //è¿™ä¸€éƒ¨åˆ†ä¸»è¦æ˜¯è°ƒç”¨ä¸€äº›å…³é”®æœåŠ¡SystemReadyç›¸å…³çš„å‡½æ•°ï¼Œ //è¿›è¡Œä¸€äº›ç­‰å¾…AMSåˆå§‹å®Œï¼Œæ‰èƒ½è¿›è¡Œçš„å·¥ä½œ // Make sure we have the current profile info, since it is needed for security checks. mUserController.onSystemReady(); mRecentTasks.onSystemReadyLocked(); mAppOpsService.systemReady(); mSystemReady = true; &#125; ArrayList&lt;ProcessRecord&gt; procsToKill = null; synchronized(mPidsSelfLocked) &#123; //mPidsSelfLockedä¸­ä¿å­˜å½“å‰æ­£åœ¨è¿è¡Œçš„æ‰€æœ‰è¿›ç¨‹çš„ä¿¡æ¯ for (int i=mPidsSelfLocked.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = mPidsSelfLocked.valueAt(i); //åœ¨AMSå¯åŠ¨å®Œæˆå‰ï¼Œå¦‚æœæ²¡æœ‰FLAG_PERSISTENTæ ‡å¿—çš„è¿›ç¨‹å·²ç»å¯åŠ¨äº†ï¼Œ //å°±å°†è¿™ä¸ªè¿›ç¨‹åŠ å…¥åˆ°procsToKillä¸­ if (!isAllowedWhileBooting(proc.info))&#123; if (procsToKill == null) &#123; procsToKill = new ArrayList&lt;ProcessRecord&gt;(); &#125; procsToKill.add(proc); &#125; &#125; &#125; synchronized(this) &#123; //åˆ©ç”¨removeProcessLockedå…³é—­procsToKillä¸­çš„è¿›ç¨‹ if (procsToKill != null) &#123; for (int i=procsToKill.size()-1; i&gt;=0; i--) &#123; ProcessRecord proc = procsToKill.get(i); Slog.i(TAG, \"Removing system update proc: \" + proc); removeProcessLocked(proc, true, false, \"system update done\"); &#125; &#125; // Now that we have cleaned up any update processes, we // are ready to start launching real processes and know that // we won't trample on them any more. //è‡³æ­¤ç³»ç»Ÿå‡†å¤‡å®Œæ¯• mProcessesReady = true; &#125; ............ //æ ¹æ®æ•°æ®åº“å’Œèµ„æºæ–‡ä»¶ï¼Œè·å–ä¸€äº›é…ç½®å‚æ•° retrieveSettings(); final int currentUserId; synchronized (this) &#123; //å¾—åˆ°å½“å‰çš„ç”¨æˆ·ID currentUserId = mUserController.getCurrentUserIdLocked(); //è¯»å–urigrants.xmlï¼Œä¸ºå…¶ä¸­å®šä¹‰çš„ContentProvideré…ç½®å¯¹æŒ‡å®šUriæ•°æ®çš„è®¿é—®/ä¿®æ”¹æƒé™ //åŸç”Ÿä»£ç ä¸­ï¼Œä¼¼ä¹æ²¡æœ‰urigrants.xmlæ–‡ä»¶ //å®é™…ä½¿ç”¨çš„grant-uri-permissionæ˜¯åˆ†å¸ƒå¼å®šä¹‰çš„ readGrantedUriPermissionsLocked(); &#125; .......... è¿™ä¸€éƒ¨åˆ†çš„å·¥ä½œä¸»è¦æ˜¯è°ƒç”¨ä¸€äº›å…³é”®æœåŠ¡çš„åˆå§‹åŒ–å‡½æ•°ï¼Œ ç„¶åæ€æ­»é‚£äº›æ²¡æœ‰FLAG_PERSISTENTå´åœ¨AMSå¯åŠ¨å®Œæˆå‰å·²ç»å­˜åœ¨çš„è¿›ç¨‹ï¼Œ åŒæ—¶è·å–ä¸€äº›é…ç½®å‚æ•°ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”±äºåªæœ‰Javaè¿›ç¨‹æ‰ä¼šå‘AMSæ³¨å†Œï¼Œè€Œä¸€èˆ¬çš„Nativeè¿›ç¨‹ä¸ä¼šå‘AMSæ³¨å†Œï¼Œå› æ­¤æ­¤å¤„æ€æ­»çš„è¿›ç¨‹æ˜¯Javaè¿›ç¨‹ã€‚ 4.5.7.2ã€é˜¶æ®µäºŒ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//1ã€è°ƒç”¨å‚æ•°ä¼ å…¥çš„runnableå¯¹è±¡ï¼ŒSystemServerä¸­æœ‰å…·ä½“çš„å®šä¹‰if (goingCallback != null) goingCallback.run();..............//è°ƒç”¨æ‰€æœ‰ç³»ç»ŸæœåŠ¡çš„onStartUseræ¥å£mSystemServiceManager.startUser(currentUserId);.............synchronized (this) &#123; // Only start up encryption-aware persistent apps; once user is // unlocked we'll come back around and start unaware apps 2ã€å¯åŠ¨persistentä¸º1çš„applicationæ‰€åœ¨çš„è¿›ç¨‹ startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); // Start up initial activity. mBooting = true; // Enable home activity for system user, so that the system can always boot //å½“isSplitSystemUserè¿”å›trueæ—¶ï¼Œæ„å‘³è€…system userå’Œprimary useræ˜¯åˆ†ç¦»çš„ //è¿™é‡Œåº”è¯¥æ˜¯è®©system userä¹Ÿæœ‰å¯åŠ¨home activityçš„æƒé™å§ if (UserManager.isSplitSystemUser()) &#123; ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class); try &#123; AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM); &#125; catch (RemoteException e) &#123; throw e.rethrowAsRuntimeException(); &#125; &#125; //3ã€å¯åŠ¨Home startHomeActivityLocked(currentUserId, \"systemReady\"); try &#123; //å‘é€æ¶ˆæ¯ï¼Œè§¦å‘å¤„ç†Uidé”™è¯¯çš„Application if (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123; .......... mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget(); &#125; &#125; catch (RemoteException e) &#123; &#125; //å‘é€ä¸€äº›å¹¿æ’­ä¿¡æ¯ ............ //è¿™é‡Œæš‚æ—¶å…ˆä¸æ·±å…¥ï¼Œç­‰è¿›ä¸€æ­¥äº†è§£Activityçš„å¯åŠ¨è¿‡ç¨‹åï¼Œå†åšäº†è§£ mStackSupervisor.resumeFocusedStackTopActivityLocked(); ............&#125;............. ä»éƒ¨åˆ†ä»£ç æ¥çœ‹ï¼Œä¸»è¦çš„å·¥ä½œå°±æ˜¯é€šçŸ¥ä¸€äº›æœåŠ¡å¯ä»¥è¿›è¡ŒsystemReadyç›¸å…³çš„å·¥ä½œï¼Œå¹¶è¿›è¡Œå¯åŠ¨æœåŠ¡æˆ–åº”ç”¨è¿›ç¨‹çš„å·¥ä½œã€‚ 2.1ã€è°ƒç”¨å›è°ƒæ¥å£å›è°ƒæ¥å£çš„å…·ä½“å†…å®¹å®šä¹‰ä¸SystemServer.javaä¸­ï¼Œå…¶ä¸­ä¼šè°ƒç”¨å¤§é‡æœåŠ¡çš„onBootPhaseå‡½æ•°ã€ä¸€äº›å¯¹è±¡çš„systemReadyå‡½æ•°æˆ–systemRunningå‡½æ•°ã€‚ æ­¤å¤„ï¼Œæˆ‘ä»¬ä»…æˆªå–ä¸€äº›æ¯”è¾ƒç‰¹åˆ«çš„å†…å®¹ï¼š 123456789101112131415161718192021public void run() &#123; ............ try &#123; //å¯åŠ¨NativeCrashListenerç›‘å¬\"/data/system/ndebugsocket\"ä¸­çš„ä¿¡æ¯ //å®é™…ä¸Šæ˜¯ç›‘å¬debuggerdä¼ å…¥çš„ä¿¡æ¯ mActivityManagerService.startObservingNativeCrashes(); &#125; catch (Throwable e) &#123; reportWtf(\"observing native crashes\", e); &#125; ............ try &#123; //å¯åŠ¨SystemUi startSystemUi(context); &#125; catch (Throwable e) &#123; reportWtf(\"starting System UI\", e); &#125; ............ //è¿™ä¸ªä»¥å‰åˆ†æè¿‡ï¼Œå¯åŠ¨Watchdog Watchdog.getInstance().start(); ....................&#125; å›è°ƒæ¥å£ä¸­çš„å†…å®¹è¾ƒå¤šï¼Œä¸åšä¸€ä¸€åˆ†æã€‚ 2.2ã€å¯åŠ¨persistentæ ‡å¿—çš„è¿›ç¨‹æˆ‘ä»¬çœ‹çœ‹startPersistentAppså¯¹åº”çš„å†…å®¹ï¼š 12345678910111213141516171819private void startPersistentApps(int matchFlags) &#123; ............. synchronized (this) &#123; try &#123; //ä»PKMSä¸­å¾—åˆ°persistentä¸º1çš„ApplicationInfo final List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager() .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList(); for (ApplicationInfo app : apps) &#123; //ç”±äºframework-res.apkå·²ç»ç”±ç³»ç»Ÿå¯åŠ¨ï¼Œæ‰€ä»¥æ­¤å¤„ä¸å†å¯åŠ¨å®ƒ if (!\"android\".equals(app.packageName)) &#123; //addAppLockedä¸­å°†å¯åŠ¨applicationæ‰€åœ¨è¿›ç¨‹ addAppLocked(app, false, null /* ABI override */); &#125; &#125; &#125; catch (RemoteException ex) &#123; &#125; &#125;&#125; è·Ÿè¿›ä¸€ä¸‹addAppLockedå‡½æ•°ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041final ProcessRecord addAppLocked(ApplicationInfo info, boolean isolated, String abiOverride) &#123; //ä»¥ä¸‹æ˜¯å–å‡ºæˆ–æ„é€ å‡ºApplicationInfoå¯¹åº”çš„ProcessRecord ProcessRecord app; if (!isolated) &#123; app = getProcessRecordLocked(info.processName, info.uid, true); &#125; else &#123; app = null; &#125; if (app == null) &#123; app = newProcessRecordLocked(info, null, isolated, 0); updateLruProcessLocked(app, false, null); updateOomAdjLocked(); &#125; ........... // This package really, really can not be stopped. try &#123; //é€šè¿‡PKMSå°†packageå¯¹åº”æ•°æ®ç»“æ„çš„StoppedStateç½®ä¸ºfasle AppGlobals.getPackageManager().setPackageStoppedState( info.packageName, false, UserHandle.getUserId(app.uid)); &#125; catch (RemoteException e) &#123; &#125; catch (IllegalArgumentException e) &#123; Slog.w(TAG, \"Failed trying to unstop package \" + info.packageName + \": \" + e); &#125; if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123; app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; &#125; if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) &#123; mPersistentStartingProcesses.add(app); //å¯åŠ¨åº”ç”¨æ‰€åœ¨è¿›ç¨‹ï¼Œå°†å‘é€æ¶ˆæ¯ç»™zygoteï¼Œåè€…forkå‡ºè¿›ç¨‹ startProcessLocked(app, \"added application\", app.processName, abiOverride, null /* entryPoint */, null /* entryPointArgs */); &#125; return app;&#125; è¿™é‡Œæœ€ç»ˆå°†é€šè¿‡startProcessLockedå‡½æ•°ï¼Œå¯åŠ¨å®é™…çš„åº”ç”¨è¿›ç¨‹ã€‚ æ­£å¦‚ä¹‹å‰åˆ†æzygoteè¿›ç¨‹æ—¶ï¼Œæè¿‡çš„ä¸€æ ·ï¼Œzygoteä¸­çš„server socketå°†æ¥æ”¶æ¶ˆæ¯ï¼Œç„¶åä¸ºåº”ç”¨forkå‡ºè¿›ç¨‹ã€‚ æ€»ç»“å¯¹äºæ•´ä¸ªAMSå¯åŠ¨è¿‡ç¨‹è€Œè¨€ï¼Œåšå®¢ä¸­æ¶‰åŠçš„å†…å®¹å¯èƒ½åªæ˜¯æå°çš„ä¸€éƒ¨åˆ†ã€‚ ä½†å³ä½¿æˆ‘ä»¬å°½å¯èƒ½çš„ç®€åŒ–ï¼Œæ•´ä¸ªè¿‡ç¨‹çš„å†…å®¹è¿˜æ˜¯éå¸¸å¤šã€‚ ä¸è¿‡æˆ‘ä»¬å›å¤´çœ‹çœ‹æ•´ä¸ªè¿‡ç¨‹ï¼Œè¿˜æ˜¯èƒ½æ¯”è¾ƒæ¸…æ™°åœ°å°†AMSçš„å¯åŠ¨è¿‡ç¨‹åˆ†ä¸ºå››æ­¥ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºï¼š 1ã€åˆ›å»ºå‡ºSystemServerè¿›ç¨‹çš„Androidè¿è¡Œç¯å¢ƒã€‚ åœ¨è¿™ä¸€éƒ¨åˆ†ï¼ŒSystemServerè¿›ç¨‹ä¸»è¦åˆ›å»ºå‡ºå¯¹åº”çš„ActivityThreadå’ŒContextImplï¼Œæ„æˆAndroidè¿è¡Œç¯å¢ƒã€‚ AMSçš„åç»­å·¥ä½œä¾èµ–äºSystemServeråœ¨æ­¤åˆ›å»ºå‡ºçš„è¿è¡Œç¯å¢ƒã€‚ 2ã€å®ŒæˆAMSçš„åˆå§‹åŒ–å’Œå¯åŠ¨ã€‚ åœ¨è¿™ä¸€éƒ¨åˆ†ï¼Œå•çº¯åœ°è°ƒç”¨AMSçš„æ„é€ å‡½æ•°å’Œstartå‡½æ•°ï¼Œå®ŒæˆAMSçš„ä¸€äº›åˆå§‹åŒ–å·¥ä½œã€‚ 3ã€å°†SystemServerè¿›ç¨‹çº³å…¥åˆ°AMSçš„ç®¡ç†ä½“ç³»ä¸­ã€‚ AMSä½œä¸ºJavaä¸–ç•Œçš„è¿›ç¨‹ç®¡ç†å’Œè°ƒåº¦ä¸­å¿ƒï¼Œè¦å¯¹æ‰€æœ‰Javaè¿›ç¨‹ä¸€è§†åŒä»ï¼Œå› æ­¤SystemServerè¿›ç¨‹ä¹Ÿå¿…é¡»è¢«AMSç®¡ç†ã€‚ åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼ŒAMSåŠ è½½äº†SystemServerä¸­framework-res.apkçš„ä¿¡æ¯ï¼Œå¹¶å¯åŠ¨å’Œæ³¨å†Œäº†SettingsProvider.apkã€‚ 4ã€å¼€å§‹æ‰§è¡ŒAMSå¯åŠ¨å®Œæ¯•åæ‰èƒ½è¿›è¡Œçš„å·¥ä½œã€‚ ç³»ç»Ÿä¸­çš„ä¸€äº›æœåŠ¡å’Œè¿›ç¨‹ï¼Œå¿…é¡»ç­‰å¾…AMSå®Œæˆå¯åŠ¨åï¼Œæ‰èƒ½å±•å¼€åç»­å·¥ä½œã€‚ åœ¨è¿™ä¸€éƒ¨åˆ†ï¼ŒAMSé€šè¿‡è°ƒç”¨systemReadyå‡½æ•°ï¼Œé€šçŸ¥ç³»ç»Ÿä¸­çš„å…¶å®ƒæœåŠ¡å’Œè¿›ç¨‹ï¼Œå¯ä»¥è¿›è¡Œå¯¹åº”å·¥ä½œäº†ã€‚ åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå€¼å¾—æˆ‘ä»¬å…³æ³¨çš„æ˜¯ï¼šHome Activityè¢«å¯åŠ¨äº†ã€‚å½“è¯¥Activityè¢«åŠ è½½å®Œæˆåï¼Œæœ€ç»ˆä¼šè§¦å‘ACTION_BOOT_COMPLETEDå¹¿æ’­ã€‚ ï¼ˆ6ï¼‰ã€å¯åŠ¨Launcher(Activity)çœ‹çœ‹å¯åŠ¨Home Activityå¯¹åº”çš„startHomeActivityLockedå‡½æ•°ï¼š 1234567891011121314151617181920212223boolean startHomeActivityLocked(int userId, String reason) &#123; .............. Intent intent = getHomeIntent(); //æ ¹æ®intentä¸­æºå¸¦çš„ComponentNameï¼Œåˆ©ç”¨PKMSå¾—åˆ°ActivityInfo ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) &#123; intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); //æ­¤æ—¶homeå¯¹åº”è¿›ç¨‹åº”è¯¥è¿˜æ²¡å¯åŠ¨ï¼Œappä¸ºnull ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) &#123; intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //å¯åŠ¨home mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); &#125; &#125; else &#123; .......... &#125; return true;&#125; è¿™é‡Œæš‚æ—¶å…ˆä¸æ·±ç©¶Home Activityå¯åŠ¨çš„å…·ä½“è¿‡ç¨‹ã€‚ ä»æ‰‹å¤´çš„èµ„æ–™æ¥çœ‹ï¼Œå½“Home Activityå¯åŠ¨åï¼Œ ActivityStackSupervisorä¸­çš„activityIdleInternalLockedå‡½æ•°å°†è¢«è°ƒç”¨ï¼š 12345678final ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) &#123; ........... if (isFocusedStack(r.task.stack) || fromTimeout) &#123; booting = checkFinishBootingLocked(); &#125; ............&#125; åœ¨checkFinishBootingLockedå‡½æ•°ä¸­ï¼š 123456789101112131415private boolean checkFinishBootingLocked() &#123; //mServiceä¸ºAMSï¼ŒmBootingå˜é‡åœ¨AMSå›è°ƒSystemServerä¸­å®šä¹‰çš„Runnableæ—¶ï¼Œç½®ä¸ºäº†true final boolean booting = mService.mBooting; boolean enableScreen = false; mService.mBooting = false; if (!mService.mBooted) &#123; mService.mBooted = true; enableScreen = true; &#125; if (booting || enableScreen) &#123;ã€ //è°ƒç”¨AMSçš„æ¥å£ï¼Œå‘é€æ¶ˆæ¯ mService.postFinishBooting(booting, enableScreen); &#125; return booting;&#125; æœ€ç»ˆï¼ŒAMSçš„finishBootingå‡½æ•°å°†è¢«è°ƒç”¨ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061final void finishBooting() &#123; ......... //ä»¥ä¸‹æ˜¯æ³¨å†Œå¹¿æ’­æ¥æ”¶å™¨ï¼Œç”¨äºå¤„ç†éœ€è¦é‡å¯çš„package IntentFilter pkgFilter = new IntentFilter(); pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART); pkgFilter.addDataScheme(\"package\"); mContext.registerReceiver(new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES); if (pkgs != null) &#123; for (String pkg : pkgs) &#123; synchronized (ActivityManagerService.this) &#123; if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, \"query restart\")) &#123; setResultCode(Activity.RESULT_OK); return; &#125; &#125; &#125; &#125; &#125; &#125;, pkgFilter); ........... // Let system services know. mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED); //ä»¥ä¸‹æ˜¯å¯åŠ¨é‚£äº›ç­‰å¾…å¯åŠ¨çš„è¿›ç¨‹ synchronized (this) &#123; // Ensure that any processes we had put on hold are now started // up. final int NP = mProcessesOnHold.size(); if (NP &gt; 0) &#123; ArrayList&lt;ProcessRecord&gt; procs = new ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold); for (int ip=0; ip&lt;NP; ip++) &#123; ................. startProcessLocked(procs.get(ip), \"on-hold\", null); &#125; &#125; &#125; &#125; .............. if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123; // Start looking for apps that are abusing wake locks. //æ¯15minæ£€æŸ¥ä¸€æ¬¡ç³»ç»Ÿå„åº”ç”¨è¿›ç¨‹ä½¿ç”¨ç”µé‡çš„æƒ…å†µï¼Œå¦‚æœæŸä¸ªè¿›ç¨‹ä½¿ç”¨WakeLockçš„æ—¶é—´è¿‡é•¿ //AMSå°†å…³é—­è¯¥è¿›ç¨‹ Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG); mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY); // Tell anyone interested that we are done booting! SystemProperties.set(\"sys.boot_completed\", \"1\"); ................. //æ­¤å¤„ä»ä»£ç æ¥çœ‹å‘é€çš„æ˜¯ACTION_LOCKED_BOOT_COMPLETEDå¹¿æ’­ //åœ¨è¿›è¡Œunlockç›¸å…³çš„å·¥ä½œåï¼ŒmUserControllerå°†è°ƒç”¨finishUserUnlockingï¼Œå‘é€SYSTEM_USER_UNLOCK_MSGæ¶ˆæ¯ç»™AMS //AMSæ”¶åˆ°æ¶ˆæ¯åï¼Œè°ƒç”¨mUserControllerçš„finishUserUnlockedå‡½æ•°ï¼Œç»è¿‡ç›¸åº”çš„å¤„ç†åï¼Œ //åœ¨mUserControllerçš„finishUserUnlockedCompletedä¸­ï¼Œæœ€ç»ˆå°†ä¼šå‘é€ACTION_BOOT_COMPLETEDå¹¿æ’­ mUserController.sendBootCompletedLocked(.........); ................. &#125;&#125; æœ€ç»ˆï¼Œå½“AMSå¯åŠ¨Home Activityç»“æŸï¼Œå¹¶å‘é€ACTION_BOOT_COMPLETEDå¹¿æ’­æ—¶ï¼ŒAMSçš„å¯åŠ¨è¿‡ç¨‹å‘Šä¸€æ®µè½ã€‚ å…·ä½“å¯åŠ¨æµç¨‹è¯·å‚è€ƒï¼šã€Android 7.1.2 (Android N) Activityå¯åŠ¨æµç¨‹åˆ†æã€‘ å‚è€ƒæ–‡æ¡£ï¼šAndroid 7.0 ActivityManagerService 1 - 10Android Initè¿›ç¨‹æºç åˆ†æ(1) - jay_richardAndroid Initè¿›ç¨‹æºç åˆ†æ(2) - jay_richardAndroid Zygoteè¿›ç¨‹åˆ†æ - jay_richardå›¾è§£Android - Zygote, System Server å¯åŠ¨åˆ†æ - æ¼«å¤©å°˜æ²™ - åšå®¢å›­Android7.0 initè¿›ç¨‹æºç åˆ†æ - ZhangJiançš„åšå®¢ - CSDNåšå®¢Androidç³»ç»Ÿå¯åŠ¨-SystemServerä¸Šç¯‡ - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢Androidç³»ç»Ÿå¯åŠ¨-Initç¯‡ - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢Androidç³»ç»Ÿå¯åŠ¨-zygoteç¯‡ - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢Androidç³»ç»Ÿå¯åŠ¨-SystemServerä¸‹ç¯‡ - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢ActivityManagerServiceå¯åŠ¨è¿‡ç¨‹ - Gityuanåšå®¢ | è¢è¾‰è¾‰åšå®¢Android Initè¿›ç¨‹æºç åˆ†æ - æ·±å…¥å‰–æAndroidç³»ç»Ÿ - CSDNåšå®¢","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Android 7.1.2 (Android N) Androidæ¶ˆæ¯å¤„ç†æœºåˆ¶åˆ†æï¼ˆä»JAVAå±‚åˆ°NATIVEå±‚ï¼‰â€“ Handlerã€Looperã€Message","slug":"Android-7-1-2-Android-N-Androidæ¶ˆæ¯æœºåˆ¶â€“Handlerã€Looperã€Message","date":"2017-07-31T16:00:00.000Z","updated":"2018-04-19T14:29:20.077Z","comments":true,"path":"2017/08/01/Android-7-1-2-Android-N-Androidæ¶ˆæ¯æœºåˆ¶â€“Handlerã€Looperã€Message/","link":"","permalink":"http://zhoujinjian.cc/2017/08/01/Android-7-1-2-Android-N-Androidæ¶ˆæ¯æœºåˆ¶â€“Handlerã€Looperã€Message/","excerpt":"","text":"â— framework/base/core/java/andorid/os/Handler.java â— framework/base/core/java/andorid/os/Looper.java â— framework/base/core/java/andorid/os/Message.java â— framework/base/core/java/andorid/os/MessageQueue.java â— framework/base/core/java/andorid/os/MessageQueue.java â— framework/base/core/jni/android_os_MessageQueue.cpp â— framework/base/core/java/andorid/os/Looper.java (Javaå±‚ï¼‰ â— system/core/libutils/Looper.cpp ( Nativeå±‚) â— framework/base/native/android/looper.cpp (ALoopå¯¹è±¡) â— framework/native/include/android/looper.h åšå®¢åŸå›¾é“¾æ¥â… ã€Androidæ¶ˆæ¯æœºåˆ¶(Javaå±‚)ä¸€ã€Androidæ¶ˆæ¯æœºåˆ¶ç›¸å…³ç±»ã€æ¦‚å¿µï¼ˆJavaå±‚ï¼‰ä¸»çº¿ç¨‹ï¼ˆUIçº¿ç¨‹ï¼‰ å®šä¹‰ï¼šå½“ç¨‹åºç¬¬ä¸€æ¬¡å¯åŠ¨æ—¶ï¼ŒAndroidä¼šåŒæ—¶å¯åŠ¨ä¸€æ¡ä¸»çº¿ç¨‹ï¼ˆMain Threadï¼‰ ä½œç”¨ï¼šä¸»çº¿ç¨‹ä¸»è¦è´Ÿè´£å¤„ç†ä¸UIç›¸å…³çš„äº‹ä»¶ Messageï¼ˆæ¶ˆæ¯ï¼‰ å®šä¹‰ï¼šHandleræ¥æ”¶å’Œå¤„ç†çš„æ¶ˆæ¯å¯¹è±¡ï¼ˆBeanå¯¹è±¡ï¼‰ ä½œç”¨ï¼šé€šä¿¡æ—¶ç›¸å…³ä¿¡æ¯çš„å­˜æ”¾å’Œä¼ é€’ ThreadLocal å®šä¹‰ï¼šçº¿ç¨‹å†…éƒ¨çš„æ•°æ®å­˜å‚¨ç±» ä½œç”¨ï¼šè´Ÿè´£å­˜å‚¨å’Œè·å–æœ¬çº¿ç¨‹çš„Looper MessageQueueï¼ˆæ¶ˆæ¯é˜Ÿåˆ—ï¼‰ å®šä¹‰ï¼šé‡‡ç”¨å•é“¾è¡¨çš„æ•°æ®ç»“æ„æ¥å­˜å‚¨æ¶ˆæ¯åˆ—è¡¨ ä½œç”¨ï¼šç”¨æ¥å­˜æ”¾é€šè¿‡Handlerå‘è¿‡æ¥çš„Messageï¼ŒæŒ‰ç…§å…ˆè¿›å…ˆå‡ºæ‰§è¡Œ Handlerï¼ˆå¤„ç†è€…ï¼‰ å®šä¹‰ï¼šMessageçš„ä¸»è¦å¤„ç†è€… ä½œç”¨ï¼šè´Ÿè´£å‘é€Messageåˆ°æ¶ˆæ¯é˜Ÿåˆ—&amp;å¤„ç†Looperåˆ†æ´¾è¿‡æ¥çš„Message Looperï¼ˆå¾ªç¯å™¨ï¼‰ å®šä¹‰ï¼šæ‰®æ¼”Message Queueå’ŒHandlerä¹‹é—´æ¡¥æ¢çš„è§’è‰² ä½œç”¨ï¼š æ¶ˆæ¯å¾ªç¯ï¼šå¾ªç¯å–å‡ºMessage Queueçš„Message æ¶ˆæ¯æ´¾å‘ï¼šå°†å–å‡ºçš„Messageäº¤ä»˜ç»™ç›¸åº”çš„Handler äºŒã€ç±»å…³ç³»å›¾ï¼ˆJavaå±‚ï¼‰ â— Looperæœ‰ä¸€ä¸ªMessageQueueæ¶ˆæ¯é˜Ÿåˆ—ï¼›â— MessageQueueæœ‰ä¸€ç»„å¾…å¤„ç†çš„Messageï¼›â—Messageä¸­æœ‰ä¸€ä¸ªç”¨äºå¤„ç†æ¶ˆæ¯çš„Handlerï¼›â— Handlerä¸­æœ‰Looperå’ŒMessageQueueã€‚ å…¸å‹å®ä¾‹:å…ˆå±•ç¤ºä¸€ä¸ªå…¸å‹çš„å…³äºHandler/Looperçš„çº¿ç¨‹ 123456789101112131415class LooperThread extends Thread &#123; public Handler mHandler; public void run() &#123; Looper.prepare(); mHandler = new Handler() &#123; public void handleMessage(Message msg) &#123; //TODO å®šä¹‰æ¶ˆæ¯å¤„ç†é€»è¾‘. &#125; &#125;; Looper.loop(); &#125;&#125; æ¥ä¸‹æ¥ï¼Œå›´ç»•ç€è¿™ä¸ªå®ä¾‹å±•å¼€è¯¦ç»†åˆ†æã€‚ ä¸‰ã€Looperæºç åˆ†æï¼ˆJavaå±‚ï¼‰å¯¹äºæ— å‚çš„æƒ…å†µï¼Œé»˜è®¤è°ƒç”¨prepare(true)ï¼Œè¡¨ç¤ºçš„æ˜¯è¿™ä¸ªLooperè¿è¡Œé€€å‡ºï¼Œè€Œå¯¹äºfalseçš„æƒ…å†µåˆ™è¡¨ç¤ºå½“å‰Looperä¸è¿è¡Œé€€å‡ºã€‚ 12345678private static void prepare(boolean quitAllowed) &#123; //æ¯ä¸ªçº¿ç¨‹åªå…è®¸æ‰§è¡Œä¸€æ¬¡è¯¥æ–¹æ³•ï¼Œç¬¬äºŒæ¬¡æ‰§è¡Œæ—¶çº¿ç¨‹çš„TLSå·²æœ‰æ•°æ®ï¼Œåˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚ if (sThreadLocal.get() != null) &#123; throw new RuntimeException(\"Only one Looper may be created per thread\"); &#125; //åˆ›å»ºLooperå¯¹è±¡ï¼Œå¹¶ä¿å­˜åˆ°å½“å‰çº¿ç¨‹çš„TLSåŒºåŸŸ sThreadLocal.set(new Looper(quitAllowed));&#125; 3.1 çŸ¥è¯†ï¼šThreadLocalä»‹ç»è¿™é‡Œçš„sThreadLocalæ˜¯ThreadLocalç±»å‹ï¼Œä¸‹é¢ï¼Œå…ˆè¯´è¯´ThreadLocalã€‚ ThreadLocalï¼š çº¿ç¨‹æœ¬åœ°å­˜å‚¨åŒºï¼ˆThread Local Storageï¼Œç®€ç§°ä¸ºTLSï¼‰ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„ç§æœ‰çš„æœ¬åœ°å­˜å‚¨åŒºåŸŸï¼Œä¸åŒçº¿ç¨‹ä¹‹é—´å½¼æ­¤ä¸èƒ½è®¿é—®å¯¹æ–¹çš„TLSåŒºåŸŸã€‚TLSå¸¸ç”¨çš„æ“ä½œæ–¹æ³•ï¼š 123456789101112ThreadLocal.set(T value)ï¼šå°†valueå­˜å‚¨åˆ°å½“å‰çº¿ç¨‹çš„TLSåŒºåŸŸï¼Œæºç å¦‚ä¸‹ï¼š public void set(T value) &#123; Thread currentThread = Thread.currentThread(); //è·å–å½“å‰çº¿ç¨‹ Values values = values(currentThread); //æŸ¥æ‰¾å½“å‰çº¿ç¨‹çš„æœ¬åœ°å‚¨å­˜åŒº if (values == null) &#123; //å½“çº¿ç¨‹æœ¬åœ°å­˜å‚¨åŒºï¼Œå°šæœªå­˜å‚¨è¯¥çº¿ç¨‹ç›¸å…³ä¿¡æ¯æ—¶ï¼Œåˆ™åˆ›å»ºValueså¯¹è±¡ values = initializeValues(currentThread); &#125; //ä¿å­˜æ•°æ®valueåˆ°å½“å‰çº¿ç¨‹this values.put(this, value); &#125; ThreadLocal.get()ï¼šè·å–å½“å‰çº¿ç¨‹TLSåŒºåŸŸçš„æ•°æ®ï¼Œæºç å¦‚ä¸‹ï¼š 123456789101112131415public T get() &#123; Thread currentThread = Thread.currentThread(); //è·å–å½“å‰çº¿ç¨‹ Values values = values(currentThread); //æŸ¥æ‰¾å½“å‰çº¿ç¨‹çš„æœ¬åœ°å‚¨å­˜åŒº if (values != null) &#123; Object[] table = values.table; int index = hash &amp; values.mask; if (this.reference == table[index]) &#123; return (T) table[index + 1]; //è¿”å›å½“å‰çº¿ç¨‹å‚¨å­˜åŒºä¸­çš„æ•°æ® &#125; &#125; else &#123; //åˆ›å»ºValueså¯¹è±¡ values = initializeValues(currentThread); &#125; return (T) values.getAfterMiss(this); //ä»ç›®æ ‡çº¿ç¨‹å­˜å‚¨åŒºæ²¡æœ‰æŸ¥è¯¢æ˜¯åˆ™è¿”å›null&#125; ThreadLocalçš„get()å’Œset()æ–¹æ³•æ“ä½œçš„ç±»å‹éƒ½æ˜¯æ³›å‹ï¼Œæ¥ç€å›åˆ°å‰é¢æåˆ°çš„sThreadLocalå˜é‡ï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š 1static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;() å¯è§sThreadLocalçš„get()å’Œset()æ“ä½œçš„ç±»å‹éƒ½æ˜¯Looperç±»å‹ã€‚ (1) Looper.prepare()Looper.prepare()åœ¨æ¯ä¸ªçº¿ç¨‹åªå…è®¸æ‰§è¡Œä¸€æ¬¡ï¼Œè¯¥æ–¹æ³•ä¼šåˆ›å»ºLooperå¯¹è±¡ï¼ŒLooperçš„æ„é€ æ–¹æ³•ä¸­ä¼šåˆ›å»ºä¸€ä¸ªMessageQueueå¯¹è±¡ï¼Œå†å°†Looperå¯¹è±¡ä¿å­˜åˆ°å½“å‰çº¿ç¨‹TLSã€‚ å¯¹äºLooperç±»å‹çš„æ„é€ æ–¹æ³•å¦‚ä¸‹ï¼š 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); //åˆ›å»ºMessageQueueå¯¹è±¡. mThread = Thread.currentThread(); //è®°å½•å½“å‰çº¿ç¨‹.&#125; å¦å¤–ï¼Œä¸prepare()ç›¸è¿‘åŠŸèƒ½çš„ï¼Œè¿˜æœ‰ä¸€ä¸ªprepareMainLooper()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦åœ¨ActivityThreadç±»ä¸­ä½¿ç”¨ã€‚ 12345678910public static void prepareMainLooper() &#123; prepare(false); //è®¾ç½®ä¸å…è®¸é€€å‡ºçš„Looper synchronized (Looper.class) &#123; //å°†å½“å‰çš„Looperä¿å­˜ä¸ºä¸»Looperï¼Œæ¯ä¸ªçº¿ç¨‹åªå…è®¸æ‰§è¡Œä¸€æ¬¡ã€‚ if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; Looper.prepare()åœ¨æ¯ä¸ªçº¿ç¨‹åªå…è®¸æ‰§è¡Œä¸€æ¬¡ï¼Œè¯¥æ–¹æ³•ä¼šåˆ›å»ºLooperå¯¹è±¡ï¼ŒLooperçš„æ„é€ æ–¹æ³•ä¸­ä¼šåˆ›å»ºä¸€ä¸ªMessageQueueå¯¹è±¡ï¼Œå†å°†Looperå¯¹è±¡ä¿å­˜åˆ°å½“å‰çº¿ç¨‹TLSã€‚ å¯¹äºLooperç±»å‹çš„æ„é€ æ–¹æ³•å¦‚ä¸‹ï¼š 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); //åˆ›å»ºMessageQueueå¯¹è±¡.ç¨åè¯¦ç»†ä»‹ç» mThread = Thread.currentThread(); //è®°å½•å½“å‰çº¿ç¨‹.&#125; å¦å¤–ï¼Œä¸prepare()ç›¸è¿‘åŠŸèƒ½çš„ï¼Œè¿˜æœ‰ä¸€ä¸ªprepareMainLooper()æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦åœ¨ä¸»çº¿ç¨‹ï¼ˆUIçº¿ç¨‹ï¼‰ActivityThreadç±»ä¸­ä½¿ç”¨ã€‚ 12345678910public static void prepareMainLooper() &#123; prepare(false); //è®¾ç½®ä¸å…è®¸é€€å‡ºçš„Looper synchronized (Looper.class) &#123; //å°†å½“å‰çš„Looperä¿å­˜ä¸ºä¸»Looperï¼Œæ¯ä¸ªçº¿ç¨‹åªå…è®¸æ‰§è¡Œä¸€æ¬¡ã€‚ if (sMainLooper != null) &#123; throw new IllegalStateException(\"The main Looper has already been prepared.\"); &#125; sMainLooper = myLooper(); &#125;&#125; ï¼ˆ2ï¼‰åˆ›å»ºMessageQueue()MessageQueueæ˜¯æ¶ˆæ¯æœºåˆ¶çš„Javaå±‚å’ŒC++å±‚çš„è¿æ¥çº½å¸¦ï¼Œå¤§éƒ¨åˆ†æ ¸å¿ƒæ–¹æ³•éƒ½äº¤ç»™nativeå±‚æ¥å¤„ç†ï¼Œå…¶ä¸­MessageQueueç±»ä¸­æ¶‰åŠçš„nativeæ–¹æ³•å¦‚ä¸‹ï¼š 123private native static long nativeInit();private native void nativePollOnce(long ptr, int timeoutMillis);private native static void nativeWake(long ptr); å…³äºè¿™äº›nativeæ–¹æ³•çš„ä»‹ç»ï¼Œè§ç¬¬äºŒèŠ‚ï¼šAndroidæ¶ˆæ¯æœºåˆ¶(nativeç¯‡)ã€‚ 12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //é€šè¿‡nativeæ–¹æ³•åˆå§‹åŒ–æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå…¶ä¸­mPtræ˜¯ä¾›nativeä»£ç ä½¿ç”¨ mPtr = nativeInit();&#125; MessageQueueåˆ›å»ºè¿‡ç¨‹æ€»ç»“ï¼š 1ã€Looperçš„prepareæˆ–è€…prepareMainLooperé™æ€æ–¹æ³•è¢«è°ƒç”¨ï¼Œå°†ä¸€ä¸ªLooperå¯¹è±¡ä¿å­˜åœ¨ThreadLocalé‡Œé¢ã€‚2ã€Looperå¯¹è±¡çš„åˆå§‹åŒ–æ–¹æ³•é‡Œï¼Œé¦–å…ˆä¼šæ–°å»ºä¸€ä¸ªMessageQueueå¯¹è±¡ã€‚3ã€MessageQueueå¯¹è±¡çš„åˆå§‹åŒ–æ–¹æ³•é€šè¿‡JNIåˆå§‹åŒ–C++å±‚çš„NativeMessageQueueå¯¹è±¡ã€‚4ã€NativeMessageQueueå¯¹è±¡åœ¨åˆ›å»ºè¿‡ç¨‹ä¸­ï¼Œä¼šåˆå§‹åŒ–ä¸€ä¸ªC++å±‚çš„Looperå¯¹è±¡ã€‚5ã€C++å±‚çš„Looperå¯¹è±¡åœ¨åˆ›å»ºçš„è¿‡ç¨‹ä¸­ï¼Œä¼šåœ¨å†…éƒ¨åˆ›å»ºä¸€ä¸ªç®¡é“ï¼ˆpipeï¼‰ï¼Œå¹¶å°†è¿™ä¸ªç®¡é“çš„è¯»å†™fdéƒ½ä¿å­˜åœ¨ mWakeReadPipeFdå’ŒmWakeWritePipeFdä¸­ã€‚ç„¶åæ–°å»ºä¸€ä¸ªepollå®ä¾‹ï¼Œå¹¶å°†ä¸¤ä¸ªfdæ³¨å†Œè¿›å»ã€‚6ã€åˆ©ç”¨epollçš„æœºåˆ¶ï¼Œå¯ä»¥åšåˆ°å½“ç®¡é“æ²¡æœ‰æ¶ˆæ¯æ—¶ï¼Œçº¿ç¨‹ç¡çœ åœ¨è¯»ç«¯çš„fdä¸Šï¼Œå½“å…¶ä»–çº¿ç¨‹å¾€ç®¡é“å†™æ•°æ®æ—¶ï¼Œæœ¬çº¿ç¨‹ä¾¿ä¼šè¢«å”¤é†’ä»¥è¿›è¡Œæ¶ˆæ¯å¤„ç†ã€‚ (3) Looper.loop()12345678910111213141516171819202122232425262728293031323334public static void loop() &#123; final Looper me = myLooper(); //è·å–TLSå­˜å‚¨çš„Looperå¯¹è±¡ if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; //è·å–Looperå¯¹è±¡ä¸­çš„æ¶ˆæ¯é˜Ÿåˆ— Binder.clearCallingIdentity(); //ç¡®ä¿åœ¨æƒé™æ£€æŸ¥æ—¶åŸºäºæœ¬åœ°è¿›ç¨‹ï¼Œè€Œä¸æ˜¯åŸºäºæœ€åˆè°ƒç”¨è¿›ç¨‹ã€‚ final long ident = Binder.clearCallingIdentity(); for (;;) &#123; //è¿›å…¥loopçš„ä¸»å¾ªç¯æ–¹æ³• Message msg = queue.next(); //å¯èƒ½ä¼šé˜»å¡ May be block if (msg == null) &#123; //æ²¡æœ‰æ¶ˆæ¯ï¼Œåˆ™é€€å‡ºå¾ªç¯ return; &#125; Printer logging = me.mLogging; //é»˜è®¤ä¸ºnullï¼Œå¯é€šè¿‡setMessageLogging()æ–¹æ³•æ¥æŒ‡å®šè¾“å‡ºï¼Œç”¨äºdebugåŠŸèƒ½ if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; msg.target.dispatchMessage(msg); //ç”¨äºåˆ†å‘Message if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); //ç¡®ä¿åˆ†å‘è¿‡ç¨‹ä¸­identityä¸ä¼šæŸå if (ident != newIdent) &#123; //æ‰“å°identityæ”¹å˜çš„logï¼Œåœ¨åˆ†å‘æ¶ˆæ¯è¿‡ç¨‹ä¸­æ˜¯ä¸å¸Œæœ›èº«ä»½è¢«æ”¹å˜çš„ã€‚ &#125; msg.recycleUnchecked(); //å°†Messageæ”¾å…¥æ¶ˆæ¯æ±  &#125;&#125; loop()è¿›å…¥å¾ªç¯æ¨¡å¼ï¼Œä¸æ–­é‡å¤ä¸‹é¢çš„æ“ä½œï¼Œç›´åˆ°æ²¡æœ‰æ¶ˆæ¯æ—¶é€€å‡ºå¾ªç¯ è¯»å–MessageQueueçš„ä¸‹ä¸€æ¡Messageï¼›æŠŠMessageåˆ†å‘ç»™ç›¸åº”çš„targetï¼› A1ï¼šLooper.loop()å¾ªç¯ä¸­çš„msg.targetæ˜¯ä»€ä¹ˆæ—¶å€™è¢«èµ‹å€¼çš„ï¼Ÿhandler.sendMessage()æœ€ç»ˆä¼šè¿›å…¥MessageQueue.enqueueMessage()ï¼Œå°±æ˜¯åœ¨è¿™é‡Œé¢å¤åˆ¶çš„ã€‚ ç¨åå†handler.sendMessage()è¯¦ç»†ä»‹ç»ã€‚ å†æŠŠåˆ†å‘åçš„Messageå›æ”¶åˆ°æ¶ˆæ¯æ± ï¼Œä»¥ä¾¿é‡å¤åˆ©ç”¨ã€‚Looper.loop()æ˜¯æ¶ˆæ¯å¤„ç†çš„æ ¸å¿ƒéƒ¨åˆ†ã€‚ 3.1 MessageQueue.next()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; //å½“æ¶ˆæ¯å¾ªç¯å·²ç»é€€å‡ºï¼Œåˆ™ç›´æ¥è¿”å› return null; &#125; int pendingIdleHandlerCount = -1; // å¾ªç¯è¿­ä»£çš„é¦–æ¬¡ä¸º-1 int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //é˜»å¡æ“ä½œï¼Œå½“ç­‰å¾…nextPollTimeoutMillisæ—¶é•¿ï¼Œæˆ–è€…æ¶ˆæ¯é˜Ÿåˆ—è¢«å”¤é†’ï¼Œéƒ½ä¼šè¿”å› nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; //å½“æ¶ˆæ¯Handlerä¸ºç©ºæ—¶ï¼ŒæŸ¥è¯¢MessageQueueä¸­çš„ä¸‹ä¸€æ¡å¼‚æ­¥æ¶ˆæ¯msgï¼Œåˆ™é€€å‡ºå¾ªç¯ã€‚ do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; //å½“å¼‚æ­¥æ¶ˆæ¯è§¦å‘æ—¶é—´å¤§äºå½“å‰æ—¶é—´ï¼Œåˆ™è®¾ç½®ä¸‹ä¸€æ¬¡è½®è¯¢çš„è¶…æ—¶æ—¶é•¿ nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // è·å–ä¸€æ¡æ¶ˆæ¯ï¼Œå¹¶è¿”å› mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; //è®¾ç½®æ¶ˆæ¯çš„ä½¿ç”¨çŠ¶æ€ï¼Œå³flags |= FLAG_IN_USE msg.markInUse(); return msg; //æˆåŠŸåœ°è·å–MessageQueueä¸­çš„ä¸‹ä¸€æ¡å³å°†è¦æ‰§è¡Œçš„æ¶ˆæ¯ &#125; &#125; else &#123; //æ²¡æœ‰æ¶ˆæ¯ nextPollTimeoutMillis = -1; &#125; //æ¶ˆæ¯æ­£åœ¨é€€å‡ºï¼Œè¿”å›null if (mQuitting) &#123; dispose(); return null; &#125; //å½“æ¶ˆæ¯é˜Ÿåˆ—ä¸ºç©ºï¼Œæˆ–è€…æ˜¯æ¶ˆæ¯é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ªæ¶ˆæ¯æ—¶ if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; //æ²¡æœ‰idle handlers éœ€è¦è¿è¡Œï¼Œåˆ™å¾ªç¯å¹¶ç­‰å¾…ã€‚ mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; //åªæœ‰ç¬¬ä¸€æ¬¡å¾ªç¯æ—¶ï¼Œä¼šè¿è¡Œidle handlersï¼Œæ‰§è¡Œå®Œæˆåï¼Œé‡ç½®pendingIdleHandlerCountä¸º0. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; //å»æ‰handlerçš„å¼•ç”¨ boolean keep = false; try &#123; keep = idler.queueIdle(); //idleæ—¶æ‰§è¡Œçš„æ–¹æ³• &#125; catch (Throwable t) &#123; Log.wtf(TAG, \"IdleHandler threw exception\", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; //é‡ç½®idle handlerä¸ªæ•°ä¸º0ï¼Œä»¥ä¿è¯ä¸ä¼šå†æ¬¡é‡å¤è¿è¡Œ pendingIdleHandlerCount = 0; //å½“è°ƒç”¨ä¸€ä¸ªç©ºé—²handleræ—¶ï¼Œä¸€ä¸ªæ–°messageèƒ½å¤Ÿè¢«åˆ†å‘ï¼Œå› æ­¤æ— éœ€ç­‰å¾…å¯ä»¥ç›´æ¥æŸ¥è¯¢pending message. nextPollTimeoutMillis = 0; &#125;&#125; nativePollOnce()åœ¨nativeåšäº†å¤§é‡çš„å·¥ä½œï¼ŒAndroidæ¶ˆæ¯æœºåˆ¶(nativeç¯‡)ç¨åè¯¦ç»†åˆ†æã€‚ æ¶ˆæ¯å¾ªç¯Looper.loop()æ€»ç»“ï¼š é¦–å…ˆé€šè¿‡è°ƒç”¨Looperçš„loopæ–¹æ³•å¼€å§‹æ¶ˆæ¯ç›‘å¬ã€‚loopæ–¹æ³•é‡Œä¼šè°ƒç”¨MessageQueueçš„nextæ–¹æ³•ã€‚nextæ–¹æ³•ä¼šå µå¡çº¿ç¨‹ç›´åˆ°æœ‰æ¶ˆæ¯åˆ°æ¥ä¸ºæ­¢ã€‚ nextæ–¹æ³•é€šè¿‡è°ƒç”¨nativePollOnceæ–¹æ³•æ¥ç›‘å¬äº‹ä»¶ã€‚nextæ–¹æ³•å†…éƒ¨é€»è¾‘å¦‚ä¸‹æ‰€ç¤º(ç®€åŒ–)ï¼š a.è¿›å…¥æ­»å¾ªç¯ï¼Œä»¥å‚æ•°timout=0è°ƒç”¨nativePollOnceæ–¹æ³•ã€‚ b.å¦‚æœæ¶ˆæ¯é˜Ÿåˆ—ä¸­æœ‰æ¶ˆæ¯ï¼ŒnativePollOnceæ–¹æ³•ä¼šå°†æ¶ˆæ¯ä¿å­˜åœ¨mMessageæˆå‘˜ä¸­ã€‚nativePollOnceæ–¹æ³•è¿”å›åç«‹åˆ»æ£€æŸ¥mMessageæˆå‘˜æ˜¯å¦ä¸ºç©ºã€‚ c.å¦‚æœmMessageä¸ä¸ºç©ºï¼Œé‚£ä¹ˆæ£€æŸ¥å®ƒæŒ‡å®šçš„è¿è¡Œæ—¶é—´ã€‚å¦‚æœæ¯”å½“å‰æ—¶é—´è¦å‰ï¼Œé‚£ä¹ˆé©¬ä¸Šè¿”å›è¿™ä¸ªmMessageï¼Œå¦åˆ™è®¾ç½®&gt; timeoutä¸ºä¸¤è€…ä¹‹å·®ï¼Œè¿›å…¥ä¸‹ä¸€æ¬¡å¾ªç¯ã€‚ d. å¦‚æœmMessageä¸ºç©ºï¼Œé‚£ä¹ˆè®¾ç½®timeoutä¸º-1ï¼Œå³ä¸‹æ¬¡å¾ªç¯nativePollOnceæ°¸ä¹…å µå¡ã€‚ nativePollOnceæ–¹æ³•å†…éƒ¨åˆ©ç”¨epollæœºåˆ¶åœ¨ä¹‹å‰å»ºç«‹çš„ç®¡é“ä¸Šç­‰å¾…æ•°æ®å†™å…¥ã€‚æ¥æ”¶åˆ°æ•°æ®åé©¬ä¸Šè¯»å–å¹¶è¿”å›ç»“æœã€‚ è¿™é‡Œå…ˆæä¸€ä¸‹ä¸ºä»€ä¹ˆä¼šé˜»å¡ï¼Œç¨åå†Androidæ¶ˆæ¯å¤„ç†(Nativeå±‚)åˆ†æï¼Œä¸»è¦æ˜¯åº•å±‚ä½¿ç”¨äº†Linux epollï¼š Linux IOæ¨¡å¼åŠ selectã€pollã€epollè¯¦è§£ 3.2 Looper.quit()1234567public void quit() &#123; mQueue.quit(false); //æ¶ˆæ¯ç§»é™¤&#125;public void quitSafely() &#123; mQueue.quit(true); //å®‰å…¨åœ°æ¶ˆæ¯ç§»é™¤&#125; Looper.quit()æ–¹æ³•çš„å®ç°æœ€ç»ˆè°ƒç”¨çš„æ˜¯MessageQueue.quit()æ–¹æ³• 123456789101112131415161718192021MessageQueue.quit()void quit(boolean safe) &#123; // å½“mQuitAllowedä¸ºfalseï¼Œè¡¨ç¤ºä¸è¿è¡Œé€€å‡ºï¼Œå¼ºè¡Œè°ƒç”¨quit()ä¼šæŠ›å‡ºå¼‚å¸¸ if (!mQuitAllowed) &#123; throw new IllegalStateException(\"Main thread not allowed to quit.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; //é˜²æ­¢å¤šæ¬¡æ‰§è¡Œé€€å‡ºæ“ä½œ return; &#125; mQuitting = true; if (safe) &#123; removeAllFutureMessagesLocked(); //ç§»é™¤å°šæœªè§¦å‘çš„æ‰€æœ‰æ¶ˆæ¯ &#125; else &#123; removeAllMessagesLocked(); //ç§»é™¤æ‰€æœ‰çš„æ¶ˆæ¯ &#125; //mQuitting=falseï¼Œé‚£ä¹ˆè®¤å®šä¸º mPtr != 0 nativeWake(mPtr); &#125; &#125; æ¶ˆæ¯é€€å‡ºçš„æ–¹å¼ï¼š å½“safe =trueæ—¶ï¼Œåªç§»é™¤å°šæœªè§¦å‘çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œå¯¹äºæ­£åœ¨è§¦å‘çš„æ¶ˆæ¯å¹¶ä¸ç§»é™¤ï¼› å½“safe =flaseæ—¶ï¼Œç§»é™¤æ‰€æœ‰çš„æ¶ˆæ¯ å‰é¢æ„é€ äº†Looper ã€MessageQueueï¼Œå‡è®¾æ­¤æ—¶æ²¡æœ‰messageå¤„ç†ï¼ŒLooper.loop()ä¼šé˜»å¡åœ¨MessageQueue.next()ã€‚ æ¥ä¸‹æ¥è®²ä¸€ä¸‹Handlerå¦‚ä½•å‘é€å’Œå¤„ç†æ¶ˆæ¯ã€‚ å››ã€å¼‚æ­¥å¤„ç†å¤§å¸ˆ Handler()(1) æ„é€ Handler()1.1 æ— å‚æ„é€ Handler()12345678910111213141516171819202122public Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; //åŒ¿åç±»ã€å†…éƒ¨ç±»æˆ–æœ¬åœ°ç±»éƒ½å¿…é¡»ç”³æ˜ä¸ºstaticï¼Œå¦åˆ™ä¼šè­¦å‘Šå¯èƒ½å‡ºç°å†…å­˜æ³„éœ² if (FIND_POTENTIAL_LEAKS) &#123; final Class&lt;? extends Handler&gt; klass = getClass(); if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp; (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123; Log.w(TAG, \"The following Handler class should be static or leaks might occur: \" + klass.getCanonicalName()); &#125; &#125; //å¿…é¡»å…ˆæ‰§è¡ŒLooper.prepare()ï¼Œæ‰èƒ½è·å–Looperå¯¹è±¡ï¼Œå¦åˆ™ä¸ºnull. mLooper = Looper.myLooper(); //ä»å½“å‰çº¿ç¨‹çš„TLSä¸­è·å–Looperå¯¹è±¡ if (mLooper == null) &#123; throw new RuntimeException(\"\"); &#125; mQueue = mLooper.mQueue; //æ¶ˆæ¯é˜Ÿåˆ—ï¼Œæ¥è‡ªLooperå¯¹è±¡ mCallback = callback; //å›è°ƒæ–¹æ³• mAsynchronous = async; //è®¾ç½®æ¶ˆæ¯æ˜¯å¦ä¸ºå¼‚æ­¥å¤„ç†æ–¹å¼&#125; å¯¹äºHandlerçš„æ— å‚æ„é€ æ–¹æ³•ï¼Œé»˜è®¤é‡‡ç”¨å½“å‰çº¿ç¨‹TLSä¸­çš„Looperå¯¹è±¡ï¼Œå¹¶ä¸”callbackå›è°ƒæ–¹æ³•ä¸ºnullï¼Œä¸”æ¶ˆæ¯ä¸ºåŒæ­¥å¤„ç†æ–¹å¼ã€‚åªè¦æ‰§è¡Œçš„Looper.prepare()æ–¹æ³•ï¼Œé‚£ä¹ˆä¾¿å¯ä»¥è·å–æœ‰æ•ˆçš„Looperå¯¹è±¡ã€‚ 1.2 æœ‰å‚æ„é€ Handler()12345678910public Handler(Looper looper) &#123; this(looper, null, false);&#125;public Handler(Looper looper, Callback callback, boolean async) &#123; mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async;&#125; Handlerç±»åœ¨æ„é€ æ–¹æ³•ä¸­ï¼Œå¯æŒ‡å®šLooperï¼ŒCallbackå›è°ƒæ–¹æ³•ä»¥åŠæ¶ˆæ¯çš„å¤„ç†æ–¹å¼(åŒæ­¥æˆ–å¼‚æ­¥)ï¼Œå¯¹äºæ— å‚çš„handlerï¼Œé»˜è®¤æ˜¯å½“å‰çº¿ç¨‹çš„Looperã€‚ (2) ä½¿ç”¨ Handlerå‘é€æ¶ˆæ¯Handler.sendMessage()ã€Handler.post(Ruunable r)ç¬¬ä¸€ç§æ–¹å¼ï¼šsendMessage(Message msg) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//ä»è¿™é‡Œå¼€å§‹public final boolean sendEmptyMessage(int what)&#123; return sendEmptyMessageDelayed(what, 0);&#125;//å¾€ä¸‹è¿½è¸ªpublic final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis);&#125;//å¾€ä¸‹è¿½è¸ªpublic final boolean sendMessageDelayed(Message msg, long delayMillis)&#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;//å¾€ä¸‹è¿½è¸ªpublic boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; //ç›´æ¥è·å–MessageQueue MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;//è°ƒç”¨sendMessageæ–¹æ³•å…¶å®æœ€åæ˜¯è°ƒç”¨äº†enqueueMessageæ–¹æ³•private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; //ä¸ºmsg.targetèµ‹å€¼ä¸ºthisï¼Œä¹Ÿå°±æ˜¯æŠŠå½“å‰çš„handlerä½œä¸ºmsgçš„targetå±æ€§ //å¦‚æœå¤§å®¶è¿˜è®°å¾—Looperçš„loop()æ–¹æ³•ä¼šå–å‡ºæ¯ä¸ªmsgç„¶åæ‰§è¡Œmsg.target.dispatchMessage(msg)å»å¤„ç†æ¶ˆæ¯ï¼Œå…¶å®å°±æ˜¯æ´¾å‘ç»™ç›¸åº”çš„Handler msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //æœ€ç»ˆè°ƒç”¨queueçš„enqueueMessageçš„æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯è¯´handlerå‘å‡ºçš„æ¶ˆæ¯ï¼Œæœ€ç»ˆä¼šä¿å­˜åˆ°æ¶ˆæ¯é˜Ÿåˆ—ä¸­å» return queue.enqueueMessage(msg, uptimeMillis);&#125; enqueueMessage()æ–¹æ³•ä¸­å°†msg.targetèµ‹å€¼ä¸ºthisï¼Œä¹Ÿå°±æ˜¯æŠŠå½“å‰çš„handlerä½œä¸ºmsgçš„targetå±æ€§ //å¦‚æœå¤§å®¶è¿˜è®°å¾—Looperçš„loop()æ–¹æ³•ä¼šå–å‡ºæ¯ä¸ªmsgç„¶åæ‰§è¡Œmsg.target.dispatchMessage(msg)å»å¤„ç†æ¶ˆæ¯ï¼Œå…¶å®å°±æ˜¯æ´¾å‘ç»™ç›¸åº”çš„Handler 2.1 MessageQueue.enqueueMessage() æ·»åŠ ä¸€æ¡æ¶ˆæ¯åˆ°æ¶ˆæ¯é˜Ÿåˆ—1234567891011121314151617181920212223242526272829303132333435363738394041424344454647boolean enqueueMessage(Message msg, long when) &#123; // æ¯ä¸€ä¸ªæ™®é€šMessageå¿…é¡»æœ‰ä¸€ä¸ªtarget if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; //æ­£åœ¨é€€å‡ºæ—¶ï¼Œå›æ”¶msgï¼ŒåŠ å…¥åˆ°æ¶ˆæ¯æ±  msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //pä¸ºnull(ä»£è¡¨MessageQueueæ²¡æœ‰æ¶ˆæ¯ï¼‰ æˆ–è€…msgçš„è§¦å‘æ—¶é—´æ˜¯é˜Ÿåˆ—ä¸­æœ€æ—©çš„ï¼Œ åˆ™è¿›å…¥è¯¥è¯¥åˆ†æ”¯ msg.next = p; mMessages = msg; needWake = mBlocked; //å½“é˜»å¡æ—¶éœ€è¦å”¤é†’ &#125; else &#123; //å°†æ¶ˆæ¯æŒ‰æ—¶é—´é¡ºåºæ’å…¥åˆ°MessageQueueã€‚ä¸€èˆ¬åœ°ï¼Œä¸éœ€è¦å”¤é†’äº‹ä»¶é˜Ÿåˆ—ï¼Œé™¤é //æ¶ˆæ¯é˜Ÿå¤´å­˜åœ¨barrierï¼Œå¹¶ä¸”åŒæ—¶Messageæ˜¯é˜Ÿåˆ—ä¸­æœ€æ—©çš„å¼‚æ­¥æ¶ˆæ¯ã€‚ needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; //æ¶ˆæ¯æ²¡æœ‰é€€å‡ºï¼Œæˆ‘ä»¬è®¤ä¸ºæ­¤æ—¶mPtr != 0 if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; MessageQueueæ˜¯æŒ‰ç…§Messageè§¦å‘æ—¶é—´çš„å…ˆåé¡ºåºæ’åˆ—çš„ï¼Œé˜Ÿå¤´çš„æ¶ˆæ¯æ˜¯å°†è¦æœ€æ—©è§¦å‘çš„æ¶ˆæ¯ã€‚å½“æœ‰æ¶ˆæ¯éœ€è¦åŠ å…¥æ¶ˆæ¯é˜Ÿåˆ—æ—¶ï¼Œä¼šä»é˜Ÿåˆ—å¤´å¼€å§‹éå†ï¼Œç›´åˆ°æ‰¾åˆ°æ¶ˆæ¯åº”è¯¥æ’å…¥çš„åˆé€‚ä½ç½®ï¼Œä»¥ä¿è¯æ‰€æœ‰æ¶ˆæ¯çš„æ—¶é—´é¡ºåºã€‚ ç¬¬äºŒç§æ–¹å¼ï¼špost(Ruunable r) 1234public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; å…¶å®post()æ–¹æ³•æœ€ç»ˆä¹Ÿä¼šä¿å­˜åˆ°æ¶ˆæ¯é˜Ÿåˆ—ä¸­å»ï¼Œå’Œä¸Šé¢ä¸åŒçš„æ˜¯å®ƒä¼ è¿›æ¥çš„ä¸€ä¸ªRunnableå¯¹è±¡ï¼Œæ‰§è¡Œäº†getPostMessage()æ–¹æ³•ï¼Œæˆ‘ä»¬å¾€ä¸‹è¿½è¸ª 12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m;&#125; å®è´¨ä¸Šå°±æ˜¯å°†è¿™ä¸ªRunnableä¿å­˜åœ¨Messageçš„å˜é‡ä¸­ï¼Œè¿™å°±å¯¼è‡´äº†æˆ‘ä»¬ä¸‹é¢å¤„ç†æ¶ˆæ¯çš„æ—¶å€™æœ‰ä¸¤ç§ä¸åŒæ–¹æ¡ˆ Handlerå‘é€æ¶ˆæ¯æ€»ç»“ï¼š 1ã€Handlerå¯¹è±¡åœ¨åˆ›å»ºæ—¶ä¼šä¿å­˜å½“å‰çº¿ç¨‹çš„looperå’ŒMessageQueueï¼Œå¦‚æœä¼ å…¥Callbackçš„è¯ä¹Ÿä¼šä¿å­˜èµ·æ¥ã€‚2ã€ç”¨æˆ·è°ƒç”¨handlerå¯¹è±¡çš„sendMessageæ–¹æ³•ï¼Œä¼ å…¥msgå¯¹è±¡ã€‚handleré€šè¿‡è°ƒç”¨MessageQueueçš„enqueueMessageæ–¹æ³•å°†æ¶ˆæ¯å‹å…¥MessageQueueã€‚3ã€enqueueMessageæ–¹æ³•ä¼šå°†ä¼ å…¥çš„æ¶ˆæ¯å¯¹è±¡æ ¹æ®è§¦å‘æ—¶é—´ï¼ˆwhenï¼‰æ’å…¥åˆ°message queueä¸­ã€‚ç„¶ååˆ¤æ–­æ˜¯å¦è¦å”¤é†’ç­‰å¾…ä¸­çš„é˜Ÿåˆ—ã€‚a. å¦‚æœæ’åœ¨é˜Ÿåˆ—ä¸­é—´ã€‚è¯´æ˜è¯¥æ¶ˆæ¯ä¸éœ€è¦é©¬ä¸Šå¤„ç†ï¼Œä¸éœ€è¦ç”±è¿™ä¸ªæ¶ˆæ¯æ¥å”¤é†’é˜Ÿåˆ—ã€‚b. å¦‚æœæ’åœ¨é˜Ÿåˆ—å¤´éƒ¨ï¼ˆæˆ–è€…when=0ï¼‰ï¼Œåˆ™è¡¨æ˜è¦é©¬ä¸Šå¤„ç†è¿™ä¸ªæ¶ˆæ¯ã€‚å¦‚æœå½“å‰é˜Ÿåˆ—æ­£åœ¨å µå¡ï¼Œåˆ™éœ€è¦å”¤é†’å®ƒè¿›è¡Œå¤„ç†ã€‚4ã€å¦‚æœéœ€è¦å”¤é†’é˜Ÿåˆ—ï¼Œåˆ™é€šè¿‡nativeWakeæ–¹æ³•ï¼Œå¾€å‰é¢æåˆ°çš„ç®¡é“ä¸­å†™å…¥ä¸€ä¸ªâ€Wâ€å­—ç¬¦ï¼Œä»¤nativePollOnceæ–¹æ³•è¿”å›ã€‚ (4) Handlerå¤„ç†æ¶ˆæ¯åœ¨Looper.loop()ä¸­ï¼Œå½“å‘ç°æœ‰æ¶ˆæ¯æ—¶ï¼Œè°ƒç”¨æ¶ˆæ¯çš„ç›®æ ‡handlerï¼Œæ‰§è¡ŒdispatchMessage()æ–¹æ³•æ¥åˆ†å‘æ¶ˆæ¯ã€‚ 1234567891011121314151617181920212223public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; //1\\. post()æ–¹æ³•çš„å¤„ç†æ–¹æ³• handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //2\\. sendMessage()æ–¹æ³•çš„å¤„ç†æ–¹æ³• handleMessage(msg); &#125;&#125;//1\\. post()æ–¹æ³•çš„æœ€ç»ˆå¤„ç†æ–¹æ³•private static void handleCallback(Message message) &#123; message.callback.run();&#125;//2\\. sendMessage()æ–¹æ³•çš„æœ€ç»ˆå¤„ç†æ–¹æ³•public void handleMessage(Message msg) &#123;&#125; å¤„ç†æ¶ˆæ¯æ€»ç»“ï¼š Looperå¯¹è±¡çš„loopæ–¹æ³•é‡Œé¢çš„queue.nextæ–¹æ³•å¦‚æœè¿”å›äº†messageï¼Œé‚£ä¹ˆhandlerçš„dispatchMessageä¼šè¢«è°ƒç”¨ã€‚a. å¦‚æœæ–°å»ºHandlerçš„æ—¶å€™ä¼ å…¥äº†callbackå®ä¾‹ï¼Œé‚£ä¹ˆcallbackçš„handleMessageæ–¹æ³•ä¼šè¢«è°ƒç”¨ã€‚b.å¦‚æœæ˜¯é€šè¿‡postæ–¹æ³•å‘handlerä¼ å…¥runnableå¯¹è±¡çš„ï¼Œé‚£ä¹ˆrunnableå¯¹è±¡çš„runæ–¹æ³•ä¼šè¢«è°ƒç”¨ã€‚c.å…¶ä»–æƒ…å†µä¸‹ï¼Œhandleræ–¹æ³•çš„handleMessageä¼šè¢«è°ƒç”¨ã€‚ (äº”)æ€»ç»“ï¼ˆ1ï¼‰ç®€æ´æ€»ç»“å›¾ç¤ºï¼š å›¾è§£ï¼š â— Handleré€šè¿‡sendMessage()å‘é€Messageåˆ°MessageQueueé˜Ÿåˆ—ï¼›â— Looperé€šè¿‡loop()ï¼Œä¸æ–­æå–å‡ºè¾¾åˆ°è§¦å‘æ¡ä»¶çš„Messageï¼Œå¹¶å°†Messageäº¤ç»™targetæ¥å¤„ç†ï¼›â— ç»è¿‡dispatchMessage()åï¼Œäº¤å›ç»™Handlerçš„handleMessage()æ¥è¿›è¡Œç›¸åº”åœ°å¤„ç†ã€‚â— å°†MessageåŠ å…¥MessageQueueæ—¶ï¼Œå¤„å¾€ç®¡é“å†™å…¥å­—ç¬¦ï¼Œå¯ä»¥ä¼šå”¤é†’loopçº¿ç¨‹ï¼›å¦‚æœMessageQueueä¸­æ²¡æœ‰Messageï¼Œå¹¶å¤„äºIdleçŠ¶æ€ï¼Œåˆ™ä¼šæ‰§è¡ŒIdelHandleræ¥å£ä¸­çš„æ–¹æ³•ï¼Œå¾€å¾€ç”¨äºåšä¸€äº›æ¸…ç†æ€§åœ°å·¥ä½œã€‚ æ¶ˆæ¯åˆ†å‘çš„ä¼˜å…ˆçº§ï¼š 1ã€Messageçš„å›è°ƒæ–¹æ³•ï¼šmessage.callback.run()ï¼Œä¼˜å…ˆçº§æœ€é«˜ï¼› 2ã€Handlerçš„å›è°ƒæ–¹æ³•ï¼šHandler.mCallback.handleMessage(msg)ï¼Œä¼˜å…ˆçº§ä»…æ¬¡äº1ï¼› 3ã€Handlerçš„é»˜è®¤æ–¹æ³•ï¼šHandler.handleMessage(msg)ï¼Œä¼˜å…ˆçº§æœ€ä½ã€‚ è¯¦ç»†æ€»ç»“å›¾ç¤ºï¼š â— Looperè°ƒç”¨prepare()è¿›è¡Œåˆå§‹åŒ–ï¼Œåˆ›å»ºäº†ä¸€ä¸ªä¸å½“å‰çº¿ç¨‹å¯¹åº”çš„Looperå¯¹è±¡ï¼ˆé€šè¿‡ThreadLocalå®ç°ï¼‰ï¼Œå¹¶ä¸”åˆå§‹åŒ–äº†ä¸€ä¸ªä¸å½“å‰Looperå¯¹åº”çš„MessageQueueå¯¹è±¡ã€‚ â— Looperè°ƒç”¨é™æ€æ–¹æ³•loop()å¼€å§‹æ¶ˆæ¯å¾ªç¯ï¼Œé€šè¿‡MessageQueue.next()æ–¹æ³•è·å–Messageå¯¹è±¡ã€‚ â— å½“è·å–åˆ°ä¸€ä¸ªMessageå¯¹è±¡æ—¶ï¼Œè®©Messageçš„å‘é€è€…ï¼ˆtargetï¼‰å»å¤„ç†å®ƒã€‚ â— Messageå¯¹è±¡åŒ…æ‹¬æ•°æ®ï¼Œå‘é€è€…ï¼ˆHandlerï¼‰ï¼Œå¯æ‰§è¡Œä»£ç æ®µï¼ˆRunnableï¼‰ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆã€‚ â— Handlerå¯ä»¥åœ¨ä¸€ä¸ªå·²ç»Looper.prepare()çš„çº¿ç¨‹ä¸­åˆå§‹åŒ–ï¼Œå¦‚æœçº¿ç¨‹æ²¡æœ‰åˆå§‹åŒ–Looperï¼Œåˆ›å»ºHandlerå¯¹è±¡ä¼šå¤±è´¥ â— ä¸€ä¸ªçº¿ç¨‹çš„æ‰§è¡Œæµä¸­å¯ä»¥æ„é€ å¤šä¸ªHandlerå¯¹è±¡ï¼Œå®ƒä»¬éƒ½å¾€åŒä¸€ä¸ªMessageQueueä¸­å‘æ¶ˆæ¯ï¼Œæ¶ˆæ¯ä¹Ÿåªä¼šåˆ†å‘ç»™å¯¹åº”çš„Handlerå¤„ç†ã€‚ â— Handlerå°†æ¶ˆæ¯å‘é€åˆ°MessageQueueä¸­ï¼ŒMessageçš„targetåŸŸä¼šå¼•ç”¨è‡ªå·±çš„å‘é€è€…ï¼ŒLooperä»MessageQueueä¸­å–å‡ºæ¥åï¼Œå†äº¤ç»™å‘é€è¿™ä¸ªMessageçš„Handlerå»å¤„ç†ã€‚ â— Messageå¯ä»¥ç›´æ¥æ·»åŠ ä¸€ä¸ªRunnableå¯¹è±¡ï¼Œå½“è¿™æ¡æ¶ˆæ¯è¢«å¤„ç†çš„æ—¶å€™ï¼Œç›´æ¥æ‰§è¡ŒRunnable.run()æ–¹æ³•ã€‚ â…¡ã€Androidæ¶ˆæ¯æœºåˆ¶(Nativeå±‚)åœ¨å‰é¢è®²è§£äº†Javaå±‚çš„æ¶ˆæ¯å¤„ç†æœºåˆ¶ï¼Œå…¶ä¸­MessageQueueç±»é‡Œé¢æ¶‰åŠåˆ°å¤šä¸ªnativeæ–¹æ³•ï¼Œé™¤äº†MessageQueueçš„nativeæ–¹æ³•ï¼Œnativeå±‚æœ¬èº«ä¹Ÿæœ‰ä¸€å¥—å®Œæ•´çš„æ¶ˆæ¯æœºåˆ¶ï¼Œç”¨äºå¤„ç†nativeçš„æ¶ˆæ¯ã€‚åœ¨æ•´ä¸ªæ¶ˆæ¯æœºåˆ¶ä¸­ï¼Œè€ŒMessageQueueæ˜¯è¿æ¥Javaå±‚å’ŒNativeå±‚çš„çº½å¸¦ï¼Œæ¢è¨€ä¹‹ï¼ŒJavaå±‚å¯ä»¥å‘MessageQueueæ¶ˆæ¯é˜Ÿåˆ—ä¸­æ·»åŠ æ¶ˆæ¯ï¼ŒNativeå±‚ä¹Ÿå¯ä»¥å‘MessageQueueæ¶ˆæ¯é˜Ÿåˆ—ä¸­æ·»åŠ æ¶ˆæ¯ã€‚ Nativeå±‚ç±»çš„å…³ç³»å›¾ï¼š (ä¸€) MessageQueue åˆå§‹åŒ–ï¼ˆNative å±‚ï¼‰æ¥ç€ä»Javaå±‚MessageQueueåˆå§‹åŒ–å¼€å§‹åˆ†æï¼š Step 1ï¼šMessageQueue()12345MessageQueue(boolean quitAllowed) &#123; mQuitAllowed = quitAllowed; //é€šè¿‡nativeæ–¹æ³•åˆå§‹åŒ–æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå…¶ä¸­mPtræ˜¯ä¾›nativeä»£ç ä½¿ç”¨ mPtr = nativeInit();&#125; Step 2ï¼šandroid_os_MessageQueue_nativeInit()12345678910==&gt; android_os_MessageQueue.cppstatic jlong android_os_MessageQueue_nativeInit(JNIEnv* env, jclass clazz) &#123; NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); //åˆå§‹åŒ–nativeæ¶ˆæ¯é˜Ÿåˆ— ã€3ã€‘ if (!nativeMessageQueue) &#123; jniThrowRuntimeException(env, \"Unable to allocate native queue\"); return 0; &#125; nativeMessageQueue-&gt;incStrong(env); return reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);&#125; åœ¨nativeInitä¸­ï¼Œnewäº†ä¸€ä¸ªNativeå±‚çš„MessageQueueçš„å¯¹è±¡ Step 3ï¼šNativeMessageQueue()123456789==&gt; android_os_MessageQueue.cppNativeMessageQueue::NativeMessageQueue() : mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123; mLooper = Looper::getForThread(); //è·å–TLSä¸­çš„Looperå¯¹è±¡ if (mLooper == NULL) &#123; mLooper = new Looper(false); //åˆ›å»ºnativeå±‚çš„Looper Looper::setForThread(mLooper); //ä¿å­˜nativeå±‚çš„Looperåˆ°TLSä¸­ &#125;&#125; åœ¨NativeMessageQueueçš„æ„é€ å‡½æ•°ä¸­è·å¾—äº†ä¸€ä¸ªNativeå±‚çš„Looperå¯¹è±¡ï¼ŒNativeå±‚çš„Looperä¹Ÿä½¿ç”¨äº†çº¿ç¨‹æœ¬åœ°å­˜å‚¨ï¼Œæ³¨æ„new Looperæ—¶ä¼ å…¥äº†å‚æ•°falseã€‚ Looper::getForThread()ï¼ŒåŠŸèƒ½ç±»æ¯”äºJavaå±‚çš„Looper.myLooper(); Looper::setForThread(mLooper)ï¼ŒåŠŸèƒ½ç±»æ¯”äºJavaå±‚çš„ThreadLocal.set(); MessageQueueæ˜¯åœ¨Javaå±‚ä¸Nativeå±‚æœ‰ç€ç´§å¯†çš„è”ç³»ï¼Œä½†æ˜¯æ­¤æ¬¡Nativeå±‚çš„Looperä¸Javaå±‚çš„Looperæ²¡æœ‰ä»»ä½•çš„å…³ç³»ï¼Œå¯ä»¥å‘ç°nativeåŸºæœ¬ç­‰ä»·äºç”¨C++é‡å†™äº†Javaçš„Looperé€»è¾‘ï¼Œæ•…å¯ä»¥å‘ç°å¾ˆå¤šåŠŸèƒ½ç±»ä¼¼çš„åœ°æ–¹ã€‚ (äºŒ) Looperåˆå§‹åŒ–ï¼ˆNativeå±‚ï¼‰1234567891011121314151617181920212223242526272829303132Looper::Looper(bool allowNonCallbacks) : mAllowNonCallbacks(allowNonCallbacks), mSendingMessage(false), mPolling(false), mEpollFd(-1), mEpollRebuildRequired(false), mNextRequestSeq(0), mResponseIndex(0), mNextMessageUptime(LLONG_MAX) &#123; mWakeEventFd = eventfd(0, EFD_NONBLOCK); //æ„é€ å”¤é†’äº‹ä»¶çš„fd AutoMutex _l(mLock); rebuildEpollLocked(); //é‡å»ºEpolläº‹ä»¶&#125;void Looper::rebuildEpollLocked() &#123; if (mEpollFd &gt;= 0) &#123; close(mEpollFd); //å…³é—­æ—§çš„epollå®ä¾‹ &#125; mEpollFd = epoll_create(EPOLL_SIZE_HINT); //åˆ›å»ºæ–°çš„epollå®ä¾‹ï¼Œå¹¶æ³¨å†Œwakeç®¡é“ struct epoll_event eventItem; memset(&amp; eventItem, 0, sizeof(epoll_event)); //æŠŠæœªä½¿ç”¨çš„æ•°æ®åŒºåŸŸè¿›è¡Œç½®0æ“ä½œ eventItem.events = EPOLLIN; //å¯è¯»äº‹ä»¶ eventItem.data.fd = mWakeEventFd; //å°†å”¤é†’äº‹ä»¶(mWakeEventFd)æ·»åŠ åˆ°epollå®ä¾‹(mEpollFd) int result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp; eventItem); for (size_t i = 0; i &lt; mRequests.size(); i++) &#123; const Request&amp; request = mRequests.valueAt(i); struct epoll_event eventItem; request.initEventItem(&amp;eventItem); //å°†requesté˜Ÿåˆ—çš„äº‹ä»¶ï¼Œåˆ†åˆ«æ·»åŠ åˆ°epollå®ä¾‹ int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d while rebuilding epoll set, errno=%d\", request.fd, errno); &#125; &#125;&#125; é€šè¿‡eventfdåˆ›å»ºmWakeEventFdç”¨äºçº¿ç¨‹é—´é€šä¿¡å»å”¤é†’Looperçš„ï¼Œå½“éœ€è¦å”¤é†’Looperæ—¶ï¼Œå°±å¾€é‡Œé¢å†™1 åˆ›å»ºç”¨äºç›‘å¬epoll_eventçš„mEpollFdï¼Œå¹¶åˆå§‹åŒ–mEpollFdè¦ç›‘å¬çš„epoll_eventç±»å‹ é€šè¿‡epoll_ctlå°†mWakeEventFdæ³¨å†Œåˆ°mEpollFdä¸­ï¼Œå½“mWakeEventFdæœ‰äº‹ä»¶å¯è¯»åˆ™å”¤é†’Looper å¦‚æœmRequestsä¸ä¸ºç©ºçš„è¯ï¼Œè¯´æ˜å‰é¢æ³¨å†Œäº†æœ‰è¦ç›‘å¬çš„fdï¼Œåˆ™éå†mRequestsä¸­çš„Requestï¼Œå°†å®ƒåˆå§‹åŒ–ä¸ºepoll_eventå¹¶é€šè¿‡epoll_ctlæ³¨å†Œåˆ°mEpollFdä¸­ï¼Œå½“æœ‰å¯è¯»äº‹ä»¶åŒæ ·å”¤é†’Looper (ä¸‰) nativePollOnce()æˆ‘ä»¬ä»å‰é¢åˆ†æçŸ¥é“ï¼ŒLooper.loop()æ–¹æ³•è¢«è°ƒç”¨åï¼Œä¼šå¯åŠ¨ä¸€ä¸ªæ— é™å¾ªç¯ï¼Œè€Œåœ¨è¿™ä¸ªå¾ªç¯ä¸­ï¼Œè°ƒç”¨äº†MessageQueueçš„next()æ–¹æ³•ä»¥è·å–ä¸‹ä¸€æ¡æ¶ˆæ¯ï¼Œè€Œnext()æ–¹æ³•ä¸­ä¼šé¦–å…ˆè°ƒç”¨nativePollOnce()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•çš„ä½œç”¨åœ¨ä¹‹å‰è¯´è¿‡æ˜¯é˜»å¡ï¼Œè¾¾åˆ°è¶…æ—¶æ—¶é—´æˆ–æœ‰æ–°çš„æ¶ˆæ¯åˆ°è¾¾æ—¶å¾—åˆ°eventFdçš„é€šçŸ¥å†å”¤é†’æ¶ˆæ¯é˜Ÿåˆ—ï¼Œå…¶å®è¿™ä¸ªæ–¹æ³•ä¹Ÿæ˜¯nativeæ¶ˆæ¯å¤„ç†çš„å¼€å§‹ã€‚ nativePollOnceç”¨äºæå–æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ï¼Œæå–æ¶ˆæ¯çš„è°ƒç”¨é“¾ï¼Œå¦‚ä¸‹ï¼š ä¸‹é¢æ¥è¿›ä¸€æ­¥æ¥çœ‹çœ‹è°ƒç”¨é“¾çš„è¿‡ç¨‹ï¼š Step 1ï¼šMessageQueue.next()12345678910111213==&gt; MessageQueue.javaMessage next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; for (;;) &#123; ... nativePollOnce(ptr, nextPollTimeoutMillis); //é˜»å¡æ“ä½œ ... &#125; Step 2ï¼šandroid_os_MessageQueue_nativePollOnce()1234567==&gt; android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativePollOnce(JNIEnv* env, jobject obj, jlong ptr, jint timeoutMillis) &#123; //å°†Javaå±‚ä¼ é€’ä¸‹æ¥çš„mPtrè½¬æ¢ä¸ºnativeMessageQueue NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);&#125; Step 3ï¼šNativeMessageQueue::pollOnce()1234567891011121314==&gt; android_os_MessageQueue.cppvoid NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, int timeoutMillis) &#123; mPollEnv = env; mPollObj = pollObj; mLooper-&gt;pollOnce(timeoutMillis); mPollObj = NULL; mPollEnv = NULL; if (mExceptionObj) &#123; env-&gt;Throw(mExceptionObj); env-&gt;DeleteLocalRef(mExceptionObj); mExceptionObj = NULL; &#125;&#125; Step 4ï¼šLooper::pollOnce()1234567891011121314151617181920212223242526272829==&gt; Looper.cppint Looper::pollOnce(int timeoutMillis, int* outFd, int* outEvents, void** outData) &#123; int result = 0; for (;;) &#123; // å…ˆå¤„ç†æ²¡æœ‰Callbackæ–¹æ³•çš„ Responseäº‹ä»¶ while (mResponseIndex &lt; mResponses.size()) &#123; const Response&amp; response = mResponses.itemAt(mResponseIndex++); int ident = response.request.ident; if (ident &gt;= 0) &#123; //identå¤§äº0ï¼Œåˆ™è¡¨ç¤ºæ²¡æœ‰callback, å› ä¸ºPOLL_CALLBACK = -2, int fd = response.request.fd; int events = response.events; void* data = response.request.data; if (outFd != NULL) *outFd = fd; if (outEvents != NULL) *outEvents = events; if (outData != NULL) *outData = data; return ident; &#125; &#125; if (result != 0) &#123; if (outFd != NULL) *outFd = 0; if (outEvents != NULL) *outEvents = 0; if (outData != NULL) *outData = NULL; return result; &#125; // å†å¤„ç†å†…éƒ¨è½®è¯¢ result = pollInner(timeoutMillis); &#125;&#125; Step 5 ï¼šLooper::pollInner()ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102==&gt; Looper.cppvoid Looper::awoken() &#123; uint64_t counter; //ä¸æ–­è¯»å–ç®¡é“æ•°æ®ï¼Œç›®çš„å°±æ˜¯ä¸ºäº†æ¸…ç©ºç®¡é“å†…å®¹ TEMP_FAILURE_RETRY(read(mWakeEventFd, &amp;counter, sizeof(uint64_t)));&#125;int Looper::pollInner(int timeoutMillis) &#123; ... int result = POLL_WAKE; mResponses.clear(); mResponseIndex = 0; mPolling = true; //å³å°†å¤„äºidleçŠ¶æ€ struct epoll_event eventItems[EPOLL_MAX_EVENTS]; //fdæœ€å¤§ä¸ªæ•°ä¸º16 //ç­‰å¾…äº‹ä»¶å‘ç”Ÿæˆ–è€…è¶…æ—¶ï¼Œåœ¨nativeWake()æ–¹æ³•ï¼Œå‘ç®¡é“å†™ç«¯å†™å…¥å­—ç¬¦ï¼Œåˆ™è¯¥æ–¹æ³•ä¼šè¿”å›ï¼› int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis); mPolling = false; //ä¸å†å¤„äºidleçŠ¶æ€ mLock.lock(); //è¯·æ±‚é” if (mEpollRebuildRequired) &#123; mEpollRebuildRequired = false; rebuildEpollLocked(); // epollé‡å»ºï¼Œç›´æ¥è·³è½¬Done; goto Done; &#125; if (eventCount &lt; 0) &#123; if (errno == EINTR) &#123; goto Done; &#125; result = POLL_ERROR; // epolläº‹ä»¶ä¸ªæ•°å°äº0ï¼Œå‘ç”Ÿé”™è¯¯ï¼Œç›´æ¥è·³è½¬Done; goto Done; &#125; if (eventCount == 0) &#123; //epolläº‹ä»¶ä¸ªæ•°ç­‰äº0ï¼Œå‘ç”Ÿè¶…æ—¶ï¼Œç›´æ¥è·³è½¬Done; result = POLL_TIMEOUT; goto Done; &#125; //å¾ªç¯éå†ï¼Œå¤„ç†æ‰€æœ‰çš„äº‹ä»¶ for (int i = 0; i &lt; eventCount; i++) &#123; int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); //å·²ç»å”¤é†’äº†ï¼Œåˆ™è¯»å–å¹¶æ¸…ç©ºç®¡é“æ•°æ® &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; //å¤„ç†requestï¼Œç”Ÿæˆå¯¹åº”çš„reponseå¯¹è±¡ï¼Œpushåˆ°å“åº”æ•°ç»„ pushResponse(events, mRequests.valueAt(requestIndex)); &#125; &#125; &#125;Done: ; //å†å¤„ç†Nativeçš„Messageï¼Œè°ƒç”¨ç›¸åº”å›è°ƒæ–¹æ³• mNextMessageUptime = LLONG_MAX; while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); if (messageEnvelope.uptime &lt;= now) &#123; &#123; sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); //é‡Šæ”¾é” handler-&gt;handleMessage(message); // å¤„ç†æ¶ˆæ¯äº‹ä»¶ &#125; mLock.lock(); //è¯·æ±‚é” mSendingMessage = false; result = POLL_CALLBACK; // å‘ç”Ÿå›è°ƒ &#125; else &#123; mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; mLock.unlock(); //é‡Šæ”¾é” //å¤„ç†å¸¦æœ‰Callback()æ–¹æ³•çš„Responseäº‹ä»¶ï¼Œæ‰§è¡ŒReponseç›¸åº”çš„å›è°ƒæ–¹æ³• for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; // å¤„ç†è¯·æ±‚çš„å›è°ƒæ–¹æ³• int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); //ç§»é™¤fd &#125; response.request.callback.clear(); //æ¸…é™¤reponseå¼•ç”¨çš„å›è°ƒæ–¹æ³• result = POLL_CALLBACK; // å‘ç”Ÿå›è°ƒ &#125; &#125; return result;&#125; pollInner()æ–¹æ³•æ¯”è¾ƒé•¿ä¹Ÿæ˜¯nativeæ¶ˆæ¯æœºåˆ¶çš„æ ¸å¿ƒï¼Œæˆ‘ä»¬æ‹†æˆå‡ ä¸ªéƒ¨åˆ†çœ‹ã€‚ 5.1 Request ä¸ Response12345678910111213141516171819202122232425262728293031323334int result = POLL_WAKE;mResponses.clear();mResponseIndex = 0;mPolling = true;struct epoll_event eventItems[EPOLL_MAX_EVENTS];int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);// ç¬¬7è¡ŒmPolling = false;mLock.lock();...for (int i = 0; i &lt; eventCount; i++) &#123;//ç¬¬11è¡Œ int fd = eventItems[i].data.fd; uint32_t epollEvents = eventItems[i].events; if (fd == mWakeEventFd) &#123; if (epollEvents &amp; EPOLLIN) &#123; awoken(); &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on wake event fd.\", epollEvents); &#125; &#125; else &#123; ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &gt;= 0) &#123; int events = 0; if (epollEvents &amp; EPOLLIN) events |= EVENT_INPUT; if (epollEvents &amp; EPOLLOUT) events |= EVENT_OUTPUT; if (epollEvents &amp; EPOLLERR) events |= EVENT_ERROR; if (epollEvents &amp; EPOLLHUP) events |= EVENT_HANGUP; pushResponse(events, mRequests.valueAt(requestIndex));// ç¬¬28è¡Œ &#125; else &#123; ALOGW(\"Ignoring unexpected epoll events 0x%x on fd %d that is \" \"no longer registered.\", epollEvents, fd); &#125; &#125;&#125; å½“ç¬¬7è¡Œç³»ç»Ÿè°ƒç”¨epoll_wait()è¿”å›æ—¶ï¼Œè¯´æ˜å› æ³¨å†Œçš„fdæœ‰æ¶ˆæ¯æˆ–è¾¾åˆ°è¶…æ—¶ï¼Œåœ¨ç¬¬11è¡Œå°±å¯¹æ”¶åˆ°çš„å”¤é†’eventsè¿›è¡Œéå†ï¼Œé¦–å…ˆåˆ¤æ–­æœ‰æ¶ˆæ¯çš„fdæ˜¯ä¸æ˜¯ç”¨äºå”¤é†’çš„mWakeEventFdï¼Œå¦‚æœä¸æ˜¯çš„è¯ï¼Œè¯´æ˜æ˜¯ç³»ç»Ÿè°ƒç”¨addFd()æ–¹æ³•è®¾ç½®çš„è‡ªå®šä¹‰fdï¼ˆåé¢ä¼šè®²ï¼‰ã€‚é‚£ä¹ˆæˆ‘ä»¬éœ€è¦å¯¹è¿™ä¸ªäº‹ä»¶ä½œå‡ºå“åº”ã€‚ ç¬¬21åˆ°28è¡Œå°±å¯¹è¿™ä¸ªeventåšå¤„ç†ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬ä»¥è¿™ä¸ªfdä¸ºkeyä»mRequestsä¸­æ‰¾åˆ°ä»–çš„ç´¢å¼•ï¼Œè¿™ä¸ªmRequestsæ˜¯æˆ‘ä»¬åœ¨addFd()æ–¹æ³•ä¸€å¹¶æ³¨å†Œçš„ä»¥fdä¸ºkeyï¼ŒRequestä¸ºvalueçš„æ˜ å°„è¡¨ã€‚æ‰¾åˆ°requestä¹‹åï¼Œ28è¡Œè°ƒç”¨pushResponse()æ–¹æ³•å»å»ºç«‹responseï¼š 123456void Looper::pushResponse(int events, const Request&amp; request) &#123; Response response; response.events = events; response.request = request; mResponses.push(response);&#125; ç°åœ¨æˆ‘ä»¬è¦å¤„ç†çš„ä»»åŠ¡å·²ç»è¢«å°è£…æˆäº†ä¸€ä¸ªResponseå¯¹è±¡ï¼Œç­‰å¾…è¢«å¤„ç†ï¼Œé‚£ä¹ˆçœŸæ­£çš„å¤„ç†åœ¨å“ªé‡Œå‘¢ï¼Ÿ åœ¨ä¸Šé¢çš„ä»£ç ä¸å¤„ç†responseçš„ä»£ç ä¸­é—´å¤¹ç€çš„æ˜¯å¤„ç†MessageEnvelopeçš„ä»£ç ï¼Œæˆ‘ä»¬åé¢å†è®²è¿™æ®µï¼Œç°åœ¨åˆ°å¤„ç†responseçš„ä»£ç ï¼š 1234567891011121314 for (size_t i = 0; i &lt; mResponses.size(); i++) &#123; Response&amp; response = mResponses.editItemAt(i); if (response.request.ident == POLL_CALLBACK) &#123; int fd = response.request.fd; int events = response.events; void* data = response.request.data; int callbackResult = response.request.callback-&gt;handleEvent(fd, events, data); if (callbackResult == 0) &#123; removeFd(fd, response.request.seq); &#125; response.request.callback.clear(); result = POLL_CALLBACK; &#125;&#125; éå†æ‰€æœ‰responseå¯¹è±¡ï¼Œå–å‡ºä¹‹å‰æ³¨å†Œçš„requestå¯¹è±¡çš„ä¿¡æ¯ï¼Œç„¶åè°ƒç”¨äº†request.callback-&gt;handleEvent()æ–¹æ³•è¿›è¡Œå›è°ƒï¼Œå¦‚æœè¯¥å›è°ƒè¿”å›0ï¼Œåˆ™è°ƒç”¨removeFd()æ–¹æ³•å–æ¶ˆè¿™ä¸ªfdçš„æ³¨å†Œã€‚ å†æ¢³ç†ä¸€éè¿™ä¸ªè¿‡ç¨‹ï¼šæ³¨å†Œçš„è‡ªå®šä¹‰fdè¢«æ¶ˆæ¯å”¤é†’ï¼Œä»mRequestsä¸­ä»¥fdä¸ºkeyæ‰¾åˆ°å¯¹åº”çš„æ³¨å†Œå¥½çš„requestå¯¹è±¡ç„¶åç”Ÿæˆresponseå¯¹è±¡ï¼Œåœ¨MessageEnvelopå¤„ç†å®Œæ¯•ä¹‹åå¤„ç†responseï¼Œè°ƒç”¨requestä¸­çš„callbackçš„handleEvent()æ–¹æ³•ã€‚ é‚£ä¹ˆaddFd()æ³¨å†Œè‡ªå®šä¹‰fdä¸removeFd()å–æ¶ˆæ³¨å†Œæ˜¯å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿ 5.2 addFd()12345678910111213141516171819202122232425262728293031323334353637383940414243444546int Looper::addFd(int fd, int ident, int events, const sp&lt;LooperCallback&gt;&amp; callback, void* data) &#123;...&#123; // acquire lock AutoMutex _l(mLock); Request request;//ç¬¬6-13è¡Œ request.fd = fd; request.ident = ident; request.events = events; request.seq = mNextRequestSeq++; request.callback = callback; request.data = data; // ç¬¬6-13è¡Œ end if (mNextRequestSeq == -1) mNextRequestSeq = 0; // reserve sequence number -1 struct epoll_event eventItem; request.initEventItem(&amp;eventItem); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; // ç¬¬19è¡Œ int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); //ç¬¬20è¡Œ if (epollResult &lt; 0) &#123; ALOGE(\"Error adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; mRequests.add(fd, request); //ç¬¬25è¡Œ &#125; else &#123; int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_MOD, fd, &amp; eventItem); // ç¬¬27è¡Œ if (epollResult &lt; 0) &#123; if (errno == ENOENT) &#123; epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp; eventItem); if (epollResult &lt; 0) &#123; ALOGE(\"Error modifying or adding epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; scheduleEpollRebuildLocked(); &#125; else &#123; ALOGE(\"Error modifying epoll events for fd %d: %s\", fd, strerror(errno)); return -1; &#125; &#125; mRequests.replaceValueAt(requestIndex, request); &#125;&#125; // release lockreturn 1;&#125; ç¬¬6-13è¡Œä½¿ç”¨ä¼ å…¥çš„å‚æ•°åˆå§‹åŒ–äº†requestå¯¹è±¡ï¼Œç„¶å16è¡Œç”±requestæ¥åˆå§‹åŒ–æ³¨å†Œepollä½¿ç”¨çš„eventã€‚19è¡Œæ ¹æ®mRequests.indexOfKey()æ–¹æ³•å–å‡ºçš„å€¼æ¥åˆ¤æ–­fdæ˜¯å¦å·²ç»æ³¨å†Œï¼Œå¦‚æœæœªæ³¨å†Œï¼Œåˆ™åœ¨20è¡Œè¿›è¡Œç³»ç»Ÿè°ƒç”¨epoll_ctl()æ³¨å†Œæ–°ç›‘å¬å¹¶åœ¨25è¡Œå°†fdä¸requestå­˜å…¥mRequestï¼Œå¦‚æœå·²æ³¨å†Œï¼Œåˆ™åœ¨27è¡Œæ›´æ–°æ³¨å†Œå¹¶åœ¨42è¡Œæ›´æ–°requestã€‚ è¿™å°±æ˜¯è‡ªå®šä¹‰fdè®¾ç½®çš„è¿‡ç¨‹ï¼šä¿å­˜requestå¹¶ä½¿ç”¨epoll_ctlç³»ç»Ÿè°ƒç”¨æ³¨å†Œfdçš„ç›‘å¬ã€‚ 5.3 removeFd()12345678910111213141516171819202122232425int Looper::removeFd(int fd, int seq) &#123; &#123; // acquire lock AutoMutex _l(mLock); ssize_t requestIndex = mRequests.indexOfKey(fd); if (requestIndex &lt; 0) &#123; return 0; &#125; if (seq != -1 &amp;&amp; mRequests.valueAt(requestIndex).seq != seq) &#123; return 0; &#125; mRequests.removeItemsAt(requestIndex); int epollResult = epoll_ctl(mEpollFd, EPOLL_CTL_DEL, fd, NULL); if (epollResult &lt; 0) &#123; if (seq != -1 &amp;&amp; (errno == EBADF || errno == ENOENT)) &#123; scheduleEpollRebuildLocked(); &#125; else &#123; ALOGE(\"Error removing epoll events for fd %d: %s\", fd, strerror(errno)); scheduleEpollRebuildLocked(); return -1; &#125; &#125; &#125; // release lock return 1;&#125; è§£é™¤çš„è¿‡ç¨‹ç›¸åï¼Œåœ¨ç¬¬11è¡Œåˆ é™¤mRequestsä¸­çš„é”®å€¼å¯¹ï¼Œç„¶ååœ¨ç¬¬13è¡Œç³»ç»Ÿè°ƒç”¨epoll_ctl()è§£é™¤fdçš„epollæ³¨å†Œã€‚ MessageEnvelopeæ¶ˆæ¯å¤„ç†ä¹‹å‰è¯´åˆ°ï¼Œåœ¨requestç”Ÿæˆresponseåˆ°responseçš„å¤„ç†ä¸­é—´æœ‰ä¸€æ®µä»£ç æ‰§è¡Œäº†MessageEnvelopæ¶ˆæ¯çš„å¤„ç†ï¼Œè¿™ä¸ªé¡ºåºä¿è¯äº†MessageEnvelopä¼˜å…ˆäºfdå¼•èµ·çš„requestçš„å¤„ç†ã€‚ ç°åœ¨æˆ‘ä»¬æ¥çœ‹è¿™æ®µä»£ç ï¼š 12345678910111213141516171819202122mNextMessageUptime = LLONG_MAX;while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); // ç¬¬4è¡Œ if (messageEnvelope.uptime &lt;= now) &#123; &#123; // obtain handler sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; Message message = messageEnvelope.message; mMessageEnvelopes.removeAt(0); mSendingMessage = true; mLock.unlock(); handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = POLL_CALLBACK; &#125; else &#123; mNextMessageUptime = messageEnvelope.uptime; break; &#125;&#125; å¯ä»¥çœ‹åˆ°mMessageEnvelopeså®¹å™¨ä¸­å­˜å‚¨äº†æ‰€æœ‰çš„æ¶ˆæ¯ï¼Œç¬¬4è¡Œä»é¦–ä½ç½®å–å‡ºä¸€æ¡æ¶ˆæ¯ï¼Œéšåè¿›è¡Œæ—¶é—´åˆ¤æ–­ï¼Œå¦‚æœæ—¶é—´åˆ°è¾¾ï¼Œå…ˆç§»å‡ºå®¹å™¨ï¼Œä¸javaå±‚æ¯”è¾ƒç›¸ä¼¼éƒ½æ˜¯è°ƒç”¨äº†handlerçš„handleMessage()æ¥è¿›è¡Œæ¶ˆæ¯çš„å¤„ç†ã€‚ é‚£ä¹ˆMessageEnvelopeæ˜¯å¦‚ä½•æ·»åŠ çš„å‘¢ï¼Ÿ Native Looperæä¾›äº†ä¸€å¥—ä¸javaå±‚MessageQueueç±»ä¼¼çš„æ–¹æ³•ï¼Œç”¨äºæ·»åŠ MessageEnvelopeï¼š 12345678910111213141516171819202122void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; // acquire lock AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); if (mSendingMessage) &#123; return; &#125; &#125; // release lock if (i == 0) &#123; wake(); &#125;&#125; å°ç»“: ç°åœ¨æˆ‘ä»¬çœ‹åˆ°ï¼Œå…¶å®Nativeä¸­çš„æ¶ˆæ¯æœºåˆ¶æœ‰ä¸¤ä¸ªæ–¹é¢ï¼Œä¸€æ–¹é¢æ˜¯é€šè¿‡addFd()æ³¨å†Œçš„è‡ªå®šä¹‰fdè§¦å‘æ¶ˆæ¯å¤„ç†ï¼Œé€šè¿‡mRequestsä¿å­˜çš„requestå¯¹è±¡ä¸­çš„callbackè¿›è¡Œæ¶ˆæ¯å¤„ç†ã€‚å¦ä¸€æ–¹é¢æ˜¯é€šè¿‡ä¸javaå±‚ç±»ä¼¼çš„MessageEnvelopæ¶ˆæ¯å¯¹è±¡è¿›è¡Œå¤„ç†ï¼Œè°ƒç”¨çš„æ˜¯è¯¥å¯¹è±¡handleråŸŸçš„handleMessage()æ–¹æ³•ï¼Œä¸javaå±‚éå¸¸ç±»ä¼¼ã€‚ä¼˜å…ˆçº§æ˜¯å…ˆå¤„ç†MessageEnvelopå†å¤„ç†requestã€‚ ä¸€äº›æ€è€ƒ ç°åœ¨æ¶ˆæ¯æœºåˆ¶å…¨éƒ¨å†…å®¹åˆ†æä¸‹æ¥ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°androidçš„æ¶ˆæ¯æœºåˆ¶ä¸ç®—å¤æ‚ï¼Œåˆ†ä¸ºnativeä¸javaä¸¤ä¸ªéƒ¨åˆ†ï¼Œè¿™ä¸¤ä¸ªéƒ¨åˆ†åˆ†åˆ«æœ‰è‡ªå·±çš„æ¶ˆæ¯å¤„ç†æœºåˆ¶ï¼Œå…¶ä¸­å…³é”®çš„è¶…æ—¶ä¸å”¤é†’éƒ¨åˆ†æ˜¯å€ŸåŠ©äº†linuxç³»ç»Ÿepollæœºåˆ¶æ¥å®ç°çš„ã€‚ è¿æ¥javaä¸nativeå±‚æ¶ˆæ¯å¤„ç†è¿‡ç¨‹çš„æ˜¯next()æ–¹æ³•ä¸­çš„nativePollOnce()ï¼Œjavaå±‚æ¶ˆæ¯å¾ªç¯å…ˆè°ƒç”¨å®ƒï¼Œè‡ªèº«é˜»å¡ï¼Œè¿›å…¥nativeçš„æ¶ˆæ¯å¤„ç†ï¼Œåœ¨nativeæ¶ˆæ¯å¤„ç†å®Œæ¯•åè¿”å›ï¼Œå†è¿›è¡Œjavaå±‚çš„æ¶ˆæ¯å¤„ç†ï¼Œæ­£æ˜¯å› ä¸ºå¦‚æ­¤ï¼Œå¦‚æœæˆ‘ä»¬åœ¨å¤„ç†javaå±‚æ¶ˆæ¯çš„æ—¶å€™æ‰§è¡Œäº†è€—æ—¶æˆ–é˜»å¡çš„ä»»åŠ¡ï¼ˆç”šè‡³é˜»å¡äº†æ•´ä¸ªä¸»çº¿ç¨‹ï¼‰ï¼Œæ•´ä¸ªjavaå±‚çš„æ¶ˆæ¯å¾ªç¯å°±ä¼šé˜»å¡ï¼Œä¹Ÿæ— æ³•è¿›ä¸€æ­¥è¿›å…¥nativeå±‚çš„æ¶ˆæ¯å¤„ç†ï¼Œä¹Ÿå°±æ— æ³•å“åº”ä¾‹å¦‚è§¦æ‘¸äº‹ä»¶è¿™æ ·çš„æ¶ˆæ¯ï¼Œå¯¼è‡´ANRçš„å‘ç”Ÿã€‚è¿™ä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¸åº”åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œè¿™ç±»ä»»åŠ¡çš„åŸå› ã€‚ (å››) å”¤é†’ nativeWake()åœ¨æ·»åŠ æ¶ˆæ¯åˆ°æ¶ˆæ¯é˜Ÿåˆ—enqueueMessage(), æˆ–è€…æŠŠæ¶ˆæ¯ä»æ¶ˆæ¯é˜Ÿåˆ—ä¸­å…¨éƒ¨ç§»é™¤quit()ï¼Œå†æœ‰éœ€è¦æ—¶éƒ½ä¼šè°ƒç”¨ nativeWakeæ–¹æ³•ã€‚åŒ…å«å”¤é†’è¿‡ç¨‹çš„æ·»åŠ æ¶ˆæ¯çš„è°ƒç”¨é“¾ï¼ŒnativeWakeç”¨äºå”¤é†’åŠŸèƒ½ï¼Œå¦‚ä¸‹ï¼š ä¸‹é¢æ¥è¿›ä¸€æ­¥æ¥çœ‹çœ‹è°ƒç”¨é“¾çš„è¿‡ç¨‹ï¼š Step 1 ï¼šMessageQueue.enqueueMessage()12345678==&gt; MessageQueue.javaboolean enqueueMessage(Message msg, long when) &#123; ... //å°†MessageæŒ‰æ—¶é—´é¡ºåºæ’å…¥MessageQueue if (needWake) &#123; nativeWake(mPtr); &#125;&#125; å¾€æ¶ˆæ¯é˜Ÿåˆ—æ·»åŠ Messageæ—¶ï¼Œéœ€è¦æ ¹æ®mBlockedæƒ…å†µæ¥å†³å®šæ˜¯å¦éœ€è¦è°ƒç”¨nativeWakeã€‚ Step 2 ï¼šandroid_os_MessageQueue_nativeWake()123456==&gt; android_os_MessageQueue.cppstatic void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125; Step 3 ï¼šNativeMessageQueue::wake()12345==&gt; android_os_MessageQueue.cppvoid NativeMessageQueue::wake() &#123; mLooper-&gt;wake();&#125; Step 4 ï¼šLooper::wake()12345678910111213==&gt; Looper.cppvoid Looper::wake() &#123; uint64_t inc = 1; // å‘ç®¡é“mWakeEventFdå†™å…¥å­—ç¬¦1 ssize_t nWrite = TEMP_FAILURE_RETRY(write(mWakeEventFd, &amp;inc, sizeof(uint64_t))); if (nWrite != sizeof(uint64_t)) &#123; if (errno != EAGAIN) &#123; ALOGW(\"Could not write wake signal, errno=%d\", errno); &#125; &#125;&#125;å…¶ä¸­TEMP_FAILURE_RETRY æ˜¯ä¸€ä¸ªå®å®šä¹‰ï¼Œ å½“æ‰§è¡Œwriteå¤±è´¥åï¼Œä¼šä¸æ–­é‡å¤æ‰§è¡Œï¼Œç›´åˆ°æ‰§è¡ŒæˆåŠŸä¸ºæ­¢ã€‚ (äº”) å‘é€æ¶ˆæ¯sendMessageï¼ˆNativeå±‚ï¼‰åœ¨å‰é¢Androidæ¶ˆæ¯æœºåˆ¶(Javaå±‚)æ–‡ä¸­ï¼Œè®²è¿°äº†Javaå±‚å¦‚ä½•å‘MessageQueueç±»ä¸­æ·»åŠ æ¶ˆæ¯ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥è®²è®²Nativeå±‚å¦‚ä½•å‘MessageQueueå‘é€æ¶ˆæ¯ã€‚ Step 1 ï¼šsendMessage()1234void Looper::sendMessage(const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); sendMessageAtTime(now, handler, message);&#125; Step 2 ï¼šsendMessageDelayed()12345void Looper::sendMessageDelayed(nsecs_t uptimeDelay, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); sendMessageAtTime(now + uptimeDelay, handler, message);&#125; sendMessage(),sendMessageDelayed() éƒ½æ˜¯è°ƒç”¨sendMessageAtTime()æ¥å®Œæˆæ¶ˆæ¯æ’å…¥ã€‚ Step 3 ï¼šsendMessageAtTime()12345678910111213141516171819202122void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; //è¯·æ±‚é” AutoMutex _l(mLock); size_t messageCount = mMessageEnvelopes.size(); //æ‰¾åˆ°messageåº”è¯¥æ’å…¥çš„ä½ç½®i while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); //å¦‚æœå½“å‰æ­£åœ¨å‘é€æ¶ˆæ¯ï¼Œé‚£ä¹ˆä¸å†è°ƒç”¨wake()ï¼Œç›´æ¥è¿”å›ã€‚ if (mSendingMessage) &#123; return; &#125; &#125; //é‡Šæ”¾é” //å½“æŠŠæ¶ˆæ¯åŠ å…¥åˆ°æ¶ˆæ¯é˜Ÿåˆ—çš„å¤´éƒ¨æ—¶ï¼Œéœ€è¦å”¤é†’pollå¾ªç¯ã€‚ if (i == 0) &#123; wake(); &#125;&#125; (å…­) å¤„ç†æ¶ˆæ¯MessageHandler.handleMessage() &amp;&amp; LooperCallback.handleEvent()ï¼ˆNativeå±‚ï¼‰å…¶å®Nativeä¸­çš„æ¶ˆæ¯æœºåˆ¶æœ‰ä¸¤ä¸ªæ–¹é¢ï¼Œä¸€æ–¹é¢æ˜¯é€šè¿‡addFd()æ³¨å†Œçš„è‡ªå®šä¹‰fdè§¦å‘æ¶ˆæ¯å¤„ç†ï¼Œé€šè¿‡mRequestsä¿å­˜çš„requestå¯¹è±¡ä¸­çš„callbackè¿›è¡Œæ¶ˆæ¯å¤„ç†ã€‚å³è°ƒç”¨LooperCallbackçš„handleEvent()å¤„ç† å¦ä¸€æ–¹é¢æ˜¯é€šè¿‡ä¸javaå±‚ç±»ä¼¼çš„MessageEnvelopæ¶ˆæ¯å¯¹è±¡è¿›è¡Œå¤„ç†ï¼Œè°ƒç”¨çš„æ˜¯è¯¥å¯¹è±¡handleråŸŸçš„handleMessage()æ–¹æ³•ï¼Œä¸javaå±‚éå¸¸ç±»ä¼¼ã€‚ä¼˜å…ˆçº§æ˜¯å…ˆå¤„ç†MessageEnvelopå†å¤„ç†requestã€‚å³è°ƒç”¨MessageHandlerç±»çš„handleMessage()å¤„ç† 6.1 MessageHandlerç±»ï¼šè°ƒç”¨MessageHandlerç±»çš„handleMessage()å¤„ç†æ¶ˆæ¯ 123456class MessageHandler : public virtual RefBase &#123;protected: virtual ~MessageHandler() &#123; &#125;public: virtual void handleMessage(const Message&amp; message) = 0;&#125;; 6.2 LooperCallback.handleEvent)ï¼šç”¨äºå¤„ç†æŒ‡å®šçš„æ–‡ä»¶æè¿°ç¬¦çš„polläº‹ä»¶ 12345678LooperCallbackç±»class LooperCallback : public virtual RefBase &#123;protected:virtual ~LooperCallback() &#123; &#125;public://ç”¨äºå¤„ç†æŒ‡å®šçš„æ–‡ä»¶æè¿°ç¬¦çš„polläº‹ä»¶virtual int handleEvent(int fd, int events, void* data) = 0;&#125;; (ä¸ƒ) Nativeæ¶ˆæ¯æœºåˆ¶ä½¿ç”¨å®ä¾‹ï¼šSurfaceFlinger Nativeæ¶ˆæ¯å¤„ç†åœ¨ ã€Android 7.1.2(Android N) Activity-WindowåŠ è½½æ˜¾ç¤ºæµç¨‹ã€‘ä¸­è®²åˆ° Appè¯·æ±‚åˆ›å»ºSurfaceåˆ›å»ºè¿‡ç¨‹ä¸­ï¼ŒSurfaceFlingerä¼šå¤„ç†Nativeæ¶ˆæ¯ï¼Œæ­¤å¤„ä¾¿æ˜¯Nativeæ¶ˆæ¯æœºåˆ¶ä½¿ç”¨çš„ä¸€ä¸ªå…·ä½“å®ä¾‹ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243status_t Client::createSurface( const String8&amp; name, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp)&#123; /* * createSurface must be called from the GL thread so that it can * have access to the GL context. */ class MessageCreateLayer : public MessageBase &#123; SurfaceFlinger* flinger; Client* client; sp&lt;IBinder&gt;* handle; sp&lt;IGraphicBufferProducer&gt;* gbp; status_t result; const String8&amp; name; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateLayer(SurfaceFlinger* flinger, const String8&amp; name, Client* client, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags, sp&lt;IBinder&gt;* handle, sp&lt;IGraphicBufferProducer&gt;* gbp) : flinger(flinger), client(client), handle(handle), gbp(gbp), result(NO_ERROR), name(name), w(w), h(h), format(format), flags(flags) &#123; &#125; status_t getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createLayer(name, client, w, h, format, flags, handle, gbp); return true; &#125; &#125;; sp&lt;MessageBase&gt; msg = new MessageCreateLayer(mFlinger.get(), name, this, w, h, format, flags, handle, gbp); mFlinger-&gt;postMessageSync(msg); return static_cast&lt;MessageCreateLayer*&gt;( msg.get() )-&gt;getResult(); &#125; Clientå°†åº”ç”¨ç¨‹åºåˆ›å»ºSurfaceçš„è¯·æ±‚è½¬æ¢ä¸ºå¼‚æ­¥æ¶ˆæ¯æŠ•é€’åˆ°SurfaceFlingerçš„æ¶ˆæ¯é˜Ÿåˆ—ä¸­ï¼Œå°†åˆ›å»ºSurfaceçš„ä»»åŠ¡è½¬äº¤ç»™SurfaceFlingerã€‚ å‡½æ•°é¦–å…ˆå°†è¯·æ±‚åˆ›å»ºçš„Surfaceå‚æ•°å°è£…ä¸ºMessageCreateSurfaceå¯¹è±¡ï¼Œç„¶åè°ƒç”¨SurfaceFlingerçš„postMessageSyncå‡½æ•°å¾€SurfaceFlingerçš„æ¶ˆæ¯é˜Ÿåˆ—ä¸­å‘é€ä¸€ä¸ªåŒæ­¥æ¶ˆæ¯ï¼Œå½“æ¶ˆæ¯å¤„ç†å®Œåï¼Œé€šè¿‡è°ƒç”¨æ¶ˆæ¯msgçš„getResult()å‡½æ•°æ¥å¾—åˆ°åˆ›å»ºçš„Surfaceã€‚ 1234567891011121314151617181920212223status_t SurfaceFlinger::postMessageSync(const sp&lt;MessageBase&gt;&amp; msg, nsecs_t reltime, uint32_t flags) &#123; //å¾€æ¶ˆæ¯é˜Ÿåˆ—ä¸­å‘é€ä¸€ä¸ªæ¶ˆæ¯ status_t res = mEventQueue.postMessage(msg, reltime); //æ¶ˆæ¯å‘é€æˆåŠŸåï¼Œå½“å‰çº¿ç¨‹ç­‰å¾…æ¶ˆæ¯å¤„ç† if (res == NO_ERROR) &#123; msg-&gt;wait(); &#125; return res; &#125; status_t MessageQueue::postMessage( const sp&lt;MessageBase&gt;&amp; messageHandler, nsecs_t relTime) &#123;const Message dummyMessage;//å°†messageHandlerå¯¹è±¡å’ŒdummyMessageæ¶ˆæ¯å¯¹è±¡å‘é€åˆ°æ¶ˆæ¯å¾ªç¯Looperå¯¹è±¡ä¸­if (relTime &gt; 0) &#123; mLooper-&gt;sendMessageDelayed(relTime, messageHandler, dummyMessage);&#125; else &#123; mLooper-&gt;sendMessage(messageHandler, dummyMessage);&#125;return NO_ERROR;&#125; å…³äºæ¶ˆæ¯å¾ªç¯Looperå¯¹è±¡çš„æ¶ˆæ¯å‘é€å‡½æ•°sendMessageçš„è°ƒç”¨æµç¨‹è¯·çœ‹å‰é¢è®²è§£ã€‚ è¿™é‡Œå†æ¬¡è´´ä¸Šå…³äºæ¶ˆæ¯æ’å…¥ä»£ç ï¼š 1234567891011121314151617181920212223void Looper::sendMessageAtTime(nsecs_t uptime, const sp&lt;MessageHandler&gt;&amp; handler, const Message&amp; message) &#123; size_t i = 0; &#123; // acquire lock AutoMutex _l(mLock); //è·å–æ¶ˆæ¯é˜Ÿåˆ—ä¸­ä¿å­˜çš„æ¶ˆæ¯ä¸ªæ•° size_t messageCount = mMessageEnvelopes.size(); //æŒ‰æ—¶é—´æ’åºï¼ŒæŸ¥æ‰¾å½“å‰æ¶ˆæ¯åº”è¯¥æ’å…¥çš„ä½ç½® while (i &lt; messageCount &amp;&amp; uptime &gt;= mMessageEnvelopes.itemAt(i).uptime) &#123; i += 1; &#125; //å°†Messageæ¶ˆæ¯åŠæ¶ˆæ¯å¤„ç†Handlerå°è£…ä¸ºMessageEnvelopeå¯¹è±¡ï¼Œå¹¶æ’å…¥åˆ°æ¶ˆæ¯é˜Ÿåˆ—mMessageEnvelopesä¸­ MessageEnvelope messageEnvelope(uptime, handler, message); mMessageEnvelopes.insertAt(messageEnvelope, i, 1); if (mSendingMessage) &#123; return; &#125; &#125; // release lock //å”¤é†’æ¶ˆæ¯å¾ªç¯çº¿ç¨‹ä»¥åŠæ—¶å¤„ç†æ¶ˆæ¯ if (i == 0) &#123; wake(); &#125; &#125; åˆ°æ­¤æ¶ˆæ¯å‘é€å°±å®Œæˆäº†ï¼Œç”±äºå‘é€çš„æ˜¯ä¸€ä¸ªåŒæ­¥æ¶ˆæ¯ï¼Œå› æ­¤æ¶ˆæ¯å‘é€çº¿ç¨‹æ­¤åˆ»è¿›å…¥ç¡çœ ç­‰å¾…çŠ¶æ€ï¼Œè€Œæ¶ˆæ¯å¾ªç¯çº¿ç¨‹è¢«å”¤é†’èµ·æ¥å¤„ç†æ¶ˆæ¯ï¼Œæ¶ˆæ¯å¤„ç†è¿‡ç¨‹å¦‚ä¸‹ï¼š 12345678910111213141516171819202122232425262728//æ‰€æœ‰C++å±‚çš„æ¶ˆæ¯éƒ½å°è£…ä¸ºMessageEnvelopeç±»å‹çš„å˜é‡å¹¶ä¿å­˜åˆ°mMessageEnvelopesé“¾è¡¨ä¸­ while (mMessageEnvelopes.size() != 0) &#123; nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC); const MessageEnvelope&amp; messageEnvelope = mMessageEnvelopes.itemAt(0); //å¤„ç†å½“å‰æ—¶åˆ»ä¹‹å‰çš„æ‰€æœ‰æ¶ˆæ¯ if (messageEnvelope.uptime &lt;= now) &#123; &#123; //å–å‡ºå¤„ç†è¯¥æ¶ˆæ¯çš„Hanlder sp&lt;MessageHandler&gt; handler = messageEnvelope.handler; //å–å‡ºè¯¥æ¶ˆæ¯æè¿°ç¬¦ Message message = messageEnvelope.message; //ä»mMessageEnvelopesé“¾è¡¨ä¸­ç§»é™¤è¯¥æ¶ˆæ¯ mMessageEnvelopes.removeAt(0); //è¡¨ç¤ºå½“å‰æ¶ˆæ¯å¾ªç¯çº¿ç¨‹æ­£åœ¨å¤„ç†æ¶ˆæ¯ï¼Œå¤„äºå”¤é†’çŠ¶æ€ï¼Œå› æ­¤æ¶ˆæ¯å‘é€çº¿ç¨‹æ— éœ€å”¤é†’æ¶ˆæ¯å¾ªç¯çº¿ç¨‹ mSendingMessage = true; mLock.unlock(); //è°ƒç”¨è¯¥æ¶ˆæ¯Handlerå¯¹è±¡çš„handleMessageå‡½æ•°æ¥å¤„ç†è¯¥æ¶ˆæ¯ handler-&gt;handleMessage(message); &#125; // release handler mLock.lock(); mSendingMessage = false; result = ALOOPER_POLL_CALLBACK; &#125; else &#123; // The last message left at the head of the queue determines the next wakeup time. mNextMessageUptime = messageEnvelope.uptime; break; &#125; &#125; æ¶ˆæ¯å¤„ç†è¿‡ç¨‹å°±æ˜¯è°ƒç”¨è¯¥æ¶ˆæ¯çš„Handlerå¯¹è±¡çš„handleMessageå‡½æ•°æ¥å®Œæˆï¼Œç”±äºåˆ›å»ºSurfaceæ—¶ï¼Œå¾€æ¶ˆæ¯é˜Ÿåˆ—ä¸­å‘é€çš„Handlerå¯¹è±¡ç±»å‹ä¸ºMessageCreateSurfaceï¼Œå› æ­¤å¿…å®šä¼šè°ƒç”¨è¯¥ç±»çš„handleMessageå‡½æ•°æ¥å¤„ç†Surfaceåˆ›å»ºæ¶ˆæ¯ã€‚ä½†è¯¥ç±»å¹¶æœªå®ç° handleMessageå‡½æ•°ï¼ŒåŒæ—¶è¯¥ç±»ç»§æ‰¿äºMessageBaseï¼Œç”±æ­¤å¯è§å…¶çˆ¶ç±»MessageBaseå¿…å®šå®ç°äº†handleMessageå‡½æ•°ï¼š 1234void MessageBase::handleMessage(const Message&amp;) &#123; this-&gt;handler(); barrier.open(); &#125;; è¯¥å‡½æ•°é¦–å…ˆè°ƒç”¨å…¶å­ç±»çš„handler()å‡½æ•°å¤„ç†æ¶ˆæ¯ï¼Œç„¶åå”¤é†’æ¶ˆæ¯å‘é€çº¿ç¨‹ï¼Œè¡¨æ˜å‘å¾€æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯å·²å¾—åˆ°å¤„ç†ï¼Œæ¶ˆæ¯å‘é€çº¿ç¨‹å¯ä»¥å¾€ä¸‹æ‰§è¡Œäº†ã€‚ç”±äºMessageCreateSurfaceæ˜¯MessageBaseçš„å­ç±»ï¼Œå› æ­¤è¯¥ç±»å¿…å®šå®ç°äº†handler()å‡½æ•°æ¥å¤„ç†Surfaceåˆ›å»ºæ¶ˆæ¯ï¼š 123456789101112131415161718192021222324252627class MessageCreateSurface : public MessageBase &#123; sp&lt;ISurface&gt; result; SurfaceFlinger* flinger; ISurfaceComposerClient::surface_data_t* params; Client* client; const String8&amp; name; DisplayID display; uint32_t w, h; PixelFormat format; uint32_t flags; public: MessageCreateSurface(SurfaceFlinger* flinger, ISurfaceComposerClient::surface_data_t* params, const String8&amp; name, Client* client, DisplayID display, uint32_t w, uint32_t h, PixelFormat format, uint32_t flags) : flinger(flinger), params(params), client(client), name(name), display(display), w(w), h(h), format(format), flags(flags) &#123; &#125; sp&lt;ISurface&gt; getResult() const &#123; return result; &#125; virtual bool handler() &#123; result = flinger-&gt;createSurface(params, name, client,display, w, h, format, flags); return true; &#125; &#125;; è¿™é‡Œåˆè°ƒç”¨SurfaceFlingerçš„createSurfaceå‡½æ•°æ¥åˆ›å»ºSurfaceã€‚ç»•äº†ä¸€åœˆåˆå›åˆ°SurfaceFlingerï¼Œä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšå‘¢ï¼Ÿå› ä¸ºåœ¨åŒä¸€æ—¶åˆ»å¯ä»¥æœ‰å¤šä¸ªåº”ç”¨ç¨‹åºè¯·æ±‚SurfaceFlingerä¸ºå…¶åˆ›å»ºSurfaceï¼Œé€šè¿‡æ¶ˆæ¯é˜Ÿåˆ—å¯ä»¥å®ç°è¯·æ±‚æ’é˜Ÿï¼Œç„¶åSurfaceFlingerä¾æ¬¡ä¸ºåº”ç”¨ç¨‹åºåˆ›å»ºSurfaceã€‚ å›¾è§£ï¼š çº¢è‰²è™šçº¿å…³ç³»ï¼šJavaå±‚å’ŒNativeå±‚çš„MessageQueueé€šè¿‡JNIå»ºç«‹å…³è”ï¼Œå½¼æ­¤ä¹‹é—´èƒ½ç›¸äº’è°ƒç”¨ï¼Œææ˜ç™½è¿™ä¸ªäº’è°ƒå…³ç³»ï¼Œä¹Ÿå°±ææ˜ç™½äº†Javaå¦‚ä½•è°ƒç”¨C++ä»£ç ï¼ŒC++ä»£ç åˆæ˜¯å¦‚ä½•è°ƒç”¨Javaä»£ç ã€‚ è“è‰²è™šçº¿å…³ç³»ï¼šHandler/Looper/Messageè¿™ä¸‰å¤§ç±»Javaå±‚ä¸Nativeå±‚å¹¶æ²¡æœ‰ä»»ä½•çš„çœŸæ­£å…³è”ï¼Œåªæ˜¯åˆ†åˆ«åœ¨Javaå±‚å’ŒNativeå±‚çš„handleræ¶ˆæ¯æ¨¡å‹ä¸­å…·æœ‰ç›¸ä¼¼çš„åŠŸèƒ½ã€‚éƒ½æ˜¯å½¼æ­¤ç‹¬ç«‹çš„ï¼Œå„è‡ªå®ç°ç›¸åº”çš„é€»è¾‘ã€‚ WeakMessageHandlerç»§æ‰¿äºMessageHandlerç±»ï¼ŒNativeMessageQueueç»§æ‰¿äºMessageQueueç±» å¦å¤–ï¼Œæ¶ˆæ¯å¤„ç†æµç¨‹æ˜¯å…ˆå¤„ç†Native Messageï¼Œå†å¤„ç†Native Requestï¼Œæœ€åå¤„ç†Java Messageã€‚ç†è§£äº†è¯¥æµç¨‹ï¼Œä¹Ÿå°±æ˜ç™½æœ‰æ—¶ä¸Šå±‚æ¶ˆæ¯å¾ˆå°‘ï¼Œä½†å“åº”æ—¶é—´å´è¾ƒé•¿çš„çœŸæ­£åŸå› ã€‚ æ€»ç»“ï¼š å‚è€ƒæ–‡æ¡£ï¼ˆç‰¹åˆ«æ„Ÿè°¢ï¼‰ï¼šAndroidæ¶ˆæ¯å¤„ç†æœºåˆ¶(Handlerã€Looperã€MessageQueueä¸Message)androidçš„æ¶ˆæ¯å¤„ç†æœºåˆ¶ï¼ˆå›¾+æºç åˆ†æï¼‰â€”-Looper,Handler,MessageAndroidè¿›é˜¶â€”-Androidæ¶ˆæ¯æœºåˆ¶ä¹‹Looperã€Handlerã€MessageQueenHandlerã€Looperã€Messageã€MessageQueue åŸºç¡€æµç¨‹åˆ†æå›¾è§£Android ä¸­çº¿ç¨‹é—´é€šä¿¡åŸç†åˆ†æï¼šLooper, MessageQueue, HandlerAndroidæ¶ˆæ¯æœºåˆ¶1-Handler(Javaå±‚)Androidæ¶ˆæ¯æœºåˆ¶2-Handler(Nativeå±‚)ANDROIDæ¶ˆæ¯æœºåˆ¶ï¼Œä»JAVAå±‚åˆ°NATIVEå±‚å‰–æ Androidåº”ç”¨ç¨‹åºæ¶ˆæ¯å¤„ç†æœºåˆ¶Android æ¶ˆæ¯æœºåˆ¶ï¼ˆä¸‰ï¼‰Nativeå±‚æ¶ˆæ¯æœºåˆ¶","categories":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhoujinjian.cc/tags/Android/"}]},{"title":"Hexo - Hello World","slug":"hello-world","date":"2015-06-30T16:00:00.000Z","updated":"2018-04-19T14:23:49.974Z","comments":true,"path":"2015/07/01/hello-world/","link":"","permalink":"http://zhoujinjian.cc/2015/07/01/hello-world/","excerpt":"hexo-theme-melody hexo-theme-melody-documentation","text":"hexo-theme-melody hexo-theme-melody-documentation Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo Deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoujinjian.cc/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://zhoujinjian.cc/tags/Hexo/"}]}]}