<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>๑Charles✦ˑ̫✦Vincent๑</title>
  
  <subtitle>๑Charles✦ˑ̫✦Vincent๑</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhoujinjian.cc/"/>
  <updated>2018-07-22T09:26:29.516Z</updated>
  <id>http://zhoujinjian.cc/</id>
  
  <author>
    <name>๑Charles✦ˑ̫✦Vincent๑</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】</title>
    <link href="http://zhoujinjian.cc/2088/08/08/zhoujinjian.cc-Android%E7%B3%BB%E5%88%97%E5%88%86%E6%9E%90%E6%96%87%E6%A1%A3%E3%80%90%F0%9F%8C%80%E7%BD%AE%E9%A1%B6%F0%9F%8C%80%E3%80%91/"/>
    <id>http://zhoujinjian.cc/2088/08/08/zhoujinjian.cc-Android系列分析文档【🌀置顶🌀】/</id>
    <published>2088-08-08T00:08:08.080Z</published>
    <updated>2018-07-22T09:26:29.516Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p><strong>Android 8.x &amp;&amp; Linux kernel 4.x</strong></p></blockquote><p><strong>Todo</strong><br><a href="http://zhoujinjian.cc/2018/09/28/Android%20O%20Treble%20%E6%9E%B6%E6%9E%84%20-%20HIDL%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/">Android O Treble 架构 - HIDL源代码分析</a></p><hr><blockquote><p><strong>Android 7.x &amp;&amp; Linux kernel 3.x</strong></p></blockquote><hr><h4 id="Android-Multimedia-System："><a href="#Android-Multimedia-System：" class="headerlink" title="Android Multimedia System："></a>Android Multimedia System：</h4><p><a href="http://zhoujinjian.cc/2018/09/17/Android%20Video%20System%EF%BC%886%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20NuPlayer%20HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE%E3%80%81RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/">Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</a><br><a href="http://zhoujinjian.cc/2018/09/12/Android%20Video%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20NuPlayer%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</a><br><a href="http://zhoujinjian.cc/2018/09/06/Android%20Video%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20OpenMax%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">Android Video System（4）：Android Multimedia - OpenMax实现分析</a><br><a href="http://zhoujinjian.cc/2018/06/18/Android%20Video%20System%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6Recorder%E3%80%81%E7%BC%96%E7%A0%81Encoder%E3%80%81%E6%B7%B7%E5%90%88MediaMuxer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</a><br><a href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</a><br><a href="http://zhoujinjian.cc/2018/06/01/Android%20Video%20System%EF%BC%881%EF%BC%89%EF%BC%9AVideo%20System[%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F]%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/">Android Video System（1）：Video System(视频系统)框架分析</a></p><hr><h4 id="Android-Camera-System："><a href="#Android-Camera-System：" class="headerlink" title="Android Camera System："></a>Android Camera System：</h4><p><a href="http://zhoujinjian.cc/2018/07/10/Android%20Camera%20System%EF%BC%882%EF%BC%89%EF%BC%9ACamera%20System[Camera%20%E7%B3%BB%E7%BB%9F]startPreview%E3%80%81takePicture%E3%80%81Recorder%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析</a><br><a href="http://zhoujinjian.cc/2018/07/10/Android%20Camera%20System%EF%BC%882%EF%BC%89%EF%BC%9ACamera%20System[Camera%20%E7%B3%BB%E7%BB%9F]startPreview%E3%80%81takePicture%E3%80%81Recorder%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析</a></p><hr><h4 id="Android-Display-System："><a href="#Android-Display-System：" class="headerlink" title="Android Display System："></a>Android Display System：</h4><p><a href="http://zhoujinjian.cc/2018/08/30/Android%20Display%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BDisplay%20Driver%20Architecture/">Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</a><br><a href="http://zhoujinjian.cc/2018/08/16/Android%20Display%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BGralloc%20&amp;&amp;%20HWComposer%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/">Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析</a><br><a href="http://zhoujinjian.cc/2018/08/01/Android%20Display%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BHardwareRenderer.draw%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析</a><br><a href="http://zhoujinjian.cc/2018/07/20/Android%20Display%20System%EF%BC%882%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BAndroid%20EGL%20&amp;&amp;%20OpenGL/">Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL</a><br><a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析</a></p><hr><h4 id="Android-Audio-System："><a href="#Android-Audio-System：" class="headerlink" title="Android Audio System："></a>Android Audio System：</h4><p><a href="http://zhoujinjian.cc/2018/05/25/Audio%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20audio%20system[%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F]%E5%88%86%E6%9E%90/">Android Audio System（3）：Android audio system(音频系统)分析</a><br><a href="http://zhoujinjian.cc/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android Audio System（2）：Linux ALSA音频系统分析</a><br><a href="http://zhoujinjian.cc/2018/05/01/Audio%20System%EF%BC%881%EF%BC%89%EF%BC%9ALinux%20&amp;&amp;%20Android%20Audio%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/">Android Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析</a></p><hr><h4 id="Android-Input-System："><a href="#Android-Input-System：" class="headerlink" title="Android Input System："></a>Android Input System：</h4><p><a href="http://zhoujinjian.cc/2017/12/01/Android-7-1-2-Android-N-Android-%E8%BE%93%E5%85%A5%E5%AD%90%E7%B3%BB%E7%BB%9F-Input-System/">Android Input System（2）：Android 7.1.2 (Android N) Android 输入子系统 - Input System 分析</a><br><a href="http://zhoujinjian.cc/2018/04/01/Linux%E5%86%85%E6%A0%B8%EF%BC%88Kernel-3-18%EF%BC%89-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-i-wonder/">Android Input System（1）：Linux内核（Kernel-3.18） - Linux Input 子系统 分析 </a></p><hr><h4 id="Android-基础（AMS-amp-WMS）"><a href="#Android-基础（AMS-amp-WMS）" class="headerlink" title="Android 基础（AMS &amp; WMS）"></a>Android 基础（AMS &amp; WMS）</h4><p><a href="http://zhoujinjian.cc/2018/03/01/Android-7-1-2-Android-N-Android-WindowManagerService-%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90-i-wonder/">Android基础 （6）：Android 7.1.2 (Android N) Android WindowManagerService 窗口管理服务 分析</a><br><a href="http://zhoujinjian.cc/2017/11/01/Android-7-1-2-Android-N-Activity-Window%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E6%B5%81%E7%A8%8B/">Android基础 （5）：Android 7.1.2 (Android N) Activity - Window 加载显示流程 分析</a><br><a href="http://zhoujinjian.cc/2017/10/01/Android-7-1-2-Android-N-Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">Android基础 （4）：Android 7.1.2 (Android N) Activity 启动流程 （AMS）分析</a><br><a href="http://zhoujinjian.cc/2017/09/01/Android-7-1-2-Android-N-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">Android基础 （3）：Android 7.1.2 (Android N) Android 系统启动流程 分析</a><br><a href="http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android基础 （2）：Android 7.1.2 (Android N) Android Binder 系统分析</a><br><a href="http://zhoujinjian.cc/2017/08/01/Android-7-1-2-Android-N-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%93Handler%E3%80%81Looper%E3%80%81Message/">Android基础 （1）：Android 7.1.2 (Android N) Android消息机制–Handler、Looper、Message 分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Android 8.x &amp;amp;&amp;amp; Linux kernel 4.x&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Todo&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;http://
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android O Treble 架构 - HIDL源代码分析</title>
    <link href="http://zhoujinjian.cc/2018/09/28/Android%20O%20Treble%20%E6%9E%B6%E6%9E%84%20-%20HIDL%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/09/28/Android O Treble 架构 - HIDL源代码分析/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-07-22T09:18:17.529Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;&amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm ©Android @Linux 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/o.hidl.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p>首先感谢：</p><p><a href="https://blog.csdn.net/yangwen123" target="_blank" rel="noopener">【YANGWEN123】Android O Treble架构（系列分析文章）</a><br><a href="https://www.slideshare.net/opersys/androids-hidl-treble-in-the-hal" target="_blank" rel="noopener">【Karim Yaghmour】Android’s HIDL: Treble in the HAL - SlideShare</a></p><p>正是由于前人的分析和总结，帮助我节约了大量的时间和精力，再次感谢！！！</p><p>Google Pixel、Pixel XL 内核代码（==<strong>文章基于 Kernel-4.x</strong>==）：<br> <a href="https://github.com/izhoujinjian/wahoo" target="_blank" rel="noopener">Kernel source for Pixel 2 (walleye) and Pixel 2 XL (taimen) - GitHub</a></p><p>AOSP 源码（==<strong>文章基于 Android 8.x</strong>==）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>==源码（部分）==：</p><blockquote><p>Java框架</p></blockquote><p>/frameworks/base/core/java/android/os/（JAVA）</p><ul><li>IHwInterface.java</li><li>HwBinder.java</li><li>HwRemoteBinder.java</li><li>IHwBinder.java</li><li>HwParcel.java</li></ul><p>/frameworks/base/core/jni/（JNI）</p><ul><li>android_os_HwRemoteBinder.cpp</li><li>android_os_HwBinder.cpp</li><li>android_os_HwParcel.cpp</li></ul><blockquote><p>Native框架</p></blockquote><p>/system/libhwbinder/</p><ul><li>Binder.cpp</li><li>BpHwBinder.cpp</li><li>IInterface.cpp</li><li>IPCThreadState.cpp</li><li>Parcel.cpp</li><li>ProcessState.cpp</li></ul><p>/system/libhidl/transport/</p><ul><li>HidlBinderSupport.cpp</li><li>HidlTransportSupport.cpp</li><li>ServiceManagement.cpp</li><li>/manager/1.0/IServiceManager.hal</li><li>/manager/1.0/IServiceNotification.hal</li></ul><p>/system/hwservicemanager/</p><ul><li>HidlService.cpp</li><li>hwservicemanager.rc</li><li>ServiceManager.cpp</li><li>service.cpp</li></ul><blockquote><p>Binder Driver（Kernel）</p></blockquote><p>/drivers/android/</p><ul><li>binder.c</li><li>binder_alloc.c</li></ul><blockquote><p>源码编译生成路径（Java）：</p></blockquote><p>\out\target\common\gen\JAVA_LIBRARIES</p><ul><li>android.hardware.light-V2.0-java_intermediates</li><li>android.hidl.manager-V1.0-java_intermediates</li><li>……</li></ul><blockquote><p>源码编译生成路径（hardware/interfaces/）：</p></blockquote><p>\out\soong.intermediates\system\</p><ul><li>libhidl\transport\manager\1.1\android.hidl.manager@1.1_genc++</li></ul><p>\out\soong.intermediates\hardware\interfaces*</p><ul><li>light\2.0\android.hardware.light@2.0_genc++</li><li>audio\2.0\android.hardware.audio@2.0_genc++</li><li>camera*</li><li>graphics*</li><li>media*</li><li>wifi*</li><li>……</li></ul><hr><blockquote><p>注：文中图文许多参考<a href="https://blog.csdn.net/yangwen123/" target="_blank" rel="noopener">快乐安卓</a>，由于博主有点小小的强迫症，把图片水印都去掉了，请各位见谅！</p></blockquote><h4 id="（一）、Android-O-Treble-架构介绍"><a href="#（一）、Android-O-Treble-架构介绍" class="headerlink" title="（一）、Android O Treble 架构介绍"></a>（一）、Android O Treble 架构介绍</h4><h6 id="1-0、Android整体架构变化（VNDK、VINTF、HIDL）"><a href="#1-0、Android整体架构变化（VNDK、VINTF、HIDL）" class="headerlink" title="1.0、Android整体架构变化（VNDK、VINTF、HIDL）"></a>1.0、Android整体架构变化（VNDK、VINTF、HIDL）</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-01-HIDL-treble-after.png.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-02-HIDL-treble-architecture.png.png" alt="Alt text | center"></p><p>AndroidO引入Treble架构后的变化:</p><ol><li><p>增加了2个服务管家，Android O 之前版本有且只有一个servicemanager，现在增加到3个(servicemanager、hwservicemanager、vndservicemanager)，他们分管不同的服务。</p></li><li><p>增加了binder通信库，这是为了适配binder域的扩展。</p></li><li><p>增加了binder域，系统定义了3个binder设备节点，binder驱动分别处理这3个binder设备节点上的binder通信事件。</p></li></ol><h6 id="1-1、Binder通信域变化"><a href="#1-1、Binder通信域变化" class="headerlink" title="1.1、Binder通信域变化"></a>1.1、Binder通信域变化</h6><p>Treble架构的引入足以说明Binder通信的重要性，之前APP和Framework之间通过binder实现跨进程调用，当然这个调用对开发者来说是透明的，相当于函数本地调用。Treble引入后，Framework和HAL又实现了进程分离，Framework和HAL之间依然使用binder通信，通过HIDL来定义通信接口。那binder通信有什么变化呢？ 在Treble中，引入了多个binder域，主要是增加了多个binder设备，binder驱动实现原理基本没变，变化了一些细节。增加binder设备应该是为了实现更换的权限控制，使用不同binder设备的主体和客体之间的selinux权限有所不同，同时，Android 框架和 HAL 现在使用 Binder 互相通信。由于这种通信方式极大地增加了 Binder 流量。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-03-HIDL-Binder-enhancement.png" alt="Alt text | center"></p><p>为了明确地拆分框架（与设备无关）和供应商（与具体设备相关）代码之间的 Binder 流量，Android O 引入了“Binder 上下文”这一概念。每个 Binder 上下文都有自己的设备节点和上下文（服务）管理器。您只能通过上下文管理器所属的设备节点对其进行访问，并且在通过特定上下文传递 Binder 节点时，只能由另一个进程从相同的上下文访问上下文管理器，从而确保这些域完全互相隔离。为了显示 /dev/vndbinder，请确保内核配置项 CONFIG_ANDROID_BINDER_DEVICES 设为”binder,hwbinder,vndbinder”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;kernel/android/configs/android-base.cfg]</span><br><span class="line">CONFIG_ANDROID_BINDER_DEVICES=binder,hwbinder,vndbinder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[-&gt;kernel/drivers/android/binder.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *binder_devices_param = CONFIG_ANDROID_BINDER_DEVICES;</span><br><span class="line">module_param_named(devices, binder_devices_param, charp, S_IRUGO);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">binder_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">......</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the module_parameter string, because we don't want to</span></span><br><span class="line"><span class="comment"> * tokenize it in-place.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"><span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">","</span>))) &#123;</span><br><span class="line">ret = init_binder_device(device_name);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_binder_device</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_device</span> *<span class="title">binder_device</span>;</span></span><br><span class="line"></span><br><span class="line">binder_device = kzalloc(<span class="keyword">sizeof</span>(*binder_device), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">ret = misc_register(&amp;binder_device-&gt;miscdev);</span><br><span class="line">......</span><br><span class="line">hlist_add_head(&amp;binder_device-&gt;hlist, &amp;binder_devices);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以kernel参数形式得到配置的binder设备节点名称，然后在binder驱动中创建不同的binder设备：<br>这样在驱动中就创建了binder、vndbinder、hwbinder三个驱动设备，并保存在binder设备列表binder_devices中。/dev/binder 设备节点成为了框架进程的专属节点，这意味着oem进程将无法再访问该节点。oem进程可以访问 /dev/hwbinder，但必须将其 AIDL 接口转为使用 HIDL。</p><h6 id="1-2、vndbinder-amp-amp-vndservicemanager"><a href="#1-2、vndbinder-amp-amp-vndservicemanager" class="headerlink" title="1.2、vndbinder &amp;&amp; vndservicemanager"></a>1.2、vndbinder &amp;&amp; vndservicemanager</h6><p>一直以来，供应商进程都使用 Binder 进程间通信 (IPC) 技术进行通信。在 Android O 中，/dev/binder 设备节点成为了框架进程的专属节点，这意味着供应商进程将无法再访问该节点。供应商进程可以访问 /dev/hwbinder，但必须将其 AIDL 接口转为使用 HIDL。对于想要继续在供应商进程之间使用 AIDL 接口的供应商，Android 会按以下方式支持 Binder IPC。</p><h6 id="1-2-1、vndbinder"><a href="#1-2-1、vndbinder" class="headerlink" title="1.2.1、vndbinder"></a>1.2.1、vndbinder</h6><p>Android O 支持供应商服务使用新的 Binder 域，这可通过使用 /dev/vndbinder（而非 /dev/binder）进行访问。添加 /dev/vndbinder 后，Android 现在拥有以下 3 个 IPC 域：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-04-HIDL-hwbinder-vndbinder.png" alt="Alt text | center"></p><p>通常，供应商进程不直接打开 Binder 驱动程序，而是链接到打开 Binder 驱动程序的 libbinder 用户空间库。为 ::android::ProcessState() 添加方法可为 libbinder 选择 Binder 驱动程序。供应商进程应该在调用 ProcessState,、IPCThreadState 或发出任何普通 Binder 调用之前调用此方法。要使用该方法，请在供应商进程（客户端和服务器）的 main() 后放置以下调用：</p><p>ProcessState::initWithDriver(“/dev/vndbinder”);</p><h6 id="1-2-2、vndservicemanager"><a href="#1-2-2、vndservicemanager" class="headerlink" title="1.2.2、vndservicemanager"></a>1.2.2、vndservicemanager</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-05-HIDL-hwservicemanager.png" alt="Alt text | center"></p><p>以前，Binder 服务通过 servicemanager 注册，其他进程可从中检索这些服务。在 Android O 中，servicemanager 现在专用于框架和应用进程，供应商进程无法再对其进行访问。</p><p>不过，供应商服务现在可以使用 vndservicemanager，这是一个使用 /dev/vndbinder（<strong>作为构建基础的源代码与框架 servicemanager 相同/frameworks/native/cmds/servicemanager/</strong>）而非 /dev/binder 的 servicemanager 的新实例。供应商进程无需更改即可与 vndservicemanager 通信；当供应商进程打开 /dev/vndbinder 时，服务查询会自动转至 vndservicemanager。</p><p>vndservicemanager 二进制文件包含在 Android 的默认设备 Makefile 中。<br>servicemanager和vndservicemanager使用的是同一份代码，都是由service_manager.c编译而来。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/]</span><br><span class="line">Android.bp</span><br><span class="line">bctest.c</span><br><span class="line">binder.c</span><br><span class="line">binder.h</span><br><span class="line">service_manager.c</span><br><span class="line">servicemanager.rc</span><br><span class="line">vndservicemanager.rc</span><br><span class="line"></span><br><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/service_manager.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>]; <span class="comment">/* /dev/vndbinder */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">    sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在启动servicemanager 时，并没有传参，而启动vndservicemanager时，传递了binder设备节点。</p><blockquote><p>service servicemanager /system/bin/servicemanager<br>service vndservicemanager /vendor/bin/vndservicemanager ==<strong>/dev/vndbinder</strong>==<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/vndservicemanager.rc]</span><br><span class="line">service vndservicemanager /vendor/bin/vndservicemanager /dev/vndbinder</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/cmds/servicemanager/servicemanager.rc]</span><br><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">core</span> <span class="title">animation</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span> <span class="title">readproc</span></span></span><br><span class="line"><span class="class">    <span class="title">critical</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">healthd</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">zygote</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">audioserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">media</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">surfaceflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">inputflinger</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">drm</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">keystore</span></span></span><br><span class="line"><span class="class">    <span class="title">onrestart</span> <span class="title">restart</span> <span class="title">gatekeeperd</span></span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">system</span>-<span class="title">background</span>/<span class="title">tasks</span></span></span><br><span class="line"><span class="class">    <span class="title">shutdown</span> <span class="title">critical</span></span></span><br></pre></td></tr></table></figure><h6 id="1-2-3、servicemanager"><a href="#1-2-3、servicemanager" class="headerlink" title="1.2.3、servicemanager"></a>1.2.3、servicemanager</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-05-HIDL-servicemanager.png.png" alt="Alt text | center"></p><h6 id="1-3、hwservicemanager"><a href="#1-3、hwservicemanager" class="headerlink" title="1.3、hwservicemanager"></a>1.3、hwservicemanager</h6><p>hwservicemanager用于管理hidl服务，因此其实现和servicemanager完全不同，使用的binder库也完全不同。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-05-HIDL-vndservicemanager.png.png" alt="Alt text | center"></p><h6 id="1-4、Binder库变化"><a href="#1-4、Binder库变化" class="headerlink" title="1.4、Binder库变化"></a>1.4、Binder库变化</h6><p>servicemanager和vndservicemanager都使用libbinder库，只是他们使用的binder驱动不同而已，而hwservicemanager使用libhwbinder库，binder驱动也不同。</p><p>libbinder库源码(\frameworks\native\libs\binder)<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-06-libbinder-sourcecode.png" alt="Alt text | center"></p><p>libhwbinder库源码：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-07-libhwbinder-sourcecode.png" alt="Alt text | center"></p><p>文件对比：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-08-HIDL-binder-hwbinder-file-compare.png" alt="Alt text | center"></p><h6 id="1-5、Binder通信框架变化"><a href="#1-5、Binder通信框架变化" class="headerlink" title="1.5、Binder通信框架变化"></a>1.5、Binder通信框架变化</h6><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-09-HIDL-binder-binder_ipc_process.jpg" alt="Alt text | center"></p><p>1.在普通Java Binder框架中，Client端Proxy类完成数据打包，然后交给mRemotebinder代理来完成数据传输。Server端Stub类完成数据解析，然后交给其子类实现。</p><p>2.在普通Native Binder框架中，Client端BpXXX类完成数据打包，然后交给mRemoteBpBinder来完成数据传输。Server端BnXXX类完成数据解析，然后交个其子类实现。</p><ol><li>在HwBinder框架中，Client端的BpHwXXX类完成数据打包，然后交给mRemoteBpHwBinder来完成数据传输。Server端的BnHwXXX类完成数据解析，然后交给_hidl_mImpl来实现。</li></ol><h6 id="1-6、框架层Binder对象变化"><a href="#1-6、框架层Binder对象变化" class="headerlink" title="1.6、框架层Binder对象变化"></a>1.6、框架层Binder对象变化</h6><p>参考：<a href="https://blog.csdn.net/yangwen123/article/details/79836109" target="_blank" rel="noopener">【AndroidO Treble架构下的变化】</a><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-10-HIDL-binder-hwbinder-fw-compare.png" alt="Alt text | center"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-11-HIDL-hwbinder-object.png" alt="Alt text | center"></p><h4 id="（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译"><a href="#（二）、Android-O-Treble-之-HIDL文件（-hal文件）接口文件编译" class="headerlink" title="（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译"></a>（二）、Android O Treble 之 HIDL文件（.hal文件）接口文件编译</h4><p>HIDL是一种接口定义语言，描述了HAL和它的用户之间的接口。同aidi类似，我们只需要为hal定义相关接口，然后通过hidl-gen工具即可自动编译生成对应的C++或者java源文件，定义hal接口的文件命名为xxx.hal，为了编译这些.hal文件，需要编写相应的Android.bp或者Android.mk文件:</p><ol><li><p>Android.bp文件用于编译C++；</p></li><li><p>Android.mk文件用于编译Java；</p></li></ol><h5 id="2-1、生成子Android-mk和Android-bp文件"><a href="#2-1、生成子Android-mk和Android-bp文件" class="headerlink" title="2.1、生成子Android.mk和Android.bp文件"></a>2.1、生成子Android.mk和Android.bp文件</h5><p>所有的HIDL Interface 都是通过一个.hal文件来描述，为了方便编译生成每一个子hal。Google在系统默认提供了一个脚本update-makefiles.sh，位于hardware/interfaces/、frameworks/hardware/interfaces/、system/hardware/interfaces/、system/libhidl/。以hardware/interfaces/里面的代码为实例做介绍：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">source system/tools/hidl/update-makefiles-helper.sh</span><br><span class="line"> </span><br><span class="line">do_makefiles_update \</span><br><span class="line">  <span class="string">"android.hardware:hardware/interfaces"</span> \</span><br></pre></td></tr></table></figure><p>这个脚本的主要作用：根据hal文件生成Android.mk(makefile)和Android.bp(blueprint)文件。在hardware/interfaces的子目录里面，存在.hal文件的目录，都会产生Android.bp和Android.mk文件。详细分析如下：</p><ol><li>source system/tools下面的update-makefiles-helper.sh，然后执行do_makefiles_update</li><li>解析传入进去的参数。参数android.hardware:hardware/interfaces:<br> android.hardware: android.hardware表示包名。<br> hardware/interfaces：表示相对于根目录的文件路径。<br>会输出如下LOG：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Updating makefiles <span class="keyword">for</span> android.hardware in hardware/interfaces.</span><br><span class="line">Updating ….</span><br></pre></td></tr></table></figure><p>3.获取所有的包名。通过function get_packages()函数，获取hardware/interfaces路径下面的所有hal文件所在的目录路径，比如子目录Light里面的hal文件的路径是\hardware\interfaces\light\2.0，加上当前的参数包名hardware/interfaces，通过点的方式连接，将light/2.0+hardware/interfaces里面的斜线转换成点,最终获取的包名就是 android.hardware.light@2.0，依次类推获取所有的包名。<br>4.执行hidl-gen命令.将c步骤里面获取的参数和包名还有类名传入hidl-gen命令，在\hardware\interfaces\light\2.0目录下产生Android.mk和Android.bp文件。<br>    Android.mk: hidl-gen -Lmakefile -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport android.hardware.light@2.0</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-12-HIDL-android-hal-make.png" alt="Alt text | center"></p><p>编译最终在./out/target/common/gen/JAVA_LIBRARIES目录下生成Java源文件。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-13-HIDL-android-make-java.png" alt="Alt text | center"></p><pre><code>Android.bp: hidl-gen -Landroidbp -r android.hardware:hardware/interfaces -r android.hidl:system/libhidl/transport android.hidl.manager@1.0</code></pre><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-14-HIDL-android-hal-manager.png" alt="Alt text | center"></p><p>编译最终在./out/soong/.intermediates/hardware/interfaces目录下生成C++源文件。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-15-HIDL-android-hal-manager-gen-c++.png" alt="Alt text | center"></p><p>5.在hardware/interfaces的每个子目录下面产生Android.bp文件，文件内容主要是subdirs的初始化，存放当前目录需要包含的子目录。比如hardware/interfaces/light/下面的Android.bp文件。</p><p>经过以上步骤，就会在对应的子目录产生Android.mk和Android.bp文件。这样以后我们就可以执行正常的编译命令进行编译了。比如mmm hardware/interfaces/light/,默认情况下，在源码中，Android.mk和Android.bp文件已经存在。</p><h5 id="2-2、hidl-gen工具"><a href="#2-2、hidl-gen工具" class="headerlink" title="2.2、hidl-gen工具"></a>2.2、hidl-gen工具</h5><p>在Treble架构中，系统定义的所有的.hal接口，都是通过hidl-gen工具转换成对应的代码。比如\hardware\interfaces\light\2.0\ILight.hal，会通过hidl-gen转换成\out\soong.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++\gen\android\hardware\light\2.0\LightAll.cpp文件。<br>hidl-gen源码路径：system/tools/hidl，是在ubuntu上可执行的二进制文件。<br>使用方法：hidl-gen -o output-path -L language (-r interface-root) fqname<br>参数含义：<br>    -L： 语言类型，包括c++, c++-headers, c++-sources, export-header, c++-impl, java, java-constants, vts, makefile, androidbp, androidbp-impl, hash等。hidl-gen可根据传入的语言类型产生不同的文件。fqname：完全限定名称的输入文件。比如本例中android.hardware.light@2.0，要求在源码目录下必须有hardware/interfaces/light/2.0/目录。<br>        对于单个文件来说，格式如下：package@version::fileName，比如android.hardware.light@1.0::types.Feature。<br>        对于目录来说。格式如下package@version，比如android.hardware.light@2.0。<br>    -r： 格式package:path，可选，对fqname对应的文件来说，用来指定包名和文件所在的目录到Android系统源码根目录的路径。如果没有制定，前缀默认是：android.hardware，目录是Android源码的根目录。<br>    -o ： 存放hidl-gen产生的中间文件的路径。我们查看\hardware\interfaces\light\2.0\Android.bp，可以看到，-o参数都是写的$(genDir),一般都是在\out\soong.intermediates\hardware\interfaces\light\2.0\下面，根据-L的不同，后面产生的路径可能不太一样，比如c++，那么就会就是\out\soong.intermediates\hardware\interfaces\light\2.0\gen，如果是c++-headers，那么就是\out\soong.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++_headers\gen。</p><p>对于实例来说，fqname是：android.hardware.light@2.0，包名是android.hardware，文件所在的目录是hardware/interfaces。例子中的命令会在\out\soong.intermediates\hardware\interfaces\light\2.0\下面产生对应的c++文件。</p><p>在\hardware\interfaces\light\2.0\目录下mm编译将生成：</p><p>\system\lib64\android.hardware.light@2.0.so<br>\symbols\vendor\lib64\hw\android.hardware.light@2.0-impl.so<br>\vendor\etc\init\android.hardware.light@2.0-service.rc<br>\vendor\bin\hw\android.hardware.light@2.0-service</p><p>android.hardware.light@2.0-service为hal进程的可执行文件，在android.hardware.light@2.0-service.rc是hal进程启动的配置脚本文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\android.hardware.light@<span class="number">2.0</span>-service.rc]</span><br><span class="line"></span><br><span class="line">service light-hal<span class="number">-2</span><span class="number">-0</span> /vendor/bin/hw/android.hardware.light@<span class="number">2.0</span>-service</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hal</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br></pre></td></tr></table></figure><p>也就是说AndroidO的Treble架构下，所有hal都运行在独立的进程空间：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-16-HIDL-hal-process-.png" alt="Alt text | center"></p><h4 id="（三）、Android-O-Treble-之-hwservicemanager-启动过程"><a href="#（三）、Android-O-Treble-之-hwservicemanager-启动过程" class="headerlink" title="（三）、Android O Treble 之 hwservicemanager 启动过程"></a>（三）、Android O Treble 之 hwservicemanager 启动过程</h4><p>hwservicemanager是hidl服务管理中心，负责管理系统中的所有hidl服务，由init进程启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/rootdir/init.rc]</span><br><span class="line">on post-fs</span><br><span class="line">    # Load properties from</span><br><span class="line">    #     /system/build.prop,</span><br><span class="line">    #     /odm/build.prop,</span><br><span class="line">    #     /vendor/build.prop <span class="keyword">and</span></span><br><span class="line">    #     /factory/factory.prop</span><br><span class="line">    load_system_props</span><br><span class="line">    <span class="meta"># start essential services</span></span><br><span class="line">    start logd</span><br><span class="line">    start servicemanager</span><br><span class="line">    start hwservicemanager</span><br><span class="line">    start vndservicemanager</span><br></pre></td></tr></table></figure><p>可以看到在文件系统刚初始化没多久，就启动了系统非常重要的三个管理服务，接下来分析hwservicemanager的启动流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\hwservicemanager\hwservicemanager.rc]</span><br><span class="line">service hwservicemanager /system/bin/hwservicemanager</span><br><span class="line">    user system</span><br><span class="line">    disabled</span><br><span class="line">    group system readproc</span><br><span class="line">    critical</span><br><span class="line">    onrestart setprop hwservicemanager.ready <span class="literal">false</span></span><br><span class="line">    onrestart class_restart hal</span><br><span class="line">    onrestart class_restart early_hal</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">animation</span></span></span><br></pre></td></tr></table></figure><p>hwservicemanager的源码位于system\hwservicemanager\s。<br>我们从system\hwservicemanager\service.cpp 的main()入口函数开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\hwservicemanager\service.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    configureRpcThreadpool(<span class="number">1</span>, <span class="literal">true</span> <span class="comment">/* callerWillJoin */</span>);</span><br><span class="line"><span class="comment">//创建ServiceManager对象</span></span><br><span class="line">    ServiceManager *manager = <span class="keyword">new</span> ServiceManager();</span><br><span class="line"><span class="comment">//将ServiceManager对象自身注册到mServiceMap表中</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, manager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register hwservicemanager with itself."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建TokenManager对象</span></span><br><span class="line">    TokenManager *tokenManager = <span class="keyword">new</span> TokenManager();</span><br><span class="line"><span class="comment">//将TokenManager对象自身注册到mServiceMap表中</span></span><br><span class="line">    <span class="keyword">if</span> (!manager-&gt;add(serviceName, tokenManager)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to register ITokenManager with hwservicemanager."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//建立消息循环</span></span><br><span class="line">    sp&lt;Looper&gt; looper(Looper::prepare(<span class="number">0</span> <span class="comment">/* opts */</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> binder_fd = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">//将主线程加入binder线程池，并得到/dev/hwbinder句柄</span></span><br><span class="line">    IPCThreadState::self()-&gt;setupPolling(&amp;binder_fd);</span><br><span class="line">    <span class="keyword">if</span> (binder_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to aquire binder FD. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Flush after setupPolling(), to make sure the binder driver</span></span><br><span class="line">    <span class="comment">// knows about this thread handling commands.</span></span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line"><span class="comment">//主线程监听EVENT_INPUT，通过回调BinderCallback处理</span></span><br><span class="line">    sp&lt;BinderCallback&gt; cb(<span class="keyword">new</span> BinderCallback);</span><br><span class="line">    <span class="keyword">if</span> (looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,</span><br><span class="line">            <span class="literal">nullptr</span>) != <span class="number">1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to add hwbinder FD to Looper. Aborting..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//创建BnHwServiceManager对象</span></span><br><span class="line">    <span class="comment">// Tell IPCThreadState we're the service manager</span></span><br><span class="line">    sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">    IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line">    <span class="comment">// Then tell binder kernel</span></span><br><span class="line">    ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Only enable FIFO inheritance for hwbinder</span></span><br><span class="line">    <span class="comment">// <span class="doctag">FIXME:</span> remove define when in the kernel</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_SET_INHERIT_FIFO_PRIO    _IO(<span class="meta-string">'b'</span>, 10)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rc = ioctl(binder_fd, BINDER_SET_INHERIT_FIFO_PRIO);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        ALOGE(<span class="string">"BINDER_SET_INHERIT_FIFO_PRIO failed with error %d\n"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过属性方式告知其他进程，hwservicemanager已经就绪</span></span><br><span class="line">    rc = property_set(<span class="string">"hwservicemanager.ready"</span>, <span class="string">"true"</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Failed to set \"hwservicemanager.ready\" (error %d). "</span>\</span><br><span class="line">              <span class="string">"HAL services will not start!\n"</span>, rc);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//进入消息循环</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        looper-&gt;pollAll(<span class="number">-1</span> <span class="comment">/* timeoutMillis */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hwservicemanager启动过程比较简单，最重要的就是以下几行：</p><h5 id="3-1、创建BnHwServiceManager"><a href="#3-1、创建BnHwServiceManager" class="headerlink" title="3.1、创建BnHwServiceManager"></a>3.1、创建BnHwServiceManager</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;BnHwServiceManager&gt; service = <span class="keyword">new</span> BnHwServiceManager(manager);</span><br><span class="line">IPCThreadState::self()-&gt;setTheContextObject(service);</span><br><span class="line"><span class="comment">// Then tell binder kernel</span></span><br><span class="line">ioctl(binder_fd, BINDER_SET_CONTEXT_MGR, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听请求</span></span><br><span class="line">sp&lt;BinderCallback&gt; cb(<span class="keyword">new</span> BinderCallback);</span><br><span class="line">looper-&gt;addFd(binder_fd, Looper::POLL_CALLBACK, Looper::EVENT_INPUT, cb,<span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure><p>这里创建一个binder本地对象BnHwServiceManager，然后注册到binder驱动中，让其他client进程都可以找到这个binder本地对象，然后为其创建binder代理对象。需要注意的是BnHwServiceManager的成员变量_hidl_mImpl保存的是ServiceManager实例，ServiceManager类实现了IServiceManager接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\1.1\android.hidl.manager@1.1_genc++\gen\android\hidl\manager\1.1\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">BnHwServiceManager::BnHwServiceManager(const ::android::sp&lt;IServiceManager&gt; &amp;_hidl_impl)</span><br><span class="line">        : ::android::hidl::base::V1_0::BnHwBase(_hidl_impl, &quot;android.hidl.manager@1.1&quot;, &quot;IServiceManager&quot;) &#123; </span><br><span class="line">            _hidl_mImpl = _hidl_impl;</span><br><span class="line">            auto prio = ::android::hardware::details::gServicePrioMap.get(_hidl_impl, &#123;SCHED_NORMAL, 0&#125;);</span><br><span class="line">            mSchedPolicy = prio.sched_policy;</span><br><span class="line">            mSchedPriority = prio.prio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3-2、IPCThreadState-gt-setTheContextObject-service"><a href="#3-2、IPCThreadState-gt-setTheContextObject-service" class="headerlink" title="3.2、IPCThreadState-&gt;setTheContextObject(service)"></a>3.2、IPCThreadState-&gt;setTheContextObject(service)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将BnHwServiceManager设置到IPCThreadState内部对象当中：</span></span><br><span class="line">sp&lt;BHwBinder&gt;         mContextObject;</span><br><span class="line"><span class="keyword">void</span> IPCThreadState::setTheContextObject(sp&lt;BHwBinder&gt; obj)</span><br><span class="line">&#123;</span><br><span class="line">    mContextObject = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3、BinderCallback"><a href="#3-3、BinderCallback" class="headerlink" title="3.3、BinderCallback"></a>3.3、BinderCallback</h5><p>通过循环监听binder_fd，当有请求时会回调BinderCallback的handleEvent()函数，这部分的知识请参考<br><a href="http://zhoujinjian.cc/2017/08/01/Android-7-1-2-Android-N-Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E2%80%93Handler%E3%80%81Looper%E3%80%81Message/">【Android 7.1.2 (Android N) Android消息机制–Handler、Looper、Message 分析】</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\core\libutils\Looper.cpp]</span><br><span class="line"><span class="keyword">int</span> Looper::pollInner(<span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">int</span> callbackResult = response.request.callback-&gt;handleEvent(fd, events, data);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理请求 handlePolledCommands<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinderCallback</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinderCallback() &#123;&#125;</span><br><span class="line">    ~BinderCallback() override &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">handleEvent</span><span class="params">(<span class="keyword">int</span> <span class="comment">/* fd */</span>, <span class="keyword">int</span> <span class="comment">/* events */</span>, <span class="keyword">void</span>* <span class="comment">/* data */</span>)</span> override </span>&#123;</span><br><span class="line">        IPCThreadState::self()-&gt;handlePolledCommands();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// Continue receiving callbacks.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>进一步通过talkWithDriver() 和 executeCommand(cmd) 处理请求，这一部分跟普通的binder通信就没有区别了，这里就不做分析了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\IPCThreadState.cpp]</span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::handlePolledCommands()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line">    &#125; <span class="keyword">while</span> (mIn.dataPosition() &lt; mIn.dataSize());</span><br><span class="line"></span><br><span class="line">    processPendingDerefs();</span><br><span class="line">    flushCommands();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::getAndExecuteCommand()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">int32_t</span> cmd;</span><br><span class="line"></span><br><span class="line">    result = talkWithDriver();</span><br><span class="line">    <span class="keyword">if</span> (result &gt;= NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> IN = mIn.dataAvail();</span><br><span class="line">        <span class="keyword">if</span> (IN &lt; <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>)) <span class="keyword">return</span> result;</span><br><span class="line">        cmd = mIn.readInt32();</span><br><span class="line">        .......</span><br><span class="line">        result = executeCommand(cmd);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3-4、hwservicemanager-继续关系"><a href="#3-4、hwservicemanager-继续关系" class="headerlink" title="3.4、hwservicemanager 继续关系"></a>3.4、hwservicemanager 继续关系</h5><p>hwservicemanager进程中的servicemanager作为hidl服务，同样适用了hwbinder框架，其类继承关系图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-17-HIDL-binder-bnservicemanager.png" alt="Alt text | center"></p><h4 id="（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程"><a href="#（四）、Android-O-Treble-之-hwservicemanager-添加服务（add）过程" class="headerlink" title="（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程"></a>（四）、Android O Treble 之 hwservicemanager 添加服务（add）过程</h4><p>这里以light模块为例子（其他模块类似）:</p><blockquote><p><a href="https://blog.csdn.net/ly890700/article/details/62424821" target="_blank" rel="noopener">Android 7.0 init.rc的一点改变</a><br>在Android 7之前的版本中，系统Native服务，不管它们的可执行文件位于系统什么位置都定义在根分区的init.*.rc文件中。这造成init＊.rc文件臃肿庞大，给维护带来了一些不便，而且其中定义的一些服务的二进制文件根本不存在。</p><p>但在Android 7.0中，对该机制做了一些改变 。</p><p>单一的init＊.rc，被拆分，服务根据其二进制文件的位置（/system，/vendor，/odm）定义到对应分区的etc/init目录中，每个服务一个rc文件。与该服务相关的触发器、操作等也定义在同一rc文件中。</p><ul><li>/system/etc/init，包含系统核心服务的定义，如SurfaceFlinger、MediaServer、Logcatd等。</li><li>/vendor/etc/init， SOC厂商针对SOC核心功能定义的一些服务。比如高通、MTK某一款SOC的相关的服务。</li><li>/odm/etc/init，OEM/ODM厂商如小米、华为、OPP其产品所使用的外设以及差异化功能相关的服务。</li></ul><p>这样的目录结构拆分，也与Android产品的开发流程相吻合，减轻了维护的负担。下图为Android7.0<br>模拟器/system/etc/init中定义的服务。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[源代码路径]</span><br><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\android.hardware.light@<span class="number">2.0</span>-service.rc]</span><br><span class="line">service light-hal<span class="number">-2</span><span class="number">-0</span> /vendor/bin/hw/android.hardware.light@<span class="number">2.0</span>-service</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">hal</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">system</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">[编译生成路径（真机 /<span class="title">vendor</span>/<span class="title">etc</span>/<span class="title">init</span>）]</span></span><br><span class="line"><span class="class">[-&gt;\<span class="title">out</span>\<span class="title">target</span>\<span class="title">product</span>\<span class="title">msm8909go</span>\<span class="title">vendor</span>\<span class="title">etc</span>\<span class="title">init</span>\<span class="title">android</span>.<span class="title">hardware</span>.<span class="title">light</span>@2.0-<span class="title">service</span>.<span class="title">rc</span>]</span></span><br></pre></td></tr></table></figure><p>开机会注册android.hardware.light@2.0-service， 直接看main()函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\service.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;ILight&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接着调用defaultPassthroughServiceImplementation<ilight>()模板函数</ilight></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\include\hidl\LegacySupport.h]</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">registerPassthroughServiceImplementation</span>(</span></span><br><span class="line"><span class="class">        <span class="title">std</span>:</span>:<span class="built_in">string</span> name = <span class="string">"default"</span>) &#123;</span><br><span class="line">    sp&lt;Interface&gt; service = Interface::getService(name, <span class="literal">true</span> <span class="comment">/* getStub */</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">status_t</span> status = service-&gt;registerAsService(name);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">std</span>:</span>:<span class="built_in">string</span> name,</span><br><span class="line">                                            <span class="keyword">size_t</span> maxThreads = <span class="number">1</span>) &#123;</span><br><span class="line">    configureRpcThreadpool(maxThreads, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">status_t</span> result = registerPassthroughServiceImplementation&lt;Interface&gt;(name);</span><br><span class="line">    ......</span><br><span class="line">    joinRpcThreadpool();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Interface</span>&gt;</span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">warn_unused_result</span>))</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">defaultPassthroughServiceImplementation</span>(<span class="title">size_t</span> <span class="title">maxThreads</span> = 1) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> defaultPassthroughServiceImplementation&lt;Interface&gt;(<span class="string">"default"</span>, maxThreads);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\2.0\android.hardware.light@2.0_genc++\gen\android\hardware\light\2.0\LightAll.cpp]</span><br><span class="line">// static</span><br><span class="line">::android::sp&lt;ILight&gt; ILight::getService(const std::string &amp;serviceName, const bool getStub) &#123;</span><br><span class="line">    using ::android::hardware::defaultServiceManager;</span><br><span class="line">    using ::android::hardware::details::waitForHwService;</span><br><span class="line">    using ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    using ::android::hardware::Return;</span><br><span class="line">    using ::android::sp;</span><br><span class="line">    using Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line"></span><br><span class="line">    sp&lt;ILight&gt; iface = nullptr;</span><br><span class="line"></span><br><span class="line">    const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(ILight::descriptor, serviceName);</span><br><span class="line">    </span><br><span class="line">    Transport transport = transportRet;</span><br><span class="line">    const bool vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    const bool vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line">    ......</span><br><span class="line">    if (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        const sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        if (pm != nullptr) &#123;</span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                    pm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line">            if (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</span><br><span class="line">                if (baseInterface != nullptr) &#123;</span><br><span class="line">                    iface = ILight::castFrom(baseInterface);</span><br><span class="line">                    if (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface = new BsLight(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return iface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp<interface> service = Interface::getService(name, true /<em> getStub </em>/)所以getStub=true. 这里通过PassthroughServiceManager来获取ILight对象。其实所有的Hal 进程都是通过PassthroughServiceManager来得到hidl服务对象的，而作为Hal进程的Client端Framework进程在获取hidl服务对象时，需要通过hal的Transport类型来选择获取方式。</interface></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[\device\qcom\xxx\manifest.xml]</span><br><span class="line">    &lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.light&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;ILight&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">    &lt;/hal&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-18-HIDL-treble_cpp_legacy_hal_progression.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;system\libhidl\transport\ServiceManagement.cpp]</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager1_0&gt; getPassthroughServiceManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> getPassthroughServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager1_1&gt; getPassthroughServiceManager1_1() &#123;</span><br><span class="line">    <span class="keyword">static</span> sp&lt;PassthroughServiceManager&gt; manager(<span class="keyword">new</span> PassthroughServiceManager());</span><br><span class="line">    <span class="keyword">return</span> manager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassthroughServiceManager</span> :</span> IServiceManager1_1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">openLibs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fqName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span> <span class="comment">/* continue */</span>(<span class="keyword">void</span>* <span class="comment">/* handle */</span>,</span></span></span><br><span class="line">                const std::string&amp; /* lib */, const std::string&amp; /* sym */)&gt; eachLib) &#123;</span><br><span class="line">        <span class="comment">//fqName looks like android.hardware.foo@1.0::IFoo</span></span><br><span class="line">        <span class="keyword">size_t</span> idx = fqName.find(<span class="string">"::"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> packageAndVersion = fqName.substr(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ifaceName = fqName.substr(idx + <span class="built_in">strlen</span>(<span class="string">"::"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> prefix = packageAndVersion + <span class="string">"-impl"</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> sym = <span class="string">"HIDL_FETCH_"</span> + ifaceName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> dlMode = RTLD_LAZY;</span><br><span class="line">        <span class="keyword">void</span> *handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; paths = &#123;HAL_LIBRARY_PATH_ODM, HAL_LIBRARY_PATH_VENDOR,</span><br><span class="line">                                          HAL_LIBRARY_PATH_VNDK_SP, HAL_LIBRARY_PATH_SYSTEM&#125;;</span><br><span class="line">                                          </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path : paths) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; libs = search(path, prefix, <span class="string">".so"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;lib : libs) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> fullPath = path + lib;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (path != HAL_LIBRARY_PATH_SYSTEM) &#123;</span><br><span class="line">                    handle = android_load_sphal_library(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    handle = dlopen(fullPath.c_str(), dlMode);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                <span class="keyword">if</span> (!eachLib(handle, lib, sym)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里只是简单的创建了一个PassthroughServiceManager对象。PassthroughServiceManager也实现了IServiceManager接口。然后通过PassthroughServiceManager询服务：</p><p>根据传入的fqName获取当前的接口名ILight，拼接出后面需要查找的函数名HIDL_FETCH_ILight和库名字android.hardware.light@2.0-impl.so,然后查找”/system/lib64/hw/“、”/vendor/lib64/hw/“、”/odm/lib64/hw/“下是否有对应的so库。接着通过dlopen载入/vendor/lib/hw/android.hardware.light@2.0-impl.so，然后通过dlsym查找并调用HIDL_FETCH_ILight函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[-&gt;\hardware\interfaces\light\<span class="number">2.0</span>\<span class="keyword">default</span>\Light.cpp]</span><br><span class="line"><span class="function">ILight* <span class="title">HIDL_FETCH_ILight</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="comment">/* name */</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;Type, <span class="keyword">light_device_t</span>*&gt; lights;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="keyword">const</span> &amp;pair : kLogicalLights) &#123;</span><br><span class="line">        Type type = pair.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = pair.second;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">light_device_t</span>* light = getLightDevice(name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (light != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lights[type] = light;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lights.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Log information, but still return new Light.</span></span><br><span class="line">        <span class="comment">// Some devices may not have any lights.</span></span><br><span class="line">        ALOGI(<span class="string">"Could not open any lights."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Light(<span class="built_in">std</span>::move(lights));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-19-HIDL-binder-ILight-so-dlopen.png" alt="Alt text | center"></p><h6 id="4-1、ILight-registerAsService"><a href="#4-1、ILight-registerAsService" class="headerlink" title="4.1、ILight::registerAsService()"></a>4.1、ILight::registerAsService()</h6><p>首先会调用registerAsService()注册服务，然后joinRpcThreadpool()加入线程池<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> ILight::registerAsService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName) &#123;</span><br><span class="line">    ::android::hardware::details::onRegistration(<span class="string">"android.hardware.light@2.0"</span>, <span class="string">"ILight"</span>, serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm</span><br><span class="line">            = ::android::hardware::defaultServiceManager();</span><br><span class="line">    <span class="keyword">if</span> (sm == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ::android::INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; ret = sm-&gt;add(serviceName.c_str(), <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> ret.isOk() &amp;&amp; ret ? ::android::OK : ::android::UNKNOWN_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过defaultServiceManager()获取IServiceManager，接着add()添加服务</p><p>首先根据属性”hwservicemanager.ready”值判断hwservicemanager进程是否启动就绪，如果hwservicemanager已经启动，那么通过fromBinder<iservicemanager, bphwservicemanager,="" bnhwservicemanager="">( ProcessState::self()-&gt;getContextObject(NULL))来获取hwservicemanager的代理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\ServiceManagement.cpp]</span><br><span class="line">sp&lt;IServiceManager1_0&gt; defaultServiceManager() &#123;</span><br><span class="line">    <span class="keyword">return</span> defaultServiceManager1_1();</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IServiceManager1_1&gt; defaultServiceManager1_1() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(details::gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">if</span> (details::gDefaultServiceManager != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (access(<span class="string">"/dev/hwbinder"</span>, F_OK|R_OK|W_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        waitForHwServiceManager();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (details::gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            details::gDefaultServiceManager =</span><br><span class="line">                    fromBinder&lt;IServiceManager1_1, BpHwServiceManager, BnHwServiceManager&gt;(</span><br><span class="line">                        ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> details::gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></iservicemanager,></p><p>首先看看ProcessState::getContextObject()</p><p>因此通过ProcessState::self()-&gt;getContextObject(NULL)将得到一个BpHwBinder对象，然后通过fromBinder<iservicemanager, bphwservicemanager,="" bnhwservicemanager="">进行转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\ProcessState.cpp]</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="comment">/*caller*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> getStrongProxyForHandle(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(<span class="keyword">int32_t</span> handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e = lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        IBinder* b = e-&gt;binder;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">NULL</span> || !e-&gt;refs-&gt;attemptIncWeak(<span class="keyword">this</span>)) &#123;</span><br><span class="line">            b = <span class="keyword">new</span> BpHwBinder(handle);</span><br><span class="line">            e-&gt;binder = b;</span><br><span class="line">            <span class="keyword">if</span> (b) e-&gt;refs = b-&gt;getWeakRefs();</span><br><span class="line">            result = b;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></iservicemanager,></p><p>第一次调用会调用fromBinder()函数，在这里将创建一个BpHwServiceManager对象，ProcessState::self()-&gt;getContextObject(NULL)如果返回的是远程binder对象，那么基于BpHwBinder创建BpHwServiceManager对象，BpHwBinder负责数据传输，而BpHwServiceManager服务数据业务，业务数据在BpHwServiceManager层打包好后，转交给BpHwBinder发送。如果getContextObject(NULL)返回的是本地binder对象，那么将这个本地binder对象强制转换为BnHwBase类型，从上图可知BnHwBase继承BHwBinder类，BHwBinder即是本地binder对象。<br>static_cast<bnhwbase*>(binderIface.get()) 然后通过BnHwBase的getImpl()函数得到其业务实现对象IBase。<br>sp<ibase> base =static_cast<bnhwbase*>(binderIface.get())-&gt;getImpl();</bnhwbase*></ibase></bnhwbase*></p><p>然后检查业务接口是否相同：<br>if (details::canCastInterface(base.get(),IType::descriptor))<br>如果业务接口类型相同，那么再次将这个本地binder对象转换为孙类BnHwServiceManager类型：<br>BnHwServiceManager<em> stub = static_cast&lt;BnHwServiceManager</em>&gt;(binderIface.get());<br>然后返回业务实现类对象ServiceManager对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\include\hidl\HidlBinderSupport.h]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IType, <span class="keyword">typename</span> ProxyType, <span class="keyword">typename</span> StubType&gt;</span><br><span class="line">sp&lt;IType&gt; fromBinder(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; binderIface) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::IBase;</span><br><span class="line">    <span class="keyword">using</span> ::android::hidl::base::V1_0::BnHwBase;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binderIface.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (binderIface-&gt;localBinder() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProxyType(binderIface);</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;IBase&gt; base = <span class="keyword">static_cast</span>&lt;BnHwBase*&gt;(binderIface.get())-&gt;getImpl();</span><br><span class="line">    <span class="keyword">if</span> (details::canCastInterface(base.get(), IType::descriptor)) &#123;</span><br><span class="line">        StubType* stub = <span class="keyword">static_cast</span>&lt;StubType*&gt;(binderIface.get());</span><br><span class="line">        <span class="keyword">return</span> stub-&gt;getImpl();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 getImpl()函数实现，返回的是<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++_headers\gen\android\hidl\manager\<span class="number">1.0</span>\BnHwServiceManager.h]</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; _hidl_mImpl;</span><br><span class="line">    </span><br><span class="line">    ::android::sp&lt;IServiceManager&gt; getImpl() &#123; <span class="keyword">return</span> _hidl_mImpl; &#125;;</span><br></pre></td></tr></table></figure></p><h6 id="4-2、sm-gt-add-serviceName-c-str-this-添加light-service"><a href="#4-2、sm-gt-add-serviceName-c-str-this-添加light-service" class="headerlink" title="4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service"></a>4.2、sm-&gt;add(serviceName.c_str(), this) 添加light service</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; BpHwServiceManager::add(<span class="keyword">const</span> ::android::hardware::hidl_string&amp; name, <span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; service)&#123;</span><br><span class="line">    ::android::hardware::Return&lt;<span class="keyword">bool</span>&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_add(<span class="keyword">this</span>, <span class="keyword">this</span>, name, service);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;<span class="keyword">bool</span>&gt; BpHwServiceManager::_hidl_add(::android::hardware::IInterface *_hidl_this, ::android::hardware::details::HidlInstrumentor *_hidl_this_instrumentor, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name, <span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; service) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    ::android::hardware::Parcel _hidl_data;</span><br><span class="line">    ::android::hardware::Parcel _hidl_reply;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err;</span><br><span class="line">    ::android::hardware::Status _hidl_status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    ::android::hardware::ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    _hidl_err = ::android::hardware::IInterface::asBinder(_hidl_this)-&gt;transact(<span class="number">2</span> <span class="comment">/* add */</span>, _hidl_data, &amp;_hidl_reply);</span><br><span class="line">   .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhwbinder\BpHwBinder.cpp]</span><br><span class="line"><span class="keyword">status_t</span> BpHwBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags, TransactCallback <span class="comment">/*callback*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/libhwbinder/IPCThreadState.cpp]</span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = data.errorCheck();</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) &#123;</span><br><span class="line">        err = writeTransactionData(BC_TRANSACTION_SG, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>waitForResponse()会通过底层binder 驱动进入到服务端，服务端监听消息来到处理过后会调用onTransact()函数</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-20-HIDL-ioctl-kernel.png.png" alt="Alt text | center"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/libhwbinder/Binder.cpp]</span><br><span class="line">status_t BHwBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags, TransactCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    data.setDataPosition(0);</span><br><span class="line"></span><br><span class="line">    status_t err = NO_ERROR;</span><br><span class="line">    switch (code) &#123;</span><br><span class="line">        default:</span><br><span class="line">            err = onTransact(code, data, reply, flags,</span><br><span class="line">                    [&amp;](auto &amp;replyParcel) &#123;</span><br><span class="line">                        replyParcel.setDataPosition(0);</span><br><span class="line">                        if (callback != NULL) &#123;</span><br><span class="line">                            callback(replyParcel);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::onTransact(</span><br><span class="line">        <span class="keyword">uint32_t</span> _hidl_code,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        <span class="keyword">uint32_t</span> _hidl_flags,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line">    ::android::<span class="keyword">status_t</span> _hidl_err = ::android::OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (_hidl_code) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> <span class="comment">/* add */</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> _hidl_is_oneway = _hidl_flags &amp; ::android::hardware::IBinder::FLAG_ONEWAY;</span><br><span class="line">            <span class="keyword">if</span> (_hidl_is_oneway != <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ::android::UNKNOWN_ERROR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _hidl_err = ::android::hidl::manager::V1_0::BnHwServiceManager::_hidl_add(<span class="keyword">this</span>, _hidl_data, _hidl_reply, _hidl_cb);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::_hidl_add(</span><br><span class="line">        ::android::hidl::base::V1_0::BnHwBase* _hidl_this,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* name;</span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*name), &amp;_hidl_name_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;name));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*name),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl_service_binder;</span><br><span class="line">        _hidl_err = _hidl_data.readNullableStrongBinder(&amp;_hidl_service_binder);</span><br><span class="line">        <span class="keyword">if</span> (_hidl_err != ::android::OK) &#123; <span class="keyword">return</span> _hidl_err; &#125;</span><br><span class="line"></span><br><span class="line">        service = ::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl_service_binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    atrace_begin(ATRACE_TAG_HAL, <span class="string">"HIDL::IServiceManager::add::server"</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _hidl_out_success = <span class="keyword">static_cast</span>&lt;BnHwServiceManager*&gt;(_hidl_this)-&gt;_hidl_mImpl-&gt;add(*name, service);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> _hidl_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的_hidl_mImpl即之前得到的::android::sp<iservicemanager> ==_hidl_mImpl== 对象，所以会调用</iservicemanager></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\hwservicemanager\ServiceManager.cpp]</span><br><span class="line">Return&lt;<span class="keyword">bool</span>&gt; ServiceManager::add(<span class="keyword">const</span> hidl_string&amp; name, <span class="keyword">const</span> sp&lt;IBase&gt;&amp; service) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">pid_t</span> pid = IPCThreadState::self()-&gt;getCallingPid();</span><br><span class="line">    <span class="keyword">auto</span> context = mAcl.getContext(pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret = service-&gt;interfaceChain([&amp;](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;interfaceChain) &#123;</span><br><span class="line">    </span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; interfaceChain.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> fqName = interfaceChain[i];</span><br><span class="line"></span><br><span class="line">            PackageInterfaceMap &amp;ifaceMap = mServiceMap[fqName];</span><br><span class="line">            HidlService *hidlService = ifaceMap.lookup(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hidlService == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                ifaceMap.insertService(</span><br><span class="line">                    <span class="built_in">std</span>::make_unique&lt;HidlService&gt;(fqName, name, service, pid));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (hidlService-&gt;getService() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">auto</span> ret = hidlService-&gt;getService()-&gt;unlinkToDeath(<span class="keyword">this</span>);</span><br><span class="line">                    ret.isOk(); <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">                hidlService-&gt;setService(service, pid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ifaceMap.sendPackageRegistrationNotification(fqName, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> linkRet = service-&gt;linkToDeath(<span class="keyword">this</span>, <span class="number">0</span> <span class="comment">/*cookie*/</span>);</span><br><span class="line">        linkRet.isOk(); <span class="comment">// ignore</span></span><br><span class="line">        isValidService = <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> isValidService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成插入到PackageInterfaceMap &amp;ifaceMap 对象中，并添加一些监听。之后就可以查询到light service了。</p><h6 id="4-3、joinRpcThreadpool"><a href="#4-3、joinRpcThreadpool" class="headerlink" title="4.3、joinRpcThreadpool()"></a>4.3、joinRpcThreadpool()</h6><p>加入线程池，至此Light service 就启动起来了，可以等待Client的请求了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\system\libhidl\transport\HidlTransportSupport.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinRpcThreadpool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO(b/32756130) this should be transport-dependent</span></span><br><span class="line">    joinBinderRpcThreadpool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\system\libhidl\transport\HidlBinderSupport.cpp]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">joinBinderRpcThreadpool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\system\libhwbinder\IPCThreadState.cpp]</span><br><span class="line"><span class="keyword">void</span> IPCThreadState::joinThreadPool(<span class="keyword">bool</span> isMain)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> result;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        processPendingDerefs();</span><br><span class="line">        <span class="comment">// now get the next command to be processed, waiting if necessary</span></span><br><span class="line">        result = getAndExecuteCommand();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);</span><br><span class="line">    </span><br><span class="line">    mOut.writeInt32(BC_EXIT_LOOPER);</span><br><span class="line">    talkWithDriver(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此就完成了hidl服务注册。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-21-HIDL-hwbinder-ILight-add.png" alt="Alt text | center"></p><h4 id="（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程"><a href="#（五）、Android-O-Treble-之-hwservicemanager-查询服务（get）过程" class="headerlink" title="（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程"></a>（五）、Android O Treble 之 hwservicemanager 查询服务（get）过程</h4><p>这里以light模块为例子（其他模块类似）：<br>通过前面的分析我们知道，Hal进程启动时，会向hwservicemanager进程注册hidl服务，那么当Framework Server需要通过hal访问硬件设备时，首先需要查询对应的hidl服务，那么Client进程是如何查询hidl服务的呢？这篇文章将展开分析，这里再次以ILight为例进行展开。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-22-android-hwservicemanager-get.png" alt="Alt text | center"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/services/core/java/com/android/server/lights/LightsService.java]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(<span class="keyword">int</span> light, <span class="keyword">int</span> color, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> onMS, <span class="keyword">int</span> offMS, <span class="keyword">int</span> brightnessMode)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/services/core/jni/com_android_server_lights_LightsService.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setLight_native</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* <span class="comment">/* env */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject <span class="comment">/* clazz */</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint light,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint colorARGB,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint flashMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint onMS,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint offMS,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint brightnessMode)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;ILight&gt; hal = LightHal::associate();</span><br><span class="line">    .......</span><br><span class="line">    Type type = <span class="keyword">static_cast</span>&lt;Type&gt;(light);</span><br><span class="line">    LightState state = constructState(</span><br><span class="line">        colorARGB, flashMode, onMS, offMS, brightnessMode);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        android::base::Timer t;</span><br><span class="line">        Return&lt;Status&gt; ret = hal-&gt;setLight(type, state);</span><br><span class="line">        processReturn(ret, type, state);</span><br><span class="line">        <span class="keyword">if</span> (t.duration() &gt; <span class="number">50</span>ms) ALOGD(<span class="string">"Excessive delay setting light"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>associate() 会获取ILight::getService();这里通过ILight::getService()函数来查询ILight这个HIDL服务，由于这里没有传递任何参数，因此函数最终会调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++_headers\gen\android\hardware\light\<span class="number">2.0</span>\ILight.h]</span><br><span class="line">    <span class="keyword">static</span> ::android::sp&lt;ILight&gt; getService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName=<span class="string">"default"</span>, <span class="keyword">bool</span> getStub=<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>注意，这里的getStub为false，说明加载hidl服务方式是由当前hidl服务的transport类型决定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[\device\qcom\xxx\manifest.xml]</span><br><span class="line">    &lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.light&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.0</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;ILight&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">    &lt;/hal&gt;</span><br></pre></td></tr></table></figure><p>由于ILight的transport是hwbinder类型，那么将从hwservicemanager中查询hidl服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line">::android::sp&lt;ILight&gt; ILight::getService(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;serviceName, <span class="keyword">const</span> <span class="keyword">bool</span> getStub) &#123;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::defaultServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::details::waitForHwService;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::getPassthroughServiceManager;</span><br><span class="line">    <span class="keyword">using</span> ::android::hardware::Return;</span><br><span class="line">    <span class="keyword">using</span> ::android::sp;</span><br><span class="line">    <span class="keyword">using</span> Transport = ::android::hidl::manager::V1_0::IServiceManager::Transport;</span><br><span class="line"></span><br><span class="line">    sp&lt;ILight&gt; iface = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line"></span><br><span class="line">    Return&lt;Transport&gt; transportRet = sm-&gt;getTransport(ILight::descriptor, serviceName);</span><br><span class="line">    </span><br><span class="line">    Transport transport = transportRet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfHwbinder = (transport == Transport::HWBINDER);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> vintfPassthru = (transport == Transport::PASSTHROUGH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tries = <span class="number">0</span>; !getStub &amp;&amp; (vintfHwbinder || (vintfLegacy &amp;&amp; tries == <span class="number">0</span>)); tries++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (vintfHwbinder &amp;&amp; tries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            waitForHwService(ILight::descriptor, serviceName);</span><br><span class="line">        &#125;</span><br><span class="line">        Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                sm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line"></span><br><span class="line">        sp&lt;::android::hidl::base::V1_0::IBase&gt; base = ret;</span><br><span class="line"></span><br><span class="line">        Return&lt;sp&lt;ILight&gt;&gt; castRet = ILight::castFrom(base, <span class="literal">true</span> <span class="comment">/* emitError */</span>);</span><br><span class="line"></span><br><span class="line">        iface = castRet;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> iface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getStub || vintfPassthru || vintfLegacy) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;::android::hidl::manager::V1_0::IServiceManager&gt; pm = getPassthroughServiceManager();</span><br><span class="line">        <span class="keyword">if</span> (pm != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            Return&lt;sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; ret = </span><br><span class="line">                    pm-&gt;get(ILight::descriptor, serviceName);</span><br><span class="line">            <span class="keyword">if</span> (ret.isOk()) &#123;</span><br><span class="line">                sp&lt;::android::hidl::base::V1_0::IBase&gt; baseInterface = ret;</span><br><span class="line">                <span class="keyword">if</span> (baseInterface != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    iface = ILight::castFrom(baseInterface);</span><br><span class="line">                    <span class="keyword">if</span> (!getStub || trebleTestingOverride) &#123;</span><br><span class="line">                        iface = <span class="keyword">new</span> BsLight(iface);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过sm-&gt;get(ILight::descriptor, serviceName)查询ILight这个hidl服务，得到IBase对象后，在通过ILight::castFrom转换为ILight对象。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-23-HIDL-castFrom.png" alt="Alt text | center"></p><h5 id="5-1、服务查询-hidl-get"><a href="#5-1、服务查询-hidl-get" class="headerlink" title="5.1、服务查询_hidl_get()"></a>5.1、服务查询_hidl_get()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.1</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.1</span>\ServiceManagerAll.cpp]</span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; BpHwServiceManager::get(<span class="keyword">const</span> ::android::hardware::hidl_string&amp; fqName, <span class="keyword">const</span> ::android::hardware::hidl_string&amp; name)&#123;</span><br><span class="line">    ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;  _hidl_out = ::android::hidl::manager::V1_0::BpHwServiceManager::_hidl_get(<span class="keyword">this</span>, <span class="keyword">this</span>, fqName, name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _hidl_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\1.0\android.hidl.manager@1.0_genc++\gen\android\hidl\manager\1.0\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt; BpHwServiceManager::_hidl_get(::android::hardware::IInterface *_hidl_this, ::android::hardware::details::HidlInstrumentor *_hidl_this_instrumentor, const ::android::hardware::hidl_string&amp; fqName, const ::android::hardware::hidl_string&amp; name) &#123;</span><br><span class="line">    </span><br><span class="line">    ::android::hardware::Parcel _hidl_data;</span><br><span class="line">    ::android::hardware::Parcel _hidl_reply;</span><br><span class="line">    ::android::status_t _hidl_err;</span><br><span class="line">    ::android::hardware::Status _hidl_status;</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; _hidl_out_service;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeInterfaceToken(BpHwServiceManager::descriptor);</span><br><span class="line"></span><br><span class="line">    size_t _hidl_fqName_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeBuffer(&amp;fqName, sizeof(fqName), &amp;_hidl_fqName_parent);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::writeEmbeddedToParcel(</span><br><span class="line">            fqName,</span><br><span class="line">            &amp;_hidl_data,</span><br><span class="line">            _hidl_fqName_parent,</span><br><span class="line">            0 /* parentOffset */);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    size_t _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.writeBuffer(&amp;name, sizeof(name), &amp;_hidl_name_parent);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::writeEmbeddedToParcel(</span><br><span class="line">            name,</span><br><span class="line">            &amp;_hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            0 /* parentOffset */);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::IInterface::asBinder(_hidl_this)-&gt;transact(1 /* get */, _hidl_data, &amp;_hidl_reply);</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readFromParcel(&amp;_hidl_status, _hidl_reply);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl__hidl_out_service_binder;</span><br><span class="line">        _hidl_err = _hidl_reply.readNullableStrongBinder(&amp;_hidl__hidl_out_service_binder);</span><br><span class="line"></span><br><span class="line">        _hidl_out_service = ::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl__hidl_out_service_binder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_status.setFromStatusT(_hidl_err);</span><br><span class="line">    return ::android::hardware::Return&lt;::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&gt;(_hidl_out_service);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个调用过程和hidl 添加服务过程完全一致，就是一个从BpHwServiceManager –&gt; BnHwServiceManager –&gt; ServiceManager的过程。但需要注意，BpHwServiceManager得到BnHwServiceManager返回过来的binder代理后，会通过fromBinder函数进行对象转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::android::hardware::fromBinder&lt;::android::hidl::base::V1_0::IBase,::android::hidl::base::V1_0::BpHwBase,::android::hidl::base::V1_0::BnHwBase&gt;(_hidl__hidl_out_service_binder)</span><br></pre></td></tr></table></figure><p>hwservicemanager将ILight的binder代理BpHwBinder发给Framework Server进程，Framework Server进程拿到的依然是ILight的binder代理BpHwBinder对象，因此在fromBinder函数中将创建BpHwBase对象来封装BpHwBinder。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\system\libhidl\transport\manager\<span class="number">1.0</span>\android.hidl.manager@<span class="number">1.0</span>_genc++\gen\android\hidl\manager\<span class="number">1.0</span>\ServiceManagerAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::<span class="keyword">status_t</span> BnHwServiceManager::_hidl_get(</span><br><span class="line">        ::android::hidl::base::V1_0::BnHwBase* _hidl_this,</span><br><span class="line">        <span class="keyword">const</span> ::android::hardware::Parcel &amp;_hidl_data,</span><br><span class="line">        ::android::hardware::Parcel *_hidl_reply,</span><br><span class="line">        TransactCallback _hidl_cb) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* fqName;</span><br><span class="line">    <span class="keyword">const</span> ::android::hardware::hidl_string* name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_fqName_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*fqName), &amp;_hidl_fqName_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;fqName));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*fqName),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_fqName_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _hidl_name_parent;</span><br><span class="line"></span><br><span class="line">    _hidl_err = _hidl_data.readBuffer(<span class="keyword">sizeof</span>(*name), &amp;_hidl_name_parent,  <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> **&gt;(&amp;name));</span><br><span class="line"></span><br><span class="line">    _hidl_err = ::android::hardware::readEmbeddedFromParcel(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;::android::hardware::hidl_string &amp;&gt;(*name),</span><br><span class="line">            _hidl_data,</span><br><span class="line">            _hidl_name_parent,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* parentOffset */</span>);</span><br><span class="line"></span><br><span class="line">    ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt; _hidl_out_service = <span class="keyword">static_cast</span>&lt;BnHwServiceManager*&gt;(_hidl_this)-&gt;_hidl_mImpl-&gt;get(*fqName, *name);</span><br><span class="line"></span><br><span class="line">    ::android::hardware::writeToParcel(::android::hardware::Status::ok(), _hidl_reply);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_hidl_out_service == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _hidl_err = _hidl_reply-&gt;writeStrongBinder(<span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ::android::sp&lt;::android::hardware::IBinder&gt; _hidl_binder = ::android::hardware::toBinder&lt;</span><br><span class="line">                ::android::hidl::base::V1_0::IBase&gt;(_hidl_out_service);</span><br><span class="line">        <span class="keyword">if</span> (_hidl_binder.get() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _hidl_err = _hidl_reply-&gt;writeStrongBinder(_hidl_binder);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _hidl_err = ::android::UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _hidl_cb(*_hidl_reply);</span><br><span class="line">    <span class="keyword">return</span> _hidl_err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BnHwServiceManager通过ServiceManager对象查询到对应的hidl服务，返回IBase对象后，会调用toBinder函数转换为IBinder类型对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::android::hardware::toBinder&lt; ::android::hidl::base::V1_0::IBase&gt;(_hidl_out_service)</span><br></pre></td></tr></table></figure><p>由于在hwservicemanager这边，保存的是ILight的BpHwBase对象，因此在toBinder函数中将调用IInterface::asBinder来得到BpHwBase的成员变量中的BpHwBinder对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ifacePtr-&gt;isRemote()) &#123;</span><br><span class="line"><span class="keyword">return</span> ::android::hardware::IInterface::asBinder(<span class="keyword">static_cast</span>&lt;ProxyType *&gt;(ifacePtr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务查询过程其实就是根据接口包名及服务名称，从hwservicemanager管理的表中查询对应的IBase服务对象，然后在Client进程空间分别创建BpHwBinder和BpHwBase对象。</p><h5 id="5-2、接口转换IXXX-castFrom"><a href="#5-2、接口转换IXXX-castFrom" class="headerlink" title="5.2、接口转换IXXX::castFrom()"></a>5.2、接口转换IXXX::castFrom()</h5><p>Framework Server进程通过上述hidl服务查询，得到了BpHwBase对象后，需要将其转换为与业务相关的代理对象，这就是通过：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\out\soong\.intermediates\hardware\interfaces\light\<span class="number">2.0</span>\android.hardware.light@<span class="number">2.0</span>_genc++\gen\android\hardware\light\<span class="number">2.0</span>\LightAll.cpp]</span><br><span class="line"></span><br><span class="line">::android::hardware::Return&lt;::android::sp&lt;ILight&gt;&gt; ILight::castFrom(<span class="keyword">const</span> ::android::sp&lt;::android::hidl::base::V1_0::IBase&gt;&amp; parent, <span class="keyword">bool</span> emitError) &#123;</span><br><span class="line">    <span class="keyword">return</span> ::android::hardware::details::castInterface&lt;ILight, ::android::hidl::base::V1_0::IBase, BpHwLight&gt;(</span><br><span class="line">            parent, <span class="string">"android.hardware.light@2.0::ILight"</span>, emitError);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>system\libhidl\transport\include\hidl\HidlTransportSupport.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cast the interface IParent to IChild.</span></span><br><span class="line"><span class="comment">// Return nonnull if cast successful.</span></span><br><span class="line"><span class="comment">// Return nullptr if:</span></span><br><span class="line"><span class="comment">// 1. parent is null</span></span><br><span class="line"><span class="comment">// 2. cast failed because IChild is not a child type of IParent.</span></span><br><span class="line"><span class="comment">// 3. !emitError, calling into parent fails.</span></span><br><span class="line"><span class="comment">// Return an error Return object if:</span></span><br><span class="line"><span class="comment">// 1. emitError, calling into parent fails.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> IChild, <span class="keyword">typename</span> IParent, <span class="keyword">typename</span> BpChild, <span class="keyword">typename</span> BpParent&gt;</span><br><span class="line">Return&lt;sp&lt;IChild&gt;&gt; castInterface(sp&lt;IParent&gt; parent, <span class="keyword">const</span> <span class="keyword">char</span> *childIndicator, <span class="keyword">bool</span> emitError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// casts always succeed with nullptrs.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; canCastRet = details::canCastInterface(parent.get(), childIndicator, emitError);</span><br><span class="line">    <span class="keyword">if</span> (!canCastRet.isOk()) &#123;</span><br><span class="line">        <span class="comment">// call fails, propagate the error if emitError</span></span><br><span class="line">        <span class="keyword">return</span> emitError</span><br><span class="line">                ? details::StatusOf&lt;<span class="keyword">bool</span>, sp&lt;IChild&gt;&gt;(canCastRet)</span><br><span class="line">                : Return&lt;sp&lt;IChild&gt;&gt;(sp&lt;IChild&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!canCastRet) &#123;</span><br><span class="line">        <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="literal">nullptr</span>); <span class="comment">// cast failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO b/32001926 Needs to be fixed for socket mode.</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// binderized mode. Got BpChild. grab the remote and wrap it.</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="keyword">new</span> BpChild(toBinder&lt;IParent, BpParent&gt;(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Passthrough mode. Got BnChild and BsChild.</span></span><br><span class="line">    <span class="keyword">return</span> sp&lt;IChild&gt;(<span class="keyword">static_cast</span>&lt;IChild *&gt;(parent.get()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;  <span class="comment">// namespace details</span></span><br></pre></td></tr></table></figure><p>这个模板函数展开后如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Return&lt;sp&lt;ILight&gt;&gt; castInterface(sp&lt;IBase&gt; parent, <span class="keyword">const</span> <span class="keyword">char</span> *childIndicator, <span class="keyword">bool</span> emitError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// casts always succeed with nullptrs.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Return&lt;<span class="keyword">bool</span>&gt; canCastRet = details::canCastInterface(parent.get(), childIndicator, emitError);</span><br><span class="line">    <span class="keyword">if</span> (!canCastRet.isOk()) &#123;</span><br><span class="line">        <span class="comment">// call fails, propagate the error if emitError</span></span><br><span class="line">        <span class="keyword">return</span> emitError</span><br><span class="line">                ? details::StatusOf&lt;<span class="keyword">bool</span>, sp&lt;ILight&gt;&gt;(canCastRet)</span><br><span class="line">                : Return&lt;sp&lt;ILight&gt;&gt;(sp&lt;ILight&gt;(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!canCastRet) &#123;</span><br><span class="line">        <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="literal">nullptr</span>); <span class="comment">// cast failed.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO b/32001926 Needs to be fixed for socket mode.</span></span><br><span class="line">    <span class="keyword">if</span> (parent-&gt;isRemote()) &#123;</span><br><span class="line">        <span class="comment">// binderized mode. Got BpChild. grab the remote and wrap it.</span></span><br><span class="line">        <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="keyword">new</span> BpHwLight(toBinder&lt;IBase, BpParent&gt;(parent)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Passthrough mode. Got BnChild and BsChild.</span></span><br><span class="line">    <span class="keyword">return</span> sp&lt;ILight&gt;(<span class="keyword">static_cast</span>&lt;ILight*&gt;(parent.get()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此最终会创建一个BpHwLight对象。new BpHwLight(toBinder<ibase, bpparent="">(parent))</ibase,></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-24-HIDL-binder-bphwxxxx.png" alt="Alt text | center"></p><h4 id="（六）、Android-O-Treble-之-HIDL服务Java框架实现"><a href="#（六）、Android-O-Treble-之-HIDL服务Java框架实现" class="headerlink" title="（六）、Android O Treble 之 HIDL服务Java框架实现"></a>（六）、Android O Treble 之 HIDL服务Java框架实现</h4><p>前面介绍了HIDL服务在native层的实现过程，包括HIDL服务加载创建、服务注册、服务查询过程等，那么Java层是否也实现了相关的服务框架呢？ 通常情况下，所有的Hal都实现在native层面，每个hal进程都是一个native进程，由init进程启动，在hal进程启动时会完成HIDL服务注册，Framework Server进程不一定完全是native进程，比如system_server进程，它运行在虚拟机环境中，由zygote进程fork而来，这时，Java层也需要请求HIDL服务，因此Android不仅在native层HIDL化了hal，在Java层同样也定义了相关的服务框架。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-25-Java-binder.png" alt="Alt text | center"></p><p>上图是Java层binder和hwbinder之间的类基础图对比。当我们定义一个.hal接口文件时，通过hidl-gen编译为Java文件后，将按上图中的类继承关系自动生成代码。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-26-Java-binder-class-inherit.png" alt="Alt text | center"></p><p>如上图所示，当我们定义IXXX.hal文件后，通过编译将在out/target/common/gen/JAVA_LIBRARIES目录下生成对应的IXXX.java，该文件按上述类继承关系自动生成相关代码，我们只需要定义一个XXXImp类，继承Stub并实现所有方法，然后在某个服务进程中创建一个XXXImp对象，并调用registerService（）函数进行hidl服务注册，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XXXImp mXXXImp = <span class="keyword">new</span> XXXImp();</span><br><span class="line">mXXXImp.registerAsService(<span class="string">"XXXImp"</span>);</span><br></pre></td></tr></table></figure><p>这样就完成了一个Java层的hidl服务注册，当然在当前Android系统中，大部分还是native层的hidl服务，Java层的hidl服务还是比较少的。从上述可知，Java层的hidl服务包括2个步骤：</p><ol><li>hidl服务对象创建；</li></ol><p>2.hidl服务注册；</p><h5 id="6-1、Java-hidl服务创建过程"><a href="#6-1、Java-hidl服务创建过程" class="headerlink" title="6.1、Java hidl服务创建过程"></a>6.1、Java hidl服务创建过程</h5><p>从上面的类继承图可知，hidl服务实现类继承于Stub，Stub又继承于HwBinder，因此创建一个XXXImp对象时，会调用HwBinder的构造函数。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-27-HwBinder.java.setup.png" alt="Alt text | center"></p><p>frameworks\base\core\java\android\os\HwBinder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HwBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">native_setup();</span><br><span class="line"> </span><br><span class="line">sNativeRegistry.registerNativeAllocation(</span><br><span class="line"><span class="keyword">this</span>,</span><br><span class="line">mNativeContext);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">long</span> freeFunction = native_init();</span><br><span class="line"> </span><br><span class="line">sNativeRegistry = <span class="keyword">new</span> NativeAllocationRegistry(</span><br><span class="line">HwBinder.class.getClassLoader(),</span><br><span class="line">freeFunction,</span><br><span class="line"><span class="number">128</span> <span class="comment">/* size */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建HwBinder对象会首先执行native_init()函数，然后调用native_setup()函数。<br>frameworks\base\core\jni\android_os_HwBinder.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">JHwBinder_native_init</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    JHwBinder::InitClass(env);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(&amp;releaseNativeContext);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JHwBinder_native_setup</span><span class="params">(JNIEnv *env, jobject thiz)</span> </span>&#123;</span><br><span class="line">    sp&lt;JHwBinderHolder&gt; context = <span class="keyword">new</span> JHwBinderHolder;</span><br><span class="line">    JHwBinder::SetNativeContext(env, thiz, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建一个JHwBinderHolder 对象，并保存在HwBinder类的mNativeContext变量中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;JHwBinderHolder&gt; JHwBinder::SetNativeContext(</span><br><span class="line">        JNIEnv *env, jobject thiz, <span class="keyword">const</span> sp&lt;JHwBinderHolder&gt; &amp;context) &#123;</span><br><span class="line">    sp&lt;JHwBinderHolder&gt; old =</span><br><span class="line">        (JHwBinderHolder *)env-&gt;GetLongField(thiz, gFields.contextID);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        context-&gt;incStrong(<span class="literal">NULL</span> <span class="comment">/* id */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (old != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old-&gt;decStrong(<span class="literal">NULL</span> <span class="comment">/* id */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    env-&gt;SetLongField(thiz, gFields.contextID, (<span class="keyword">long</span>)context.get());</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了多个binder类型：HwBinder、JHwBinderHolder、JHwBinder他们的类继承图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-28-Java-binder---.png" alt="Alt text | center"></p><p>红线标识了这3个类对象之间的关系，为了更加清晰地描述他们之间的关联关系，如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-29-HIDL-java-object.png" alt="Alt text | center"></p><h5 id="6-2、Java层服务注册（add）查询（get）过程"><a href="#6-2、Java层服务注册（add）查询（get）过程" class="headerlink" title="6.2、Java层服务注册（add）查询（get）过程"></a>6.2、Java层服务注册（add）查询（get）过程</h5><p>服务注册查询过程本质也是通过Native层的hwservicemanager来进行的。<br>（略）请参考大牛博客：<a href="https://blog.csdn.net/yangwen123/article/details/79876534" target="_blank" rel="noopener">Android O Treble架构下HIDL服务Java框架实现</a><br>到此Treble架构下的hwBinder实现过程就基本介绍完成。<br>总体架构：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/o.hidl.system/Treble-09-HIDL-binder-binder_ipc_process.jpg" alt="Alt text | center"></p><h4 id="（七）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考资料(特别感谢各位前辈的分析和图示)："></a>（七）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/yangwen123" target="_blank" rel="noopener">Android O Treble架构（系列分析文章） -  CSDN博客</a><br><a href="http://zhoujinjian.cc/2018/01/01/Android-7-1-2-Android-N-Android-Binder%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">Android 7.1.2 (Android N) Android Binder 系统分析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料 Android 8.x &amp;amp;&amp;amp; Linux（kernel 4.x）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议</title>
    <link href="http://zhoujinjian.cc/2018/09/17/Android%20Video%20System%EF%BC%886%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20NuPlayer%20HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE%E3%80%81RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/"/>
    <id>http://zhoujinjian.cc/2018/09/17/Android Video System（6）：Android Multimedia - NuPlayer HLS流媒体协议、RTSP流媒体协议/</id>
    <published>2018-09-16T16:00:00.000Z</published>
    <updated>2018-07-11T14:42:13.863Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网（◕‿◕），如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://tbfungeek.github.io/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">【特别感谢 -  Android 源码分析之基于NuPlayer的HLS流媒体协议】</a><br><a href="https://tbfungeek.github.io/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">【特别感谢 -  Android 源码分析之基于NuPlayer的RTSP流媒体协议】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><blockquote><p>注：本文基本转载于上述两篇博客！！！</p></blockquote><h4 id="（一）、基于NuPlayer的HLS流媒体协议"><a href="#（一）、基于NuPlayer的HLS流媒体协议" class="headerlink" title="（一）、基于NuPlayer的HLS流媒体协议"></a>（一）、基于NuPlayer的HLS流媒体协议</h4><h5 id="1-1、HLS-概述"><a href="#1-1、HLS-概述" class="headerlink" title="1.1、HLS 概述"></a>1.1、HLS 概述</h5><p>HTTP Live Streaming（HLS）是苹果公司实现的基于HTTP的流媒体直播和点播协议，主要应用在iOS系统。相对于普通的流媒体，例如RTMP协议、RTSP协议、MMS协议等，HLS最大的优点是可以根据网络状况自动切换到不同码率的视频，如果网络状况较好，则会切换到高码率的视频，若发现网络状况不佳，则会逐渐过渡到低码率的视频，这个我们下面将会结合代码对其进行说明。</p><h5 id="1-2、HLS框架介绍"><a href="#1-2、HLS框架介绍" class="headerlink" title="1.2、HLS框架介绍"></a>1.2、HLS框架介绍</h5><p>我们接下来看下HLS系统的整体结构图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-01-HLS-playback-architecture.png" alt="Alt text | center"></p><p>我们首先将要直播的视频送到编码器中，编码器分别对视频和音频进行编码，然后输出到一个MPEG-2格式的传输流中，再由分段器将MPEG-2传输流进行分段，产生一系列等间隔的媒体片段，这些媒体片段一般很小并且保存成后缀为.ts的文件，同时生成一个指向这些媒体文件的索引文件，也就是我们很经常听到的.M3U8文件。完成分段之后将这些索引文件以及媒体文件上传到Web服务器上。客户端读取索引文件，然后按顺序请求下载索引文件中列出的媒体文件。下载后是一个ts文件。需要进行解压获得对应的媒体数据并解码后进行播放。由于在直播过程中服务器端会不断地将最新的直播数据生成新的小文件，并上传所以只要客户端不断地按顺序下载并播放从服务器获取到的文件，从整个过程上看就相当于实现了直播。而且由于分段文件的很短，客户端可以根据实际的带宽情况切换到不同码率的直播源，从而实现多码率的适配的目的。</p><p>M3U8 知识请参考：<a href="https://blog.csdn.net/Guofengpu/article/details/54922865" target="_blank" rel="noopener">HLS之m3u8、ts流格式详解</a></p><h5 id="1-3、HLS播放流程"><a href="#1-3、HLS播放流程" class="headerlink" title="1.3、HLS播放流程"></a>1.3、HLS播放流程</h5><p>1、获取不同带宽下对应的网络资源URI及音视频编解码，视频分辨率等信息的文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=899152,RESOLUTION=480x270,CODECS="avc1.4d4015,mp4a.40.5"</span><br><span class="line">http:<span class="comment">//hls.ftdp.com/video1_widld/m3u8/01.m3u8</span></span><br></pre></td></tr></table></figure><p>2、根据上述获取的信息初始化对应的编解码器</p><p>3、获取第一个网络资源对应的分段索引列表（index文件）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-VERSION:3</span><br><span class="line">#EXT-X-TARGETDURATION:10</span><br><span class="line">#EXT-X-MEDIA-SEQUENCE:6532</span><br><span class="line">#EXT-X-KEY:METHOD=AES-128,URI="18319965201.key"</span><br><span class="line">#EXTINF:10,</span><br><span class="line"><span class="number">20125484</span>T125708<span class="number">-01</span><span class="number">-6533.</span>ts</span><br><span class="line">#EXT-X-KEY:METHOD=AES-128,URI="14319965205.key"</span><br><span class="line">#EXTINF:10,</span><br><span class="line"><span class="number">20125484</span>T125708<span class="number">-01</span><span class="number">-6534.</span>ts</span><br><span class="line">....</span><br><span class="line">#EXTINF:8,</span><br><span class="line"></span><br><span class="line"><span class="number">20140804</span>T125708<span class="number">-01</span><span class="number">-6593.</span>ts</span><br></pre></td></tr></table></figure><p>4、获取某一个分片的Key</p><p>5、请求下载某一个分片<br>6、根据当前的带宽决定是否切换视频资源<br>7、将下载的分片资源解密后送到解码器进行解码</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-02-HLS-playback-flow.png" alt="Alt text | center"></p><p>关于NuPlayerDrvier的创建以及SetDataSource的流程和Stagefight Player大体一致，区别在于setDataSource的时候是根据url的不同会创建三种不同的DataSource：HttpLiveSource，RTSPSource，以及GenericSource。这里就不做大篇幅的介绍了，就直接上图吧</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-03-HLS-nuplayer-setdatasource-java.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-04-HLS-nuplayer-setdatasource-native.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-05-HLS-nuplayer-setdatasource-native-2.png" alt="Alt text | center"></p><h4 id="（二）、基于NuPlayer的HLS流媒体播放源码分析"><a href="#（二）、基于NuPlayer的HLS流媒体播放源码分析" class="headerlink" title="（二）、基于NuPlayer的HLS流媒体播放源码分析"></a>（二）、基于NuPlayer的HLS流媒体播放源码分析</h4><p>首先看看总体时序图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-06-HttpLiveStream-flow.png" alt="Alt text | center"></p><h5 id="2-1、HTTPLiveSource-prepareAsync"><a href="#2-1、HTTPLiveSource-prepareAsync" class="headerlink" title="2.1、HTTPLiveSource::prepareAsync()"></a>2.1、HTTPLiveSource::prepareAsync()</h5><p>我们直接从prepare结合HLS原理开始分析，直接看HttpliveSource的prepareAsync。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\HTTPLiveSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::HTTPLiveSource::prepareAsync() &#123;</span><br><span class="line">    <span class="comment">//创建并启动一个Looper</span></span><br><span class="line">    <span class="keyword">if</span> (mLiveLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLiveLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLiveLooper-&gt;setName(<span class="string">"http live"</span>);</span><br><span class="line">        mLiveLooper-&gt;start();</span><br><span class="line">        mLiveLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个kWhatSessionNotify赋值给LiveSession用于通知</span></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatSessionNotify, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建一个LiveSession</span></span><br><span class="line">    mLiveSession = <span class="keyword">new</span> LiveSession(</span><br><span class="line">            notify,</span><br><span class="line">            (mFlags &amp; kFlagIncognito) ? LiveSession::kFlagIncognito : <span class="number">0</span>,</span><br><span class="line">            mHTTPService);</span><br><span class="line">    mLiveLooper-&gt;registerHandler(mLiveSession);</span><br><span class="line">    <span class="comment">//使用LiveSession进行异步连接</span></span><br><span class="line">    mLiveSession-&gt;connectAsync(mURL.c_str(), mExtraHeaders.isEmpty() ? <span class="literal">NULL</span> : &amp;mExtraHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line"><span class="keyword">void</span> LiveSession::connectAsync(<span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers) &#123;</span><br><span class="line">    <span class="comment">//创建一个kWhatConnect并传入url</span></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConnect, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">"url"</span>, url);</span><br><span class="line">    <span class="keyword">if</span> (headers != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setPointer(<span class="string">"headers"</span>,<span class="keyword">new</span> KeyedVector&lt;String8, String8&gt;(*headers));</span><br><span class="line">    &#125;</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LiveSession::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line"><span class="keyword">case</span> kWhatConnect:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用onConnect</span></span><br><span class="line">        onConnect(msg);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LiveSession::onConnect(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="comment">//获取传过来的Uri</span></span><br><span class="line">    CHECK(msg-&gt;findString(<span class="string">"url"</span>, &amp;mMasterURL));</span><br><span class="line">    KeyedVector&lt;String8, String8&gt; *headers = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;findPointer(<span class="string">"headers"</span>, (<span class="keyword">void</span> **)&amp;headers)) &#123;</span><br><span class="line">        mExtraHeaders.clear();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mExtraHeaders = *headers;</span><br><span class="line">        <span class="keyword">delete</span> headers;</span><br><span class="line">        headers = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个mFetcherLooper</span></span><br><span class="line">    <span class="keyword">if</span> (mFetcherLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mFetcherLooper = <span class="keyword">new</span> ALooper();</span><br><span class="line">        mFetcherLooper-&gt;setName(<span class="string">"Fetcher"</span>);</span><br><span class="line">        mFetcherLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取不同带宽下对应的网络资源URI及音视频编解码信息</span></span><br><span class="line">    addFetcher(mMasterURL.c_str())-&gt;fetchPlaylistAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就开始获取不同带宽下对应的网络资源URI及音视频编解码信息了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line">sp&lt;PlaylistFetcher&gt; LiveSession::addFetcher(<span class="keyword">const</span> <span class="keyword">char</span> *uri) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index = mFetcherInfos.indexOfKey(uri);</span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatFetcherNotify, <span class="keyword">this</span>);</span><br><span class="line">    notify-&gt;setString(<span class="string">"uri"</span>, uri);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"switchGeneration"</span>, mSwitchGeneration);</span><br><span class="line">    FetcherInfo info;</span><br><span class="line">    <span class="comment">//创建一个PlaylistFetcher并返回</span></span><br><span class="line">    info.mFetcher = <span class="keyword">new</span> PlaylistFetcher(notify, <span class="keyword">this</span>, uri, mCurBandwidthIndex, mSubtitleGeneration);</span><br><span class="line">    info.mDurationUs = <span class="number">-1l</span>l;</span><br><span class="line">    info.mToBeRemoved = <span class="literal">false</span>;</span><br><span class="line">    info.mToBeResumed = <span class="literal">false</span>;</span><br><span class="line">    mFetcherLooper-&gt;registerHandler(info.mFetcher);</span><br><span class="line">    mFetcherInfos.add(uri, info);</span><br><span class="line">    <span class="comment">//这里的info.mFetcher是上面new 出来的PlaylistFetcher</span></span><br><span class="line">    <span class="keyword">return</span> info.mFetcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过这里返回的PlaylistFetcher调用fetchPlaylistAsync来获取playlists<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\PlaylistFetcher.cpp]</span><br><span class="line"><span class="keyword">void</span> PlaylistFetcher::fetchPlaylistAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatFetchPlaylist, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlaylistFetcher::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">case</span> kWhatFetchPlaylist:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> unchanged;</span><br><span class="line">        <span class="comment">//获取一个M3U8Parser</span></span><br><span class="line">        sp&lt;M3UParser&gt; playlist = mHTTPDownloader-&gt;fetchPlaylist(mURI.c_str(), <span class="literal">NULL</span> <span class="comment">/* curPlaylistHash */</span>, &amp;unchanged);</span><br><span class="line">        sp&lt;AMessage&gt; notify = mNotify-&gt;dup();</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"what"</span>, kWhatPlaylistFetched);</span><br><span class="line">        <span class="comment">//将playlist返回</span></span><br><span class="line">        notify-&gt;setObject(<span class="string">"playlist"</span>, playlist);</span><br><span class="line">        notify-&gt;post();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们接下来看下fetchFile过程：首先会通过fetchFile从服务器端获取到m3u8 playlist内容存放到buffer缓存区，然后将获取到的缓存数据包装成M3UParser</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\HTTPDownloader.cpp]</span><br><span class="line">sp&lt;M3UParser&gt; HTTPDownloader::fetchPlaylist(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">uint8_t</span> *curPlaylistHash, <span class="keyword">bool</span> *unchanged) &#123;</span><br><span class="line"></span><br><span class="line">    *unchanged = <span class="literal">false</span>;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    String8 actualUrl;</span><br><span class="line">    <span class="comment">//调用fetchFile</span></span><br><span class="line">    <span class="keyword">ssize_t</span> err = fetchFile(url, &amp;buffer, &amp;actualUrl);</span><br><span class="line"><span class="comment">//断开连接</span></span><br><span class="line">    mHTTPDataSource-&gt;disconnect();</span><br><span class="line"> <span class="comment">//将获取到的缓存数据包装成M3UParser</span></span><br><span class="line">    sp&lt;M3UParser&gt; playlist = <span class="keyword">new</span> M3UParser(actualUrl.<span class="built_in">string</span>(), buffer-&gt;data(), buffer-&gt;size());</span><br><span class="line">    <span class="keyword">return</span> playlist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ssize_t</span> HTTPDownloader::fetchFile(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *url, sp&lt;ABuffer&gt; *out, String8 *actualUrl) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> err = fetchBlock(url, out, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, actualUrl, <span class="literal">true</span> <span class="comment">/* reconnect */</span>);</span><br><span class="line">    <span class="comment">// close off the connection after use</span></span><br><span class="line">    mHTTPDataSource-&gt;disconnect();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里看下M3UParser构造方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\M3UParser.cpp]</span><br><span class="line">M3UParser::M3UParser(</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *baseURI, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> size)</span><br><span class="line">    : mInitCheck(NO_INIT),</span><br><span class="line">      mBaseURI(baseURI),</span><br><span class="line">      mIsExtM3U(<span class="literal">false</span>),</span><br><span class="line">      mIsVariantPlaylist(<span class="literal">false</span>),</span><br><span class="line">      mIsComplete(<span class="literal">false</span>),</span><br><span class="line">      mIsEvent(<span class="literal">false</span>),</span><br><span class="line">      mFirstSeqNumber(<span class="number">-1</span>),</span><br><span class="line">      mLastSeqNumber(<span class="number">-1</span>),</span><br><span class="line">      mTargetDurationUs(<span class="number">-1l</span>l),</span><br><span class="line">      mDiscontinuitySeq(<span class="number">0</span>),</span><br><span class="line">      mDiscontinuityCount(<span class="number">0</span>),</span><br><span class="line">      mSelectedIndex(<span class="number">-1</span>) &#123;</span><br><span class="line">    mInitCheck = parse(data, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最后的时候会调用parse对缓存数据进行解析：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\M3UParser.cpp]</span><br><span class="line"><span class="keyword">status_t</span> M3UParser::parse(<span class="keyword">const</span> <span class="keyword">void</span> *_data, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> lineNo = <span class="number">0</span>;</span><br><span class="line">    sp&lt;AMessage&gt; itemMeta;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *data = (<span class="keyword">const</span> <span class="keyword">char</span> *)_data;</span><br><span class="line">    <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> segmentRangeOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (offset &lt; size) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> offsetLF = offset;</span><br><span class="line">        <span class="keyword">while</span> (offsetLF &lt; size &amp;&amp; data[offsetLF] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">            ++offsetLF;</span><br><span class="line">        &#125;</span><br><span class="line">        AString line;</span><br><span class="line">        <span class="keyword">if</span> (offsetLF &gt; offset &amp;&amp; data[offsetLF - <span class="number">1</span>] == <span class="string">'\r'</span>) &#123;</span><br><span class="line">            line.setTo(&amp;data[offset], offsetLF - offset - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            line.setTo(&amp;data[offset], offsetLF - offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (line.empty()) &#123;</span><br><span class="line">            offset = offsetLF + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (lineNo == <span class="number">0</span> &amp;&amp; line == <span class="string">"#EXTM3U"</span>) &#123;</span><br><span class="line">            mIsExtM3U = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mIsExtM3U) &#123;</span><br><span class="line">            <span class="keyword">status_t</span> err = OK;</span><br><span class="line">            <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-TARGETDURATION"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseMetaData(line, &amp;mMeta, <span class="string">"target-duration"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-MEDIA-SEQUENCE"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseMetaData(line, &amp;mMeta, <span class="string">"media-sequence"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-KEY"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseCipherInfo(line, &amp;itemMeta, mBaseURI);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-ENDLIST"</span>)) &#123;</span><br><span class="line">                mIsComplete = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-PLAYLIST-TYPE:EVENT"</span>)) &#123;</span><br><span class="line">                mIsEvent = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXTINF"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                err = parseMetaDataDuration(line, &amp;itemMeta, <span class="string">"durationUs"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-DISCONTINUITY"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (itemMeta == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    itemMeta = <span class="keyword">new</span> AMessage;</span><br><span class="line">                &#125;</span><br><span class="line">                itemMeta-&gt;setInt32(<span class="string">"discontinuity"</span>, <span class="literal">true</span>);</span><br><span class="line">                ++mDiscontinuityCount;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-STREAM-INF"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                mIsVariantPlaylist = <span class="literal">true</span>;</span><br><span class="line">                err = parseStreamInf(line, &amp;itemMeta);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-BYTERANGE"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">uint64_t</span> length, offset;</span><br><span class="line">                err = parseByteRange(line, segmentRangeOffset, &amp;length, &amp;offset);</span><br><span class="line">                <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (itemMeta == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        itemMeta = <span class="keyword">new</span> AMessage;</span><br><span class="line">                    &#125;</span><br><span class="line">                    itemMeta-&gt;setInt64(<span class="string">"range-offset"</span>, offset);</span><br><span class="line">                    itemMeta-&gt;setInt64(<span class="string">"range-length"</span>, length);</span><br><span class="line">                    segmentRangeOffset = offset + length;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-MEDIA"</span>)) &#123;</span><br><span class="line">                err = parseMedia(line);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line.startsWith(<span class="string">"#EXT-X-DISCONTINUITY-SEQUENCE"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mIsVariantPlaylist) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">size_t</span> seq;</span><br><span class="line">                err = parseDiscontinuitySequence(line, &amp;seq);</span><br><span class="line">                <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">                    mDiscontinuitySeq = seq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="keyword">return</span> err;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!line.startsWith(<span class="string">"#"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mIsVariantPlaylist) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">                <span class="keyword">if</span> (itemMeta == <span class="literal">NULL</span></span><br><span class="line">                        || !itemMeta-&gt;findInt64(<span class="string">"durationUs"</span>, &amp;durationUs)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">                &#125;</span><br><span class="line">                itemMeta-&gt;setInt32(<span class="string">"discontinuity-sequence"</span>,</span><br><span class="line">                        mDiscontinuitySeq + mDiscontinuityCount);</span><br><span class="line">            &#125;</span><br><span class="line">            mItems.push();</span><br><span class="line">            Item *item = &amp;mItems.editItemAt(mItems.size() - <span class="number">1</span>);</span><br><span class="line">            CHECK(MakeURL(mBaseURI.c_str(), line.c_str(), &amp;item-&gt;mURI));</span><br><span class="line">            item-&gt;mMeta = itemMeta;</span><br><span class="line">            itemMeta.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        offset = offsetLF + <span class="number">1</span>;</span><br><span class="line">        ++lineNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsVariantPlaylist) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> targetDurationSecs;</span><br><span class="line">        <span class="keyword">if</span> (mMeta == <span class="literal">NULL</span> || !mMeta-&gt;findInt32(</span><br><span class="line">                <span class="string">"target-duration"</span>, &amp;targetDurationSecs)) &#123;</span><br><span class="line">            ALOGE(<span class="string">"Media playlist missing #EXT-X-TARGETDURATION"</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line">        mTargetDurationUs = targetDurationSecs * <span class="number">1000000l</span>l;</span><br><span class="line">        mFirstSeqNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mMeta-&gt;findInt32(<span class="string">"media-sequence"</span>, &amp;mFirstSeqNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastSeqNumber = mFirstSeqNumber + mItems.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>好了我们现在已经获取到了类型为M3UParser的播放列表文件了，这时候会发送一个kWhatPlaylistFetched，这个在哪里被处理呢？当然是LiveSession啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line"><span class="keyword">case</span> PlaylistFetcher::kWhatPlaylistFetched:</span><br><span class="line">&#123;</span><br><span class="line">    onMasterPlaylistFetched(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取到播放列表后要干啥呢？我们接下来看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line"><span class="keyword">void</span> LiveSession::onMasterPlaylistFetched(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line"></span><br><span class="line">    AString uri;</span><br><span class="line">    CHECK(msg-&gt;findString(<span class="string">"uri"</span>, &amp;uri));</span><br><span class="line">    <span class="keyword">ssize_t</span> index = mFetcherInfos.indexOfKey(uri);</span><br><span class="line">    <span class="comment">// no longer useful, remove</span></span><br><span class="line">    mFetcherLooper-&gt;unregisterHandler(mFetcherInfos[index].mFetcher-&gt;id());</span><br><span class="line">    mFetcherInfos.removeItemsAt(index);</span><br><span class="line">    <span class="comment">//取走获取到的playlist</span></span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"playlist"</span>, (sp&lt;RefBase&gt; *)&amp;mPlaylist));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We trust the content provider to make a reasonable choice of preferred</span></span><br><span class="line">    <span class="comment">// initial bandwidth by listing it first in the variant playlist.</span></span><br><span class="line">    <span class="comment">// At startup we really don't have a good estimate on the available</span></span><br><span class="line">    <span class="comment">// network bandwidth since we haven't tranferred any data yet. Once</span></span><br><span class="line">    <span class="comment">// we have we can make a better informed choice.</span></span><br><span class="line">    <span class="keyword">size_t</span> initialBandwidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> initialBandwidthIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断获取到的playlist是否有效，无效就没啥用了，我们这里假设有效</span></span><br><span class="line">    <span class="keyword">if</span> (mPlaylist-&gt;isVariantPlaylist()) &#123;</span><br><span class="line">        Vector&lt;BandwidthItem&gt; itemsWithVideo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mPlaylist-&gt;size(); ++i) &#123;</span><br><span class="line">            BandwidthItem item;</span><br><span class="line">            item.mPlaylistIndex = i;</span><br><span class="line">            item.mLastFailureUs = <span class="number">-1l</span>l;</span><br><span class="line">            sp&lt;AMessage&gt; meta;</span><br><span class="line">            AString uri;</span><br><span class="line">            mPlaylist-&gt;itemAt(i, &amp;uri, &amp;meta);</span><br><span class="line">            <span class="comment">//获取带宽</span></span><br><span class="line">            CHECK(meta-&gt;findInt32(<span class="string">"bandwidth"</span>, (<span class="keyword">int32_t</span> *)&amp;item.mBandwidth));</span><br><span class="line">            <span class="comment">//获取最大分辨率</span></span><br><span class="line">            <span class="keyword">int32_t</span> width, height;</span><br><span class="line">            <span class="keyword">if</span> (meta-&gt;findInt32(<span class="string">"width"</span>, &amp;width)) &#123;</span><br><span class="line">                maxWidth = max(maxWidth, width);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (meta-&gt;findInt32(<span class="string">"height"</span>, &amp;height)) &#123;</span><br><span class="line">                maxHeight = max(maxHeight, height);</span><br><span class="line">            &#125;</span><br><span class="line">            mBandwidthItems.push(item);</span><br><span class="line">            <span class="keyword">if</span> (mPlaylist-&gt;hasType(i, <span class="string">"video"</span>)) &#123;</span><br><span class="line">                itemsWithVideo.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//移除只有声音的信息</span></span><br><span class="line">        <span class="keyword">if</span> (!itemsWithVideo.empty()&amp;&amp; itemsWithVideo.size() &lt; mBandwidthItems.size()) &#123;</span><br><span class="line">            mBandwidthItems.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; itemsWithVideo.size(); ++i) &#123;</span><br><span class="line">                mBandwidthItems.push(itemsWithVideo[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        CHECK_GT(mBandwidthItems.size(), <span class="number">0u</span>);</span><br><span class="line">        initialBandwidth = mBandwidthItems[<span class="number">0</span>].mBandwidth;</span><br><span class="line">        <span class="comment">//按照带宽进行排序</span></span><br><span class="line">        mBandwidthItems.sort(SortByBandwidth);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mBandwidthItems.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mBandwidthItems.itemAt(i).mBandwidth == initialBandwidth) &#123;</span><br><span class="line">                initialBandwidthIndex = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取到最大的分辨率</span></span><br><span class="line">    mMaxWidth = maxWidth &gt; <span class="number">0</span> ? maxWidth : mMaxWidth;</span><br><span class="line">    mMaxHeight = maxHeight &gt; <span class="number">0</span> ? maxHeight : mMaxHeight;</span><br><span class="line">    mPlaylist-&gt;pickRandomMediaItems();</span><br><span class="line">    changeConfiguration(<span class="number">0l</span>l <span class="comment">/* timeUs */</span>, initialBandwidthIndex, <span class="literal">false</span> <span class="comment">/* pickTrack */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line"><span class="keyword">void</span> LiveSession::changeConfiguration(<span class="keyword">int64_t</span> timeUs, <span class="keyword">ssize_t</span> bandwidthIndex, <span class="keyword">bool</span> pickTrack) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取消带宽切换</span></span><br><span class="line">    cancelBandwidthSwitch();</span><br><span class="line">    mReconfigurationInProgress = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//由mOrigBandwidthIndex切换到mCurBandwidthIndex</span></span><br><span class="line">    <span class="keyword">if</span> (bandwidthIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//将当前的带宽设置为当前带宽</span></span><br><span class="line">        mOrigBandwidthIndex = mCurBandwidthIndex;</span><br><span class="line">        mCurBandwidthIndex = bandwidthIndex;</span><br><span class="line">        <span class="keyword">if</span> (mOrigBandwidthIndex != mCurBandwidthIndex) &#123;</span><br><span class="line">            <span class="comment">//开始切换带宽</span></span><br><span class="line">            ALOGI(<span class="string">"#### Starting Bandwidth Switch: %zd =&gt; %zd"</span>,mOrigBandwidthIndex, mCurBandwidthIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_LT(mCurBandwidthIndex, mBandwidthItems.size());</span><br><span class="line">    <span class="comment">//获取当前的BandwidthItem</span></span><br><span class="line">    <span class="keyword">const</span> BandwidthItem &amp;item = mBandwidthItems.itemAt(mCurBandwidthIndex);</span><br><span class="line">    <span class="keyword">uint32_t</span> streamMask = <span class="number">0</span>; <span class="comment">// streams that should be fetched by the new fetcher</span></span><br><span class="line">    <span class="keyword">uint32_t</span> resumeMask = <span class="number">0</span>; <span class="comment">// streams that should be fetched by the original fetcher</span></span><br><span class="line">    AString URIs[kMaxStreams];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPlaylist-&gt;getTypeURI(item.mPlaylistIndex, mStreams[i].mType, &amp;URIs[i])) &#123;</span><br><span class="line">            streamMask |= indexToType(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止我们不需要的，暂停我们将要复用的，第一次的时候这里是没有的所以跳过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mFetcherInfos.size(); ++i) &#123;</span><br><span class="line">        <span class="comment">//.........................</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg;</span><br><span class="line">    <span class="keyword">if</span> (timeUs &lt; <span class="number">0l</span>l) &#123;</span><br><span class="line">        <span class="comment">// skip onChangeConfiguration2 (decoder destruction) if not seeking.</span></span><br><span class="line">        msg = <span class="keyword">new</span> AMessage(kWhatChangeConfiguration3, <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg = <span class="keyword">new</span> AMessage(kWhatChangeConfiguration2, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"streamMask"</span>, streamMask);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"resumeMask"</span>, resumeMask);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"pickTrack"</span>, pickTrack);</span><br><span class="line">    msg-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((streamMask | resumeMask) &amp; indexToType(i)) &#123;</span><br><span class="line">            msg-&gt;setString(mStreams[i].uriKey().c_str(), URIs[i].c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Every time a fetcher acknowledges the stopAsync or pauseAsync request</span></span><br><span class="line">    <span class="comment">// we'll decrement mContinuationCounter, once it reaches zero, i.e. all</span></span><br><span class="line">    <span class="comment">// fetchers have completed their asynchronous operation, we'll post</span></span><br><span class="line">    <span class="comment">// mContinuation, which then is handled below in onChangeConfiguration2.</span></span><br><span class="line">  <span class="comment">//每次fetcher 调用了stopAsync和pauseAsync mContinuationCounter 数值都会减去1,一旦减到0 那么将会在onChangeConfiguration2处理</span></span><br><span class="line">    mContinuationCounter = mFetcherInfos.size();</span><br><span class="line">    mContinuation = msg;</span><br><span class="line">    <span class="keyword">if</span> (mContinuationCounter == <span class="number">0</span>) &#123;</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LiveSession::onChangeConfiguration2(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">    CHECK(msg-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        mLastSeekTimeUs = timeUs;</span><br><span class="line">        mLastDequeuedTimeUs = timeUs;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mPacketSources.size(); i++) &#123;</span><br><span class="line">            sp&lt;AnotherPacketSource&gt; packetSource = mPacketSources.editValueAt(i);</span><br><span class="line">            sp&lt;MetaData&gt; format = packetSource-&gt;getFormat();</span><br><span class="line">            packetSource-&gt;clear();</span><br><span class="line">            packetSource-&gt;setFormat(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">            mStreams[i].reset();</span><br><span class="line">        &#125;</span><br><span class="line">        mDiscontinuityOffsetTimesUs.clear();</span><br><span class="line">        mDiscontinuityAbsStartTimesUs.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mSeekReplyID != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            CHECK(mSeekReply != <span class="literal">NULL</span>);</span><br><span class="line">            mSeekReply-&gt;setInt32(<span class="string">"err"</span>, OK);</span><br><span class="line">            mSeekReply-&gt;postReply(mSeekReplyID);</span><br><span class="line">            mSeekReplyID.clear();</span><br><span class="line">            mSeekReply.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        restartPollBuffering();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> streamMask, resumeMask;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"streamMask"</span>, (<span class="keyword">int32_t</span> *)&amp;streamMask));</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"resumeMask"</span>, (<span class="keyword">int32_t</span> *)&amp;resumeMask));</span><br><span class="line"></span><br><span class="line">    streamMask |= resumeMask;</span><br><span class="line"></span><br><span class="line">    AString URIs[kMaxStreams];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxStreams; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (streamMask &amp; indexToType(i)) &#123;</span><br><span class="line">            <span class="keyword">const</span> AString &amp;uriKey = mStreams[i].uriKey();</span><br><span class="line">            CHECK(msg-&gt;findString(uriKey.c_str(), &amp;URIs[i]));</span><br><span class="line">            ALOGV(<span class="string">"%s = '%s'"</span>, uriKey.c_str(), URIs[i].c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> changedMask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxStreams &amp;&amp; i != kSubtitleIndex; ++i) &#123;</span><br><span class="line">        <span class="comment">// stream URI could change even if onChangeConfiguration2 is only</span></span><br><span class="line">        <span class="comment">// used for seek. Seek could happen during a bw switch, in this</span></span><br><span class="line">        <span class="comment">// case bw switch will be cancelled, but the seekTo position will</span></span><br><span class="line">        <span class="comment">// fetch from the new URI.</span></span><br><span class="line">        <span class="keyword">if</span> ((mStreamMask &amp; streamMask &amp; indexToType(i))</span><br><span class="line">                &amp;&amp; !mStreams[i].mUri.empty()</span><br><span class="line">                &amp;&amp; !(URIs[i] == mStreams[i].mUri)) &#123;</span><br><span class="line">            ALOGV(<span class="string">"stream %zu changed: oldURI %s, newURI %s"</span>, i,</span><br><span class="line">                    mStreams[i].mUri.c_str(), URIs[i].c_str());</span><br><span class="line">            sp&lt;AnotherPacketSource&gt; source = mPacketSources.valueFor(indexToType(i));</span><br><span class="line">            <span class="keyword">if</span> (source-&gt;getLatestDequeuedMeta() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                source-&gt;queueDiscontinuity(ATSParser::DISCONTINUITY_FORMATCHANGE, <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Determine which decoders to shutdown on the player side,</span></span><br><span class="line">        <span class="comment">// a decoder has to be shutdown if its streamtype was active</span></span><br><span class="line">        <span class="comment">// before but now longer isn't.</span></span><br><span class="line">        <span class="keyword">if</span> ((mStreamMask &amp; ~streamMask &amp; indexToType(i))) &#123;</span><br><span class="line">            changedMask |= indexToType(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里会触发kWhatStreamsChanged</span></span><br><span class="line">    sp&lt;AMessage&gt; notify = mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"what"</span>, kWhatStreamsChanged);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"changedMask"</span>, changedMask);</span><br><span class="line"><span class="comment">//将kWhatChangeConfiguration3作为回复消息</span></span><br><span class="line">    msg-&gt;setWhat(kWhatChangeConfiguration3);</span><br><span class="line">    msg-&gt;setTarget(<span class="keyword">this</span>);</span><br><span class="line">    notify-&gt;setMessage(<span class="string">"reply"</span>, msg);</span><br><span class="line">    notify-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line"><span class="keyword">void</span> LiveSession::onChangeConfiguration3(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    mContinuation.clear();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> streamMask, resumeMask;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"streamMask"</span>, (<span class="keyword">int32_t</span> *)&amp;streamMask));</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"resumeMask"</span>, (<span class="keyword">int32_t</span> *)&amp;resumeMask));</span><br><span class="line"></span><br><span class="line">    mNewStreamMask = streamMask | resumeMask;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">    <span class="keyword">int32_t</span> pickTrack;</span><br><span class="line">    <span class="keyword">bool</span> switching = <span class="literal">false</span>;</span><br><span class="line">    CHECK(msg-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"pickTrack"</span>, &amp;pickTrack));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; kMaxStreams; i++) &#123;</span><br><span class="line">        ......</span><br><span class="line">        fetcher-&gt;startAsync(</span><br><span class="line">                sources[kAudioIndex],</span><br><span class="line">                sources[kVideoIndex],</span><br><span class="line">                sources[kSubtitleIndex],</span><br><span class="line">                getMetadataSource(sources, mNewStreamMask, switching),</span><br><span class="line">                startTime.mTimeUs &lt; <span class="number">0</span> ? mLastSeekTimeUs : startTime.mTimeUs,</span><br><span class="line">                startTime.getSegmentTimeUs(),</span><br><span class="line">                startTime.mSeq,</span><br><span class="line">                seekMode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\PlaylistFetcher.cpp]</span><br><span class="line"><span class="keyword">void</span> PlaylistFetcher::startAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AnotherPacketSource&gt; &amp;audioSource,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AnotherPacketSource&gt; &amp;videoSource,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AnotherPacketSource&gt; &amp;subtitleSource,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AnotherPacketSource&gt; &amp;metadataSource,</span><br><span class="line">        <span class="keyword">int64_t</span> startTimeUs,</span><br><span class="line">        <span class="keyword">int64_t</span> segmentStartTimeUs,</span><br><span class="line">        <span class="keyword">int32_t</span> startDiscontinuitySeq,</span><br><span class="line">        LiveSession::SeekMode seekMode) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">    ......</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"streamTypeMask"</span>, streamTypeMask);</span><br><span class="line">    msg-&gt;setInt64(<span class="string">"startTimeUs"</span>, startTimeUs);</span><br><span class="line">    msg-&gt;setInt64(<span class="string">"segmentStartTimeUs"</span>, segmentStartTimeUs);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"startDiscontinuitySeq"</span>, startDiscontinuitySeq);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"seekMode"</span>, seekMode);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> PlaylistFetcher::onStart(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    postMonitorQueue();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> PlaylistFetcher::postMonitorQueue(<span class="keyword">int64_t</span> delayUs, <span class="keyword">int64_t</span> minDelayUs) &#123;</span><br><span class="line">    <span class="keyword">int64_t</span> maxDelayUs = delayUsToRefreshPlaylist();</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatMonitorQueue, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"generation"</span>, mMonitorQueueGeneration);</span><br><span class="line">    msg-&gt;post(delayUs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatDownloadNext:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> generation;</span><br><span class="line">            CHECK(msg-&gt;findInt32(<span class="string">"generation"</span>, &amp;generation));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (generation != mMonitorQueueGeneration) &#123;</span><br><span class="line">                <span class="comment">// Stale event</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (msg-&gt;what() == kWhatMonitorQueue) &#123;</span><br><span class="line">                onMonitorQueue();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onDownloadNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> PlaylistFetcher::onDownloadNext() &#123;</span><br><span class="line">    AString uri;</span><br><span class="line">    sp&lt;AMessage&gt; itemMeta;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    sp&lt;ABuffer&gt; tsBuffer;</span><br><span class="line">    <span class="keyword">int32_t</span> firstSeqNumberInPlaylist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> lastSeqNumberInPlaylist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> connectHTTP = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// block-wise download</span></span><br><span class="line">    <span class="keyword">bool</span> shouldPause = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> bytesRead;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> startUs = ALooper::GetNowUs();</span><br><span class="line">        bytesRead = mHTTPDownloader-&gt;fetchBlock(</span><br><span class="line">                uri.c_str(), &amp;buffer, range_offset, range_length, kDownloadBlockSize,</span><br><span class="line">                <span class="literal">NULL</span> <span class="comment">/* actualURL */</span>, connectHTTP);</span><br><span class="line">        <span class="keyword">int64_t</span> delayUs = ALooper::GetNowUs() - startUs;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (bufferStartsWithTsSyncByte(buffer)) &#123;</span><br><span class="line">            <span class="comment">// Incremental extraction is only supported for MPEG2 transport streams.</span></span><br><span class="line">            <span class="keyword">if</span> (tsBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                tsBuffer = <span class="keyword">new</span> ABuffer(buffer-&gt;data(), buffer-&gt;capacity());</span><br><span class="line">                tsBuffer-&gt;setRange(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tsBuffer-&gt;capacity() != buffer-&gt;capacity()) &#123;</span><br><span class="line">                <span class="keyword">size_t</span> tsOff = tsBuffer-&gt;offset(), tsSize = tsBuffer-&gt;size();</span><br><span class="line">                tsBuffer = <span class="keyword">new</span> ABuffer(buffer-&gt;data(), buffer-&gt;capacity());</span><br><span class="line">                tsBuffer-&gt;setRange(tsOff, tsSize);</span><br><span class="line">            &#125;</span><br><span class="line">            tsBuffer-&gt;setRange(tsBuffer-&gt;offset(), tsBuffer-&gt;size() + bytesRead);</span><br><span class="line">            err = extractAndQueueAccessUnitsFromTs(tsBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">while</span> (bytesRead != <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// bulk extract non-ts files</span></span><br><span class="line">    <span class="keyword">bool</span> startUp = mStartup;</span><br><span class="line">    <span class="keyword">if</span> (tsBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = extractAndQueueAccessUnits(buffer, itemMeta);</span><br><span class="line">        <span class="keyword">if</span> (err == -EAGAIN) &#123;</span><br><span class="line">            <span class="comment">// starting sequence number too low/high</span></span><br><span class="line">            postMonitorQueue();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err == ERROR_OUT_OF_RANGE) &#123;</span><br><span class="line">            <span class="comment">// reached stopping point</span></span><br><span class="line">            notifyStopReached();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            notifyError(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> PlaylistFetcher::extractAndQueueAccessUnits(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;itemMeta) &#123;</span><br><span class="line">    <span class="keyword">if</span> (bufferStartsWithWebVTTMagicSequence(buffer)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStreamTypeMask != LiveSession::STREAMTYPE_SUBTITLES) &#123;</span><br><span class="line">            ALOGE(<span class="string">"This stream only contains subtitles."</span>);</span><br><span class="line">            <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> sp&lt;AnotherPacketSource&gt; packetSource =</span><br><span class="line">            mPacketSources.valueFor(LiveSession::STREAMTYPE_SUBTITLES);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        CHECK(itemMeta-&gt;findInt64(<span class="string">"durationUs"</span>, &amp;durationUs));</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, getSegmentStartTimeUs(mSeqNumber));</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt64(<span class="string">"durationUs"</span>, durationUs);</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt64(<span class="string">"segmentStartTimeUs"</span>, getSegmentStartTimeUs(mSeqNumber));</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">"discontinuitySeq"</span>, mDiscontinuitySeq);</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">"subtitleGeneration"</span>, mSubtitleGeneration);</span><br><span class="line">        packetSource-&gt;queueAccessUnit(buffer);</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (offset &lt; buffer-&gt;size()) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *adtsHeader = buffer-&gt;data() + offset;</span><br><span class="line">        CHECK_LT(offset + <span class="number">5</span>, buffer-&gt;size());</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        sp&lt;ABuffer&gt; unit = <span class="keyword">new</span> ABuffer(aac_frame_length);</span><br><span class="line">        <span class="built_in">memcpy</span>(unit-&gt;data(), adtsHeader, aac_frame_length);</span><br><span class="line"></span><br><span class="line">        unit-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, unitTimeUs);</span><br><span class="line">        setAccessUnitProperties(unit, packetSource);</span><br><span class="line">        packetSource-&gt;queueAccessUnit(unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\mpeg2ts\AnotherPacketSource.cpp]</span><br><span class="line"><span class="keyword">void</span> AnotherPacketSource::queueAccessUnit(<span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> damaged;</span><br><span class="line">    ......</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    mBuffers.push_back(buffer);</span><br><span class="line">    mCondition.signal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> discontinuity;</span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">"discontinuity"</span>, &amp;discontinuity))&#123;</span><br><span class="line">        ALOGV(<span class="string">"queueing a discontinuity with queueAccessUnit"</span>);</span><br><span class="line"></span><br><span class="line">        mLastQueuedTimeUs = <span class="number">0l</span>l;</span><br><span class="line">        mEOSResult = OK;</span><br><span class="line">        mLatestEnqueuedMeta = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        mDiscontinuitySegments.push_back(DiscontinuitySegment());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、获取数据进行解码"><a href="#2-2、获取数据进行解码" class="headerlink" title="2.2、获取数据进行解码"></a>2.2、获取数据进行解码</h5><p>关于解码初始化NuPlayer::instantiateDecoder过程请参考：<a href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</a><br>我们直接看如何获取数据进行解码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::signalResume() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatResume, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> kWhatResume:</span><br><span class="line">&#123;</span><br><span class="line">    resume();</span><br><span class="line">    handled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line"></span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="comment">// Post all available input buffers</span></span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mBuffers[kPortIndexInput].size() == <span class="number">0u</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"[%s] we don't have any input buffers to resume"</span>, mCodec-&gt;mComponentName.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)BufferInfo::OWNED_BY_US);</span><br><span class="line">    sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line">    info-&gt;mData-&gt;meta()-&gt;clear();</span><br><span class="line">    notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line">    notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line">    notify-&gt;post();</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> CodecBase::kWhatFillThisBuffer:</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//..........</span></span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mState == FLUSHED) &#123;</span><br><span class="line">                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onInputBufferAvailable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">        CHECK(handleDequeueInputBuffer(mDequeueInputReplyID));</span><br><span class="line">        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        postActivityNotificationIfPossible();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这个mCallback怎么来的？</span><br><span class="line"></span><br><span class="line">``` cpp</span><br><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onConfigure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.................</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>);</span><br><span class="line">    mCodec-&gt;setCallback(reply);</span><br><span class="line"><span class="comment">//..................</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::setCallback(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;callback) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetCallback, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"callback"</span>, callback);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; response;</span><br><span class="line">    <span class="keyword">return</span> PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> kWhatSetCallback:</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">    CHECK(msg-&gt;senderAwaitsResponse(&amp;replyID));</span><br><span class="line">    sp&lt;AMessage&gt; callback;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"callback"</span>, &amp;callback));</span><br><span class="line"></span><br><span class="line">    mCallback = callback;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCallback != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mFlags |= kFlagIsAsync;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mFlags &amp;= ~kFlagIsAsync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; response = <span class="keyword">new</span> AMessage;</span><br><span class="line">    response-&gt;postReply(replyID);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以根据上面我们可以知道接下来i调用的是kWhatCodecNotify 下的 CB_INPUT_AVAILABLE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">case</span> MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"index"</span>, &amp;index));</span><br><span class="line"></span><br><span class="line">    handleAnInputBuffer(index);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnInputBuffer(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDiscontinuityPending()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getInputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        handleError(UNKNOWN_ERROR);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mInputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add();</span><br><span class="line">            mMediaBuffers.add();</span><br><span class="line">            mInputBufferIsDequeued.add();</span><br><span class="line">            mMediaBuffers.editItemAt(i) = <span class="literal">NULL</span>;</span><br><span class="line">            mInputBufferIsDequeued.editItemAt(i) = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//CHECK_LT(bufferIx, mInputBuffers.size());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaBuffers[index]-&gt;release();</span><br><span class="line">        mMediaBuffers.editItemAt(index) = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.editItemAt(index) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.isEmpty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(<span class="number">0</span>);</span><br><span class="line">        ALOGI(<span class="string">"[%s] resubmitting CSD"</span>, mComponentName.c_str());</span><br><span class="line">        msg-&gt;setBuffer(<span class="string">"buffer"</span>, buffer);</span><br><span class="line">        mCSDsToSubmit.removeAt(<span class="number">0</span>);</span><br><span class="line">        CHECK(onInputBufferFetched(msg));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin();</span><br><span class="line">        <span class="keyword">if</span> (!onInputBufferFetched(msg)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.editItemAt(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push_back(index);</span><br><span class="line"></span><br><span class="line">    onRequestInputBuffers();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::onRequestInputBuffers() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRequestInputBuffersPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// doRequestBuffers() return true if we should request more data</span></span><br><span class="line">    <span class="keyword">if</span> (doRequestBuffers()) &#123;</span><br><span class="line">        mRequestInputBuffersPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatRequestInputBuffers, <span class="keyword">this</span>);</span><br><span class="line">        msg-&gt;post(<span class="number">10</span> * <span class="number">1000l</span>l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::doRequestBuffers() &#123;</span><br><span class="line">    <span class="comment">// mRenderer is only NULL if we have a legacy widevine source that</span></span><br><span class="line">    <span class="comment">// is not yet ready. In this case we must not fetch input.</span></span><br><span class="line">    <span class="keyword">if</span> (isDiscontinuityPending() || mRenderer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    <span class="keyword">while</span> (err == OK &amp;&amp; !mDequeuedInputBuffers.empty()) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bufferIx = *mDequeuedInputBuffers.begin();</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">"buffer-ix"</span>, bufferIx);</span><br><span class="line">        err = fetchInputData(msg);</span><br><span class="line">        <span class="keyword">if</span> (err != OK &amp;&amp; err != ERROR_END_OF_STREAM) &#123;</span><br><span class="line">            <span class="comment">// if EOS, need to queue EOS buffer</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDequeuedInputBuffers.erase(mDequeuedInputBuffers.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mPendingInputMessages.empty()</span><br><span class="line">                || !onInputBufferFetched(msg)) &#123;</span><br><span class="line">            mPendingInputMessages.push_back(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err == -EWOULDBLOCK</span><br><span class="line">            &amp;&amp; mSource-&gt;feedMoreTSData() == OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::Decoder::fetchInputData(sp&lt;AMessage&gt; &amp;reply) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    <span class="keyword">bool</span> dropAccessUnit;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = mSource-&gt;dequeueAccessUnit(mIsAudio, &amp;accessUnit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err == -EWOULDBLOCK) &#123;</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (err == INFO_DISCONTINUITY) &#123;</span><br><span class="line">                <span class="keyword">int32_t</span> type;</span><br><span class="line">                CHECK(accessUnit-&gt;meta()-&gt;findInt32(<span class="string">"discontinuity"</span>, &amp;type));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> formatChange =</span><br><span class="line">                    (mIsAudio &amp;&amp;</span><br><span class="line">                     (type &amp; ATSParser::DISCONTINUITY_AUDIO_FORMAT))</span><br><span class="line">                    || (!mIsAudio &amp;&amp;</span><br><span class="line">                            (type &amp; ATSParser::DISCONTINUITY_VIDEO_FORMAT));</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> timeChange = (type &amp; ATSParser::DISCONTINUITY_TIME) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                ALOGI(<span class="string">"%s discontinuity (format=%d, time=%d)"</span>,</span><br><span class="line">                        mIsAudio ? <span class="string">"audio"</span> : <span class="string">"video"</span>, formatChange, timeChange);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">bool</span> seamlessFormatChange = <span class="literal">false</span>;</span><br><span class="line">                sp&lt;AMessage&gt; newFormat = mSource-&gt;getFormat(mIsAudio);</span><br><span class="line">                <span class="keyword">if</span> (formatChange) &#123;</span><br><span class="line">                    seamlessFormatChange =</span><br><span class="line">                        supportsSeamlessFormatChange(newFormat);</span><br><span class="line">                    <span class="comment">// treat seamless format change separately</span></span><br><span class="line">                    formatChange = !seamlessFormatChange;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// For format or time change, return EOS to queue EOS input,</span></span><br><span class="line">                <span class="comment">// then wait for EOS on output.</span></span><br><span class="line">                <span class="keyword">if</span> (formatChange <span class="comment">/* not seamless */</span>) &#123;</span><br><span class="line">                    mFormatChangePending = <span class="literal">true</span>;</span><br><span class="line">                    err = ERROR_END_OF_STREAM;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeChange) &#123;</span><br><span class="line">                    rememberCodecSpecificData(newFormat);</span><br><span class="line">                    mTimeChangePending = <span class="literal">true</span>;</span><br><span class="line">                    err = ERROR_END_OF_STREAM;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seamlessFormatChange) &#123;</span><br><span class="line">                    <span class="comment">// reuse existing decoder and don't flush</span></span><br><span class="line">                    rememberCodecSpecificData(newFormat);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This stream is unaffected by the discontinuity</span></span><br><span class="line">                    <span class="keyword">return</span> -EWOULDBLOCK;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reply should only be returned without a buffer set</span></span><br><span class="line">            <span class="comment">// when there is an error (including EOS)</span></span><br><span class="line">            CHECK(err != OK);</span><br><span class="line"></span><br><span class="line">            reply-&gt;setInt32(<span class="string">"err"</span>, err);</span><br><span class="line">            <span class="keyword">return</span> ERROR_END_OF_STREAM;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dropAccessUnit = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mIsAudio</span><br><span class="line">                &amp;&amp; !mIsSecure</span><br><span class="line">                &amp;&amp; mRenderer-&gt;getVideoLateByUs() &gt; <span class="number">100000l</span>l</span><br><span class="line">                &amp;&amp; mIsVideoAVC</span><br><span class="line">                &amp;&amp; !IsAVCReferenceFrame(accessUnit)) &#123;</span><br><span class="line">            dropAccessUnit = <span class="literal">true</span>;</span><br><span class="line">            ++mNumInputFramesDropped;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (dropAccessUnit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGV("returned a valid buffer of %s data", mIsAudio ? "mIsAudio" : "video");</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">int64_t</span> mediaTimeUs;</span><br><span class="line">    CHECK(accessUnit-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs));</span><br><span class="line">    ALOGV(<span class="string">"[%s] feeding input buffer at media time %.3f"</span>,</span><br><span class="line">         mIsAudio ? <span class="string">"audio"</span> : <span class="string">"video"</span>,</span><br><span class="line">         mediaTimeUs / <span class="number">1E6</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mCCDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mCCDecoder-&gt;decode(accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply-&gt;setBuffer(<span class="string">"buffer"</span>, accessUnit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、循环获取数据HTTPLiveSource-dequeueAccessUnit"><a href="#2-3、循环获取数据HTTPLiveSource-dequeueAccessUnit" class="headerlink" title="2.3、循环获取数据HTTPLiveSource::dequeueAccessUnit()"></a>2.3、循环获取数据HTTPLiveSource::dequeueAccessUnit()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\httplive\LiveSession.cpp]</span><br><span class="line"><span class="keyword">status_t</span> LiveSession::dequeueAccessUnit(</span><br><span class="line">        StreamType stream, sp&lt;ABuffer&gt; *accessUnit) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> finalResult = OK;</span><br><span class="line">    sp&lt;AnotherPacketSource&gt; packetSource = mPacketSources.valueFor(stream);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = packetSource-&gt;dequeueAccessUnit(accessUnit);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\mpeg2ts\AnotherPacketSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> AnotherPacketSource::dequeueAccessUnit(sp&lt;ABuffer&gt; *buffer) &#123;</span><br><span class="line">    buffer-&gt;clear();</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (mEOSResult == OK &amp;&amp; mBuffers.empty()) &#123;</span><br><span class="line">        mCondition.wait(mLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mBuffers.empty()) &#123;</span><br><span class="line">        *buffer = *mBuffers.begin();</span><br><span class="line">        mBuffers.erase(mBuffers.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> discontinuity;</span><br><span class="line">        <span class="keyword">if</span> ((*buffer)-&gt;meta()-&gt;findInt32(<span class="string">"discontinuity"</span>, &amp;discontinuity)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wasFormatChange(discontinuity)) &#123;</span><br><span class="line">                mFormat.clear();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDiscontinuitySegments.erase(mDiscontinuitySegments.begin());</span><br><span class="line">            <span class="comment">// CHECK(!mDiscontinuitySegments.empty());</span></span><br><span class="line">            <span class="keyword">return</span> INFO_DISCONTINUITY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CHECK(!mDiscontinuitySegments.empty());</span></span><br><span class="line">        DiscontinuitySegment &amp;seg = *mDiscontinuitySegments.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        mLatestDequeuedMeta = (*buffer)-&gt;meta()-&gt;dup();</span><br><span class="line">        CHECK(mLatestDequeuedMeta-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line">        <span class="keyword">if</span> (timeUs &gt; seg.mMaxDequeTimeUs) &#123;</span><br><span class="line">            seg.mMaxDequeTimeUs = timeUs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;RefBase&gt; object;</span><br><span class="line">        <span class="keyword">if</span> ((*buffer)-&gt;meta()-&gt;findObject(<span class="string">"format"</span>, &amp;object)) &#123;</span><br><span class="line">            setFormat(<span class="keyword">static_cast</span>&lt;MetaData*&gt;(object.get()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mEOSResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4、解码后音视频播放过程"><a href="#2-4、解码后音视频播放过程" class="headerlink" title="2.4、解码后音视频播放过程"></a>2.4、解码后音视频播放过程</h5><p>关于解码后播放过程请参考：<a href="http://zhoujinjian.cc/2018/09/12/Android%20Video%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20NuPlayer%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/">Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</a></p><h4 id="（三）、基于NuPlayer的RTSP流媒体协议"><a href="#（三）、基于NuPlayer的RTSP流媒体协议" class="headerlink" title="（三）、基于NuPlayer的RTSP流媒体协议"></a>（三）、基于NuPlayer的RTSP流媒体协议</h4><h5 id="3-1-1、RTSP-概述："><a href="#3-1-1、RTSP-概述：" class="headerlink" title="3.1.1、RTSP 概述："></a>3.1.1、RTSP 概述：</h5><p>RTSP 是Real Time Streaming Protocol（实时流媒体协议）的简称。RTSP提供一种可扩展的框架，使得能够提供可控制的，按需传输实时数据，比如音频和视频文件。RTSP对流媒体提供了诸如暂停，快进等控制，而它本身并不传输数据，RTSP作用相当于流媒体服务器的远程控制。传输数据可以通过传输层的TCP，UDP协议，RTSP也提供了基于 RTP传输机制的一些有效的方法。</p><h5 id="3-1-2、RTSP-模型："><a href="#3-1-2、RTSP-模型：" class="headerlink" title="3.1.2、RTSP 模型："></a>3.1.2、RTSP 模型：</h5><p>客户机在向视频服务器请求视频服务之前，首先通过HTTP协议从WEB服务器获取所请求视频服务的演示描述（Presentation description）文件，在RTSP中，每个演示（Presentation）及其所对应的媒体流都由一个RTSP URL标识。整个演示及媒体特性都在一个演示描述（Presentation description）文件中定义，该文件可能包括媒体编码方式、语言、RTSPURLs、目标地址、端口及其它参数。用户在向服务器请求某个连续媒体流的服务之前，必须首先从服务器获得该媒体流的演示描述（Presentation description ）文件以得到必需的参数。利用该文件提供的信息定位视频服务地址（包括视频服务器地址和端口号）及视频服务的编码方式等信息。<br>客户机根据上述信息向视频服务器请求视频服务。视频服务初始化完毕，视频服务器为该客户建立一个新的视频服务流，客户端与服务器运行实时流控制协议RTSP，以对该流进行各种VCR 控制信号的交换，如播放、暂停、快进、快退等。当服务完毕，客户端提出拆线（TEARDOWN）请求。服务器使用 RTP协议将媒体数据传输给客户端，一旦数据抵达客户端，客户端应用程序即可播放输出。在流式传输中，使用RTP/RTCP和RTSP /TCP两种不同的通信协议在客户端和服务器间建立联系。如下图：</p><h5 id="3-1-3、RTSP-协议消息格式："><a href="#3-1-3、RTSP-协议消息格式：" class="headerlink" title="3.1.3、RTSP 协议消息格式："></a>3.1.3、RTSP 协议消息格式：</h5><p>请求消息格式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法   URI  RTSP版本   CR  LF </span><br><span class="line">消息头 CR   LF   CR  LF </span><br><span class="line">消息体 CR   LF</span><br></pre></td></tr></table></figure><p>其中方法包括OPTION回应中所有的命令,URI是接受方的地址,例如<br>rtsp://192.168.20.136</p><p>RTSP版本一般都是 RTSP/1.0.每行后面的CR LF表示回车换行，需要接受端有相应的解析，最后一个消息头需要有两个CR LF</p><p>回应消息格式:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RTSP版本  状态码  解释 CR  LF </span><br><span class="line">消息头 CR  LF  CR  LF </span><br><span class="line">消息体 CR  LF</span><br></pre></td></tr></table></figure><p>其中RTSP版本一般都是RTSP/1.0,状态码是一个数值,200表示成功,解释是与状态码对应的文本解释。</p><h5 id="3-1-4、简单的RTSP-交互过程"><a href="#3-1-4、简单的RTSP-交互过程" class="headerlink" title="3.1.4、简单的RTSP 交互过程:"></a>3.1.4、简单的RTSP 交互过程:</h5><p>下面以一次流媒体播放为例介绍整个播放过程的RTSP状态转换的流程：<br>其中C表示RTSP客户端,S表示RTSP服务端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C-&gt;S:OPTION     request        <span class="comment">//询问服务端有哪些方法可用</span></span><br><span class="line">S-&gt;C:OPTION     response       <span class="comment">//服务端回应信息中包括提供的所有可用方法 </span></span><br><span class="line"></span><br><span class="line">C-&gt;S:DESCRIBE    request        <span class="comment">//要求得到服务端提供的媒体初始化描述信息 </span></span><br><span class="line">S-&gt;C:DESCRIBE    response       <span class="comment">//服务端回应媒体初始化描述信息，主要是SDP</span></span><br><span class="line"></span><br><span class="line">C-&gt;S:SETUP       request        <span class="comment">//设置会话的属性，以及传输模式提醒服务端建立会话 </span></span><br><span class="line">S-&gt;C:SETUP       response       <span class="comment">//服务端建立会话，返回会话标识符，和会话相关信息 </span></span><br><span class="line"></span><br><span class="line">C-&gt;S:PLAY        request         <span class="comment">//客户端请求播放 </span></span><br><span class="line">S-&gt;C:PLAY        response       <span class="comment">//服务器回应该请求的信息 </span></span><br><span class="line"></span><br><span class="line">S-&gt;C:                           <span class="comment">//发送流媒体数据 </span></span><br><span class="line"></span><br><span class="line">C-&gt;S:TEARDOWN    request        <span class="comment">//客户端请求关闭会话 </span></span><br><span class="line">S-&gt;C:TEARDOWN    response <span class="comment">//服务端回应该请求</span></span><br></pre></td></tr></table></figure><p>其中第SETUP和PLAY这两部是必需的，<br>OPTION 步骤只要服务器客户端约定好，有哪些方法可用，则option请求可以不要。<br>如果我们有其他途径得到媒体初始化描述信息，则我们也不需要通过RTSP中的DESCRIPTION请求来完成。<br>TEARDOWN，可以根据系统需求的设计来决定是否需要。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-07-RTSP-TEARDOWN.png" alt="Alt text | center"></p><h5 id="3-1-5、RTSP的主要命令表："><a href="#3-1-5、RTSP的主要命令表：" class="headerlink" title="3.1.5、RTSP的主要命令表："></a>3.1.5、RTSP的主要命令表：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-08-RTSP-option.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-09-RTSP-describe.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-10-RTSP-setup.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-11-RTSP-play.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-12-RTSP-teardowm.png" alt="Alt text | center"></p><p>RTSP状态码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Status-Code =</span><br><span class="line">| <span class="string">"100"</span> ; Continue</span><br><span class="line">| <span class="string">"200"</span> ; OK</span><br><span class="line">| <span class="string">"201"</span> ; Created</span><br><span class="line">| <span class="string">"250"</span> ; Low on Storage Space</span><br><span class="line">| <span class="string">"300"</span> ; Multiple Choices</span><br><span class="line">| <span class="string">"301"</span> ;Moved Permanently</span><br><span class="line">| <span class="string">"302"</span> ; Moved Temporarily</span><br><span class="line">| <span class="string">"303"</span> ; See Other</span><br><span class="line">| <span class="string">"304"</span> ; Not Modified</span><br><span class="line">| <span class="string">"305"</span> ; Use Proxy</span><br><span class="line">| <span class="string">"400"</span> ; Bad Request</span><br><span class="line">| <span class="string">"401"</span> ; Unauthorized</span><br><span class="line">| <span class="string">"402"</span> ; Payment Required</span><br><span class="line">| <span class="string">"403"</span> ; Forbidden</span><br><span class="line">| <span class="string">"404"</span> ; Not Found</span><br><span class="line">| <span class="string">"405"</span> ; Method Not Allowed</span><br><span class="line">| <span class="string">"406"</span> ; Not Acceptable</span><br><span class="line">| <span class="string">"407"</span> ; Proxy Authentication Required</span><br><span class="line">| <span class="string">"408"</span> ; Request Time-out</span><br><span class="line">| <span class="string">"410"</span> ; Gone</span><br><span class="line">| <span class="string">"411"</span> ; Length Required</span><br><span class="line">| <span class="string">"412"</span> ; Precondition Failed</span><br><span class="line">| <span class="string">"413"</span> ; Request Entity Too Large</span><br><span class="line">| <span class="string">"414"</span> ; Request-URI Too Large</span><br><span class="line">| <span class="string">"415"</span> ; Unsupported Media Type</span><br><span class="line">| <span class="string">"451"</span> ; Parameter Not Understood</span><br><span class="line">| <span class="string">"452"</span> ; Conference Not Found</span><br><span class="line">| <span class="string">"453"</span> ; Not Enough Bandwidth</span><br><span class="line">| <span class="string">"454"</span> ; Session Not Found</span><br><span class="line">| <span class="string">"455"</span> ; Method Not Valid in This State</span><br><span class="line">| <span class="string">"456"</span> ; Header Field Not Valid <span class="keyword">for</span> Resource</span><br><span class="line">| <span class="string">"457"</span> ; Invalid Range</span><br><span class="line">| <span class="string">"458"</span> ; Parameter Is Read-Only</span><br><span class="line">| <span class="string">"459"</span> ;Aggregate operation <span class="keyword">not</span> allowed</span><br><span class="line">| <span class="string">"460"</span> ; Only aggregate operation allowed</span><br><span class="line">| <span class="string">"461"</span> ; Unsupported transport</span><br><span class="line">| <span class="string">"462"</span> ; Destination unreachable</span><br><span class="line">| <span class="string">"500"</span> ; Internal Server Error</span><br><span class="line">| <span class="string">"501"</span> ; Not Implemented</span><br><span class="line">| <span class="string">"502"</span> ; Bad Gateway</span><br><span class="line">| <span class="string">"503"</span> ; Service Unavailable</span><br><span class="line">| <span class="string">"504"</span> ; Gateway Time-out</span><br><span class="line">| <span class="string">"505"</span> ; RTSP Version <span class="keyword">not</span> supported</span><br><span class="line">| <span class="string">"551"</span> ; Option <span class="keyword">not</span> supported</span><br></pre></td></tr></table></figure><h5 id="3-1-6、SDP的格式："><a href="#3-1-6、SDP的格式：" class="headerlink" title="3.1.6、SDP的格式："></a>3.1.6、SDP的格式：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">v=&lt;version&gt;                            (协议版本)</span><br><span class="line">o=&lt;username&gt; &lt;session id&gt; &lt;version&gt; &lt;network type&gt; &lt;address type&gt; &lt;address&gt;                              （所有者/创建者和会话标识符）</span><br><span class="line">s=&lt;session name&gt;                       （会话名称）</span><br><span class="line">i=&lt;session description&gt;                （会话信息） </span><br><span class="line">u=&lt;URI&gt;                                （URI 描述）</span><br><span class="line">e=&lt;email address&gt;                      （Email 地址）</span><br><span class="line">p=&lt;phone number&gt;                       （电话号码）</span><br><span class="line">c=&lt;network type&gt; &lt;address type&gt; &lt;connection address&gt;   （连接信息）</span><br><span class="line">b=&lt;modifier&gt;:&lt;bandwidth-value&gt;         （带宽信息）</span><br><span class="line">t=&lt;start time&gt; &lt;stop time&gt;             （会话活动时间）</span><br><span class="line">r=&lt;repeat interval&gt; &lt;active duration&gt; &lt;<span class="built_in">list</span> of offsets from start-time&gt; </span><br><span class="line">                                        （<span class="number">0</span>或多次重复次数）</span><br><span class="line">z=&lt;adjustment time&gt; &lt;offset&gt; &lt;adjustment time&gt; &lt;offset&gt;（时间区域调整）</span><br><span class="line">k=&lt;method&gt;:&lt;encryption key&gt;             （加密密钥）</span><br><span class="line">a=&lt;attribute&gt;:&lt;value&gt;                   （<span class="number">0</span> 个或多个会话属性行）</span><br><span class="line">m=&lt;media&gt; &lt;port&gt; &lt;transport&gt; &lt;fmt <span class="built_in">list</span>&gt; （媒体名称和传输地址）</span><br><span class="line"></span><br><span class="line">时间描述： </span><br><span class="line">t = （会话活动时间） </span><br><span class="line">r = * （<span class="number">0</span>或多次重复次数） </span><br><span class="line">媒体描述： </span><br><span class="line">m = （媒体名称和传输地址） </span><br><span class="line">i = * （媒体标题） </span><br><span class="line">c = * （连接信息 — 如果包含在会话层则该字段可选） </span><br><span class="line">b = * （带宽信息） </span><br><span class="line">k = * （加密密钥） </span><br><span class="line">a = * （<span class="number">0</span> 个或多个媒体属性行）</span><br></pre></td></tr></table></figure><h5 id="3-1-7、RTP协议："><a href="#3-1-7、RTP协议：" class="headerlink" title="3.1.7、RTP协议："></a>3.1.7、RTP协议：</h5><p>实时传输协议（Real-time Transport Protocol，RTP）是用来在单播或者多播的情境中传流媒体数据的数据传输协议。通常使用UDP来进行多媒体数据的传输，也不排除使用TCP或者ATM等其它协议作为它的载体，整个RTP 协议由两个密切相关的部分组成：RTP数据协议和RTP控制协议（也就是RTCP协议）。<br>RTP为Internet上端到端的实时传输提供时间信息和流同步，但它并不保证服务质量，服务质量由RTCP来提供。</p><ul><li><p>使用RTP协议进行数据传输的一个简要RTP的会话过程：<br>当应用程序建立一个RTP会话时，应用程序将确定一对目的传输地址。目的传输地址由一个网络地址和一对端口组成，有两个端口：一个给RTP包，一个给RTCP包，也就是说RTP和RTCP数据包是分开传输的，这样可以使得RTP/RTCP数据能够正确发送。其中RTP数据发向偶数的UDP端口，而对应的控制信号RTCP数据发向相邻的奇数UDP端口，这样就构成一个UDP端口对。<br>当发送数据的时候RTP协议从上层接收流媒体信息码流，封装成RTP数据包；RTCP从上层接收控制信息，封装成RTCP控制包。RTP将RTP 数据包发往UDP端口对中偶数端口；RTCP将RTCP控制包发往UDP端口对中的接收端口。<br>如果在一次会议中同时使用了音频和视频会议，这两种媒体将分别在不同的RTP会话中传送，每一个会话使用不同的传输地址（IP地址＋端口）。如果一个用户同时使用了两个会话，则每个会话对应的RTCP包都使用规范化名字CNAME（Canonical Name）。与会者可以根据RTCP包中的CNAME来获取相关联的音频和视频，然后根据RTCP包中的计时信息(Network time protocol)来实现音频和视频的同步。</p></li><li><p>翻译器和混合器<br>在RTP协议中还引入了翻译器和混合器。翻译器和混合器都是RTP级的中继系统。<br>混合器的使用情景：<br>在Internet上举行视频会议时，可能有少数参加者通过低速链路与使用高速网络的多数参加者相连接。为了不强制所有会议参加者都使用低带宽和低质量的数据编码，RTP允许在低带宽区域附近使用混合器作为RTP级中继器。混合器从一个或多个信源接收RTP报文，对到达的数据报文进行重新同步和重新组合，这些重组的数据流被混合成一个数据流，将数据编码转化为在低带宽上可用的类型，并通过低速链路向低带宽区域转发。为了对多个输入信源进行统一的同步，混合器在多个媒体流之间进行定时调整，产生它自己的定时同步，因此所有从混合器输出的报文都把混合器作为同步信源。为了保证接收者能够正确识别混合器处理前的原始报文发送者，混合器在RTP报头中设置了CSRC标识符队列，以标识那些产生混和报文的原始同步信源。<br>翻译器的使用情景<br>在Internet环境中，一些会议的参加者可能被隔离在应用级防火墙的外面，这些参加者被禁止直接使用IP组播地址进行访问，虽然他们可能是通过高速链路连接的。在这些情况下，RTP允许使用转换器作为RTP级中继器。在防火墙两端分别安装一个转换器，防火墙之外的转换器过滤所有接收到的组播报文，并通过一条安全的连接传送给防火墙之内的转换器，内部转换器将这些组播报文再转发送给内部网络中的组播组成员</p><h5 id="3-1-8、RTP协议报头格式"><a href="#3-1-8、RTP协议报头格式" class="headerlink" title="3.1.8、RTP协议报头格式"></a>3.1.8、RTP协议报头格式</h5></li></ul><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-13-RTSP-baotou1.png" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-14-RTSP-baotou2.png" alt="Alt text | center"></p><h5 id="3-1-9、RTCP协议报头格式"><a href="#3-1-9、RTCP协议报头格式" class="headerlink" title="3.1.9、RTCP协议报头格式"></a>3.1.9、RTCP协议报头格式</h5><p>如前面所述RTCP的主要功能是：服务质量的监视与反馈、媒体间的同步，以及多播组中成员的标识。在RTP会话期间，各参与者周期性地传送RTCP包。RTCP包中含有已发送的数据包的数量、丢失的数据包的数量等统计资料，因此，各参与者可以利用这些信息动态地改变传输速率，甚至改变有效载荷类型。RTP和RTCP配合使用，它们能以有效的反馈和最小的开销使传输效率最佳化，因而特别适合传送网上的实时数据。RTCP也是用UDP来传送的，但RTCP封装的仅仅是一些控制信息，因而分组很短，所以可以将多个RTCP分组封装在一个UDP包中。<br>RTCP有如下五种分组类型：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-15-RTCP-baotou1.png" alt="Alt text | center"></p><p>下面是SR分组的格式：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-16-RTCP-baotou2.png" alt="Alt text | center"></p><h5 id="3-2、基于NuPLayer的RTSP-代码流程"><a href="#3-2、基于NuPLayer的RTSP-代码流程" class="headerlink" title="3.2、基于NuPLayer的RTSP 代码流程"></a>3.2、基于NuPLayer的RTSP 代码流程</h5><p>setDataSource 阶段的任务这里就不重复介绍了，它主要完成播放引擎的建立以及根据URL格式创建对应的Source，比如这里将要提到的RTSPSource，然后赋值给mSource。</p><p>我们直接来看prepare阶段：</p><p>先上图再看代码，结合图看会比较清晰<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-17-ARTSPConnection.png" alt="Alt text | center"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-18-ARTSP-Source.png" alt="Alt text | center"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-19-ARTSP-Source-state.png" alt="Alt text | center"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-06-20-ARTSP-Source-state2.png" alt="Alt text | center"></p><h5 id="3-3、RTSPSource-prepareAsync-流程"><a href="#3-3、RTSPSource-prepareAsync-流程" class="headerlink" title="3.3、RTSPSource::prepareAsync()流程"></a>3.3、RTSPSource::prepareAsync()流程</h5><p>在prepare阶段我们首先会判断是否是SDP，mIsSDP这个变量是在初始化RTSPSource时候传入的，我们这里先分析mIsSDP = false的情况。这种情况下首先创建一个MyHandler，并调用connect，与服务器建立连接。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\RTSPSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::RTSPSource::prepareAsync() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//..........</span></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatNotify, <span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检查当前状态是否为DISCONNECTED</span></span><br><span class="line">    CHECK_EQ(mState, (<span class="keyword">int</span>)DISCONNECTED);</span><br><span class="line">    <span class="comment">//设置当前状态为CONNECTING</span></span><br><span class="line">    mState = CONNECTING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsSDP) &#123;</span><br><span class="line">        <span class="comment">//如果是SDP那么就需要创建一个SDPLoader 从服务器上加载一个描述文件</span></span><br><span class="line">        mSDPLoader = <span class="keyword">new</span> SDPLoader(notify, (mFlags &amp; kFlagIncognito) ? SDPLoader::kFlagIncognito : <span class="number">0</span>, mHTTPService);</span><br><span class="line">        mSDPLoader-&gt;load(mURL.c_str(), mExtraHeaders.isEmpty() ? <span class="literal">NULL</span> : &amp;mExtraHeaders);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是SDP 那么就使用MyHandler 来进行连接</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> MyHandler(mURL.c_str(), notify, mUIDValid, mUID);</span><br><span class="line">        mLooper-&gt;registerHandler(mHandler);</span><br><span class="line">        mHandler-&gt;connect();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//启动缓存</span></span><br><span class="line">    startBufferingIfNecessary();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在介绍connect方法之前需要先了解mConn以及mRTPConn这两个成员变量，mConn是一个ARTSPConnection，它主要与服务器相连，发送和接收请求数据，mRTPConn是一个ARTPConnection 用于发送和接收媒体数据。<br>在connect方法中会使用mConn向服务器发起连接请求。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\MyHandler.h]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mConn(new ARTSPConnection(mUIDValid, mUID)),</span></span><br><span class="line">    looper()-&gt;registerHandler(mConn);</span><br><span class="line">    <span class="comment">//mRTPConn(new ARTPConnection),</span></span><br><span class="line">    (<span class="number">1</span> ? mNetLooper : looper())-&gt;registerHandler(mRTPConn);</span><br><span class="line">    sp&lt;AMessage&gt; notify = new AMessage('biny', this);</span><br><span class="line">    mConn-&gt;observeBinaryData(notify);</span><br><span class="line">    <span class="comment">//连接服务</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = new AMessage('conn', this);</span><br><span class="line">    mConn-&gt;connect(mOriginalSessionURL.c_str(), reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTSPConnection.cpp]</span><br><span class="line"><span class="keyword">void</span> ARTSPConnection::connect(<span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;reply) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConnect, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">"url"</span>, url);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> kWhatConnect:</span><br><span class="line">    onConnect(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>在ARTSPConnection::onConnect中将会从传递过来的URl中解析host，port，path，mUser，mPass，并调用::connect 和服务器取得联系，最后调用postReceiveReponseEvent将请求的回复响应暂存起来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTSPConnection.cpp]</span><br><span class="line"><span class="keyword">void</span> ARTSPConnection::onConnect(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    ++mConnectionID;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mState != DISCONNECTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">            HTTPBase::UnRegisterSocketUserTag(mSocket);</span><br><span class="line">            HTTPBase::UnRegisterSocketUserMark(mSocket);</span><br><span class="line">        &#125;</span><br><span class="line">        close(mSocket);</span><br><span class="line">        mSocket = <span class="number">-1</span>;</span><br><span class="line">        flushPendingRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mState = CONNECTING;</span><br><span class="line">    AString url;</span><br><span class="line">    <span class="comment">//从消息中取下Url</span></span><br><span class="line">    CHECK(msg-&gt;findString(<span class="string">"url"</span>, &amp;url));</span><br><span class="line">    sp&lt;AMessage&gt; reply;</span><br><span class="line">    <span class="comment">//从消息中取下replay</span></span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"reply"</span>, &amp;reply));</span><br><span class="line"></span><br><span class="line">    AString host, path;</span><br><span class="line">    <span class="keyword">unsigned</span> port;</span><br><span class="line">    <span class="comment">//从URl中解析host，port，path，mUser，mPass</span></span><br><span class="line">    <span class="keyword">if</span> (!ParseURL(url.c_str(), &amp;host, &amp;port, &amp;path, &amp;mUser, &amp;mPass)</span><br><span class="line">            || (mUser.size() &gt; <span class="number">0</span> &amp;&amp; mPass.size() == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有用户名，但是没有密码，返回错误信息</span></span><br><span class="line">        <span class="comment">// If we have a user name but no password we have to give up</span></span><br><span class="line">        <span class="comment">// right here, since we currently have no way of asking the user</span></span><br><span class="line">        <span class="comment">// for this information.</span></span><br><span class="line">        ALOGE(<span class="string">"Malformed rtsp url %s"</span>, uriDebugString(url).c_str());</span><br><span class="line">        reply-&gt;setInt32(<span class="string">"result"</span>, ERROR_MALFORMED);</span><br><span class="line">        reply-&gt;post();</span><br><span class="line">        mState = DISCONNECTED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUser.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"user = '%s', pass = '%s'"</span>, mUser.c_str(), mPass.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">ent</span> = <span class="title">gethostbyname</span>(<span class="title">host</span>.<span class="title">c_str</span>());</span></span><br><span class="line">    <span class="keyword">if</span> (ent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Unknown host %s"</span>, host.c_str());</span><br><span class="line">        reply-&gt;setInt32(<span class="string">"result"</span>, -ENOENT);</span><br><span class="line">        reply-&gt;post();</span><br><span class="line">        mState = DISCONNECTED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mSocket = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">        HTTPBase::RegisterSocketUserTag(mSocket, mUID,(<span class="keyword">uint32_t</span>)*(<span class="keyword">uint32_t</span>*) <span class="string">"RTSP"</span>);</span><br><span class="line">        HTTPBase::RegisterSocketUserMark(mSocket, mUID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MakeSocketBlocking(mSocket, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">remote</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(remote.sin_zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(remote.sin_zero));</span><br><span class="line">    remote.sin_family = AF_INET;</span><br><span class="line">    remote.sin_addr.s_addr = *(<span class="keyword">in_addr_t</span> *)ent-&gt;h_addr;</span><br><span class="line">    remote.sin_port = htons(port);</span><br><span class="line">    <span class="comment">//连接到服务器</span></span><br><span class="line">    <span class="keyword">int</span> err = ::connect(mSocket, (<span class="keyword">const</span> struct sockaddr *)&amp;remote, <span class="keyword">sizeof</span>(remote));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回服务器ip</span></span><br><span class="line">    reply-&gt;setInt32(<span class="string">"server-ip"</span>, ntohl(remote.sin_addr.s_addr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINPROGRESS) &#123;</span><br><span class="line">            sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatCompleteConnection, <span class="keyword">this</span>);</span><br><span class="line">            msg-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line">            msg-&gt;setInt32(<span class="string">"connection-id"</span>, mConnectionID);</span><br><span class="line">            msg-&gt;post();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply-&gt;setInt32(<span class="string">"result"</span>, -errno);</span><br><span class="line">        mState = DISCONNECTED;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">            HTTPBase::UnRegisterSocketUserTag(mSocket);</span><br><span class="line">            HTTPBase::UnRegisterSocketUserMark(mSocket);</span><br><span class="line">        &#125;</span><br><span class="line">        close(mSocket);</span><br><span class="line">        mSocket = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//成功的花返回result为OK</span></span><br><span class="line">        reply-&gt;setInt32(<span class="string">"result"</span>, OK);</span><br><span class="line">        <span class="comment">//设置状态为CONNECTED</span></span><br><span class="line">        mState = CONNECTED;</span><br><span class="line">        mNextCSeq = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//发送等待返回消息</span></span><br><span class="line">        postReceiveReponseEvent();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//‘conn’</span></span><br><span class="line">    reply-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来看下postReceiveReponseEvent,调用receiveRTSPReponse获得服务器的回复</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="keyword">void</span> ARTSPConnection::postReceiveReponseEvent() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiveResponseEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatReceiveResponse, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">    mReceiveResponseEventPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ARTSPConnection::onReceiveResponse() &#123;</span><br><span class="line">    mReceiveResponseEventPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mState != CONNECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">    tv.tv_usec = kSelectTimeoutUs;</span><br><span class="line">    fd_set rs;</span><br><span class="line">    FD_ZERO(&amp;rs);</span><br><span class="line">    FD_SET(mSocket, &amp;rs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择一个返回的连接</span></span><br><span class="line">    <span class="keyword">int</span> res = select(mSocket + <span class="number">1</span>, &amp;rs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">        MakeSocketBlocking(mSocket, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">bool</span> success = receiveRTSPReponse();</span><br><span class="line">        MakeSocketBlocking(mSocket, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="comment">// Something horrible, irreparable has happened.</span></span><br><span class="line">            flushPendingRequests();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postReceiveReponseEvent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的receiveRTSPReponse是有双重功能的，方面可以接收从服务器发来的请求，另一方面可以处理服务器发来的应答信号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTSPConnection.cpp]</span><br><span class="line"><span class="keyword">bool</span> ARTSPConnection::receiveRTSPReponse() &#123;</span><br><span class="line"></span><br><span class="line">    AString statusLine;</span><br><span class="line">    <span class="keyword">if</span> (!receiveLine(&amp;statusLine)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (statusLine == <span class="string">"$"</span>) &#123;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = receiveBinaryData();</span><br><span class="line">        <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mObserveBinaryMessage != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sp&lt;AMessage&gt; notify = mObserveBinaryMessage-&gt;dup();</span><br><span class="line">            notify-&gt;setBuffer(<span class="string">"buffer"</span>, buffer);</span><br><span class="line">            notify-&gt;post();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGW(<span class="string">"received binary data, but no one cares."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RTSP返回对象</span></span><br><span class="line">    sp&lt;ARTSPResponse&gt; response = <span class="keyword">new</span> ARTSPResponse;</span><br><span class="line">    response-&gt;mStatusLine = statusLine;</span><br><span class="line">    ALOGI(<span class="string">"status: %s"</span>, response-&gt;mStatusLine.c_str());</span><br><span class="line">    <span class="keyword">ssize_t</span> space1 = response-&gt;mStatusLine.find(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (space1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">ssize_t</span> space2 = response-&gt;mStatusLine.find(<span class="string">" "</span>, space1 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (space2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isRequest = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//判断返回的RTSP版本是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (!IsRTSPVersion(AString(response-&gt;mStatusLine, <span class="number">0</span>, space1))) &#123;</span><br><span class="line">        CHECK(IsRTSPVersion(AString(response-&gt;mStatusLine,space2 + <span class="number">1</span>,response-&gt;mStatusLine.size() - space2 - <span class="number">1</span>)));</span><br><span class="line">        isRequest = <span class="literal">true</span>;</span><br><span class="line">        response-&gt;mStatusCode = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//判断状态码是否正确</span></span><br><span class="line">        AString statusCodeStr(response-&gt;mStatusLine, space1 + <span class="number">1</span>, space2 - space1 - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ParseSingleUnsignedLong(statusCodeStr.c_str(), &amp;response-&gt;mStatusCode) || response-&gt;mStatusCode &lt; <span class="number">100</span> || response-&gt;mStatusCode &gt; <span class="number">999</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AString line;</span><br><span class="line">    <span class="keyword">ssize_t</span> lastDictIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!receiveLine(&amp;line)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (line.empty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGV(<span class="string">"line: '%s'"</span>, line.c_str());</span><br><span class="line">        <span class="keyword">if</span> (line.c_str()[<span class="number">0</span>] == <span class="string">' '</span> || line.c_str()[<span class="number">0</span>] == <span class="string">'\t'</span>) &#123;</span><br><span class="line">            <span class="comment">// Support for folded header values.</span></span><br><span class="line">            <span class="keyword">if</span> (lastDictIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// First line cannot be a continuation of the previous one.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            AString &amp;value = response-&gt;mHeaders.editValueAt(lastDictIndex);</span><br><span class="line">            value.append(line);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">ssize_t</span> colonPos = line.find(<span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (colonPos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Malformed header line.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">AString <span class="title">key</span><span class="params">(line, <span class="number">0</span>, colonPos)</span></span>;</span><br><span class="line">        key.trim();</span><br><span class="line">        key.<span class="built_in">tolower</span>();</span><br><span class="line">        line.erase(<span class="number">0</span>, colonPos + <span class="number">1</span>);</span><br><span class="line">        lastDictIndex = response-&gt;mHeaders.add(key, line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; response-&gt;mHeaders.size(); ++i) &#123;</span><br><span class="line">        response-&gt;mHeaders.editValueAt(i).trim();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> contentLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> i = response-&gt;mHeaders.indexOfKey(<span class="string">"content-length"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AString value = response-&gt;mHeaders.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!ParseSingleUnsignedLong(value.c_str(), &amp;contentLength)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收mContent</span></span><br><span class="line">    <span class="keyword">if</span> (contentLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        response-&gt;mContent = <span class="keyword">new</span> ABuffer(contentLength);</span><br><span class="line">        <span class="keyword">if</span> (receive(response-&gt;mContent-&gt;data(), contentLength) != OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//isRequest 表示是服务器主动发送的请求，那么将调用handleServerRequest，否则表示是服务器被动响应客户端的请求，那么将通知服务器有响应了notifyResponseListener</span></span><br><span class="line">    <span class="keyword">return</span> isRequest</span><br><span class="line">        ? handleServerRequest(response)</span><br><span class="line">        : notifyResponseListener(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>isRequest 表示是服务器主动发送的请求，那么将调用handleServerRequest，否则表示是服务器被动响应客户端的请求，那么将通知服务器有响应了notifyResponseListener，我们这里先看下这两个方法的实现：</p><p>看到handleServerRequest大家可能会有点失望，因为这里尚未实现这个功能所以只是向服务器返回一个“RTSP/1.0 501 Not Implemented”的消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTSPConnection.cpp]</span><br><span class="line"><span class="keyword">bool</span> ARTSPConnection::handleServerRequest(<span class="keyword">const</span> sp&lt;ARTSPResponse&gt; &amp;request) &#123;</span><br><span class="line">    <span class="comment">// Implementation of server-&gt;client requests is optional for all methods</span></span><br><span class="line">    <span class="comment">// but we do need to respond, even if it's just to say that we don't</span></span><br><span class="line">    <span class="comment">// support the method.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里我们不实现任何答复行为只是简单反馈我们尚未实现这个功能</span></span><br><span class="line">    <span class="keyword">ssize_t</span> space1 = request-&gt;mStatusLine.find(<span class="string">" "</span>);</span><br><span class="line">    CHECK_GE(space1, <span class="number">0</span>);</span><br><span class="line">    AString response;</span><br><span class="line">    response.append(<span class="string">"RTSP/1.0 501 Not Implemented\r\n"</span>);</span><br><span class="line">    <span class="keyword">ssize_t</span> i = request-&gt;mHeaders.indexOfKey(<span class="string">"cseq"</span>);</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        AString value = request-&gt;mHeaders.valueAt(i);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> cseq;</span><br><span class="line">        <span class="keyword">if</span> (!ParseSingleUnsignedLong(value.c_str(), &amp;cseq)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.append(<span class="string">"CSeq: "</span>);</span><br><span class="line">        response.append(cseq);</span><br><span class="line">        response.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    response.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> numBytesSent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (numBytesSent &lt; response.size()) &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> n =</span><br><span class="line">            send(mSocket, response.c_str() + numBytesSent,</span><br><span class="line">                 response.size() - numBytesSent, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Server closed the connection.</span></span><br><span class="line">                ALOGE(<span class="string">"Server unexpectedly closed the connection."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"Error sending rtsp response (%s)."</span>, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">            performDisconnect();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        numBytesSent += (<span class="keyword">size_t</span>)n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>notifyResponseListener的实现比较清晰，它会根据服务器发来的应答响应，找出响应该应答的Message，然后将response返回给MyHandler，进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTSPConnection.cpp]</span><br><span class="line"><span class="keyword">bool</span> ARTSPConnection::notifyResponseListener(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ARTSPResponse&gt; &amp;response) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> i;</span><br><span class="line">    <span class="comment">//在队列中查找尚未处理的请求</span></span><br><span class="line">    <span class="keyword">status_t</span> err = findPendingRequest(response, &amp;i);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//发送服务器的回复给它</span></span><br><span class="line">    sp&lt;AMessage&gt; reply = mPendingRequests.valueAt(i);</span><br><span class="line">    mPendingRequests.removeItemsAt(i);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"result"</span>, OK);</span><br><span class="line">    reply-&gt;setObject(<span class="string">"response"</span>, response);</span><br><span class="line">    reply-&gt;post();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了我们言归正传，我们看下MyHandler中对conn回复怎么处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\MyHandler.h]</span><br><span class="line">case 'conn':</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    <span class="comment">//取出反馈结果</span></span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"result"</span>, &amp;result));</span><br><span class="line">    <span class="keyword">if</span> (result == OK) &#123;</span><br><span class="line">        <span class="comment">//发送请求描述符的消息</span></span><br><span class="line">        AString request;</span><br><span class="line">        request = <span class="string">"DESCRIBE "</span>;</span><br><span class="line">        request.append(mSessionURL);</span><br><span class="line">        request.append(<span class="string">" RTSP/1.0\r\n"</span>);</span><br><span class="line">        request.append(<span class="string">"Accept: application/sdp\r\n"</span>);</span><br><span class="line">        request.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        sp&lt;AMessage&gt; reply = new AMessage('desc', this);</span><br><span class="line">        mConn-&gt;sendRequest(request.c_str(), reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (new AMessage('disc', this))-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较简单就是收到答复之后，直接判断结果是OK还是不OK，如果OK那么就发送一个DESCRIBE的请求。我们重点看下，onSendRequest理解这个很重要：<br>在onSendRequest中会对请求加工处理下，比如添加Cseq等操作，然后就会调用send向服务器发送请求。并将请求以Cseq为键码，replay为回复消息的待处理请求队列中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTSPConnection.cpp]</span><br><span class="line"><span class="keyword">void</span> ARTSPConnection::onSendRequest(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; reply;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"reply"</span>, &amp;reply));</span><br><span class="line">    <span class="comment">//对请求进行加工处理</span></span><br><span class="line">    AString request;</span><br><span class="line">    CHECK(msg-&gt;findString(<span class="string">"request"</span>, &amp;request));</span><br><span class="line">    <span class="comment">// Just in case we need to re-issue the request with proper authentication</span></span><br><span class="line">    <span class="comment">// later, stash it away.</span></span><br><span class="line">    reply-&gt;setString(<span class="string">"original-request"</span>, request.c_str(), request.size());</span><br><span class="line">    addAuthentication(&amp;request);</span><br><span class="line">    addUserAgent(&amp;request);</span><br><span class="line">    <span class="comment">// Find the boundary between headers and the body.</span></span><br><span class="line">    <span class="keyword">ssize_t</span> i = request.find(<span class="string">"\r\n\r\n"</span>);</span><br><span class="line">    CHECK_GE(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int32_t</span> cseq = mNextCSeq++;</span><br><span class="line">    AString cseqHeader = <span class="string">"CSeq: "</span>;</span><br><span class="line">    cseqHeader.append(cseq);</span><br><span class="line">    cseqHeader.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    request.insert(cseqHeader, i + <span class="number">2</span>);</span><br><span class="line">    ALOGV(<span class="string">"request: '%s'"</span>, request.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> numBytesSent = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (numBytesSent &lt; request.size()) &#123;</span><br><span class="line">        <span class="comment">//如果请求还没完全发送结束那么继续发送</span></span><br><span class="line">        <span class="keyword">ssize_t</span> n = send(mSocket, request.c_str() + numBytesSent,request.size() - numBytesSent, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="comment">//忽略错误处理代码</span></span><br><span class="line">        numBytesSent += (<span class="keyword">size_t</span>)n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将请求添加到mPendingRequests，等待服务器回复</span></span><br><span class="line">    mPendingRequests.add(cseq, reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到上面提到的notifyResponseListener结合onSendRequest以及findPendingRequest是否看出了整个事件处理的流程？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ARTSPConnection::findPendingRequest(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ARTSPResponse&gt; &amp;response, <span class="keyword">ssize_t</span> *index) <span class="keyword">const</span> &#123;</span><br><span class="line">    *index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> i = response-&gt;mHeaders.indexOfKey(<span class="string">"cseq"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This is an unsolicited server-&gt;client message.</span></span><br><span class="line">        *index = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    AString value = response-&gt;mHeaders.valueAt(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> cseq;</span><br><span class="line">    <span class="keyword">if</span> (!ParseSingleUnsignedLong(value.c_str(), &amp;cseq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line">    i = mPendingRequests.indexOfKey(cseq);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ENOENT;</span><br><span class="line">    &#125;</span><br><span class="line">    *index = i;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onSendRequest 会不断将请求放入mPendingRequests中，而每次服务器给出应答的时候会调用notifyResponseListener，notifyResponseListener会从mPendingRequests中取出一个应答消息，并发送消息给MyHandler进行处理，而notifyResponseListener又会阻塞等待下一个服务器的应答信号。</p><p>OK我们接下来看下收到‘desc’信号后的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">case 'desc':</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"result"</span>, &amp;result));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == OK) &#123;</span><br><span class="line">        sp&lt;RefBase&gt; obj;</span><br><span class="line">        CHECK(msg-&gt;findObject(<span class="string">"response"</span>, &amp;obj));</span><br><span class="line">        sp&lt;ARTSPResponse&gt; response = <span class="keyword">static_cast</span>&lt;ARTSPResponse *&gt;(obj.get());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (response-&gt;mStatusCode == <span class="number">301</span> || response-&gt;mStatusCode == <span class="number">302</span>) &#123;</span><br><span class="line">            <span class="comment">//重定向连接</span></span><br><span class="line">            <span class="comment">//............</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response-&gt;mStatusCode != <span class="number">200</span>) &#123;</span><br><span class="line">            result = UNKNOWN_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response-&gt;mContent == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            result = ERROR_MALFORMED;</span><br><span class="line">            ALOGE(<span class="string">"The response has no content."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获得ASessionDescription</span></span><br><span class="line">            mSessionDesc = <span class="keyword">new</span> ASessionDescription;</span><br><span class="line">            mSessionDesc-&gt;setTo(response-&gt;mContent-&gt;data(),response-&gt;mContent-&gt;size());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mSessionDesc-&gt;isValid()) &#123;</span><br><span class="line">                <span class="comment">//............</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//............</span></span><br><span class="line">                <span class="keyword">if</span> (mSessionDesc-&gt;countTracks() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">// There's no actual tracks in this session.</span></span><br><span class="line">                    <span class="comment">// The first "track" is merely session meta</span></span><br><span class="line">                    <span class="comment">// data.</span></span><br><span class="line">                    ALOGW(<span class="string">"Session doesn't contain any playable "</span></span><br><span class="line">                         <span class="string">"tracks. Aborting."</span>);</span><br><span class="line">                    result = ERROR_UNSUPPORTED;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//这里才是真正要处理的代码</span></span><br><span class="line">                    setupTrack(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码很长我们忽略不重要的，直接看setupTrack。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setupTrack</span><span class="params">(<span class="keyword">size_t</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sp&lt;APacketSource&gt; source = <span class="keyword">new</span> APacketSource(mSessionDesc, index);</span><br><span class="line">    AString url;</span><br><span class="line">    CHECK(mSessionDesc-&gt;findAttribute(index, <span class="string">"a=control"</span>, &amp;url));</span><br><span class="line">    AString trackURL;</span><br><span class="line">    <span class="comment">//获得多媒体文件的Uri</span></span><br><span class="line">    CHECK(MakeURL(mBaseURL.c_str(), url.c_str(), &amp;trackURL));</span><br><span class="line"></span><br><span class="line">    mTracks.push(TrackInfo());</span><br><span class="line">    TrackInfo *info = &amp;mTracks.editItemAt(mTracks.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//设置uri</span></span><br><span class="line">    info-&gt;mURL = trackURL;</span><br><span class="line">    <span class="comment">//设置APacketSource</span></span><br><span class="line">    info-&gt;mPacketSource = source;</span><br><span class="line">    info-&gt;mUsingInterleavedTCP = <span class="literal">false</span>;</span><br><span class="line">    info-&gt;mFirstSeqNumInSegment = <span class="number">0</span>;</span><br><span class="line">    info-&gt;mNewSegment = <span class="literal">true</span>;</span><br><span class="line">    info-&gt;mRTPSocket = <span class="number">-1</span>;</span><br><span class="line">    info-&gt;mRTCPSocket = <span class="number">-1</span>;</span><br><span class="line">    info-&gt;mRTPAnchor = <span class="number">0</span>;</span><br><span class="line">    info-&gt;mNTPAnchorUs = <span class="number">-1</span>;</span><br><span class="line">    info-&gt;mNormalPlayTimeRTP = <span class="number">0</span>;</span><br><span class="line">    info-&gt;mNormalPlayTimeUs = <span class="number">0l</span>l;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> PT;</span><br><span class="line">    AString formatDesc;</span><br><span class="line">    AString formatParams;</span><br><span class="line">    mSessionDesc-&gt;getFormatType(index, &amp;PT, &amp;formatDesc, &amp;formatParams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> timescale;</span><br><span class="line">    <span class="keyword">int32_t</span> numChannels;</span><br><span class="line">    ASessionDescription::ParseFormatDesc(formatDesc.c_str(), &amp;timescale, &amp;numChannels);</span><br><span class="line"></span><br><span class="line">    info-&gt;mTimeScale = timescale;</span><br><span class="line">    info-&gt;mEOSReceived = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"track #%zu URL=%s"</span>, mTracks.size(), trackURL.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立SETUP请求</span></span><br><span class="line">    AString request = <span class="string">"SETUP "</span>;</span><br><span class="line">    request.append(trackURL);</span><br><span class="line">    request.append(<span class="string">" RTSP/1.0\r\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mTryTCPInterleaving) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> interleaveIndex = <span class="number">2</span> * (mTracks.size() - <span class="number">1</span>);</span><br><span class="line">        info-&gt;mUsingInterleavedTCP = <span class="literal">true</span>;</span><br><span class="line">        info-&gt;mRTPSocket = interleaveIndex;</span><br><span class="line">        info-&gt;mRTCPSocket = interleaveIndex + <span class="number">1</span>;</span><br><span class="line">        request.append(<span class="string">"Transport: RTP/AVP/TCP;interleaved="</span>);</span><br><span class="line">        request.append(interleaveIndex);</span><br><span class="line">        request.append(<span class="string">"-"</span>);</span><br><span class="line">        request.append(interleaveIndex + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> rtpPort;</span><br><span class="line">        ARTPConnection::MakePortPair(</span><br><span class="line">                &amp;info-&gt;mRTPSocket, &amp;info-&gt;mRTCPSocket, &amp;rtpPort);</span><br><span class="line">        <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">            HTTPBase::RegisterSocketUserTag(info-&gt;mRTPSocket, mUID,</span><br><span class="line">                                            (<span class="keyword">uint32_t</span>)*(<span class="keyword">uint32_t</span>*) <span class="string">"RTP_"</span>);</span><br><span class="line">            HTTPBase::RegisterSocketUserTag(info-&gt;mRTCPSocket, mUID,</span><br><span class="line">                                            (<span class="keyword">uint32_t</span>)*(<span class="keyword">uint32_t</span>*) <span class="string">"RTP_"</span>);</span><br><span class="line">            HTTPBase::RegisterSocketUserMark(info-&gt;mRTPSocket, mUID);</span><br><span class="line">            HTTPBase::RegisterSocketUserMark(info-&gt;mRTCPSocket, mUID);</span><br><span class="line">        &#125;</span><br><span class="line">        request.append(<span class="string">"Transport: RTP/AVP/UDP;unicast;client_port="</span>);</span><br><span class="line">        request.append(rtpPort);</span><br><span class="line">        request.append(<span class="string">"-"</span>);</span><br><span class="line">        request.append(rtpPort + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        request.append(<span class="string">"Session: "</span>);</span><br><span class="line">        request.append(mSessionID);</span><br><span class="line">        request.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request.append(<span class="string">"\r\n"</span>);</span><br><span class="line">    sp&lt;AMessage&gt; reply = new AMessage('setu', this);</span><br><span class="line">    reply-&gt;setSize(<span class="string">"index"</span>, index);</span><br><span class="line">    reply-&gt;setSize(<span class="string">"track-index"</span>, mTracks.size() - <span class="number">1</span>);</span><br><span class="line">    mConn-&gt;sendRequest(request.c_str(), reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也很简单就是将要获取到的歌曲信息存放到mTracks，并使用sendRequest发起setu请求，sendRequest就不再作详细介绍了，我们直接看下‘setu’返回后的处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">case 'setu':</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"index"</span>, &amp;index));</span><br><span class="line">    TrackInfo *track = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> trackIndex;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findSize(<span class="string">"track-index"</span>, &amp;trackIndex)) &#123;</span><br><span class="line">        track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> result;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"result"</span>, &amp;result));</span><br><span class="line">    <span class="keyword">if</span> (result == OK) &#123;</span><br><span class="line">        CHECK(track != <span class="literal">NULL</span>);</span><br><span class="line">        sp&lt;RefBase&gt; obj;</span><br><span class="line">        CHECK(msg-&gt;findObject(<span class="string">"response"</span>, &amp;obj));</span><br><span class="line">        sp&lt;ARTSPResponse&gt; response =</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ARTSPResponse *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (response-&gt;mStatusCode != <span class="number">200</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">ssize_t</span> i = response-&gt;mHeaders.indexOfKey(<span class="string">"session"</span>);</span><br><span class="line">            CHECK_GE(i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//得到SessionID</span></span><br><span class="line">            mSessionID = response-&gt;mHeaders.valueAt(i);</span><br><span class="line">            mKeepAliveTimeoutUs = kDefaultKeepAliveTimeoutUs;</span><br><span class="line">            AString timeoutStr;</span><br><span class="line">            <span class="comment">//........................</span></span><br><span class="line">            sp&lt;AMessage&gt; notify = new AMessage('accu', this);</span><br><span class="line">            notify-&gt;setSize(<span class="string">"track-index"</span>, trackIndex);</span><br><span class="line">            i = response-&gt;mHeaders.indexOfKey(<span class="string">"transport"</span>);</span><br><span class="line">            CHECK_GE(i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (track-&gt;mRTPSocket != <span class="number">-1</span> &amp;&amp; track-&gt;mRTCPSocket != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!track-&gt;mUsingInterleavedTCP) &#123;</span><br><span class="line">                    AString transport = response-&gt;mHeaders.valueAt(i);</span><br><span class="line">                    <span class="comment">// We are going to continue even if we were</span></span><br><span class="line">                    <span class="comment">// unable to poke a hole into the firewall...</span></span><br><span class="line">                    pokeAHole(</span><br><span class="line">                            track-&gt;mRTPSocket,</span><br><span class="line">                            track-&gt;mRTCPSocket,</span><br><span class="line">                            transport);</span><br><span class="line">                &#125;</span><br><span class="line">                mRTPConn-&gt;addStream(</span><br><span class="line">                        track-&gt;mRTPSocket, track-&gt;mRTCPSocket,</span><br><span class="line">                        mSessionDesc, index,</span><br><span class="line">                        notify, track-&gt;mUsingInterleavedTCP);</span><br><span class="line">                mSetupTracksSuccessful = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = BAD_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面最重要的就是获取SessionID并调用mRTPConn-&gt;addStream完ARTPConnection中添加一个流，我们看下addStream：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ARTPConnection::addStream(</span><br><span class="line">        <span class="keyword">int</span> rtpSocket, <span class="keyword">int</span> rtcpSocket,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ASessionDescription&gt; &amp;sessionDesc,</span><br><span class="line">        <span class="keyword">size_t</span> index,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">bool</span> injected) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatAddStream, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"rtp-socket"</span>, rtpSocket);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"rtcp-socket"</span>, rtcpSocket);</span><br><span class="line">    msg-&gt;setObject(<span class="string">"session-desc"</span>, sessionDesc);</span><br><span class="line">    msg-&gt;setSize(<span class="string">"index"</span>, index);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"notify"</span>, notify);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"injected"</span>, injected);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> kWhatAddStream:</span><br><span class="line">&#123;</span><br><span class="line">    onAddStream(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ARTPConnection::onAddStream(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="comment">//将Stream信息添加到mStreams</span></span><br><span class="line">    mStreams.push_back(StreamInfo());</span><br><span class="line">    StreamInfo *info = &amp;*--mStreams.end();</span><br><span class="line">    <span class="keyword">int32_t</span> s;</span><br><span class="line">    <span class="comment">//获得rtp-socket</span></span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"rtp-socket"</span>, &amp;s));</span><br><span class="line">    info-&gt;mRTPSocket = s;</span><br><span class="line">    <span class="comment">//获得rtcp-socket</span></span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"rtcp-socket"</span>, &amp;s));</span><br><span class="line">    info-&gt;mRTCPSocket = s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> injected;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"injected"</span>, &amp;injected));</span><br><span class="line"></span><br><span class="line">    info-&gt;mIsInjected = injected;</span><br><span class="line">    <span class="comment">//获得session-desc</span></span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"session-desc"</span>, &amp;obj));</span><br><span class="line">    info-&gt;mSessionDesc = <span class="keyword">static_cast</span>&lt;ASessionDescription *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"index"</span>, &amp;info-&gt;mIndex));</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"notify"</span>, &amp;info-&gt;mNotifyMsg));</span><br><span class="line"></span><br><span class="line">    info-&gt;mNumRTCPPacketsReceived = <span class="number">0</span>;</span><br><span class="line">    info-&gt;mNumRTPPacketsReceived = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;info-&gt;mRemoteRTCPAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(info-&gt;mRemoteRTCPAddr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送轮询查询事件</span></span><br><span class="line">    <span class="keyword">if</span> (!injected) &#123;</span><br><span class="line">        postPollEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中重点关注的是postPollEvent：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> ARTPConnection::postPollEvent() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPollEventPending) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatPollStreams, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">    mPollEventPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> kWhatPollStreams:</span><br><span class="line">&#123;</span><br><span class="line">    onPollStreams();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ARTPConnection::onPollStreams() &#123;</span><br><span class="line">    mPollEventPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStreams.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    tv.tv_sec = <span class="number">0</span>;</span><br><span class="line">    tv.tv_usec = kSelectTimeoutUs;</span><br><span class="line"></span><br><span class="line">    fd_set rs;</span><br><span class="line">    FD_ZERO(&amp;rs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxSocket = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;StreamInfo&gt;::iterator it = mStreams.begin();</span><br><span class="line">         it != mStreams.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*it).mIsInjected) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FD_SET(it-&gt;mRTPSocket, &amp;rs);</span><br><span class="line">        FD_SET(it-&gt;mRTCPSocket, &amp;rs);</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;mRTPSocket &gt; maxSocket) &#123;</span><br><span class="line">            maxSocket = it-&gt;mRTPSocket;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;mRTCPSocket &gt; maxSocket) &#123;</span><br><span class="line">            maxSocket = it-&gt;mRTCPSocket;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (maxSocket == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选择一个网络请求</span></span><br><span class="line">    <span class="keyword">int</span> res = select(maxSocket + <span class="number">1</span>, &amp;rs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//在这里接收服务器发过来的数据</span></span><br><span class="line">        List&lt;StreamInfo&gt;::iterator it = mStreams.begin();</span><br><span class="line">        <span class="keyword">while</span> (it != mStreams.end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((*it).mIsInjected) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">status_t</span> err = OK;</span><br><span class="line">            <span class="comment">//接受从服务器发来的数据</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(it-&gt;mRTPSocket, &amp;rs)) &#123;</span><br><span class="line">                <span class="comment">//调用的是status_t ARTPConnection::receive(StreamInfo *s, bool receiveRTP)</span></span><br><span class="line">                err = receive(&amp;*it, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//接受从服务器发来的数据</span></span><br><span class="line">            <span class="keyword">if</span> (err == OK &amp;&amp; FD_ISSET(it-&gt;mRTCPSocket, &amp;rs)) &#123;</span><br><span class="line">                <span class="comment">//调用的是status_t ARTPConnection::receive(StreamInfo *s, bool receiveRTP)</span></span><br><span class="line">                err = receive(&amp;*it, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> nowUs = ALooper::GetNowUs();</span><br><span class="line">    <span class="keyword">if</span> (mLastReceiverReportTimeUs &lt;= <span class="number">0</span>|| mLastReceiverReportTimeUs + <span class="number">5000000l</span>l &lt;= nowUs) &#123;</span><br><span class="line">        <span class="comment">//新建一个缓存区</span></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(kMaxUDPSize);</span><br><span class="line">        List&lt;StreamInfo&gt;::iterator it = mStreams.begin();</span><br><span class="line">        <span class="keyword">while</span> (it != mStreams.end()) &#123;</span><br><span class="line">            StreamInfo *s = &amp;*it;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;mIsInjected) &#123;</span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s-&gt;mNumRTCPPacketsReceived == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// We have never received any RTCP packets on this stream,</span></span><br><span class="line">                <span class="comment">// we don't even know where to send a report.</span></span><br><span class="line">                ++it;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buffer-&gt;setRange(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s-&gt;mSources.size(); ++i) &#123;</span><br><span class="line">                sp&lt;ARTPSource&gt; source = s-&gt;mSources.valueAt(i);</span><br><span class="line">                <span class="comment">//填充buffer</span></span><br><span class="line">                source-&gt;addReceiverReport(buffer);</span><br><span class="line">                <span class="keyword">if</span> (mFlags &amp; kRegularlyRequestFIR) &#123;</span><br><span class="line">                    source-&gt;addFIR(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buffer-&gt;size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGV(<span class="string">"Sending RR..."</span>);</span><br><span class="line">                <span class="keyword">ssize_t</span> n;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">//通過RTCPSocket發送</span></span><br><span class="line">                    n = sendto(s-&gt;mRTCPSocket, buffer-&gt;data(), buffer-&gt;size(), <span class="number">0</span>,(<span class="keyword">const</span> struct sockaddr *)&amp;s-&gt;mRemoteRTCPAddr, <span class="keyword">sizeof</span>(s-&gt;mRemoteRTCPAddr));</span><br><span class="line">                &#125; <span class="keyword">while</span> (n &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line">                CHECK_EQ(n, (<span class="keyword">ssize_t</span>)buffer-&gt;size());</span><br><span class="line">                mLastReceiverReportTimeUs = nowUs;</span><br><span class="line">            &#125;</span><br><span class="line">            ++it;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStreams.empty()) &#123;</span><br><span class="line">        postPollEvent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再onPollStreams中会阻塞监听服务器发过来的媒体数据，并调用receive对其进行处理，并定期发送RTCP消息给服务器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ARTPConnection::receive(StreamInfo *s, <span class="keyword">bool</span> receiveRTP) &#123;</span><br><span class="line">    </span><br><span class="line">    ALOGV(<span class="string">"receiving %s"</span>, receiveRTP ? <span class="string">"RTP"</span> : <span class="string">"RTCP"</span>);</span><br><span class="line"></span><br><span class="line">    CHECK(!s-&gt;mIsInjected);</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer = <span class="keyword">new</span> ABuffer(<span class="number">65536</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> remoteAddrLen =</span><br><span class="line">        (!receiveRTP &amp;&amp; s-&gt;mNumRTCPPacketsReceived == <span class="number">0</span>)</span><br><span class="line">            ? <span class="keyword">sizeof</span>(s-&gt;mRemoteRTCPAddr) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> nbytes;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//从服务器接收数据</span></span><br><span class="line">        nbytes = recvfrom(</span><br><span class="line">            receiveRTP ? s-&gt;mRTPSocket : s-&gt;mRTCPSocket,</span><br><span class="line">            buffer-&gt;data(),</span><br><span class="line">            buffer-&gt;capacity(),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            remoteAddrLen &gt; <span class="number">0</span> ? (struct sockaddr *)&amp;s-&gt;mRemoteRTCPAddr : <span class="literal">NULL</span>,</span><br><span class="line">            remoteAddrLen &gt; <span class="number">0</span> ? &amp;remoteAddrLen : <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (nbytes &lt; <span class="number">0</span> &amp;&amp; errno == EINTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -ECONNRESET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setRange(<span class="number">0</span>, nbytes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGI("received %d bytes.", buffer-&gt;size());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="comment">//解析RTP 或者 parseRTCP</span></span><br><span class="line">    <span class="keyword">if</span> (receiveRTP) &#123;</span><br><span class="line">        err = parseRTP(s, buffer);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = parseRTCP(s, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>receive方法中会调用recvfrom。将数据从服务器中读取到缓存，并调用parseRTP或者parseRTCP对缓存中的数据进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ARTPConnection::parseRTP(StreamInfo *s, <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *data = buffer-&gt;data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((data[<span class="number">0</span>] &gt;&gt; <span class="number">6</span>) != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Unsupported version.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] &amp; <span class="number">0x20</span>) &#123;</span><br><span class="line">        <span class="comment">// Padding present.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> paddingLength = data[size - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paddingLength + <span class="number">12</span> &gt; size) &#123;</span><br><span class="line">            <span class="comment">// If we removed this much padding we'd end up with something</span></span><br><span class="line">            <span class="comment">// that's too short to be a valid RTP header.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size -= paddingLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numCSRCs = data[<span class="number">0</span>] &amp; <span class="number">0x0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> payloadOffset = <span class="number">12</span> + <span class="number">4</span> * numCSRCs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &lt; payloadOffset) &#123;</span><br><span class="line">        <span class="comment">// Not enough data to fit the basic header and all the CSRC entries.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] &amp; <span class="number">0x10</span>) &#123;</span><br><span class="line">        <span class="comment">// Header eXtension present.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; payloadOffset + <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// Not enough data to fit the basic header, all CSRC entries</span></span><br><span class="line">            <span class="comment">// and the first 4 bytes of the extension header.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *extensionData = &amp;data[payloadOffset];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> extensionLength =</span><br><span class="line">            <span class="number">4</span> * (extensionData[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> | extensionData[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (size &lt; payloadOffset + <span class="number">4</span> + extensionLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        payloadOffset += <span class="number">4</span> + extensionLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> srcId = u32at(&amp;data[<span class="number">8</span>]);</span><br><span class="line"></span><br><span class="line">    sp&lt;ARTPSource&gt; source = findSource(s, srcId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> rtpTime = u32at(&amp;data[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; meta = buffer-&gt;meta();</span><br><span class="line">    meta-&gt;setInt32(<span class="string">"ssrc"</span>, srcId);</span><br><span class="line">    meta-&gt;setInt32(<span class="string">"rtp-time"</span>, rtpTime);</span><br><span class="line">    meta-&gt;setInt32(<span class="string">"PT"</span>, data[<span class="number">1</span>] &amp; <span class="number">0x7f</span>);</span><br><span class="line">    meta-&gt;setInt32(<span class="string">"M"</span>, data[<span class="number">1</span>] &gt;&gt; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setInt32Data(u16at(&amp;data[<span class="number">2</span>]));</span><br><span class="line">    buffer-&gt;setRange(payloadOffset, size - payloadOffset);</span><br><span class="line">    <span class="comment">//这里十分重要void ARTPSource::processRTPPacket(const sp&lt;ABuffer&gt; &amp;buffer)</span></span><br><span class="line">    source-&gt;processRTPPacket(buffer);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在parsRTP中根据RTP格式对缓存区中的数据进行解析，最后调用ARTPSource::processRTPPacket进行后续处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTPSource.cpp]</span><br><span class="line"><span class="keyword">void</span> ARTPSource::processRTPPacket(<span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (queuePacket(buffer) &amp;&amp; mAssembler != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAssembler-&gt;onPacketReceived(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processRTPPacket中调用Assembler来将数据进行重组，这里最重要的方法是assembleMore</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\rtsp\ARTPAssembler.cpp]</span><br><span class="line"><span class="keyword">void</span> ARTPAssembler::onPacketReceived(<span class="keyword">const</span> sp&lt;ARTPSource&gt; &amp;source) &#123;</span><br><span class="line">    AssemblyStatus status;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//assembleMore</span></span><br><span class="line">        status = assembleMore(source);</span><br><span class="line">        <span class="keyword">if</span> (status == WRONG_SEQUENCE_NUMBER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFirstFailureTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ALooper::GetNowUs() - mFirstFailureTimeUs &gt; <span class="number">10000l</span>l) &#123;</span><br><span class="line">                    mFirstFailureTimeUs = <span class="number">-1</span>;</span><br><span class="line">                    <span class="comment">// LOG(VERBOSE) &lt;&lt; "waited too long for packet.";</span></span><br><span class="line">                    packetLost();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mFirstFailureTimeUs = ALooper::GetNowUs();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFirstFailureTimeUs = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (status == NOT_ENOUGH_DATA) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ARTPAssembler::AssemblyStatus AMPEG4AudioAssembler::assembleMore(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ARTPSource&gt; &amp;source) &#123;</span><br><span class="line">        <span class="comment">//调用addPacket</span></span><br><span class="line">    AssemblyStatus status = addPacket(source);</span><br><span class="line">    <span class="keyword">if</span> (status == MALFORMED_PACKET) &#123;</span><br><span class="line">        mAccessUnitDamaged = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实际上是对无序的数据包进行排序，并调用submitAccessUnit提交AU数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">ARTPAssembler::AssemblyStatus AMPEG4AudioAssembler::addPacket(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ARTPSource&gt; &amp;source) &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;sp&lt;ABuffer&gt; &gt; *<span class="built_in">queue</span> = source-&gt;<span class="built_in">queue</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mNextExpectedSeqNoValid) &#123;</span><br><span class="line">        List&lt;sp&lt;ABuffer&gt; &gt;::iterator it = <span class="built_in">queue</span>-&gt;begin();</span><br><span class="line">        <span class="keyword">while</span> (it != <span class="built_in">queue</span>-&gt;end()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)(*it)-&gt;int32Data() &gt;= mNextExpectedSeqNo) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            it = <span class="built_in">queue</span>-&gt;erase(it);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer = *<span class="built_in">queue</span>-&gt;begin();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mNextExpectedSeqNoValid) &#123;</span><br><span class="line">        mNextExpectedSeqNoValid = <span class="literal">true</span>;</span><br><span class="line">        mNextExpectedSeqNo = (<span class="keyword">uint32_t</span>)buffer-&gt;int32Data();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">uint32_t</span>)buffer-&gt;int32Data() != mNextExpectedSeqNo) &#123;</span><br><span class="line">#<span class="keyword">if</span> VERBOSE</span><br><span class="line">        LOG(VERBOSE) &lt;&lt; <span class="string">"Not the sequence number I expected"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> WRONG_SEQUENCE_NUMBER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> rtpTime;</span><br><span class="line">    CHECK(buffer-&gt;meta()-&gt;findInt32(<span class="string">"rtp-time"</span>, (<span class="keyword">int32_t</span> *)&amp;rtpTime));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交AccessUnit</span></span><br><span class="line">    <span class="keyword">if</span> (mPackets.size() &gt; <span class="number">0</span> &amp;&amp; rtpTime != mAccessUnitRTPTime) &#123;</span><br><span class="line">        submitAccessUnit();</span><br><span class="line">    &#125;</span><br><span class="line">    mAccessUnitRTPTime = rtpTime;</span><br><span class="line">    <span class="comment">//将缓存添加到mPackets</span></span><br><span class="line">    mPackets.push_back(buffer);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;erase(<span class="built_in">queue</span>-&gt;begin());</span><br><span class="line">    ++mNextExpectedSeqNo;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>submitAccessUnit中回调‘accu’，交给MyHandler处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AMPEG4AudioAssembler::submitAccessUnit() &#123;</span><br><span class="line">    CHECK(!mPackets.empty());</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VERBOSE</span></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; <span class="string">"Access unit complete ("</span> &lt;&lt; mPackets.size() &lt;&lt; <span class="string">" packets)"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit = MakeCompoundFromPackets(mPackets);</span><br><span class="line">    accessUnit = removeLATMFraming(accessUnit);</span><br><span class="line">    CopyTimes(accessUnit, *mPackets.begin());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAccessUnitDamaged) &#123;</span><br><span class="line">        accessUnit-&gt;meta()-&gt;setInt32(<span class="string">"damaged"</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPackets.clear();</span><br><span class="line">    mAccessUnitDamaged = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//回调‘accu’</span></span><br><span class="line">    sp&lt;AMessage&gt; msg = mNotifyMsg-&gt;dup();</span><br><span class="line">    msg-&gt;setBuffer(<span class="string">"access-unit"</span>, accessUnit);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case 'accu':</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> timeUpdate;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"time-update"</span>, &amp;timeUpdate) &amp;&amp; timeUpdate) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> trackIndex;</span><br><span class="line">        CHECK(msg-&gt;findSize(<span class="string">"track-index"</span>, &amp;trackIndex));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> rtpTime;</span><br><span class="line">        <span class="keyword">uint64_t</span> ntpTime;</span><br><span class="line">        CHECK(msg-&gt;findInt32(<span class="string">"rtp-time"</span>, (<span class="keyword">int32_t</span> *)&amp;rtpTime));</span><br><span class="line">        CHECK(msg-&gt;findInt64(<span class="string">"ntp-time"</span>, (<span class="keyword">int64_t</span> *)&amp;ntpTime));</span><br><span class="line"></span><br><span class="line">        onTimeUpdate(trackIndex, rtpTime, ntpTime);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> first;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"first-rtcp"</span>, &amp;first)) &#123;</span><br><span class="line">        mReceivedFirstRTCPPacket = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"first-rtp"</span>, &amp;first)) &#123;</span><br><span class="line">        mReceivedFirstRTPPacket = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ++mNumAccessUnitsReceived;</span><br><span class="line">    postAccessUnitTimeoutCheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> trackIndex;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"track-index"</span>, &amp;trackIndex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (trackIndex &gt;= mTracks.size()) &#123;</span><br><span class="line">        ALOGV(<span class="string">"late packets ignored."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrackInfo *track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> eos;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"eos"</span>, &amp;eos)) &#123;</span><br><span class="line">        ALOGI(<span class="string">"received BYE on track index %zu"</span>, trackIndex);</span><br><span class="line">        <span class="keyword">if</span> (!mAllTracksHaveTime &amp;&amp; dataReceivedOnAllChannels()) &#123;</span><br><span class="line">            ALOGI(<span class="string">"No time established =&gt; fake existing data"</span>);</span><br><span class="line"></span><br><span class="line">            track-&gt;mEOSReceived = <span class="literal">true</span>;</span><br><span class="line">            mTryFakeRTCP = <span class="literal">true</span>;</span><br><span class="line">            mReceivedFirstRTCPPacket = <span class="literal">true</span>;</span><br><span class="line">            fakeTimestamps();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            postQueueEOS(trackIndex, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    <span class="comment">//取出accessUnit</span></span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">"access-unit"</span>, &amp;accessUnit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> seqNum = (<span class="keyword">uint32_t</span>)accessUnit-&gt;int32Data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSeekPending) &#123;</span><br><span class="line">        ALOGV(<span class="string">"we're seeking, dropping stale packet."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (seqNum &lt; track-&gt;mFirstSeqNumInSegment) &#123;</span><br><span class="line">        ALOGV(<span class="string">"dropping stale access-unit (%d &lt; %d)"</span>,</span><br><span class="line">             seqNum, track-&gt;mFirstSeqNumInSegment);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;mNewSegment) &#123;</span><br><span class="line">        track-&gt;mNewSegment = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用onAccessUnitComplete</span></span><br><span class="line">    onAccessUnitComplete(trackIndex, accessUnit);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‘accu’取出AU数据后调用onAccessUnitComplete进行处理，我们接下来看下这部分逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onAccessUnitComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int32_t</span> trackIndex, <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;accessUnit)</span> </span>&#123;</span><br><span class="line">    ALOGV(<span class="string">"onAccessUnitComplete track %d"</span>, trackIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!mPlayResponseParsed)&#123;</span><br><span class="line">        ALOGI(<span class="string">"play response is not parsed, storing accessunit"</span>);</span><br><span class="line">        TrackInfo *track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line">        track-&gt;mPackets.push_back(accessUnit);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleFirstAccessUnit();</span><br><span class="line"></span><br><span class="line">    TrackInfo *track = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mAllTracksHaveTime) &#123;</span><br><span class="line">        ALOGV(<span class="string">"storing accessUnit, no time established yet"</span>);</span><br><span class="line">        track-&gt;mPackets.push_back(accessUnit);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!track-&gt;mPackets.empty()) &#123;</span><br><span class="line">        sp&lt;ABuffer&gt; accessUnit = *track-&gt;mPackets.begin();</span><br><span class="line">        track-&gt;mPackets.erase(track-&gt;mPackets.begin());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (addMediaTimestamp(trackIndex, track, accessUnit)) &#123;</span><br><span class="line">            <span class="comment">//postQueueAccessUnit</span></span><br><span class="line">            postQueueAccessUnit(trackIndex, accessUnit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (addMediaTimestamp(trackIndex, track, accessUnit)) &#123;</span><br><span class="line">        postQueueAccessUnit(trackIndex, accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (track-&gt;mEOSReceived) &#123;</span><br><span class="line">        postQueueEOS(trackIndex, ERROR_END_OF_STREAM);</span><br><span class="line">        track-&gt;mEOSReceived = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postQueueAccessUnit</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">size_t</span> trackIndex, <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;accessUnit)</span> </span>&#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = mNotify-&gt;dup();</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"what"</span>, kWhatAccessUnit);</span><br><span class="line">    msg-&gt;setSize(<span class="string">"trackIndex"</span>, trackIndex);</span><br><span class="line">    msg-&gt;setBuffer(<span class="string">"accessUnit"</span>, accessUnit);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在RTSPSource中调用AnotherPacketSource queueAccessUnit(accessUnit)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MyHandler::kWhatAccessUnit:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> trackIndex;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"trackIndex"</span>, &amp;trackIndex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTSParser == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        CHECK_LT(trackIndex, mTracks.size());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CHECK_EQ(trackIndex, <span class="number">0u</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; accessUnit;</span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">"accessUnit"</span>, &amp;accessUnit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> damaged;</span><br><span class="line">    <span class="keyword">if</span> (accessUnit-&gt;meta()-&gt;findInt32(<span class="string">"damaged"</span>, &amp;damaged)</span><br><span class="line">            &amp;&amp; damaged) &#123;</span><br><span class="line">        ALOGI(<span class="string">"dropping damaged access unit."</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTSParser != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> offset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">status_t</span> err = OK;</span><br><span class="line">        <span class="keyword">while</span> (offset + <span class="number">188</span> &lt;= accessUnit-&gt;size()) &#123;</span><br><span class="line">            err = mTSParser-&gt;feedTSPacket(</span><br><span class="line">                    accessUnit-&gt;data() + offset, <span class="number">188</span>);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            offset += <span class="number">188</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; accessUnit-&gt;size()) &#123;</span><br><span class="line">            err = ERROR_MALFORMED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            sp&lt;AnotherPacketSource&gt; source = getSource(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">            <span class="keyword">if</span> (source != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                source-&gt;signalEOS(err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            source = getSource(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">            <span class="keyword">if</span> (source != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                source-&gt;signalEOS(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrackInfo *info = &amp;mTracks.editItemAt(trackIndex);</span><br><span class="line"></span><br><span class="line">    sp&lt;AnotherPacketSource&gt; source = info-&gt;mSource;</span><br><span class="line">    <span class="keyword">if</span> (source != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> rtpTime;</span><br><span class="line">        CHECK(accessUnit-&gt;meta()-&gt;findInt32(<span class="string">"rtp-time"</span>, (<span class="keyword">int32_t</span> *)&amp;rtpTime));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!info-&gt;mNPTMappingValid) &#123;</span><br><span class="line">            <span class="comment">// This is a live stream, we didn't receive any normal</span></span><br><span class="line">            <span class="comment">// playtime mapping. We won't map to npt time.</span></span><br><span class="line">            source-&gt;queueAccessUnit(accessUnit);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> nptUs =</span><br><span class="line">            ((<span class="keyword">double</span>)rtpTime - (<span class="keyword">double</span>)info-&gt;mRTPTime)</span><br><span class="line">                / info-&gt;mTimeScale</span><br><span class="line">                * <span class="number">1000000l</span>l</span><br><span class="line">                + info-&gt;mNormalPlaytimeUs;</span><br><span class="line"></span><br><span class="line">        accessUnit-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, nptUs);</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        source-&gt;queueAccessUnit(accessUnit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queueAccessUnit(accessUnit);将AU数据存放到AnotherPacketSource 的mBuffers中供解码器解码播放：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> AnotherPacketSource::queueAccessUnit(<span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> damaged;</span><br><span class="line">    ......</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    mBuffers.push_back(buffer);</span><br><span class="line">    mCondition.signal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> discontinuity;</span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">"discontinuity"</span>, &amp;discontinuity))&#123;</span><br><span class="line">        ALOGV(<span class="string">"queueing a discontinuity with queueAccessUnit"</span>);</span><br><span class="line"></span><br><span class="line">        mLastQueuedTimeUs = <span class="number">0l</span>l;</span><br><span class="line">        mEOSResult = OK;</span><br><span class="line">        mLatestEnqueuedMeta = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        mDiscontinuitySegments.push_back(DiscontinuitySegment());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> lastQueuedTimeUs;</span><br><span class="line">    CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;lastQueuedTimeUs));</span><br><span class="line">    mLastQueuedTimeUs = lastQueuedTimeUs;</span><br><span class="line">    ALOGV(<span class="string">"queueAccessUnit timeUs=%"</span> PRIi64 <span class="string">" us (%.2f secs)"</span>,</span><br><span class="line">            mLastQueuedTimeUs, mLastQueuedTimeUs / <span class="number">1E6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHECK(!mDiscontinuitySegments.empty());</span></span><br><span class="line">    DiscontinuitySegment &amp;tailSeg = *(--mDiscontinuitySegments.end());</span><br><span class="line">    <span class="keyword">if</span> (lastQueuedTimeUs &gt; tailSeg.mMaxEnqueTimeUs) &#123;</span><br><span class="line">        tailSeg.mMaxEnqueTimeUs = lastQueuedTimeUs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tailSeg.mMaxDequeTimeUs == <span class="number">-1</span>) &#123;</span><br><span class="line">        tailSeg.mMaxDequeTimeUs = lastQueuedTimeUs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mLatestEnqueuedMeta == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLatestEnqueuedMeta = buffer-&gt;meta()-&gt;dup();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> latestTimeUs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> frameDeltaUs = <span class="number">0</span>;</span><br><span class="line">        CHECK(mLatestEnqueuedMeta-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;latestTimeUs));</span><br><span class="line">        <span class="keyword">if</span> (lastQueuedTimeUs &gt; latestTimeUs) &#123;</span><br><span class="line">            mLatestEnqueuedMeta = buffer-&gt;meta()-&gt;dup();</span><br><span class="line">            frameDeltaUs = lastQueuedTimeUs - latestTimeUs;</span><br><span class="line">            mLatestEnqueuedMeta-&gt;setInt64(<span class="string">"durationUs"</span>, frameDeltaUs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mLatestEnqueuedMeta-&gt;findInt64(<span class="string">"durationUs"</span>, &amp;frameDeltaUs)) &#123;</span><br><span class="line">            <span class="comment">// For B frames</span></span><br><span class="line">            frameDeltaUs = latestTimeUs - lastQueuedTimeUs;</span><br><span class="line">            mLatestEnqueuedMeta-&gt;setInt64(<span class="string">"durationUs"</span>, frameDeltaUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-4、获取数据进行编码（请参考前面HLS小节分析）"><a href="#3-4、获取数据进行编码（请参考前面HLS小节分析）" class="headerlink" title="3.4、获取数据进行编码（请参考前面HLS小节分析）"></a>3.4、获取数据进行编码（请参考前面HLS小节分析）</h5><h5 id="3-5、播放流程（请参考前面HLS小节分析）"><a href="#3-5、播放流程（请参考前面HLS小节分析）" class="headerlink" title="3.5、播放流程（请参考前面HLS小节分析）"></a>3.5、播放流程（请参考前面HLS小节分析）</h5><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://tbfungeek.github.io/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84HLS%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">Android 源码分析之基于NuPlayer的HLS流媒体协议</a><br><a href="https://tbfungeek.github.io/2016/08/02/Android-%E8%BF%9B%E9%98%B6%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%9F%BA%E4%BA%8ENuPlayer%E7%9A%84RTSP%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE/" target="_blank" rel="noopener">Android 源码分析之基于NuPlayer的RTSP流媒体协议</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析</title>
    <link href="http://zhoujinjian.cc/2018/09/12/Android%20Video%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20NuPlayer%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/09/12/Android Video System（5）：Android Multimedia - NuPlayer音视频同步实现分析/</id>
    <published>2018-09-11T16:00:00.000Z</published>
    <updated>2018-07-09T12:33:48.621Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">【特别感谢 -  Android MediaCodec ACodec】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><h4 id="（一）、音视频同步时如何实现的？"><a href="#（一）、音视频同步时如何实现的？" class="headerlink" title="（一）、音视频同步时如何实现的？"></a>（一）、音视频同步时如何实现的？</h4><p>从Renderer接口层来看，没有任何关于同步处理的接口，仅有有限的几个控制接口flush/pause/resume，以及queueBuffer/queueEOS接口。同步问题的核心就在于ALooper-AHandler机制。其实真正的同步都是在消息循环的响应函数里实现的。先看音频。</p><h5 id="1-1、Renderer中的音频同步机制"><a href="#1-1、Renderer中的音频同步机制" class="headerlink" title="1.1、Renderer中的音频同步机制"></a>1.1、Renderer中的音频同步机制</h5><p>起始位置从音频PCM数据进入开始，处理在Renderer::queueBuffer()中，最终发送了kWhatQueueBuffer消息。这个消息的实际处理函数是Renderer::onQueueBuffer()。实际代码在“音视频原始数据输入——queueBuffer”中有，这里仅针对音频流程解释下。 基本逻辑很简单，保存传入的buffer参数，并通知输出下AudioQueue。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onQueueBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">......</span><br><span class="line">    QueueEntry entry;</span><br><span class="line">    entry.mBuffer = buffer;</span><br><span class="line">    entry.mNotifyConsumed = notifyConsumed;</span><br><span class="line">    entry.mOffset = <span class="number">0</span>;</span><br><span class="line">    entry.mFinalResult = OK;</span><br><span class="line">    entry.mBufferOrdinal = ++mTotalBuffersQueued;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mAudioQueue.push_back(entry);</span><br><span class="line">        postDrainAudioQueue_l();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVideoQueue.push_back(entry);</span><br><span class="line">        postDrainVideoQueue();</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看postDrainAudioQueue_l的实现，内部实现逻辑基本上就是边界判断加上发送kWhatDrainAudioQueue消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::postDrainAudioQueue_l(<span class="keyword">int64_t</span> delayUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mAudioQueue.empty()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mDrainAudioQueuePending = <span class="literal">true</span>;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatDrainAudioQueue, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"drainGeneration"</span>, mAudioDrainGeneration);</span><br><span class="line">    msg-&gt;post(delayUs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那就继续查看下这个消息如何处理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">        <span class="keyword">case</span> kWhatDrainAudioQueue:</span><br><span class="line">        &#123;</span><br><span class="line">            mDrainAudioQueuePending = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (onDrainAudioQueue()) &#123;</span><br><span class="line">                <span class="keyword">uint32_t</span> numFramesPlayed;</span><br><span class="line">                <span class="keyword">uint32_t</span> numFramesPendingPlayout = mNumFramesWritten - numFramesPlayed;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里是audio sink中缓存了多长的可用于播放的数据</span></span><br><span class="line">                <span class="keyword">int64_t</span> delayUs = mAudioSink-&gt;msecsPerFrame() * numFramesPendingPlayout * <span class="number">1000l</span>l;</span><br><span class="line">                <span class="keyword">if</span> (mPlaybackRate &gt; <span class="number">1.0f</span>) &#123;</span><br><span class="line">                    delayUs /= mPlaybackRate;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 利用一半的延时来保证下次刷新时间（注意时间上有重叠）</span></span><br><span class="line">                delayUs /= <span class="number">2</span>;</span><br><span class="line">                <span class="comment">// 参考buffer大小来估计最大的延时时间</span></span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int64_t</span> maxDrainDelayUs = <span class="built_in">std</span>::max(</span><br><span class="line">                        mAudioSink-&gt;getBufferDurationInUs(), (<span class="keyword">int64_t</span>)<span class="number">500000</span> <span class="comment">/* half second */</span>);</span><br><span class="line">                ALOGD_IF(delayUs &gt; maxDrainDelayUs, <span class="string">"postDrainAudioQueue long delay: %lld &gt; %lld"</span>,</span><br><span class="line">                        (<span class="keyword">long</span> <span class="keyword">long</span>)delayUs, (<span class="keyword">long</span> <span class="keyword">long</span>)maxDrainDelayUs);</span><br><span class="line">                Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">                postDrainAudioQueue_l(delayUs); <span class="comment">// 这里同一个消息重发了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>到这里，貌似还是没有同步的机制，不过我们已经知道这个音频播放消息的触发机制了，在queueBuffer和消息处理函数中都会触发，基本上就是定时器。还有最后一个函数onDrainAudioQueue()。下面是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Renderer::onDrainAudioQueue() &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> numFramesPlayed;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink-&gt;getPosition(&amp;numFramesPlayed) != OK) &#123;      </span><br><span class="line">        drainAudioQueueUntilLastEOS();</span><br><span class="line">        ALOGW(<span class="string">"onDrainAudioQueue(): audio sink is not ready"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> prevFramesWritten = mNumFramesWritten;</span><br><span class="line">    <span class="keyword">while</span> (!mAudioQueue.empty()) &#123;</span><br><span class="line">        QueueEntry *entry = &amp;*mAudioQueue.begin();</span><br><span class="line"></span><br><span class="line">        mLastAudioBufferDrained = entry-&gt;mBufferOrdinal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;mBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除针对EOS的处理代码            </span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ignore 0-sized buffer which could be EOS marker with no data</span></span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;mOffset == <span class="number">0</span> &amp;&amp; entry-&gt;mBuffer-&gt;size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> mediaTimeUs;</span><br><span class="line">            CHECK(entry-&gt;mBuffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs));</span><br><span class="line">            ALOGV(<span class="string">"onDrainAudioQueue: rendering audio at media time %.2f secs"</span>,</span><br><span class="line">                    mediaTimeUs / <span class="number">1E6</span>);</span><br><span class="line">            onNewAudioMediaTime(mediaTimeUs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> copy = entry-&gt;mBuffer-&gt;size() - entry-&gt;mOffset;</span><br><span class="line">        <span class="keyword">ssize_t</span> written = mAudioSink-&gt;write(entry-&gt;mBuffer-&gt;data() + entry-&gt;mOffset,</span><br><span class="line">                                            copy, <span class="literal">false</span> <span class="comment">/* blocking */</span>);</span><br><span class="line">        <span class="keyword">if</span> (written &lt; <span class="number">0</span>) &#123;<span class="comment">/* ...忽略异常处理部分代码 */</span>&#125;</span><br><span class="line"></span><br><span class="line">        entry-&gt;mOffset += written;</span><br><span class="line">        <span class="keyword">size_t</span> remainder = entry-&gt;mBuffer-&gt;size() - entry-&gt;mOffset;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">ssize_t</span>)remainder &lt; mAudioSink-&gt;frameSize()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remainder &gt; <span class="number">0</span>) &#123;<span class="comment">// 这是直接凑成完整的一帧音频</span></span><br><span class="line">                ALOGW(<span class="string">"Corrupted audio buffer has fractional frames, discarding %zu bytes."</span>, remainder);</span><br><span class="line">                entry-&gt;mOffset += remainder;</span><br><span class="line">                copy -= remainder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entry-&gt;mNotifyConsumed-&gt;post();</span><br><span class="line">            mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">            entry = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> copiedFrames = written / mAudioSink-&gt;frameSize();</span><br><span class="line">        mNumFramesWritten += copiedFrames;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">            <span class="keyword">int64_t</span> maxTimeMedia;</span><br><span class="line">            maxTimeMedia = mAnchorTimeMediaUs +</span><br><span class="line">                        (<span class="keyword">int64_t</span>)(max((<span class="keyword">long</span> <span class="keyword">long</span>)mNumFramesWritten - mAnchorNumFramesWritten, <span class="number">0L</span>L)</span><br><span class="line">                                * <span class="number">1000L</span>L * mAudioSink-&gt;msecsPerFrame());</span><br><span class="line">            mMediaClock-&gt;updateMaxTimeMedia(maxTimeMedia);</span><br><span class="line"></span><br><span class="line">            notifyIfMediaRenderingStarted_l();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (written != (<span class="keyword">ssize_t</span>)copy) &#123;</span><br><span class="line">            <span class="comment">// A short count was received from AudioSink::write()</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// AudioSink write is called in non-blocking mode.</span></span><br><span class="line">            <span class="comment">// It may return with a short count when:</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// 1) Size to be copied is not a multiple of the frame size. Fractional frames are</span></span><br><span class="line">            <span class="comment">//    discarded.</span></span><br><span class="line">            <span class="comment">// 2) The data to be copied exceeds the available buffer in AudioSink.</span></span><br><span class="line">            <span class="comment">// 3) An error occurs and data has been partially copied to the buffer in AudioSink.</span></span><br><span class="line">            <span class="comment">// 4) AudioSink is an AudioCache for data retrieval, and the AudioCache is exceeded.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// (Case 1)</span></span><br><span class="line">            <span class="comment">// Must be a multiple of the frame size.  If it is not a multiple of a frame size, it</span></span><br><span class="line">            <span class="comment">// needs to fail, as we should not carry over fractional frames between calls.</span></span><br><span class="line">            CHECK_EQ(copy % mAudioSink-&gt;frameSize(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (Case 2, 3, 4)</span></span><br><span class="line">            <span class="comment">// Return early to the caller.</span></span><br><span class="line">            <span class="comment">// Beware of calling immediately again as this may busy-loop if you are not careful.</span></span><br><span class="line">            ALOGV(<span class="string">"AudioSink write short frame count %zd &lt; %zu"</span>, written, copy);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate whether we need to reschedule another write.</span></span><br><span class="line">    <span class="keyword">bool</span> reschedule = !mAudioQueue.empty()</span><br><span class="line">            &amp;&amp; (!mPaused</span><br><span class="line">                || prevFramesWritten != mNumFramesWritten); <span class="comment">// permit pause to fill buffers</span></span><br><span class="line">    <span class="comment">//ALOGD("reschedule:%d  empty:%d  mPaused:%d  prevFramesWritten:%u  mNumFramesWritten:%u",</span></span><br><span class="line">    <span class="comment">//        reschedule, mAudioQueue.empty(), mPaused, prevFramesWritten, mNumFramesWritten);</span></span><br><span class="line">    <span class="keyword">return</span> reschedule;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面比较主要的更新是onNewAudioMediaTime和mNumFramesWritten字段。<br>剩下的一部分代码是关于异常边界情况下的音视频处理逻辑：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer;</span><br><span class="line">    sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstAudioBuffer == <span class="literal">NULL</span> || firstVideoBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 对于一个队列为空的情况，通知另个一队列EOS</span></span><br><span class="line">        syncQueuesDone_l();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> firstVideoTimeUs;</span><br><span class="line">    CHECK(firstAudioBuffer-&gt;meta()</span><br><span class="line">            -&gt;findInt64(<span class="string">"timeUs"</span>, &amp;firstAudioTimeUs));</span><br><span class="line">    CHECK(firstVideoBuffer-&gt;meta()</span><br><span class="line">            -&gt;findInt64(<span class="string">"timeUs"</span>, &amp;firstVideoTimeUs));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> diff = firstVideoTimeUs - firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000l</span>l) &#123;</span><br><span class="line">        <span class="comment">// 音频数据时间戳比视频数据早0.1s，</span></span><br><span class="line"></span><br><span class="line">        (*mAudioQueue.begin()).mNotifyConsumed-&gt;post();</span><br><span class="line">        mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syncQueuesDone_l();</span><br></pre></td></tr></table></figure><h5 id="1-2、Renderer中的视频同步部分"><a href="#1-2、Renderer中的视频同步部分" class="headerlink" title="1.2、Renderer中的视频同步部分"></a>1.2、Renderer中的视频同步部分</h5><p>和音频同步类似，入口在在Renderer::queueBuffer()，主要区分在Renderer::onQueueBuffer()中，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是视频，则将数据存放到视频队列，然后安排刷新</span></span><br><span class="line">mVideoQueue.push_back(entry);</span><br><span class="line">postDrainVideoQueue();</span><br></pre></td></tr></table></figure><p>下面按照之前的思路继续分析，接下来是postDrainVideoQueue实现，主要音视频同步逻辑位于这里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::postDrainVideoQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueueEntry &amp;entry = *mVideoQueue.begin();</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatDrainVideoQueue, <span class="keyword">this</span>); <span class="comment">//这是实际处理视频缓冲区和显示的消息</span></span><br><span class="line">    msg-&gt;setInt32(<span class="string">"drainGeneration"</span>, getDrainGeneration(<span class="literal">false</span> <span class="comment">/* audio */</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (entry.mBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// EOS doesn't carry a timestamp.</span></span><br><span class="line">        msg-&gt;post();</span><br><span class="line">        mDrainVideoQueuePending = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> needRepostDrainVideoQueue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> delayUs;</span><br><span class="line">    <span class="keyword">int64_t</span> nowUs = ALooper::GetNowUs();</span><br><span class="line">    <span class="keyword">int64_t</span> realTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> mediaTimeUs;</span><br><span class="line">    CHECK(entry.mBuffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs));</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; FLAG_REAL_TIME) &#123;        </span><br><span class="line">        realTimeUs = mediaTimeUs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::Autolock autoLock(mLock);</span><br><span class="line">            <span class="keyword">if</span> (mAnchorTimeMediaUs &lt; <span class="number">0</span>) &#123; <span class="comment">// 同步基准未设置的情况下，直接显示</span></span><br><span class="line">                mMediaClock-&gt;updateAnchor(mediaTimeUs, nowUs, mediaTimeUs);</span><br><span class="line">                mAnchorTimeMediaUs = mediaTimeUs;</span><br><span class="line">                realTimeUs = nowUs;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mVideoSampleReceived) &#123; <span class="comment">// 第一帧未显示前，直接显示</span></span><br><span class="line">                <span class="comment">// Always render the first video frame.</span></span><br><span class="line">                realTimeUs = nowUs;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mAudioFirstAnchorTimeMediaUs &lt; <span class="number">0</span> <span class="comment">// 音频未播放之前，以视频为准</span></span><br><span class="line">                || mMediaClock-&gt;getRealTimeFor(mediaTimeUs, &amp;realTimeUs) == OK) &#123;</span><br><span class="line">                realTimeUs = getRealTimeUs(mediaTimeUs, nowUs);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mediaTimeUs - mAudioFirstAnchorTimeMediaUs &gt;= <span class="number">0</span>) &#123; <span class="comment">// 视频超前的情况下，等待</span></span><br><span class="line">                needRepostDrainVideoQueue = <span class="literal">true</span>; </span><br><span class="line">                realTimeUs = nowUs;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                realTimeUs = nowUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Heuristics to handle situation when media time changed without a</span></span><br><span class="line">        <span class="comment">// discontinuity. If we have not drained an audio buffer that was</span></span><br><span class="line">        <span class="comment">// received after this buffer, repost in 10 msec. Otherwise repost</span></span><br><span class="line">        <span class="comment">// in 500 msec.</span></span><br><span class="line">        delayUs = realTimeUs - nowUs;</span><br><span class="line">        <span class="keyword">int64_t</span> postDelayUs = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (delayUs &gt; <span class="number">500000</span>) &#123;</span><br><span class="line">            postDelayUs = <span class="number">500000</span>;</span><br><span class="line">            <span class="keyword">if</span> (mHasAudio &amp;&amp; (mLastAudioBufferDrained - entry.mBufferOrdinal) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                postDelayUs = <span class="number">10000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needRepostDrainVideoQueue) &#123;</span><br><span class="line">            <span class="comment">// CHECK(mPlaybackRate &gt; 0);</span></span><br><span class="line">            <span class="comment">// CHECK(mAudioFirstAnchorTimeMediaUs &gt;= 0);</span></span><br><span class="line">            <span class="comment">// CHECK(mediaTimeUs - mAudioFirstAnchorTimeMediaUs &gt;= 0);</span></span><br><span class="line">            postDelayUs = mediaTimeUs - mAudioFirstAnchorTimeMediaUs;</span><br><span class="line">            postDelayUs /= mPlaybackRate;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postDelayUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            msg-&gt;setWhat(kWhatPostDrainVideoQueue);</span><br><span class="line">            msg-&gt;post(postDelayUs);</span><br><span class="line">            mVideoScheduler-&gt;restart();</span><br><span class="line">            ALOGI(<span class="string">"possible video time jump of %dms or uninitialized media clock, retrying in %dms"</span>,</span><br><span class="line">                    (<span class="keyword">int</span>)(delayUs / <span class="number">1000</span>), (<span class="keyword">int</span>)(postDelayUs / <span class="number">1000</span>));</span><br><span class="line">            mDrainVideoQueuePending = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    realTimeUs = mVideoScheduler-&gt;schedule(realTimeUs * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> twoVsyncsUs = <span class="number">2</span> * (mVideoScheduler-&gt;getVsyncPeriod() / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    delayUs = realTimeUs - nowUs;</span><br><span class="line">    <span class="comment">// 上面代码的主要目的是计算这个延时</span></span><br><span class="line">    ALOGW_IF(delayUs &gt; <span class="number">500000</span>, <span class="string">"unusually high delayUs: %"</span> PRId64, delayUs);</span><br><span class="line">    <span class="comment">// post 2 display refreshes before rendering is due</span></span><br><span class="line">    msg-&gt;post(delayUs &gt; twoVsyncsUs ? delayUs - twoVsyncsUs : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    mDrainVideoQueuePending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要的是发送了一个延时消息kWhatDrainVideoQueue，下面是如何处理的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatDrainVideoQueue:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> generation;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"drainGeneration"</span>, &amp;generation));</span><br><span class="line">    <span class="keyword">if</span> (generation != getDrainGeneration(<span class="literal">false</span> <span class="comment">/* audio */</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDrainVideoQueuePending = <span class="literal">false</span>;</span><br><span class="line">    onDrainVideoQueue();</span><br><span class="line">    postDrainVideoQueue(); <span class="comment">// 注意这里相当于定时器的实现了</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用onDrainVideoQueue函数，看看如何实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onDrainVideoQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QueueEntry *entry = &amp;*mVideoQueue.begin();</span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;mBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// ...省略针对EOS 处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> nowUs = ALooper::GetNowUs();</span><br><span class="line">    <span class="keyword">int64_t</span> realTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> mediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mFlags &amp; FLAG_REAL_TIME) &#123;</span><br><span class="line">        CHECK(entry-&gt;mBuffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;realTimeUs));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CHECK(entry-&gt;mBuffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs));</span><br><span class="line">        realTimeUs = getRealTimeUs(mediaTimeUs, nowUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> tooLate = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mPaused) &#123;</span><br><span class="line">        setVideoLateByUs(nowUs - realTimeUs);</span><br><span class="line">        tooLate = (mVideoLateByUs &gt; <span class="number">40000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tooLate) &#123;</span><br><span class="line">            ALOGV(<span class="string">"video late by %lld us (%.2f secs)"</span>,</span><br><span class="line">                 (<span class="keyword">long</span> <span class="keyword">long</span>)mVideoLateByUs, mVideoLateByUs / <span class="number">1E6</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> mediaUs = <span class="number">0</span>;</span><br><span class="line">            mMediaClock-&gt;getMediaTime(realTimeUs, &amp;mediaUs);</span><br><span class="line">            ALOGV(<span class="string">"rendering video at media time %.2f secs"</span>,</span><br><span class="line">                    (mFlags &amp; FLAG_REAL_TIME ? realTimeUs :</span><br><span class="line">                    mediaUs) / <span class="number">1E6</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(mFlags &amp; FLAG_REAL_TIME)</span><br><span class="line">                    &amp;&amp; mLastAudioMediaTimeUs != <span class="number">-1</span></span><br><span class="line">                    &amp;&amp; mediaTimeUs &gt; mLastAudioMediaTimeUs) &#123;</span><br><span class="line">                <span class="comment">// If audio ends before video, video continues to drive media clock.</span></span><br><span class="line">                <span class="comment">// Also smooth out videos &gt;= 10fps.</span></span><br><span class="line">                mMediaClock-&gt;updateMaxTimeMedia(mediaTimeUs + <span class="number">100000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setVideoLateByUs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mVideoSampleReceived &amp;&amp; !mHasAudio) &#123;</span><br><span class="line">            <span class="comment">// This will ensure that the first frame after a flush won't be used as anchor</span></span><br><span class="line">            <span class="comment">// when renderer is in paused state, because resume can happen any time after seek.</span></span><br><span class="line">            Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">            clearAnchorTime_l();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always render the first video frame while keeping stats on A/V sync.</span></span><br><span class="line">    <span class="keyword">if</span> (!mVideoSampleReceived) &#123;</span><br><span class="line">        realTimeUs = nowUs;</span><br><span class="line">        tooLate = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    entry-&gt;mNotifyConsumed-&gt;setInt64(<span class="string">"timestampNs"</span>, realTimeUs * <span class="number">1000l</span>l); <span class="comment">// 上面所有计算的参数在这里使用了</span></span><br><span class="line">    entry-&gt;mNotifyConsumed-&gt;setInt32(<span class="string">"render"</span>, !tooLate);</span><br><span class="line">    entry-&gt;mNotifyConsumed-&gt;post(); <span class="comment">// 注意这里，实际是向解码器发送消息，用于显示</span></span><br><span class="line">    mVideoQueue.erase(mVideoQueue.begin());</span><br><span class="line">    entry = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    mVideoSampleReceived = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mPaused) &#123; <span class="comment">// 这里是通知NuPlayer层渲染开始</span></span><br><span class="line">        <span class="keyword">if</span> (!mVideoRenderingStarted) &#123;</span><br><span class="line">            mVideoRenderingStarted = <span class="literal">true</span>;</span><br><span class="line">            notifyVideoRenderingStart();</span><br><span class="line">        &#125;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        notifyIfMediaRenderingStarted_l();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，小结下，读完这部分代码发现，NuPlayer::Renderer使用的以视频为基准的同步机制，音频晚了直接丢包，视频需要显示。同步主要位于视频缓冲区处理部分onDrainVideoQueue和音频缓冲区处理部分onDrainVideoQueue中。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-05-02-avsync.jpg" alt="Alt text | center"></p><h4 id="（二）、音视频同步时序图"><a href="#（二）、音视频同步时序图" class="headerlink" title="（二）、音视频同步时序图"></a>（二）、音视频同步时序图</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-05-01-AudioVideoSync.png" alt="Alt text | center"></p><p>1：OMX component 集成在ACodec中，ACodec（A/V）解完数据后，通知Nulayer；<br>2：NuPlayer通知Render，Render需要A/V的时间同步（另，如果是JPEG的话就不需要这个同步，直接render即可）；<br>3：对于Audio，直接通过AudioSink播放；<br>4：对于Video，通过通知ACodec，让ACodec通过(NativeWindow/Render)发送到界面</p><p>Step1:<br>1.1 omx_message::FILL_BUFFER_DONE ===&gt;&gt;&gt;ACodec::onOMXFillBufferDone()<br>  OMX component send msg FILL_BUFFER_DONE<br>  ACodec call onOMXFillBufferDone to handle<br>1.2 ACodec::onOMXFillBufferDone()::ACodec::kWhatDrainThisBuffer setMessage ===&gt;&gt;&gt; NuPlayer::onMessageReceived()<br>Step2:<br>2.1 NuPlayer::renderBuffer()<br>2.2 NuPlayer::Renderer::queueBuffer() ===&gt;&gt;&gt; send msg kWhatQueueBuffer<br>2.3 NuPlayer::Renderer::onMessageReceived() ===&gt;&gt;&gt; onQueueBuffer()<br>2.4 postDrainAudioQueue() or postDrainVideoQueue() ===&gt;&gt;&gt; send msg kWhatDrainVideoQueue<br>2.5 onMessageReceived() ===&gt;&gt;&gt; onDrainVideoQueue(); postDrainVideoQueue();<br>onDrainVideoQueue():A/V的时间同步,如果慢0.4s,标记too_late<br>postDrainVideoQueue():A/V的时间同步,如果解码时间快，决定等待的时间，并把消息给render<br>Step3：<br>3.1 postDrainAudioQueue()===&gt;&gt;&gt;onDrainAudioQueue()===&gt;&gt;&gt;mAudioSink-&gt;write()<br>Step4:<br>4.1 Renderer::onDrainVideoQueue(): entry-&gt;mNotifyConsumed-&gt;setInt32(“render”, !tooLate);<br>4.2 Renderer::postDrainVideoQueue()===&gt;&gt;&gt; send msg kWhatDrainVideoQueue<br>4.2 ACodec::BaseState::onMessageReceived() ===&gt;&gt;&gt; onOutputBufferDrained(msg);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Log:</span><br><span class="line">...</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.675</span>   <span class="number">741</span>  <span class="number">5075</span> V NuPlayerRenderer: rendering video at media time <span class="number">0.36</span> secs</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.676</span>   <span class="number">725</span>  <span class="number">1139</span> V AudioFlinger: releaseWakeLock_l() AudioOut_25</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.676</span>   <span class="number">725</span>  <span class="number">1139</span> V AudioFlinger: thread <span class="number">0xef883380</span> type <span class="number">0</span> TID <span class="number">1139</span> going to sleep</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.679</span>   <span class="number">725</span>  <span class="number">1131</span> V AudioFlinger: releaseWakeLock_l() AudioOut_D</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.682</span>   <span class="number">741</span>  <span class="number">5075</span> V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time <span class="number">0.70</span> secs</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioTrack: frame adjustment:<span class="number">2400</span>  timestamp:BOOTTIME offset <span class="number">0</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioTrack: ExtendedTimestamp[<span class="number">0</span>]  position: <span class="number">0</span>  time: <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioTrack: ExtendedTimestamp[<span class="number">1</span>]  position: <span class="number">17280</span>  time: <span class="number">96476185950</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioTrack: ExtendedTimestamp[<span class="number">2</span>]  position: <span class="number">0</span>  time: <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioTrack: ExtendedTimestamp[<span class="number">3</span>]  position: <span class="number">0</span>  time: <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioTrack: ExtendedTimestamp[<span class="number">4</span>]  position: <span class="number">0</span>  time: <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.683</span>   <span class="number">741</span>  <span class="number">5075</span> V AudioSink: getPlayedOutDurationUs(<span class="number">370130</span>) nowUs(<span class="number">96536315</span>) frames(<span class="number">14880</span>) framesAt(<span class="number">96476185</span>)</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.684</span>   <span class="number">741</span>  <span class="number">5075</span> V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time <span class="number">0.73</span> secs</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.694</span>   <span class="number">725</span>  <span class="number">1131</span> V AudioFlinger: thread <span class="number">0xf0208880</span> type <span class="number">0</span> TID <span class="number">1131</span> going to sleep</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.701</span>   <span class="number">741</span>  <span class="number">5075</span> V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time <span class="number">0.75</span> secs</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.717</span>   <span class="number">741</span>  <span class="number">5075</span> V NuPlayerRenderer: rendering video at media time <span class="number">0.41</span> secs</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">32</span>:<span class="number">58.733</span>   <span class="number">741</span>  <span class="number">5075</span> V NuPlayerRenderer: onDrainAudioQueue: rendering audio at media time <span class="number">0.77</span> secs</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="（三）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（三）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（三）、参考资料(特别感谢各位前辈的分析和图示)："></a>（三）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://windrunnerlihuan.com/2016/12/15/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%BA%94-OpenMax%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">④NuPlayer播放框架之Renderer源码分析：音视频同步时如何实现的？</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（4）：Android Multimedia - OpenMax实现分析</title>
    <link href="http://zhoujinjian.cc/2018/09/06/Android%20Video%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Multimedia%20-%20OpenMax%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/09/06/Android Video System（4）：Android Multimedia - OpenMax实现分析/</id>
    <published>2018-09-05T16:00:00.000Z</published>
    <updated>2018-07-06T12:27:52.098Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://windrunnerlihuan.com/categories/Android%E6%8A%80%E6%9C%AF%E7%82%B9/page/2/" target="_blank" rel="noopener">【特别感谢 -  Copy Windrunnerlihuan（OpenMax分析）】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">【特别感谢 -  Android MediaCodec ACodec】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ \hardware\qcom\media\msm8996\libstagefrighthw</p><ul><li>QComOMXPlugin.cpp</li><li>QComOMXMetadata.h</li><li>QComOMXPlugin.h</li></ul><p>☯  \hardware\qcom\media\msm8996\mm-video-v4l2\vidc</p><p>☯ \hardware\qcom\media\msm8996\mm-core</p><hr><h4 id="（一）、OpenMax简介"><a href="#（一）、OpenMax简介" class="headerlink" title="（一）、OpenMax简介"></a>（一）、OpenMax简介</h4><p>  android中的 NuPlayer就是用OpenMax来做(codec)编解码的，本节就主要科普一下OpenMax和它在Android系统中扮演的角色。</p><h5 id="1-1、-OpenMax系统的结构"><a href="#1-1、-OpenMax系统的结构" class="headerlink" title="1.1、 OpenMax系统的结构"></a>1.1、 OpenMax系统的结构</h5><h6 id="1-1-1、OpenMax总体层次结构"><a href="#1-1-1、OpenMax总体层次结构" class="headerlink" title="1.1.1、OpenMax总体层次结构"></a>1.1.1、OpenMax总体层次结构</h6><p> OpenMax是一个多媒体应用程序的框架标准，由NVIDIA公司和Khronos在2006年推出。</p><p> OpenMax是无授权费的，跨平台的应用程序接口API，通过使媒体加速组件能够在开发、集成和编程环节中实现跨多操作系统和处理器硬件平台，提供全面的流媒体编解码器和应用程序便携化。</p><p>OpenMax的官方网站如下所示：<br>       <a href="http://www.khronos.org/openmax/" target="_blank" rel="noopener">http://www.khronos.org/openmax/</a><br>OpenMax实际上分成三个层次，自上而下分别是，OpenMax DL（开发层），OpenMax IL（集成层）和OpenMax AL（应用层）。三个层次的内容分别如下所示：</p><blockquote><p>第一层：OpenMax DL（Development Layer，开发层）<br>        OpenMax DL定义了一个API，它是音频、视频和图像功能的集合。供应商能够在一个新的处理器上实现并优化，然后编解码供应商使用它来编写更广泛的编解码器功能。它包括音频信号的处理功能，如FFT和filter，图像原始处理，如颜色空间转换、视频原始处理，以实现例如MPEG-4、H.264、MP3、AAC和JPEG等编解码器的优化。</p><p>第二层：OpenMax IL（Integration Layer，集成层）<br>       OpenMax IL作为音频、视频和图像编解码器能与多媒体编解码器交互，并以统一的行为支持组件（例如，资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是透明的底层接口应用于嵌入式、移动设备。它提供了应用程序和媒体框架，透明的。编解码器供应商必须写私有的或者封闭的接口，集成进移动设备。IL的主要目的是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。</p><p>第三层：OpenMax AL（Appliction Layer，应用层）<br>       OpenMax AL API在应用程序和多媒体中间件之间提供了一个标准化接口，多媒体中间件提供服务以实现被期待的API功能。</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-01-openmaxsystem.png" alt="Alt text | center"></p><p>OpenMax API将会与处理器一同提供，以<strong>使库和编解码器开发者能够高速有效地利用新器件的完整加速潜能，无须担心其底层的硬件结构。</strong>该标准是针对嵌入式设备和移动设备的多媒体软件架构。在架构底层上为多媒体的编解码和数据处理定义了一套统一的编程接口，对多媒体数据的处理功能进行系统级抽象，为用户屏蔽了底层的细节。因此，<strong>多媒体应用程序和多媒体框架通过OpenMax IL可以以一种统一的方式来使用编解码和其他多媒体数据处理功能，具有了跨越软硬件平台的移植性。</strong></p><p>注：在实际的应用中，OpenMax的三个层次中使用较多的是OpenMax IL集成层，由于操作系统到硬件的差异和多媒体应用的差异，OpenMax的DL和AL层使用相对较少。</p><h6 id="1-1-2、OpenMax-IL简介"><a href="#1-1-2、OpenMax-IL简介" class="headerlink" title="1.1.2、OpenMax IL简介"></a>1.1.2、OpenMax IL简介</h6><p>OpenMax IL 处在中间层的位置，OpenMAX IL 作为音频，视频和图像编解码器 能与多媒体编解码器交互，并以统一的行为支持组件（例如资源和皮肤）。这些编解码器或许是软硬件的混合体，对用户是 的底层接口应用于嵌入式或 / 和移动设备。它提供了应用程序和媒体框架， 透明的。本质上不存在这种标准化的接口，编解码器供 应商必须写私有的或者封闭的接口，集成进移动设备。 IL 的主要目的 是使用特征集合为编解码器提供一个系统抽象，为解决多个不同媒体系统之间轻便性的问题。<br>       OpenMax IL 的目的就是为硬件平台的图形及音视频提供一个抽象层，可以为上层的应用提供一个可跨平台的支撑。这一点对于跨平台的媒体应用来说十分重要。本人也接触过几家高清解码芯片，这些芯片底层的音视频接口虽然功能上大致相同，但是接口设计及用法上各有不同，而且相差很多。你要想让自己开发的媒体应用完美的运行在不同的硬件厂商平台上，就得适应不同芯片的底层解码接口。这个对于应用开发来说十分繁琐。所以就需要类似于OpenMax IL 这种接口规范。应用假如涉及到音视频相关功能时，只需调用这些标准的接口，而不需要关心接口下方硬件相关的实现。假如换了硬件平台时，只需要把接口层与硬件适配好了就行了。上层应用不需要频繁改动。<br>       你可以把OpenMax IL 看作是中间件中的porting层接口，但是现在中间件大部分都是自家定义自己的。</p><p>OpenMax 想做的就是定义一个这样的行业标准，这样媒体应用、硬件厂商都遵循这种标准。硬件厂商将OpenMax 与处理器一并提供，上层的多媒体框架想要用到硬件音视频加速功能时，只需遵循openmax的接口就可以扩平台运行。<br>       可喜的，现在越来越多的多媒体框架及多媒体应用正在遵循openmax标准，包括各种知名的媒体开源软件。越来越多的芯片厂商也在遵循openmax的标准。对于现在的音视频编解码来说，分辨率越来越高，需要芯片提供硬件加速功能是个大的趋势。我相信 接口的标准化是一定要走的。如下图所示， openmax IL在多媒体框架中的应用：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-02-openmaxuse.png" alt="Alt text | center"></p><p><strong>OpenMax IL目前已经成为了事实上的多媒体框架标准。</strong>嵌入式处理器或者多媒体编解码模块的硬件生产者，通常提供标准的OpenMax IL层的软件接口，这样软件的开发者就可以基于这个层次的标准化接口进行多媒体程序的开发。</p><p> OpenMax IL的接口层次结构适中，既不是硬件编解码的接口，也不是应用程序层的接口，因此比较容易实现标准化。OpenMax IL的层次结构如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-03-openmaxIL.png" alt="Alt text | center"></p><p>图中的虚线中的内容是OpenMax IL层的内容，其主要实现了OpenMax IL中的各个组件（Component）。<strong>对下层，OpenMax IL可以调用OpenMax DL层的接口，也可以直接调用各种Codec实现。对上层，OpenMax IL可以给OpenMax AL 层等框架层（Middleware）调用，也可以给应用程序直接调用。</strong></p><h6 id="1-1-3、OpenMax-IL结构"><a href="#1-1-3、OpenMax-IL结构" class="headerlink" title="1.1.3、OpenMax IL结构"></a>1.1.3、OpenMax IL结构</h6><p>OpenMax IL主要内容如下所示。</p><p>☯ 客户端（Client）：OpenMax IL的调用者<br>☯ 组件（Component）：OpenMax IL的单元，每一个组件实现一种功能<br>☯ 端口（Port）：组件的输入输出接口<br>☯ 隧道化（Tunneled）：让两个组件直接连接的方式<br>       OpenMax IL的基本运作过程如图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-04-openmaxilbase.png" alt="Alt text | center"></p><p>OpenMAL IL的客户端，通过调用四个OpenMAL IL组件，实现了一个功能。四个组件分别是Source组件、Host组件、Accelerator组件和Sink组件。Source组件只有一个输出端口；而Host组件有一个输入端口和一个输出端口；Accelerator组件具有一个输入端口，调用了硬件的编解码器，加速主要体现在这个环节上。Accelerator组件和Sink组件通过私有通讯方式在内部进行连接，没有经过明确的组件端口。<br>       OpenMAL IL在使用的时候，其数据流也有不同的处理方式：既可以经由客户端，也可以不经由客户端。图中Source组件到Host组件的数据流就是经过客户端的；而Host组件到Accelerator组件的数据流就没有经过客户端，使用了隧道化的方式；Accelerator组件和Sink组件甚至可以使用私有的通讯方式。</p><p>   OpenMax Core是辅助各个组件运行的部分，它通常需要完成各个组件的初始化等工作，在真正运行过程中，重点是各个OpenMax IL的组件，OpenMax Core不是重点，也不是标准。</p><p> OpenMAL IL的组件是OpenMax IL实现的核心内容，一个组件以输入、输出端口为接口，端口可以被连接到另一个组件上。外部对组件可以发送命令，还进行设置/获取参数、配置等内容。组件的端口可以包含缓冲区（Buffer）的队列。</p><p>组件的处理的核心内容是：通过输入端口消耗Buffer，通过输出端口填充Buffer，由此多组件相联接可以构成流式的处理。OpenMAL IL中一个组件的结构如下图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-05-openilinternal.jpg" alt="Alt text | center"></p><pre><code>组件的功能和其定义的端口类型密切相关，通常情况下：只有一个输出端口的，为Source组件；只有一个输入端口的，为Sink组件；有多个输入端口，一个输出端口的为Mux组件；有一个输入端口，多个输出端口的为DeMux组件；输入输出端口各一个组件的为中间处理环节，这是最常见的组件。</code></pre><p>  端口具体支持的数据也有不同的类型。例如，对于一个输入、输出端口各一个组件，其输入端口使用MP3格式的数据，输出端口使用PCM格式的数据，那么这个组件就是一个MP3解码组件。</p><p>  隧道化（Tunneled）是一个关于组件连接方式的概念。通过隧道化可以将不同的组件的一个输入端口和一个输出端口连接到一起，在这种情况下，两个组件的处理过程合并，共同处理。尤其对于单输入和单输出的组件，两个组件将作为类似一个使用。</p><h5 id="1-2、Android中的OpenMax"><a href="#1-2、Android中的OpenMax" class="headerlink" title="1.2、Android中的OpenMax"></a>1.2、Android中的OpenMax</h5><h6 id="1-2-1、OpenMax在Android中的使用情况"><a href="#1-2-1、OpenMax在Android中的使用情况" class="headerlink" title="1.2.1、OpenMax在Android中的使用情况"></a>1.2.1、OpenMax在Android中的使用情况</h6><p>  在Android中，OpenMax IL层，<strong>通常可以用于多媒体引擎的插件</strong>，Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为插件，主要用于<strong>编解码（Codec）</strong>处理。<br>  在Android的框架层，也定义了由Android封装的OpenMax接口，和标准的接口概念基本相同，但是使用C++类型的接口，并且使用了Android的Binder IPC机制。Android封装OpenMax的接口被StageFright使用，OpenCore没有使用这个接口，而是使用其他形式对OpenMax IL层接口进行封装。Android OpenMax的基本层次结构如图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-06-openmaxinandroid.jpg" alt="Alt text | center"></p><p>Android系统的一些部分对OpenMax IL层进行使用，基本使用的是标准OpenMax IL层的接口，只是进行了简单的封装。标准的OpenMax IL实现很容易以插件的形式加入到Android系统中。</p><p>Android的多媒体引擎OpenCore和StageFright都可以使用OpenMax作为多媒体编解码的插件，只是没有直接使用OpenMax IL层提供的纯C接口，而是对其进行了一定的封装(C++封装)。</p><p>在Android2.x版本之后，Android的框架层也对OpenMax IL层的接口进行了封装定义，甚至使用Android中的Binder IPC机制。Stagefright使用了这个层次的接口，OpenCore没有使用。</p><p>注：OpenCore使用OpenMax IL层作为编解码插件在前，Android框架层封装OpenMax接口在后面的版本中才引入。</p><h6 id="1-2-2、Android-OpenMax实现的内容"><a href="#1-2-2、Android-OpenMax实现的内容" class="headerlink" title="1.2.2、Android OpenMax实现的内容"></a>1.2.2、Android OpenMax实现的内容</h6><p>   android中的 AwesomePlayer就是用openmax来做(Codec)编解码,其实在openmax接口设计中，他不光能用来当编解码。通过他的组件可以组成一个完整的播放器，包括sourc、demux、decode、output。但是为什么android只用他来做code呢？应该有如下方面：</p><p>☯    1.在整个播放器中，解码器不得不说是最重要的一部分，而且也是最耗资源的一块。如果全靠软解，直接通过cpu来运算，特别是高清视频。别的事你就可以啥都不干了。所以解码器是最需要硬件提供加速的部分。现在的高清解码芯片都是主芯片+DSP结构，解码的工作都是通过DSP来做，不会在过多的占用主芯片。所有将芯片中DSP硬件编解码的能力通过openmax标准接口呈现出来，提供上层播放器来用。我认为这块是openmax最重要的意义。<br>☯    2.source 主要是和协议打交道，demux 分解容器部分，大多数的容器格式的分解是不需要通过硬件来支持。只是ts流这种格式最可能用到硬件的支持。因为ts格式比较特殊，单包的大小太小了，只有188字节。所以也是为什么现在常见的解码芯片都会提供硬件ts demux 的支持。<br>☯   3.音视频输出部分video\audio output 这块和操作系统关系十分紧密。可以看看著名开源播放器vlc。vlc 在mac、linux、Windows都有，功能上差别也不大。所以说他是跨平台的，他跨平台跨在哪？主要的工作量还是在音视频解码完之后的输出模块。因为各个系统的图像渲染和音频输出实现方法不同，所以vlc需要针对每个平台实现不同的output。这部分内容放在openmax来显然不合适。<br>       Android中使用的主要是OpenMax的编解码功能。虽然OpenMax也可以生成输入、输出、文件解析-构建等组件，但是在各个系统（不仅是Android）中使用的最多的还是编解码组件。媒体的输入、输出环节和系统的关系很大，引入OpenMax标准比较麻烦；文件解析-构建环节一般不需要使用硬件加速。编解码组件也是最能体现硬件加速的环节，因此最常使用。</p><h5 id="1-3、初窥适配层接口"><a href="#1-3、初窥适配层接口" class="headerlink" title="1.3、初窥适配层接口"></a>1.3、初窥适配层接口</h5><p>在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节：</p><p>☯    编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。<br>☯   OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。<br> <strong>Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配）</strong>，它作为Android本地层的接口，可以被Android的多媒体引擎调用。上一篇文章末尾，初始化解码器核心调用的两个方法就是适配层的接口。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-07-openmaxsult.jpg" alt="Alt text | center"></p><p>☯    1.上面已经说过了，android系统中只用openmax来做Codec，所以android向上抽象了一层OMXCodec，提供给上层播放器用。播放器中音视频解码器mVideosource、mAudiosource都是OMXCodec的实例。<br>☯    2.OMXCodec通过IOMX 依赖binder机制 获得 OMX服务，OMX服务 才是openmax 在android中 实现。<br>☯    3.OMX把软编解码和硬件编解码统一看作插件的形式管理起来。</p><h4 id="（二）、Android中OpenMax的实现-preview"><a href="#（二）、Android中OpenMax的实现-preview" class="headerlink" title="（二）、Android中OpenMax的实现(preview)"></a>（二）、Android中OpenMax的实现(preview)</h4><h5 id="2-1、OpenMax的接口与实现"><a href="#2-1、OpenMax的接口与实现" class="headerlink" title="2.1、OpenMax的接口与实现"></a>2.1、OpenMax的接口与实现</h5><p>在Android中实现OpenMax IL层和标准的OpenMax IL层的方式基本，一般需要实现以下两个环节。</p><p>编解码驱动程序：位于Linux内核空间，需要通过Linux内核调用驱动程序，通常使用非标准的驱动程序。<br>OpenMax IL层：根据OpenMax IL层的标准头文件实现不同功能的组件。<br>       Android中还提供了OpenMax的适配层接口（对OpenMax IL的标准组件进行封装适配），它作为Android本地层的接口，可以被Android的多媒体引擎调用。</p><p>OpenMax IL层接口<br>       OpenMax IL层的接口定义由若干个头文件组成，这也是实现它需要实现的内容，位于frameworks/native/include/media/openmax下，它们的基本描述如下所示：</p><blockquote><p>OMX_Types.h：OpenMax Il的数据类型定义<br>OMX_Core.h：OpenMax IL核心的API<br>OMX_Component.h：OpenMax IL 组件相关的 API<br>OMX_Audio.h：音频相关的常量和数据结构<br>OMX_IVCommon.h：图像和视频公共的常量和数据结构<br>OMX_Image.h：图像相关的常量和数据结构<br>OMX_Video.h：视频相关的常量和数据结构<br>OMX_Other.h：其他数据结构（包括A/V 同步）<br>OMX_Index.h：OpenMax IL定义的数据结构索引<br>OMX_ContentPipe.h：内容的管道定义</p></blockquote><p>   <strong>提示：OpenMax标准只有头文件，没有标准的库，设置没有定义函数接口。对于实现者，需要实现的主要是包含函数指针的结构体。</strong></p><p>其中，OMX_Component.h中定义的OMX_COMPONENTTYPE结构体是OpenMax IL层的核心内容，表示一个组件，其内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks/native/include/media/openmax/OMX_Component.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OMX_COMPONENTTYPE</span>    </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    OMX_U32 nSize;                          <span class="comment">/* 这个结构体的大小 */</span>    </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本号 */</span>    </span><br><span class="line">    OMX_PTR pComponentPrivate;          <span class="comment">/* 这个组件的私有数据指针. */</span>    </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* 调用者（IL client）设置的指针，用于保存它的私有数据，传回给所有的回调函数 */</span>    </span><br><span class="line">    OMX_PTR pApplicationPrivate;    </span><br><span class="line">    <span class="comment">/* 以下的函数指针返回OMX_core.h中的对应内容 */</span>    </span><br><span class="line">    OMX_ERRORTYPE (*GetComponentVersion)(<span class="comment">/* 获得组件的版本*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STRING pComponentName,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pComponentVersion,    </span><br><span class="line">        OMX_OUT OMX_VERSIONTYPE* pSpecVersion,    </span><br><span class="line">        OMX_OUT OMX_UUIDTYPE* pComponentUUID);    </span><br><span class="line">    OMX_ERRORTYPE (*SendCommand)(<span class="comment">/* 发送命令 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_COMMANDTYPE Cmd,    </span><br><span class="line">        OMX_IN  OMX_U32 nParam1,    </span><br><span class="line">        OMX_IN  OMX_PTR pCmdData);    </span><br><span class="line">    OMX_ERRORTYPE (*GetParameter)(<span class="comment">/* 获得参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nParamIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetParameter)(<span class="comment">/* 设置参数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentParameterStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetConfig)(<span class="comment">/* 获得配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_INOUT OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*SetConfig)(<span class="comment">/* 设置配置 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_INDEXTYPE nIndex,    </span><br><span class="line">        OMX_IN  OMX_PTR pComponentConfigStructure);    </span><br><span class="line">    OMX_ERRORTYPE (*GetExtensionIndex)(<span class="comment">/* 转换成OMX结构的索引 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_STRING cParameterName,    </span><br><span class="line">        OMX_OUT OMX_INDEXTYPE* pIndexType);    </span><br><span class="line">    OMX_ERRORTYPE (*GetState)(<span class="comment">/* 获得组件当前的状态 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_STATETYPE* pState);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentTunnelRequest)(<span class="comment">/* 用于连接到另一个组件*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nPort,    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hTunneledComp,    </span><br><span class="line">        OMX_IN  OMX_U32 nTunneledPort,    </span><br><span class="line">        OMX_INOUT  OMX_TUNNELSETUPTYPE* pTunnelSetup);    </span><br><span class="line">    OMX_ERRORTYPE (*UseBuffer)(<span class="comment">/* 为某个端口使用Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes,    </span><br><span class="line">        OMX_IN OMX_U8* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*AllocateBuffer)(<span class="comment">/* 在某个端口分配Buffer */</span>    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBuffer,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN OMX_U32 nSizeBytes);    </span><br><span class="line">    OMX_ERRORTYPE (*FreeBuffer)(<span class="comment">/*将某个端口Buffer释放*/</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*EmptyThisBuffer)(<span class="comment">/* 让组件消耗这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*FillThisBuffer)(<span class="comment">/* 让组件填充这个Buffer */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_BUFFERHEADERTYPE* pBuffer);    </span><br><span class="line">    OMX_ERRORTYPE (*SetCallbacks)(<span class="comment">/* 设置回调函数 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_IN  OMX_CALLBACKTYPE* pCallbacks,    </span><br><span class="line">        OMX_IN  OMX_PTR pAppData);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentDeInit)(<span class="comment">/* 反初始化组件 */</span>    </span><br><span class="line">        OMX_IN  OMX_HANDLETYPE hComponent);    </span><br><span class="line">    OMX_ERRORTYPE (*UseEGLImage)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_INOUT OMX_BUFFERHEADERTYPE** ppBufferHdr,    </span><br><span class="line">        OMX_IN OMX_U32 nPortIndex,    </span><br><span class="line">        OMX_IN OMX_PTR pAppPrivate,    </span><br><span class="line">        OMX_IN <span class="keyword">void</span>* eglImage);    </span><br><span class="line">    OMX_ERRORTYPE (*ComponentRoleEnum)(    </span><br><span class="line">        OMX_IN OMX_HANDLETYPE hComponent,    </span><br><span class="line">        OMX_OUT OMX_U8 *cRole,    </span><br><span class="line">        OMX_IN OMX_U32 nIndex);    </span><br><span class="line">&#125; OMX_COMPONENTTYPE;</span><br></pre></td></tr></table></figure><p>☯    1）EmptyThisBuffer和FillThisBuffer是驱动组件运行的基本的机制，前者表示让组件消耗缓冲区，表示对应组件输入的内容；后者表示让组件填充缓冲区，表示对应组件输出的内容。<br>☯    2）UseBuffer，AllocateBuffer，FreeBuffer为和端口相关的缓冲区管理函数，对于组件的端口有些可以自己分配缓冲区，有些可以使用外部的缓冲区，因此有不同的接口对其进行操作。<br>☯    3）SendCommand表示向组件发送控制类的命令。GetParameter，SetParameter，GetConfig，SetConfig几个接口用于辅助的参数和配置的设置和获取。<br>☯     4）ComponentTunnelRequest用于组件之间的隧道化连接，其中需要制定两个组件及其相连的端口。<br>☯     5）ComponentDeInit用于组件的反初始化。</p><p>OMX_COMPONENTTYPE结构体实现后，其中的各个函数指针就是调用者可以使用的内容。各个函数指针和OMX_core.h中定义的内容相对应。</p><p>提示：OpenMax函数的参数中，经常包含OMX_IN和OMX_OUT等宏，它们的实际内容为空，只是为了标记参数的方向是输入还是输出。</p><p>OMX_Component.h中端口类型的定义为OMX_PORTDOMAINTYPE枚举类型，内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_PORTDOMAINTYPE &#123;   </span><br><span class="line">    OMX_PortDomainAudio,        <span class="comment">/* 音频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainVideo,        <span class="comment">/* 视频类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainImage,        <span class="comment">/* 图像类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainOther,        <span class="comment">/* 其他类型端口 */</span>   </span><br><span class="line">    OMX_PortDomainKhronosExtensions = <span class="number">0x6F000000</span>,   <span class="comment">//为Khronos标准预留宽展</span></span><br><span class="line">    OMX_PortDomainVendorStartUnused = <span class="number">0x7F000000</span>    <span class="comment">//为厂商预留扩展</span></span><br><span class="line">    OMX_PortDomainMax = <span class="number">0x7ffffff</span>  </span><br><span class="line">&#125; OMX_PORTDOMAINTY</span><br></pre></td></tr></table></figure><p>音频类型，视频类型，图像类型，其他类型是OpenMax IL层此所定义的四种端口的类型。</p><p>端口具体内容的定义使用OMX_PARAM_PORTDEFINITIONTYPE类（也在OMX_Component.h中定义）来表示，其内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">OMX_PARAM_PORTDEFINITIONTYPE</span> &#123;</span>   </span><br><span class="line">    OMX_U32 nSize;                      <span class="comment">/* 结构体大小 */</span>   </span><br><span class="line">    OMX_VERSIONTYPE nVersion;           <span class="comment">/* 版本*/</span>   </span><br><span class="line">    OMX_U32 nPortIndex;             <span class="comment">/* 端口号 */</span>   </span><br><span class="line">    OMX_DIRTYPE eDir;                   <span class="comment">/* 端口的方向 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountActual;         <span class="comment">/* 为这个端口实际分配的Buffer的数目 */</span>   </span><br><span class="line">    OMX_U32 nBufferCountMin;            <span class="comment">/* 这个端口最小Buffer的数目*/</span>   </span><br><span class="line">    OMX_U32 nBufferSize;                <span class="comment">/* 缓冲区的字节数 */</span>   </span><br><span class="line">    OMX_BOOL bEnabled;                  <span class="comment">/* 是否使能 */</span>   </span><br><span class="line">    OMX_BOOL bPopulated;                <span class="comment">/* 是否在填充 */</span>   </span><br><span class="line">    OMX_PORTDOMAINTYPE eDomain;         <span class="comment">/* 端口的类型 */</span>   </span><br><span class="line">    <span class="keyword">union</span> &#123;                         <span class="comment">/* 端口实际的内容，由类型确定具体结构 */</span>   </span><br><span class="line">        OMX_AUDIO_PORTDEFINITIONTYPE audio;   </span><br><span class="line">        OMX_VIDEO_PORTDEFINITIONTYPE video;   </span><br><span class="line">        OMX_IMAGE_PORTDEFINITIONTYPE image;   </span><br><span class="line">        OMX_OTHER_PORTDEFINITIONTYPE other;   </span><br><span class="line">    &#125; format;   </span><br><span class="line">    OMX_BOOL bBuffersContiguous;   </span><br><span class="line">    OMX_U32 nBufferAlignment;   </span><br><span class="line">&#125; OMX_PARAM_PORTDEFINITIONTYPE;</span><br></pre></td></tr></table></figure><p>对于一个端口，其重点的内容如下:</p><p>☯    端口的方向（OMX_DIRTYPE）：包含OMX_DirInput（输入）和OMX_DirOutput（输出）两种<br>☯    端口分配的缓冲区数目和最小缓冲区数目<br>☯    端口的类型（OMX_PORTDOMAINTYPE）：可以是四种类型<br>☯    端口格式的数据结构：使用format联合体来表示，具体由四种不同类型来表示，与端口的类型相对应<br>☯    OMX_AUDIO_PORTDEFINITIONTYPE，OMX_VIDEO_PORTDEFINITIONTYPE，OMX_IMAGE_PORTDEFINITIONTYPE和OMX_OTHER_PORTDEFINITIONTYPE等几个具体的格式类型，分别在OMX_Audio.h，OMX_Video.h，OMX_Image.h和OMX_Other.h这四个头文件中定义。<br>       OMX_Core.h中定义的枚举类型OMX_STATETYPE命令表示OpenMax的状态机，内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_STATETYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_StateInvalid,                   <span class="comment">/* 组件监测到内部的数据结构被破坏 */</span>   </span><br><span class="line">    OMX_StateLoaded,                    <span class="comment">/* 组件被加载但是没有完成初始化 */</span>   </span><br><span class="line">    OMX_StateIdle,                      <span class="comment">/* 组件初始化完成，准备开始 */</span>   </span><br><span class="line">    OMX_StateExecuting,             <span class="comment">/* 组件接受了开始命令，正在树立数据 */</span>   </span><br><span class="line">    OMX_StatePause,                     <span class="comment">/* 组件接受暂停命令*/</span>   </span><br><span class="line">    OMX_StateWaitForResources,      <span class="comment">/* 组件正在等待资源 */</span>   </span><br><span class="line">    OMX_StateKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_StateVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_StateMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_STATETYPE;</span><br></pre></td></tr></table></figure><p>OpenMax组件的状态机可以由外部的命令改变，也可以由内部发生的情况改变。OpenMax IL组件的状态机的迁移关系如图所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-08-OMXstate.png" alt="Alt text | center"></p><p> OMX_Core.h中定义的枚举类型OMX_COMMANDTYPE表示对组件的命令类型，内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> OMX_COMMANDTYPE   </span><br><span class="line">&#123;   </span><br><span class="line">    OMX_CommandStateSet,                <span class="comment">/* 改变状态机器 */</span>   </span><br><span class="line">    OMX_CommandFlush,                   <span class="comment">/* 刷新数据队列 */</span>   </span><br><span class="line">    OMX_CommandPortDisable,             <span class="comment">/* 禁止端口 */</span>   </span><br><span class="line">    OMX_CommandPortEnable,              <span class="comment">/* 使能端口 */</span>   </span><br><span class="line">    OMX_CommandMarkBuffer,              <span class="comment">/* 标记组件或Buffer用于观察 */</span>   </span><br><span class="line">    OMX_CommandKhronosExtensions = <span class="number">0x6F000000</span>, <span class="comment">/* 保留for Khronos */</span>   </span><br><span class="line">    OMX_CommandVendorStartUnused = <span class="number">0x7F000000</span>, <span class="comment">/* 保留for厂商 */</span>   </span><br><span class="line">    OMX_CommandMax = <span class="number">0X7FFFFFFF</span>  </span><br><span class="line">&#125; OMX_COMMANDTYPE;</span><br></pre></td></tr></table></figure><p>OMX_COMMANDTYPE类型在SendCommand调用中作为参数被使用，其中OMX_CommandStateSet就是改变状态机的命令。</p><h6 id="2-1-2、OpenMax-IL实现的内容"><a href="#2-1-2、OpenMax-IL实现的内容" class="headerlink" title="2.1.2、OpenMax IL实现的内容"></a>2.1.2、OpenMax IL实现的内容</h6><p>  对于OpenMax IL层的实现，一般的方式并不调用OpenMax DL层。具体实现的内容就是各个不同的组件。<br>       OpenMax IL组件的实现包含以下两个步骤：</p><p>☯    组件的初始化函数：硬件和OpenMax数据结构的初始化，一般分成函数指针初始化、私有数据结构的初始化、端口的初始化等几个步骤，使用OMX_Component.h其中的pComponentPrivate成员保留本组件的私有数据为上下文，最后获得填充完成OMX_COMPONENTTYPE类型的结构体。<br>☯    OMX_COMPONENTTYPE类型结构体的各个指针：实现其中的各个函数指针，需要使用私有数据的时候，从其中的pComponentPrivate得到指针，转化成实际的数据结构使用。</p><p>端口的定义是OpenMax IL组件对外部的接口。OpenMax IL常用的组件大都是输入和输出端口各一个。对于最常用的编解码（Codec）组件，通常需要在每个组件的实现过程中，调用硬件的编解码接口来实现。在组件的内部处理中，可以建立线程来处理。OpenMax的组件的端口有默认参数，但也可以在运行时设置，因此一个端口也可以支持不同的编码格式。音频编码组件的输出和音频编码组件的输入通常是原始数据格式（PCM格式），视频编码组件的输出和视频编码组件的输入通常是原始数据格式（YUV格式）。<br>       提示：在一种特定的硬件实现中，编解码部分具有相似性，因此通常可以构建一个OpenMax组件的”基类”或者公共函数，来完成公共性的操作。</p><h5 id="2-2、Android中OpenMax的适配层"><a href="#2-2、Android中OpenMax的适配层" class="headerlink" title="2.2、Android中OpenMax的适配层"></a>2.2、Android中OpenMax的适配层</h5><p>  Android中的OpenMax适配层的接口在frameworks/av/include/media/IOMX.h文件定义，其内容如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOMX</span> :</span> <span class="keyword">public</span> IInterface &#123;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    DECLARE_META_INTERFACE(OMX);    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *buffer_id;    </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span> *node_id;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">livesLocally</span><span class="params">(<span class="keyword">pid_t</span> pid)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ComponentInfo</span> &#123;</span><span class="comment">// 组件的信息    </span></span><br><span class="line">        String8 mName;    </span><br><span class="line">        List&lt;String8&gt; mRoles;    </span><br><span class="line">    &#125;;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">listNodes</span><span class="params">(List&lt;ComponentInfo&gt; *<span class="built_in">list</span>)</span> </span>= <span class="number">0</span>;  <span class="comment">// 节点列表    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateNode</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> sp&lt;IOMXObserver&gt; &amp;observer,  <span class="comment">// 分配节点    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id *node)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeNode</span><span class="params">(node_id node)</span> </span>= <span class="number">0</span>; <span class="comment">// 找到节点    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">sendCommand</span><span class="params">(<span class="comment">// 发送命令    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_COMMANDTYPE cmd, OMX_S32 param)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getParameter</span><span class="params">(<span class="comment">// 获得参数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setParameter</span><span class="params">(<span class="comment">// 设置参数    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getConfig</span><span class="params">(<span class="comment">// 获得配置    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">setConfig</span><span class="params">(<span class="comment">// 设置配置    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_INDEXTYPE index,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">void</span> *params, <span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">useBuffer</span><span class="params">(<span class="comment">// 使用缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBuffer</span><span class="params">(<span class="comment">// 分配缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">size_t</span> size,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer, <span class="keyword">void</span> **buffer_data)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">allocateBufferWithBackup</span><span class="params">(<span class="comment">// 分配带后备缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, <span class="keyword">const</span> sp&lt;IMemory&gt; ¶ms,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id *buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">freeBuffer</span><span class="params">(<span class="comment">// 释放缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node, OMX_U32 port_index, buffer_id buffer)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">fillBuffer</span><span class="params">(node_id node, buffer_id buffer)</span> </span>= <span class="number">0</span>; <span class="comment">// 填充缓冲区    </span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">emptyBuffer</span><span class="params">(<span class="comment">// 消耗缓冲区    </span></span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node,    </span></span></span><br><span class="line"><span class="function"><span class="params">        buffer_id buffer,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_U32 range_offset, OMX_U32 range_length,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_U32 flags, OMX_TICKS timestamp)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">getExtensionIndex</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params">        node_id node,    </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *parameter_name,    </span></span></span><br><span class="line"><span class="function"><span class="params">        OMX_INDEXTYPE *index)</span> </span>= <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">virtual</span> sp&lt;IOMXRenderer&gt; createRenderer(<span class="comment">// 创建渲染器（从ISurface）    </span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;ISurface&gt; &amp;surface,    </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *componentName,    </span><br><span class="line">        OMX_COLOR_FORMATTYPE colorFormat,    </span><br><span class="line">        <span class="keyword">size_t</span> encodedWidth, <span class="keyword">size_t</span> encodedHeight,    </span><br><span class="line">        <span class="keyword">size_t</span> displayWidth, <span class="keyword">size_t</span> displayHeight) = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    ......   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> IOMX表示的是OpenMax的一个组件，根据Android的Binder IPC机制，BnOMX继承IOMX，实现者需要继承实现BnOMX。IOMX类中，有标准的OpenMax的GetParameter，SetParameter，GetConfig，SetConfig，SendCommand，UseBuffer，AllocateBuffer，FreeBuffer，FillThisBuffer和EmptyThisBuffer等接口。<br>       在IOMX.h文件中，另有表示观察器类的IOMXObserver，这个类表示OpenMax的观察者，其中只包含一个onMessage()函数，其参数为omx_message接口体，其中包含Event事件类型、FillThisBuffer完成和EmptyThisBuffer完成几种类型。<br>       提示：Android中OpenMax的适配层是OpenMAX IL层至上的封装层，在Android系统中被StageFright调用，也可以被其他部分调用。</p><h4 id="2-3、TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现"><a href="#2-3、TI-Texas-Instruments-德州仪器-OpenMax-IL的硬件实现" class="headerlink" title="2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现"></a>2.3、TI(Texas Instruments 德州仪器) OpenMax IL的硬件实现</h4><h5 id="2-3-1、TI-OpenMax-IL实现的结构和机制"><a href="#2-3-1、TI-OpenMax-IL实现的结构和机制" class="headerlink" title="2.3.1、TI OpenMax IL实现的结构和机制"></a>2.3.1、TI OpenMax IL实现的结构和机制</h5><p> Android的开源代码中，已经包含了TI的OpenMax IL层的实现代码，其路径如hardware/ti/omap3/omx下。其中包含的主要目录如下所示：</p><p>☯    system：OpenMax核心和公共部分<br>☯    audio：音频处理部分的OpenMax IL组件<br>☯    video：视频处理部分OpenMax IL组件<br>☯    image：图像处理部分OpenMax IL组件<br>       TI OpenMax IL实现的结构如图所示:</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-09-tiopenmaxil.png" alt="Alt text | center"></p><p> 在TI OpenMax IL实现中，最上面的内容是OpenMax的管理者用于管理和初始化，中间层是各个编解码单元的OpenMax IL标准组件，下层是LCML层，供各个OpenMax IL标准组件所调用。<br>       （1）TI OpenMax IL实现的公共部分在system/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ omx_core/src：OpenMax IL的核心，生成动态库libOMX_Core.so<br>☯ lcml/：LCML的工具库，生成动态库libLCML.so<br>       （2）I OpenMax IL的视频（Video）相关的组件在video/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ prepost_processor：Video数据的前处理和后处理，生成动态库libOMX.TI.VPP.so<br>☯ video_decode：Video解码器，生成动态库libOMX.TI.Video.Decoder.so<br>☯ video_encode：Video编码器，生成动态库libOMX.TI.Video.encoder.so<br>       （3）TI OpenMax IL的音频（Audio）相关的组件在audio/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ g711_dec：G711解码器，生成动态库libOMX.TI.G711.decode.so<br>☯ g711_enc：G711编码器，生成动态库libOMX.TI.G711.encode.so<br>☯ g722_dec：G722解码器，生成动态库libOMX.TI.G722.decode.so<br>☯ g722_enc：G722编码器，生成动态库libOMX.TI.G722.encode.so<br>☯ g726_dec：G726解码器，生成动态库libOMX.TI.G726.decode.so<br>☯ g726_enc：G726编码器，生成动态库libOMX.TI.G726.encode.so<br>☯ g729_dec：G729解码器，生成动态库libOMX.TI.G729.decode.so<br>☯ g729_enc：G720编码器，生成动态库libOMX.TI.G729.encode.so<br>☯ nbamr_dec：AMR窄带解码器，生成动态库libOMX.TI.AMR.decode.so<br>☯ nbamr_enc：AMR窄带编码器，生成动态库libOMX.TI.AMR.encode.so<br>☯ wbamr_dec：AMR宽带解码器，生成动态库libOMX.TI.WBAMR.decode.so<br>☯ wbamr_enc：AMR宽带编码器，生成动态库libOMX.TI.WBAMR.encode.so<br>☯ mp3_dec：MP3解码器，生成动态库libOMX.TI.MP3.decode.so<br>☯ aac_dec：AAC解码器，生成动态库libOMX.TI.AAC.decode.so<br>☯ aac_enc：AAC编码器，生成动态库libOMX.TI.AAC.encode.so<br>☯ wma_dec：WMA解码器，生成动态库libOMX.TI.WMA.decode.so<br>       （4）TI OpenMax IL的图像（Image）相关的组件在image/src/openmax_il/目录中，主要的内容如下所示。</p><p>☯ jpeg_enc：JPEG编码器，生成动态库libOMX.TI.JPEG.Encoder.so<br>☯ jpeg_dec：JPEG解码器，生成动态库libOMX.TI.JPEG.decoder.so</p><h5 id="2-3-2、TI-OpenMax-IL的核心和公共内容"><a href="#2-3-2、TI-OpenMax-IL的核心和公共内容" class="headerlink" title="2.3.2、TI OpenMax IL的核心和公共内容"></a>2.3.2、TI OpenMax IL的核心和公共内容</h5><p> LCML的全称是”Linux Common Multimedia Layer“，是TI的Linux公共多媒体层。在OpenMax IL的实现中，这个内容在system/src/openmax_il/lcml/目录中，主要文件是子目录src中的LCML_DspCodec.c文件。通过调用DSPBridge的内容， 让ARM和DSP进行通信，然DSP进行编解码方面的处理。DSP的运行还需要固件的支持。</p><p> TI OpenMax IL的核心实现在system/src/openmax_il/omx_core/目录中，生成TI OpenMax IL的核心库libOMX_Core.so。</p><p>其中子目录src中的OMX_Core.c为主要文件，其中定义了编解码器的名称等，其片断如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *tComponentName[MAXCOMP][<span class="number">2</span>] = &#123;    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.decoder"</span>, <span class="string">"image_decoder.jpeg"</span>&#125;,<span class="comment">/* 图像和视频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.JPEG.Encoder"</span>, <span class="string">"image_encoder.jpeg"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.avc"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.Decoder"</span>, <span class="string">"video_decoder.wmv"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.mpeg4"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.h263"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.Video.encoder"</span>, <span class="string">"video_encoder.avc"</span>&#125;,    </span><br><span class="line">     <span class="comment">/* ......省略 ，语音相关组件*/</span>    </span><br><span class="line">#ifdef BUILD_WITH_TI_AUDIO <span class="comment">/* 音频编解码器 */</span>    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.MP3.decode"</span>, <span class="string">"audio_decoder.mp3"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.encode"</span>, <span class="string">"audio_encoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AAC.decode"</span>, <span class="string">"audio_decoder.aac"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WMA.decode"</span>, <span class="string">"audio_decoder.wma"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.decode"</span>, <span class="string">"audio_decoder.amrwb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.decode"</span>, <span class="string">"audio_decoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.AMR.encode"</span>, <span class="string">"audio_encoder.amrnb"</span>&#125;,    </span><br><span class="line">    &#123;<span class="string">"OMX.TI.WBAMR.encode"</span>, <span class="string">"audio_encoder.amrwb"</span>&#125;,    </span><br><span class="line">#endif    </span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;,    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  tComponentName数组的各个项中，第一个表示<strong>编解码库内容</strong>，第二个表示<strong>库所实现的功能</strong>。<br>       其中，TIOMX_GetHandle()函数用于获得各个组件的句柄，其实现的主要片断如下所示：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">TIOMX_GetHandle</span><span class="params">( OMX_HANDLETYPE* pHandle, OMX_STRING cComponentName,    </span></span></span><br><span class="line"><span class="function"><span class="params">    OMX_PTR pAppData, OMX_CALLBACKTYPE* pCallBacks)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> prefix[] = <span class="string">"lib"</span>;    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> postfix[] = <span class="string">".so"</span>;    </span><br><span class="line">    OMX_ERRORTYPE (*pComponentInit)(OMX_HANDLETYPE*);    </span><br><span class="line">    OMX_ERRORTYPE err = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *componentType;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pErr = dlerror();    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; COUNTOF(pModules); i++) &#123;       <span class="comment">// 循环查找    </span></span><br><span class="line">        <span class="keyword">if</span>(pModules[i] == <span class="literal">NULL</span>) <span class="keyword">break</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">    <span class="keyword">int</span> refIndex = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (refIndex=<span class="number">0</span>; refIndex &lt; MAX_TABLE_SIZE; refIndex++) &#123;    </span><br><span class="line">    <span class="comment">// 循环查找组件列表    </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(componentTable[refIndex].name, cComponentName) == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (componentTable[refIndex].refCount&gt;= MAX_CONCURRENT_INSTANCES) &#123;    </span><br><span class="line">            <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(prefix) + MAXNAMESIZE+ <span class="keyword">sizeof</span>(postfix)];    </span><br><span class="line">                <span class="built_in">strcpy</span>(buf, prefix);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, cComponentName);    </span><br><span class="line">                <span class="built_in">strcat</span>(buf, postfix);    </span><br><span class="line">                pModules[i] = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                <span class="comment">// 动态取出初始化的符号    </span></span><br><span class="line">                pComponentInit = dlsym(pModules[i], <span class="string">"OMX_ComponentInit"</span>);    </span><br><span class="line">                pErr = dlerror();    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                *pHandle = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(OMX_COMPONENTTYPE));    </span><br><span class="line">                <span class="comment">// ...... 省略错误处理内容    </span></span><br><span class="line">                pComponents[i] = *pHandle;    </span><br><span class="line">                componentType = (OMX_COMPONENTTYPE*) *pHandle;    </span><br><span class="line">                componentType-&gt;nSize = <span class="keyword">sizeof</span>(OMX_COMPONENTTYPE);    </span><br><span class="line">                err = (*pComponentInit)(*pHandle);   <span class="comment">// 执行初始化工作    </span></span><br><span class="line">                <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    err = OMX_ErrorComponentNotFound;    </span><br><span class="line">    <span class="keyword">goto</span> UNLOCK_MUTEX;    </span><br><span class="line">    <span class="comment">// ...... 省略部分内容    </span></span><br><span class="line">     <span class="keyword">return</span> (err);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 在TIOMX_GetHandle()函数中，根据tComponentName数组中动态库的名称，动态打开各个编解码实现的动态库，取出其中的<strong>OMX_ComponentInit</strong>符号来执行各个组件的初始化。</p><h5 id="2-3-3、一个TI-OpenMax-IL组件的实现"><a href="#2-3-3、一个TI-OpenMax-IL组件的实现" class="headerlink" title="2.3.3、一个TI OpenMax IL组件的实现"></a>2.3.3、一个TI OpenMax IL组件的实现</h5><p>  TI OpenMax IL中各个组件都是通过调用LCML来实现的，实现的方式基本类似。主要都是实现了名称为OMX_ComponentInit的初始化函数，实现OMX_COMPONENTTYPE类型的结构体中的各个成员。各个组件其目录结构和文件结构也类似。</p><p>以MP3解码器的实现为例，在audio/src/openmax_il/mp3_dec/src目录中，主要包含以下文件：</p><p>☯ OMX_Mp3Decoder.c：MP3解码器组件实现<br>☯ OMX_Mp3Dec_CompThread.c：MP3解码器组件的线程循环<br>☯ OMX_Mp3Dec_Utils.c：MP3解码器的相关工具，调用LCML实现真正的MP3解码的功能<br>       OMX_Mp3Decoder.c中的OMX_ComponentInit()函数负责组件的初始化，返回的内容再从参数中得到，这个函数的主要片断如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OMX_ERRORTYPE <span class="title">OMX_ComponentInit</span> <span class="params">(OMX_HANDLETYPE hComp)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    OMX_ERRORTYPE eError = OMX_ErrorNone;    </span><br><span class="line">    OMX_COMPONENTTYPE *pHandle = (OMX_COMPONENTTYPE*) hComp;    </span><br><span class="line">    OMX_PARAM_PORTDEFINITIONTYPE *pPortDef_ip = <span class="literal">NULL</span>, *pPortDef_op = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PORTFORMATTYPE *pPortFormat = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_MP3TYPE *mp3_ip = <span class="literal">NULL</span>;    </span><br><span class="line">    OMX_AUDIO_PARAM_PCMMODETYPE *mp3_op = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3DEC_COMPONENT_PRIVATE *pComponentPrivate = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_AUDIODEC_PORT_TYPE *pCompPort = <span class="literal">NULL</span>;    </span><br><span class="line">    MP3D_BUFFERLIST *pTemp = <span class="literal">NULL</span>;    </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">  </span><br><span class="line">    MP3D_OMX_CONF_CHECK_CMD(pHandle,<span class="number">1</span>,<span class="number">1</span>);    </span><br><span class="line">    <span class="comment">/* ......省略，初始化OMX_COMPONENTTYPE类型的指针pHandle */</span>    </span><br><span class="line">    OMX_MALLOC_GENERIC(pHandle-&gt;pComponentPrivate, MP3DEC_COMPONENT_PRIVATE);    </span><br><span class="line">    pComponentPrivate = pHandle-&gt;pComponentPrivate; <span class="comment">/* 私有指针互相指向 */</span>    </span><br><span class="line">    pComponentPrivate-&gt;pHandlepHandle = pHandle;    </span><br><span class="line">    <span class="comment">/* ......略，初始化似有数据指针pComponentPrivate */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_ip-&gt;nSize                   = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_ip-&gt;nPortIndex             = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortDef_ip-&gt;eDir                    = OMX_DirInput;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountActual    = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferCountMin        = MP3D_NUM_INPUT_BUFFERS;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferSize             = MP3D_INPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_ip-&gt;nBufferAlignment       = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_ip-&gt;bEnabled                 = OMX_TRUE;    </span><br><span class="line">    pPortDef_ip-&gt;bPopulated               = OMX_FALSE;    </span><br><span class="line">    pPortDef_ip-&gt;eDomain                   = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.eEncoding = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.cMIMEType = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.pNativeRender           = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_ip-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* 设置输出端口（OMX_PARAM_PORTDEFINITIONTYPE类型）的默认值 */</span>    </span><br><span class="line">    pPortDef_op-&gt;nSize                 = <span class="keyword">sizeof</span>(OMX_PARAM_PORTDEFINITIONTYPE);    </span><br><span class="line">    pPortDef_op-&gt;nPortIndex           = MP3D_OUTPUT_PORT;    </span><br><span class="line">    pPortDef_op-&gt;eDir                  = OMX_DirOutput;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountMin     = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferCountActual  = MP3D_NUM_OUTPUT_BUFFERS;    </span><br><span class="line">    pPortDef_op-&gt;nBufferSize          = MP3D_OUTPUT_BUFFER_SIZE;    </span><br><span class="line">    pPortDef_op-&gt;nBufferAlignment    = DSP_CACHE_ALIGNMENT;    </span><br><span class="line">    pPortDef_op-&gt;bEnabled              = OMX_TRUE;    </span><br><span class="line">    pPortDef_op-&gt;bPopulated            = OMX_FALSE;    </span><br><span class="line">    pPortDef_op-&gt;eDomain               = OMX_PortDomainAudio;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.eEncoding      = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.cMIMEType      = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.pNativeRender = <span class="literal">NULL</span>;    </span><br><span class="line">    pPortDef_op-&gt;format.audio.bFlagErrorConcealment = OMX_FALSE;    </span><br><span class="line">    <span class="comment">/* ......省略，分配端口 */</span>    </span><br><span class="line">    <span class="comment">/* 设置输入端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_INPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">    pPortFormat-&gt;nPortIndex         = MP3D_INPUT_PORT;    </span><br><span class="line">    pPortFormat-&gt;nIndex             = OMX_IndexParamAudioMp3;    </span><br><span class="line">    pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingMP3;    </span><br><span class="line">    <span class="comment">/* 设置输出端口的默认格式 */</span>    </span><br><span class="line">    pPortFormat = pComponentPrivate-&gt;pCompPort[MP3D_OUTPUT_PORT]-&gt;pPortFormat;    </span><br><span class="line">    OMX_CONF_INIT_STRUCT(pPortFormat, OMX_AUDIO_PARAM_PORTFORMATTYPE);    </span><br><span class="line">        pPortFormat-&gt;nPortIndex         = MP3D_OUTPUT_PORT;    </span><br><span class="line">        pPortFormat-&gt;nIndex             = OMX_IndexParamAudioPcm;    </span><br><span class="line">        pPortFormat-&gt;eEncoding          = OMX_AUDIO_CodingPCM;    </span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    eError = Mp3Dec_StartCompThread(pHandle);   <span class="comment">// 启动MP3解码线程    </span></span><br><span class="line">    <span class="comment">/* ......省略部分内容 */</span>    </span><br><span class="line">    <span class="keyword">return</span> eError;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个组件是OpenMax的标准实现方式，对外的接口的内容只有一个初始化函数。完成OMX_COMPONENTTYPE类型的初始化。输入端口的编号为MP3D_INPUT_PORT（==0），类型为OMX_PortDomainAudio，格式为OMX_AUDIO_CodingMP3。输出端口的编号是MP3D_OUTPUT_PORT（==1），类型为OMX_PortDomainAudio，格式为OMXAUDIO CodingPCM。</p><p>  OMX_Mp3Dec_CompThread.c中定义了MP3DEC_ComponentThread()函数，用于创建MP3解码的线程的执行函数。<br>  OMX_Mp3Dec_Utils.c中的Mp3Dec_StartCompThread()函数，调用了POSIX的线程库建立MP3解码的线程，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nRet = pthread_create (&amp;(pComponentPrivate-&gt;ComponentThread), <span class="literal">NULL</span>,    </span><br><span class="line">    MP3DEC_ComponentThread, pComponentPrivate);</span><br></pre></td></tr></table></figure><p> Mp3Dec_StartCompThread()函数就是在组件初始化函数OMX_ComponentInit()最后调用的内容。MP3线程的开始并不表示解码过程开始，线程需要等待通过pipe机制获得命令和数据（cmdPipe和dataPipe），在适当的时候开始工作。这个pipe在MP3解码组件的SendCommand等实现写操作，在线程中读取其内容。</p><h5 id="2-4、Qualcomm-高通-OpenMax-IL的硬件实现"><a href="#2-4、Qualcomm-高通-OpenMax-IL的硬件实现" class="headerlink" title="2.4、Qualcomm(高通) OpenMax IL的硬件实现"></a>2.4、Qualcomm(高通) OpenMax IL的硬件实现</h5><h6 id="2-4-1、qcom-OpenMax-IL实现的结构和机制"><a href="#2-4-1、qcom-OpenMax-IL实现的结构和机制" class="headerlink" title="2.4.1、qcom OpenMax IL实现的结构和机制"></a>2.4.1、qcom OpenMax IL实现的结构和机制</h6><p>（1）在AOSP中依然有对高通平台的OpenMax IL层实现代码，位于hardware/qcom/media/mm-core下。这一部分是OpenMax核心和公共部分，主要编译为libOmxCore.so。</p><p>（2）e.g. 继续在hardware/qcom/media下，选取mm-video-v4l2目录。即Video4linux2（简称V4L2),是linux中关于视频设备的内核驱动。再次进入vidc，（DivxDrmDecrypt为DRM数字版权相关）主要目录如下：</p><p>☯ vdec：视频解码处理，编译成libOmxVdec.so/libOmxVdecHevc.so<br>☯ venc：视频编码处理，编译成libOmxVenc.so<br>qcom OpenMax IL的核心和公共内容<br>       类似于前面介绍的TI，高通平台在OpenMax IL实现也是大同小异，位于hardware/qcom/media/mm-core，生成libOmxCore.so库。<br>       其中qc_omx_core为主要文件，位于hardware/qcom/media/mm-core/omxcore/src/common/下面。和TI的差不多，OMX_GetHandle()函数用户获取各个组件的句柄，其实现的主要片断如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编解码器组件集合数组</span></span><br><span class="line"><span class="keyword">extern</span> omx_core_cb_type core[];</span><br><span class="line"></span><br><span class="line"> OMX_API OMX_ERRORTYPE OMX_APIENTRY</span><br><span class="line">OMX_GetHandle(OMX_OUT OMX_HANDLETYPE*     handle,</span><br><span class="line">              OMX_IN OMX_STRING    componentName,</span><br><span class="line">              OMX_IN OMX_PTR             appData,</span><br><span class="line">              OMX_IN OMX_CALLBACKTYPE* callBacks)</span><br><span class="line">&#123;</span><br><span class="line">  OMX_ERRORTYPE  eRet = OMX_ErrorNone;</span><br><span class="line">  <span class="keyword">int</span> cmp_index = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">int</span> hnd_index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  DEBUG_PRINT(<span class="string">"OMXCORE API :  Get Handle %p %s %p\n"</span>, handle,</span><br><span class="line">                                                     componentName,</span><br><span class="line">                                                     appData);</span><br><span class="line">  pthread_mutex_lock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">if</span>(handle)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sd</span>;</span></span><br><span class="line"><span class="comment">//组件句柄</span></span><br><span class="line">    *handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//获取根据组件名获取相应index</span></span><br><span class="line">    cmp_index = get_cmp_index(componentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmp_index &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       DEBUG_PRINT(<span class="string">"getting fn pointer\n"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// dynamically load the so 动态加载组件的so库</span></span><br><span class="line">      core[cmp_index].fn_ptr =</span><br><span class="line">        omx_core_load_cmp_library(core[cmp_index].so_lib_name,</span><br><span class="line">                                  &amp;core[cmp_index].so_lib_handle);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(core[cmp_index].fn_ptr)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// Construct the component requested</span></span><br><span class="line">        <span class="comment">// Function returns the opaque handle</span></span><br><span class="line">        <span class="comment">//根据获取的组件句柄初始化它</span></span><br><span class="line">        <span class="keyword">void</span>* pThis = (*(core[cmp_index].fn_ptr))();</span><br><span class="line">        <span class="keyword">if</span>(pThis)</span><br><span class="line">        &#123;</span><br><span class="line">      <span class="comment">//包装一层，忽略</span></span><br><span class="line">          <span class="keyword">void</span> *hComp = <span class="literal">NULL</span>;</span><br><span class="line">          hComp = qc_omx_create_component_wrapper((OMX_PTR)pThis);</span><br><span class="line">          <span class="keyword">if</span>((eRet = qc_omx_component_init(hComp, core[cmp_index].name)) !=</span><br><span class="line">                           OMX_ErrorNone)</span><br><span class="line">          &#123;</span><br><span class="line">              DEBUG_PRINT(<span class="string">"Component not created succesfully\n"</span>);</span><br><span class="line">              pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">              <span class="keyword">return</span> eRet;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//设置回调</span></span><br><span class="line">          qc_omx_component_set_callbacks(hComp,callBacks,appData);</span><br><span class="line">          hnd_index = get_comp_handle_index(componentName);</span><br><span class="line"> </span><br><span class="line">          <span class="keyword">if</span>(hnd_index &gt;= <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//保存这个组件句柄</span></span><br><span class="line">            core[cmp_index].inst[hnd_index]= *handle = (OMX_HANDLETYPE) hComp;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">          <span class="comment">/*-------下面全是错误处理，忽略------*/</span></span><br><span class="line">            DEBUG_PRINT(<span class="string">"OMX_GetHandle:NO free slot available to store Component Handle\n"</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">          &#125;</span><br><span class="line">          DEBUG_PRINT(<span class="string">"Component %p Successfully created\n"</span>,*handle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">          DEBUG_PRINT(<span class="string">"Component Creation failed\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        eRet = OMX_ErrorNotImplemented;</span><br><span class="line">        DEBUG_PRINT(<span class="string">"library couldnt return create instance fn\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      eRet = OMX_ErrorNotImplemented;</span><br><span class="line">      DEBUG_PRINT(<span class="string">"ERROR: Already another instance active  ;rejecting \n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    eRet =  OMX_ErrorBadParameter;</span><br><span class="line">    DEBUG_PRINT(<span class="string">"\n OMX_GetHandle: NULL handle \n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock_core);</span><br><span class="line">  <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里的有个数组：extern omx_core_cb_type core[]，是从别的文件中声明过来的全局变量，其中包含了各种编解码器的名称和一些属性的结构体。结构体定义位于hardware/qcom/media/mm-core/omxcore/src/common/qc_omx_core.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">omx_core_cb_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span>*                         name;<span class="comment">// Component name 组件名</span></span><br><span class="line">  create_qc_omx_component     fn_ptr;<span class="comment">// create instance fn ptr 创建实例函数指针</span></span><br><span class="line">  <span class="keyword">void</span>*                         inst[OMX_COMP_MAX_INST];<span class="comment">// Instance handle 实例句柄</span></span><br><span class="line">  <span class="keyword">void</span>*                so_lib_handle;<span class="comment">// So Library handle so库句柄</span></span><br><span class="line">  <span class="keyword">char</span>*                  so_lib_name;<span class="comment">// so directory so名</span></span><br><span class="line">  <span class="keyword">char</span>* roles[OMX_CORE_MAX_CMP_ROLES];<span class="comment">// roles played 组件扮演的角色</span></span><br><span class="line">&#125;omx_core_cb_type;</span><br></pre></td></tr></table></figure><p>  但是给omx_core_cb_type core[]这个结构体数组复制的地方要根据不同型号进行选取，我们进入hardware/qcom/media/mm-core/src下面，会看到有许多型号，7627A、7630、8084、8226、8610、8660等等。比如这个8974的，位于hardware/qcom/media/mm-core/src/8974/qc_registry_table_android.c中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">omx_core_cb_type core[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//avc/h264解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.avc"</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.avc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//mpeg4解码器</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.mpeg4"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.mpeg4"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//wmv解码器</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.decoder.wmv"</span>,</span><br><span class="line">    <span class="literal">NULL</span>, <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVdec.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_decoder.vc1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    <span class="comment">//hevc/h265编码器</span></span><br><span class="line">   &#123;</span><br><span class="line">    <span class="string">"OMX.qcom.video.encoder.hevc"</span>,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Create instance function</span></span><br><span class="line">    <span class="comment">// Unique instance handle</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="literal">NULL</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">NULL</span>,   <span class="comment">// Shared object library handle</span></span><br><span class="line">    <span class="string">"libOmxVencHevc.so"</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"video_encoder.hevc"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  ...太多了，省略...</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面就是对编解码器相关信息的注册。</p><p>在OMX_GetHandle()函数中，根据omx_core_cb_type core[]数组中动态库的名称，动态打开各个编解码实现的动态库,然后进行初始化。</p><h6 id="2-4-1、一个qcom-OpenMax-IL组件的实现"><a href="#2-4-1、一个qcom-OpenMax-IL组件的实现" class="headerlink" title="2.4.1、一个qcom OpenMax IL组件的实现"></a>2.4.1、一个qcom OpenMax IL组件的实现</h6><p> 高通平台对于编解码组件的处理都比较集中，不像TI那么分散和细致。一个组件实现都要包含Qc_omx_component.h头文件，位于很多地方，如hardware/qcom/media/mm-core/inc，要实现里面相关纯虚函数。当一个组件被创建后要初始化，就要实现component_init(OMX_IN OMX_STRING componentName)方法。</p><p>举个例子，依然以Video4linux2平台，进入hardware/qcom/media/mm-video-v4l2/vidc/vdec/src查看视频解码相关组件。比如我们看看解码组件omx_vdec_hevc.cpp，查看component_init方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENUS_HEVC</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"/dev/video/venus_dec"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEVICE_NAME <span class="meta-string">"/dev/video/q6_dec"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ======================================================================</span></span><br><span class="line"><span class="comment">   FUNCTION</span></span><br><span class="line"><span class="comment">   omx_vdec::ComponentInit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   DESCRIPTION</span></span><br><span class="line"><span class="comment">   Initialize the component.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PARAMETERS</span></span><br><span class="line"><span class="comment">   ctxt -- Context information related to the self.</span></span><br><span class="line"><span class="comment">   id   -- Event identifier. This could be any of the following:</span></span><br><span class="line"><span class="comment">   1. Command completion event</span></span><br><span class="line"><span class="comment">   2. Buffer done callback event</span></span><br><span class="line"><span class="comment">   3. Frame done callback event</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   RETURN VALUE</span></span><br><span class="line"><span class="comment">   None.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   ========================================================================== */</span></span><br><span class="line">OMX_ERRORTYPE omx_vdec::component_init(OMX_STRING role)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    OMX_ERRORTYPE eRet = OMX_ErrorNone;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_fmtdesc</span> <span class="title">fdesc</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">bufreq</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">control</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>   alignment = <span class="number">0</span>,buffer_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> r,ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> codec_ambiguous = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//打开设备文件"/dev/video/venus_dec"或"/dev/video/q6_dec"</span></span><br><span class="line">    OMX_STRING device_name = (OMX_STRING)DEVICE_NAME;</span><br><span class="line">    ......</span><br><span class="line">    drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是一个打开成功后，为什么要再次打开？？excuse me ？</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd == <span class="number">0</span>) &#123;</span><br><span class="line">        drv_ctx.video_driver_fd = open(device_name, O_RDWR);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//打开设备文件失败</span></span><br><span class="line">    <span class="keyword">if</span> (drv_ctx.video_driver_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Omx_vdec::Comp Init Returning failure, errno %d"</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line">    drv_ctx.frame_rate.fps_numerator = DEFAULT_FPS;<span class="comment">//帧率分子</span></span><br><span class="line">    drv_ctx.frame_rate.fps_denominator = <span class="number">1</span>;<span class="comment">//帧率分母</span></span><br><span class="line"><span class="comment">//创建一个异步线程，执行async_message_thread函数，对输入端进行设置</span></span><br><span class="line">    ret = pthread_create(&amp;async_thread_id,<span class="number">0</span>,async_message_thread,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//创建线程失败，则关闭设备文件</span></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        close(drv_ctx.video_driver_fd);</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Failed to create async_message_thread"</span>);</span><br><span class="line">        <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy the role information which provides the decoder kind</span></span><br><span class="line">    <span class="comment">//将组建角色名字copy进设备驱动上下文结构体的kind属性</span></span><br><span class="line">    strlcpy(drv_ctx.kind,role,<span class="number">128</span>);</span><br><span class="line"><span class="comment">//如果是mpeg4解码组件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">"OMX.qcom.video.decoder.mpeg4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.mpeg4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.timestamp_adjust = <span class="literal">true</span>;</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG4;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG4;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_MPEG4;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG4*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG4;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是mpeg2解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind,<span class="string">"OMX.qcom.video.decoder.mpeg2"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.mpeg2"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_MPEG2;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_MPEG2;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingMPEG2;</span><br><span class="line">        <span class="comment">/*Initialize Start Code for MPEG2*/</span></span><br><span class="line">        codec_type_parse = CODEC_TYPE_MPEG2;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是h263解码组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.h263"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.h263"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW(<span class="string">"H263 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H263;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingH263;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_H263;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H263;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是divx311...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx311"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_LOW (<span class="string">"DIVX 311 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_3;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX_311;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx4...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx4"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">"DIVX 4 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_4;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是divx...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.divx"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.divx"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        DEBUG_PRINT_ERROR (<span class="string">"DIVX 5/6 Decoder selected"</span>);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_DIVX_6;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_DIVX;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingDivx;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_DIVX;</span><br><span class="line">        codec_ambiguous = <span class="literal">true</span>;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"></span><br><span class="line">        eRet = createDivxDrmContext();</span><br><span class="line">        <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"createDivxDrmContext Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> eRet;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果是avc/h264...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.avc"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.avc"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_H264;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_H264;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingAVC;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_H264;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">......</span><br><span class="line"><span class="comment">//如果是hevc/h265...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.hevc"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.hevc"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_HEVC;</span><br><span class="line">        output_capability=V4L2_PIX_FMT_HEVC;</span><br><span class="line">        eCompressionFormat = (OMX_VIDEO_CODINGTYPE)QOMX_VIDEO_CodingHevc;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_HEVC;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line">        m_frame_parser.init_nal_length(nal_length);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//如果是vc1...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.vc1"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vc1"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_G;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"><span class="comment">//如果是wmv...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.wmv"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vc1"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        drv_ctx.decoder_format = VDEC_CODECTYPE_VC1_RCV;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingWMV;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VC1;</span><br><span class="line">        output_capability = V4L2_PIX_FMT_VC1_ANNEX_L;</span><br><span class="line">        m_frame_parser.init_start_codes (codec_type_parse);</span><br><span class="line"><span class="comment">//如果是vp8...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drv_ctx.kind, <span class="string">"OMX.qcom.video.decoder.vp8"</span>,\</span><br><span class="line">                OMX_MAX_STRINGNAME_SIZE)) &#123;</span><br><span class="line">        strlcpy((<span class="keyword">char</span> *)m_cRole, <span class="string">"video_decoder.vp8"</span>,OMX_MAX_STRINGNAME_SIZE);</span><br><span class="line">        output_capability=V4L2_PIX_FMT_VP8;</span><br><span class="line">        eCompressionFormat = OMX_VIDEO_CodingVPX;</span><br><span class="line">        codec_type_parse = CODEC_TYPE_VP8;</span><br><span class="line">        arbitrary_bytes = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 如果是不认识的解码组件，则报错</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"ERROR:Unknown Component"</span>);</span><br><span class="line">        eRet = OMX_ErrorInvalidComponentName;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//如果错误</span></span><br><span class="line">    <span class="keyword">if</span> (eRet == OMX_ErrorNone) &#123;</span><br><span class="line"><span class="comment">//设置视频输出编码格式为YUV的一种</span></span><br><span class="line">        drv_ctx.output_format = VDEC_YUV_FORMAT_NV12;</span><br><span class="line">        <span class="comment">//设置颜色编码</span></span><br><span class="line">        OMX_COLOR_FORMATTYPE dest_color_format = (OMX_COLOR_FORMATTYPE)</span><br><span class="line">            QOMX_COLOR_FORMATYUV420PackedSemiPlanar32m;</span><br><span class="line">        <span class="keyword">if</span> (!client_buffers.set_color_format(dest_color_format)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Setting color format failed"</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//订阅事件</span></span><br><span class="line">        capture_capability= V4L2_PIX_FMT_NV12;</span><br><span class="line">        ret = subscribe_to_events(drv_ctx.video_driver_fd);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Subscribe Event Failed"</span>);</span><br><span class="line">            <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span></span><br><span class="line">        <span class="comment">//设置查询能力标志位</span></span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_QUERYCAP, &amp;cap);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to query capabilities"</span>);</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"Capabilities: driver_name = %s, card = %s, bus_info = %s,"</span></span><br><span class="line">                    <span class="string">" version = %d, capabilities = %x"</span>, cap.driver, cap.card,</span><br><span class="line">                    cap.bus_info, cap.version, cap.capabilities);</span><br><span class="line">        &#125;</span><br><span class="line">        ret=<span class="number">0</span>;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"fmt: description: %s, fmt: %x, flags = %x"</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        fdesc.type=V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fdesc.index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (ioctl(drv_ctx.video_driver_fd, VIDIOC_ENUM_FMT, &amp;fdesc) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            DEBUG_PRINT_HIGH(<span class="string">"fmt: description: %s, fmt: %x, flags = %x"</span>, fdesc.description,</span><br><span class="line">                    fdesc.pixelformat, fdesc.flags);</span><br><span class="line">            fdesc.index++;</span><br><span class="line">        &#125;</span><br><span class="line">        update_resolution(<span class="number">320</span>, <span class="number">240</span>);</span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = output_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to set format on output port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Set Format was successful"</span>);</span><br><span class="line">        <span class="comment">//如果有歧义的解码组件</span></span><br><span class="line">        <span class="keyword">if</span> (codec_ambiguous) &#123;</span><br><span class="line">            <span class="keyword">if</span> (output_capability == V4L2_PIX_FMT_DIVX) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_control</span> <span class="title">divx_ctrl</span>;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_4) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_4;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_DIVX_5) &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_5;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    divx_ctrl.value = V4L2_MPEG_VIDC_VIDEO_DIVX_FORMAT_6;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                divx_ctrl.id = V4L2_CID_MPEG_VIDC_VIDEO_DIVX_FORMAT;</span><br><span class="line">                ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;divx_ctrl);</span><br><span class="line">                <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"Failed to set divx version"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"Codec should not be ambiguous"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//解码相关参数设置</span></span><br><span class="line">        fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;</span><br><span class="line">        fmt.fmt.pix_mp.height = drv_ctx.video_resolution.frame_height;</span><br><span class="line">        fmt.fmt.pix_mp.width = drv_ctx.video_resolution.frame_width;</span><br><span class="line">        fmt.fmt.pix_mp.pixelformat = capture_capability;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_FMT, &amp;fmt);</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="comment">/*<span class="doctag">TODO:</span> How to handle this case */</span></span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"Failed to set format on capture port"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Set Format was successful"</span>);</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            control.id = V4L2_CID_MPEG_VIDC_VIDEO_SECURE;</span><br><span class="line">            control.value = <span class="number">1</span>;</span><br><span class="line">            DEBUG_PRINT_LOW(<span class="string">"Omx_vdec:: calling to open secure device %d"</span>, ret);</span><br><span class="line">            ret=ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL,&amp;control);</span><br><span class="line">            <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"Omx_vdec:: Unable to open secure device %d"</span>, ret);</span><br><span class="line">                close(drv_ctx.video_driver_fd);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Get the Buffer requirements for input and output ports*/</span></span><br><span class="line">        <span class="comment">//获得输入和输出的缓冲条件</span></span><br><span class="line">        drv_ctx.ip_buf.buffer_type = VDEC_BUFFER_TYPE_INPUT;</span><br><span class="line">        drv_ctx.op_buf.buffer_type = VDEC_BUFFER_TYPE_OUTPUT;</span><br><span class="line">        <span class="keyword">if</span> (secure_mode) &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_1M;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_1M;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            drv_ctx.op_buf.alignment=SZ_4K;</span><br><span class="line">            drv_ctx.ip_buf.alignment=SZ_4K;</span><br><span class="line">        &#125;</span><br><span class="line">        drv_ctx.interlace = VDEC_InterlaceFrameProgressive;</span><br><span class="line">        drv_ctx.extradata = <span class="number">0</span>;</span><br><span class="line">        drv_ctx.picture_order = VDEC_ORDER_DISPLAY;</span><br><span class="line">        control.id = V4L2_CID_MPEG_VIDC_VIDEO_OUTPUT_ORDER;</span><br><span class="line">        control.value = V4L2_MPEG_VIDC_VIDEO_OUTPUT_ORDER_DISPLAY;</span><br><span class="line">        ret = ioctl(drv_ctx.video_driver_fd, VIDIOC_S_CTRL, &amp;control);</span><br><span class="line">        drv_ctx.idr_only_decoding = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        m_state = OMX_StateLoaded;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEFAULT_EXTRADATA</span></span><br><span class="line">        <span class="keyword">if</span> (eRet == OMX_ErrorNone &amp;&amp; !secure_mode)</span><br><span class="line">            enable_extradata(DEFAULT_EXTRADATA, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        eRet=get_buffer_req(&amp;drv_ctx.ip_buf);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Input Buffer Size =%d"</span>,drv_ctx.ip_buf.buffer_size);</span><br><span class="line">        get_buffer_req(&amp;drv_ctx.op_buf);</span><br><span class="line">        <span class="comment">//如果解码器格式是h264或者hevc/h265</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264 ||</span><br><span class="line">                drv_ctx.decoder_format == VDEC_CODECTYPE_HEVC) &#123;</span><br><span class="line">            h264_scratch.nAllocLen = drv_ctx.ip_buf.buffer_size;</span><br><span class="line">            h264_scratch.pBuffer = (OMX_U8 *)<span class="built_in">malloc</span> (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">            h264_scratch.nFilledLen = <span class="number">0</span>;</span><br><span class="line">            h264_scratch.nOffset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (h264_scratch.pBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"h264_scratch.pBuffer Allocation failed "</span>);</span><br><span class="line">                <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果解码器格式是h264</span></span><br><span class="line">        <span class="keyword">if</span> (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                m_frame_parser.mutils = <span class="keyword">new</span> H264_Utils();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (m_frame_parser.mutils == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"parser utils Allocation failed "</span>);</span><br><span class="line">                    eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    m_frame_parser.mutils-&gt;initialize_frame_checking_environment();</span><br><span class="line">                    m_frame_parser.mutils-&gt;allocate_rbsp_buffer (drv_ctx.ip_buf.buffer_size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//创建一个h264流的解析器</span></span><br><span class="line">            h264_parser = <span class="keyword">new</span> h264_stream_parser();</span><br><span class="line">            <span class="keyword">if</span> (!h264_parser) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"ERROR: H264 parser allocation failed!"</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//打开一个管道，读写端保存进fds数组</span></span><br><span class="line">        <span class="keyword">if</span> (pipe(fds)) &#123;</span><br><span class="line">            DEBUG_PRINT_ERROR(<span class="string">"pipe creation failed"</span>);</span><br><span class="line">            eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp1[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (fds[<span class="number">0</span>] == <span class="number">0</span> || fds[<span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pipe (temp1)) &#123;</span><br><span class="line">                    DEBUG_PRINT_ERROR(<span class="string">"pipe creation failed"</span>);</span><br><span class="line">                    <span class="keyword">return</span> OMX_ErrorInsufficientResources;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//close (fds[0]);</span></span><br><span class="line">                <span class="comment">//close (fds[1]);</span></span><br><span class="line">                fds[<span class="number">0</span>] = temp1 [<span class="number">0</span>];</span><br><span class="line">                fds[<span class="number">1</span>] = temp1 [<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输入/读</span></span><br><span class="line">            m_pipe_in = fds[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//输出/写</span></span><br><span class="line">            m_pipe_out = fds[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//创建一个工作线程，调用omx开始处理解码，并进行i/o操作</span></span><br><span class="line">            r = pthread_create(&amp;msg_thread_id,<span class="number">0</span>,message_thread,<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                DEBUG_PRINT_ERROR(<span class="string">"component_init(): message_thread creation failed"</span>);</span><br><span class="line">                eRet = OMX_ErrorInsufficientResources;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//没有错误，然后收尾</span></span><br><span class="line">    <span class="keyword">if</span> (eRet != OMX_ErrorNone) &#123;</span><br><span class="line">        DEBUG_PRINT_ERROR(<span class="string">"Component Init Failed"</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Calling VDEC_IOCTL_STOP_NEXT_MSG"</span>);</span><br><span class="line">        (<span class="keyword">void</span>)ioctl(drv_ctx.video_driver_fd, VDEC_IOCTL_STOP_NEXT_MSG,</span><br><span class="line">                <span class="literal">NULL</span>);</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"Calling close() on Video Driver"</span>);</span><br><span class="line">        close (drv_ctx.video_driver_fd);</span><br><span class="line">        drv_ctx.video_driver_fd = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        DEBUG_PRINT_HIGH(<span class="string">"omx_vdec::component_init() success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//memset(&amp;h264_mv_buff,0,sizeof(struct h264_mv_buffer));</span></span><br><span class="line">    <span class="keyword">return</span> eRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个是解码组件的初始化实现。我们能够看出和TI的差距挺大的。步骤大概如下（maybe wrong）：</p><p>☯ 打开media相关设备文件<br>☯ 创建一个异步线程，执行async_message_thread函数，对输入端进行设置<br>☯ 根据解码器role名配置相关属性<br>☯ 对视频解码相关基本配置进行设置<br>☯ 创建一个管道，然后再开一个个工作线程，调用omx开始处理解码，并进行i/o操作</p><h4 id="（三）、Android中OpenMax的实现"><a href="#（三）、Android中OpenMax的实现" class="headerlink" title="（三）、Android中OpenMax的实现"></a>（三）、Android中OpenMax的实现</h4><h5 id="3-1、android-MediaCodec-ACodec"><a href="#3-1、android-MediaCodec-ACodec" class="headerlink" title="3.1、android MediaCodec ACodec"></a>3.1、android MediaCodec ACodec</h5><h5 id="3-1-1、MediaCodec"><a href="#3-1-1、MediaCodec" class="headerlink" title="3.1.1、MediaCodec"></a>3.1.1、MediaCodec</h5><p>MediaCodec类可用于访问Android底层的媒体编解码器，例如，编码/解码组件。它是Android为多媒体支持提供的底层接口的一部分（通常与MediaExtractor, MediaSync, MediaMuxer, MediaCrypto, MediaDrm, Image, Surface, 以及AudioTrack一起使用）。<br>从广义上讲，一个编解码器通过处理输入数据来产生输出数据。它通过异步方式处理数据，并且使用了一组输入输出buffers。在简单层面，请求（或接收）到一个空的输入buffer，向里面填满数据并将它传递给编解码器处理。这个编解码器将使用完这些数据并向所有空的输出buffer中的一个填充这些数据。最终，请求（或接受）到一个填充了数据的buffer,可以使用其中的数据内容，并且在使用完后将其释放回编解码器。</p><p>1、    Data Types<br>编解码器处理三种类型的数据：压缩数据，原始音频数据，原始视频数据。上述三种数据都可以通过ByteBuffers进行处理，但需要为原始视频数据提供一个Surface来提高编解码性能。<br>    压缩缓存（Compressed Buffers）：输入缓冲区(解码器)和输出缓冲区(编码器)包含压缩数据格式的类型。<br>    原始音频缓存（Raw Audio Buffers）：原始音频缓冲区包含整个PCM音频帧数据。<br>    原始视频缓存（Raw Video Buffers）：ByteBuffer模式视频缓冲区根据他们的颜色格式布局。视频编解码器可能支持三种类型的色彩格式：1)、native raw video format：被COLOR_FormatSurface标记，其可与输入或输出Surface一起使用；2)、flexible YUV buffers（如COLOR_FormatYUV420Flexible），可以与输入/输出Surface一起使用, ByteBuffer模式下可以通过调用getInput/OutputImage(int)方法进行使用；3)、通常只在ByteBuffer模式下被支持。由供应商指定，可以使用 getInput/OutputImage(int)方法。</p><p>2、States<br>在编解码器的生命周期内有三种理论状态：停止态-Stopped、执行态-Executing、释放态-Released。停止状态（Stopped）包括了三种子状态：未初始化（Uninitialized）、配置（Configured）、错误（Error）。执行状态（Executing）在概念上会经历三种子状态：刷新（Flushed）、运行（Running）、流结束（End-of-Stream）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-10-MediaCodec-states.png" alt="Alt text | center"></p><p>使用工厂方法之一创建一个编解码器的时候，是处于Uninitialized状态。首先，需要通过configure(…)方法配置它，以此进入Configured 状态。然后，通过调用start()方法转入Executing 状态。在这个状态下可以通过上述buffer队列操作过程数据。<br>调用start()方法后立即进入Flushed状态，此时编解码器拥有所有的缓存。一旦第一个输入缓存被移出队列，编解码器就转入运行子状态，这种状态占据了编解码器的大部分生命周期。当将一个带有end-of-stream marker标记的输入缓存入队列时，编解码器将转入流结束子状态。可在Executing状态的任何时候通过调用flush()。<br>调用stop()方法返回编解码器的Uninitialized 状态，因此这个编解码器需要再次configured 。当使用完编解码器后，必须调用release()方法释放其资源。</p><p>3、Data Processing<br>每一个编解码器包含一组输入和输出缓存，这些缓存在API调用中通过buffer-ID进行引用。当成功调用start()方法后客户端将不会拥有输入或输出buffers。在同步模式下，通过调用dequeueInput/OutputBuffer(…) 方法从编解码器获得一个输入或输出buffer；在异步模式下，可以通过MediaCodec.Callback.onInput/OutputBufferAvailable(…)的回调方法自动地获得可用的buffers。<br>在获得一个输入buffe后，填充数据，利用queueInputBuffer/queueSecureInputBuffer方法将其提交给编解码器，不要提交多个具有相同时间戳的输入bufers（除非它是也被同样标记的codec-specific data，因为codec-specific data缓冲的时间戳无意义）。<br>a.    Asynchronous Processing using Buffers<br>    从Android 5.0开始，首选的方法是调用configure之前通过设置回调异步地处理数据。异步模式稍微改变了状态转换方式，因为必须在调用flush()方法后再调用start()方法才能使编解码器的状态转换为Running子状态并开始接收输入buffers。同样，初始调用start方法将编解码器的状态直接变化为Running 子状态并通过回调方法开始传递可用的输入buufers。<br>b.    Synchronous Processing using Buffers<br>从Android 5.0开始，即使在同步模式下使用编解码器，也应该通过getInput/OutputBuffer(int) 和/或 getInput/OutputImage(int) 方法检索输入和输出buffers。</p><h5 id="3-1-2、ACodec"><a href="#3-1-2、ACodec" class="headerlink" title="3.1.2、ACodec"></a>3.1.2、ACodec</h5><p>1、ACodec消息机制：<br>    ACodec有一个BaseState和派生出来的其他State，如 UninitializedState, LoadedToIdleState, ExecutingState等。当有消息过来时，如果派生类有重写的方法，则会调到重写的方法，如果没有，则会调到BaseState的<br>    ACodec继承自AHierarchicalStateMachine类，该类用于将收到的消息传递给哪个state。<br>    ACodec收到的消息分两种，一种是MediaCodec传过来的，对应onMessageReceived方法；另一种是OMX Component传过来的，对应onOMXMessage方法。而onOMXMessage里面又分了4种情况来调用不同的方法。（EVENT、EMPTY_BUFFER_DONE、FILL_BUFFER_DONE和FRAME_RENDERED）</p><p>2、MediaCodec与ACodec的通知：<br>    OMX的组件解码之后，ACodec::BaseState:: onOMXFillBufferDone (…)会被回调，去取得解码后的数据。然后会在onOMXFillBufferDone中调用notify通知MediaCodec，发给MediaCodec的消息形如notify-&gt;setInt32(“what”, CodecBase::kWhatDrainThisBuffer);<br>    MediaCodec收到ACodec发的消息之后会updateBuffers(kPortIndexOutput, msg) 进行更新，同时调用onOutputBufferAvailable()中通知NuPlayer::Decoder有可用的output buffer。</p><p>3、ACodec有三种端口模式状态，其会根据当前处于哪个状态来决定buffer如何处理：<br>    KEEP_BUFFERS：当ACodec处于BaseState或者收到OnInputBufferFilled消息但是buffer里面没有填充有效的数据时，ACodec握有的buffer不会送到OMX 组件；<br>    RESUBMIT_BUFFERS：当ACodec处于ExecutingState或者处于OutputPortSettingChangedState但是当前是input口的buffer时，ACodec将握有的buffer送给OMX 组件；<br>    FREE_BUFFERS：当ACodec处于OutputPortSettingChangedState并且当前是output口的buffer时，ACodec将握有的buffer free。</p><p>4、stagefright类的调用关系：<br>    OMXNodeInstance负责创建并维护不同的实例，这些实例以node作为唯一标识。这样播放器中每个ACodec在OMX服务端都对应有了自己的OMXNodeInstance实例。<br>    OMXMaster用来维护底层软硬件解码库，根据OMXNodeInstance中想要的解码器来创建解码实体组件。<br>    OMXPluginBase负责加载组件库，创建组件实例，由OMXMaster管理。Android原生提供的组件都是由SoftOMXPlugin类来管理，这个类就是继承自OMXPluginBase。（Android源码提供了一些软件解码和编码的组件，它们被抽象为SoftOMXComponent）<br>    OMXClient是客户端用来与OMX IL进行通信的。<br>    内部结构CallbackDispatcher作用是用来接收回调函数的消息<br>    OMXNodeInstance + CallbackDispatcher = 合作完成不同实例的消息处理任务</p><p>5、ACodec同OMXNodeInstance的消息传递：<br>    ACodec将CodecObserver observer对象通过omx-&gt;allocateNode()传递到OMXNodeInstance。<br>    OMXNodeInstance将kCallbacks(OnEvent,OnEmptyBufferDone,OnFillBufferDone)传递给OMX Component<br>    当OMX Component有消息notify上来时，OMXNodeInstance最先收到，然后调用OMX.cpp。将消息在OMX.cpp里面将OMX Component thread转换到CallbackDispatcher线程中处理。CallbackDispatcher又将消息反调到OMXNodeInstance. 最后调用CodecObserver 的onMessage()回到ACodec中</p><p>6、    ACodec与OMX组件的关系<br>    ACodec ，CodecObserver和OMXNodeInstance是一一对应的，简单的可以理解它们3个构成了OpenMAX IL的一个Component，每一个node就是一个codec在OMX服务端的标识。当然还有CallbackDispatcher，用于处理codec过来的消息，通过它的post/loop/dispatch来发起接收，从OMX.cpp发送消息，最终通过OMXNodeInstance::onMessage -&gt; CodecObserver::onMessage -&gt; ACodec::onMessage一路往上，当然消息的来源是因为我们有向codec注册OMXNodeInstance::kCallbacks。<br>    而在OMXPluginBase创建组件实例的时候，需要传递一个callback给组件，这个callback用于接收组件的消息，它的实现是在OMXNodeInstance.cpp中。而kcallbacks是OMXNodeInstance的静态成员变量，它内部的三个函数指针分别指向了OMXNodeInstance的三个静态方法，也即是这三个方法与组件进行着消息传递</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-11-OMX-allocateNode.png" alt="Alt text | center"></p><p>    对于NuPlayer来说，它并不直接接触解码组件，而是通过创建ACodec来和组件交互。ACode内部有一个id，这个id对应于一个OMXNodeInstance。OMX对象中会对产生的每一个OMXNodeInstance分配一个唯一的node_id。每一个OMXNodeInstance内部又保存着组件实例的指针【OMX_HANDLETYPE mHandle;】，通过这个指针就可以和组件进行交互。交互的流程为：ACodec → OMX → OMXNodeInstance → COMPONENT。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-12-NuPlayer-libstagefrighthw.png" alt="Alt text | center"></p><p>8、组件的管理<br>    对组件的管理可以总结为：通过OMXMaster加载libstagefrighthw.so库文件，创建OMXPluginBase【即创建继承此类的组件对象】，通过这个类来管理组件。<br>    Android源码提供了一些软件解码和编码的组件，它们被抽象为SoftOMXComponent。OMXPluginBase扮演者组件的管理者。它负责加载组件库，创建组件实例。而OMXMaster则管理着OMXPluginBase，Android原生提供的组件都是由SoftOMXPlugin类来管理，这个类就是继承自OMXPluginBase。<br>    对于厂商来说，如果要实现自己的组件管理模块，需要通过继承实现OMXPluginBase，并将之编译为libstagefrighthw.so。在OMXMaster中会加载这个库文件，然后调用其createOMXPlugin方法获得一个OMXPluginBase指针，然后将其加入OMXPluginBase列表以及与组件名相关的map 【mPluginByComponentName】中，后续都会通过OMXPluginBase来管理组件。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-04-13-OMXMaster-addPlugin.png" alt="Alt text | center"></p><h5 id="3-2、音视频解码数据处理"><a href="#3-2、音视频解码数据处理" class="headerlink" title="3.2、音视频解码数据处理"></a>3.2、音视频解码数据处理</h5><p>数据处理请参考： <a href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#%EF%BC%88%E4%B8%89%EF%BC%89%E3%80%81%E9%9F%B3%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86">音视频解码数据处理</a></p><h5 id="3-3、高通实现（参考高通文档）"><a href="#3-3、高通实现（参考高通文档）" class="headerlink" title="3.3、高通实现（参考高通文档）"></a>3.3、高通实现（参考高通文档）</h5><p><a href="https://createpoint.qti.qualcomm.com" target="_blank" rel="noopener">OpenMAX Integration Layer Video Encoder for Linux Android（高通文档）</a><br><a href="https://createpoint.qti.qualcomm.com" target="_blank" rel="noopener">OpenMAX Integration Layer Video Decoder for Linux Android（高通文档）</a></p><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://windrunnerlihuan.com/2016/12/15/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%BA%94-OpenMax%E7%AE%80%E4%BB%8B/" target="_blank" rel="noopener">Android多媒体开发(五)—-OpenMax简介</a><br><a href="http://windrunnerlihuan.com/2016/12/26/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E5%85%AD-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0-preview/" target="_blank" rel="noopener">Android多媒体开发(六)—-Android中OpenMax的实现(preview)</a><br><a href="http://windrunnerlihuan.com/2016/12/29/Android%E5%A4%9A%E5%AA%92%E4%BD%93%E5%BC%80%E5%8F%91-%E4%B8%83-Android%E4%B8%ADOpenMax%E7%9A%84%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">Android多媒体开发(七)—-Android中OpenMax的实现</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料 Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（5）：Android Display System 系统分析之Display Driver Architecture</title>
    <link href="http://zhoujinjian.cc/2018/08/30/Android%20Display%20System%EF%BC%885%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BDisplay%20Driver%20Architecture/"/>
    <id>http://zhoujinjian.cc/2018/08/30/Android Display System（5）：Android Display System 系统分析之Display Driver Architecture/</id>
    <published>2018-08-29T16:00:00.000Z</published>
    <updated>2018-06-20T15:15:33.034Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/eliot_shao/article/details/74926010" target="_blank" rel="noopener">【特别感谢 - 高通Android平台-应用空间操作framebuffer dump LCD总结】</a><br><a href="https://blog.csdn.net/u012719256/article/details/52096727" target="_blank" rel="noopener">【特别感谢 -  linux qcom LCD framwork】</a><br><a href="https://blog.csdn.net/ic_soc_arm_robin/article/details/12949347" target="_blank" rel="noopener">【特别感谢 -  msm8610 lcd driver code analysis】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】 </p><hr><p>路径：<br>kernel\msm-3.18\drivers\video\msm\mdss</p><p> MDSS driver software block diagram</p><ul><li>mdss_fb → Top-level IOCTL/native framebufferinterface</li><li>mdss_mdp.c → MDP resources(clocks/irq/bus-bw/power)</li><li>mdss_mdp_overlay → Overlay/DMA top-levelAPI</li><li>mdss_mdp_ctl → Controls the hardware abstraction to club the (LM + DSPP + Ping-pong +<br>interface)</li><li>mdss_mdp_pipe → SRC pipe related handling</li><li>mdss_mdp_intf_cmd/mdss_mdp_intf_video/mdss_mdp_intf_writeback → MDP panel<br>interface relatedhandling</li><li>mdss_mdp_pp → Postprocessing related implementation</li><li>mdss_mdp_rotator → Rotator APIs (overlay_set/overlay_playinterface)</li><li>mdss_mdp_pp.c → Postprocessing relatedmaterial</li></ul><hr><p><strong>注：</strong>首先说明，由于博主不是kernel开发方向的，可能理解不够透彻，还请看官见谅，主要是为了理解Kernel Display原理。为了加深对显示屏工作原理的理解，首先先看两个操作LCD显示屏的例子<br>绪论（总体架构图）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-01-Display-Architecture.png" alt="Alt text | center"></p><h4 id="（一）、直接操作framebuffer显示图像"><a href="#（一）、直接操作framebuffer显示图像" class="headerlink" title="（一）、直接操作framebuffer显示图像"></a>（一）、直接操作framebuffer显示图像</h4><h5 id="1-1、直接操作framebuffer显示图像"><a href="#1-1、直接操作framebuffer显示图像" class="headerlink" title="1.1、直接操作framebuffer显示图像"></a>1.1、直接操作framebuffer显示图像</h5><h5 id="1-1-1、源代码"><a href="#1-1-1、源代码" class="headerlink" title="1.1.1、源代码"></a>1.1.1、源代码</h5><p><strong>panel_test.c</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/fb.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"yellow_face.zif"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> fbfd = <span class="number">0</span>;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">vinfo</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmapinfo</span>;</span>  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> screensize = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">char</span> *fbp = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> location = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> b,g,r;  </span><br><span class="line">    <span class="comment">// Open the file for reading and writing  </span></span><br><span class="line">    fbfd = open(<span class="string">"/dev/graphics/fb0"</span>, O_RDWR,<span class="number">0</span>);                    <span class="comment">// 打开Frame Buffer设备  </span></span><br><span class="line">    <span class="keyword">if</span> (fbfd &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error: cannot open framebuffer device.%x\n"</span>,fbfd);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The framebuffer device was opened successfully.\n"</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Get fixed screen information  </span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fbfd, FBIOGET_FSCREENINFO, &amp;finfo)) &#123;            <span class="comment">// 获取设备固有信息  </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error reading fixed information.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">2</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntype:0x%x\n"</span>, finfo.type );                            <span class="comment">// FrameBuffer 类型,如0为象素  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"visual:%d\n"</span>, finfo.visual );                        <span class="comment">// 视觉类型：如真彩2，伪彩3   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"line_length:%d\n"</span>, finfo.line_length );        <span class="comment">// 每行长度  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\nsmem_start:0x%lx,smem_len:%u\n"</span>, finfo.smem_start, finfo.smem_len ); <span class="comment">// 映象RAM的参数  </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mmio_start:0x%lx ,mmio_len:%u\n"</span>, finfo.mmio_start, finfo.mmio_len );  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Get variable screen information  </span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fbfd, FBIOGET_VSCREENINFO, &amp;vinfo)) &#123;            <span class="comment">// 获取设备可变信息  </span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error reading variable information.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">3</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%dx%d, %dbpp,xres_virtual=%d,yres_virtual=%dvinfo.xoffset=%d,vinfo.yoffset=%d\n"</span>, vinfo.xres, vinfo.yres, vinfo.bits_per_pixel,vinfo.xres_virtual,vinfo.yres_virtual,vinfo.xoffset,vinfo.yoffset);  </span><br><span class="line"></span><br><span class="line">screensize = finfo.line_length * vinfo.yres_virtual;</span><br><span class="line">    <span class="comment">// Map the device to memory 通过mmap系统调用将framebuffer内存映射到用户空间,并返回映射后的起始地址  </span></span><br><span class="line">    fbp = (<span class="keyword">char</span> *)mmap(<span class="number">0</span>, screensize, PROT_READ | PROT_WRITE, MAP_SHARED,fbfd, <span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)fbp == <span class="number">-1</span>) &#123;  </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error: failed to map framebuffer device to memory.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">4</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"The framebuffer device was mapped to memory successfully.\n"</span>);  </span><br><span class="line"><span class="comment">/***************exampel 1**********************/</span></span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">g = <span class="number">100</span>;</span><br><span class="line">r = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">for</span> ( y = <span class="number">0</span>; y &lt; <span class="number">340</span>; y++ )</span><br><span class="line">        <span class="keyword">for</span> ( x = <span class="number">0</span>; x &lt; <span class="number">420</span>; x++ ) &#123; </span><br><span class="line">      </span><br><span class="line">         location = (x+<span class="number">100</span>) * (vinfo.bits_per_pixel/<span class="number">8</span>) + </span><br><span class="line">             (y+<span class="number">100</span>) * finfo.line_length; </span><br><span class="line">      </span><br><span class="line">         <span class="keyword">if</span> ( vinfo.bits_per_pixel == <span class="number">32</span> ) &#123;        <span class="comment">//          </span></span><br><span class="line">                        *(fbp + location) = b; <span class="comment">// Some blue  </span></span><br><span class="line">                        *(fbp + location + <span class="number">1</span>) = g;             <span class="comment">// A little green  </span></span><br><span class="line">                        *(fbp + location + <span class="number">2</span>) = r;             <span class="comment">// A lot of red  </span></span><br><span class="line">                        *(fbp + location + <span class="number">3</span>) = <span class="number">0</span>;     <span class="comment">// No transparency  </span></span><br><span class="line">         &#125;</span><br><span class="line">      </span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/*****************exampel 1********************/</span></span><br><span class="line"><span class="comment">/*****************exampel 2********************/</span></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">char</span> *pTemp = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)fbp;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="comment">//起始坐标(x,y),终点坐标(right,bottom)</span></span><br><span class="line">x = <span class="number">400</span>;</span><br><span class="line">y = <span class="number">400</span>;</span><br><span class="line"><span class="keyword">int</span> right = <span class="number">700</span>;<span class="comment">//vinfo.xres;</span></span><br><span class="line"><span class="keyword">int</span> bottom = <span class="number">1000</span>;<span class="comment">//vinfo.yres;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=y; i&lt; bottom; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=x; j&lt;right; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> data = yellow_face_data[(((i-y)  % <span class="number">128</span>) * <span class="number">128</span>) + ((j-x) %<span class="number">128</span>)];</span><br><span class="line">pTemp[i*finfo.line_length + (j*<span class="number">4</span>) + <span class="number">2</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((data &amp; <span class="number">0xF800</span>) &gt;&gt; <span class="number">11</span> &lt;&lt; <span class="number">3</span>);</span><br><span class="line">pTemp[i*finfo.line_length + (j*<span class="number">4</span>) + <span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((data &amp; <span class="number">0x7E0</span>) &gt;&gt; <span class="number">5</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">pTemp[i*finfo.line_length + (j*<span class="number">4</span>) + <span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">char</span>)((data &amp; <span class="number">0x1F</span>) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/*****************exampel 2********************/</span></span><br><span class="line"><span class="comment">//note：vinfo.xoffset =0 vinfo.yoffset =0 否则FBIOPAN_DISPLAY不成功</span></span><br><span class="line"><span class="keyword">if</span> (ioctl(fbfd, FBIOPAN_DISPLAY, &amp;vinfo)) &#123;    </span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Error FBIOPAN_DISPLAY information.\n"</span>);  </span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">5</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">sleep(<span class="number">10</span>);</span><br><span class="line">munmap(fbp,finfo.smem_len);<span class="comment">//finfo.smem_len == screensize == finfo.line_length * vinfo.yres_virtual </span></span><br><span class="line">    close(fbfd);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Android.mk</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Copyright 2006-2014 The Android Open Source Project</span><br><span class="line"></span><br><span class="line">LOCAL_PATH:= $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line"></span><br><span class="line">LOCAL_SRC_FILES:= panel_test.c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES        := $(common_libs) libqdutils libdl liblog libbase libcutils</span><br><span class="line">LOCAL_C_INCLUDES              := $(common_includes) $(kernel_includes)</span><br><span class="line">LOCAL_ADDITIONAL_DEPENDENCIES := $(common_deps) $(kernel_deps)</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := panel_test</span><br><span class="line"></span><br><span class="line">LOCAL_CFLAGS := -Werror</span><br><span class="line"></span><br><span class="line">include $(BUILD_EXECUTABLE)</span><br><span class="line"></span><br><span class="line">include $(call first-makefiles-under,$(LOCAL_PATH))</span><br></pre></td></tr></table></figure><p><strong>yellow_face.zif</strong><br><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-yellow_face.zif" target="_blank" rel="noopener">yellow_face.zif</a></p><h5 id="1-1-2、编译测试"><a href="#1-1-2、编译测试" class="headerlink" title="1.1.2、编译测试"></a>1.1.2、编译测试</h5><p>编译会生成panel_test，然后进行测试。</p><blockquote><p>注意事项：<br>1、adb shell stop 杀掉surfaceflinger 之后在测试；<br>2、设置背光 echo 255 &gt; /sys/class/leds/lcd-backlight/brightness</p><p>1、连接adb<br>2、adb push panel_test system/bin<br>3、进入adb shell<br>4、stop<br>5、echo 255 &gt; /sys/class/leds/lcd-backlight/brightness<br>6、system/bin/panel_test</p></blockquote><h5 id="1-1-3、显示效果"><a href="#1-1-3、显示效果" class="headerlink" title="1.1.3、显示效果"></a>1.1.3、显示效果</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-02-Qcom_FrameBuffer_test_.gif" alt="Alt text | center"></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-03-yellow_face_zif_test.jpg" alt="Alt text | center"></p><h5 id="1-1-4、视频（加深理解、自☯备☯梯☯子）"><a href="#1-1-4、视频（加深理解、自☯备☯梯☯子）" class="headerlink" title="1.1.4、视频（加深理解、自☯备☯梯☯子）"></a>1.1.4、视频（加深理解、自☯备☯梯☯子）</h5><p><a href="https://www.youtube.com/watch?v=BUPPyR6VasI" target="_blank" rel="noopener">Android Frame Buffer and Screen Shots Tutorial</a><br><a href="https://www.youtube.com/watch?v=7n_hDZ6kHjc" target="_blank" rel="noopener">Mplayer on Android Through Chroot and Frame Buffer</a></p><h5 id="1-1-5、驱动总体概览图"><a href="#1-1-5、驱动总体概览图" class="headerlink" title="1.1.5、驱动总体概览图"></a>1.1.5、驱动总体概览图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-04-msm8x25-display-overview.png" alt="Alt text | center"></p><h4 id="（二）、FrameBuffer驱动程序分析"><a href="#（二）、FrameBuffer驱动程序分析" class="headerlink" title="（二）、FrameBuffer驱动程序分析"></a>（二）、FrameBuffer驱动程序分析</h4><p>FrameBuffer通常作为LCD控制器或者其他显示设备的驱动，FrameBuffer驱动是一个字符设备，设备节点是/dev/fbX（Android 设备为/dev/graphics/fb0），主设备号为29，次设备号递增，用户可以将Framebuffer看成是显示内存的一个映像，将其映射到进程地址空间之后，就可以直接进行读写操作，而写操作可以立即反应在屏幕上。这种操作是抽象的，统一的。用户不必关心物理显存的位置、换页机制等等具体细节。这些都是由Framebuffer设备驱动来完成的。Framebuffer设备为上层应用程序提供系统调用，也为下一层的特定硬件驱动提供接口；那些底层硬件驱动需要用到这儿的接口来向系统内核注册它们自己。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-05-mdss-driver-architecture.png" alt="Alt text | center"></p><p>Linux中的PCI设备可以将其控制寄存器映射到物理内存空间，而后，对这些控制寄存器的访问变成了对理内存的访问，因此，这些寄存器又被称为”memio”。一旦被映射到物理内存，Linux的普通进程就可以通过mmap将这些内存I/O映射到进程地址空间，这样就可以直接访问这些寄存器了。</p><p>FrameBuffer设备属于字符设备，采用了文件层—驱动层的接口方式，Linux为帧缓冲设备定义了驱动层的接口fb_info结构，在文件层上，用户调用file_operations的函数操作，间接调用fb_info中的fb_ops函数集来操作硬件。</p><h5 id="2-1、-Framebuffer数据结构"><a href="#2-1、-Framebuffer数据结构" class="headerlink" title="2.1、 Framebuffer数据结构"></a>2.1、 Framebuffer数据结构</h5><h5 id="2-1-1、-fb-info"><a href="#2-1-1、-fb-info" class="headerlink" title="2.1.1、 fb_info"></a>2.1.1、 fb_info</h5><p>fb_info是Linux为帧缓冲设备定义的驱动层接口。它不仅包含了底层函数，而且还有记录设备状态的数据。每个帧缓冲设备都与一个fb_info结构相对应。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;kernel\include\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span> count;</span><br><span class="line"><span class="keyword">int</span> node;</span><br><span class="line"><span class="keyword">int</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span><span class="comment">/* Lock for open/release/ioctl funcs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mm_lock</span>;</span><span class="comment">/* Lock for fb_mmap and smem_* fields */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">var</span>;</span><span class="comment">/* Current var */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">fix</span>;</span><span class="comment">/* Current fix */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_monspecs</span> <span class="title">monspecs</span>;</span><span class="comment">/* Current Monitor specs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">queue</span>;</span><span class="comment">/* Framebuffer event queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">pixmap</span>;</span><span class="comment">/* Image hardware mapper */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_pixmap</span> <span class="title">sprite</span>;</span><span class="comment">/* Cursor hardware mapper */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_cmap</span> <span class="title">cmap</span>;</span><span class="comment">/* Current cmap */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">modelist</span>;</span>      <span class="comment">/* mode list */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> *<span class="title">mode</span>;</span><span class="comment">/* current mode */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span><span class="comment">/* current file node */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FB_DEFERRED_IO</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> <span class="title">deferred_work</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_deferred_io</span> *<span class="title">fbdefio</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> *<span class="title">fbops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">device</span>;</span><span class="comment">/* This is the parent */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span><span class="comment">/* This is this fb device */</span></span><br><span class="line"><span class="keyword">int</span> class_flag;                    <span class="comment">/* private sysfs flags */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FB_TILEBLITTING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_tile_ops</span> *<span class="title">tileops</span>;</span>    <span class="comment">/* Tile Blitting */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">char</span> __iomem *screen_base;<span class="comment">/* Virtual address */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> screen_size;<span class="comment">/* Amount of ioremapped VRAM or 0 */</span> </span><br><span class="line"><span class="keyword">void</span> *pseudo_palette;<span class="comment">/* Fake palette of 16 colors */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FBINFO_STATE_RUNNING0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FBINFO_STATE_SUSPENDED1</span></span><br><span class="line">u32 state;<span class="comment">/* Hardware state i.e suspend */</span></span><br><span class="line"><span class="keyword">void</span> *fbcon_par;                <span class="comment">/* fbcon use-only private area */</span></span><br><span class="line"><span class="comment">/* From here on everything is device dependent */</span></span><br><span class="line"><span class="keyword">void</span> *par;</span><br><span class="line"><span class="comment">/* we need the PCI or similar aperture base/size not</span></span><br><span class="line"><span class="comment">   smem_start/size as smem_start may just be an object</span></span><br><span class="line"><span class="comment">   allocated inside the aperture so may not actually overlap */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">apertures_struct</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aperture</span> &#123;</span></span><br><span class="line"><span class="keyword">resource_size_t</span> base;</span><br><span class="line"><span class="keyword">resource_size_t</span> size;</span><br><span class="line">&#125; ranges[<span class="number">0</span>];</span><br><span class="line">&#125; *apertures;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> skip_vt_switch; <span class="comment">/* no VT switch on suspend/resume required */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-1-2、fb-var-screeninfo"><a href="#2-1-2、fb-var-screeninfo" class="headerlink" title="2.1.2、fb_var_screeninfo"></a>2.1.2、fb_var_screeninfo</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-06-xres-yres.png" alt="Alt text | center"></p><p>fb_var_screeninfo：用于记录用户可修改的显示控制器参数，包括屏幕分辨率、每个像素点的比特数等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\include\uapi\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> &#123;</span>  </span><br><span class="line">    __u32 xres;         <span class="comment">/* 行可见像素*/</span>  </span><br><span class="line">    __u32 yres;         <span class="comment">/* 列可见像素*/</span>  </span><br><span class="line">    __u32 xres_virtual; <span class="comment">/* 行虚拟像素*/</span>  </span><br><span class="line">    __u32 yres_virtual; <span class="comment">/* 列虚拟像素*/</span>  </span><br><span class="line">    __u32 xoffset;      <span class="comment">/* 水平偏移量*/</span>  </span><br><span class="line">    __u32 yoffset;      <span class="comment">/* 垂直偏移量*/</span>  </span><br><span class="line">    __u32 bits_per_pixel;<span class="comment">/*每个像素所占bit位数*/</span>  </span><br><span class="line">    __u32 grayscale;    <span class="comment">/* 灰色刻度*/</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">red</span>;</span> <span class="comment">/* bitfield in fb mem if true color, */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">green</span>;</span>   <span class="comment">/* else only length is significant */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">blue</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_bitfield</span> <span class="title">transp</span>;</span>  <span class="comment">/* transparency         */</span>    </span><br><span class="line">    __u32 nonstd;           <span class="comment">/* != 0 Non standard pixel format */</span>  </span><br><span class="line">    __u32 activate;         <span class="comment">/* see FB_ACTIVATE_*        */</span>  </span><br><span class="line">    __u32 height;           <span class="comment">/* 图像高度*/</span>  </span><br><span class="line">    __u32 width;            <span class="comment">/* 图像宽度*/</span>  </span><br><span class="line">    __u32 accel_flags;      <span class="comment">/* (OBSOLETE) see fb_info.flags */</span>  </span><br><span class="line">    __u32 pixclock;         <span class="comment">/* pixel clock in ps (pico seconds) */</span>  </span><br><span class="line">    __u32 left_margin;      <span class="comment">/* time from sync to picture    */</span>  </span><br><span class="line">    __u32 right_margin;     <span class="comment">/* time from picture to sync    */</span>  </span><br><span class="line">    __u32 upper_margin;     <span class="comment">/* time from sync to picture    */</span>  </span><br><span class="line">    __u32 lower_margin;  </span><br><span class="line">    __u32 hsync_len;        <span class="comment">/* length of horizontal sync    */</span>  </span><br><span class="line">    __u32 vsync_len;        <span class="comment">/* length of vertical sync  */</span>  </span><br><span class="line">    __u32 sync;         <span class="comment">/* see FB_SYNC_*        */</span>  </span><br><span class="line">    __u32 vmode;            <span class="comment">/* see FB_VMODE_*       */</span>  </span><br><span class="line">    __u32 rotate;           <span class="comment">/* angle we rotate counter clockwise */</span>  </span><br><span class="line">    __u32 reserved[<span class="number">5</span>];      <span class="comment">/* Reserved for future compatibility */</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-1-3、fb-fix-screeninfo"><a href="#2-1-3、fb-fix-screeninfo" class="headerlink" title="2.1.3、fb_fix_screeninfo"></a>2.1.3、fb_fix_screeninfo</h5><p>fb_fix_screeninfo：记录了用户不能修改的显示控制器的参数，这些参数是在驱动初始化时设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\include\uapi\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> id[<span class="number">16</span>];<span class="comment">/* identification string eg "TT Builtin" */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> smem_start;<span class="comment">/* Start of frame buffer mem */</span></span><br><span class="line"><span class="comment">/* (physical address) */</span></span><br><span class="line">__u32 smem_len;<span class="comment">/* Length of frame buffer mem */</span></span><br><span class="line">__u32 type;<span class="comment">/* see FB_TYPE_**/</span></span><br><span class="line">__u32 type_aux;<span class="comment">/* Interleave for interleaved Planes */</span></span><br><span class="line">__u32 visual;<span class="comment">/* see FB_VISUAL_**/</span> </span><br><span class="line">__u16 xpanstep;<span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">__u16 ypanstep;<span class="comment">/* zero if no hardware panning  */</span></span><br><span class="line">__u16 ywrapstep;<span class="comment">/* zero if no hardware ywrap    */</span></span><br><span class="line">__u32 line_length;<span class="comment">/* length of a line in bytes    */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mmio_start;<span class="comment">/* Start of Memory Mapped I/O   */</span></span><br><span class="line"><span class="comment">/* (physical address) */</span></span><br><span class="line">__u32 mmio_len;<span class="comment">/* Length of Memory Mapped I/O  */</span></span><br><span class="line">__u32 accel;<span class="comment">/* Indicate to driver which*/</span></span><br><span class="line"><span class="comment">/*  specific chip/card we have*/</span></span><br><span class="line">__u16 capabilities;<span class="comment">/* see FB_CAP_**/</span></span><br><span class="line">__u16 reserved[<span class="number">2</span>];<span class="comment">/* Reserved for future compatibility */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>fb_ops是提供给底层设备驱动的一个接口。当我们编写一个FrameBuffer的时候，就要依照Linux FrameBuffer编程的套路，填写fb_ops结构体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\include\linux\fb.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/* open/release and usage marking */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="keyword">int</span> (*fb_open)(struct fb_info *info, <span class="keyword">int</span> user);</span><br><span class="line"><span class="keyword">int</span> (*fb_release)(struct fb_info *info, <span class="keyword">int</span> user);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* For framebuffers with strange non linear layouts or that do not</span></span><br><span class="line"><span class="comment"> * work with normal memory mapped access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">ssize_t</span> (*fb_read)(struct fb_info *info, <span class="keyword">char</span> __user *buf,</span><br><span class="line">   <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos);</span><br><span class="line"><span class="keyword">ssize_t</span> (*fb_write)(struct fb_info *info, <span class="keyword">const</span> <span class="keyword">char</span> __user *buf,</span><br><span class="line">    <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* checks var and eventually tweaks it to something supported,</span></span><br><span class="line"><span class="comment"> * DO NOT MODIFY PAR */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the video mode according to info-&gt;var */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_set_par)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set color register */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_setcolreg)(<span class="keyword">unsigned</span> regno, <span class="keyword">unsigned</span> red, <span class="keyword">unsigned</span> green,</span><br><span class="line">    <span class="keyword">unsigned</span> blue, <span class="keyword">unsigned</span> transp, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set color registers in batch */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* blank display */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_blank)(<span class="keyword">int</span> blank, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pan display */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Draws a rectangle */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_fillrect) (struct fb_info *info, <span class="keyword">const</span> struct fb_fillrect *rect);</span><br><span class="line"><span class="comment">/* Copy data from area to another */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_copyarea) (struct fb_info *info, <span class="keyword">const</span> struct fb_copyarea *region);</span><br><span class="line"><span class="comment">/* Draws a image to the display */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_imageblit) (struct fb_info *info, <span class="keyword">const</span> struct fb_image *image);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Draws cursor */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Rotates the display */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_rotate)(struct fb_info *info, <span class="keyword">int</span> angle);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* wait for blit idle, optional */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_sync)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform fb specific ioctl (optional) */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_ioctl)(struct fb_info *info, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform fb specific ioctl v2 (optional) - provides file param */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_ioctl_v2)(struct fb_info *info, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg, struct file *file);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle 32bit compat ioctl (optional) */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_compat_ioctl)(struct fb_info *info, <span class="keyword">unsigned</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Handle 32bit compat ioctl (optional) */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_compat_ioctl_v2)(struct fb_info *info, <span class="keyword">unsigned</span> cmd,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> arg, struct file *file);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* perform fb specific mmap */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get capability given var */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps,</span><br><span class="line">    struct fb_var_screeninfo *var);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* teardown any resources to do with this framebuffer */</span></span><br><span class="line"><span class="keyword">void</span> (*fb_destroy)(struct fb_info *info);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* called at KDB enter and leave time to prepare the console */</span></span><br><span class="line"><span class="keyword">int</span> (*fb_debug_enter)(struct fb_info *info);</span><br><span class="line"><span class="keyword">int</span> (*fb_debug_leave)(struct fb_info *info);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-2、Framebuffer驱动注册过程"><a href="#2-2、Framebuffer驱动注册过程" class="headerlink" title="2.2、Framebuffer驱动注册过程"></a>2.2、Framebuffer驱动注册过程</h5><p>在系统启动时，内核调用所有注册驱动程序的驱动程序初始化函数。 为了帧缓冲区驱动程序，调用mdss_fb_init。 mdss_fb_init注册mdss_fb_driver。驱动在mdss_fb.c文件中注册。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-\drivers\video\msm\mdss\mdss_fb.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mdss_fb_driver</span> = &#123;</span></span><br><span class="line">.probe = mdss_fb_probe,</span><br><span class="line">.remove = mdss_fb_remove,</span><br><span class="line">.suspend = mdss_fb_suspend,</span><br><span class="line">.resume = mdss_fb_resume,</span><br><span class="line">.shutdown = mdss_fb_shutdown,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"mdss_fb"</span>,</span><br><span class="line">.of_match_table = mdss_fb_dt_match,</span><br><span class="line">.pm = &amp;mdss_fb_pm_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在调用init之后，内核调用每个平台驱动程序的探测函数。 在调用mdss_fb_probe时，函数执行资源分配并调用mdss_fb_register。 可以有多个帧缓冲区（fb）设备（节点）。 该驱动程序通过调用mdss_fb_register来注册各个fb设备，后者又调用register_framebuffer。 HDMI和主显示器是各个fb设备的例子。 以下操作已注册：</p><p>首先看一下mdss_fb_probe()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdss_fb.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdss_fb_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_fb_data_type</span> *<span class="title">mfd</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdss_panel_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fbi</span>;</span></span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"></span><br><span class="line">pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * alloc framebuffer info + par data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fbi = framebuffer_alloc(<span class="keyword">sizeof</span>(struct msm_fb_data_type), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">mfd = (struct msm_fb_data_type *)fbi-&gt;par;</span><br><span class="line">mfd-&gt;key = MFD_KEY;</span><br><span class="line">mfd-&gt;fbi = fbi;</span><br><span class="line">mfd-&gt;panel_info = &amp;pdata-&gt;panel_info;</span><br><span class="line">mfd-&gt;panel.type = pdata-&gt;panel_info.type;</span><br><span class="line">mfd-&gt;panel.id = mfd-&gt;index;</span><br><span class="line">mfd-&gt;fb_page = MDSS_FB_NUM;</span><br><span class="line">mfd-&gt;index = fbi_list_index;</span><br><span class="line">mfd-&gt;mdp_fb_page_protection = MDP_FB_PAGE_PROTECTION_WRITECOMBINE;</span><br><span class="line"></span><br><span class="line">mfd-&gt;ext_ad_ctrl = <span class="number">-1</span>;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">platform_set_drvdata(pdev, mfd);</span><br><span class="line"></span><br><span class="line">rc = mdss_fb_register(mfd);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用framebuffer_alloc()函数返回一个fb_info 结构体，然后调用mdss_fb_register(mfd)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdss_fb.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdss_fb_register</span><span class="params">(struct msm_fb_data_type *mfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = -ENODEV;</span><br><span class="line"><span class="keyword">int</span> bpp;</span><br><span class="line"><span class="keyword">char</span> panel_name[<span class="number">20</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdss_panel_info</span> *<span class="title">panel_info</span> = <span class="title">mfd</span>-&gt;<span class="title">panel_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_info</span> *<span class="title">fbi</span> = <span class="title">mfd</span>-&gt;<span class="title">fbi</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> *<span class="title">fix</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> *<span class="title">var</span>;</span></span><br><span class="line"><span class="keyword">int</span> *id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fb info initialization</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fix = &amp;fbi-&gt;fix;</span><br><span class="line">var = &amp;fbi-&gt;var;</span><br><span class="line"></span><br><span class="line">fix-&gt;type_aux = <span class="number">0</span>;<span class="comment">/* if type == FB_TYPE_INTERLEAVED_PLANES */</span></span><br><span class="line">fix-&gt;visual = FB_VISUAL_TRUECOLOR;<span class="comment">/* True Color */</span></span><br><span class="line">fix-&gt;ywrapstep = <span class="number">0</span>;<span class="comment">/* No support */</span></span><br><span class="line">fix-&gt;mmio_start = <span class="number">0</span>;<span class="comment">/* No MMIO Address */</span></span><br><span class="line">fix-&gt;mmio_len = <span class="number">0</span>;<span class="comment">/* No MMIO Address */</span></span><br><span class="line">fix-&gt;accel = FB_ACCEL_NONE;<span class="comment">/* FB_ACCEL_MSM needes to be added in fb.h */</span></span><br><span class="line"></span><br><span class="line">var-&gt;xoffset = <span class="number">0</span>,<span class="comment">/* Offset from virtual to visible */</span></span><br><span class="line">var-&gt;yoffset = <span class="number">0</span>,<span class="comment">/* resolution */</span></span><br><span class="line">var-&gt;grayscale = <span class="number">0</span>,<span class="comment">/* No graylevels */</span></span><br><span class="line">var-&gt;nonstd = <span class="number">0</span>,<span class="comment">/* standard pixel format */</span></span><br><span class="line">var-&gt;activate = FB_ACTIVATE_VBL,<span class="comment">/* activate it at vsync */</span></span><br><span class="line">var-&gt;height = <span class="number">-1</span>,<span class="comment">/* height of picture in mm */</span></span><br><span class="line">var-&gt;width = <span class="number">-1</span>,<span class="comment">/* width of picture in mm */</span></span><br><span class="line">var-&gt;accel_flags = <span class="number">0</span>,<span class="comment">/* acceleration flags */</span></span><br><span class="line">var-&gt;sync = <span class="number">0</span>,<span class="comment">/* see FB_SYNC_* */</span></span><br><span class="line">var-&gt;rotate = <span class="number">0</span>,<span class="comment">/* angle we rotate counter clockwise */</span></span><br><span class="line">mfd-&gt;op_enable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (mfd-&gt;fb_imgType) &#123;</span><br><span class="line"><span class="keyword">case</span> MDP_RGB_565:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">0</span>;</span><br><span class="line">bpp = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_RGB_888:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">0</span>;</span><br><span class="line">bpp = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_ARGB_8888:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">8</span>;</span><br><span class="line">bpp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_RGBA_8888:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">24</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">8</span>;</span><br><span class="line">bpp = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> MDP_YCRYCB_H2V1:</span><br><span class="line">......</span><br><span class="line">var-&gt;transp.offset = <span class="number">0</span>;</span><br><span class="line">var-&gt;transp.length = <span class="number">0</span>;</span><br><span class="line">bpp = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdss_panelinfo_to_fb_var(panel_info, var);</span><br><span class="line"></span><br><span class="line">fix-&gt;type = panel_info-&gt;is_3d_panel;</span><br><span class="line"><span class="keyword">if</span> (mfd-&gt;mdp.fb_stride)</span><br><span class="line">fix-&gt;line_length = mfd-&gt;mdp.fb_stride(mfd-&gt;index, var-&gt;xres,</span><br><span class="line">bpp);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">fix-&gt;line_length = var-&gt;xres * bpp;</span><br><span class="line"></span><br><span class="line">var-&gt;xres_virtual = var-&gt;xres;</span><br><span class="line">var-&gt;yres_virtual = panel_info-&gt;yres * mfd-&gt;fb_page;</span><br><span class="line">var-&gt;bits_per_pixel = bpp * <span class="number">8</span>;<span class="comment">/* FrameBuffer color depth */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Populate smem length here for uspace to get the</span></span><br><span class="line"><span class="comment"> * Framebuffer size when FBIO_FSCREENINFO ioctl is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">fix-&gt;smem_len = PAGE_ALIGN(fix-&gt;line_length * var-&gt;yres) * mfd-&gt;fb_page;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* id field for fb app  */</span></span><br><span class="line">id = (<span class="keyword">int</span> *)&amp;mfd-&gt;panel;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(fix-&gt;id, <span class="keyword">sizeof</span>(fix-&gt;id), <span class="string">"mdssfb_%x"</span>, (u32) *id);</span><br><span class="line"></span><br><span class="line">fbi-&gt;fbops = &amp;mdss_fb_ops;</span><br><span class="line">fbi-&gt;flags = FBINFO_FLAG_DEFAULT;</span><br><span class="line">fbi-&gt;pseudo_palette = mdss_fb_pseudo_palette;</span><br><span class="line"></span><br><span class="line">mfd-&gt;ref_cnt = <span class="number">0</span>;</span><br><span class="line">mfd-&gt;panel_power_state = MDSS_PANEL_POWER_OFF;</span><br><span class="line">mfd-&gt;dcm_state = DCM_UNINIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mdss_fb_alloc_fbmem(mfd))</span><br><span class="line">pr_warn(<span class="string">"unable to allocate fb memory in fb register\n"</span>);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ret = fb_alloc_cmap(&amp;fbi-&gt;cmap, <span class="number">256</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">pr_err(<span class="string">"fb_alloc_cmap() failed!\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (register_framebuffer(fbi) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">fb_dealloc_cmap(&amp;fbi-&gt;cmap);</span><br><span class="line">mfd-&gt;op_enable = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">snprintf</span>(panel_name, ARRAY_SIZE(panel_name), <span class="string">"mdss_panel_fb%d"</span>,</span><br><span class="line">mfd-&gt;index);</span><br><span class="line">mdss_panel_debugfs_init(panel_info, panel_name);</span><br><span class="line">pr_info(<span class="string">"FrameBuffer[%d] %dx%d registered successfully!\n"</span>, mfd-&gt;index,</span><br><span class="line">fbi-&gt;var.xres, fbi-&gt;var.yres);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任何一个特定硬件Framebuffer驱动在初始化时都必须向fbmem.c注册，FrameBuffer模块提供了驱动注册接口函数register_framebuffer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\fbdev\core\fbmem.c]</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">register_framebuffer(struct fb_info *fb_info)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;registration_lock);</span><br><span class="line">ret = do_register_framebuffer(fb_info);</span><br><span class="line">mutex_unlock(&amp;registration_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数fb_info描述特定硬件的FrameBuffer驱动信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\fbdev\core\fbmem.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">do_register_framebuffer</span><span class="params">(struct fb_info *fb_info)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_event</span> <span class="title">event</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_videomode</span> <span class="title">mode</span>;</span>  </span><br><span class="line">    <span class="keyword">if</span> (fb_check_foreignness(fb_info))  </span><br><span class="line">        <span class="keyword">return</span> -ENOSYS;  </span><br><span class="line">    <span class="comment">//根据当前注册的fb_info的apertures属性从FrameBuffer驱动数组registered_fb中查询是否存在冲突  </span></span><br><span class="line">    do_remove_conflicting_framebuffers(fb_info-&gt;apertures, fb_info-&gt;fix.id,  </span><br><span class="line">                     fb_is_primary_device(fb_info));  </span><br><span class="line">    <span class="comment">//判断已注册的驱动是否超过32个FrameBuffer驱动  </span></span><br><span class="line">    <span class="keyword">if</span> (num_registered_fb == FB_MAX)  </span><br><span class="line">        <span class="keyword">return</span> -ENXIO;  </span><br><span class="line">    <span class="comment">//增加已注册的驱动个数  </span></span><br><span class="line">    num_registered_fb++;  </span><br><span class="line">    <span class="comment">//从数组registered_fb中查找空闲元素，用于存储当前注册的fb_info  </span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; FB_MAX; i++)  </span><br><span class="line">        <span class="keyword">if</span> (!registered_fb[i])  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    <span class="comment">//将当前注册的fb_info在数组registered_fb中的索引位置保存到fb_info-&gt;node  </span></span><br><span class="line">    fb_info-&gt;node = i;  </span><br><span class="line">    <span class="comment">//初始化当前注册的fb_info的成员信息  </span></span><br><span class="line">    atomic_set(&amp;fb_info-&gt;count, <span class="number">1</span>);  </span><br><span class="line">    mutex_init(&amp;fb_info-&gt;lock);  </span><br><span class="line">    mutex_init(&amp;fb_info-&gt;mm_lock);  </span><br><span class="line">    <span class="comment">//在/dev目录下创建一个fbx的设备文件，次设备号就是该fb_info在数组registered_fb中的索引  </span></span><br><span class="line">    fb_info-&gt;dev = device_create(fb_class, fb_info-&gt;device,MKDEV(FB_MAJOR, i), <span class="literal">NULL</span>, <span class="string">"fb%d"</span>, i);  </span><br><span class="line">    <span class="keyword">if</span> (IS_ERR(fb_info-&gt;dev)) &#123;  </span><br><span class="line">        printk(KERN_WARNING <span class="string">"Unable to create device for framebuffer %d; errno = %ld\n"</span>, i, PTR_ERR(fb_info-&gt;dev));  </span><br><span class="line">        fb_info-&gt;dev = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span>  </span><br><span class="line">        <span class="comment">//初始化fb_info  </span></span><br><span class="line">        fb_init_device(fb_info);  </span><br><span class="line">    <span class="keyword">if</span> (fb_info-&gt;pixmap.addr == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        fb_info-&gt;pixmap.addr = kmalloc(FBPIXMAPSIZE, GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (fb_info-&gt;pixmap.addr) &#123;  </span><br><span class="line">            fb_info-&gt;pixmap.size = FBPIXMAPSIZE;  </span><br><span class="line">            fb_info-&gt;pixmap.buf_align = <span class="number">1</span>;  </span><br><span class="line">            fb_info-&gt;pixmap.scan_align = <span class="number">1</span>;  </span><br><span class="line">            fb_info-&gt;pixmap.access_align = <span class="number">32</span>;  </span><br><span class="line">            fb_info-&gt;pixmap.flags = FB_PIXMAP_DEFAULT;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;     </span><br><span class="line">    fb_info-&gt;pixmap.offset = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_x)  </span><br><span class="line">        fb_info-&gt;pixmap.blit_x = ~(u32)<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!fb_info-&gt;pixmap.blit_y)  </span><br><span class="line">        fb_info-&gt;pixmap.blit_y = ~(u32)<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (!fb_info-&gt;modelist.prev || !fb_info-&gt;modelist.next)  </span><br><span class="line">        INIT_LIST_HEAD(&amp;fb_info-&gt;modelist);  </span><br><span class="line">    fb_var_to_videomode(&amp;mode, &amp;fb_info-&gt;var);  </span><br><span class="line">    fb_add_videomode(&amp;mode, &amp;fb_info-&gt;modelist);  </span><br><span class="line">    <span class="comment">//将特定硬件对应的fb_info注册到registered_fb数组中  </span></span><br><span class="line">    registered_fb[i] = fb_info;  </span><br><span class="line">    event.info = fb_info;  </span><br><span class="line">    <span class="keyword">if</span> (!lock_fb_info(fb_info))  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">    <span class="comment">//使用Linux事件通知机制发送一个FrameBuffer注册事件FB_EVENT_FB_REGISTERED  </span></span><br><span class="line">    fb_notifier_call_chain(FB_EVENT_FB_REGISTERED, &amp;event);  </span><br><span class="line">    unlock_fb_info(fb_info);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册过程就是将指定的设备驱动信息fb_info存放到registered_fb数组中。因此在注册具体的fb_info时，首先要构造一个fb_info数据结构，并初始化该数据结构，该结构用于描述一个特定的FrameBuffer驱动。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-07-fb-device-create.jpg" alt="Alt text | center"></p><h4 id="（三）、MDP-driver"><a href="#（三）、MDP-driver" class="headerlink" title="（三）、MDP driver"></a>（三）、MDP driver</h4><p>MDP也被注册为平台驱动程序。 mdp3_driver_init执行驱动程序init。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdp3.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">mdp3_driver</span> = &#123;</span></span><br><span class="line">.probe = mdp3_probe,</span><br><span class="line">.remove = mdp3_remove,</span><br><span class="line">.suspend = mdp3_suspend,</span><br><span class="line">.resume = mdp3_resume,</span><br><span class="line">.shutdown = <span class="literal">NULL</span>,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"mdp3"</span>,</span><br><span class="line">.of_match_table = mdp3_dt_match,</span><br><span class="line">.pm             = &amp;mdp3_pm_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">mdp3_driver_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = platform_driver_register(&amp;mdp3_driver);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">"register mdp3 driver failed!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mdp3_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">msm_mdp_interface</span> <span class="title">mdp3_interface</span> = &#123;</span></span><br><span class="line">.init_fnc = mdp3_init,</span><br><span class="line">.fb_mem_get_iommu_domain = mdp3_fb_mem_get_iommu_domain,</span><br><span class="line">.panel_register_done = mdp3_panel_register_done,</span><br><span class="line">.fb_stride = mdp3_fb_stride,</span><br><span class="line">.check_dsi_status = mdp3_check_dsi_ctrl_status,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdp3_intr_cb</span> <span class="title">underrun_cb</span> = &#123;</span></span><br><span class="line">.cb = mdp3_dma_underrun_intr_handler,</span><br><span class="line">.data = <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s: START\n"</span>, __func__);</span><br><span class="line"><span class="keyword">if</span> (!pdev-&gt;dev.of_node) &#123;</span><br><span class="line">pr_err(<span class="string">"MDP driver only supports device tree probe\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -ENOTSUPP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mdp3_res) &#123;</span><br><span class="line">pr_err(<span class="string">"MDP already initialized\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdp3_res = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(struct mdp3_hw_resource),</span><br><span class="line">GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (mdp3_res == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">pdev-&gt;id = <span class="number">0</span>;</span><br><span class="line">mdp3_res-&gt;pdev = pdev;</span><br><span class="line">mutex_init(&amp;mdp3_res-&gt;res_mutex);</span><br><span class="line">spin_lock_init(&amp;mdp3_res-&gt;irq_lock);</span><br><span class="line">platform_set_drvdata(pdev, mdp3_res);</span><br><span class="line">atomic_set(&amp;mdp3_res-&gt;active_intf_cnt, <span class="number">0</span>);</span><br><span class="line">mutex_init(&amp;mdp3_res-&gt;reg_bus_lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;mdp3_res-&gt;reg_bus_clist);</span><br><span class="line"></span><br><span class="line">mdp3_res-&gt;mdss_util = mdss_get_util_intf();</span><br><span class="line"><span class="keyword">if</span> (mdp3_res-&gt;mdss_util == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pr_err(<span class="string">"Failed to get mdss utility functions\n"</span>);</span><br><span class="line">rc =  -ENODEV;</span><br><span class="line"><span class="keyword">goto</span> get_util_fail;</span><br><span class="line">&#125;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;get_iommu_domain = mdp3_get_iommu_domain;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;iommu_attached = is_mdss_iommu_attached;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;iommu_ctrl = mdp3_iommu_ctrl;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;bus_scale_set_quota = mdp3_bus_scale_set_quota;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;panel_intf_type = mdp3_panel_intf_type;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;dyn_clk_gating_ctrl =</span><br><span class="line">mdp3_dynamic_clock_gating_ctrl;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;panel_intf_type = mdp3_panel_intf_type;</span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;panel_intf_status = mdp3_panel_get_intf_status;</span><br><span class="line">rc = mdp3_parse_dt(pdev);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line"></span><br><span class="line">rc = mdp3_res_init();</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to initialize mdp3 resources\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdp3_res-&gt;fs_ena = <span class="literal">false</span>;</span><br><span class="line">mdp3_res-&gt;fs = devm_regulator_get(&amp;pdev-&gt;dev, <span class="string">"vdd"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR_OR_NULL(mdp3_res-&gt;fs)) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to get mdss gdsc regulator\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rc = mdp3_debug_init(pdev);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to initialize mdp debugging\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, AUTOSUSPEND_TIMEOUT_MS);</span><br><span class="line"><span class="keyword">if</span> (mdp3_res-&gt;idle_pc_enabled) &#123;</span><br><span class="line">pr_debug(<span class="string">"%s: Enabling autosuspend\n"</span>, __func__);</span><br><span class="line">pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Enable PM runtime */</span></span><br><span class="line">pm_runtime_set_suspended(&amp;pdev-&gt;dev);</span><br><span class="line">pm_runtime_enable(&amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!pm_runtime_enabled(&amp;pdev-&gt;dev)) &#123;</span><br><span class="line">rc = mdp3_footswitch_ctrl(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"unable to turn on FS\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rc = mdp3_check_version();</span><br><span class="line"><span class="keyword">if</span> (rc) &#123;</span><br><span class="line">pr_err(<span class="string">"mdp3 check version failed\n"</span>);</span><br><span class="line"><span class="keyword">goto</span> probe_done;</span><br><span class="line">&#125;</span><br><span class="line">rc = mdp3_register_sysfs(pdev);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"unable to register mdp sysfs nodes\n"</span>);</span><br><span class="line"></span><br><span class="line">rc = mdss_fb_register_mdp_instance(&amp;mdp3_interface);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"unable to register mdp instance\n"</span>);</span><br><span class="line"></span><br><span class="line">rc = mdp3_set_intr_callback(MDP3_INTR_LCDC_UNDERFLOW,</span><br><span class="line">&amp;underrun_cb);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"unable to configure interrupt callback\n"</span>);</span><br><span class="line"></span><br><span class="line">rc = mdss_smmu_init(mdss_res, &amp;pdev-&gt;dev);</span><br><span class="line"><span class="keyword">if</span> (rc)</span><br><span class="line">pr_err(<span class="string">"mdss smmu init failed\n"</span>);</span><br><span class="line"></span><br><span class="line">mdp3_res-&gt;mdss_util-&gt;mdp_probe_done = <span class="literal">true</span>;</span><br><span class="line">pr_debug(<span class="string">"%s: END\n"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核调用MDP探测函数mdp3_probe。 在探测器上，驱动程序从设备树中获取面板信息，并通过调用mdp3_parse_dt来解析信息。 在mdp3_ctrl_on期间，MDP驱动程序调用mdp3_ctrl_res_req_clk并请求MDP和Vsync时钟。 在mdp3_ctrl_off期间，驱动程序请求关闭MDP和Vsync时钟。</p><h4 id="（四）、DSI-controller-driver-（lcd驱动-dsi）"><a href="#（四）、DSI-controller-driver-（lcd驱动-dsi）" class="headerlink" title="（四）、DSI controller driver （lcd驱动 dsi）"></a>（四）、DSI controller driver （lcd驱动 dsi）</h4><p>msm_dsi_v2_driver_init执行驱动程序初始化。 msm_dsi_v2_driver_init调用 msm_dsi_v2_register_driver注册驱动程序。<br>总体时序图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-08-dsi-host-v2.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\dsi_host_v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm_dsi_v2_driver</span> = &#123;</span></span><br><span class="line">.probe = msm_dsi_probe,</span><br><span class="line">.remove = msm_dsi_remove,</span><br><span class="line">.shutdown = <span class="literal">NULL</span>,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"msm_dsi_v2"</span>,</span><br><span class="line">.of_match_table = msm_dsi_v2_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_dsi_v2_register_driver</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> platform_driver_register(&amp;msm_dsi_v2_driver);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_dsi_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dsi_interface</span> <span class="title">intf</span>;</span></span><br><span class="line"><span class="keyword">char</span> panel_cfg[MDSS_MAX_PANEL_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mdss_dsi_ctrl_pdata</span> *<span class="title">ctrl_pdata</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">dsi_pan_node</span> = <span class="title">NULL</span>;</span></span><br><span class="line"><span class="keyword">bool</span> cmd_cfg_cont_splash = <span class="literal">false</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">resource</span> *<span class="title">mdss_dsi_mres</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">rc = msm_dsi_init();</span><br><span class="line"></span><br><span class="line">pdev-&gt;id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ctrl_pdata = platform_get_drvdata(pdev);</span><br><span class="line"><span class="keyword">if</span> (!ctrl_pdata) &#123;</span><br><span class="line">ctrl_pdata = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(struct mdss_dsi_ctrl_pdata), GFP_KERNEL);</span><br><span class="line">platform_set_drvdata(pdev, ctrl_pdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctrl_pdata-&gt;mdss_util = mdss_get_util_intf();</span><br><span class="line"><span class="keyword">if</span> (mdp3_res-&gt;mdss_util == <span class="literal">NULL</span>) &#123;</span><br><span class="line">pr_err(<span class="string">"Failed to get mdss utility functions\n"</span>);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdss_dsi_mres = platform_get_resource(pdev, IORESOURCE_MEM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!mdss_dsi_mres) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dsi_host_private-&gt;dsi_reg_size = resource_size(mdss_dsi_mres);</span><br><span class="line">dsi_host_private-&gt;dsi_base = ioremap(mdss_dsi_mres-&gt;start,</span><br><span class="line">dsi_host_private-&gt;dsi_reg_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mdss_dsi_mres = platform_get_resource(pdev, IORESOURCE_IRQ, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rc = of_platform_populate(pdev-&gt;dev.of_node, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pdev-&gt;dev);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* DSI panels can be different between controllers */</span></span><br><span class="line">rc = dsi_get_panel_cfg(panel_cfg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* find panel device node */</span></span><br><span class="line">dsi_pan_node = dsi_find_panel_of_node(pdev, panel_cfg);</span><br><span class="line"></span><br><span class="line">cmd_cfg_cont_splash = mdp3_panel_get_boot_cfg() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">rc = mdss_dsi_panel_init(dsi_pan_node, ctrl_pdata, cmd_cfg_cont_splash);</span><br><span class="line"></span><br><span class="line">rc = dsi_ctrl_config_init(pdev, ctrl_pdata);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">msm_dsi_parse_lane_swap(pdev-&gt;dev.of_node, &amp;(ctrl_pdata-&gt;dlane_swap));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>;  i &lt; DSI_MAX_PM; i++) &#123;</span><br><span class="line">rc = msm_dsi_io_init(pdev, &amp;(ctrl_pdata-&gt;power_data[i]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s: Dsi Ctrl-&gt;0 initialized\n"</span>, __func__);</span><br><span class="line"></span><br><span class="line">dsi_host_private-&gt;dis_dev = pdev-&gt;dev;</span><br><span class="line">intf.on = msm_dsi_on;</span><br><span class="line">intf.off = msm_dsi_off;</span><br><span class="line">intf.cont_on = msm_dsi_cont_on;</span><br><span class="line">intf.clk_ctrl = msm_dsi_clk_ctrl;</span><br><span class="line">intf.op_mode_config = msm_dsi_op_mode_config;</span><br><span class="line">intf.index = <span class="number">0</span>;</span><br><span class="line">intf.<span class="keyword">private</span> = <span class="literal">NULL</span>;</span><br><span class="line">dsi_register_interface(&amp;intf);</span><br><span class="line"></span><br><span class="line">msm_dsi_debug_init();</span><br><span class="line"></span><br><span class="line">msm_dsi_ctrl_init(ctrl_pdata);</span><br><span class="line"></span><br><span class="line">rc = msm_dsi_irq_init(&amp;pdev-&gt;dev, mdss_dsi_mres-&gt;start,</span><br><span class="line">   ctrl_pdata);</span><br><span class="line"></span><br><span class="line">rc = dsi_panel_device_register_v2(pdev, ctrl_pdata);</span><br><span class="line"></span><br><span class="line">pr_debug(<span class="string">"%s success\n"</span>, __func__);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核调用msm_dsi_probe。 面板被检测到。 msm_dsi_probe调用mdss_dsi_panel_init函数。 mdss_dsi_panel_init调用mdss_panel_parse_dt来获取面板参数。<br>MDP驱动程序使用该事件与DSI驱动程序进行通信。 DSI驱动程序具有mdss_dsi_event_handler，这是MDP核心事件的回调处理程序。 mdss_panel.h定义了MDP核心事件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\drivers\video\msm\mdss\mdss_panel.h]</span><br><span class="line"><span class="keyword">enum</span> mdss_intf_events &#123;</span><br><span class="line">MDSS_EVENT_RESET = <span class="number">1</span>,</span><br><span class="line">MDSS_EVENT_LINK_READY,</span><br><span class="line">MDSS_EVENT_UNBLANK,</span><br><span class="line">MDSS_EVENT_PANEL_ON,</span><br><span class="line">MDSS_EVENT_POST_PANEL_ON,</span><br><span class="line">MDSS_EVENT_BLANK,</span><br><span class="line">MDSS_EVENT_PANEL_OFF,</span><br><span class="line">MDSS_EVENT_CLOSE,</span><br><span class="line">MDSS_EVENT_SUSPEND,</span><br><span class="line">MDSS_EVENT_RESUME,</span><br><span class="line">MDSS_EVENT_CHECK_PARAMS,</span><br><span class="line">MDSS_EVENT_CONT_SPLASH_BEGIN,</span><br><span class="line">MDSS_EVENT_CONT_SPLASH_FINISH,</span><br><span class="line">MDSS_EVENT_PANEL_UPDATE_FPS,</span><br><span class="line">MDSS_EVENT_FB_REGISTERED,</span><br><span class="line">MDSS_EVENT_PANEL_CLK_CTRL,</span><br><span class="line">MDSS_EVENT_DSI_CMDLIST_KOFF,</span><br><span class="line">MDSS_EVENT_ENABLE_PARTIAL_ROI,</span><br><span class="line">MDSS_EVENT_DSC_PPS_SEND,</span><br><span class="line">MDSS_EVENT_DSI_STREAM_SIZE,</span><br><span class="line">MDSS_EVENT_DSI_UPDATE_PANEL_DATA,</span><br><span class="line">MDSS_EVENT_REGISTER_RECOVERY_HANDLER,</span><br><span class="line">MDSS_EVENT_REGISTER_MDP_CALLBACK,</span><br><span class="line">MDSS_EVENT_DSI_PANEL_STATUS,</span><br><span class="line">MDSS_EVENT_DSI_DYNAMIC_SWITCH,</span><br><span class="line">MDSS_EVENT_DSI_RECONFIG_CMD,</span><br><span class="line">MDSS_EVENT_DSI_RESET_WRITE_PTR,</span><br><span class="line">MDSS_EVENT_PANEL_TIMING_SWITCH,</span><br><span class="line">MDSS_EVENT_MAX,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在msm_dsi_on期间，通过调用msm_dsi_clk_enable打开DSI时钟。 在msm_dsi_off期间，通过调用msm_dsi_clk_disable关闭clks。</p><h4 id="（五）、-Panel-driver-（面板-dsi）"><a href="#（五）、-Panel-driver-（面板-dsi）" class="headerlink" title="（五）、 Panel driver （面板 dsi）"></a>（五）、 Panel driver （面板 dsi）</h4><p>MDSS : Multimedia Display sub system<br>DSI: Display Serial Interface</p><blockquote><p>qcom,mdss-dsi-force-clock-lane-hs;          // faulse ：clock每帧回lp11<br>ture: clock不回 qcom,mdss-dsi-hfp-power-mode;               // data 每行回lp11,对应的hfp要修改成300以上</p></blockquote><p>面板信息位于kernel\arch\arm\boot\dts\中的.dtsi文件中。 这包含所有面板特定的命令，例如on，off和reset（mdss-dsi-on-command，mdss-dsi-off-command，mdss-dsi-reset-sequence），BL控制和其他面板 独立参数。<br>例如：<br>msm8610-mdss.dtsi （文件名通常为 msmxxx-mdss.dtsi 指定了mdss 的 mdp 和 dsi）</p><h5 id="5-1、-dtsi文件解析"><a href="#5-1、-dtsi文件解析" class="headerlink" title="5.1、.dtsi文件解析"></a>5.1、.dtsi文件解析</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mdss_mdp: qcom,mdss_mdp@fd900000 &#123;</span><br><span class="line">            compatible = <span class="string">"qcom,mdss_mdp3"</span>;  <span class="comment">// 对应mdss驱动 mdss_mdp.c</span></span><br><span class="line">----------</span><br><span class="line">  mdss_dsi0: qcom,mdss_dsi@fdd00000 &#123;</span><br><span class="line">        compatible = <span class="string">"qcom,msm-dsi-v2"</span>;      <span class="comment">// 对应dsi解析驱动 dsi_host_v2.c</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">  mdss_dsi0: qcom,mdss_dsi_ctrl0@<span class="number">1</span>a94000 &#123;</span><br><span class="line">        compatible = <span class="string">"qcom,mdss-dsi-ctrl"</span>;  <span class="comment">// 对应dsi解析驱动 mdss_dsi.c</span></span><br></pre></td></tr></table></figure><p>通过下面函数向 mdss_fb.c 注册了fb_info结构  (包含在mdss_dsi_ctrl_pdata结构中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">drivers\video\msm\mdss\dsi_host_v2.c （lcd驱动 dsi）</span><br><span class="line">dsi_panel_device_register_v2(struct platform_device *dev,struct mdss_dsi_ctrl_pdata *ctrl_pdata)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static const struct of_device_id msm_dsi_v2_dt_match[] = &#123;</span><br><span class="line">    &#123;.compatible = &quot;qcom,msm-dsi-v2&quot;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line">drivers\video\msm\mdss\mdss_dsi.c</span><br></pre></td></tr></table></figure><p>msm8610-asus.dts （指定mdp中的哪一个配置）<br>通常在dts文件的 mdss_dsi0 lab里面通过 qcom,dsi-pref-prim-pan 属性 指定使用哪一个lcd配置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;mdss_dsi0 &#123;</span><br><span class="line">        qcom,dsi-pref-prim-pan = &lt;&amp;dsi_fl10802_fwvga_vid&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>dsi-panel-fl10802-fwvga-video.dtsi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&amp;mdss_mdp &#123;</span><br><span class="line">    dsi_fl10802_fwvga_vid: qcom,mdss_dsi_fl10802_fwvga_video &#123;</span><br><span class="line">        qcom,mdss-dsi-panel-name = &quot;fl10802 fwvga video mode dsi panel&quot;;</span><br><span class="line">        qcom,mdss-dsi-drive-ic = &quot;fl10802&quot;;</span><br><span class="line">        qcom,mdss-dsi-panel-controller = &lt;&amp;mdss_dsi0&gt;;</span><br><span class="line">        qcom,mdss-dsi-panel-type = &quot;dsi_video_mode&quot;;</span><br><span class="line">        qcom,mdss-dsi-panel-destination = &quot;display_1&quot;;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h5 id="5-2、mdss-mdp-和-mdss-dsi0-的关系"><a href="#5-2、mdss-mdp-和-mdss-dsi0-的关系" class="headerlink" title="5.2、mdss_mdp 和 mdss_dsi0 的关系"></a>5.2、mdss_mdp 和 mdss_dsi0 的关系</h5><p>mdss_mdp 相当于一个数组，里面定义了很多不同lcd显示屏的配置项包括分辨率等等</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-09-mdss_mdp-mdss_dsi0.jpg" alt="Alt text | center"></p><p>面板驱动程序可以根据连接的实际面板数量具有多个节点。<br>mdss_register_panel注册面板驱动程序：<br>msm_dsi_probe→dsi_panel_device_register_v2→mdss_register_panel→<br>of_platform_device_create<br>以下面板控制功能可用并在mdss_dsi_panel_init中初始化：<br>ctrl_pdata→on = mdss_dsi_panel_on;<br>ctrl_pdata→off = mdss_dsi_panel_off;<br>ctrl_pdata→panel_data.set_backlight = mdss_dsi_panel_bl_ctrl;<br>  例如，在mdp3_ctrl.c中，函数mdp3_ctrl_on（）会调用以下DSI处理程序<br>MDSS_EVENT_UNBLANK和MDSS_EVENT_PANEL_ON事件如下所示：<br>rc = panel→event_handler（panel，MDSS_EVENT_UNBLANK，NULL）;<br>rc | =面板→event_handler（面板，MDSS_EVENT_PANEL_ON，NULL）;</p><h5 id="5-3、通过内核接口打开和关闭显示器"><a href="#5-3、通过内核接口打开和关闭显示器" class="headerlink" title="5.3、通过内核接口打开和关闭显示器"></a>5.3、通过内核接口打开和关闭显示器</h5><h5 id="5-3-1、启动"><a href="#5-3-1、启动" class="headerlink" title="5.3.1、启动"></a>5.3.1、启动</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-10-display-subsystem-on-bootup.png" alt="Alt text | center"></p><p>按照上面的部分所述注册设备后：<br>mdss_fb_open→mdss_fb_blank_sub→pdata→on（面板ON功能）<br>注意：对于命令模式面板，如果面板在启动时已打开，则会跳过该启动序列 以避免关闭/ -on的文物。</p><h5 id="5-3-2、暂停-恢复"><a href="#5-3-2、暂停-恢复" class="headerlink" title="5.3.2、暂停/恢复"></a>5.3.2、暂停/恢复</h5><p>挂起/恢复时，调用fb驱动程序挂起/恢复和MDP驱动程序挂起/恢复。 fb驱动程序依次调用面板驱动程序的开/关功能。</p><h5 id="5-3-2-1、暂停序列"><a href="#5-3-2-1、暂停序列" class="headerlink" title="5.3.2.1、暂停序列"></a>5.3.2.1、暂停序列</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-11-suspend sequence.png" alt="Alt text | center"></p><p>Kernelcall→mdss_fb_release_all→mdss_fb_blank→mdss_fb_blank_sub→mdp3_ctrl_off→<br>mdp3_ctrl_off发送两个事件：</p><ol><li>MDSS_EVENT_PANEL_OFF - dsi_event_handler接收事件。 当事件发生时<br>接收到时，调用小组关闭序列。</li><li>MDSS_EVENT_BLANK - 该事件由调用的dsi_event_handler处理<br>mdss_dsi_off。</li></ol><ul><li>Kernelcall→mdp3_suspend - 未使用<h5 id="5-3-2-2、恢复序列"><a href="#5-3-2-2、恢复序列" class="headerlink" title="5.3.2.2、恢复序列"></a>5.3.2.2、恢复序列</h5></li></ul><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-12-resume sequence.png" alt="Alt text | center"></p><p>Kernelcall→mdss_fb_blank→mdss_fb_blank_sub→mdp3_ctrl_on→<br>mdp3_ctrl_on发送两个事件：</p><ol><li>MDSS_EVENT_UNBLANK - dsi_event_handler接收事件。 当事件发生时<br>收到，DSI-on被调用。</li><li>MDSS_EVENT_PANEL_ON - 事件由dsi_event_handler处理，dsi_event_handler发送<br>面板上的序列。<br>Kernelcall→mdp3_resume - 未使用</li></ol><h5 id="5-4、图像更新到面板"><a href="#5-4、图像更新到面板" class="headerlink" title="5.4、图像更新到面板"></a>5.4、图像更新到面板</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS05-13-flow for display subsystem commit.png" alt="Alt text | center"></p><p> 用户必须确保MSMFB_OVERLAY_SET IOCTL在呼叫之前至少被调用一次 到MSMFB_OVERLAY_PLAY IOCLT（例如ioctl(fd, MSMFB_OVERLAY_PLAY, &amp;od)）。MSMFB_OVERLAY_PLAY队列缓冲区 显示在面板上。 用户使用MSMFB_DISPLAY_COMMIT调用fb IOCLT。这会启动一个呼叫<br> mdss_fb_display_commit 并安排工作队列。此工作队列处理程序调用<br> msm_fb_pan_display_ex，然后调用mdp3_ctrl_pan_display。<br> mdss_fb_ioctl→（MSMFB_DISPLAY_COMMIT）→mdss_fb_display_commit→<br> mdss_fb_pan_display_ex→计划工作mdss_fb_commit_wq_handler<br> msm_fb_commit_wq_handler→mdp3_ctrl_display_commit_kickoff→mdp3_dmap_update<br>一次呼叫后，可以有多个对PLAY和COMMIT IOCLT的呼叫 MSMFB_OVERLAY_SET IOCTL。面板更新完成并且设备完成后<br>需要进入挂起或关闭状态，用户可以调用MSMFB_OVERLAY_UNSET。</p><p>注意：工作队列架构正在被即将发布的线程取代，<br>这些文件未被捕获。视频和命令模式面板的面板更新略有不同。为了在命令模式面板中，mdp3_dmap_update函数会等待，直到前一个图像更新为止完成使用MDP DMA开始新帧更新</p><p>if（dma-&gt; output_config.out_sel == MDP3_DMA_OUTPUT_SEL_DSI_CMD）{<br>cb_type = MDP3_DMA_CALLBACK_TYPE_DMA_DONE;<br>如果（intf-&gt; active）<br>wait_for_completion_killable（DMA-&gt; dma_comp）;</p><p>对于视频面板，在DMA触发后，mdp3_dmap_update等待vsync。</p><h4 id="（六）、Msm8610-lcd-driver-内核初始化分析"><a href="#（六）、Msm8610-lcd-driver-内核初始化分析" class="headerlink" title="（六）、Msm8610  lcd driver 内核初始化分析"></a>（六）、Msm8610  lcd driver 内核初始化分析</h4><p>请参考<a href="https://blog.csdn.net/ic_soc_arm_robin/article/details/12949347" target="_blank" rel="noopener">【msm8610 lcd driver code analysis】</a></p><h4 id="（七）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（七）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（七）、参考资料(特别感谢各位前辈的分析和图示)："></a>（七）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><strong>(๑乛◡乛๑) 、（ ͡° ͜ʖ ͡°）、（ಡωಡ）！！！累~~~</strong><br><strong>时至今日，终于完整的分析了Android Display System 总体框架流程，不禁感叹计算机世界的博大精深，在这个系列的分析中历练了如何拆解分析一个庞大复杂的模块、学习收获良多，同时也了解了自身知识的欠缺，由于涉及知识较多较广，博主也未能完全吃透，其中分析有误的地方还请各位见谅。所谓路漫漫其修远兮，吾将上下而求索。</strong><br><strong>Todo：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究，Multimedia System 任还有许多未解之惑，需恶补Linux内核知识，少年，加油（➽➽➽）</strong></p><h4 id="（八）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（八）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（八）、参考资料(特别感谢各位前辈的分析和图示)："></a>（八）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://s3.amazonaws.com/connect.linaro.org/bkk16/Presentations/Wednesday/BKK16-315.pdf" target="_blank" rel="noopener">Graphics Stack Update</a><br><a href="https://blog.csdn.net/eliot_shao/article/details/74926010" target="_blank" rel="noopener">高通Android平台-应用空间操作framebuffer dump LCD总结</a><br><a href="https://blog.csdn.net/ic_soc_arm_robin/article/details/12949347" target="_blank" rel="noopener">msm8610 lcd driver code analysis</a><br><a href="https://blog.csdn.net/u012719256/article/details/52096727" target="_blank" rel="noopener">linux qcom LCD framwork</a><br><a href="https://blog.csdn.net/weijory/article/details/69391838" target="_blank" rel="noopener">Qualcomm平台 display bring up 过程详解</a><br><a href="https://blog.csdn.net/wlwl0071986/article/details/8247443" target="_blank" rel="noopener">高通8x25平台display模块总结</a><br><a href="https://blog.csdn.net/sfrysh/article/details/7305253" target="_blank" rel="noopener">Android 中的 framebuffer</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12096483" target="_blank" rel="noopener">FrameBuffer驱动程序分析</a><br><a href="http://www.wxtlife.com/2017/06/07/Android-framebuffer/" target="_blank" rel="noopener">Android Framebuffer介绍及使用</a><br><a href="https://www.wolfcstech.com/categories/Android-%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Android 图形系统</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析</title>
    <link href="http://zhoujinjian.cc/2018/08/16/Android%20Display%20System%EF%BC%884%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BGralloc%20&amp;&amp;%20HWComposer%E6%A8%A1%E5%9D%97%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/08/16/Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析/</id>
    <published>2018-08-15T16:00:00.000Z</published>
    <updated>2018-06-20T15:16:27.801Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/putiancaijunyu/article/category/2558539" target="_blank" rel="noopener">【特别感谢 -  Android研究 Gralloc &amp;&amp; HWComposer系列分析】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">【特别感谢 -  Android display 系列分析】</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12192401" target="_blank" rel="noopener">【特别感谢 -  Android图形显示之硬件抽象层Gralloc】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】</p><hr><p>\hardware\libhardware\include\hardware</p><ul><li>fb.h</li></ul><p>\hardware\libhardware\modules\gralloc</p><ul><li>framebuffer.cpp</li><li>gralloc.cpp</li><li>gralloc_priv.h</li><li>gr.h</li><li>mapper.cpp</li></ul><p>\hardware\qcom\display\msm8996\libgralloc</p><ul><li>alloc_controller.cpp</li><li>framebuffer.cpp</li><li>gpu.cpp</li><li>gralloc.cpp</li><li>ionalloc.cpp</li><li>mapper.cpp</li></ul><p>\hardware\qcom\display\msm8996\libgralloc1</p><ul><li>gr_adreno_info.cpp</li><li>gr_allocator.cpp</li><li>gr_buf_mgr.cpp</li><li>gr_device_impl.cpp</li><li>gr_ion_alloc.cpp</li><li>gr_utils.cpp</li></ul><p>\frameworks\native\services\surfaceflinger</p><ul><li>DisplayDevice.cpp</li><li>SurfaceFlinger.cpp</li><li>MonitoredProducer.cpp</li><li>SurfaceFlingerConsumer.cpp</li><li>SurfaceFlinger_hwc1.cpp</li><li>Client.cpp</li><li>DispSync.cpp</li><li>EventControlThread.cpp</li><li>EventThread.cpp</li><li>Layer.cpp</li><li>MessageQueue.cpp</li></ul><p>\frameworks\native\services\surfaceflinger\DisplayHardware</p><ul><li>FramebufferSurface.cpp</li><li>HWC2.cpp</li><li>HWC2On1Adapter.cpp</li><li>HWComposer.cpp</li><li>HWComposer_hwc1.cpp</li></ul><hr><p>Linux系统下的显示驱动框架，每个显示屏被抽象为一个帧缓冲区，注册到FrameBuffer模块中，并在/dev/graphics目录下创建对应的fbX设备。Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对帧缓冲区的所有访问操作。用户空间的应用程序在使用帧缓冲区之间，首先要加载Gralloc模块，并且获得一个gralloc设备和一个fb设备。有了gralloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过gralloc设备来释放它，并且将它从地址空间中解除映射。</p><p>高通MSM8996 <a href="Android 图形系统之gralloc">Gralloc模块</a> 实现源码位于：<br>\hardware\qcom\display\msm8996\libgralloc<br>每个硬件抽象层模块都必须定义HAL_MODULE_INFO_SYM符号，并且有自己唯一的ID，Gralloc也不例外，Gralloc模块ID定义为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/gralloc.h]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The id of this module</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_MODULE_ID <span class="meta-string">"gralloc"</span></span></span><br></pre></td></tr></table></figure><p>同时定义了以HAL_MODULE_INFO_SYM为符号的类型为 private_module_t的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">hardware\libhardware\modules\gralloc\gralloc.cpp</span><br><span class="line"><span class="comment">// HAL module methods</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">gralloc_module_methods</span> = &#123;</span></span><br><span class="line">    .open = gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HAL module initialize</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_module_t</span> <span class="title">HAL_MODULE_INFO_SYM</span> = &#123;</span></span><br><span class="line">    .base = &#123;</span><br><span class="line">        .common = &#123;</span><br><span class="line">            .tag = HARDWARE_MODULE_TAG,</span><br><span class="line">            .version_major = <span class="number">1</span>,</span><br><span class="line">            .version_minor = <span class="number">0</span>,</span><br><span class="line">            .id = GRALLOC_HARDWARE_MODULE_ID,</span><br><span class="line">            .name = <span class="string">"Graphics Memory Allocator Module"</span>,</span><br><span class="line">            .author = <span class="string">"The Android Open Source Project"</span>,</span><br><span class="line">            .methods = &amp;gralloc_module_methods,</span><br><span class="line">            .dso = <span class="number">0</span>,</span><br><span class="line">            .reserved = &#123;<span class="number">0</span>&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        .registerBuffer = gralloc_register_buffer,</span><br><span class="line">        .unregisterBuffer = gralloc_unregister_buffer,</span><br><span class="line">        .lock = gralloc_lock,</span><br><span class="line">        .unlock = gralloc_unlock,</span><br><span class="line">        .perform = gralloc_perform,</span><br><span class="line">        .lock_ycbcr = gralloc_lock_ycbcr,</span><br><span class="line">    &#125;,</span><br><span class="line">    .framebuffer = <span class="number">0</span>,</span><br><span class="line">    .fbFormat = <span class="number">0</span>,</span><br><span class="line">    .flags = <span class="number">0</span>,</span><br><span class="line">    .numBuffers = <span class="number">0</span>,</span><br><span class="line">    .bufferMask = <span class="number">0</span>,</span><br><span class="line">    .lock = PTHREAD_MUTEX_INITIALIZER,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过<a href="Android 图形系统之gralloc">Gralloc模块加载</a> 分析的方法将Gralloc模块加载到内存中来之后，就可以调用函数dlsym来获得它所导出的符号HMI，得到private_module_t的首地址后，由于private_module_t的第一个成员变量的类型为gralloc_module_t，因此也是gralloc_module_t的首地址，由于gralloc_module_t的第一个成员变量类型为hw_module_t，因此也是hw_module_t的首地址，因此只要得到这三种类型中其中一种类型变量的地址，就可以相互转换为其他两种类型的指针。</p><h4 id="（一）、Gralloc模块-数据结构"><a href="#（一）、Gralloc模块-数据结构" class="headerlink" title="（一）、Gralloc模块 数据结构"></a>（一）、Gralloc模块 数据结构</h4><p>在分析Gralloc模块之前，首先介绍Gralloc模块定义的一些数据结构。private_module_t用于描述Gralloc模块下的系统帧缓冲区信息<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\fb_priv.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_module_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">gralloc_module_t</span> base;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span>* <span class="title">framebuffer</span>;</span><span class="comment">//指向系统帧缓冲区的句柄  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> fbFormat;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;<span class="comment">//用来标志系统帧缓冲区是否支持双缓冲</span></span><br><span class="line">    <span class="keyword">uint32_t</span> numBuffers;<span class="comment">//表示系统帧缓冲区包含有多少个图形缓冲区  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> bufferMask;<span class="comment">//记录系统帧缓冲区中的图形缓冲区的使用情况 </span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> lock;<span class="comment">//一个互斥锁，用来保护结构体private_module_t的并行访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">info</span>;</span><span class="comment">//保存设备显示屏的动态属性信息  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span><span class="comment">//保存设备显示屏的固定属性信息</span></span><br><span class="line">    <span class="keyword">float</span> xdpi;<span class="comment">//描述设备显示屏在宽度  </span></span><br><span class="line">    <span class="keyword">float</span> ydpi;<span class="comment">//描述设备显示屏在高度  </span></span><br><span class="line">    <span class="keyword">float</span> fps;<span class="comment">//用来描述显示屏的刷新频率  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> swapInterval;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>framebuffer_device_t用来描述系统帧缓冲区设备的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/fb.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">framebuffer_device_t</span> &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Common methods of the framebuffer device.  This *must* be the first member of</span></span><br><span class="line"><span class="comment">     * framebuffer_device_t as users of this structure will cast a hw_device_t to</span></span><br><span class="line"><span class="comment">     * framebuffer_device_t pointer in contexts where it's known the hw_device_t references a</span></span><br><span class="line"><span class="comment">     * framebuffer_device_t.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    <span class="comment">//用来记录系统帧缓冲区的标志</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  flags;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏的宽度、高度 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  width;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span>  height;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏的一行有多少个像素点  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       stride;</span><br><span class="line">    <span class="comment">//用来描述系统帧缓冲区的像素格式</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       format;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏在宽度上的密度、密度</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     xdpi;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     ydpi;</span><br><span class="line">    <span class="comment">//用来描述设备显示屏的刷新频率  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span>     fps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔 </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       minSwapInterval;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       maxSwapInterval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of framebuffers supported*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>       numFramebuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> reserved[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区交换前后两个图形缓冲区的最小和最大时间间隔</span></span><br><span class="line">    <span class="keyword">int</span> (*setSwapInterval)(struct <span class="keyword">framebuffer_device_t</span>* window,</span><br><span class="line">            <span class="keyword">int</span> interval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来设置帧缓冲区的更新区域</span></span><br><span class="line">    <span class="keyword">int</span> (*setUpdateRect)(struct <span class="keyword">framebuffer_device_t</span>* window,</span><br><span class="line">            <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> width, <span class="keyword">int</span> height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来将图形缓冲区buffer的内容渲染到帧缓冲区中去</span></span><br><span class="line">    <span class="keyword">int</span> (*post)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">buffer_handle_t</span> buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来通知fb设备，图形缓冲区的组合工作已经完成</span></span><br><span class="line">    <span class="keyword">int</span> (*compositionComplete)(struct <span class="keyword">framebuffer_device_t</span>* dev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line">    <span class="keyword">int</span> (*enableScreen)(struct <span class="keyword">framebuffer_device_t</span>* dev, <span class="keyword">int</span> enable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">framebuffer_device_t</span>;</span><br></pre></td></tr></table></figure><p>gralloc_module_t用于描述gralloc模块信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">gralloc_module_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> <span class="title">common</span>;</span></span><br><span class="line">    <span class="comment">//映射一块图形缓冲区到一个进程的地址空间去 </span></span><br><span class="line">    <span class="keyword">int</span> (*registerBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    <span class="comment">//取消映射一块图形缓冲区到一个进程的地址空间去</span></span><br><span class="line">    <span class="keyword">int</span> (*unregisterBuffer)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*lock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> w, <span class="keyword">int</span> h,</span><br><span class="line">            <span class="keyword">void</span>** vaddr);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> (*unlock)(struct <span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* reserved for future use */</span></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">3</span>];</span><br><span class="line">&#125; <span class="keyword">gralloc_module_t</span>;</span><br></pre></td></tr></table></figure><p>alloc_device_t用于描述gralloc设备的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">alloc_device_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_device_t</span> <span class="title">common</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> (*alloc)(struct <span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">            <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span>* handle, <span class="keyword">int</span>* stride);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">int</span> (*<span class="built_in">free</span>)(struct <span class="keyword">alloc_device_t</span>* dev,</span><br><span class="line">            <span class="keyword">buffer_handle_t</span> handle);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">void</span> (*dump)(struct <span class="keyword">alloc_device_t</span> *dev, <span class="keyword">char</span> *buff, <span class="keyword">int</span> buff_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* reserved_proc[<span class="number">7</span>];</span><br><span class="line">&#125; <span class="keyword">alloc_device_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/hardware.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">uint32_t</span> tag;<span class="comment">//标签  </span></span><br><span class="line">　　<span class="keyword">uint16_t</span> version_major;<span class="comment">//模块主设备号  </span></span><br><span class="line">　　<span class="keyword">uint16_t</span> version_minor;<span class="comment">//模块次设备号  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *id;<span class="comment">//模块ID  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">//模块名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *author;<span class="comment">//模块作者  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span>* <span class="title">methods</span>;</span><span class="comment">//模块操作方法  </span></span><br><span class="line">    <span class="keyword">void</span>* dso;<span class="comment">//保存模块首地址  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved[<span class="number">32</span><span class="number">-7</span>];<span class="comment">//保留位  </span></span><br><span class="line">&#125; <span class="keyword">hw_module_t</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">模块</th><th style="text-align:right">设备</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:left">private_module_t</td><td style="text-align:right">framebuffer_device_t</td><td style="text-align:center">将图形缓冲器映射到帧缓冲区</td></tr><tr><td style="text-align:left">gralloc_module_t</td><td style="text-align:right">alloc_module_t</td><td style="text-align:center">分配或释放图形缓冲区</td></tr><tr><td style="text-align:left">hw_module_t</td><td style="text-align:right">hw_module_t</td><td style="text-align:center">关联设备和模块</td></tr></tbody></table><p>硬件抽象层Gralloc模块定义了设备fb和设备gpu：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\fb.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_FB0 <span class="meta-string">"fb0"</span></span></span><br><span class="line">[-&gt;/hardware/libhardware/include/hardware/gralloc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GRALLOC_HARDWARE_GPU0 <span class="meta-string">"gpu0"</span></span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-01-GRALLOC_HARDWARE_.png" alt="Alt text | center"></p><p>设备gpu用于分配图形缓冲区，而设备fb用于渲染图形缓冲区；hw_module_t用于描述硬件抽象层Gralloc模块，而hw_device_t则用于描述硬件抽象层Gralloc设备，通过硬件抽象层设备可以找到对应的硬件抽象层模块。在Gralloc模块中，无论是定义fb设备还是gpu设备，都是用来处理图形缓冲区，以下是关于缓冲区的数据结构 定义：<br>private_handle_t用来描述一块缓冲区，Android对缓冲区的定义提供了C和C++两种方式，C++：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gralloc_priv.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span> :</span> <span class="keyword">public</span> native_handle &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">private_handle_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">native_handle_t</span> nativeHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">enum</span> &#123;</span><br><span class="line">            PRIV_FLAGS_FRAMEBUFFER        = <span class="number">0x00000001</span>,</span><br><span class="line">            ......</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// file-descriptors</span></span><br><span class="line">        <span class="keyword">int</span>     fd;</span><br><span class="line">        <span class="keyword">int</span>     fd_metadata;          <span class="comment">// fd for the meta-data</span></span><br><span class="line">        <span class="comment">// ints</span></span><br><span class="line">        <span class="keyword">int</span>     magic;</span><br><span class="line">        <span class="keyword">int</span>     flags;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  size;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span>  offset;</span><br><span class="line">        <span class="keyword">int</span>     bufferType;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span>     format;</span><br><span class="line">        <span class="keyword">int</span>     width;</span><br><span class="line">        <span class="keyword">int</span>     height;</span><br><span class="line">        ......</span><br></pre></td></tr></table></figure></p><p>两种编译器下的private_handle_t定义都继承于native_handle，native_handle的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/include/cutils/native_handle.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">native_handle</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> version; <span class="comment">//设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本  </span></span><br><span class="line">    <span class="keyword">int</span> numFds;  <span class="comment">//表示结构体native_handle_t所包含的文件描述符的个数，这些文件描述符保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> numInts; <span class="comment">//表示结构体native_handle_t所包含的整数值的个数，这些整数保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>]; <span class="comment">//指向的一块缓冲区中  </span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keyword">native_handle_t</span>* <span class="keyword">buffer_handle_t</span>;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-02-gralloc-hwt.png" alt="Alt text | center"></p><p>  下面就分析Gralloc模块中定义了两种设备的打开过程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-03-GRALLOC_HARDWARE.png" alt="Alt text | center"></p><h4 id="（二）、Fb设备打开过程"><a href="#（二）、Fb设备打开过程" class="headerlink" title="（二）、Fb设备打开过程"></a>（二）、Fb设备打开过程</h4><p>Fb设备打开过程是从SurfaceFlinger.init()函数通过HWComposer对象初始化过程中打开的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\services\surfaceflinger\SurfaceFlinger_hwc1.cpp]</span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">    <span class="comment">// initialize EGL for the default display</span></span><br><span class="line">    mEGLDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    eglInitialize(mEGLDisplay, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the EventThread</span></span><br><span class="line">    sp&lt;VSyncSource&gt; vsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            vsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"app"</span>);</span><br><span class="line">    mEventThread = <span class="keyword">new</span> EventThread(vsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    sp&lt;VSyncSource&gt; sfVsyncSrc = <span class="keyword">new</span> DispSyncSource(&amp;mPrimaryDispSync,</span><br><span class="line">            sfVsyncPhaseOffsetNs, <span class="literal">true</span>, <span class="string">"sf"</span>);</span><br><span class="line">    mSFEventThread = <span class="keyword">new</span> EventThread(sfVsyncSrc, *<span class="keyword">this</span>);</span><br><span class="line">    mEventQueue.setEventThread(mSFEventThread);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Initialize the H/W composer object.  There may or may not be an</span></span><br><span class="line">    <span class="comment">// actual hardware composer underneath.</span></span><br><span class="line">    mHwc = <span class="keyword">new</span> HWComposer(<span class="keyword">this</span>,</span><br><span class="line">            *<span class="keyword">static_cast</span>&lt;HWComposer::EventHandler *&gt;(<span class="keyword">this</span>));</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>看看HWComposer构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">HWComposer::HWComposer(</span><br><span class="line">        const sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(0), mHwc(0), mNumDisplays(1),</span><br><span class="line">      mCBContext(new cb_context),</span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(false)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    // Note: some devices may insist that the FB HAL be opened before HWC.</span><br><span class="line">    int fberr = loadFbHalModule();</span><br><span class="line">    loadHwcModule();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">int HWComposer::loadFbHalModule()</span><br><span class="line">&#123;</span><br><span class="line">    hw_module_t const* module;</span><br><span class="line"></span><br><span class="line">    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);</span><br><span class="line">    ......</span><br><span class="line">    return framebuffer_open(module, &amp;mFbDev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Android系统在硬件抽象层中提供了一个Gralloc模块，封装了对framebuffer的所有访问操作。Gralloc模块符合Android标准的HAL架构设计。Gralloc对应的hardware id为：GRALLOC_HARDWARE_MODULE_ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\fb.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">framebuffer_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">framebuffer_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>,</span><br><span class="line">            GRALLOC_HARDWARE_FB0, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户空间的应用程序在使用帧缓冲区之前，首先要加载Gralloc模块，并且获得一个gpu0设备(gralloc_device, modulename:GRALLOC_HARDWARE_GPU0)和一个fb0设备(modulename:GRALLOC_HARDWARE_FB0)。</p><p>有了alloc设备之后，用户空间中的应用程序就可以申请分配一块图形缓冲区，并且将这块图形缓冲区映射到应用程序的地址空间来，以便可以向里面写入要绘制的画面的内容。最后，用户空间中的应用程序就通过fb0设备来将已经准备好了的图形缓冲区渲染到帧缓冲区中去，即将图形缓冲区的内容绘制到显示屏中去。相应地，当用户空间中的应用程序不再需要使用一块图形缓冲区的时候，就可以通过alloc设备来释放它，并且将它从地址空间中解除映射。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gralloc.cpp]</span><br><span class="line"><span class="comment">// Open Gralloc device</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            <span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">gpu_context_t</span> *dev;</span><br><span class="line">        IAllocController* alloc_ctrl = IAllocController::getInstance();</span><br><span class="line">        dev = <span class="keyword">new</span> <span class="keyword">gpu_context_t</span>(m, alloc_ctrl);</span><br><span class="line">        <span class="keyword">if</span>(!dev)</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">        *device = &amp;dev-&gt;common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//GRALLOC_HARDWARE_FB0,</span></span><br><span class="line">        status = fb_device_open(<span class="keyword">module</span>, name, device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1、Fb设备打开过程fb-device-open"><a href="#2-1、Fb设备打开过程fb-device-open" class="headerlink" title="2.1、Fb设备打开过程fb_device_open()"></a>2.1、Fb设备打开过程fb_device_open()</h5><p>看下fb_device_open()函数实现过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fb_device_open</span><span class="params">(<span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_FB0)) &#123;</span><br><span class="line">        <span class="keyword">alloc_device_t</span>* gralloc_device;</span><br><span class="line">        <span class="comment">// 打开gralloc_device设备。GRALLOC_HARDWARE_GPU0</span></span><br><span class="line">        status = gralloc_open(<span class="keyword">module</span>, &amp;gralloc_device);</span><br><span class="line">        <span class="keyword">if</span> (status &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个fb_context_t对象，用来描述fb设备上下文  </span></span><br><span class="line">        <span class="keyword">fb_context_t</span> *dev = (<span class="keyword">fb_context_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*dev));</span><br><span class="line">        ......</span><br><span class="line">        <span class="built_in">memset</span>(dev, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dev));</span><br><span class="line">        <span class="comment">//初始化fb_context_t对象  </span></span><br><span class="line">        <span class="comment">/* initialize the procs */</span></span><br><span class="line">        dev-&gt;device.common.tag      = HARDWARE_DEVICE_TAG;</span><br><span class="line">        dev-&gt;device.common.version  = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.common.<span class="keyword">module</span>   = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">        <span class="comment">//注册fb设备的操作函数</span></span><br><span class="line">        dev-&gt;device.common.close    = fb_close;</span><br><span class="line">        dev-&gt;device.setSwapInterval = fb_setSwapInterval;</span><br><span class="line">        dev-&gt;device.post            = fb_post;</span><br><span class="line">        dev-&gt;device.setUpdateRect   = <span class="number">0</span>;</span><br><span class="line">        dev-&gt;device.compositionComplete = fb_compositionComplete;</span><br><span class="line">        <span class="comment">//将fb映射到当前进程地址空间 </span></span><br><span class="line">        status = mapFrameBuffer((<span class="keyword">framebuffer_device_t</span>*)dev);</span><br><span class="line">        <span class="keyword">private_module_t</span>* m = (<span class="keyword">private_module_t</span>*)dev-&gt;device.common.<span class="keyword">module</span>;</span><br><span class="line">        <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> stride = m-&gt;finfo.line_length / (m-&gt;info.bits_per_pixel &gt;&gt; <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.flags) = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span>&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.stride) = stride;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.format) = m-&gt;fbFormat;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">float</span>&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.minSwapInterval) =</span><br><span class="line">                                                        PRIV_MIN_SWAP_INTERVAL;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.maxSwapInterval) =</span><br><span class="line">                                                        PRIV_MAX_SWAP_INTERVAL;</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(dev-&gt;device.numFramebuffers) = m-&gt;numBuffers;</span><br><span class="line">            dev-&gt;device.setUpdateRect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            *device = &amp;dev-&gt;device.common;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Close the gralloc module</span></span><br><span class="line">        gralloc_close(gralloc_device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要是用来创建一个fb_context_t结构体，并且对它的成员变量device进行初始化。结构体fb_context_t的成员变量device的类型为framebuffer_device_t，它是用来描述fb设备的。fb设备主要是用来渲染图形缓冲区的，这是通过调用它的成员函数post来实现的。函数fb_device_open所打开的fb设备的成员函数post被设置为Gralloc模块中的函数fb_post。函数mapFrameBuffer除了用来获得系统帧缓冲区的信息之外，还会将系统帧缓冲区映射到当前进程的地址空间来。line_length用来描述显示屏一行像素总共所占用的字节数，bits_per_pixel用来描述显示屏每一个像素所占用的位数，bits_per_pixel的值向右移3位，就可以得到显示屏每一个像素所占用的字节数。用显示屏像素总共所占用的字节数line_length除以每一个像素所占用的字节数就可以得到显示屏一行有多少个像素点，并保存在stride中。</p><h5 id="2-2、Fb设备地址空间映射mapFrameBuffer"><a href="#2-2、Fb设备地址空间映射mapFrameBuffer" class="headerlink" title="2.2、Fb设备地址空间映射mapFrameBuffer()"></a>2.2、Fb设备地址空间映射mapFrameBuffer()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">mapFrameBuffer</span><span class="params">(<span class="keyword">framebuffer_device_t</span> *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> property[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span>((property_get(<span class="string">"debug.gralloc.map_fb_memory"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">       (!<span class="built_in">strncmp</span>(property, <span class="string">"1"</span>, PROPERTY_VALUE_MAX ) ||</span><br><span class="line">        (!strncasecmp(property,<span class="string">"true"</span>, PROPERTY_VALUE_MAX )))) &#123;</span><br><span class="line">        <span class="keyword">private_module_t</span>* <span class="keyword">module</span> =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line">        pthread_mutex_lock(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">        err = mapFrameBufferLocked(dev);</span><br><span class="line">        pthread_mutex_unlock(&amp;<span class="keyword">module</span>-&gt;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用mapFrameBufferLocked函数执行映射过程，该函数在线程保护下完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapFrameBufferLocked</span><span class="params">(<span class="keyword">framebuffer_device_t</span> *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* <span class="keyword">module</span> =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(dev-&gt;common.<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">fb_context_t</span> *ctx = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">fb_context_t</span>*&gt;(dev);</span><br><span class="line">    <span class="comment">// already initialized...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span>-&gt;framebuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> device_template[] = &#123;</span><br><span class="line">        <span class="string">"/dev/graphics/fb%u"</span>,</span><br><span class="line">        <span class="string">"/dev/fb%u"</span>,</span><br><span class="line">        <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">char</span> property[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="comment">//检查是否存在设备文件/dev/graphics/fb0或者/dev/fb0。如果存在的话，那么就调用函数open来打开它，并且将得到的文件描述符保存在变量fd中 </span></span><br><span class="line">    <span class="keyword">while</span> ((fd==<span class="number">-1</span>) &amp;&amp; device_template[i]) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(name, <span class="number">64</span>, device_template[i], <span class="number">0</span>);</span><br><span class="line">        fd = open(name, O_RDWR, <span class="number">0</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//通过IO控制命令FBIOGET_FSCREENINFO来获得系统帧缓冲区的固定信息，保存在fb_fix_screeninfo结构体finfo中  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_fix_screeninfo</span> <span class="title">finfo</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过IO控制命令FBIOGET_VSCREENINFO来获得系统帧缓冲区的可变信息，保存在fb_var_screeninfo结构体info中 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fb_var_screeninfo</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化info  </span></span><br><span class="line">    info.reserved[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    info.reserved[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    info.xoffset = <span class="number">0</span>;</span><br><span class="line">    info.yoffset = <span class="number">0</span>;</span><br><span class="line">    info.activate = FB_ACTIVATE_NOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interpretation of offset for color fields: All offsets are from the</span></span><br><span class="line"><span class="comment">     * right, inside a "pixel" value, which is exactly 'bits_per_pixel' wide</span></span><br><span class="line"><span class="comment">     * (means: you can use the offset as right argument to &lt;&lt;). A pixel</span></span><br><span class="line"><span class="comment">     * afterwards is a bit stream and is written to video memory as that</span></span><br><span class="line"><span class="comment">     * unmodified. This implies big-endian byte order if bits_per_pixel is</span></span><br><span class="line"><span class="comment">     * greater than 8.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(info.bits_per_pixel == <span class="number">32</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Explicitly request RGBA_8888</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        info.bits_per_pixel = <span class="number">32</span>;</span><br><span class="line">        info.red.offset     = <span class="number">24</span>;</span><br><span class="line">        info.red.length     = <span class="number">8</span>;</span><br><span class="line">        info.green.offset   = <span class="number">16</span>;</span><br><span class="line">        info.green.length   = <span class="number">8</span>;</span><br><span class="line">        info.blue.offset    = <span class="number">8</span>;</span><br><span class="line">        info.blue.length    = <span class="number">8</span>;</span><br><span class="line">        info.transp.offset  = <span class="number">0</span>;</span><br><span class="line">        info.transp.length  = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note: the GL driver does not have a r=8 g=8 b=8 a=0 config, so if we</span></span><br><span class="line"><span class="comment">         * do not use the MDP for composition (i.e. hw composition == 0), ask</span></span><br><span class="line"><span class="comment">         * for RGBA instead of RGBX. */</span></span><br><span class="line">        <span class="keyword">if</span> (property_get(<span class="string">"debug.sf.hw"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                                           atoi(property) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(property_get(<span class="string">"debug.composition.type"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (<span class="built_in">strncmp</span>(property, <span class="string">"mdp"</span>, <span class="number">3</span>) == <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBX_8888;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGBA_8888;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Explicitly request 5/6/5</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        info.bits_per_pixel = <span class="number">16</span>;</span><br><span class="line">        info.red.offset     = <span class="number">11</span>;</span><br><span class="line">        info.red.length     = <span class="number">5</span>;</span><br><span class="line">        info.green.offset   = <span class="number">5</span>;</span><br><span class="line">        info.green.length   = <span class="number">6</span>;</span><br><span class="line">        info.blue.offset    = <span class="number">0</span>;</span><br><span class="line">        info.blue.length    = <span class="number">5</span>;</span><br><span class="line">        info.transp.offset  = <span class="number">0</span>;</span><br><span class="line">        info.transp.length  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">module</span>-&gt;fbFormat = HAL_PIXEL_FORMAT_RGB_565;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adreno needs 4k aligned offsets. Max hole size is 4096-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = roundUpToPageSize(info.yres * info.xres *</span><br><span class="line">                                               (info.bits_per_pixel/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Request NUM_BUFFERS screens (at least 2 for page flipping)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> numberOfBuffers = (<span class="keyword">int</span>)(finfo.smem_len/size);</span><br><span class="line">    ALOGV(<span class="string">"num supported framebuffers in kernel = %d"</span>, numberOfBuffers);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"debug.gr.numframebuffers"</span>, property, <span class="literal">NULL</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> num = atoi(property);</span><br><span class="line">        <span class="keyword">if</span> ((num &gt;= NUM_FRAMEBUFFERS_MIN) &amp;&amp; (num &lt;= NUM_FRAMEBUFFERS_MAX)) &#123;</span><br><span class="line">            numberOfBuffers = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numberOfBuffers &gt; NUM_FRAMEBUFFERS_MAX)</span><br><span class="line">        numberOfBuffers = NUM_FRAMEBUFFERS_MAX;</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"We support %d buffers"</span>, numberOfBuffers);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//consider the included hole by 4k alignment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> line_length = (info.xres * info.bits_per_pixel / <span class="number">8</span>);</span><br><span class="line">    info.yres_virtual = (<span class="keyword">uint32_t</span>) ((size * numberOfBuffers) / line_length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = PAGE_FLIP;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.yres_virtual &lt; ((size * <span class="number">2</span>) / line_length) ) &#123;</span><br><span class="line">        <span class="comment">// we need at least 2 for page-flipping</span></span><br><span class="line">        info.yres_virtual = (<span class="keyword">int</span>)(size / line_length);</span><br><span class="line">        flags &amp;= ~PAGE_FLIP;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">int</span>(info.width) &lt;= <span class="number">0</span> || <span class="keyword">int</span>(info.height) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        info.width  = (<span class="keyword">uint32_t</span>)(((<span class="keyword">float</span>)(info.xres) * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);</span><br><span class="line">        info.height = (<span class="keyword">uint32_t</span>)(((<span class="keyword">float</span>)(info.yres) * <span class="number">25.4f</span>)/<span class="number">160.0f</span> + <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> xdpi = ((<span class="keyword">float</span>)(info.xres) * <span class="number">25.4f</span>) / (<span class="keyword">float</span>)info.width;</span><br><span class="line">    <span class="keyword">float</span> ydpi = ((<span class="keyword">float</span>)(info.yres) * <span class="number">25.4f</span>) / (<span class="keyword">float</span>)info.height;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过IO控制命令FBIOGET_VSCREENINFO来重新获得系统帧缓冲区的可变信息  </span></span><br><span class="line">    <span class="keyword">if</span> (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == <span class="number">-1</span>) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> -errno;</span><br><span class="line">    &#125;......</span><br><span class="line">    <span class="keyword">module</span>-&gt;flags = flags;</span><br><span class="line">    <span class="keyword">module</span>-&gt;info = info;</span><br><span class="line">    <span class="keyword">module</span>-&gt;finfo = finfo;</span><br><span class="line">    <span class="keyword">module</span>-&gt;xdpi = xdpi;</span><br><span class="line">    <span class="keyword">module</span>-&gt;ydpi = ydpi;</span><br><span class="line">    <span class="keyword">module</span>-&gt;fps = fps;</span><br><span class="line">    <span class="keyword">module</span>-&gt;swapInterval = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * map the framebuffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">module</span>-&gt;numBuffers = info.yres_virtual / info.yres;</span><br><span class="line">    <span class="keyword">module</span>-&gt;bufferMask = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">//整个系统帧缓冲区的大小=虚拟分辨率的高度值info.yres_virtual * 每一行所占用的字节数finfo.line_length,并将整个系统帧缓冲区的大小对齐到页面边界  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fbSize = roundUpToPageSize(finfo.line_length * info.yres)*</span><br><span class="line">                    <span class="keyword">module</span>-&gt;numBuffers;</span><br><span class="line">   <span class="comment">//系统帧缓冲区在当前进程的地址空间中的起始地址保存到private_handle_t的域base中  </span></span><br><span class="line">    <span class="keyword">void</span>* vaddr = mmap(<span class="number">0</span>, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//store the framebuffer fd in the ctx</span></span><br><span class="line">    ctx-&gt;fbFd = fd;</span><br><span class="line">   ......</span><br><span class="line">   <span class="comment">//创建一个private_handle_t，用来描述整个系统帧缓冲区的信息</span></span><br><span class="line">    <span class="comment">// Create framebuffer handle using the ION fd</span></span><br><span class="line">    <span class="keyword">module</span>-&gt;framebuffer = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(fd, fbSize,</span><br><span class="line">                                        <span class="keyword">private_handle_t</span>::PRIV_FLAGS_USES_ION,</span><br><span class="line">                                        BUFFER_TYPE_UI,</span><br><span class="line">                                        <span class="keyword">module</span>-&gt;fbFormat, info.xres, info.yres);</span><br><span class="line">    <span class="comment">//以读写共享方式将帧缓冲区映射到当前进程地址空间中 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">module</span>-&gt;framebuffer-&gt;base = <span class="keyword">uint64_t</span>(vaddr);</span><br><span class="line">    <span class="built_in">memset</span>(vaddr, <span class="number">0</span>, fbSize);</span><br><span class="line">    <span class="comment">//Enable vsync</span></span><br><span class="line">    <span class="keyword">int</span> enable = <span class="number">1</span>;</span><br><span class="line">    ioctl(ctx-&gt;fbFd, MSMFB_OVERLAY_VSYNC_CTRL, &amp;enable);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、GPU设备打开过程gralloc-open"><a href="#2-3、GPU设备打开过程gralloc-open" class="headerlink" title="2.3、GPU设备打开过程gralloc_open()"></a>2.3、GPU设备打开过程gralloc_open()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.h]</span><br><span class="line"><span class="comment">/** convenience API for opening and closing a supported device */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gralloc_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">        struct <span class="keyword">alloc_device_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, </span><br><span class="line">            GRALLOC_HARDWARE_GPU0, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终会走到gralloc_device_open()函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\include\hardware\gralloc.cpp]</span><br><span class="line"></span><br><span class="line"><span class="comment">// HAL module methods</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">gralloc_module_methods</span> = &#123;</span></span><br><span class="line">    .open = gralloc_device_open</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Open Gralloc device</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_device_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">hw_device_t</span>** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status = -EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, GRALLOC_HARDWARE_GPU0)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">private_module_t</span>*&gt;(</span><br><span class="line">            <span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">gpu_context_t</span> *dev;</span><br><span class="line">        IAllocController* alloc_ctrl = IAllocController::getInstance();</span><br><span class="line">        dev = <span class="keyword">new</span> <span class="keyword">gpu_context_t</span>(m, alloc_ctrl);</span><br><span class="line">        ......</span><br><span class="line">        *device = &amp;dev-&gt;common;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = fb_device_open(<span class="keyword">module</span>, name, device);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数主要是用来创建一个gpu_context_t 结构体，并且对它的成员变量device进行初始化。gpu_context_t类继承了alloc_device_t，并实现了alloc_device_t中的alloc，free等方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">gpu_context_t</span>::<span class="keyword">gpu_context_t</span>(<span class="keyword">const</span> <span class="keyword">private_module_t</span>* <span class="keyword">module</span>,</span><br><span class="line">                             IAllocController* alloc_ctrl ) :</span><br><span class="line">    mAllocCtrl(alloc_ctrl)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Zero out the alloc_device_t</span></span><br><span class="line">    <span class="built_in">memset</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">alloc_device_t</span>*&gt;(<span class="keyword">this</span>), <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">alloc_device_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the procs</span></span><br><span class="line">    common.tag     = HARDWARE_DEVICE_TAG;</span><br><span class="line">    common.version = <span class="number">0</span>;</span><br><span class="line">    common.<span class="keyword">module</span>  = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(&amp;<span class="keyword">module</span>-&gt;base.common);</span><br><span class="line">    common.close   = gralloc_close;</span><br><span class="line">    alloc          = gralloc_alloc;</span><br><span class="line">    <span class="built_in">free</span>           = gralloc_free;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是完成alloc_device_t参数的初始化。其成员函数alloc，free被设置成gralloc_alloc &amp; gralloc_free。自此，alloc设备的打开过程就分析完成了。<br>接下来，我们重点分析alloc_device_t中提供的几个关键函数。</p><h4 id="（三）、-Gralloc分配和释放Buffer"><a href="#（三）、-Gralloc分配和释放Buffer" class="headerlink" title="（三）、 Gralloc分配和释放Buffer"></a>（三）、 Gralloc分配和释放Buffer</h4><h5 id="3-1、Gralloc分配buffer"><a href="#3-1、Gralloc分配buffer" class="headerlink" title="3.1、Gralloc分配buffer"></a>3.1、Gralloc分配buffer</h5><p>先来回忆一下SurfacFlinger图形缓冲区创建过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GraphicBuffer::GraphicBuffer </span><br><span class="line">  -&gt; initSize </span><br><span class="line">    -&gt; GraphicBufferAllocator::alloc </span><br><span class="line">      -&gt; <span class="keyword">alloc_device_t</span>::alloc </span><br><span class="line">        -&gt; gralloc_alloc</span><br></pre></td></tr></table></figure><p>用户空间的应用程序用到的图形缓冲区是由Gralloc模块中的函数gralloc_alloc来分配的，这个函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc(<span class="keyword">alloc_device_t</span>* dev, <span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format,</span><br><span class="line">                                 <span class="keyword">int</span> usage, <span class="keyword">buffer_handle_t</span>* pHandle,</span><br><span class="line">                                 <span class="keyword">int</span>* pStride)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">gpu_context_t</span>* gpu = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">gpu_context_t</span>*&gt;(dev);</span><br><span class="line">    <span class="keyword">return</span> gpu-&gt;alloc_impl(w, h, format, usage, pHandle, pStride, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::alloc_impl(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> format, <span class="keyword">int</span> usage,</span><br><span class="line">                              <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span>* pStride,</span><br><span class="line">                              <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize) &#123;</span><br><span class="line">   </span><br><span class="line">    ......</span><br><span class="line">     <span class="comment">// 参数format用来描述要分配的图形缓冲区的颜色格式。这些格式定义在system/core/include/system/graphic.h中</span></span><br><span class="line">    <span class="keyword">if</span>(format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED ||</span><br><span class="line">       format == HAL_PIXEL_FORMAT_YCbCr_420_888) &#123;</span><br><span class="line">        <span class="keyword">if</span> (usage &amp; GRALLOC_USAGE_PRIVATE_ALLOC_UBWC)</span><br><span class="line">            grallocFormat = HAL_PIXEL_FORMAT_YCbCr_420_SP_VENUS_UBWC;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(usage &amp; GRALLOC_USAGE_HW_VIDEO_ENCODER)</span><br><span class="line">            grallocFormat = HAL_PIXEL_FORMAT_NV12_ENCODEABLE; <span class="comment">//NV12</span></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置buffertype，BUFFER_TYPE_UI: RGB formats &amp; HAL_PIXEL_FORMAT_R_8 &amp;HAL_PIXEL_FORMAT_RG_88。其他的都为BUFFER_TYPE_VIDEO</span></span><br><span class="line">    getGrallocInformationFromFormat(grallocFormat, &amp;bufferType);</span><br><span class="line">    <span class="comment">// 根据formate &amp; w，h算出buffersize</span></span><br><span class="line">    size = getBufferSizeAndDimensions(w, h, grallocFormat, usage, alignedw,</span><br><span class="line">                   alignedh);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    size = (bufferSize &gt;= size)? bufferSize : size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(useFbMem) &#123;</span><br><span class="line">        err = gralloc_alloc_framebuffer(usage, pHandle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = gralloc_alloc_buffer(size, usage, pHandle, bufferType,</span><br><span class="line">                                   grallocFormat, alignedw, alignedh);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    *pStride = alignedw;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后根据memory alloc出处，区别调用gralloc_alloc_framebuffer&amp;  gralloc_alloc_buffer函数。</p><p>首先来看看 gralloc_alloc_framebuffer的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc_framebuffer_locked(<span class="keyword">int</span> usage,</span><br><span class="line">                                                    <span class="keyword">buffer_handle_t</span>* pHandle)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 变量bufferMask用来描述系统帧缓冲区的使用情况</span></span><br><span class="line">    <span class="comment">// 变量numBuffers用来描述系统帧缓冲区可以划分为多少个图形缓冲区来使用</span></span><br><span class="line">    <span class="comment">// 变量bufferSize用来描述设备显示屏一屏内容所占用的内存的大小,同时高通的硬件要求4K对齐。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferMask = m-&gt;bufferMask;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> numBuffers = m-&gt;numBuffers;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//adreno needs FB size to be page aligned</span></span><br><span class="line">    bufferSize = roundUpToPageSize(bufferSize);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假设此时系统帧缓冲区中尚有空闲的图形缓冲区的，接下来函数就会创建一个private_handle_t结构体hnd来描述这个即将要分配出去的图形缓冲区。注意，这个图形缓冲区的标志值等于PRIV_FLAGS_FRAMEBUFFER，即表示这是一块在系统帧缓冲区中分配的图形缓冲区。</span></span><br><span class="line">    <span class="keyword">uint64_t</span> vaddr = <span class="keyword">uint64_t</span>(m-&gt;framebuffer-&gt;base);</span><br><span class="line">    <span class="comment">// As GPU needs ION FD, the private handle is created</span></span><br><span class="line">    <span class="comment">// using ION fd and ION flags are set</span></span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(</span><br><span class="line">        dup(m-&gt;framebuffer-&gt;fd), bufferSize,</span><br><span class="line">        <span class="keyword">private_handle_t</span>::PRIV_FLAGS_USES_ION |</span><br><span class="line">        <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER,</span><br><span class="line">        BUFFER_TYPE_UI, m-&gt;fbFormat, m-&gt;info.xres,</span><br><span class="line">        m-&gt;info.yres);</span><br><span class="line">    <span class="comment">//  接下来的for循环从低位到高位检查变量bufferMask的值，并且找到第一个值等于0的位，这样就可以知道在系统帧缓冲区中，第几个图形缓冲区的是空闲的。注意，变量vadrr的值开始的时候指向系统帧缓冲区的基地址，在下面的for循环中，每循环一次它的值都会增加bufferSize。从这里就可以看出，每次从系统帧缓冲区中分配出去的图形缓冲区的大小都是刚好等于显示屏一屏内容大小的。</span></span><br><span class="line">    <span class="comment">// find a free slot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span> ; i&lt;numBuffers ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((bufferMask &amp; (<span class="number">1L</span>U&lt;&lt;i)) == <span class="number">0</span>) &#123;</span><br><span class="line">            m-&gt;bufferMask |= (<span class="keyword">uint32_t</span>)(<span class="number">1L</span>U&lt;&lt;i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vaddr += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line">    / 将分配的缓冲区的开始地址保存到变量base中，这样用户控件的应用程序可以直接将需要渲染的图形内容拷贝到这个地址上。这样，就相当于是直接将图形渲染到系统帧缓冲区中去。</span><br><span class="line"><span class="comment">// offset表示分配到的图形缓冲区的起始地址正对于系统帧缓冲区基地址的偏移量。</span></span><br><span class="line">    hnd-&gt;base = vaddr;</span><br><span class="line">    hnd-&gt;offset = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(vaddr - m-&gt;framebuffer-&gt;base);</span><br><span class="line">    *pHandle = hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc_framebuffer(<span class="keyword">int</span> usage,</span><br><span class="line">                                             <span class="keyword">buffer_handle_t</span>* pHandle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(common.<span class="keyword">module</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">int</span> err = gralloc_alloc_framebuffer_locked(usage, pHandle);</span><br><span class="line">    pthread_mutex_unlock(&amp;m-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面分析了从framebuffer中分配图形缓冲区的过程。总结下这块buffer的来历。首先在fb设备open的时候，通过mmap从fb0中映射一块内存到用户空间，即一个内存池（module-&gt;framebuffer)，通过bufferMask来表示该池中内存的使用情况。而alloc做的事情，就是从这个内存池中找到一个空闲的区块，然后返回该区块的hanlder指针pHandle。</p><p>我们现在来看看从内存中分配图形缓冲区的情况。从Android 4.0开始，Android启动新的内存管理方式ION，以取代PMEM。PMEM需要一个连续的物理内存，同时需要在系统启动的时候，就完成分配。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\gpu.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::gralloc_alloc_buffer(<span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">int</span> usage,</span><br><span class="line">                                        <span class="keyword">buffer_handle_t</span>* pHandle, <span class="keyword">int</span> bufferType,</span><br><span class="line">                                        <span class="keyword">int</span> format, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">    size = roundUpToPageSize(size);</span><br><span class="line">    <span class="comment">// 首先分配一个data区域</span></span><br><span class="line">    alloc_data data;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 追查代码可以知道mallocCtrl指向IonController对象，关键代码可以参考hardware/qrom/display/msm8974/libgralloc/alloc_controller.cpp。具体怎么从ion中分配buffer</span></span><br><span class="line">    data.size = size;</span><br><span class="line">    data.pHandle = (<span class="keyword">uintptr_t</span>) pHandle;</span><br><span class="line">    err = mAllocCtrl-&gt;allocate(data, usage);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        <span class="comment">/* allocate memory for enhancement data */</span></span><br><span class="line">        alloc_data eData;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> eDataErr = mAllocCtrl-&gt;allocate(eData, eDataUsage);</span><br><span class="line">        ......</span><br><span class="line">        flags |= data.allocType;</span><br><span class="line">        <span class="keyword">uint64_t</span> eBaseAddr = (<span class="keyword">uint64_t</span>)(eData.base) + eData.offset;</span><br><span class="line">        <span class="keyword">private_handle_t</span> *hnd = <span class="keyword">new</span> <span class="keyword">private_handle_t</span>(data.fd, size, flags,</span><br><span class="line">                bufferType, format, width, height, eData.fd, eData.offset,</span><br><span class="line">                eBaseAddr);</span><br><span class="line"></span><br><span class="line">        hnd-&gt;offset = data.offset;</span><br><span class="line">        hnd-&gt;base = (<span class="keyword">uint64_t</span>)(data.base) + data.offset;</span><br><span class="line">        hnd-&gt;gpuaddr = <span class="number">0</span>;</span><br><span class="line">        ColorSpace_t colorSpace = ITU_R_601;</span><br><span class="line">        setMetaData(hnd, UPDATE_COLOR_SPACE, (<span class="keyword">void</span>*) &amp;colorSpace);</span><br><span class="line"></span><br><span class="line">        *pHandle = hnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGE_IF(err, <span class="string">"gralloc failed err=%s"</span>, strerror(-err));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2、Gralloc释放buffer"><a href="#3-2、Gralloc释放buffer" class="headerlink" title="3.2、Gralloc释放buffer"></a>3.2、Gralloc释放buffer</h5><p>释放buffer本质是调用gralloc_free函数，该函数又调用了free_impl函数。在处理free buffer的时候，也是按照两种情况来分别处理的。如果之前这个buffer是从framebuffer分配的话，就只要把bufferMask中设置成0即可。而对应从内存中申请的，则是调用allocCtrl（ion）中的free_buffer来完成释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\display\msm8996\libgralloc\framebuffer.cpp]</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">gpu_context_t</span>::free_impl(<span class="keyword">private_handle_t</span> <span class="keyword">const</span>* hnd) &#123;</span><br><span class="line">    <span class="keyword">private_module_t</span>* m = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">private_module_t</span>*&gt;(common.<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> index = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) ((hnd-&gt;base - m-&gt;framebuffer-&gt;base)</span><br><span class="line">                / bufferSize);</span><br><span class="line">        m-&gt;bufferMask &amp;= (<span class="keyword">uint32_t</span>)~(<span class="number">1L</span>U&lt;&lt;index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        terminateBuffer(&amp;m-&gt;base, <span class="keyword">const_cast</span>&lt;<span class="keyword">private_handle_t</span>*&gt;(hnd));</span><br><span class="line">        IMemAlloc* memalloc = mAllocCtrl-&gt;getAllocator(hnd-&gt;flags);</span><br><span class="line">        <span class="keyword">int</span> err = memalloc-&gt;free_buffer((<span class="keyword">void</span>*)hnd-&gt;base, hnd-&gt;size,</span><br><span class="line">                                        hnd-&gt;offset, hnd-&gt;fd);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        <span class="comment">// free the metadata space</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> size = ROUND_UP_PAGESIZE(<span class="keyword">sizeof</span>(MetaData_t));</span><br><span class="line">        err = memalloc-&gt;free_buffer((<span class="keyword">void</span>*)hnd-&gt;base_metadata,</span><br><span class="line">                                    size, hnd-&gt;offset_metadata,</span><br><span class="line">                                    hnd-&gt;fd_metadata);</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> hnd;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、图形缓冲区映射过程"><a href="#（四）、图形缓冲区映射过程" class="headerlink" title="（四）、图形缓冲区映射过程"></a>（四）、图形缓冲区映射过程</h4><p> 图形缓冲区可以从系统帧缓冲区分配也可以从内存中分配，分配一个图形缓冲区后还需要将该图形缓冲区映射到分配该buffer的进程地址空间来，在Android系统中，图形缓冲区的管理由SurfaceFlinger服务来负责。在系统帧缓冲区中分配的图形缓冲区是在SurfaceFlinger服务中使用，而在内存中分配的图形缓冲区既可以在SurfaceFlinger服务中使用，也可以在其它的应用程序中使用。当其它的应用程序需要使用图形缓冲区的时候，它们就会请求SurfaceFlinger服务为它们分配并将SurfaceFlinger服务返回来的图形缓冲区映射到应用程序进程地址空间。在从内存中分配buffer时，已经将分配的buffer映射到了SurfaceFlinger服务进程地址空间，如果该buffer是应用程序请求SurfaceFlinger服务为它们分配的，那么还需要将SurfaceFlinger服务返回来的图形缓冲区映射到应用程序进程地址空间。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-04-grallocbuffer.jpg" alt="Alt text | center"></p><p>一个对象要在进程间传输必须继承于Flattenable类，并且实现flatten和unflatten方法，flatten方法用于序列化该对象，unflatten方法用于反序列化对象。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-05-graphicbuffer-flatten.jpg" alt="Alt text | center"></p><p>GraphicBuffer类从模板类Flattenable派生，这个派生类可以通过Parcel传递，通常派生类需要重载flatten和unflatten方法，用于对象的序列化和反序列化。</p><p>1）将一个对象写入到Parcel中，需要使用flatten函数序列化该对象，我们先来看下flatten函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\ui\GraphicBuffer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> GraphicBuffer::flatten(<span class="keyword">void</span>*&amp; buffer, <span class="keyword">size_t</span>&amp; size, <span class="keyword">int</span>*&amp; fds, <span class="keyword">size_t</span>&amp; count) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">size_t</span> sizeNeeded = GraphicBuffer::getFlattenedSize();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; sizeNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> fdCountNeeded = GraphicBuffer::getFdCount();</span><br><span class="line">    <span class="keyword">if</span> (count &lt; fdCountNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span>* buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>*&gt;(buffer);</span><br><span class="line">    buf[0] = 'GBFR';</span><br><span class="line">    buf[<span class="number">1</span>] = width;</span><br><span class="line">    buf[<span class="number">2</span>] = height;</span><br><span class="line">    buf[<span class="number">3</span>] = stride;</span><br><span class="line">    buf[<span class="number">4</span>] = format;</span><br><span class="line">    buf[<span class="number">5</span>] = usage;</span><br><span class="line">    buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(mId &gt;&gt; <span class="number">32</span>);</span><br><span class="line">    buf[<span class="number">7</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(mId &amp; <span class="number">0xFFFFFFFF</span>ull);</span><br><span class="line">    buf[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">9</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        buf[<span class="number">8</span>] = handle-&gt;numFds;</span><br><span class="line">        buf[<span class="number">9</span>] = handle-&gt;numInts;</span><br><span class="line">        <span class="keyword">native_handle_t</span> <span class="keyword">const</span>* <span class="keyword">const</span> h = handle;</span><br><span class="line">        <span class="comment">//把handle中的data复制到fds中 </span></span><br><span class="line">        <span class="built_in">memcpy</span>(fds,     h-&gt;data,             h-&gt;numFds*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;buf[<span class="number">10</span>], h-&gt;data + h-&gt;numFds, h-&gt;numInts*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        fds += handle-&gt;numFds;</span><br><span class="line">        count -= handle-&gt;numFds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个handle类型为native_handle_t ，且typedef成了buffer_handle_t，我们贴一下它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/system/core/include/cutils/native_handle.h]</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">native_handle</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> version; <span class="comment">//设置为结构体native_handle_t的大小，用来标识结构体native_handle_t的版本  </span></span><br><span class="line">    <span class="keyword">int</span> numFds;  <span class="comment">//表示结构体native_handle_t所包含的文件描述符的个数，这些文件描述符保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> numInts; <span class="comment">//表示结构体native_handle_t所包含的整数值的个数，这些整数保存在成员变量data所指向的一块缓冲区中。  </span></span><br><span class="line">    <span class="keyword">int</span> data[<span class="number">0</span>]; <span class="comment">//指向的一块缓冲区中  </span></span><br><span class="line">&#125; <span class="keyword">native_handle_t</span>;</span><br></pre></td></tr></table></figure><p> 所以我们回到flatten函数中，fds参数用来传递文件句柄，函数把handle中的表示指向图形缓冲区文件描述符句柄复制到fds中，因此这些句柄就能通过binder传递到目标进程中去。</p><p>2）在应用程序读取来自服务进程的GraphicBuffer对象时，也就是result = reply.read(*p)，会调用GraphicBuffer类的unflatten函数进行反序列化过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\ui\GraphicBuffer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> GraphicBuffer::unflatten(</span><br><span class="line">        <span class="keyword">void</span> <span class="keyword">const</span>*&amp; buffer, <span class="keyword">size_t</span>&amp; size, <span class="keyword">int</span> <span class="keyword">const</span>*&amp; fds, <span class="keyword">size_t</span>&amp; count) &#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; <span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>* buf = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> <span class="keyword">const</span>*&gt;(buffer);</span><br><span class="line">    if (buf[0] != 'GBFR') return BAD_TYPE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> numFds  = buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> numInts = buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> sizeNeeded = (<span class="number">10</span> + numInts) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">if</span> (size &lt; sizeNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> fdCountNeeded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; fdCountNeeded) <span class="keyword">return</span> NO_MEMORY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        <span class="comment">// free previous handle if any</span></span><br><span class="line">        free_handle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numFds || numInts) &#123;</span><br><span class="line">        width  = buf[<span class="number">1</span>];</span><br><span class="line">        height = buf[<span class="number">2</span>];</span><br><span class="line">        stride = buf[<span class="number">3</span>];</span><br><span class="line">        format = buf[<span class="number">4</span>];</span><br><span class="line">        usage  = buf[<span class="number">5</span>];</span><br><span class="line">        <span class="comment">//创建一个native_handle对象</span></span><br><span class="line">        native_handle* h = native_handle_create(numFds, numInts);</span><br><span class="line">        <span class="comment">//将fds复制到native_handle对象的data中，和flatten操作相反</span></span><br><span class="line">        <span class="built_in">memcpy</span>(h-&gt;data,          fds,     numFds*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="built_in">memcpy</span>(h-&gt;data + numFds, &amp;buf[<span class="number">10</span>], numInts*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        handle = h;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        width = height = stride = format = usage = <span class="number">0</span>;</span><br><span class="line">        handle = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mId = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(buf[<span class="number">6</span>]) &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    mId |= <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(buf[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">    mOwner = ownHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//使用GraphicBufferMapper将服务端创建的图形缓冲区映射到当前进程地址空间  </span></span><br><span class="line">        <span class="keyword">status_t</span> err = mBufferMapper.registerBuffer(handle);</span><br><span class="line">        <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">            width = height = stride = format = usage = <span class="number">0</span>;</span><br><span class="line">            handle = <span class="literal">NULL</span>;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> <span class="keyword">const</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span> <span class="keyword">const</span>*&gt;(buffer) + sizeNeeded);</span><br><span class="line">    size -= sizeNeeded;</span><br><span class="line">    fds += numFds;</span><br><span class="line">    count -= numFds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用unflatten函数时，共享区的文件句柄已经准备好了，但是内存还没有进行映射，调用了mBufferMapper.registerBuffer函数来进行内存映射。</p><h5 id="4-1、图形缓冲区的注册过程"><a href="#4-1、图形缓冲区的注册过程" class="headerlink" title="4.1、图形缓冲区的注册过程"></a>4.1、图形缓冲区的注册过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> GraphicBufferMapper::registerBuffer(<span class="keyword">const</span> GraphicBuffer* buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">gralloc1_error_t</span> error = mDevice-&gt;retain(buffer);</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用了mDevice-&gt;retain(buffer)函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\ui\Gralloc1On0Adapter.cpp]</span><br><span class="line"><span class="keyword">gralloc1_error_t</span> Gralloc1On0Adapter::retain(</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Buffer&gt;&amp; buffer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mBufferMutex);</span><br><span class="line">    buffer-&gt;retain();</span><br><span class="line">    <span class="keyword">return</span> GRALLOC1_ERROR_NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">gralloc1_error_t</span> Gralloc1On0Adapter::retain(</span><br><span class="line">        <span class="keyword">const</span> android::GraphicBuffer* graphicBuffer)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">buffer_handle_t</span> handle = graphicBuffer-&gt;getNativeBuffer()-&gt;handle;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mBufferMutex);</span><br><span class="line"></span><br><span class="line">    ALOGV(<span class="string">"Calling registerBuffer(%p)"</span>, handle);</span><br><span class="line">    <span class="keyword">int</span> result = mModule-&gt;registerBuffer(mModule, handle);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过一系列步骤的调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/display/msm8996/libgralloc/mapper.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gralloc_register_buffer</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">buffer_handle_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> err =  gralloc_map(<span class="keyword">module</span>, handle);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gralloc_map</span><span class="params">(<span class="keyword">gralloc_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">buffer_handle_t</span> handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private_handle_t</span>* hnd = (<span class="keyword">private_handle_t</span>*)handle;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    IMemAlloc* memalloc = getAllocator(hnd-&gt;flags) ;</span><br><span class="line">    <span class="keyword">void</span> *mappedAddress = MAP_FAILED;</span><br><span class="line">    hnd-&gt;base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dont map framebuffer and secure buffers</span></span><br><span class="line">    <span class="keyword">if</span> (!(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_FRAMEBUFFER) &amp;&amp;</span><br><span class="line">        !(hnd-&gt;flags &amp; <span class="keyword">private_handle_t</span>::PRIV_FLAGS_SECURE_BUFFER)) &#123;</span><br><span class="line">        size = hnd-&gt;size;</span><br><span class="line">        err = memalloc-&gt;map_buffer(&amp;mappedAddress, size,</span><br><span class="line">                                       hnd-&gt;offset, hnd-&gt;fd);</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        hnd-&gt;base = <span class="keyword">uint64_t</span>(mappedAddress) + hnd-&gt;offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = -EACCES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Allow mapping of metadata for all buffers including secure ones, but not</span></span><br><span class="line">    <span class="comment">//of framebuffer</span></span><br><span class="line">    <span class="keyword">int</span> metadata_err = gralloc_map_metadata(handle);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/display/msm8996/libgralloc/ionalloc.cpp]</span><br><span class="line"><span class="keyword">int</span> IonAlloc::map_buffer(<span class="keyword">void</span> **pBase, <span class="keyword">unsigned</span> <span class="keyword">int</span> size, <span class="keyword">unsigned</span> <span class="keyword">int</span> offset,</span><br><span class="line">        <span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">int</span> err = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> *base = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// It is a (quirky) requirement of ION to have opened the</span></span><br><span class="line">    <span class="comment">// ion fd in the process that is doing the mapping</span></span><br><span class="line">    err = open_device(); </span><br><span class="line">    ......</span><br><span class="line">    base = mmap(<span class="number">0</span>, size, PROT_READ| PROT_WRITE,</span><br><span class="line">                MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    *pBase = base;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数就是调用了mmap来进行共享内存的映射。</p><h5 id="4-2、图形缓冲区的释放过程"><a href="#4-2、图形缓冲区的释放过程" class="headerlink" title="4.2、图形缓冲区的释放过程"></a>4.2、图形缓冲区的释放过程</h5><p>释放过程调用流程类似，最后会调用unmap_buffer()释放图像缓冲区。</p><h5 id="4-3、小结"><a href="#4-3、小结" class="headerlink" title="4.3、小结"></a>4.3、小结</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-04-06-sf-app-dup-mmap.png" alt="Alt text | center"></p><h4 id="（五）HWComposer模块"><a href="#（五）HWComposer模块" class="headerlink" title="（五）HWComposer模块"></a>（五）HWComposer模块</h4><p>前面分析HWComposer构造函数没有分析loadHwcModule()函数，<br>loadHwcModule()函数用来加载HWC模块，我们继续查看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[E-&gt;\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer_hwc1.cpp]</span><br><span class="line">HWComposer::HWComposer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;SurfaceFlinger&gt;&amp; flinger,</span><br><span class="line">        EventHandler&amp; handler)</span><br><span class="line">    : mFlinger(flinger),</span><br><span class="line">      mFbDev(<span class="number">0</span>), mHwc(<span class="number">0</span>), mNumDisplays(<span class="number">1</span>),</span><br><span class="line">      mCBContext(<span class="keyword">new</span> cb_context),<span class="comment">//这里直接new了一个设备上下文对象</span></span><br><span class="line">      mEventHandler(handler),</span><br><span class="line">      mDebugForceFakeVSync(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//装载HWComposer的硬件模块,这个函数中会将mHwc置为true</span></span><br><span class="line">    loadHwcModule();</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//硬件vsync信号</span></span><br><span class="line">    <span class="keyword">if</span> (mHwc) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Using %s version %u.%u"</span>, HWC_HARDWARE_COMPOSER,</span><br><span class="line">              (hwcApiVersion(mHwc) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,</span><br><span class="line">              (hwcApiVersion(mHwc) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">        <span class="keyword">if</span> (mHwc-&gt;registerProcs) &#123;</span><br><span class="line">            <span class="comment">//HWComposer设备上下文变量mCBContext赋值</span></span><br><span class="line">            mCBContext-&gt;hwc = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//函数指针钩子函数hook_invalidate放入上下文</span></span><br><span class="line">            mCBContext-&gt;procs.invalidate = &amp;hook_invalidate;</span><br><span class="line">            <span class="comment">//vsync钩子函数放入上下文</span></span><br><span class="line">            mCBContext-&gt;procs.vsync = &amp;hook_vsync;</span><br><span class="line">            <span class="keyword">if</span> (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))</span><br><span class="line">                <span class="comment">//hotplug狗子函数放入上下文</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = &amp;hook_hotplug;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mCBContext-&gt;procs.hotplug = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">memset</span>(mCBContext-&gt;procs.zero, <span class="number">0</span>, <span class="keyword">sizeof</span>(mCBContext-&gt;procs.zero));</span><br><span class="line">            <span class="comment">//将钩子函数注册进硬件设备，硬件驱动回调这些钩子函数</span></span><br><span class="line">            mHwc-&gt;registerProcs(mHwc, &amp;mCBContext-&gt;procs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't need a vsync thread if we have a hardware composer</span></span><br><span class="line">        <span class="comment">//如果有硬件vsync信号， 则不需要软件vsync实现</span></span><br><span class="line">        needVSyncThread = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Load and prepare the hardware composer module.  Sets mHwc.</span></span><br><span class="line"><span class="keyword">void</span> HWComposer::loadHwcModule()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">hw_module_t</span> <span class="keyword">const</span>* <span class="keyword">module</span>;</span><br><span class="line">    <span class="comment">//同样是HAL层封装的函数，参数是HWC_HARDWARE_MODULE_ID，加载hwc模块</span></span><br><span class="line">    <span class="keyword">if</span> (hw_get_module(HWC_HARDWARE_MODULE_ID, &amp;<span class="keyword">module</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开hwc设备</span></span><br><span class="line">    <span class="keyword">int</span> err = hwc_open_1(<span class="keyword">module</span>, &amp;mHwc);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果硬件设备打开成功，则将钩子函数hook_invalidate、hook_vsync和hook_hotplug注册进硬件设备，作为回调函数。这三个都是硬件产生事件信号，通知上层SurfaceFlinger的回调函数，用于处理这个信号。</p><p>因为我们本节是Vsync信号相关，所以我们只看看hook_vsync钩子函数。这里指定了vsync的回调函数是hook_vsync，如果硬件中产生了VSync信号，将通过这个函数来通知上层，看看它的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[E-&gt;\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer_hwc1.cpp]</span><br><span class="line"><span class="keyword">void</span> HWComposer::hook_vsync(<span class="keyword">const</span> struct hwc_procs* procs, <span class="keyword">int</span> disp,</span><br><span class="line">        <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    cb_context* ctx = <span class="keyword">reinterpret_cast</span>&lt;cb_context*&gt;(</span><br><span class="line">            <span class="keyword">const_cast</span>&lt;<span class="keyword">hwc_procs_t</span>*&gt;(procs));</span><br><span class="line">    ctx-&gt;hwc-&gt;vsync(disp, timestamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  hook_vsync钩子函数会调用vsync函数，我们继续看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[E-&gt;\frameworks\native\services\surfaceflinger\DisplayHardware\HWComposer_hwc1.cpp]</span><br><span class="line"><span class="keyword">void</span> HWComposer::vsync(<span class="keyword">int</span> disp, <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">uint32_t</span>(disp) &lt; HWC_NUM_PHYSICAL_DISPLAY_TYPES) &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line">            mLastHwVSync[disp] = timestamp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> tag[<span class="number">16</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(tag, <span class="keyword">sizeof</span>(tag), <span class="string">"HW_VSYNC_%1u"</span>, disp);</span><br><span class="line">        ATRACE_INT(tag, ++mVSyncCounts[disp] &amp; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里调用EventHandler类型变量mEventHandler就是SurfaceFlinger，</span></span><br><span class="line">        <span class="comment">//所以调用了SurfaceFlinger的onVSyncReceived函数</span></span><br><span class="line">        mEventHandler.onVSyncReceived(disp, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mEventHandler对象类型为EventHandler，我们在SurfaceFlinger的init函数创建HWComposer类实例时候讲SurfaceFlinger强转为EventHandler作为构造函数的参数传入其中。再者SurfaceFlinger继承HWComposer::EventHandler，所以最终会调用SurfaceFlinger的onVSyncReceived函数，这就是硬件vsync信号的产生。</p><h5 id="5-1、HWC设备打开过程"><a href="#5-1、HWC设备打开过程" class="headerlink" title="5.1、HWC设备打开过程"></a>5.1、HWC设备打开过程</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/libhardware/include/hardware/hwcomposer.h]</span><br><span class="line"><span class="comment">/** convenience API for opening and closing a device */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">hwc_open_1</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">hwc_composer_device_1_t</span>** device)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>,</span><br><span class="line">            HWC_HARDWARE_COMPOSER, (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现/hardware/qcom/display/msm8996/sdm/libs/hwc/ or /hardware/qcom/display/msm8996/sdm/libs/hwc2/。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/display/msm8996/sdm/libs/hwc/hwc_session.h]</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">HWCModuleMethods</span> :</span> <span class="keyword">public</span> <span class="keyword">hw_module_methods_t</span> &#123;</span><br><span class="line">    HWCModuleMethods() &#123;</span><br><span class="line">      <span class="keyword">hw_module_methods_t</span>::open = HWCSession::Open;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">[-&gt;/hardware/qcom/display/msm8996/sdm/libs/hwc/hwc_session.cpp]</span><br><span class="line"><span class="keyword">int</span> HWCSession::Open(<span class="keyword">const</span> <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">hw_device_t</span> **device) &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, HWC_HARDWARE_COMPOSER)) &#123;</span><br><span class="line">    HWCSession *hwc_session = <span class="keyword">new</span> HWCSession(<span class="keyword">module</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status = hwc_session-&gt;Init();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">hwc_composer_device_1_t</span> *composer_device = hwc_session;</span><br><span class="line">    *device = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hw_device_t</span> *&gt;(composer_device);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWCSession::HWCSession(<span class="keyword">const</span> <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>) &#123;</span><br><span class="line">  <span class="comment">// By default, drop any events. Calls will be routed to SurfaceFlinger after registerProcs.</span></span><br><span class="line">  hwc_procs_default_.invalidate = Invalidate;</span><br><span class="line">  hwc_procs_default_.vsync = VSync;</span><br><span class="line">  hwc_procs_default_.hotplug = Hotplug;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.version = HWC_DEVICE_API_VERSION_1_5;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.<span class="keyword">module</span> = <span class="keyword">const_cast</span>&lt;<span class="keyword">hw_module_t</span>*&gt;(<span class="keyword">module</span>);</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::common.close = Close;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::prepare = Prepare;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::<span class="built_in">set</span> = Set;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::eventControl = EventControl;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::setPowerMode = SetPowerMode;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::query = Query;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::registerProcs = RegisterProcs;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::dump = Dump;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::getDisplayConfigs = GetDisplayConfigs;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::getDisplayAttributes = GetDisplayAttributes;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::getActiveConfig = GetActiveConfig;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::setActiveConfig = SetActiveConfig;</span><br><span class="line">  <span class="keyword">hwc_composer_device_1_t</span>::setCursorPositionAsync = SetCursorPositionAsync;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/putiancaijunyu/article/category/2558539" target="_blank" rel="noopener"> Android研究 Gralloc &amp;&amp; HWComposer系列分析</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">Android Display 系列分析</a><br><a href="https://blog.csdn.net/honour2sword/article/details/12004289" target="_blank" rel="noopener">Android display: framebuffer 映射关系</a><br><a href="https://blog.csdn.net/honour2sword/article/details/38265879" target="_blank" rel="noopener">Android display框架与数据流</a><br><a href="https://blog.csdn.net/yangwen123/article/details/12192401" target="_blank" rel="noopener">Android图形显示之硬件抽象层Gralloc</a><br><a href="https://www.jianshu.com/p/af5858c06d5d" target="_blank" rel="noopener">SurfaceFlinger中Buffer的创建与显示</a><br><a href="https://www.wolfcstech.com/2017/09/21/android_graphics_gralloc/" target="_blank" rel="noopener">Android 图形系统之gralloc</a><br><a href="https://blog.csdn.net/yangwen123/article/category/1647761" target="_blank" rel="noopener">深入剖析Android系统 显示模块</a><br><a href="http://windrunnerlihuan.com/" target="_blank" rel="noopener">Android SurfaceFlinger 学习之路</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（3）：Android Display System 系统分析 之  HardwareRenderer.draw()绘制流程分析</title>
    <link href="http://zhoujinjian.cc/2018/08/01/Android%20Display%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BHardwareRenderer.draw%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/08/01/Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw绘制流程分析/</id>
    <published>2018-07-31T16:00:00.000Z</published>
    <updated>2018-06-20T15:11:18.995Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/luoshengyang/article/details/45601143" target="_blank" rel="noopener">【特别感谢 - Android应用程序UI硬件加速渲染技术简要介绍和学习计划】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">【特别感谢 - Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)】</a><br><a href="https://www.jianshu.com/p/7bf306c09c7e" target="_blank" rel="noopener">【特别感谢 - Android DisplayList 构建过程】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】 </p><hr><p>\frameworks\base\core\java\android\view\</p><ul><li>ViewRootImpl.java</li><li>RenderNode.java</li><li>View.java</li><li>DisplayListCanvas.java</li></ul><p>\frameworks\base\core\jni\</p><ul><li>android_view_DisplayListCanvas.cpp</li><li>android_view_RenderNode.cpp</li><li>android_view_ThreadedRenderer.cpp</li><li>android_view_Surface.cpp</li><li>android_server_AssetAtlasService.cpp</li></ul><p>\frameworks\base\core\jni\android\graphics\</p><ul><li>Graphics.cpp</li><li>Bitmap.cpp</li></ul><p>\frameworks\base\libs\hwui\</p><ul><li>AssetAtlas.cpp</li><li>BakedOpDispatcher.cpp</li><li>BakedOpRenderer.cpp</li><li>DeferredDisplayList.cpp</li><li>DeferredLayerUpdater.cpp</li><li>DisplayList.cpp</li><li>DisplayListCanvas.cpp</li><li>LayerBuilder.cpp</li><li>LayerRenderer.cpp</li><li>LayerUpdateQueue.cpp</li><li>Patch.cpp</li><li>RecordingCanvas.cpp</li><li>RenderNode.cpp</li></ul><p>\frameworks\base\libs\hwui\hwui\</p><ul><li>Canvas.cpp</li></ul><p>\frameworks\base\libs\hwui\renderthread\</p><ul><li>EglManager.cpp</li><li>CanvasContext.cpp</li><li>DrawFrameTask.cpp</li><li>RenderProxy.cpp</li><li>RenderTask.cpp</li><li>RenderThread.cpp</li></ul><hr><p>UI作为用户体验的核心之一，始终是Android每次升级中的重点。从Androd 3.0(Honeycomb)开始，Android开始支持hwui（UI硬件加速）。到Android 4.0（ICS）时，硬件加速被默认开启。同时ICS还引入了DisplayList的概念（不是OpenGL里的那个），它相当于是从View的绘制命令到GL命令之间的“中间语言”。它记录了绘制该View所需的全部信息，之后只要重放（replay）即可完成内容的绘制。这样如果View没有改动或只部分改动，便可重用或修改DisplayList，从而避免调用了一些上层代码，提高了效率。Android 4.3（JB）中引入了DisplayList的defer操作，它主要用于对DisplayList中命令进行Batch（批次）和Merge（合并）。这样可以减少GL draw call和context切换以提高效率。之后，在Android 5.0（Lollipop）中又引入了RenderNode（渲染节点）的概念，它是对DisplayList及一些View显示属性的进一步封装。代码上，一个View对应一个RenderNode（Native层对应同名类），其中管理着对应的DisplayList和OffscreenBuffer（如果该View为硬件绘制层）。每个向WindowManagerService注册的窗口对应一个RootRenderNode，通过它可以找到View层次结构中所有View的DisplayList信息。在Java层的DisplayListCanvas用于生成DisplayList，其在native层的对应类为RecordingCanvas（在Android N前为DisplayListCanvas）。另外Android L中还引入了RenderThread（渲染线程）。所有的GL命令执行都放到这个线程上。渲染线程在RenderNode中存有渲染帧的所有信息，且还监听VSync信号，因此可以独立做一些属性动画。这样即便主线程block也可以保证动画流畅。引入渲染线程后ThreadedRenderer替代了Gl20Renderer，作为proxy用于主线程（UI线程）把渲染任务交给渲染线程。近期，在Android 7.0（Nougat）中又对hwui进行了小规模重构，引入了BakedOpRenderer, FrameBuilder, LayerBuilder, RecordingCanvas等类，用宏HWUI_NEW_OPS管理。下面简单介绍下这些新成员：</p><p>☯ <strong>RecordingCanvas</strong>: 之前Java层的DisplayListCanvas对应native层的DisplayListCanvas。引入RecordingCanvas后，其在native层的对应物就变成了RecordingCanvas。和DisplayListCanvas类似，画在RecordingCanvas上的内容都会被记录在RenderNode的DisplayList中。</p><p>☯ <strong>BakedOpRenderer</strong>: 顾名思义，就是用于绘制batch/merge好的操作。用于替代之前的OpenGLRenderer。它是真正用GL绘制到on-screen surface上的。</p><p>☯ <strong>BakedOpDispatcher</strong>: 提供一系列onXXX（如onBitmapOp）和onMergedXXX（如onMergedBitmapOps）静态函数供replay时调用。这些dispatch函数最后一般都会通过GlopBuilder来构造Glop然后通过BakedOpRenderer的renderGlop()函数来用OpenGL绘制。</p><p>☯ <strong>LayerBuilder</strong>: 用于存储绘制某一层的操作和状态。替代了部分原DeferredDisplayList的工作。对于所有View通用，即如果View有render layer，它对应一个FBO；如果对于普通View，它对应的是SurfaceFlinger提供的surface。 其中的mBatches存储了当前层defer后（即batch/merge好）的绘制操作。</p><p>☯ <strong>FrameBuilder</strong>: 管理某一帧的构建，用于处理，优化和存储从RenderNode和LayerUpdateQueue中来的渲染命令，同时它的replayBakedOps()方法还用于该帧的绘制命令重放。一帧中可能需要绘制多个层，每一层的上下文都会存在相应的LayerBuilder中。在FrameBuilder中通过mLayerBuilders和mLayerStack存储一个layer stack。它替代了原Snapshot类的一部分功能。</p><p>☯ <strong>OffscreenBuffer</strong>: 用于替代Layer类，但是设计上更轻量，而且自带内存池（通过OffscreenBufferPool）。</p><p>☯ <strong>LayerUpdateQueue</strong>：用于记录类型为硬件绘制层的RenderNode的更新操作。之后会通过FrameBuilder将该layer对应的RenderNode通过deferNodeOps()方法进行处理。</p><p>☯ <strong>RecordedOp</strong>: 由RecordedCanvas将View中的绘制命令转化为RecordedOp。RecordedOp也是DisplayList中的基本元素，用于替代Android N之前的DisplayListOp。它有一坨各式各样的继承类代表各种各样的绘制操作。BakedOpState是RecordedOp和相应的状态的自包含封装（封装的过程称为bake）。</p><p>☯ <strong>BatchBase</strong>: LayerBuilder中对DisplayList进行batch/merge处理后的结果以BatchBase形式保存在LayerBuilder的mBatches成员中。它有两个继承类分别为OpBatch和MergingOpBatch，分别用于不可合并和可合并操作。</p><p>概括下它们和相关类的关系图如下，接下来从DisplayList(RenderNode)的构建和绘制两个阶段分析下具体有哪些改动。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-01-android-hw-ops.png" alt="Alt text | center"></p><p>首先看看总体时序图：然后一步一步分析：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-02-HW.Draw.png" alt="Alt text | center"></p><h4 id="（一）、Android硬件渲染环境初始化ViewRootImpl-enableHardwareAcceleration"><a href="#（一）、Android硬件渲染环境初始化ViewRootImpl-enableHardwareAcceleration" class="headerlink" title="（一）、Android硬件渲染环境初始化ViewRootImpl.enableHardwareAcceleration()"></a>（一）、Android硬件渲染环境初始化ViewRootImpl.enableHardwareAcceleration()</h4><p>在ViewRootImpl.java的setView里，会去enable硬件加速功能。如果当前创建的窗口支持硬件加速渲染，那么就会创建一个HardwareRenderer对象，这个HardwareRenderer对象以后将负责执行窗口硬件加速渲染的相关操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ViewRootImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enableHardwareAcceleration</span><span class="params">(WindowManager.LayoutParams attrs)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (hardwareAccelerated) &#123;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (fakeHwAccelerated) &#123;</span><br><span class="line">                ......</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled</span><br><span class="line">                    || (ThreadedRenderer.sSystemRendererDisabled &amp;&amp; forceHwAccelerated)) &#123;</span><br><span class="line">                ......</span><br><span class="line">                mAttachInfo.mHardwareRenderer = ThreadedRenderer.create(mContext, translucent);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>ThreadedRenderer类的静态成员函数create的实现如下所示：</p><h5 id="1-1、ThreadedRenderer创建过程"><a href="#1-1、ThreadedRenderer创建过程" class="headerlink" title="1.1、ThreadedRenderer创建过程"></a>1.1、ThreadedRenderer创建过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadedRenderer <span class="title">create</span><span class="params">(Context context, <span class="keyword">boolean</span> translucent)</span> </span>&#123;</span><br><span class="line">        ThreadedRenderer renderer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (DisplayListCanvas.isAvailable()) &#123;</span><br><span class="line">            renderer = <span class="keyword">new</span> ThreadedRenderer(context, translucent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> renderer;</span><br><span class="line">    &#125;</span><br><span class="line">    ThreadedRenderer(Context context, <span class="keyword">boolean</span> translucent) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//1、nCreateRootRenderNode在Native层创建了一个Render Node</span></span><br><span class="line">        <span class="keyword">long</span> rootNodePtr = nCreateRootRenderNode();</span><br><span class="line">        mRootNode = RenderNode.adopt(rootNodePtr);</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//2、nCreateProxy在Native层创建了一个Render Proxy对象</span></span><br><span class="line">        mNativeProxy = nCreateProxy(translucent, rootNodePtr);</span><br><span class="line">        <span class="comment">//3、初始化一个系统预加载资源的地图集,优化资源的内存使用</span></span><br><span class="line">        ProcessInitializer.sInstance.init(context, mNativeProxy);</span><br><span class="line"></span><br><span class="line">        loadSystemProperties();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="1-1-1、创建RenderNode"><a href="#1-1-1、创建RenderNode" class="headerlink" title="1.1.1、创建RenderNode"></a>1.1.1、创建RenderNode</h5><p>nCreateRootRenderNode在Native层创建了一个Render Node。 从这里就可以看出，窗口在Native层的Root Render Node实际上是一个RootRenderNode对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\jni\android_view_ThreadedRenderer.cpp]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootRenderNode</span> :</span> <span class="keyword">public</span> RenderNode, ErrorHandler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RootRenderNode(JNIEnv* env) : RenderNode() &#123;</span><br><span class="line">        mLooper = Looper::getForThread();</span><br><span class="line">        env-&gt;GetJavaVM(&amp;mVm);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createRootRenderNode</span><span class="params">(JNIEnv* env, jobject clazz)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* node = <span class="keyword">new</span> RootRenderNode(env);</span><br><span class="line">    node-&gt;incStrong(<span class="number">0</span>);</span><br><span class="line">    node-&gt;setName(<span class="string">"RootRenderNode"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出会创建一个C++层的RootRenderNode对象，RootRenderNode继承自RenderNode，去看看RenderNode构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\RenderNode.cpp]</span><br><span class="line">RenderNode::RenderNode()</span><br><span class="line">        : mDirtyPropertyFields(<span class="number">0</span>)</span><br><span class="line">        , mNeedsDisplayListSync(<span class="literal">false</span>)</span><br><span class="line">        , mDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mStagingDisplayList(<span class="literal">nullptr</span>)</span><br><span class="line">        , mAnimatorManager(*<span class="keyword">this</span>)</span><br><span class="line">        , mParentCount(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这个RootRenderNode对象之后，函数android_view_ThreadedRenderer_createProxy就创建了一个RenderProxy对象。</p><h5 id="1-1-2、创建RenderProxy"><a href="#1-1-2、创建RenderProxy" class="headerlink" title="1.1.2、创建RenderProxy"></a>1.1.2、创建RenderProxy</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\jni\android_view_ThreadedRenderer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_view_ThreadedRenderer_createProxy</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jboolean translucent, jlong rootRenderNodePtr)</span> </span>&#123;</span><br><span class="line">    RootRenderNode* rootRenderNode = <span class="keyword">reinterpret_cast</span>&lt;RootRenderNode*&gt;(rootRenderNodePtr);</span><br><span class="line">    <span class="function">ContextFactoryImpl <span class="title">factory</span><span class="params">(rootRenderNode)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> (jlong) <span class="keyword">new</span> RenderProxy(translucent, rootRenderNode, &amp;factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy对象的创建过程如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> [-&gt;\frameworks\base\libs\hwui\renderthread\RenderProxy.cpp]</span><br><span class="line"> RenderProxy::RenderProxy(<span class="keyword">bool</span> translucent, RenderNode* rootRenderNode, IContextFactory* contextFactory)</span><br><span class="line">        : mRenderThread(RenderThread::getInstance())</span><br><span class="line">        , mContext(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    SETUP_TASK(createContext);</span><br><span class="line">    args-&gt;translucent = translucent;</span><br><span class="line">    args-&gt;rootRenderNode = rootRenderNode;</span><br><span class="line">    args-&gt;thread = &amp;mRenderThread;</span><br><span class="line">    args-&gt;contextFactory = contextFactory;</span><br><span class="line">    mContext = (CanvasContext*) postAndWait(task);</span><br><span class="line">    mDrawFrameTask.setContext(&amp;mRenderThread, mContext, rootRenderNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy类有三个重要的成员变量mRenderThread、mContext和mDrawFrameTask，mRenderThread描述的就是Render Thread，mContext描述的是一个画布上下文，mDrawFrameTask描述的是一个用来执行渲染任务的Task</p><h5 id="1-1-2-1、RenderThread-实例化"><a href="#1-1-2-1、RenderThread-实例化" class="headerlink" title="1.1.2.1、RenderThread 实例化"></a>1.1.2.1、RenderThread 实例化</h5><p>来看看RenderThread::getInstance()实例化过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line">RenderThread&amp; RenderThread::getInstance() &#123;</span><br><span class="line">    <span class="keyword">static</span> RenderThread* sInstance = <span class="keyword">new</span> RenderThread();</span><br><span class="line">    gHasRenderThreadInstance = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> *sInstance;</span><br><span class="line">&#125;</span><br><span class="line">RenderThread::RenderThread() : Thread(<span class="literal">true</span>)</span><br><span class="line">        , mNextWakeup(LLONG_MAX)</span><br><span class="line">        , mDisplayEventReceiver(<span class="literal">nullptr</span>)</span><br><span class="line">        , mVsyncRequested(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTaskPending(<span class="literal">false</span>)</span><br><span class="line">        , mFrameCallbackTask(<span class="literal">nullptr</span>)</span><br><span class="line">        , mRenderState(<span class="literal">nullptr</span>)</span><br><span class="line">        , mEglManager(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Properties::load();</span><br><span class="line">    mFrameCallbackTask = <span class="keyword">new</span> DispatchFrameCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    mLooper = <span class="keyword">new</span> Looper(<span class="literal">false</span>);</span><br><span class="line">    run(<span class="string">"RenderThread"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//RenderThread类的成员变量mFrameCallbackTask描述的Task是用来做什么的呢？原来就是用来显示动画的。当Java层注册一个动画</span></span><br><span class="line"><span class="comment">//类型的Render Node到Render Thread时，一个类型为IFrameCallback的回调接口就会通过RenderThread类的成员函数</span></span><br><span class="line"><span class="comment">//postFrameCallback注册到Render Thread的一个Pending Registration Frame Callbacks列表中</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DispatchFrameCallbacks</span> :</span> <span class="keyword">public</span> RenderTask &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RenderThread* mRenderThread;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DispatchFrameCallbacks(RenderThread* rt) : mRenderThread(rt) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        mRenderThread-&gt;dispatchFrameCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::dispatchFrameCallbacks() &#123;</span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">if</span> (callbacks.size()) &#123;</span><br><span class="line">        ......</span><br><span class="line">        requestVsync();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;IFrameCallback*&gt;::iterator it = callbacks.begin(); it != callbacks.end(); it++) &#123;</span><br><span class="line">            (*it)-&gt;doFrame();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、mFrameCallbackTask指向一个DispatchFrameCallbacks对象，用来描述一个帧绘制任务<br>2、mLooper指向一个Looper对象，消息驱动模型<br>3、RenderThread类是从Thread类继承下来的，当我们调用它的成员函数run的时候，就会创建一个新的线程。这个新的线程的入口点函数为RenderThread类的成员函数threadLoop，它的实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line">bool RenderThread::threadLoop() &#123;</span><br><span class="line">    setpriority(PRIO_PROCESS, 0, PRIORITY_DISPLAY);</span><br><span class="line">    initThreadLocals();</span><br><span class="line"></span><br><span class="line">    int timeoutMillis = -1;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        int result = mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line"></span><br><span class="line">        nsecs_t nextWakeup;</span><br><span class="line">        // Process our queue, if we have anything</span><br><span class="line">        while (RenderTask* task = nextTask(&amp;nextWakeup)) &#123;</span><br><span class="line">            task-&gt;run();</span><br><span class="line">            // task may have deleted itself, do not reference it again</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        if (mPendingRegistrationFrameCallbacks.size() &amp;&amp; !mFrameCallbackTaskPending) &#123;</span><br><span class="line">            drainDisplayEventQueue();</span><br><span class="line">            mFrameCallbacks.insert(</span><br><span class="line">                    mPendingRegistrationFrameCallbacks.begin(), mPendingRegistrationFrameCallbacks.end());</span><br><span class="line">            mPendingRegistrationFrameCallbacks.clear();</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!mFrameCallbackTaskPending &amp;&amp; !mVsyncRequested &amp;&amp; mFrameCallbacks.size()) &#123;</span><br><span class="line">            requestVsync();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们就可以看到Render Thread的运行模型：<br>1、空闲的时候，Render Thread就睡眠在成员变量mLooper指向的一个Looper对象的成员函数pollOnce中。<br>2、当其它线程需要调度Render Thread，就会向它的任务队列增加一个任务，然后唤醒Render Thread进行处理。Render Thread通过成员函数nextTask获得需要处理的任务，并且调用它的成员函数run进行处理。<br>RenderThread类的成员函数nextTask的实现如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line">RenderTask* RenderThread::nextTask(nsecs_t* nextWakeup) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    RenderTask* next = mQueue.peek();</span><br><span class="line">    if (!next) &#123;</span><br><span class="line">        mNextWakeup = LLONG_MAX;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ......</span><br><span class="line">        if (next-&gt;mRunAt &lt;= 0 || next-&gt;mRunAt &lt;= systemTime(SYSTEM_TIME_MONOTONIC)) &#123;</span><br><span class="line">            next = mQueue.next();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next = nullptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意，如果没有下一个任务可以执行，那么RenderThread类的成员函数nextTask通过参数nextWakeup返回的值为LLONG_MAX，表示Render Thread接下来无限期进入睡眠状态，直到被其它线程唤醒为止。<br> RenderThread类提供了queue、queueAndWait、queueAtFront和queueAt四个成员函数向Task Queue增加一个Task，它们的实现如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line"><span class="keyword">void</span> RenderThread::<span class="built_in">queue</span>(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.<span class="built_in">queue</span>(task);</span><br><span class="line">    <span class="keyword">if</span> (mNextWakeup &amp;&amp; task-&gt;mRunAt &lt; mNextWakeup) &#123;</span><br><span class="line">        mNextWakeup = <span class="number">0</span>;</span><br><span class="line">        mLooper-&gt;wake();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::queueAndWait(RenderTask* task) &#123;</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    Condition condition;</span><br><span class="line">    <span class="function">SignalingRenderTask <span class="title">syncTask</span><span class="params">(task, &amp;mutex, &amp;condition)</span></span>;</span><br><span class="line"></span><br><span class="line">    AutoMutex _lock(mutex);</span><br><span class="line">    <span class="built_in">queue</span>(&amp;syncTask);</span><br><span class="line">    condition.wait(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::queueAtFront(RenderTask* task) &#123;</span><br><span class="line">    AutoMutex _lock(mLock);</span><br><span class="line">    mQueue.queueAtFront(task);</span><br><span class="line">    mLooper-&gt;wake();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderThread::queueAt(RenderTask* task, <span class="keyword">nsecs_t</span> runAtNs) &#123;</span><br><span class="line">    task-&gt;mRunAt = runAtNs;</span><br><span class="line">    <span class="built_in">queue</span>(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看Render Thread在进入无限循环之前调用的initThreadLocals()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderThread.cpp]</span><br><span class="line"><span class="keyword">void</span> RenderThread::initThreadLocals() &#123;</span><br><span class="line">    sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">            ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">    <span class="keyword">status_t</span> status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;mDisplayInfo);</span><br><span class="line">    ......</span><br><span class="line">    initializeDisplayEventReceiver();</span><br><span class="line">    mEglManager = <span class="keyword">new</span> EglManager(*<span class="keyword">this</span>);</span><br><span class="line">    mRenderState = <span class="keyword">new</span> RenderState(*<span class="keyword">this</span>);</span><br><span class="line">    mJankTracker = <span class="keyword">new</span> JankTracker(mDisplayInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、initializeDisplayEventReceiver创建和初始化一个DisplayEventReceiver对象，用来接收Vsync信号。<br>产生Vsync信号时，SurfaceFlinger服务（Vsync信号由SurfaceFlinger服务进行管理和分发）会通过上述文件描述符号唤醒Render Thread。这时候Render Thread就会调用RenderThread类的静态成员函数displayEventReceiverCallback()-&gt;drainDisplayEventQueue()-&gt;<br>2、创建一个EglManager对象，之后会调用EglManager::initialize() Open GL ES环境初始化<br>3、创建一个RenderState对象（记录Render Thread当前的一些渲染状态）</p><h5 id="1-1-2-2、CanvasContext-画布上下文-的初始化过程"><a href="#1-1-2-2、CanvasContext-画布上下文-的初始化过程" class="headerlink" title="1.1.2.2、CanvasContext(画布上下文)的初始化过程"></a>1.1.2.2、CanvasContext(画布上下文)的初始化过程</h5><p>了解了Render Thread的创建过程之后，回到RenderProxy类的构造函数中，接下来我们继续分析它的成员变量mContext的初始化过程，也就是画布上下文的初始化过程。这是通过向Render Thread发送一个createContext命令来完成的。为了方便描述，我们将相关的代码列出来，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderProxy.cpp]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARGS(method) method ## Args  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE_BRIDGE4(name, a1, a2, a3, a4) CREATE_BRIDGE(name, a1,a2,a3,a4,,,,)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CREATE_BRIDGE(name, a1, a2, a3, a4, a5, a6, a7, a8) \  </span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> \  </span><br><span class="line">        a1; a2; a3; a4; a5; a6; a7; a8; \  </span><br><span class="line">    &#125; ARGS(name); \  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span>* Bridge_ #<span class="meta"># name(ARGS(name)* args)  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETUP_TASK(method) \  </span></span><br><span class="line">    .......  </span><br><span class="line">    MethodInvokeRenderTask* task = <span class="keyword">new</span> MethodInvokeRenderTask((RunnableMethod) Bridge_ ## method); \  </span><br><span class="line">    ARGS(method) *args = (ARGS(method) *) task-&gt;payload()  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">CREATE_BRIDGE4(createContext, RenderThread* thread, <span class="keyword">bool</span> translucent,  </span><br><span class="line">        RenderNode* rootRenderNode, IContextFactory* contextFactory) &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CanvasContext(*args-&gt;thread, args-&gt;translucent,  </span><br><span class="line">            args-&gt;rootRenderNode, args-&gt;contextFactory);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们首先看宏SETUP_TASK，它需要一个函数作为参数。这个函数通过CREATE_BRIDGEX来声明，其中X是一个数字，数字的大小就等于函数需要的参数的个数。例如，通过CREATE_BRIDGE4声明的函数有4个参数。在上面的代码段中，我们通过CREATE_BRIDGE4宏声明了一个createContext函数。</p><p>宏SETUP_TASK的作用创建一个类型MethodInvokeRenderTask的Task。这个Task关联有一个由CREATE_BRIDGEX宏声明的函数。例如，SETUP_TASK(createContext)创建的MethodInvokeRenderTask关联的函数是由CREATE_BRIDGE4声明的函数createContext。这个Task最终会通过RenderProxy类的成员函数postAndWait添加到Render Thread的Task Queue中，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\RenderProxy.cpp]</span><br><span class="line"><span class="keyword">void</span>* RenderProxy::postAndWait(MethodInvokeRenderTask* task) &#123;</span><br><span class="line">    <span class="keyword">void</span>* retval;</span><br><span class="line">    task-&gt;setReturnPtr(&amp;retval);</span><br><span class="line">    <span class="function">SignalingRenderTask <span class="title">syncTask</span><span class="params">(task, &amp;mSyncMutex, &amp;mSyncCondition)</span></span>;</span><br><span class="line">    AutoMutex _lock(mSyncMutex);</span><br><span class="line">    mRenderThread.<span class="built_in">queue</span>(&amp;syncTask);</span><br><span class="line">    mSyncCondition.wait(mSyncMutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RenderProxy对象的创建过程就分析完成了，从中我们也看到Render Thread的创建过程和运行模型，以及Render Proxy与Render Thread的交互模型，总结来说：</p><p>1、RenderProxy内部有一个成员变量mRenderThread，它指向的是一个RenderThread对象，通过它可以向Render Thread线程发送命令。</p><p>2、 RenderProxy内部有一个成员变量mContext，它指向的是一个CanvasContext对象，Render Thread的渲染工作就是通过它来完成的。</p><p>3、RenderProxy内部有一个成员变量mDrawFrameTask，它指向的是一个DrawFrameTask对象，Main Thread通过它向Render Thread线程发送渲染下一帧的命令。</p><h4 id="（二）、Open-GL-ES环境初始化-绑定窗口到Render-Thread中"><a href="#（二）、Open-GL-ES环境初始化-绑定窗口到Render-Thread中" class="headerlink" title="（二）、Open GL ES环境初始化 (绑定窗口到Render Thread中)"></a>（二）、Open GL ES环境初始化 (绑定窗口到Render Thread中)</h4><p>Activity窗口的绘制流程是在ViewRoot(Impl)类的成员函数performTraversals发起的。在绘制之前，首先要获得一个Surface。这个Surface描述的就是一个窗口。因此，一旦获得了对应的Surface，就需要将它绑定到Render Thread中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/view/ViewRootImpl.java]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewRootImpl</span> <span class="keyword">implements</span> <span class="title">ViewParent</span>,  </span></span><br><span class="line"><span class="class">        <span class="title">View</span>.<span class="title">AttachInfo</span>.<span class="title">Callbacks</span>, <span class="title">HardwareRenderer</span>.<span class="title">HardwareDrawCallbacks</span> </span>&#123;  </span><br><span class="line">    ......  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ......</span><br><span class="line">        hwInitialized = mAttachInfo.mHardwareRenderer.initialize(  </span><br><span class="line">                                        mSurface);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mHardwareRenderer对象，它的成员函数initialize的实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">initialize</span><span class="params">(Surface surface)</span> <span class="keyword">throws</span> OutOfResourcesException </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> status = !mInitialized;</span><br><span class="line">        mInitialized = <span class="keyword">true</span>;</span><br><span class="line">        updateEnabledState(surface);</span><br><span class="line">        nInitialize(mNativeProxy, surface);</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>nInitialize是一个JNI函数，由Native层的函数android_view_ThreadedRenderer_initialize实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\jni\android_view_ThreadedRenderer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_view_ThreadedRenderer_initialize</span><span class="params">(JNIEnv* env, jobject clazz,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong proxyPtr, jobject jsurface)</span> </span>&#123;</span><br><span class="line">    RenderProxy* proxy = <span class="keyword">reinterpret_cast</span>&lt;RenderProxy*&gt;(proxyPtr);</span><br><span class="line">    sp&lt;Surface&gt; surface = android_view_Surface_getSurface(env, jsurface);</span><br><span class="line">    proxy-&gt;initialize(surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java层的Surface在Native层对应的是一个ANativeWindow。我们可以通过函数android_view_Surface_getNativeWindow来获得一个Java层的Surface在Native层对应的ANativeWindow<br>RenderProxy-&gt;initialize()函数实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE_BRIDGE2(initialize, CanvasContext* context, Surface* surface) &#123;</span><br><span class="line">    args-&gt;context-&gt;initialize(args-&gt;surface);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> RenderProxy::initialize(<span class="keyword">const</span> sp&lt;Surface&gt;&amp; surface) &#123;</span><br><span class="line">    SETUP_TASK(initialize);</span><br><span class="line">    args-&gt;context = mContext;</span><br><span class="line">    args-&gt;surface = surface.get();</span><br><span class="line">    post(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当这个Task在Render Thread中执行时，由宏CREATE_BRIDGE2声明的函数initialize就会被执行。</p><p>在由宏CREATE_BRIDGE2声明的函数initialize中，参数context指向的是RenderProxy类的成员变量mContext指向的一个CanvasContext对象，而参数window指向的ANativeWindow就是要绑定到Render Thread的ANativeWindow。</p><p>由宏CREATE_BRIDGE2声明的函数initialize通过调用参数context指向的CanvasContext对象的成员函数initialize来绑定参数window指向的ANativeWindow，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\CanvasContext.cpp]</span><br><span class="line"><span class="keyword">void</span> CanvasContext::initialize(Surface* surface) &#123;</span><br><span class="line">    setSurface(surface);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !HWUI_NEW_OPS</span></span><br><span class="line">    <span class="keyword">if</span> (mCanvas) <span class="keyword">return</span>;</span><br><span class="line">    mCanvas = <span class="keyword">new</span> OpenGLRenderer(mRenderThread.renderState());</span><br><span class="line">    mCanvas-&gt;initProperties();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> CanvasContext::setSurface(Surface* surface) &#123;</span><br><span class="line">    mNativeSurface = surface;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (surface) &#123;</span><br><span class="line">        mEglSurface = mEglManager.createSurface(surface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mEglSurface != EGL_NO_SURFACE) &#123;</span><br><span class="line">        ......</span><br><span class="line">        mHaveNewSurface = <span class="literal">true</span>;</span><br><span class="line">        .....</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRenderThread.removeFrameCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个Open GL渲染上下文都需要关联有一个EGL Surface。这个EGL Surface描述的是一个绘图表面，它封装的实际上是一个ANativeWindow。有了这个EGL Surface之后，我们在执行Open GL命令的时候，才能确定这些命令是作用在哪个窗口上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\EglManager.cpp]</span><br><span class="line">EGLSurface EglManager::createSurface(EGLNativeWindowType window) &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    EGLSurface surface = eglCreateWindowSurface(mEglDisplay, mEglConfig, window, <span class="literal">nullptr</span>);</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> EglManager::initialize() &#123;</span><br><span class="line">    ......</span><br><span class="line">    loadConfig();<span class="comment">//</span></span><br><span class="line">    createContext();<span class="comment">//</span></span><br><span class="line">    createPBufferSurface();<span class="comment">//</span></span><br><span class="line">    makeCurrent(mPBufferSurface);<span class="comment">//</span></span><br><span class="line">    DeviceInfo::initialize();</span><br><span class="line">    mRenderThread.renderState().onGLContextCreated();</span><br><span class="line">    initAtlas();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用EGL的绘图的一般步骤：<br>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p></blockquote><p>Android EGL &amp;&amp; OpenGL分析请参考【Android Display System（2）：Android Display System 系统分析 之 Android EGL &amp;&amp; OpenGL】</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-03-UIThread-ThreadRenderer.png" alt="Alt text | center"></p><p>至此，将当前窗口绑定到Render Thread的过程就分析完成了，整个Android应用程序UI硬件加速渲染环境的初始化过程也分析完成了。</p><h4 id="（三）、RenderNode构建"><a href="#（三）、RenderNode构建" class="headerlink" title="（三）、RenderNode构建"></a>（三）、RenderNode构建</h4><p>我们知道，通常情况下，App要完成一帧渲染，是通过ViewRootImpl的performTraversals()函数来实现。而它又可分为measure, layout, draw三个阶段。上面这些改动主要影响的是最后这步，因此我们就主要focus在draw这个阶段的流程。首先看DisplayList是怎么录制的。在ViewRootImpl::performDraw()中会调用draw()函数。当判断需要进行绘制时（比如有脏区域，或在动画中时），又如果硬件加速可用（通过ThreadedRenderer的isEnabled()），会进行下面的重绘动作。接下来根据是否有相关请求（如resize时）或offset是否有变化来判断是否要调用ThreadedRenderer的invalidRoot()来标记更新RootRenderNode。</p><p>扯个题外话。和Android M相比，N中UI子系统中加入了不少对用户进行窗口resize的处理，主要应该是为了Android N新增加的多窗口分屏模式。比如当用户拖拽分屏窗口边缘时，onWindowDragResizeStart()被调用。它其中会创建BackdropFrameRenderer。BackdropFrameRenderer本身运行单独的线程，它负责在resize窗口而窗口绘制来不及的情况下填充背景。它会通过addRenderNode()加入专用的RenderNode。同时，Android N中将DecorView从PhoneWindow中分离成一个单独的文件，并实现新加的WindowCallbacks接口。它主要用于当用户变化窗口大小时ViewRootImpl对DecorView的回调。因为ViewRootImpl和WindowManagerService通信，它会被通知到窗口变化，然后回调到DecorView中。而DecorView中的相应回调会和BackupdropFrameRenderer交互。如updateContentDrawBounds()中最后会调用到了BackupdropFrmeRenderer的onContentDrawn()函数，其返回值代表在下面的内容绘制后是否需要再发起一次绘制。如果需要，之后会调用requestDrawWindow()。</p><p>回到ViewRootImpl::performDraw()函数，接下来，最重要的就是通过ThreadedRenderer的draw()来进行绘制。在这个draw()函数中，比较重要的一步是通过updateRootDisplayList()函数来更新根结点的DisplayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateViewTreeDisplayList</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        view.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line">        view.mRecreateDisplayList = (view.mPrivateFlags &amp; View.PFLAG_INVALIDATED)</span><br><span class="line">                == View.PFLAG_INVALIDATED;</span><br><span class="line">        view.mPrivateFlags &amp;= ~View.PFLAG_INVALIDATED;</span><br><span class="line">        view.updateDisplayListIfDirty();</span><br><span class="line">        view.mRecreateDisplayList = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRootDisplayList</span><span class="params">(View view, HardwareDrawCallbacks callbacks)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Record View#draw()"</span>);</span><br><span class="line">        updateViewTreeDisplayList(view);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mRootNodeNeedsUpdate || !mRootNode.isValid()) &#123;</span><br><span class="line">            DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> saveCount = canvas.save();</span><br><span class="line">                canvas.translate(mInsetLeft, mInsetTop);</span><br><span class="line">                callbacks.onHardwarePreDraw(canvas);</span><br><span class="line"></span><br><span class="line">                canvas.insertReorderBarrier();</span><br><span class="line">                canvas.drawRenderNode(view.updateDisplayListIfDirty());</span><br><span class="line">                canvas.insertInorderBarrier();</span><br><span class="line"></span><br><span class="line">                callbacks.onHardwarePostDraw(canvas);</span><br><span class="line">                canvas.restoreToCount(saveCount);</span><br><span class="line">                mRootNodeNeedsUpdate = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mRootNode.end(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>函数updateRootDisplayList()中的updateViewTreeDisplayList()会调到DecorView的updateDisplayListIfDirty()函数。这个函数主要功能是更新DecorView对应的RenderNode中的DisplayList。它返回的RenderNode会通过RecordingCanvas::drawRenderNode()函数将之作为RenderNodeOp加入到RootRenderNode的DisplayList中。函数updateDisplayListIfDirty()中首先判断当前View是否需要更新。如果不需要就调用dispatchGetDisplayList()让子View更新，然后直接返回。否则就是当前View的DisplayList需要更新。这里我们假设是第一次绘制，更新DisplayList的流程首先通过RenderNode的start()来获得一个用于记录绘制操作的Canvas，即DisplayListCanvas（在Android M中Java层由GLES20RecordingCanvas改为DisplayListCanvas，native层中的DisplayListRenderer改为DisplayListCanvas，Android N中native层中的DisplayListCanvas改为RecordingCanvas）。</p><p>接下去就是比较关键的步骤了。这里就要分几种情况了，一个View可以为三种类型（LAYER_TYPE_NONE, LAYER_TYPE_SOFTWARE, LAYER_TYPE_HARDWARE）中的一种。LAYER_TYPE_NONE为默认值，代表没有layer。LAYER_TYPE_SOFTWARE代表该View有软件层，以bitmap为back，内容用软件渲染。LAYER_TYPE_HARDWARE和LAYER_TYPE_SOFTWARE类似，区别在于其有硬件层，以FBO（Framebuffer object）为back，内容使用硬件渲染。如果硬件加速没有打开，它的行为和LAYER_TYPE_SOFTWARE是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\view\ThreadedRenderer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RenderNode <span class="title">updateDisplayListIfDirty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        final RenderNode renderNode = mRenderNode;</span><br><span class="line">       .......</span><br><span class="line">        <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == <span class="number">0</span></span><br><span class="line">                || !renderNode.isValid()</span><br><span class="line">                || (mRecreateDisplayList)) &#123;</span><br><span class="line">            <span class="comment">// Don't need to recreate the display list, just need to tell our</span></span><br><span class="line">            <span class="comment">// children to restore/recreate theirs</span></span><br><span class="line">            <span class="keyword">if</span> (renderNode.isValid()</span><br><span class="line">                    &amp;&amp; !mRecreateDisplayList) &#123;</span><br><span class="line">                mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                dispatchGetDisplayList();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> renderNode; <span class="comment">// no work needed</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we got here, we're recreating it. Mark it as such to ensure that</span></span><br><span class="line">            <span class="comment">// we copy in child display lists into ours in drawChild()</span></span><br><span class="line">            mRecreateDisplayList = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> width = mRight - mLeft;</span><br><span class="line">            <span class="keyword">int</span> height = mBottom - mTop;</span><br><span class="line">            <span class="keyword">int</span> layerType = getLayerType();</span><br><span class="line"></span><br><span class="line">            final DisplayListCanvas canvas = renderNode.start(width, height);</span><br><span class="line">            canvas.setHighContrastText(mAttachInfo.mHighContrastText);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (layerType == LAYER_TYPE_SOFTWARE) &#123;</span><br><span class="line">                    buildDrawingCache(<span class="literal">true</span>);</span><br><span class="line">                    Bitmap cache = getDrawingCache(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cache != null) &#123;</span><br><span class="line">                        canvas.drawBitmap(cache, <span class="number">0</span>, <span class="number">0</span>, mLayerPaint);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    computeScroll();</span><br><span class="line"></span><br><span class="line">                    canvas.translate(-mScrollX, -mScrollY);</span><br><span class="line">                    mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">                    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                        dispatchDraw(canvas);</span><br><span class="line">                        <span class="keyword">if</span> (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">                            mOverlay.getOverlayView().draw(canvas);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        draw(canvas);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                renderNode.end(canvas);</span><br><span class="line">                setDisplayListProperties(renderNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> renderNode;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果当前View是软件渲染层（类型为LAYER_TYPE_SOFTWARE）的话，则调用buildDrawingCache()获得Bitmap后调用drawBitmap()将该Bitmap记录到DisplayListCanvas中。现在Android中都默认硬件渲染了，为什么还要考虑软件渲染层呢?一方面有些平台不支持硬件渲染，或app不启用硬件加速，另一方面有些UI控件不支持硬件渲染 。在复杂的View（及子View）在动画过程中，可以被绘制成纹理，这样只需要画一次。显然，在View经常更新的情况下并不适用。因为这样每次都需要重新用软件渲染，如果硬件渲染打开时还要上传成硬件纹理（上传纹理是个比较慢的操作）。类似的，硬件渲染层（LAYER_TYPE_HARDWARE）也是适用于类似的复杂View结构进行属性动画的场景，但它与LAYER_TYPE_SOFTWARE的层的区别为它对应FBO，可以直接硬件渲染生成纹理。因此渲染的过程中不需要先生成Bitmap，从而省去了上传成硬件纹理的这一步操作。</p><p>如果当前View对应LAYER_TYPE_NONE或者LAYER_TYPE_HARDWARE，下面会考查是否为没有背景的Layout。这种情况下当前View没什么好画的，会走快速路径。即通过dispatchDraw()直接让子View重绘。否则就调draw()来绘制当前View及其子View。注意View中的draw()有两个重载同名函数。一个参数的版本用于直接调用。三个参数的版本用于ViewGroup中drawChild()时调用。这里调的是一个参数的版本。这个draw()函数中会按下面的顺序进行绘制（DisplayList的更新）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Draw traversal performs several drawing steps which must be executed</span></span><br><span class="line"><span class="comment">     * in the appropriate order:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      1. Draw the background</span></span><br><span class="line"><span class="comment">     *      2. If necessary, save the canvas' layers to prepare for fading</span></span><br><span class="line"><span class="comment">     *      3. Draw view's content</span></span><br><span class="line"><span class="comment">     *      4. Draw children</span></span><br><span class="line"><span class="comment">     *      5. If necessary, draw the fading edges and restore layers</span></span><br><span class="line"><span class="comment">     *      6. Draw decorations (scrollbars for instance)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1, draw the background, if needed</span></span><br><span class="line">    ......</span><br><span class="line">    drawBackground(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5, draw the fade effect and restore layers</span></span><br><span class="line">    <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是通过drawBackground(), onDraw(), dispatchDraw()和onDrawForeground()等函数实现。这些函数本质上就是将相应内容绘制到提供的DisplayListCanvas上。由于View是以树形层次结构组织的，draw()中会通过dispatchDraw()来更新子View的DisplayList。dispatchDraw()为对每个子View调用drawChild()。然后调用子View的draw()函数（这次就是上面说的draw()的三个参数的版本了）。这个版本的draw()函数里会更新其View的DisplayList，然后调用DisplayListCanvas的drawRenderNode()将该子view对应的RenderNode记录到其父view的DisplayList中去。这样便根据View的树型结构生成了DisplayList的树型结构。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-04-DisplayList-RootRenderNode.png" alt="Alt text | center"></p><p>其中onDraw()用于绘制当前View的自定义UI，它是每个View需要自定义的成员函数。比较典型地，在View的绘制函数中会调用canvas的drawXXX函数。比如canvas.drawLine()-&gt;drawLines(android_graphics_Canvas.cpp)，它会通过JNI最后调到RecordingCanvas.cpp中的RecordingCanvas::drawLines()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\RecordingCanvas.cpp]</span><br><span class="line"><span class="keyword">void</span> RecordingCanvas::drawLines(<span class="keyword">const</span> <span class="keyword">float</span>* points, <span class="keyword">int</span> floatCount, <span class="keyword">const</span> SkPaint&amp; paint) &#123;</span><br><span class="line">    <span class="keyword">if</span> (CC_UNLIKELY(floatCount &lt; <span class="number">4</span> || PaintUtils::paintWillNotDraw(paint))) <span class="keyword">return</span>;</span><br><span class="line">    floatCount &amp;= ~<span class="number">0x3</span>; <span class="comment">// round down to nearest four</span></span><br><span class="line"></span><br><span class="line">    addOp(alloc().create_trivial&lt;LinesOp&gt;(</span><br><span class="line">            calcBoundsOfPoints(points, floatCount),</span><br><span class="line">            *mState.currentSnapshot()-&gt;transform,</span><br><span class="line">            getRecordedClip(),</span><br><span class="line">            refPaint(&amp;paint), refBuffer&lt;<span class="keyword">float</span>&gt;(points, floatCount), floatCount));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RecordingCanvas中绝大多数的drawXXX系函数都是类似于这样，通过addOp()将一个RecordedOp的继承类存到其成员mDisplayList中。RecordedOp家庭成员很多，有不少继承类，每个对应一种操作。操作的种类可以参照下这个表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\RecordedOp.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAP_OPS_BASED_ON_TYPE(PRE_RENDER_OP_FN, RENDER_ONLY_OP_FN, UNMERGEABLE_OP_FN, MERGEABLE_OP_FN) \</span></span><br><span class="line">        PRE_RENDER_OP_FN(RenderNodeOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(CirclePropsOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(RoundRectPropsOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(BeginLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(EndLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(BeginUnclippedLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(EndUnclippedLayerOp) \</span><br><span class="line">        PRE_RENDER_OP_FN(VectorDrawableOp) \</span><br><span class="line">        \</span><br><span class="line">        RENDER_ONLY_OP_FN(ShadowOp) \</span><br><span class="line">        RENDER_ONLY_OP_FN(LayerOp) \</span><br><span class="line">        RENDER_ONLY_OP_FN(CopyToLayerOp) \</span><br><span class="line">        RENDER_ONLY_OP_FN(CopyFromLayerOp) \</span><br><span class="line">        \</span><br><span class="line">        UNMERGEABLE_OP_FN(ArcOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(BitmapMeshOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(BitmapRectOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(ColorOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(FunctorOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(LinesOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(OvalOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(PathOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(PointsOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(RectOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(RoundRectOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(SimpleRectsOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(TextOnPathOp) \</span><br><span class="line">        UNMERGEABLE_OP_FN(TextureLayerOp) \</span><br><span class="line">        \</span><br><span class="line">        MERGEABLE_OP_FN(BitmapOp) \</span><br><span class="line">        MERGEABLE_OP_FN(PatchOp) \</span><br><span class="line">        MERGEABLE_OP_FN(TextOp)</span><br></pre></td></tr></table></figure><p>各个View的DisplayList更新好后，回到udpateRootDisplayList()。如果发现RootRenderNode也需要更新，则先通过Java层的RenderNode::start()获得DisplayListCanvas，在这个Canvas上的动作都会被记录到DisplayList中，直到调用RenderNode.end()。然后为了防止对上下文状态的影响，用Canvas::save()和Canvas::restoreToCount()来生成临时的画布状态。再接下来就是通过drawRenderNode()将DecorView的RenderNode以RenderNodeOp的形式记录到RootRenderNode。</p><p><strong>DisplayList构建实例：</strong><br><a href="https://www.jianshu.com/p/7bf306c09c7e" target="_blank" rel="noopener">Android DisplayList 构建过程</a><br><strong>activity_main.xml</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">链接：https://www.jianshu.com/p/7bf306c09c7e</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/sample_text&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;60dp&quot;</span><br><span class="line">        android:gravity=&quot;center&quot;</span><br><span class="line">        android:textSize=&quot;20sp&quot;</span><br><span class="line">        android:text=&quot;Hello World!&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;cc.bobby.debugapp.MyView</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;100dp&quot; /&gt;</span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-05-activity_main.xml.png" alt="Alt text | center"></p><p><strong>udpateRootDisplayList()</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-06-updateRootDisplayList.jpg" alt="Alt text | center"></p><p><strong>父View与子View的DisplayList</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-07-rootview-childview-displaylist.png" alt="Alt text | center"></p><h4 id="（四）、RenderNode绘制"><a href="#（四）、RenderNode绘制" class="headerlink" title="（四）、RenderNode绘制"></a>（四）、RenderNode绘制</h4><p>在ThreadedRenderer的draw()函数中构建完DisplayList后，接下来需要准备渲染了。首先通过JNI调用nSyncAndDrawFrame()调用到native层的android_view_ThreadedRenderer_syncAndDrawFrame()。其中将参数中的FrameInfo数组传到RenderProxy的mFrameInfo成员中。它是Android M开始加入用来细化hwui性能统计的。同时调用RenderProxy的syncAndDrawFrame()函数，并将创建的TreeObserver作为参数。函数syncAndDrawFrame()中即调用DrawFrameTask（这是RenderThread的TaskQueue中的特殊Task实例）的drawFrame()函数。继而通过postAndWait()往RenderThread的TaskQueue里插入自身（即DrawFrameTask）来申请新一帧的渲染。在RenderThread的queue()函数中会按Task的运行时间将之插入到适当的位置。接着postAndWait()函数中会block UI线程等待渲染线程将之unblock。渲染线程在N中的改动不大，这里就不花太多文字介绍了，需要的时候把它当作跨线程调用即可。</p><p>另一边，渲染线程处理这个DrawFrameTask时会调用到其run()函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\DrawFrameTask.cpp]</span><br><span class="line"><span class="keyword">void</span> DrawFrameTask::run() &#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"DrawFrame"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> canUnblockUiThread;</span><br><span class="line">    <span class="keyword">bool</span> canDrawThisFrame;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">TreeInfo <span class="title">info</span><span class="params">(TreeInfo::MODE_FULL, *mContext)</span></span>;</span><br><span class="line">        info.observer = mObserver;</span><br><span class="line">        canUnblockUiThread = syncFrameState(info);</span><br><span class="line">        canDrawThisFrame = info.out.canDrawThisFrame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Grab a copy of everything we need</span></span><br><span class="line">    CanvasContext* context = mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// From this point on anything in "this" is *UNSAFE TO ACCESS*</span></span><br><span class="line">    <span class="keyword">if</span> (canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CC_LIKELY(canDrawThisFrame)) &#123;</span><br><span class="line">        context-&gt;draw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// wait on fences so tasks don't overlap next frame</span></span><br><span class="line">        context-&gt;waitOnFences();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!canUnblockUiThread) &#123;</span><br><span class="line">        unblockUiThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中首先通过DrawFrameTask::syncFrameState()函数将主线程的渲染信息（如DisplayList，Property和Bitmap等）同步到渲染线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syncFrameState()</span><br><span class="line">  -&gt; eglMakeCurrent </span><br><span class="line">    -&gt; eglMakeCurrent(OEM EGL) </span><br><span class="line">      -&gt; <span class="keyword">egl_window_surface_v2_t</span>::connect()</span><br><span class="line">      -&gt; Surface::hook_dequeueBuffer() </span><br><span class="line">        -&gt; Surface::dequeueBuffer() </span><br><span class="line">            -&gt; BpGraphicBufferProducer::dequeueBuffer()</span><br><span class="line">            -&gt; BpGraphicBufferProducer::requestBuffer()</span><br></pre></td></tr></table></figure><p>这个函数中首先会处理DrawFrameTask中的mLayers。它是DeferredLayerUpdater的vector，顾名思义，就是延迟处理的layer更新任务。这主要用于TextureView。TextureView是比较特殊的类。它通常用于显示内容流，生产者端可以是另一个进程。中间通过BufferQueue进行buffer的传输和交换。当有新的buffer来到（或者有属性变化，如visibility等）是，会通过回调设置标志位(mUpdateLayer)并通过invalidate()调度下一次重绘。当下一次draw()被调用时，先通过applyUpdate()-&gt;updateSurfaceTexture()-&gt;ThreadedRenderer::pushLayerUpdate()，再调到渲染线程中的 DrawFrameTask::pushLayerUpdate()，将本次更新记录在DrawFrameTask的mLayers中。这样，在后面调用DrawFrameTask::syncFrameState()是会依次调用mLayers中的apply()进行真正的更新。这里调用它的apply()函数就会取新可用buffer（通过doUpdateTexImage()函数），并将相关纹理信息更新到mLayer。在syncFrameState()函数中，接下来，通过CanvasContext的prepareTree()继而调用RenderNode的prepareTree()同步渲染信息。最后会输出TreeInfo结构，其中的prepareTextures代表纹理上传是否成功。如果为false，说明texture cache用完了。这样为了防止渲染线程在渲染过程中使用的资源和主线程竞争，在渲染线程绘制当前帧时就不能让主线程继续往下跑了，也就不能做到真正并行。在sync完数据后，DrawFrameTask::run()最后会调用CanvasContext::draw()来进行接下来的渲染。这部分的大体流程如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-08-ThreadRender-draw.png" alt="Alt text | center"></p><p>接下来瞄下CanvasContext::draw()里做了什么。先要小小准备下EGL环境，比如通过EglManager的beginFrame()函数，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">beginFrame()</span><br><span class="line">  -&gt; eglMakeCurrent </span><br><span class="line">    -&gt; eglMakeCurrent(OEM EGL) </span><br><span class="line">      -&gt; Surface::hook_dequeueBuffer() </span><br><span class="line">        -&gt; Surface::dequeueBuffer() </span><br><span class="line">            -&gt; BpGraphicBufferProducer::dequeueBuffer()</span><br><span class="line">            -&gt; BpGraphicBufferProducer::requestBuffer()</span><br><span class="line"></span><br><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line">Frame EglManager::beginFrame(EGLSurface surface) &#123;</span><br><span class="line">    .....</span><br><span class="line">    makeCurrent(surface);</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> EglManager::makeCurrent(EGLSurface surface, EGLint* errOut) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!eglMakeCurrent(mEglDisplay, surface, surface, mEglContext)) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(  EGLDisplay dpy, EGLSurface draw,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLSurface read, EGLContext ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        <span class="comment">// if we're detaching, we need the current context</span></span><br><span class="line">        current_ctx = (EGLContext)getGlThreadSpecific();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;</span><br><span class="line">            <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EGLBoolean <span class="keyword">egl_window_surface_v2_t</span>::connect()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dequeue a buffer</span></span><br><span class="line">    <span class="keyword">int</span> fenceFd = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer,</span><br><span class="line">            &amp;fenceFd) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for the buffer</span></span><br><span class="line">    sp&lt;Fence&gt; fence(<span class="keyword">new</span> Fence(fenceFd));</span><br><span class="line">    <span class="keyword">if</span> (fence-&gt;wait(Fence::TIMEOUT_NEVER) != NO_ERROR) &#123;</span><br><span class="line">        nativeWindow-&gt;cancelBuffer(nativeWindow, buffer, fenceFd);</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继而用eglMakeCurrent()将渲染context切换到相应的surface。然后EglManager的damageFrame()设定当前帧的脏区域（如果gfx平台支持局部更新的话）。接下来就是绘制的主体部分了。这也是N中改动比较大的部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\renderthread\CanvasContext.cpp]</span><br><span class="line"><span class="keyword">void</span> CanvasContext::draw() &#123;</span><br><span class="line">    SkRect dirty;</span><br><span class="line">    mDamageAccumulator.finish(&amp;dirty);</span><br><span class="line"></span><br><span class="line">    mCurrentFrameInfo-&gt;markIssueDrawCommandsStart();</span><br><span class="line"></span><br><span class="line">    Frame frame = mEglManager.beginFrame(mEglSurface);</span><br><span class="line">    ......</span><br><span class="line">    <span class="function">SkRect <span class="title">screenDirty</span><span class="params">(dirty)</span></span>;</span><br><span class="line">    ......</span><br><span class="line">    mEglManager.damageFrame(frame, dirty);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> HWUI_NEW_OPS</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; caches = Caches::getInstance();</span><br><span class="line">    FrameBuilder frameBuilder(dirty, frame.width(), frame.height(), mLightGeometry, caches);</span><br><span class="line"></span><br><span class="line">    frameBuilder.deferLayers(mLayerUpdateQueue);</span><br><span class="line">    mLayerUpdateQueue.clear();</span><br><span class="line"></span><br><span class="line">    frameBuilder.deferRenderNodeScene(mRenderNodes, mContentDrawBounds);</span><br><span class="line"></span><br><span class="line">    BakedOpRenderer renderer(caches, mRenderThread.renderState(),</span><br><span class="line">            mOpaque, mLightInfo);</span><br><span class="line">    frameBuilder.replayBakedOps&lt;BakedOpDispatcher&gt;(renderer);</span><br><span class="line">    profiler().draw(&amp;renderer);</span><br><span class="line">    <span class="keyword">bool</span> drew = renderer.didDraw();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// post frame cleanup</span></span><br><span class="line">    caches.clearGarbage();</span><br><span class="line">    caches.pathCache.trim();</span><br><span class="line">    caches.tessellationCache.trim();</span><br><span class="line">    ......</span><br><span class="line">    mCanvas-&gt;prepareDirty(frame.width(), frame.height(),</span><br><span class="line">            dirty.fLeft, dirty.fTop, dirty.fRight, dirty.fBottom, mOpaque);</span><br><span class="line"></span><br><span class="line">    Rect outBounds;</span><br><span class="line">    <span class="comment">// It there are multiple render nodes, they are laid out as follows:</span></span><br><span class="line">    <span class="comment">// #0 - backdrop (content + caption)</span></span><br><span class="line">    <span class="comment">// #1 - content (positioned at (0,0) and clipped to - its bounds mContentDrawBounds)</span></span><br><span class="line">    <span class="comment">// #2 - additional overlay nodes</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Draw all render nodes. Note that</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> sp&lt;RenderNode&gt;&amp; node : mRenderNodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (layer == <span class="number">0</span>) &#123; <span class="comment">// Backdrop.</span></span><br><span class="line">            .......</span><br><span class="line">            <span class="comment">// Check if we have to draw something on the left side ...</span></span><br><span class="line">            <span class="keyword">if</span> (targetBounds.left &lt; contentBounds.left) &#123;</span><br><span class="line">                mCanvas-&gt;save(SaveFlags::Clip);</span><br><span class="line">                <span class="keyword">if</span> (mCanvas-&gt;clipRect(targetBounds.left, targetBounds.top,</span><br><span class="line">                                      contentBounds.left, targetBounds.bottom,</span><br><span class="line">                                      SkRegion::kIntersect_Op)) &#123;</span><br><span class="line">                    mCanvas-&gt;drawRenderNode(node.get(), outBounds);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Reduce the target area by the area we have just painted.</span></span><br><span class="line">                targetBounds.left = <span class="built_in">std</span>::min(contentBounds.left, targetBounds.right);</span><br><span class="line">                mCanvas-&gt;restore();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... or on the right side ...</span></span><br><span class="line">            <span class="comment">// ... or at the top ...</span></span><br><span class="line">            <span class="comment">// ... or at the bottom.</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (layer == <span class="number">1</span>) &#123; <span class="comment">// Content</span></span><br><span class="line">            <span class="comment">// It gets cropped against the bounds of the backdrop to stay inside.</span></span><br><span class="line">            mCanvas-&gt;save(SaveFlags::MatrixClip);</span><br><span class="line">            ......</span><br><span class="line">            mCanvas-&gt;translate(dx, dy);</span><br><span class="line">            <span class="keyword">if</span> (mCanvas-&gt;clipRect(left, top, left + width, top + height, SkRegion::kIntersect_Op)) &#123;</span><br><span class="line">                mCanvas-&gt;drawRenderNode(node.get(), outBounds);</span><br><span class="line">            &#125;</span><br><span class="line">            mCanvas-&gt;restore();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// draw the rest on top at will!</span></span><br><span class="line">            mCanvas-&gt;drawRenderNode(node.get(), outBounds);</span><br><span class="line">        &#125;</span><br><span class="line">        layer++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    profiler().draw(mCanvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> drew = mCanvas-&gt;finish();</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>先得到Caches的实例。它是一个单例类，包含了各种绘制资源的cache。然后创建FrameBuilder。该类用于当前帧的构建。FrameBuilder的构造函数中又会创建对应fbo0的LayerBuilder。fbo0即对应通过SurfaceFlinger申请来的on-screen surface，然后将之放入layer stack（通过mLayerBuilders和mLayerStack两个成员维护）。同时还会在initializeSaveStack()函数中创建和初始化Snapshot。就像名字一样，它保存了渲染surface的当前状态的一个“快照”。每个Snapshot有一个指向前继的Snapshot，从而形成一个”栈”。每次调用save()和restore()就相当于压栈和弹栈。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-09-frameBuilder.deferLayers.png" alt="Alt text | center"></p><p>接下来deferLayers()函数处理LayerUpdateQueue中的元素。之前在渲染线程每画一帧前同步信息时调用RenderNode::prepareTree()会遍历DisplayList的树形结构，对于子节点递归调用prepareTreeImpl()，如果是render layer，在RenderNode::pushLayerUpdate()中会将该layer的更新操作记录到LayerUpdateQueue中。至于哪些节点是render layer。主要是根据之前提到的view类型（LAYER_TYPE_NONE/SOFTWARE/HARDWARE）。但会有一个优化，如果一个普通view满足promotedToLayer()定义的条件，它会被当做render layer处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> FrameBuilder::deferLayers(<span class="keyword">const</span> LayerUpdateQueue&amp; layers) &#123;</span><br><span class="line">    <span class="comment">// Render all layers to be updated, in order. Defer in reverse order, so that they'll be</span></span><br><span class="line">    <span class="comment">// updated in the order they're passed in (mLayerBuilders are issued to Renderer in reverse)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = layers.entries().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        RenderNode* layerNode = layers.entries()[i].renderNode;</span><br><span class="line">        <span class="comment">// only schedule repaint if node still on layer - possible it may have been</span></span><br><span class="line">        <span class="comment">// removed during a dropped frame, but layers may still remain scheduled so</span></span><br><span class="line">        <span class="comment">// as not to lose info on what portion is damaged</span></span><br><span class="line">        OffscreenBuffer* layer = layerNode-&gt;getLayer();</span><br><span class="line">        <span class="keyword">if</span> (CC_LIKELY(layer)) &#123;</span><br><span class="line">            ATRACE_FORMAT(<span class="string">"Optimize HW Layer DisplayList %s %ux%u"</span>,</span><br><span class="line">                    layerNode-&gt;getName(), layerNode-&gt;getWidth(), layerNode-&gt;getHeight());</span><br><span class="line"></span><br><span class="line">            Rect layerDamage = layers.entries()[i].damage;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> ensure layer damage can't be larger than layer</span></span><br><span class="line">            layerDamage.doIntersect(<span class="number">0</span>, <span class="number">0</span>, layer-&gt;viewportWidth, layer-&gt;viewportHeight);</span><br><span class="line">            layerNode-&gt;computeOrdering();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// map current light center into RenderNode's coordinate space</span></span><br><span class="line">            Vector3 lightCenter = mCanvasState.currentSnapshot()-&gt;getRelativeLightCenter();</span><br><span class="line">            layer-&gt;inverseTransformInWindow.mapPoint3d(lightCenter);</span><br><span class="line"></span><br><span class="line">            saveForLayer(layerNode-&gt;getWidth(), layerNode-&gt;getHeight(), <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">                    layerDamage, lightCenter, <span class="literal">nullptr</span>, layerNode);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (layerNode-&gt;getDisplayList()) &#123;</span><br><span class="line">                deferNodeOps(*layerNode);</span><br><span class="line">            &#125;</span><br><span class="line">            restoreForLayer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到deferLayers()函数。这里就是把LayerUpdateQueue里的元素按逆序拿出来，依次调用saveForLayer()，deferNodeOps()和restoreForLayer()。saveForLayer()为该render laye创建Snapshot和LayerBuilder并放进mLayerStack和mLayerBuilders。而restoreForLayer()则是它的逆操作。Layer stack和canvas state是栈的结构。saveForLayer() 和restoreForLayer()就相当于一个push stack，一个pop stack。这里核心的deferNodeOps()函数处理该layer对应的DisplayList，将它们按以下类型以batch的形式组织存放在LayerBuilder的mBatches成员中。其中同一类型中能合并的操作还会进行合并（目前只支持Bitmap, Text和Patch三种类型的操作合并）。Batch的类型有以下几种：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\LayerBuilder.h]</span><br><span class="line"><span class="keyword">namespace</span> OpBatchType &#123;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        Bitmap,</span><br><span class="line">        MergedPatch,</span><br><span class="line">        AlphaVertices,</span><br><span class="line">        Vertices,</span><br><span class="line">        AlphaMaskTexture,</span><br><span class="line">        Text,</span><br><span class="line">        ColorText,</span><br><span class="line">        Shadow,</span><br><span class="line">        TextureLayer,</span><br><span class="line">        Functor,</span><br><span class="line">        CopyToLayer,</span><br><span class="line">        CopyFromLayer,</span><br><span class="line"></span><br><span class="line">        Count <span class="comment">// must be last</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下deferNodeOps()函数里是怎么处理RenderNode的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.cpp]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used to define a list of lambdas referencing private FrameBuilder::onXX::defer() methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This allows opIds embedded in the RecordedOps to be used for dispatching to these lambdas.</span></span><br><span class="line"><span class="comment"> * E.g. a BitmapOp op then would be dispatched to FrameBuilder::onBitmapOp(const BitmapOp&amp;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP_RECEIVER(Type) \</span></span><br><span class="line">        [](FrameBuilder&amp; frameBuilder, <span class="keyword">const</span> RecordedOp&amp; op) &#123; frameBuilder.defer##Type(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Type&amp;&gt;(op)); &#125;,</span><br><span class="line"><span class="keyword">void</span> FrameBuilder::deferNodeOps(<span class="keyword">const</span> RenderNode&amp; renderNode) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*OpDispatcher)</span> <span class="params">(FrameBuilder&amp; frameBuilder, <span class="keyword">const</span> RecordedOp&amp; op)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> OpDispatcher receivers[] = BUILD_DEFERRABLE_OP_LUT(OP_RECEIVER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// can't be null, since DL=null node rejection happens before deferNodePropsAndOps</span></span><br><span class="line">    <span class="keyword">const</span> DisplayList&amp; displayList = *(renderNode.getDisplayList());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; chunk : displayList.getChunks()) &#123;</span><br><span class="line">        FatVector&lt;ZRenderNodeOpPair, <span class="number">16</span>&gt; zTranslatedNodes;</span><br><span class="line">        buildZSortedChildList(&amp;zTranslatedNodes, displayList, chunk);</span><br><span class="line"></span><br><span class="line">        defer3dChildren(chunk.reorderClip, ChildrenSelectMode::Negative, zTranslatedNodes);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> opIndex = chunk.beginOpIndex; opIndex &lt; chunk.endOpIndex; opIndex++) &#123;</span><br><span class="line">            <span class="keyword">const</span> RecordedOp* op = displayList.getOps()[opIndex];</span><br><span class="line">            receivers[op-&gt;opId](*<span class="keyword">this</span>, *op);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (CC_UNLIKELY(!renderNode.mProjectedNodes.empty()</span><br><span class="line">                    &amp;&amp; displayList.projectionReceiveIndex &gt;= <span class="number">0</span></span><br><span class="line">                    &amp;&amp; <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(opIndex) == displayList.projectionReceiveIndex)) &#123;</span><br><span class="line">                deferProjectedChildren(renderNode);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        defer3dChildren(chunk.reorderClip, ChildrenSelectMode::Positive, zTranslatedNodes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DisplayList以chunk为单位组合RecordedOp。这些RecordedOp的opId代表它们的类型。根据这个类型调用receivers这个查找表（通过BUILD_DEFERABLE_OP_LUT构造）中的函数。它会调用FrameBuilder中相应的deferXXX函数（比如deferArcOp, deferBitmapOp, deferRenderNodeOp等）。这些deferXXX系函数一般会将RecordedOp用BakedOpState封装一下，然后会调用LayerBuilder的deferUnmergeableOp()和deferMergeableOp()函数将BakedOpState组织进mBatches成员。同时还有两个查找表mBatchLookup和mMergingBatchLookup分别用于不能合并的batch（OpBatch）和能合并的batch（MergingOpBatch）。它们分别用于查找特定类型的最近一个OpBatch或者MergingOpBatch。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-10-DisplayList-chunk.png" alt="Alt text | center"></p><p>先看下deferUnmergeableOp()函数。它会将BakedOpState按batch类型放进mBatches中。mBatches是指向BatchBase对象的vector，每个处理好的BakedOpState都会按类型放进来。如果还未有该类型的batch则创建OpBatch，并把它插入到mBatches的末尾。同时插入mBatchLookup这个查找表（batchId到最近一个该类型的OpBatch对象的映射）。这样之后处理同类型的BakedOpState时候，就会先搜索这个查找表。假如找到了，则进一步在mBatches数组中找到相应的OpBatch并通过它的batchOp()将该BakedOpState加入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\LayerBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> LayerBuilder::deferUnmergeableOp(LinearAllocator&amp; allocator,</span><br><span class="line">        BakedOpState* op, <span class="keyword">batchid_t</span> batchId) &#123;</span><br><span class="line">    onDeferOp(allocator, op);</span><br><span class="line">    OpBatch* targetBatch = mBatchLookup[batchId];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> insertBatchIndex = mBatches.size();</span><br><span class="line">    <span class="keyword">if</span> (targetBatch) &#123;</span><br><span class="line">        locateInsertIndex(batchId, op-&gt;computedState.clippedBounds,</span><br><span class="line">                (BatchBase**)(&amp;targetBatch), &amp;insertBatchIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetBatch) &#123;</span><br><span class="line">        targetBatch-&gt;batchOp(op);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="comment">// new non-merging batch</span></span><br><span class="line">        targetBatch = allocator.create&lt;OpBatch&gt;(batchId, op);</span><br><span class="line">        mBatchLookup[batchId] = targetBatch;</span><br><span class="line">        mBatches.insert(mBatches.begin() + insertBatchIndex, targetBatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看用于合并操作的deferMergeableOp()函数。它也是类似的，当没有可以合并的MergingOpBatch时会创建新的，并且插入到mBatches。因为可能存在情况这个batchId在mBatches中有但是mMergingBatchLookup中没找到（说明还没有可合并的MergingOpBatch对象）或者通过MergingOpBatch::canMergeWidth()判断不满足合并条件。这时候就要插入到mBatches中该类型所在位置。如果很顺利的情况下，前面已经有MergingOpBatch在mMergingBatchLookup中而且又满足合并条件，就通过MergingOpBatch::mergeOp()将该BakedOpState和已有的进行合并。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\LayerBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> LayerBuilder::deferMergeableOp(LinearAllocator&amp; allocator,</span><br><span class="line">        BakedOpState* op, <span class="keyword">batchid_t</span> batchId, <span class="keyword">mergeid_t</span> mergeId) &#123;</span><br><span class="line">    onDeferOp(allocator, op);</span><br><span class="line">    MergingOpBatch* targetBatch = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to merge with any existing batch with same mergeId</span></span><br><span class="line">    <span class="keyword">auto</span> getResult = mMergingBatchLookup[batchId].find(mergeId);</span><br><span class="line">    <span class="keyword">if</span> (getResult != mMergingBatchLookup[batchId].end()) &#123;</span><br><span class="line">        targetBatch = getResult-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (!targetBatch-&gt;canMergeWith(op)) &#123;</span><br><span class="line">            targetBatch = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> insertBatchIndex = mBatches.size();</span><br><span class="line">    locateInsertIndex(batchId, op-&gt;computedState.clippedBounds,</span><br><span class="line">            (BatchBase**)(&amp;targetBatch), &amp;insertBatchIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetBatch) &#123;</span><br><span class="line">        targetBatch-&gt;mergeOp(op);</span><br><span class="line">    &#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">        <span class="comment">// new merging batch</span></span><br><span class="line">        targetBatch = allocator.create&lt;MergingOpBatch&gt;(batchId, op);</span><br><span class="line">        mMergingBatchLookup[batchId].insert(<span class="built_in">std</span>::make_pair(mergeId, targetBatch));</span><br><span class="line"></span><br><span class="line">        mBatches.insert(mBatches.begin() + insertBatchIndex, targetBatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>回到CanvasContext::draw()函数，处理好layer后，下面得就是通过FrameBuilder::deferRenderNodeScene()函数处理FrameBuilder成员mRenderNodes中的RenderNode，其中包含了RootRenderNode（也可能有其它的RenderNode，比如backdrop和overlay nodes）。对于每个RenderNode，如果需要绘制则调用FrameBuilder的deferRenderNode()函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.cpp]</span><br><span class="line"><span class="keyword">void</span> FrameBuilder::deferRenderNode(RenderNode&amp; renderNode) &#123;</span><br><span class="line">    renderNode.computeOrdering();</span><br><span class="line"></span><br><span class="line">    mCanvasState.save(SaveFlags::MatrixClip);</span><br><span class="line">    deferNodePropsAndOps(renderNode);</span><br><span class="line">    mCanvasState.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和前面类似，会为之创建独立的Snapshot（Canvas渲染状态），deferNodePropsAndOps()根据RenderNode中的RenderProperties通过CanvasState设置一堆状态。如果该RenderNode对应是一个render layer，则将它封装为LayerOp（绘制offscreen buffer）并通过deferUnmergeableOp()加入batch。如果该RenderNode对应RenderProperties有半透明效果且不是render layer，则可以将该RenderNode绘制到一个临时的layer（称为save layer）。这是通过BeginLayerOp和EndLayerOp来记录的。正常情况下，还是通过deferNodeOps()来将RenderNode进行batch/merge。这个函数前面已有说明。</p><p>再次回到CanvasContext::draw()函数，下面终于要真得进行渲染了。首先创建BakedOpRenderer，然后调用FrameBuilder::replayBakedOps()函数并将BakedOpRenderer作为参数传进去。注意这是个模板函数，这里模板参数为BakedOpDispatcher。在replayBakedOps()函数中会构造两个用于处理BakedOpState的函数查找表。它们将BakedOpState按操作类型分发到BakedOpDispatcher的相应静态处理函数（onXXX或者onMergedXXX，分别用于非合并和合并的操作） 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.h]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> StaticDispatcher, <span class="keyword">typename</span> Renderer&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">replayBakedOps</span><span class="params">(Renderer&amp; renderer)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;OffscreenBuffer*&gt; temporaryLayers;</span><br><span class="line">        finishDefer();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Defines a LUT of lambdas which allow a recorded BakedOpState to use state-&gt;op-&gt;opId to</span></span><br><span class="line"><span class="comment">         * dispatch the op via a method on a static dispatcher when the op is replayed.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example a BitmapOp would resolve, via the lambda lookup, to calling:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * StaticDispatcher::onBitmapOp(Renderer&amp; renderer, const BitmapOp&amp; op, const BakedOpState&amp; state);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> X(Type) \</span></span><br><span class="line">                [](<span class="keyword">void</span>* renderer, <span class="keyword">const</span> BakedOpState&amp; state) &#123; \</span><br><span class="line">                    StaticDispatcher::on##Type(*(<span class="keyword">static_cast</span>&lt;Renderer*&gt;(renderer)), \</span><br><span class="line">                            <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Type&amp;&gt;(*(state.op)), state); \</span><br><span class="line">                &#125;,</span><br><span class="line">        <span class="keyword">static</span> BakedOpReceiver unmergedReceivers[] = BUILD_RENDERABLE_OP_LUT(X);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Defines a LUT of lambdas which allow merged arrays of BakedOpState* to be passed to a</span></span><br><span class="line"><span class="comment">         * static dispatcher when the group of merged ops is replayed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> X(Type) \</span></span><br><span class="line">                [](<span class="keyword">void</span>* renderer, <span class="keyword">const</span> MergedBakedOpList&amp; opList) &#123; \</span><br><span class="line">                    StaticDispatcher::onMerged##Type#<span class="meta">#s(*(static_cast<span class="meta-string">&lt;Renderer*&gt;(renderer)), opList); \</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">        <span class="keyword">static</span> MergedOpReceiver mergedReceivers[] = BUILD_MERGEABLE_OP_LUT(X);</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> X</span></span><br></pre></td></tr></table></figure><p> 如前面如述，之前已经在FrameBuilder中构造了LayerBuilder的stack。接下来，这儿就是按push时的逆序（z-order高到底）对其中的BakedOpState进行replay，因为下面的layer可能会依赖的上面layer的渲染结果。比如要把上面layer画在FBO上的东西当成纹理画到下一层layer上。对于layer（persistent或者temporary的），先在BakedOpRenderer::startRepaintLayer()中初始化相关GL环境，比如创建FBO，绑定layer对应OffscreenBuffer中的纹理，设置viewport，清color buffer等等。对应地，BakedOpRenderer::endLayer()中最相应的销毁和清理工作。中间调用LayerBuilder::replayBakedOpsImpl()函数做真正的replay动作。对于fbo0（即on-screen surface），也是类似的，只是把startRepaintLayer()和endLayer()换成BakedOpRenderer::startFrame()和BakedOpRenderer::endFrame()。它们的功能也是初始化和销毁GL环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\libs\hwui\FrameBuilder.h]</span><br><span class="line">template &lt;typename StaticDispatcher, typename Renderer&gt;</span><br><span class="line">    void replayBakedOps(Renderer&amp; renderer) &#123;</span><br><span class="line">        .....</span><br><span class="line">       // Relay through layers in reverse order, since layers</span><br><span class="line">        // later in the list will be drawn by earlier ones</span><br><span class="line">        for (int i = mLayerBuilders.size() - 1; i &gt;= 1; i--) &#123;</span><br><span class="line">            GL_CHECKPOINT(MODERATE);</span><br><span class="line">            LayerBuilder&amp; layer = *(mLayerBuilders[i]);</span><br><span class="line">            if (layer.renderNode) &#123;</span><br><span class="line">                // cached HW layer - can&apos;t skip layer if empty</span><br><span class="line">                renderer.startRepaintLayer(layer.offscreenBuffer, layer.repaintRect);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                layer.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                renderer.endLayer();</span><br><span class="line">            &#125; else if (!layer.empty()) &#123;</span><br><span class="line">                // save layer - skip entire layer if empty (in which case, LayerOp has null layer).</span><br><span class="line">                layer.offscreenBuffer = renderer.startTemporaryLayer(layer.width, layer.height);</span><br><span class="line">                temporaryLayers.push_back(layer.offscreenBuffer);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                layer.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers);</span><br><span class="line">                GL_CHECKPOINT(MODERATE);</span><br><span class="line">                renderer.endLayer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        GL_CHECKPOINT(MODERATE);</span><br><span class="line">        if (CC_LIKELY(mDrawFbo0)) &#123;</span><br><span class="line">            const LayerBuilder&amp; fbo0 = *(mLayerBuilders[0]);</span><br><span class="line">            renderer.startFrame(fbo0.width, fbo0.height, fbo0.repaintRect);</span><br><span class="line">            GL_CHECKPOINT(MODERATE);</span><br><span class="line">            fbo0.replayBakedOpsImpl((void*)&amp;renderer, unmergedReceivers, mergedReceivers);</span><br><span class="line">            GL_CHECKPOINT(MODERATE);</span><br><span class="line">            renderer.endFrame(fbo0.repaintRect);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (auto&amp; temporaryLayer : temporaryLayers) &#123;</span><br><span class="line">            renderer.recycleTemporaryLayer(temporaryLayer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在replayBakedOpsImpl()函数中，会根据操作的类型调用前面生成的unmergedReceivers和mergedReceivers两个函数分发表中的对应处理函数。它们实质指向BakedOpDispatcher中的静态函数。这些函数onXXXOp()和onMergedXXXOps()函数大同小异，基本都是通过GlopBuilder将BakedOpState和相关的信息封装成Glop对象，然后调用BakedOpRenderer::renderGlop()，接着通过DefaultGlopReceiver()调用BakedOpRenderer::renderGlopImpl()函数，最后在RenderState::render()中通过GL命令将Glop渲染出来。大功告成。</p><p><strong>结语</strong><br>合并之后，DeferredDisplayList Vector<batch *=""> mBatches 包含全部整合后的绘制命令，之后渲染即可，需要注意的是这里的合并并不是多个变一个，只是做了一个集合，主要是方便使用各资源纹理等，比如绘制文字的时候，需要根据文字的纹理进行渲染，而这个时候就需要查询文字的纹理坐标系，合并到一起方便统一处理，一次渲染，减少资源加载的浪费，当然对于理解硬件加速的整体流程，这个合并操作可以完全无视，甚至可以直观认为，构建完之后，就可以直接渲染，它的主要特点是在另一个Render线程使用OpenGL进行绘制，这个是它最重要的特点。而mBatches中所有的DrawOp都会通过OpenGL被绘制到GraphicBuffer中，最后通过swapBuffers函数调用queueBuffer()通知SurfaceFlinger合成。</batch></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line">EGLBoolean egl_window_surface_v2_t::swapBuffers()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">nativeWindow-&gt;queueBuffer(nativeWindow, buffer); </span><br><span class="line">nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，可以看到一个View上的东西要绘制出来，要经过多步的转化。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-11-View-draw-Surface.png" alt="Alt text | center"></p><p>这样做有几个好处：第一、对绘制操作进行batch/merge可以减少GL的draw call，从而减少渲染状态切换，提高了性能。第二、因为将View层次结构要绘制的东西转化为DisplayList这种“中间语言”的形式，当需要绘制时才转化为GL命令。因此在View中内容没有更改或只有部分属性更改时只要修改中间表示（即RenderNode和RenderProperties）即可，从而避免很多重复劳动。第三、由于DisplayList中包含了要绘制的所有信息，一些属性动画可以由渲染线程全权处理，无需主线程介入，主线程卡住也不会让界面卡住。另一方面，也可以看到一些潜力可挖。比如当前可以合并的操作类型有限。另外主线程和渲染线程间的很多调用还是同步的，并行度或许可以进一步提高。另外Vulkan的引入也可以帮助进一步榨干GPU的能力。<br><strong>例如：</strong></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-12-one_button_draw.png" alt="Alt text | center"></p><p>绘制的批次按文本、图片资源、几何图形等进行分类，分批绘制的效果如下图所示:</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-03-13-BakedOpDispatcher-onMergedBitmapOps.gif" alt="Alt text | center"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1) </a><br><a href="https://blog.csdn.net/luoshengyang/article/details/45601143" target="_blank" rel="noopener">Android应用程序UI硬件加速渲染技术简要介绍和学习计划</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/54234354" target="_blank" rel="noopener">【特别感谢 - Android N中UI硬件渲染（hwui）的HWUI_NEW_OPS(基于Android 7.1)】</a><br><a href="https://www.jianshu.com/p/7bf306c09c7e" target="_blank" rel="noopener">Android DisplayList 构建过程</a><br><a href="http://www.androidperformance.com/2015/08/12/AndroidL-hwui-RenderThread-workflow/" target="_blank" rel="noopener">Android5.0中 hwui 中 RenderThread 工作流程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL</title>
    <link href="http://zhoujinjian.cc/2018/07/20/Android%20Display%20System%EF%BC%882%EF%BC%89%EF%BC%9AAndroid%20Display%20System%20%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B9%8BAndroid%20EGL%20&amp;&amp;%20OpenGL/"/>
    <id>http://zhoujinjian.cc/2018/07/20/Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL/</id>
    <published>2018-07-19T16:00:00.000Z</published>
    <updated>2018-06-20T15:11:14.394Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/display.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="http://www.kandroid.org/board/data/board/conference/file_in_body/1/3AndroidGraphicsAndAndroidEGL.pdf" target="_blank" rel="noopener">【特别感谢 - Android Graphics and Android EGL】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/17427491" target="_blank" rel="noopener">【特别感谢 - Android 4.4 (KitKat) Design Pattern-Graphics Subsystem】</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/17293325" target="_blank" rel="noopener">【特别感谢 - Android 4.4 (KitKat) in virtualization VSync signal】</a><br><a href="https://blog.csdn.net/yangwen123/article/details/22647255" target="_blank" rel="noopener">【特别感谢 - Android显示系统设计框架介绍】</a><br><a href="http://www.cnblogs.com/samchen2009/p/3367496.html" target="_blank" rel="noopener">【特别感谢 - 图解Android - Android GUI 系统 (2) - 窗口管理 (View, Canvas, Window Manager)】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><p>【Android Display System 系统分析系列】：<br>【Android Display System（1）：Android 7.1.2 (Android N) Android Graphics 系统 分析】<br>【Android Display System（2）：Android Display System 系统分析之Android EGL &amp;&amp; OpenGL】<br>【Android Display System（3）：Android Display System 系统分析之HardwareRenderer.draw()绘制流程分析】<br>【Android Display System（4）：Android Display System 系统分析之Gralloc &amp;&amp; HWComposer模块分析】<br>【Android Display System（5）：Android Display System 系统分析之Display Driver Architecture】</p><hr><blockquote><p><strong>Android EGL、GLES_CM、GLES2：</strong></p></blockquote><p>\frameworks\native\opengl\libs\EGL</p><ul><li>egl.cpp</li><li>egl_display.cpp</li><li>eglApi.cpp</li><li>Loader.cpp</li></ul><p>\frameworks\native\opengl\libs\GLES_CM</p><ul><li>gl.cpp</li><li>gl_api.in</li><li>glext_api.in</li></ul><p>\frameworks\native\opengl\libs\GLES2</p><ul><li>gl2.cpp</li><li>gl2_api.in</li><li>gl2ext_api.in</li></ul><blockquote><p><strong>OpenGL Native &amp;&amp; JNI ：</strong></p></blockquote><p>\frameworks\base\core\jni\</p><ul><li>android_opengl_GLES10.cpp</li><li>android_opengl_GLES10Ext.cpp</li><li>android_opengl_GLES11.cpp</li><li>android_opengl_GLES11Ext.cpp</li><li>android_opengl_GLES20.cpp</li><li>android_opengl_GLES30.cpp</li><li>android_opengl_GLES31.cpp</li><li>android_opengl_GLES31Ext.cpp</li><li>android_opengl_GLES32.cpp</li><li>com_google_android_gles_jni_EGLImpl.cpp</li><li>com_google_android_gles_jni_GLImpl.cpp</li></ul><blockquote><p><strong>Opengl Java：</strong></p></blockquote><p>\frameworks\base\opengl\java\android\opengl</p><ul><li>GLES10.java</li><li>GLES10Ext.java</li><li>GLLogWrapper.java</li><li>GLSurfaceView.java</li><li>EGLDisplay.java</li><li>EGLConfig.java</li><li>EGLContext.java</li><li>EGLSurface.java</li></ul><p>\frameworks\base\opengl\java\javax\microedition\khronos\opengles</p><ul><li>GL10.java</li><li>GL11.java</li></ul><p>\frameworks\base\opengl\java\com\google\android\gles_jni</p><ul><li>GLImpl.java</li><li>EGLImpl.java</li><li>EGLConfigImpl.java</li><li>EGLContextImpl.java</li><li>EGLDisplayImpl.java</li></ul><hr><p>总体架构：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-01-Android-Graphics-Architecture-EGL.png" alt="Alt text | center"></p><p><a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android Display System（1）- Android Graphics 系统 分析】</a></p><p>####（一）、 Android EGL 应用实例</p><h5 id="1-1、Android-Graphics-测试程序"><a href="#1-1、Android-Graphics-测试程序" class="headerlink" title="1.1、Android Graphics 测试程序"></a>1.1、Android Graphics 测试程序</h5><p>首先看一下Android测试程序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">参考\frameworks\native\services\surfaceflinger\tests\Transaction_test.cpp</span><br><span class="line">拷贝同目录下.mk文件push到手机运行即可看到效果。</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gtest/gtest.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/native_window.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IMemory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/ISurfaceComposer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/Surface.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gui/SurfaceComposerClient.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/gui/ComposerService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;private/gui/LayerState.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/String8.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ui/DisplayInfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill an RGBA_8888 formatted surface with a single color.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillSurfaceRGBA8</span><span class="params">(<span class="keyword">const</span> sp&lt;SurfaceControl&gt;&amp; sc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint8_t</span> r, <span class="keyword">uint8_t</span> g, <span class="keyword">uint8_t</span> b)</span> </span>&#123;</span><br><span class="line">    ANativeWindow_Buffer outBuffer;</span><br><span class="line">    sp&lt;Surface&gt; s = sc-&gt;getSurface();</span><br><span class="line">    ASSERT_TRUE(s != <span class="literal">NULL</span>);</span><br><span class="line">    ASSERT_EQ(NO_ERROR, s-&gt;lock(&amp;outBuffer, <span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">uint8_t</span>* img = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint8_t</span>*&gt;(outBuffer.bits);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; outBuffer.height; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; outBuffer.width; x++) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span>* pixel = img + (<span class="number">4</span> * (y*outBuffer.stride + x));</span><br><span class="line">            pixel[<span class="number">0</span>] = r;</span><br><span class="line">            pixel[<span class="number">1</span>] = g;</span><br><span class="line">            pixel[<span class="number">2</span>] = b;</span><br><span class="line">            pixel[<span class="number">3</span>] = <span class="number">255</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ASSERT_EQ(NO_ERROR, s-&gt;unlockAndPost());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LayerTest</span> :</span> <span class="keyword">public</span> ::testing::Test &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SetUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());</span><br><span class="line"></span><br><span class="line">        sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">                ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">        DisplayInfo info;</span><br><span class="line">        SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line">        <span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Background surface black</span></span><br><span class="line">        mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"BG Test Surface"</span>), displayWidth, displayHeight<span class="number">-720</span>,</span><br><span class="line">                PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mBGSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mBGSurfaceControl-&gt;isValid());</span><br><span class="line">        fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface red</span></span><br><span class="line">        mFGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"FG Test Surface"</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControl-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface blue</span></span><br><span class="line">        mFGSurfaceControlBlue = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"FG Test Surface"</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlBlue != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlBlue-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Foreground surface green</span></span><br><span class="line">        mFGSurfaceControlGreen = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"FG Test Surface"</span>), <span class="number">360</span>, <span class="number">360</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlGreen != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mFGSurfaceControlGreen-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Synchronization surface</span></span><br><span class="line">        mSyncSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">                String8(<span class="string">"Sync Test Surface"</span>), <span class="number">1</span>, <span class="number">1</span>, PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line">        ASSERT_TRUE(mSyncSurfaceControl != <span class="literal">NULL</span>);</span><br><span class="line">        ASSERT_TRUE(mSyncSurfaceControl-&gt;isValid());</span><br><span class="line"></span><br><span class="line">        fillSurfaceRGBA8(mSyncSurfaceControl, <span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SurfaceComposerClient::openGlobalTransaction()</span></span><br><span class="line"></span><br><span class="line">        SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">        mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//black</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line">        <span class="comment">//red</span></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-3</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"><span class="comment">//blue</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(<span class="number">360</span>, <span class="number">360</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show());</span><br><span class="line"><span class="comment">//green</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(<span class="number">720</span>, <span class="number">720</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show());</span><br><span class="line"></span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth<span class="number">-2</span>,</span><br><span class="line">                displayHeight<span class="number">-2</span>));</span><br><span class="line">        ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line">        SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">waitForPostedBuffers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">TearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mComposerClient-&gt;dispose();</span><br><span class="line">        mBGSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mFGSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mSyncSurfaceControl = <span class="number">0</span>;</span><br><span class="line">        mComposerClient = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">waitForPostedBuffers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Since the sync surface is in synchronous mode (i.e. double buffered)</span></span><br><span class="line">        <span class="comment">// posting three buffers to it should ensure that at least two</span></span><br><span class="line">        <span class="comment">// SurfaceFlinger::handlePageFlip calls have been made, which should</span></span><br><span class="line">        <span class="comment">// guaranteed that a buffer posted to another Surface has been retired.</span></span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControl, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControlBlue, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line">        fillSurfaceRGBA8(mFGSurfaceControlGreen, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    fillSurfaceRGBA8(mSyncSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;SurfaceComposerClient&gt; mComposerClient;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mBGSurfaceControl;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControl;<span class="comment">//red</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControlBlue;</span><br><span class="line">    sp&lt;SurfaceControl&gt; mFGSurfaceControlGreen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This surface is used to ensure that the buffers posted to</span></span><br><span class="line">    <span class="comment">// mFGSurfaceControl have been picked up by SurfaceFlinger.</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; mSyncSurfaceControl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TEST_F(LayerTest, LayerWorks) &#123;</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">DisplayInfo info;</span><br><span class="line">SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line"><span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line"></span><br><span class="line">mComposerClient-&gt;setDisplayLayerStack(display, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br><span class="line"><span class="comment">//red</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-3</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;setPosition(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControl-&gt;show());</span><br><span class="line"><span class="comment">//blue</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setLayer(INT_MAX<span class="number">-2</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;setPosition(<span class="number">360</span>, <span class="number">360</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlBlue-&gt;show());</span><br><span class="line"><span class="comment">//green</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;setPosition(<span class="number">720</span>, <span class="number">720</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mFGSurfaceControlGreen-&gt;show());</span><br><span class="line"><span class="comment">//Sync</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-1</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;setPosition(displayWidth<span class="number">-2</span>,</span><br><span class="line">displayHeight<span class="number">-2</span>));</span><br><span class="line">ASSERT_EQ(NO_ERROR, mSyncSurfaceControl-&gt;show());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SurfaceComposerClient::closeGlobalTransaction(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果（保持运行，可以看到界面最顶层会绘制黑色背景和红绿蓝三个色块）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-02-Android-graphics-surface-test.gif" alt="Alt text | center"></p><p>可以看到比较关键的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SurfaceComposerClient</span></span><br><span class="line">mComposerClient = <span class="keyword">new</span> SurfaceComposerClient;</span><br><span class="line">ASSERT_EQ(NO_ERROR, mComposerClient-&gt;initCheck());</span><br><span class="line"><span class="comment">//获取display信息</span></span><br><span class="line">sp&lt;IBinder&gt; display(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">        ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">DisplayInfo info;</span><br><span class="line">SurfaceComposerClient::getDisplayInfo(display, &amp;info);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> displayWidth = info.w;</span><br><span class="line"><span class="keyword">ssize_t</span> displayHeight = info.h;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Background surface black</span></span><br><span class="line"><span class="comment">//请求SurfaceFlinger创建Surface</span></span><br><span class="line">mBGSurfaceControl = mComposerClient-&gt;createSurface(</span><br><span class="line">        String8(<span class="string">"BG Test Surface"</span>), displayWidth, displayHeight<span class="number">-720</span>,</span><br><span class="line">        PIXEL_FORMAT_RGBA_8888, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//填充Surface</span></span><br><span class="line">fillSurfaceRGBA8(mBGSurfaceControl, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置Layer层级</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;setLayer(INT_MAX<span class="number">-4</span>));</span><br><span class="line"><span class="comment">//SurfaceControl-&gt;show()显示surface</span></span><br><span class="line">ASSERT_EQ(NO_ERROR, mBGSurfaceControl-&gt;show());</span><br></pre></td></tr></table></figure><p>这部分的分析请参考<a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">【Android Display System（1）- Android Graphics 系统 分析】</a><br>我们这里主要为了引出Android底层如何利用EGL绘图。</p><h5 id="1-2、Android-BootAnimation-开机动画-EGL在Android中应用"><a href="#1-2、Android-BootAnimation-开机动画-EGL在Android中应用" class="headerlink" title="1.2、Android BootAnimation 开机动画(EGL在Android中应用)"></a>1.2、Android BootAnimation 开机动画(EGL在Android中应用)</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-03-Android-boot-egl.png" alt="Alt text | center"></p><p>关键代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\cmds\bootanimation\BootAnimation.cpp]</span><br><span class="line"><span class="keyword">status_t</span> BootAnimation::readyToRun() &#123;</span><br><span class="line">    mAssets.addDefaultAssets();</span><br><span class="line">    sp&lt;IBinder&gt; dtoken(SurfaceComposerClient::getBuiltInDisplay(</span><br><span class="line">            ISurfaceComposer::eDisplayIdMain));</span><br><span class="line">    DisplayInfo dinfo;</span><br><span class="line">    <span class="keyword">status_t</span> status = SurfaceComposerClient::getDisplayInfo(dtoken, &amp;dinfo);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// create the native surface</span></span><br><span class="line">    sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(String8(<span class="string">"BootAnimation"</span>),</span><br><span class="line">            dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565);</span><br><span class="line"></span><br><span class="line">    SurfaceComposerClient::openGlobalTransaction();</span><br><span class="line">    control-&gt;setLayer(<span class="number">0x40000000</span>);</span><br><span class="line">    SurfaceComposerClient::closeGlobalTransaction();</span><br><span class="line"></span><br><span class="line">    sp&lt;Surface&gt; s = control-&gt;getSurface();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize opengl and egl</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// (1)、获得 EGLDisplay 对象。</span></span><br><span class="line">    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);</span><br><span class="line">    <span class="comment">// (2)、初始化 EGLDisplay 对象</span></span><br><span class="line">    eglInitialize(display, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// (3)、选择 EGLConfig</span></span><br><span class="line">    eglChooseConfig(display, attribs, &amp;config, <span class="number">1</span>, &amp;numConfigs);</span><br><span class="line">    <span class="comment">// (4)、创建 Windows Surface</span></span><br><span class="line">    surface = eglCreateWindowSurface(display, config, s.get(), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// (5)、创建 EGL context</span></span><br><span class="line">    context = eglCreateContext(display, config, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_WIDTH, &amp;w);</span><br><span class="line">    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;h);</span><br><span class="line">    <span class="comment">// (6)、启用前面创建的 EGL context</span></span><br><span class="line">    <span class="keyword">if</span> (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">bool</span> BootAnimation::playAnimation(<span class="keyword">const</span> Animation&amp; animation)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">                <span class="comment">// (7)、OpenGL ES API 绘制图形：gl_*()</span></span><br><span class="line">                glDrawTexiOES(xc, mHeight - (yc + frame.trimHeight),</span><br><span class="line">                              <span class="number">0</span>, frame.trimWidth, frame.trimHeight);</span><br><span class="line">                ......</span><br><span class="line">                <span class="comment">// (8)、SwapBuffers显示</span></span><br><span class="line">                eglSwapBuffers(mDisplay, mSurface);</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用EGL一般会经历以上几个步骤。</p><h5 id="1-2、Understanding-Android-Graphics-Internals"><a href="#1-2、Understanding-Android-Graphics-Internals" class="headerlink" title="1.2、Understanding Android Graphics Internals"></a>1.2、Understanding Android Graphics Internals</h5><p>要深入了解Android Graphics机制，需要了解熟悉以下知识（包括但不限于）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-04-understand-android-graphics-internals.png" alt="Alt text | center"></p><p>####（二）、OpenGL ES 2.0 知识串讲<br>在了解EGL之前，先来看看前人总结的知识<a href="http://geekfaner.com/shineengine/index.html" target="_blank" rel="noopener">OPENGL ES 2.0 知识串讲</a>：</p><h5 id="2-1、写在前面的话"><a href="#2-1、写在前面的话" class="headerlink" title="2.1、写在前面的话"></a>2.1、写在前面的话</h5><h5 id="2-1-1、电脑是做什么用的"><a href="#2-1-1、电脑是做什么用的" class="headerlink" title="2.1.1、电脑是做什么用的?"></a>2.1.1、电脑是做什么用的?</h5><p>电脑又被称为计算机,那么最重要的工作就是计算。看过三体的同学都知道, 电脑中有无数纳米级别的计算单元,通过 0 和 1 的转换,完成加减乘除的操作。</p><h5 id="2-1-2、是什么使得电脑工作"><a href="#2-1-2、是什么使得电脑工作" class="headerlink" title="2.1.2、是什么使得电脑工作?"></a>2.1.2、是什么使得电脑工作?</h5><p>驱动,驱使着硬件完成工作。</p><h5 id="2-1-3、谁来写驱动"><a href="#2-1-3、谁来写驱动" class="headerlink" title="2.1.3、谁来写驱动?"></a>2.1.3、谁来写驱动?</h5><p>制造电脑的公司自己来写驱动,因为他们对自己的底层硬件架构最熟悉。</p><h5 id="2-1-4、谁会使用驱动"><a href="#2-1-4、谁会使用驱动" class="headerlink" title="2.1.4、谁会使用驱动?"></a>2.1.4、谁会使用驱动?</h5><p>所有的软件工程师都会直接或者间接的使用到驱动。</p><p>那么问题来了,如果说不同的电脑公司,制造出来不同的硬件,使用不同的 驱动,提供出来不同的接口供软件工程师进行使用,那么软件工程师就要崩溃了。</p><p>所以,一定是需要一个标准,来统一一下。</p><h5 id="2-1-5、那么在哪里进行统一"><a href="#2-1-5、那么在哪里进行统一" class="headerlink" title="2.1.5、那么在哪里进行统一?"></a>2.1.5、那么在哪里进行统一?</h5><p>硬件没有办法统一,每个电脑公司为了优化自己电脑性能和功耗,制造出来 不同的硬件架构,这是需要无数的心血完成的,如果统一了,那么就不需要那么 多电脑公司了。</p><p>所以只能统一驱动的接口。</p><p>电脑组件大致分为:CPU、GPU、内存、总线等。而 OpenGL 就是 GPU 驱动 的一套标准接口(OpenGL ES 为嵌入式设备 GPU 驱动的标准接口,比如手机, OpenGL ES 全称:OpenGL for Embedded Systems)。</p><p>所以综上所述,我使用了 5 个问题,引出了 OpenGL 的用处:就是将复杂的、 各种各样的 GPU 硬件包装起来,各个电脑公司编写自家的驱动,然后提供出来 一套统一的接口,供上层软件工程师调用。这样,世界就和平了。</p><h5 id="2-1-6、谁这么牛-定义了-OpenGL-这套标准"><a href="#2-1-6、谁这么牛-定义了-OpenGL-这套标准" class="headerlink" title="2.1.6、谁这么牛,定义了 OpenGL 这套标准?"></a>2.1.6、谁这么牛,定义了 OpenGL 这套标准?</h5><p>Khronos。每当我打这几个字母的时候,都会抱有一种敬畏的心理,因为它 不是一家公司,它是一个组织,它是由众多大公司联合组建而来,比如 Apple、 Intel、AMD、Google、ARM、Qualcomm、Nvidia 等等等等。各个大公司投入了大 量的人力、资金等创建了这个组织。对电脑 GPU 定义了统一的接口 OpenGL,对 手机 GPU 定义了统一的接口 OpenGL ES(我也非常有幸,在 Intel 工作期间,跟 Intel 驻 Khronos 的 3D 负责人共事了一段时间,每周一次的跨洋电话,都会让我受益匪浅)</p><p>这个组织除了定义了 OpenGL 接口之外,还定义了很多其他接口。目前针对 GPU 又提出了另外一套更底层的接口 Vulkan,这是一套比 OpenGL 更底层的接口, 使用其可以更容易优化,不过目前硬件厂商的驱动还有待开发,可能普及 Vulkan 还需要很多年。就好比 OpenGL ES 已经发展到了 3.1,而市面上的手机很多还是 只能支持 OpenGL ES 2.0 一样。所以新的科技从提出,到实现,到量产,到使用, 到普及,是一段很长的路。</p><p>所以,我们现在学习 OpenGL ES 2.0 是适时的,且是非常必要的(不懂 2.0, 想直接学习更难的 3.0、3.1、Vulkan,很难)。</p><p>事先预告一下,OpenGL ES 2.0 会分十三个课程,结束之后,我会立即奉上 OpenGL ES 3.0 在 OpenGL ES 2.0 基础上的改变。</p><h5 id="2-1-7、OpenGL-和我们游戏（Android-）开发者有什么关系"><a href="#2-1-7、OpenGL-和我们游戏（Android-）开发者有什么关系" class="headerlink" title="2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?"></a>2.1.7、OpenGL 和我们游戏（Android ）开发者有什么关系?</h5><p>电脑/手机屏幕上显示的东西,要么是 2D 的,要么是 3D 的,那么如果是 3D 的,不管是 App 也好,游戏也好,简单的图片界面也好,底层都是通过 GPU、 通过 OpenGL(ES)绘制出来的。</p><p>开发 App 的时候,是通过创建控件的方式,而控件已经对底层进行了一层封装,所以 App 开发者很少会接触到 OpenGL(ES)。</p><p>游戏的开发是通过游戏引擎,而游戏引擎的最底层,是直接调用了 OpenGL(ES),直接对 GPU 进行控制。</p><p>所以说游戏引擎工程师必须懂 OpenGL(ES),而游戏开发者,想要更好的对游戏进行更好的理解和优化,也建议学一些 OpenGL(ES)。</p><h5 id="2-1-8、DirectX-是什么"><a href="#2-1-8、DirectX-是什么" class="headerlink" title="2.1.8、DirectX 是什么?"></a>2.1.8、DirectX 是什么?</h5><p>最后一个问题。我们发现 Khronos 组织的成员中,我没有提到大名鼎鼎的微 软,因为微软不在组织中,而它提出了自己的 GPU 驱动标准,DirectX。</p><p>所以目前手机,不管是 iOS 还是 Android,都是支持 OpenGL ES。电脑,Windows 系统支持 DirectX 和 OpenGL,Linux/Mac(Unix)系统支持 OpenGL。</p><h4 id="2-2、OpenGL-ES-的两个小伙伴"><a href="#2-2、OpenGL-ES-的两个小伙伴" class="headerlink" title="2.2、OpenGL ES 的两个小伙伴"></a>2.2、OpenGL ES 的两个小伙伴</h4><p>虽然,我们教程的标题是 OpenGL ES,但是我们的内容将不仅限于 OpenGL ES。 OpenGL ES 是负责 GPU 工作的,目的是通过 GPU 计算,得到一张图片,这张图 片在内存中其实就是一块 buffer,存储有每个点的颜色信息等。而这张图片最终是要显示到屏幕上,所以还需要具体的窗口系统来操作,OpenGL ES 并没有相关的函数。所以,OpenGL ES 有一个好搭档 EGL。</p><p>EGL,全称:embedded Graphic Interface,是 OpenGL ES 和底层 Native 平台 视窗系统之间的接口。所以大概流程是这样的:首先,通过 EGL 获取到手机屏幕 的 handle,获取到手机支持的配置(RGBA8888/RGB565 之类,表示每个像素中包 含的颜色等信息的存储空间是多少位),然后根据这个配置创建一块包含默认 buffer 的 surface(buffer 的大小是根据屏幕分辨率乘以每个像素信息所占大小计 算而得)和用于存放 OpenGL ES 状态集的 context,并将它们 enable 起来。然后, 通过 OpenGL ES 操作 GPU 进行计算,将计算的结果保存在 surface 的 buffer 中。 最后,使用 EGL,将绘制的图片显示到手机屏幕上。</p><p>而在 OpenGL ES 操作 GPU 计算的时候,还需要介绍 OpenGL ES 的另外一个好搭档 GLSL。</p><p>GLSL,全称:OpenGL Shading Language,是 OpenGL ES 中使用到的着色器的 语言,用这个语言可以编写小程序运行在 GPU 上。</p><p>在这里需要先提到 CPU 和 GPU 的区别,它们的功能都是用于计算,也都是由很多核组成,区别在于 CPU 的核比较少,但是单个核的计算能力比较强,而 GPU 的核很多,但是每个核的计算能力都不算特别强。目前 GPU 的主要工作是用于生成图片(现在也有通过 GPU 进行高性能运算_并行运算,但是在这里不属于讨论的范围),原因就是图片是由很多像素组成,每个像素都包含有颜色、深度等信息,而为了得到这些信息数据,针对每个像素点的计算,是可以通过统一的算法来完成。GPU 就擅长处理针对这种大规模数据,使用同一个算法进行计算。而这个算法,就是使用 GLSL 写成 Shader,供 GPU 运算使用。</p><p>在图形学的视角中,所有的图片都是由三角形构成的。所以通过 OpenGL ES 绘制图片的时候,我们需要通过 OpenGL ES API 创建用于在 GPU 上运行的 shader, 然后将通过 CPU 获取到的图片顶点信息,传入 GPU 中的 Shader 中。在 Vertex Shader 中通过矩阵变换,将顶点坐标从模型坐标系转换到世界坐标系,再到观察坐标系,到裁剪坐标系,最后投影到屏幕坐标系中,计算出在屏幕上各个顶点的坐标。然后,通过光栅化,以插值的方法得到所有像素点的信息,并在 Fragment shader 中计算出所有像素点的颜色。最后,通过 OpenGL ES 的 API 设定的状态,将得到的像素信息进行 depth/stencil test、blend,得到最终的图片。</p><h4 id="2-3、屏幕图片的本质和产生过程"><a href="#2-3、屏幕图片的本质和产生过程" class="headerlink" title="2.3、屏幕图片的本质和产生过程"></a>2.3、屏幕图片的本质和产生过程</h4><p>当我们买一个手机的时候,我们会非常关注这个手机的分辨率。分辨率代表着像素的多少,比如我们熟知的 iphone6 的分辨率为 1334×750,而 iphone6 plus 的分辨率是1920×1080。</p><p>手机屏幕上的图片,是由一个一个的像素组成,那么可以计算出来,一个屏幕上的图片,是由上百万个像素点组成。而每个像素点都有自己的颜色,每种颜色都是由 RGB 三原色组成。三原色按照不同的比例混合,组成了手机所能显示出来的颜色。</p><p>每个像素的颜色信息都保存在 buffer 中,这块 buffer 可以分给 RGB 每个通 道各 8bit 进行信息保存,也可以分给 RGB 每个通道不同的空间进行信息保存, 比如由于人眼对绿色最敏感,那么可以分配给 G 通道 6 位,R 和 B 通道各 5 位。这些都是常见的手机配置。假如使用 RGB888 的手机配置,也就是每种颜色的取值从 0 到 255,0 最小,255 最大。那么红绿蓝都为 0 的时候,这个像素点的颜色就是黑色,红绿蓝都为 255 的时候,这个像素点的颜色就是白色。当红为 255, 绿蓝都为 0 的时候,这个像素点的颜色就是红色。当红绿为 255,蓝为 0 的时候, 这个像素点的颜色就是黄色。当然不是只取 0 或者 255,可以取 0-255 中间的值, 100,200,任意在 0 和 255 中间的值都没有问题。那么我们可以算一下,按照红绿蓝不同比例进行搭配,每个像素点,可以显示的颜色有 255<em>255</em>255=16581375 种,这个数字是非常恐怖,所以我们的手机可以显示出来各种各样的颜色。 这里在延伸的科普一下,我们看到手机可以显示那么多种颜色了,但是是不是说我们的手机在颜色上就已经发展到极致了呢?其实是远远没有的,在这个手机配置下,三原色中每一种的取值可以从 0 到 255,而在现实生活中,它们的取 值可以从 0 到 1 亿,而我们人类的眼睛所能看到的范围是,从 0 到 10 万。所以手机硬件还存在很大的提升空间。而在手机硬件提升之前,我们也可以通过 HDR 等技术尽量的在手机中多显示一些颜色。所以,讲到这里,我们知道了,手机屏幕上显示的图片,是由这上百万个像素点,以及这上百万个像素点对应的颜色组成的。</p><p>用程序员的角度来看,就是手机屏幕对应着一块 buffer,这块 buffer 对应上百万个像素点,每个像素点需要一定的空间来存储其颜色。如果使用更加形象的例子来比喻,手机屏幕对应的 buffer 就好像一块巨大的棋盘,棋盘上有上百万个格子,每个格子都有自己的颜色,那么从远处整体的看这个棋盘,就是我们看手机的时候显示的样子。这就是手机屏幕上图片的本质。</p><p>通过我们对 EGL、GLSL、OpenGL ES 的理解,借助一张图片,从专业的角度来解释一下手机屏幕上的图片是如何生成的。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-05-OpenGL-Picture-Generate.png" alt="Alt text | center"></p><p>首先,通过 EGL 获取手机屏幕,进而获取到手机屏幕对应的这个棋盘,同时, 在手机的 GPU 中根据手机的配置信息,生成另外一个的棋盘和一个本子,本子是用于记录这个棋盘初始颜色等信息。</p><p>然后,OpenGL ES 就好像程序员的画笔,程序员需要知道自己想画什么东西,比如想画一个苹果,那么就需要通过为数不多的基本几何图元(如点、直线、三 角形)来创建所需要的模型。比如用几个三角形和点和线来近似的组成这个苹果 (图形学的根本就是点、线和三角形,所有的图形,都可以由这些基本图形组成, 比如正方形或者长方形,就可以由两个三角形组成,圆形可以由无数个三角形组成,只是三角形的数量越多,圆形看上去越圆润)。</p><p>根据这些几何图元,建立数学描述,比如每个三角形或者线的顶点坐标位置、每个顶点的颜色。得到这些信息之后,可以先通过 OpenGL ES 将 EGL 生成的棋盘 (buffer)进行颜色初始化,一般会被初始化为黑色。然后将刚才我们获取到的顶点坐标位置,通过矩阵变化的方式,进行模型变换、观察变换、投影变换,最后映射到屏幕上,得到屏幕上的坐标。这个步骤可以在 CPU 中完成,也就是在 OpenGL ES 把坐标信息传给 Shader 之前,在 CPU 中通过矩阵相乘等方式进行更新,或者是直接把坐标信息通过 OpenGL ES 传给 Shader,同时也把矩阵信息传给 Shader,通过 Shader 在 GPU 端进行坐标更新,更新的算法通过 GLSL 写在 Shader 中。这个进行坐标更新的 Shader 被称为 vertex shader,简称 VS,是 OpenGL ES2.0, 也是 GLSL130 版本对应的最重要两个 shader 之一,作用是完成顶点操作阶段中的所有操作。经过矩阵变换后的像素坐标信息,为屏幕坐标系中的坐标信息。在 VS 中,最重要的输入为顶点坐标、矩阵(还可以传入顶点的颜色、法线、纹理 坐标等信息),而最重要的运算结果,就是这个将要显示在屏幕上的坐标信息。 VS 会针对传入的所有顶点进行运算,比如在 OpenGL ES 中只想绘制一个三角形 和一条线,这两个图元不共享顶点,那么在 VS 中,也就传入了 5 个顶点信息, 根据矩阵变换,这 5 个顶点的坐标转换成了屏幕上的顶点坐标信息,从图上显示, 也就是从左上角的图一,更新成了中上图的图二。</p><p>再然后,当图二生成之后,我们知道了图元在屏幕上的顶点位置,而顶点的颜色在 VS 中没有发生变化,所以图元的顶点颜色我们也是知道的。下面就是根据 OpenGL ES 中设置的状态,表明哪些点连成线,哪些点组成三角形,进行图元装配,也就是我们在右上角的图三中看到的样子。这个样子在 GPU 中不会显示, 那几条线也是虚拟的线,是不会显示在棋盘 buffer 中的,而 GPU 做的是光珊化,这一步是发生在从 VS 出来,进入另外一个Shader (Pixel shader,也称 fragment shader)之前,在 GPU 中进行的。作用是把线上,或者三角形内部所有的像素点找到,并根据插值或者其他方式计算出其颜色等信息(如果不通过插值,可以使用其他的方法,这些在 OpenGL ES 和 GLSL 中都可以进行设置)。也就生成了下面一行的图四和图五。</p><p>我们大概可以看到在图 4 和图 5 种出现了大量的顶点,大概数一下估计有 40 个点左右,这些点全部都会进入 PS 进行操作,在 PS 中可以对这些点的颜色进行操作,比如可以只显示这些点的红色通道,其他的绿蓝通道的值设置为 0, 比如之前某个点的 RGB 为 200,100,100。在 PS 中可以将其通过计算,更新为 200,0,0。这样做的结果就是所显示的图片均为红色,只是深浅不同。这也就好像戴上了一层红色的滤镜,其他颜色均为滤掉了。所以用 PS 来做滤镜是非常方便的。再比如,假如一盏红色的灯照到了苹果上,那么显示出来的颜色就是在苹果原本的颜色基础上,红色值进行一定的增值。</p><p>所以,总结一下,经过 VS 和 PS 之后,程序员想要画的东西,就已经被画出来了。想要绘制的东西,也就是左下角图五的样子。然后再根据 OpenGL ES 的设置,对新绘制出来的东西进行 Depth/Stencil Test,剔除掉被遮挡的部分,将剩余部分与原图片进行 Blend,生成新的图片。 最后,通过 EGL,把这个生成的棋盘 buffer 和手机屏幕上对应的棋盘 buffer 进行调换,让手机屏幕显示这个新生成的棋盘,旧的那个棋盘再去绘制新的图片信息。周而复始,不停的把棋盘进行切换,也就像过去看连环画一样,动画就是由一幅幅的图片组成,当每秒切换的图片数量超过 30 张的时候,我们的手机也就看到了动态的效果。这就是屏幕上图片的产生过程。</p><p>在这里再进行一下延伸,这个例子中,VS 计算了 5 个顶点的数据,PS 计算 了大概 40 个顶点的数据,而我们刚才说过,手机中存在上百万个像素点,这上百万个像素点都可以是顶点,那么这个计算量是非常大的。而这也是为什么要将 shader 运算放在 GPU 中的原因,因为 GPU 擅长进行这种运算。</p><p>我们知道 CPU 现在一般都是双核或者 4 核,多的也就是 8 核或者 16 核,但是 GPU 动辄就是 72 核,多的还有上千核,这么多核的目的就是进行并行运算, 虽然单个的 GPU 核不如 CPU 核,但是单个的 GPU 核足够进行加减乘除运算,所以大量的 GPU 核用在图形学像素点运算上,是非常有效的。而 CPU 虽然单个很强大,而且也可以通过多级流水来提高吞吐率,但是终究还是不如 GPU 的多核来得快。但是在通过 GPU 进行多核运算的时候,需要注意的是:如果 shader 中存放判断语句,就会对 GPU 造成比较大的负荷,不同 GPU 的实现方式不同,多数 GPU 会对判断语句的两种情况都进行运算,然后根据判断结果取其中一个。</p><p>我们通过这个例子再次清楚了 OpenGL ES 绘制的整个流程,而这个例子也是最简单的一个例子,其中有很多 OpenGL ES 的其他操作没有被涉及到。比如,我们绘制物体的颜色大多是从纹理中采样出来,那么设计到通过 OpenGL ES 对纹理 进行操作。而 OpenGL ES 的这些功能,我们会在下面一点一点进行学习。</p><h4 id="2-4-2、OpenGL-流水线（pipeline）"><a href="#2-4-2、OpenGL-流水线（pipeline）" class="headerlink" title="2.4.2、OpenGL 流水线（pipeline）"></a>2.4.2、OpenGL 流水线（pipeline）</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-06-OpenGL-ES-pipeline.png" alt="Alt text | center"></p><p>EGL 是用于与手机设备打交道,比如获取绘制 buffer,将绘制 buffer 展现到手机屏幕中。那么抛开 EGL 不说,OpenGL ES 与 GLSL 的主要功能,就是往这块 buffer 上绘制图片。</p><p>所以,我们可以把OpenGL ES和GLSL的流程单独拿出来进行归纳总结,而这幅流程图就是著名的 OpenGL ES2.0 pipeline。</p><p>首先,最左边的 API 指的就是 OpenGL ES 的 API,OpenGL ES 其实是一个图形学库,由 109 个 API 组成,只要明白了这 109 个 API 的意义和用途,就掌握了OpenGL ES 2.0。</p><p>然后,我们通过 API 先设定了顶点的信息,顶点的坐标、索引、颜色等信息,将这些信息传入 VS。</p><p>在 VS 中进行运算,得到最终的顶点坐标。再把算出来的顶点坐标进行图元装配,构建成虚拟的线和三角形。再进行光珊化(在光珊化的时候,把顶点连接起来形成直线,或者填充多边形的时候,需要考虑直线和多边形的直线宽度、点的大小、渐变算法以及是否使用支持抗锯齿处理的覆盖算法。最终的每个像素点,都具有各自的颜色和深度值)。</p><p>将光珊化的结果传入 PS,进行最终的颜色计算。</p><p>然后,这所谓最终的结果在被实际存储到绘制 buffer 之前,还需要进行一系列的操作。这些操作可能会修改甚至丢弃这些像素点。</p><p>这些操作主要为 alpha test、Depth/Stencil test、Blend、Dither。</p><p>Alpha Test 采用一种很霸道极端的机制,只要一个像素的 alpha 不满足条件, 那么它就会被 fragment shader 舍弃,被舍弃的 fragments 不会对后面的各种 Tests 产生影响;否则,就会按正常方式继续下面的检验。Alpha Test 产生的效果也很极端,要么完全透明,即看不到,要么完全不透明。</p><p>Depth/stencil test 比较容易理解。由于我们绘制的是 3D 图形,那么坐标为 XYZ,而 Z 一般就是深度值,OpenGL ES 可以对深度测试进行设定,比如设定深度值大的被抛弃,那么假如绘制 buffer 上某个像素点的深度值为 0,而 PS 输出的 像素点的深度值为 1,那么 PS 输出的像素点就被抛弃了。而 stencil 测试更加简单,其又被称为蒙版测试,比如可以通过 OpenGL ES 设定不同 stencil 值的配抛弃, 那么假如绘制 buffer 上某个像素点的 stencil 值为 0,而 PS 输出的像素点的 stencil 值为 1,那么 PS 输出的像素点就被抛弃了。</p><p>既然说到了 Depth/stencil,那么就在这里说一下绘制 buffer 到底有多大,存 储了多少信息。按照我们刚才的说法,手机可以支持一百万个像素,那么生成的 绘制 buffer 就需要存储这一百万个像素所包含的信息,而每个像素包含的信息, 与手机配置有关,假如手机支持 Depth/stencil。那么通过 EGL 获取的绘制 buffer 中,每个像素点就包含了 RGBA 的颜色值,depth 值和 stencil 值,其中 RGBA 每个分量一般占据 8 位,也就是 8bit,也就是 1byte,而 depth 大多数占 24 位,stencil 占 8 位。所以每个像素占 64bit,也就是 8byte。那么 iphone6 plus 的绘制 buffer 的尺寸为 1920×1080×8=16588800byte=16200KB=15.8MB。</p><p>下面还有 blend,通过 OpenGL ES 可以设置 blend 混合模式。由于绘制 buffer 中原本每个像素点已经有颜色了,那么 PS 输出的颜色与绘制 buffer 中的颜色如何混合,生成新的颜色存储在绘制 buffer 中,就是通过 blend 来进行设定。</p><p>最后的 dither,dither 是一种图像处理技术,是故意造成的噪音,用以随机化量化误差,阻止大幅度拉升图像时,导致的像 banding(色带)这样的问题。也 是通过OpenGL ES 可以开启或者关闭。</p><p>经过了这一系列的运算和测试,也就得到了最终的像素点信息,将其存储到绘制 buffer 上之后,OpenGL ES 的 pipeline 也就结束了。</p><p>整个pipeline中，纵向按照流水线作业，横线按照独立作业，多级并行、提高渲染性能</p><p>####（三）、 Android EGL Overview： OpenGL ES 和 EGL 介绍</p><h4 id="3-1-0、OpenGL-ES"><a href="#3-1-0、OpenGL-ES" class="headerlink" title="3.1.0、OpenGL ES"></a>3.1.0、OpenGL ES</h4><p>OpenGL ES（OpenGL for Embedded Systems）是 OpenGL 三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计，各显卡制造商和系统制造商来实现这组 API。</p><h4 id="3-1-1、OpenGL-基本概念"><a href="#3-1-1、OpenGL-基本概念" class="headerlink" title="3.1.1、OpenGL 基本概念"></a>3.1.1、OpenGL 基本概念</h4><p>OpenGL 的结构可以从逻辑上划分为下面 3 个部分：</p><p>☯ 图元（Primitives）<br>☯ 缓冲区（Buffers）<br>☯ 光栅化（Rasterize）<br> <strong>图元（Primitives）</strong><br>在 OpenGL 的世界里，我们只能画点、线、三角形这三种基本图形，而其它复杂的图形都可以通过三角形来组成。所以这里的图元指的就是这三种基础图形：</p><p>☯ 点：点存在于三维空间，坐标用（x,y,z）表示。<br>☯ 线：由两个三维空间中的点组成。<br>☯ 三角形：由三个三维空间的点组成。<br><strong>缓冲区（Buffers）</strong><br>OpenGL 中主要有 3 种 Buffer：</p><p><strong>帧缓冲区（Frame Buffers）</strong> 帧缓冲区：<strong>这个是存储OpenGL 最终渲染输出结果的地方</strong>，它是一个包含多个图像的集合，例如颜色图像、深度图像、模板图像等。</p><p><strong>渲染缓冲区（Render Buffers）</strong> 渲染缓冲区：渲染缓冲区就是一个图像，它是 Frame Buffer 的一个子集。</p><p><strong>缓冲区对象（Buffer Objects）</strong> 缓冲区对象就是程序员输入到 OpenGL 的数据，分为结构类和索引类的。前者被称为“数组缓冲区对象”或“顶点缓冲区对象”（“Array Buffer Object”或“Vertex Buff er Object”），即用来描述模型的数组，如顶点数组、纹理数组等； 后者被称为“索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。</p><p><strong>光栅化（Rasterize）</strong><br>在介绍光栅化之前，首先来补充 OpenGL 中的两个非常重要的概念：</p><p>Vertex Vertex 就是图形中顶点，一系列的顶点就围成了一个图形。<br>Fragment Fragment 是三维空间的点、线、三角形这些基本图元映射到二维平面上的映射区域，通常一个 Fragment 对应于屏幕上的一个像素，但高分辨率的屏幕可能会用多个像素点映射到一个 Fragment，以减少 GPU 的工作。<br>而光栅化是把点、线、三角形映射到屏幕上的像素点的过程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-07-OpenGL-guangshanhua.png" alt="Alt text | center"></p><p>着色器程序（Shader）<br>Shader 用来描述如何绘制（渲染），GLSL 是 OpenGL 的编程语言，全称 OpenGL Shader Language，它的语法类似于 C 语言。OpenGL 渲染需要两种 Shader：Vertex Shader 和 Fragment Shader。</p><p>Vertex Shader Vertex Shader 对于3D模型网格的每个顶点执行一次，主要是确定该顶点的最终位置。<br>Fragment Shader Fragment Shader对光栅化之后2D图像中的每个像素处理一次。3D物体的表面最终显示成什么样将由它决定，例如为模型的可见表面添加纹理，处理光照、阴影的影响等等。</p><h4 id="3-2、EGL-Overview"><a href="#3-2、EGL-Overview" class="headerlink" title="3.2、EGL Overview"></a>3.2、EGL Overview</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-08-OpenGL-EGL-Overview.png.png" alt="Alt text | center"></p><p>What is the Direction?<br>SW : Standard API (Java, NDK Stable API)<br>HW : OpenGLES, OpenSLES, OpenMAX<br>EGL™ is an interface between Khronos rendering APIs such as OpenGL ES or OpenVG and the underlying native platform window system</p><h4 id="3-2-1、什么是-EGL？"><a href="#3-2-1、什么是-EGL？" class="headerlink" title="3.2.1、什么是 EGL？"></a>3.2.1、什么是 EGL？</h4><p>EGL 是 OpenGL ES 渲染 API 和本地窗口系统(native platform window system)之间的一个中间接口层，它主要由系统制造商实现。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-09-eglCreateWindowSurface.png" alt="Alt text | center"></p><p>EGL提供如下机制：<br>与设备的原生窗口系统通信<br>查询绘图表面的可用类型和配置<br>创建绘图表面<br>在OpenGL ES 和其他图形渲染API之间同步渲染<br>管理纹理贴图等渲染资源<br>为了让OpenGL ES能够绘制在当前设备上，我们需要EGL作为OpenGL ES与设备的桥梁。</p><h4 id="3-2-2、使用-EGL-绘图的基本步骤"><a href="#3-2-2、使用-EGL-绘图的基本步骤" class="headerlink" title="3.2.2、使用 EGL 绘图的基本步骤"></a>3.2.2、使用 EGL 绘图的基本步骤</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-10-egl-draw-surface.png.png" alt="Alt text | center"></p><p>☯  Display(EGLDisplay) 是对实际显示设备的抽象。<br>☯  Surface（EGLSurface）是对用来存储图像的内存区域<br>☯  FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。<br>使用EGL的绘图的一般步骤：</p><p>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p><h4 id="3-3、EGLSurface-and-ANativeWindow-关系"><a href="#3-3、EGLSurface-and-ANativeWindow-关系" class="headerlink" title="3.3、EGLSurface and ANativeWindow 关系"></a>3.3、EGLSurface and ANativeWindow 关系</h4><p>OpenGL ES 定义了一个渲染图形的 API，但没有定义窗口系统。为了让 GLES 能够适合各种平台，GLES 将与知道如何通过操作系统创建和访问窗口的库结合使用。用于 Android 的库称为 EGL。如果要绘制纹理多边形，应使用 GLES 调用；如果要在屏幕上进行渲染，应使用 EGL 调用。</p><p>在使用 GLES 进行任何操作之前，需要创建一个 GL 上下文。在 EGL 中，这意味着要创建一个 EGLContext 和一个 EGLSurface。GLES 操作适用于当前上下文，该上下文通过线程局部存储访问，而不是作为参数进行传递。这意味着您必须注意渲染代码在哪个线程上执行，以及该线程上的当前上下文。</p><h4 id="3-3-1、EGLSurface"><a href="#3-3-1、EGLSurface" class="headerlink" title="3.3.1、EGLSurface"></a>3.3.1、EGLSurface</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-11-eglsurface-anativewindwo.png" alt="Alt text | center"></p><p>EGLSurface 可以是由 EGL 分配的离屏缓冲区（称为“pbuffer”），或由操作系统分配的窗口。EGL 窗口 Surface 通过 eglCreateWindowSurface() 调用被创建。该调用将“窗口对象”作为参数，在 Android 上，该对象可以是 SurfaceView、SurfaceTexture、SurfaceHolder 或 Surface，所有这些对象下面都有一个 BufferQueue。当您进行此调用时，EGL 将创建一个新的 EGLSurface 对象，并将其连接到窗口对象的 BufferQueue 的生产方接口。此后，渲染到该 EGLSurface 会导致一个缓冲区离开队列、进行渲染，然后排队等待消耗方使用。（术语“窗口”表示预期用途，但请注意，输出内容不一定会显示在显示屏上。）</p><p>EGL 不提供锁定/解锁调用，而是由您发出绘制命令，然后调用 eglSwapBuffers() 来提交当前帧。方法名称来自传统的前后缓冲区交换，但实际实现可能会有很大的不同。</p><p>一个 Surface 一次只能与一个 EGLSurface 关联（您只能将一个生产方连接到一个 BufferQueue），但是如果您销毁该 EGLSurface，它将与该 BufferQueue 断开连接，并允许其他内容连接到该 BufferQueue。</p><p>通过更改“当前”EGLSurface，指定线程可在多个 EGLSurface 之间进行切换。一个 EGLSurface 一次只能在一个线程上处于当前状态。</p><p>关于 EGLSurface 最常见的一个错误理解就是假设它只是 Surface 的另一方面（如 SurfaceHolder）。它是一个相关但独立的概念。您可以在没有 Surface 作为支持的 EGLSurface 上绘制，也可以在没有 EGL 的情况下使用 Surface。EGLSurface 仅为 GLES 提供一个绘制的地方。</p><h4 id="3-3-2、ANativeWindow"><a href="#3-3-2、ANativeWindow" class="headerlink" title="3.3.2、ANativeWindow"></a>3.3.2、ANativeWindow</h4><p>公开的 Surface 类以 Java 编程语言实现。C/C++ 中的同等项是 ANATIONWindow 类，由 Android NDK 半公开。您可以使用 ANativeWindow_fromSurface() 调用从 Surface 获取 ANativeWindow。就像它的 Java 语言同等项一样，您可以对 ANativeWindow 进行锁定、在软件中进行渲染，以及解锁并发布。</p><p>要从原生代码创建 EGL 窗口 Surface，可将 EGLNativeWindowType 的实例传递到 eglCreateWindowSurface()。EGLNativeWindowType 是 ANativeWindow 的同义词，您可以自由地在它们之间转换。</p><p>基本的“原生窗口”类型只是封装 BufferQueue 的生产方，这一点并不足为奇。</p><h4 id="3-3-3、egl-surface-t-关系图"><a href="#3-3-3、egl-surface-t-关系图" class="headerlink" title="3.3.3、egl_surface_t 关系图"></a>3.3.3、egl_surface_t 关系图</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-12-egl_surface_t.png" alt="Alt text | center"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-13-framebufferwindow-surface.png" alt="Alt text | center"></p><h4 id="3-3-4、EGLContext-and-Thread-Local-Storage"><a href="#3-3-4、EGLContext-and-Thread-Local-Storage" class="headerlink" title="3.3.4、EGLContext and Thread Local Storage"></a>3.3.4、EGLContext and Thread Local Storage</h4><h4 id="3-3-4-1、EGLContext"><a href="#3-3-4-1、EGLContext" class="headerlink" title="3.3.4.1、EGLContext"></a>3.3.4.1、EGLContext</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-14-eglcontect-TLS.png" alt="Alt text | center"></p><h4 id="3-3-4-2、Thread-Local-Storage"><a href="#3-3-4-2、Thread-Local-Storage" class="headerlink" title="3.3.4.2、Thread Local Storage"></a>3.3.4.2、Thread Local Storage</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-15-eglcontect-Thread-Loacal.png.png" alt="Alt text | center"></p><h4 id="3-3-5、EGLImplementation-HWCompser-and-SurfaceFlinger"><a href="#3-3-5、EGLImplementation-HWCompser-and-SurfaceFlinger" class="headerlink" title="3.3.5、EGLImplementation : HWCompser and SurfaceFlinger"></a>3.3.5、EGLImplementation : HWCompser and SurfaceFlinger</h4><h4 id="3-3-5-1、HWCompser"><a href="#3-3-5-1、HWCompser" class="headerlink" title="3.3.5.1、HWCompser"></a>3.3.5.1、HWCompser</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-16-Android-graphics-components.png" alt="Alt text | center"></p><h4 id="3-3-5-2、SurfaceFlinger"><a href="#3-3-5-2、SurfaceFlinger" class="headerlink" title="3.3.5.2、SurfaceFlinger"></a>3.3.5.2、SurfaceFlinger</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-17-eglimp-hwrenderer-surfaceflinger.png" alt="Alt text | center"></p><p>####（四）、Android EGL：OpenGL ES 库和 EGL 库加载过程<br>在详细分析 EGL 绘图基本步骤 前，先来看看OpenGL ES 库和 EGL 库加载过程。</p><h5 id="4-1、OpenGL-ES-和-OpenGL-ES-库的区别"><a href="#4-1、OpenGL-ES-和-OpenGL-ES-库的区别" class="headerlink" title="4.1、OpenGL ES 和 OpenGL ES 库的区别"></a>4.1、OpenGL ES 和 OpenGL ES 库的区别</h5><p><strong>OpenGL ES ：</strong> 它本身只是一个协议规范，定义了一套可以供上层应用程序进行调用的 API，它抽象了 GPU 的功能，使应用开发者不必关心底层的 GPU 类型和具体实现。<br><strong>OpenGL ES 库：</strong>OpenGL ES 库就是上面 OpenGL ES 中定义的 API 的具体实现。由于每个显卡制造厂商的 GPU 硬件结构不同，从而导致各个厂商的OpenGL ES 库也各不相同，所以 Android 系统中的 OpenGL ES 库通常是由硬件厂商提供的，通常存放在 Android 系统中的 /system/lib64/（/system/lib/） 。<br><strong>OpenGL ES Wrapper 库：</strong>OpenGL ES Wrapper 库是一个对 OpenGL ES API 进行封装的一个包裹库，它向上为应用程序提供了标准的 OpenGL ES API，向下可以和不同厂商实现的 OpenGL ES 库进行绑定，将 OpenGL ES API 和对应的实现函数一一绑定在一起。<br>并且，OpenGL ES 库的实现分为：<br><strong>软件模拟实现</strong><br><strong>硬件加速实现</strong><br>现在，因为我们 Android 手机中的 Soc 片上芯片中都集成了 GPU 模块，所以这里使用的就是硬件加速实现的 OpenGL ES 库。但是，像 Android Emulator 中的 Android 系统，如果不支持将 OpenGL ES API 指令重定向到主机系统的 GPU 加速执行的话，它所采用的 OpenGL ES 库就是软件模拟实现的。</p><p>补充：如前面小节【OpenGL ES 和 EGL 介绍】中介绍的，EGL 也是一套 API，它的实现也需要系统厂商来提供。系统厂商通常会将这两套 API 的实现封装在一个共享链接库中，但是根据最新的标准，OpenGL ES API 实现的共享链接库和 EGL API 实现的共享链接库是独立分开的，例如  Nexus 9 平板设备中 OpenGL ES 和 EGL API 实现库就是独立分开的。</p><h5 id="4-2、Android-中-OpenGL-ES-软件层次栈"><a href="#4-2、Android-中-OpenGL-ES-软件层次栈" class="headerlink" title="4.2、Android 中 OpenGL ES 软件层次栈"></a>4.2、Android 中 OpenGL ES 软件层次栈</h5><p>按照分层理念的设计，Android 中的 OpenGL ES 实现也是层次设计的，形成一个软件层次栈。最上面的是 Java 层，接着下面是 JNI 层，再调用下面的 wrapper 层，wrapper 层下面则是 OpenGL ES API 的具体软件实或者硬件实现了。整个 OpenGL 软件层次栈的调用关系如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-18-OpenGL_ES_call_graph_so.png" alt="Alt text | center"></p><h5 id="4-3、OpenGL-ES-EGL-Wrapper-库"><a href="#4-3、OpenGL-ES-EGL-Wrapper-库" class="headerlink" title="4.3、OpenGL ES/EGL Wrapper 库"></a>4.3、OpenGL ES/EGL Wrapper 库</h5><p>前面我们已经介绍过 OpenGL ES/EGL Wrapper 库是一个将 OpenGL ES API 和 OpenGL ES API 具体实现绑定在一起的库，它对应的源码路径是：/frameworks/native/opengl/libs/，其中:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libGLESv1_CM.so：OpenGL ES <span class="number">1.</span>x API 的 Wrapper 库</span><br><span class="line">libGLESv2.so：OpenGL ES <span class="number">2.0</span> 的 Wrapper 库</span><br><span class="line">libGLESv3.so：OpenGL ES <span class="number">3.0</span> 的 Wrapper 库</span><br></pre></td></tr></table></figure><p>其中因为 OpenGL ES 3.0 API 是兼容 OpenGL ES 2.0 API 的，所以 libGLESv2.so 库本质上和 libGLESv3.so 库是一样的。</p><h5 id="4-3-1、OpenGL-ES-EGL-实现库"><a href="#4-3-1、OpenGL-ES-EGL-实现库" class="headerlink" title="4.3.1、OpenGL ES/EGL 实现库"></a>4.3.1、OpenGL ES/EGL 实现库</h5><p>如果Android系统平台支持 OpenGL ES 硬件加速渲染，那么 OpenGL ES/EGL 实现库由系统厂商以.so的共享链接库的形式提供，例如，高通的实现：system\vendor\lib\egl</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">libEGL_adreno.so </span><br><span class="line">libGLESv1_CM_adreno.so</span><br><span class="line">libGLESv2_adreno.so</span><br></pre></td></tr></table></figure><p>如果Android系统平台不支持 OpenGL ES 硬件加速渲染，那么它就会默认启用软件模拟渲染，这时 OpenGL ES/EGL 实现库就是由 AOSP 提供，链接库的存在的路径为： /system/lib64/egl/libGLES_android.so。而 libGLES_android.so 库在 Android 7.1 系统对应的实现源码路径为：/frameworks/native/opengl/libagl/ 。</p><h5 id="4-3-2、Android-7-1-中加载-OpenGL-ES-库的过程"><a href="#4-3-2、Android-7-1-中加载-OpenGL-ES-库的过程" class="headerlink" title="4.3.2、Android 7.1 中加载 OpenGL ES 库的过程"></a>4.3.2、Android 7.1 中加载 OpenGL ES 库的过程</h5><p>Android 中图形渲染所采用的方式（硬件 or 软件）是在系统启动之后动态确定的，而确定渲染方式的这个源码文件就是 /frameworks/native/opengl/libs/EGL/Loader.cpp 。</p><h5 id="4-3-2-1、-Android-7-1-OpenGL-ES-库和-EGL-库加载说明"><a href="#4-3-2-1、-Android-7-1-OpenGL-ES-库和-EGL-库加载说明" class="headerlink" title="4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明"></a>4.3.2.1、 Android 7.1 OpenGL ES 库和 EGL 库加载说明</h5><p><a href="http://www.2net.co.uk/tutorial/android-egl-cgf-is-dead" target="_blank" rel="noopener">How Android finds OpenGL libraries, and the death of egl.cfg</a> 这篇文章中提到了非常关键的一点，就是从 Android Kitkat 4.4 之后，Android 中加载 OpenGL ES/EGL 库的方法发生了变化了（但是整个加载过程都是由 /frameworks/native/opengl/libs/EGL/Loader.cpp 程序所决定的，也就是说 Loader.cpp 文件发生了变化）。</p><p>在 Android 4.4 之前，加载 OpenGL ES 库是由 /system/lib/egl/egl.cfg 文件所决定的，通过读取这个配置文件来确定是加载 OpenGL ES 软件模拟实现的库，还是OpenGL ES 硬件加速实现的库。</p><p>但是，在Android 4.4 之后，Android 不再通过读取 egl.cfg 配置文件的方式来加载 OpenGL ES 库，新的加载 OpenGL ES 库的规则，如下所示：</p><p>从 /system/lib/egl 或者 /system/vendor/lib/egl/ 目录下加载 libGLES.so 库文件或者 libEGL_vendor.so，libGLESv1_CM_vendor.so，libGLESv2<em>vendor.so 库文件。<br>为了向下兼容旧的库的命名方式，同样也会加载 /system/lib/egl 或者 /vendor/lib/egl/ 目录下的 libGLES</em><em>.so 或者 libEGL_</em>.so，libGLESv1CM<em>.so，libGLESv2_</em>.so 库文件。</p><h5 id="4-3-2-2、硬件加速渲染-or-软件模拟渲染？"><a href="#4-3-2-2、硬件加速渲染-or-软件模拟渲染？" class="headerlink" title="4.3.2.2、硬件加速渲染 or 软件模拟渲染？"></a>4.3.2.2、硬件加速渲染 or 软件模拟渲染？</h5><p>前面我们提到 OpenGL ES 库的实现方式有两种，一种是硬件加速实现，一种是软件模拟实现，那么系统是怎么确定加载那一种 OpenGL ES 库的呢？</p><p>Android 7.1 源码中负责加载 OpenGL ES/EGL 库部分的代码位于：/frameworks/native/opengl/libs/EGL/Loader.cpp 文件中，这个文件中代码的主要入口函数是 Loader::open() 函数，而决定加载硬件加速渲染库还是软件模拟渲染库主要涉及到下面两个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setEmulatorGlesValue()</span><br><span class="line">checkGlesEmulationStatus()</span><br></pre></td></tr></table></figure><p>下面就来简要的分析一下 Android 系统是如何选择加载硬件加速渲染库还是软件模拟渲染库：</p><p>首先，Loader::open() 入口函数会调用 setEmulatorGlesValue() 从 property 属性系统中获取一些属性值来判断当前 Android 系统是否在 Emulator 环境中运行，并根据读取出来的信息来重新设置新的属性键值对，setEmulatorGlesValue() 函数的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setEmulatorGlesValue</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">char</span> prop[PROPERTY_VALUE_MAX];</span><br><span class="line">     property_get(<span class="string">"ro.kernel.qemu"</span>, prop, <span class="string">"0"</span>); <span class="comment">//读取 ro.kernel.qemu 属性值，判断Android系统是否运行在 qemu 中</span></span><br><span class="line">     <span class="keyword">if</span> (atoi(prop) != <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">     property_get(<span class="string">"ro.kernel.qemu.gles"</span>, prop, <span class="string">"0"</span>); <span class="comment">//读取 ro.kernel.qemu.gles 属性值，判断 qemu 中 OpenGL ES 库的实现方式</span></span><br><span class="line">     <span class="keyword">if</span> (atoi(prop) == <span class="number">1</span>) &#123;</span><br><span class="line">         ALOGD(<span class="string">"Emulator has host GPU support, qemu.gles is set to 1."</span>);</span><br><span class="line">         property_set(<span class="string">"qemu.gles"</span>, <span class="string">"1"</span>);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// for now, checking the following</span></span><br><span class="line">     <span class="comment">// directory is good enough for emulator system images</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* vendor_lib_path =</span><br><span class="line"> #<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">         <span class="string">"/vendor/lib64/egl"</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">         <span class="string">"/vendor/lib/egl"</span>;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">bool</span> has_vendor_lib = (access(vendor_lib_path, R_OK) == <span class="number">0</span>);</span><br><span class="line">     <span class="comment">//如果存在 vendor_lib_path 这个路径，那么就说明厂商提供了 OpenGL ES库自己的软件模拟渲染库，而不是 Android 系统自己编译得到的软件模拟渲染库</span></span><br><span class="line">     <span class="keyword">if</span> (has_vendor_lib) &#123;</span><br><span class="line">         ALOGD(<span class="string">"Emulator has vendor provided software renderer, qemu.gles is set to 2."</span>);</span><br><span class="line">         property_set(<span class="string">"qemu.gles"</span>, <span class="string">"2"</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         ALOGD(<span class="string">"Emulator without GPU support detected. "</span></span><br><span class="line">               <span class="string">"Fallback to legacy software renderer, qemu.gles is set to 0."</span>);</span><br><span class="line">         property_set(<span class="string">"qemu.gles"</span>, <span class="string">"0"</span>); <span class="comment">//最后，默认采取的是方案就是调用传统的Android系统自己编译得到软件模拟渲染库</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在 load_system_driver() 函数中，内部类 MatchFile 类中会调用 checkGlesEmulationStatus() 函数来检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能，然后根据 checkGlesEmulationStatus() 函数的返回状态值来确定要加载共享链接库的文件绝对路径。load_system_driver() 和 checkGlesEmulationStatus() 函数代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">load_system_driver</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind)</span> </span>&#123;</span><br><span class="line">     ATRACE_CALL();</span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">MatchFile</span> &#123;</span></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="comment">//这个函数作用是返回需要加载打开的 OpenGL ES 和 EGL API 实现库文件的绝对路径</span></span><br><span class="line">         <span class="function"><span class="keyword">static</span> String8 <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* kind)</span> </span>&#123;</span><br><span class="line">             String8 result;</span><br><span class="line">             <span class="keyword">int</span> emulationStatus = checkGlesEmulationStatus(); <span class="comment">//检查 Android 系统是否运行在模拟器中，以及在模拟器中是否启用了主机硬件加速的功能</span></span><br><span class="line">             <span class="keyword">switch</span> (emulationStatus) &#123;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//Android 运行在模拟器中，使用系统软件模拟实现的 OpenGL ES API 库 libGLES_android.so</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                 result.setTo(<span class="string">"/system/lib64/egl/libGLES_android.so"</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                 result.setTo(<span class="string">"/system/lib/egl/libGLES_android.so"</span>);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                 <span class="keyword">return</span> result;</span><br><span class="line">             <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// Android 运行在模拟器中，通过主机系统中实现 OpenGL ES 加速渲染，通过 libGLES_emulation.so 库将  OpenGL ES API 指令重定向到 host 中执行</span></span><br><span class="line">                 <span class="comment">// Use host-side OpenGL through the "emulation" library</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> defined(__LP64__)</span></span><br><span class="line">                 result.appendFormat(<span class="string">"/system/lib64/egl/lib%s_emulation.so"</span>, kind);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                 result.appendFormat(<span class="string">"/system/lib/egl/lib%s_emulation.so"</span>, kind);</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                 <span class="keyword">return</span> result;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 <span class="comment">// Not in emulator, or use other guest-side implementation</span></span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">    </span><br><span class="line">             <span class="comment">// 如果不是上面两种情况，就根据库的命名规则去找到厂商实现库文件的绝对路径</span></span><br><span class="line">             String8 pattern;</span><br><span class="line">             pattern.appendFormat(<span class="string">"lib%s"</span>, kind);</span><br><span class="line">             <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> searchPaths[] = &#123;</span><br><span class="line"> #<span class="keyword">if</span> defined(__LP64__)</span><br><span class="line">                 <span class="string">"/vendor/lib64/egl"</span>,</span><br><span class="line">                 <span class="string">"/system/lib64/egl"</span></span><br><span class="line"> #<span class="keyword">else</span></span><br><span class="line">                 <span class="string">"/vendor/lib/egl"</span>,</span><br><span class="line">                 <span class="string">"/system/lib/egl"</span></span><br><span class="line"> #endif</span><br><span class="line">             &#125;;</span><br><span class="line">                </span><br><span class="line">             ......</span><br><span class="line">     &#125;</span><br><span class="line">        </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总结一下上面代码的功能就是，首先判断 Android 是否在 qemu 虚拟机中运行，如果不是，那么就直接去加载厂商存放库的路径中去加载 OpenGL ES 实现库（不管是硬件加速实现的，还是软件模拟实现的）；如果是在 qemu 中运行，那么就要根据返回的 emulationStatus 值 来确定是加软件模拟实现的 OpenGL ES API 库 libGLES_android.so，还是加载 libGLES_emulation.so库将 OpenGL ES 指令重定向到 Host 系统中去执行。</p><h5 id="4-3-3、OpenGL-ES-EGL-库加载和解析过程"><a href="#4-3-3、OpenGL-ES-EGL-库加载和解析过程" class="headerlink" title="4.3.3、OpenGL ES/EGL 库加载和解析过程"></a>4.3.3、OpenGL ES/EGL 库加载和解析过程</h5><p>正如前面分析，在进行 OpenGL 编程时，最先开始需要获取 Display，这将调用 eglgGetDisplay() 函数被调用。在 eglGetDisplay() 里则会调用 egl_init_drivers() 初始化驱动：装载各个库进行解析，将 OpenGL ES/EGL API 函数接口和具体的实现绑定在一起，并将结果保存在 egl_connection_t 类型的全局变量 gEGLImpl 的结构体的成员变量中。</p><p>下面以 SurfaceFlinger 进程init()为例进行分析，整个 OpenGL ES/EGL 库的加载和解析流程如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-19-SF_init.png" alt="Alt text | center"></p><p>这里通过调用 EGL 库的 eglGetDisplay() 获得 Display。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\eglApi.cpp]</span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(EGLNativeDisplayType display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (egl_init_drivers() == EGL_FALSE) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_NO_DISPLAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLDisplay dpy = <span class="keyword">egl_display_t</span>::getFromNativeDisplay(display);</span><br><span class="line">    <span class="keyword">return</span> dpy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数EGLBoolean egl_init_drivers()就是负责OpenGL库的加载。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">egl_init_drivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    EGLBoolean res;</span><br><span class="line">    pthread_mutex_lock(&amp;sInitDriverMutex);</span><br><span class="line">    res = egl_init_drivers_locked();</span><br><span class="line">    pthread_mutex_unlock(&amp;sInitDriverMutex);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为保证多线程访问的安全性，使用线程锁来放完另一个接口函数egl_init_drivers_locked()<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libs\EGL\egl.cpp]</span><br><span class="line"><span class="comment">//在该文件起始位置定义的全局变量</span></span><br><span class="line"><span class="keyword">egl_connection_t</span> gEGLImpl; <span class="comment">// 描述EGL实现内容的结构体对象</span></span><br><span class="line"><span class="keyword">gl_hooks_t</span> gHooks[<span class="number">2</span>]; <span class="comment">// gl_hooks_t 是包含 OpenGL ES API 函数声明对应的函数指针结构体</span></span><br><span class="line"><span class="keyword">gl_hooks_t</span> gHooksNoContext;</span><br><span class="line"><span class="keyword">pthread_key_t</span> gGLWrapperKey = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLBoolean <span class="title">egl_init_drivers_locked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sEarlyInitState) &#123;</span><br><span class="line">        <span class="comment">// initialized by static ctor. should be set here.</span></span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 Loader 对象单例</span></span><br><span class="line">    <span class="comment">// get our driver loader</span></span><br><span class="line">    Loader&amp; loader(Loader::getInstance());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  gEGLImple 是一个全局变量，数据类型为 egl_connection_t 结构体类型</span></span><br><span class="line">    <span class="comment">// dynamically load our EGL implementation</span></span><br><span class="line">    <span class="keyword">egl_connection_t</span>* cnx = &amp;gEGLImpl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cnx-&gt;dso 本质上是一个 (void *)类型的指针，它指向的对象是 EGL 共享库打开之后的句柄</span></span><br><span class="line">    <span class="keyword">if</span> (cnx-&gt;dso == <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="comment">// &gt;= 将cnx中的 hooks 数组中指向OpenGL ES API 函数指针结构体指的数组成员，用 gHooks 中的成员的地址去初始化</span></span><br><span class="line">        <span class="comment">//也就是说 gEGLImpl 中 hook 数组指向 gHooks 数组，最终指向同一个 OpenGL ES API 函数指针的实现</span></span><br><span class="line">        cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX] =</span><br><span class="line">            &amp;gHooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX];</span><br><span class="line">        cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX] =</span><br><span class="line">            &amp;gHooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// &gt;= 最后通过loader对象的open函数开始加载 OpenGL ES 和 EGL wrapper 库</span></span><br><span class="line">        cnx-&gt;dso = loader.open(cnx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnx-&gt;dso ? EGL_TRUE : EGL_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个函数中，有一个非常关键的 egl_connection_t 指针指向一个全局变量 gEGLImpl，当第一次初始化加载 OpenGL ES 实现库和 EGL 实现库时，还需要将 gEGLImpl 中的 hooks 数组中的两个指针指向一个全局的 gl_hooks_t 数组 gHooks（这就是两个指针钩子，最终初始化完成后将分别勾住 OpenGL ES 1.0 和 OpenGL ES 2.0 的实现库），接着调用 Loader 类的实例的 open() 函数完成从 OpenGL ES 实现库中完成符号解析工作。</p><p>Loader::open() 函数的代码如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line"><span class="comment">// &gt;= Loader 类对象构造完成后，就在 /EGL/egl.cpp 文件中的 egl_init_drivers_locked() 中被调用</span></span><br><span class="line"><span class="keyword">void</span>* Loader::open(<span class="keyword">egl_connection_t</span>* cnx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* dso;</span><br><span class="line">    <span class="keyword">driver_t</span>* hnd = <span class="number">0</span>;</span><br><span class="line">    setEmulatorGlesValue();</span><br><span class="line">    dso = load_driver(<span class="string">"GLES"</span>, cnx, EGL | GLESv1_CM | GLESv2);</span><br><span class="line">    <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">        hnd = <span class="keyword">new</span> <span class="keyword">driver_t</span>(dso);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Always load EGL first</span></span><br><span class="line">        dso = load_driver(<span class="string">"EGL"</span>, cnx, EGL);</span><br><span class="line">        <span class="keyword">if</span> (dso) &#123;</span><br><span class="line">            hnd = <span class="keyword">new</span> <span class="keyword">driver_t</span>(dso);</span><br><span class="line">            hnd-&gt;<span class="built_in">set</span>( load_driver(<span class="string">"GLESv1_CM"</span>, cnx, GLESv1_CM), GLESv1_CM );</span><br><span class="line">            hnd-&gt;<span class="built_in">set</span>( load_driver(<span class="string">"GLESv2"</span>,    cnx, GLESv2),    GLESv2 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    cnx-&gt;libEgl   = load_wrapper(EGL_WRAPPER_DIR <span class="string">"/libEGL.so"</span>);</span><br><span class="line">    cnx-&gt;libGles2 = load_wrapper(EGL_WRAPPER_DIR <span class="string">"/libGLESv2.so"</span>);</span><br><span class="line">    cnx-&gt;libGles1 = load_wrapper(EGL_WRAPPER_DIR <span class="string">"/libGLESv1_CM.so"</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span>*)hnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>open() 函数主要负责 OpenGL ES 库加载前的准备工作，具体的加载细节，则是通过调用 load_driver() 去完成的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[/frameworks/native/opengl/libs/EGL/Loader.cpp]</span><br><span class="line">oid *Loader::load_driver(<span class="keyword">const</span> <span class="keyword">char</span>* kind,</span><br><span class="line">                          <span class="keyword">egl_connection_t</span>* cnx, <span class="keyword">uint32_t</span> mask)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span>* dso = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (mGetDriverNamespace) &#123;</span><br><span class="line">        <span class="keyword">android_namespace_t</span>* ns = mGetDriverNamespace();</span><br><span class="line">        <span class="keyword">if</span> (ns) &#123;</span><br><span class="line">            dso = load_updated_driver(kind, ns); <span class="comment">//加载 OpenGL ES 实现库，放回打开的共享链接库的句柄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!dso) &#123;</span><br><span class="line">        dso = load_system_driver(kind);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 EGL 库，并将wrapper 库 libEGL.so 中的函数 API 指针和具体的实现绑定在一起</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; EGL) &#123;</span><br><span class="line">        getProcAddress = (getProcAddressType)dlsym(dso, <span class="string">"eglGetProcAddress"</span>);</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">egl_t</span>* egl = &amp;cnx-&gt;egl; <span class="comment">//将 egl 指针指向描述当前系统支持 OpenGL ES和 EGL 全局变量的 gEGLImpl</span></span><br><span class="line">        __eglMustCastToProperFunctionPointerType* curr =</span><br><span class="line">            (__eglMustCastToProperFunctionPointerType*)egl;</span><br><span class="line">        <span class="keyword">char</span> <span class="keyword">const</span> * <span class="keyword">const</span> * api = egl_names; <span class="comment">//egl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 EGL API 函数指针</span></span><br><span class="line">        <span class="keyword">while</span> (*api) &#123;</span><br><span class="line">            <span class="keyword">char</span> <span class="keyword">const</span> * name = *api;</span><br><span class="line">            __eglMustCastToProperFunctionPointerType f =</span><br><span class="line">                (__eglMustCastToProperFunctionPointerType)dlsym(dso, name);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// couldn't find the entry-point, use eglGetProcAddress()</span></span><br><span class="line">                f = getProcAddress(name);</span><br><span class="line">                <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    f = (__eglMustCastToProperFunctionPointerType)<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            *curr++ = f; <span class="comment">//这一步就是最关键的将共享链接库中的 EGL API 的实现和上层调用的 API 函数指针绑定在一起</span></span><br><span class="line">            api++; <span class="comment">//指向下一个需要绑定的 api 函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 OpenGL ES 库中的 OpenGL ES 1.x API 符号</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv1_CM) &#123;</span><br><span class="line">        <span class="comment">// 调用 init_api 实现 OpenGL API 和对应实现函数的绑定</span></span><br><span class="line">        init_api(dso, gl_names, <span class="comment">// gl_names 是定义在 egl.cpp 文件中的一个数组，数组中的元素是 OpenGL ES API 函数指针</span></span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv1_INDEX]-&gt;gl, <span class="comment">//gl成员变量是一个结构体变量，结构体中的是 OpenGL ES API 函数指针</span></span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 OpenGL ES 库中的 OpenGL ES 2.0 API 符号</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; GLESv2) &#123;</span><br><span class="line">        init_api(dso, gl_names,</span><br><span class="line">                 (__eglMustCastToProperFunctionPointerType*)</span><br><span class="line">                 &amp;cnx-&gt;hooks[<span class="keyword">egl_connection_t</span>::GLESv2_INDEX]-&gt;gl,</span><br><span class="line">                 getProcAddress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Loader::load_driver() 它主要实现了两个功能：</p><p>通过 load_system_driver()  函数查找 OpenGL ES/EGL 实现库，并在指定的存放路径中找到共享链接库文件并打开它。<br>调用 init_api()解析打开的 OpenGL ES/EGL 共享链接库，将 OpenGL ES/EGL API 函数指针和共享链接库中实现的对应的函数符号绑定在一起，这样调用 OpenGL ES/EGL API 就会调用到具体实现的OpenGL ES/EGL 共享链接库中对应函数。</p><h5 id="4-4、小结"><a href="#4-4、小结" class="headerlink" title="4.4、小结"></a>4.4、小结</h5><p>Android OpenGL ES 图形库结构<br>Android 的 OpenGL ES 图形系统涉及多个库，根据设备类型的不同，这些库有着不同的结构。</p><p>对于模拟器，没有开启 OpenGL ES 的 GPU 硬件模拟的情况，Android OpenGL ES 图形库结构如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-20-opencl-egl-imp.png" alt="Alt text | center"></p><p>当为模拟器开启了 OpenGL ES 的 GPU 硬件模拟，实际的 EGL 和 OpenGL ES 实现库会采用由 android-7.1.1_r22/device/generic/goldfish-opengl 下的源码编译出来的几个库文件，即 libGLESv2_emulation.so、libGLESv1_CM_emulation.so 和 libEGL_emulation.so。此时，OpenGL ES 图形库结构如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-21-opencl-egl-imp-emulate.png" alt="Alt text | center"></p><p>对于真实的物理 Android 设备，OpenGL ES 图形库结构如下，例如高通实现（libEGL_adreno.so<br>libGLESv1_CM_adreno.so libGLESv2_adreno.so [\system\vendor\lib64\egl]）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/display.system/DS-02-22-opencl-egl-imp-qcom-adreno.png" alt="Alt text | center"></p><p>####（五）、OpenGL ES：EGL接口解析与理解</p><p>由前面的分析知道EGL的绘图的一般步骤如下，接下来分析主要的1-8个小步骤：</p><blockquote><p>使用EGL的绘图的一般步骤：<br>1、获取 EGL Display 对象：eglGetDisplay()<br>2、初始化与 EGLDisplay 之间的连接：eglInitialize()<br>3、获取 EGLConfig 对象：eglChooseConfig()<br>4、创建 EGLContext 实例：eglCreateContext()<br>5、创建 EGLSurface 实例：eglCreateWindowSurface()<br>6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()<br>7、使用 OpenGL ES API 绘制图形：gl_*()<br>8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()<br>9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()<br>10、删除 EGLSurface 对象<br>11、删除 EGLContext 对象<br>12、终止与 EGLDisplay 之间的连接</p></blockquote><p>标准 EGL 数据类型如下所示：</p><p>EGLBoolean ——EGL_TRUE =1, EGL_FALSE=0<br>EGLint ——int 数据类型<br>EGLDisplay ——系统显示 ID 或句柄，可以理解为一个前端的显示窗口<br>EGLConfig ——Surface的EGL配置，可以理解为绘制目标framebuffer的配置属性<br>EGLSurface ——系统窗口或 frame buffer 句柄 ，可以理解为一个后端的渲染目标窗口。<br>EGLContext ——OpenGL ES 图形上下文，它代表了OpenGL状态机；如果没有它，OpenGL指令就没有执行的环境。</p><p>下面几个类型比较复杂，通过例子可以更深入的理解。这里要说明的是这几个类型在不同平台其实现是不同的，EGL只提供抽象标准。</p><p>NativeDisplayType——Native 系统显示类型，标识你所开发设备的物理屏幕<br>NativeWindowType ——Native 系统窗口缓存类型，标识系统窗口<br>NativePixmapType ——Native 系统 frame buffer，可以作为 Framebuffer 的系统图像（内存）数据类型，该类型只用于离屏渲染.</p><h5 id="5-1、eglGetDisplay"><a href="#5-1、eglGetDisplay" class="headerlink" title="5.1、eglGetDisplay()"></a>5.1、eglGetDisplay()</h5><p>EGLDisplay 是一个关联系统物理屏幕的通用数据类型，表示显示设备句柄，也可以认为是一个前端显示窗。为了使用系统的显示设备， EGL 提供了 EGLDisplay 数据类型，以及一组操作设备显示的 API 。<br>下面的函数原型用于获取 Native Display ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLDisplay <span class="title">eglGetDisplay</span><span class="params">(NativeDisplayType display)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (display == EGL_DEFAULT_DISPLAY) &#123;</span><br><span class="line">        EGLDisplay dpy = (EGLDisplay)<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">egl_display_t</span>&amp; d = <span class="keyword">egl_display_t</span>::get_display(dpy);</span><br><span class="line">        d.type = display;</span><br><span class="line">        <span class="keyword">return</span> dpy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EGL_NO_DISPLAY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">egl_display_t</span>&amp; <span class="keyword">egl_display_t</span>::get_display(EGLDisplay dpy) &#123;</span><br><span class="line">    <span class="keyword">return</span> gDisplays[<span class="keyword">uintptr_t</span>(dpy)<span class="number">-1U</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其 中 display 参数是 native 系统的窗口显示 ID 值。如果你只是想得到一个系统默认的 Display ，你可以使用 EGL_DEFAULT_DISPLAY 参数。如果系统中没有一个可用的 native display ID 与给定的 display 参数匹配，函数将返回 EGL_NO_DISPLAY ，而没有任何 Error 状态被设置。</p><h5 id="5-2、eglInitialize"><a href="#5-2、eglInitialize" class="headerlink" title="5.2、eglInitialize()"></a>5.2、eglInitialize()</h5><p>每个 EGLDisplay 在使用前都需要初始化。初始化 EGLDisplay 的同时，你可以得到系统中 EGL 的实现版本号。了解当前的版本号在向后兼容性方面是非常有价值的。在移动设备上，通过动态查询 EGL 版本号，你可以为新旧版本的 EGL 附加额外的特性或运行环境。基于平台配置，软件开发可用清楚知道哪些 API 可用访问，这将会为你的代码提供最大限度的可移植性。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglInitialize</span><span class="params">(EGLDisplay dpy, EGLint *major, EGLint *minor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    EGLBoolean res = EGL_TRUE;</span><br><span class="line">    <span class="keyword">egl_display_t</span>&amp; d = <span class="keyword">egl_display_t</span>::get_display(dpy);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d.initialized.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_acquire) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == EGL_TRUE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (major != <span class="literal">NULL</span>) *major = VERSION_MAJOR;</span><br><span class="line">        <span class="keyword">if</span> (minor != <span class="literal">NULL</span>) *minor = VERSION_MINOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 dpy 应该是一个有效的 EGLDisplay 。函数返回时， major 和 minor 将被赋予当前 EGL 版本号。比如 EGL1.0 ， major 返回 1 ， minor 则返回 0 。给 major 和 minor 传 NULL 是有效的，如果你不关心版本号。<br>eglQueryString() 函数是另外一个获取版本信息和其他信息的途径。通过 eglQueryString() 获取版本信息需要解析版本字符串，所以通过传递一个指针给 eglInitializ() 函数比较容易获得这个信息。注意在调用 eglQueryString() 必须先使用 eglInitialize() 初始化 EGLDisplay ，否则将得到 EGL_NOT_INITIALIZED 错误信息。</p><h5 id="5-3、eglChooseConfig"><a href="#5-3、eglChooseConfig" class="headerlink" title="5.3、eglChooseConfig()"></a>5.3、eglChooseConfig()</h5><p>基 于 EGL 的属性，可以得到一个和需求接近的Config，但也可以选择自己需要的Config，只要平台支持。不是所有的Config都是有效的，也就是不是所有Config都会支持。 eglChooseConfig() 函数将适配一个所期望的配置，并且尽可能接近一个有效的系统配置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglChooseConfig</span><span class="params">( EGLDisplay dpy, <span class="keyword">const</span> EGLint *attrib_list,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLConfig *configs, EGLint config_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLint *num_config)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ggl_unlikely(num_config==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_PARAMETER, EGL_FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ggl_unlikely(attrib_list==<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * A NULL attrib_list should be treated as though it was an empty</span></span><br><span class="line"><span class="comment">         * one (terminated with EGL_NONE) as defined in</span></span><br><span class="line"><span class="comment">         * section 3.4.1 "Querying Configurations" in the EGL specification.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> EGLint dummy = EGL_NONE;</span><br><span class="line">        attrib_list = &amp;dummy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numAttributes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numConfigs =  NELEM(gConfigs);</span><br><span class="line">    <span class="keyword">uint32_t</span> possibleMatch = (<span class="number">1</span>&lt;&lt;numConfigs)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(possibleMatch &amp;&amp; *attrib_list != EGL_NONE) &#123;</span><br><span class="line">        numAttributes++;</span><br><span class="line">        EGLint attr = *attrib_list++;</span><br><span class="line">        EGLint val  = *attrib_list++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (isAttributeMatching(i, attr, val) == <span class="number">0</span>) &#123;</span><br><span class="line">                possibleMatch &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// now, handle the attributes which have a useful default value</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j=<span class="number">0</span> ; possibleMatch &amp;&amp; j&lt;NELEM(config_defaults) ; j++) &#123;</span><br><span class="line">        <span class="comment">// see if this attribute was specified, if not, apply its</span></span><br><span class="line">        <span class="comment">// default value</span></span><br><span class="line">        <span class="keyword">if</span> (binarySearch&lt;<span class="keyword">config_pair_t</span>&gt;(</span><br><span class="line">                (<span class="keyword">config_pair_t</span> <span class="keyword">const</span>*)attrib_list,</span><br><span class="line">                <span class="number">0</span>, numAttributes<span class="number">-1</span>,</span><br><span class="line">                config_defaults[j].key) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; possibleMatch &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!(possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (isAttributeMatching(i,</span><br><span class="line">                        config_defaults[j].key,</span><br><span class="line">                        config_defaults[j].value) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    possibleMatch &amp;= ~(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return the configurations found</span></span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (possibleMatch) &#123;</span><br><span class="line">        <span class="keyword">if</span> (configs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; config_size &amp;&amp; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                    *configs++ = (EGLConfig)(<span class="keyword">uintptr_t</span>)i;</span><br><span class="line">                    config_size--;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;numConfigs ; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (possibleMatch &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *num_config = n;</span><br><span class="line">     <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数 attrib_list 指定了选择配置时需要参照的属性。参数 configs 将返回一个按照 attrib_list 排序的平台有效的所有 EGL framebuffer 配置列表。参数 config_size 指定了可以返回到 configs 的总配置个数。参数 num_config 返回了实际匹配的配置总数。</p><h5 id="5-4、eglCreateContext"><a href="#5-4、eglCreateContext" class="headerlink" title="5.4、eglCreateContext()"></a>5.4、eglCreateContext()</h5><p>OpenGL ES的pipeline从程序的角度看就是一个状态机，有当前的颜色、纹理坐标、变换矩阵、绚染模式等一大堆状态，这些状态作用于OpenGL API程序提交的顶点坐标等图元从而形成帧缓冲内的像素。在OpenGL的编程接口中，Context就代表这个状态机，OpenGL API程序的主要工作就是向Context提供图元、设置状态，偶尔也从Context里获取一些信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLContext <span class="title">eglCreateContext</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLContext <span class="comment">/*share_list*/</span>, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ogles_context_t</span>* gl = ogles_init(<span class="keyword">sizeof</span>(<span class="keyword">egl_context_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!gl) <span class="keyword">return</span> setError(EGL_BAD_ALLOC, EGL_NO_CONTEXT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_context_t</span>* c = <span class="keyword">static_cast</span>&lt;<span class="keyword">egl_context_t</span>*&gt;(gl-&gt;rasterizer.base);</span><br><span class="line">    c-&gt;flags = <span class="keyword">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">    c-&gt;dpy = dpy;</span><br><span class="line">    c-&gt;config = config;</span><br><span class="line">    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (EGLContext)gl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-5、eglCreateWindowSurface"><a href="#5-5、eglCreateWindowSurface" class="headerlink" title="5.5、eglCreateWindowSurface()"></a>5.5、eglCreateWindowSurface()</h5><p>Surface实际上就是一个FrameBuffer，也就是渲染目的地，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLSurface <span class="title">eglCreateWindowSurface</span><span class="params">(  EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    NativeWindowType window,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> EGLint *attrib_list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createWindowSurface(dpy, config, window, attrib_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> EGLSurface <span class="title">createWindowSurface</span><span class="params">(EGLDisplay dpy, EGLConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">        NativeWindowType window, <span class="keyword">const</span> EGLint* <span class="comment">/*attrib_list*/</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_NO_SURFACE);</span><br><span class="line">    <span class="keyword">if</span> (window == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    EGLint surfaceType;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_SURFACE_TYPE, &amp;surfaceType) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(surfaceType &amp; EGL_WINDOW_BIT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window)-&gt;common.magic !=</span><br><span class="line">            ANDROID_NATIVE_WINDOW_MAGIC) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    EGLint configID;</span><br><span class="line">    <span class="keyword">if</span> (getConfigAttrib(dpy, config, EGL_CONFIG_ID, &amp;configID) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> depthFormat;</span><br><span class="line">    <span class="keyword">int32_t</span> pixelFormat;</span><br><span class="line">    <span class="keyword">if</span> (getConfigFormatInfo(configID, pixelFormat, depthFormat) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_NO_SURFACE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">egl_surface_t</span>* surface;</span><br><span class="line">    surface = <span class="keyword">new</span> <span class="keyword">egl_window_surface_v2_t</span>(dpy, config, depthFormat,</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;ANativeWindow*&gt;(window));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!surface-&gt;initCheck()) &#123;</span><br><span class="line">        <span class="keyword">delete</span> surface;</span><br><span class="line">        surface = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> surface;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来创建一个可实际显示的Surface。</p><p>系统通常还支持另外两种Surface：PixmapSurface和PBufferSurface，这两种都不是可显示的Surface，PixmapSurface是保存在系统内存中的位图，PBuffer则是保存在显存中的帧。</p><p>对于这两种surface，Android系统中，支持PBufferSurface。</p><h5 id="5-6、eglMakeCurrent"><a href="#5-6、eglMakeCurrent" class="headerlink" title="5.6、eglMakeCurrent()"></a>5.6、eglMakeCurrent()</h5><p>该接口将申请到的display，draw（surface）和 context进行了绑定。也就是说，在context下的OpenGLAPI指令将draw（surface）作为其渲染最终目的地。而display作为draw（surface）的前端显示。调用后，当前线程使用的EGLContex为context。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line"><span class="function">EGLBoolean <span class="title">eglMakeCurrent</span><span class="params">(  EGLDisplay dpy, EGLSurface draw,</span></span></span><br><span class="line"><span class="function"><span class="params">                            EGLSurface read, EGLContext ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">egl_display_t</span>::is_valid(dpy) == EGL_FALSE)</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">    <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* s = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;isValid())</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check that draw is compatible with the context</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (read &amp;&amp; read!=draw) &#123;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* s = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> (!s-&gt;isValid())</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_SURFACE, EGL_FALSE);</span><br><span class="line">        <span class="keyword">if</span> (s-&gt;dpy != dpy)</span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_DISPLAY, EGL_FALSE);</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> check that read is compatible with the context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EGLContext current_ctx = EGL_NO_CONTEXT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read == EGL_NO_SURFACE &amp;&amp; draw == EGL_NO_SURFACE) &amp;&amp; (ctx != EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((read != EGL_NO_SURFACE || draw != EGL_NO_SURFACE) &amp;&amp; (ctx == EGL_NO_CONTEXT))</span><br><span class="line">        <span class="keyword">return</span> setError(EGL_BAD_MATCH, EGL_FALSE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx == EGL_NO_CONTEXT) &#123;</span><br><span class="line">        <span class="comment">// if we're detaching, we need the current context</span></span><br><span class="line">        current_ctx = (EGLContext)getGlThreadSpecific();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(ctx);</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">        <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">        <span class="keyword">if</span> ((d &amp;&amp; d-&gt;ctx &amp;&amp; d-&gt;ctx != ctx) ||</span><br><span class="line">            (r &amp;&amp; r-&gt;ctx &amp;&amp; r-&gt;ctx != ctx)) &#123;</span><br><span class="line">            <span class="comment">// one of the surface is bound to a context in another thread</span></span><br><span class="line">            <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ogles_context_t</span>* gl = (<span class="keyword">ogles_context_t</span>*)ctx;</span><br><span class="line">    <span class="keyword">if</span> (makeCurrent(gl) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx) &#123;</span><br><span class="line">            <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(ctx);</span><br><span class="line">            <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)draw;</span><br><span class="line">            <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)read;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c-&gt;draw) &#123;</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* s = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">egl_surface_t</span>*&gt;(c-&gt;draw);</span><br><span class="line">                s-&gt;disconnect();</span><br><span class="line">                s-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                <span class="keyword">if</span> (s-&gt;zombie)</span><br><span class="line">                    <span class="keyword">delete</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;read) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            c-&gt;draw = draw;</span><br><span class="line">            c-&gt;read = read;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; <span class="keyword">egl_context_t</span>::NEVER_CURRENT) &#123;</span><br><span class="line">                c-&gt;flags &amp;= ~<span class="keyword">egl_context_t</span>::NEVER_CURRENT;</span><br><span class="line">                GLint w = <span class="number">0</span>;</span><br><span class="line">                GLint h = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (draw) &#123;</span><br><span class="line">                    w = d-&gt;getWidth();</span><br><span class="line">                    h = d-&gt;getHeight();</span><br><span class="line">                &#125;</span><br><span class="line">                ogles_surfaceport(gl, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                ogles_viewport(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">                ogles_scissor(gl, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                <span class="keyword">if</span> (d-&gt;connect() == EGL_FALSE) &#123;</span><br><span class="line">                    <span class="keyword">return</span> EGL_FALSE;</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ctx = ctx;</span><br><span class="line">                d-&gt;bindDrawSurface(gl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">FIXME:</span> lock/connect the read surface too </span></span><br><span class="line">                r-&gt;ctx = ctx;</span><br><span class="line">                r-&gt;bindReadSurface(gl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if surfaces were bound to the context bound to this thread</span></span><br><span class="line">            <span class="comment">// mark then as unbound.</span></span><br><span class="line">            <span class="keyword">if</span> (current_ctx) &#123;</span><br><span class="line">                <span class="keyword">egl_context_t</span>* c = <span class="keyword">egl_context_t</span>::context(current_ctx);</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* d = (<span class="keyword">egl_surface_t</span>*)c-&gt;draw;</span><br><span class="line">                <span class="keyword">egl_surface_t</span>* r = (<span class="keyword">egl_surface_t</span>*)c-&gt;read;</span><br><span class="line">                <span class="keyword">if</span> (d) &#123;</span><br><span class="line">                    c-&gt;draw = <span class="number">0</span>;</span><br><span class="line">                    d-&gt;disconnect();</span><br><span class="line">                    d-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="keyword">if</span> (d-&gt;zombie)</span><br><span class="line">                        <span class="keyword">delete</span> d;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (r) &#123;</span><br><span class="line">                    c-&gt;read = <span class="number">0</span>;</span><br><span class="line">                    r-&gt;ctx = EGL_NO_CONTEXT;</span><br><span class="line">                    <span class="comment">// <span class="doctag">FIXME:</span> unlock/disconnect the read surface too </span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EGL_TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setError(EGL_BAD_ACCESS, EGL_FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-7、绘制gl"><a href="#5-7、绘制gl" class="headerlink" title="5.7、绘制gl_*()"></a>5.7、绘制gl_*()</h5><p>应用程序通过OpenGL API进行绘制，一帧完成之后，调用eglSwapBuffers(EGLDisplay dpy, EGLContext ctx)来显示。</p><h5 id="5-8、eglSwapBuffers接口实现说明"><a href="#5-8、eglSwapBuffers接口实现说明" class="headerlink" title="5.8、eglSwapBuffers接口实现说明"></a>5.8、eglSwapBuffers接口实现说明</h5><p>Android平台：</p><p>为了实现eglSwapBuffers， eglSurface其实代表了一个从NativeWindow 申请到的一个Buffer（Dequeue操作）。当调用eglSwapBuffers时，对于一般应用窗口而言，NativeWindow将该Surface的Buffer 提交回去给SurfaceFlinger（Queue操作)，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\opengl\libagl\egl.cpp]</span><br><span class="line">EGLBoolean egl_window_surface_v2_t::swapBuffers()</span><br><span class="line">&#123;</span><br><span class="line">......</span><br><span class="line">nativeWindow-&gt;queueBuffer(nativeWindow, buffer); </span><br><span class="line">nativeWindow-&gt;dequeueBuffer(nativeWindow, &amp;buffer);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后又重新从NativeWindow中重新Dequeue出来一个新的Buffer给eglSurface。而eglDisplay并不代表实际的意义。我们只是从接口上感觉是，surface和display进行了交换。（注：现在是Triple Buffer）</p><blockquote><p><strong>总结：从前面关于Android EGL、OpenGL ES的分析知道，现在我们可以通过SurfaceFlinger申请一块Surface（Buffer），然后可以利用OpenGL ES接口在Native 层绘制相关的图片、文字；那么疑问来了，Android上层绚丽多彩的App界面是如何绘制而成的呢、App层如何通过底层的OpenGL ES接口来完成绘制呢？？？</strong></p></blockquote><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://www.khronos.org/" target="_blank" rel="noopener">Khronos Group</a><br><a href="https://source.android.com/devices/graphics/architecture" target="_blank" rel="noopener">Android图形架构 官方文档</a><br><a href="http://geekfaner.com/shineengine/index.html" target="_blank" rel="noopener">OPENGL ES 2.0 知识串讲</a><br><a href="https://www.slideshare.net/namjungsoo/egl-31239467" target="_blank" rel="noopener">OpenGL ES EGL Spec&amp;APIs</a><br><a href="https://www.slideshare.net/SuhanLee2/understaing-android-egl" target="_blank" rel="noopener">Understaing-Android-Egl</a><br><a href="https://woshijpf.github.io/category/android/" target="_blank" rel="noopener">Android 系统图形栈(1) &amp;&amp;(2)： OpenGL ES 和 EGL</a><br><a href="https://blog.csdn.net/hovan/article/details/43198399" target="_blank" rel="noopener">Android L 的开机动画流程 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera System（2）：Camera System(Camera 系统)startPreview、takePicture、Recorder流程分析</title>
    <link href="http://zhoujinjian.cc/2018/07/10/Android%20Camera%20System%EF%BC%882%EF%BC%89%EF%BC%9ACamera%20System%5BCamera%20%E7%B3%BB%E7%BB%9F%5DstartPreview%E3%80%81takePicture%E3%80%81Recorder%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/07/10/Android Camera System（2）：Camera System[Camera 系统]startPreview、takePicture、Recorder流程分析/</id>
    <published>2018-07-09T16:00:00.000Z</published>
    <updated>2018-05-25T12:12:49.620Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/camera.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">【特别感谢 - Android Camera fw学习-Armwind】</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">【特别感谢 - Android Camera API2分析-Gzzaigcnforever】</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">【特别感谢 - Android Camera 流程学习记录 Android 7.12-QQ_16775897】</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">【特别感谢 - 专栏：古冥的android6.0下的Camera API2.0的源码分析之旅】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><hr><p>☯ Application：<br>☯ /packages/apps/Camera2/src/com/android/camera/</p><p>☯ Framework：<br>☯ /frameworks/base/core/java/android/hardware/Camera.java</p><p>☯ JNI:<br>☯ /frameworks/base/core/jni/android_hardware_Camera.cpp</p><p>☯ Native:<br>☯ Client：<br>frameworks/av/camera/CameraBase.cpp<br>frameworks/av/camera/Camera.cpp<br>frameworks/av/camera/ICamera.cpp<br>frameworks/av/camera/aidl/android/hardware/ICamera.aidl<br>frameworks/av/camera/aidl/android/hardware/ICameraClient.aidl<br>☯ Server：<br>frameworks/av/camera/cameraserver/main_cameraserver.cpp<br>frameworks/av/services/camera/libcameraservice/CameraService.cpp<br>frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</p><p>☯ HAL：<br>☯ /frameworks/av/services/camera/libcameraservice/device3/<br>☯ /hardware/qcom/camera/QCamera2(高通HAL)<br>☯ /vendor/qcom/proprietary/mm-camera(高通mm-camera)<br>☯ /vendor/qcom/proprietary/mm-still(高通JPEG)</p><p>☯ Kernel：<br>☯ /kernel/drivers/media/platform/msm/camera_v2(高通V4L2)<br>☯ /kernel/arch/arm/boot/dts/(高通dts)</p><hr><h4 id="（一）、Camera-System-startPreview流程分析"><a href="#（一）、Camera-System-startPreview流程分析" class="headerlink" title="（一）、Camera System startPreview流程分析"></a>（一）、Camera System startPreview流程分析</h4><h5 id="1-1、Camera2-startPreview的应用层-Java-流程分析"><a href="#1-1、Camera2-startPreview的应用层-Java-流程分析" class="headerlink" title="1.1、Camera2 startPreview的应用层(Java)流程分析"></a>1.1、Camera2 startPreview的应用层(Java)流程分析</h5><p>preview流程都是从startPreview开始的，所以来看startPreview方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startPreview</span><span class="params">(Surface previewSurface, CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    mPreviewSurface = previewSurface;</span><br><span class="line">    <span class="comment">//根据Surface以及CaptureReadyCallback回调来建立preview环境</span></span><br><span class="line">    setupAsync(mPreviewSurface, listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这其中有一个比较重要的回调CaptureReadyCallback，先分析setupAsync方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupAsync</span><span class="params">(<span class="keyword">final</span> Surface previewSurface, <span class="keyword">final</span> CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    mCameraHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//建立preview环境</span></span><br><span class="line">            setup(previewSurface, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里通过CameraHandler来post一个Runnable对象，它只会调用Runnable的run方法，它仍然属于UI线程，并没有创建新的线程。所以，继续分析setup方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setup</span><span class="params">(Surface previewSurface, <span class="keyword">final</span> CaptureReadyCallback listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCaptureSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCaptureSession.abortCaptures();</span><br><span class="line">            mCaptureSession = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Surface&gt; outputSurfaces = <span class="keyword">new</span> ArrayList&lt;Surface&gt;(<span class="number">2</span>);</span><br><span class="line">        outputSurfaces.add(previewSurface);</span><br><span class="line">        outputSurfaces.add(mCaptureImageReader.getSurface());</span><br><span class="line">        <span class="comment">//创建CaptureSession会话来与Camera Device发送Preview请求</span></span><br><span class="line">        mDevice.createCaptureSession(outputSurfaces, <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//如果配置失败，则回调CaptureReadyCallback的onSetupFailed方法</span></span><br><span class="line">                listener.onSetupFailed();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                mCaptureSession = session;</span><br><span class="line">                mAFRegions = ZERO_WEIGHT_3A_REGION;</span><br><span class="line">                mAERegions = ZERO_WEIGHT_3A_REGION;</span><br><span class="line">                mZoomValue = <span class="number">1f</span>;</span><br><span class="line">                mCropRegion = cropRegionForZoom(mZoomValue);</span><br><span class="line">                <span class="comment">//调用repeatingPreview来启动preview</span></span><br><span class="line">                <span class="keyword">boolean</span> success = repeatingPreview(<span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                    <span class="comment">//若启动成功，则回调CaptureReadyCallback的onReadyForCapture，表示准备拍照成功</span></span><br><span class="line">                    listener.onReadyForCapture();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//若启动失败，则回调CaptureReadyCallback的onSetupFailed，表示preview建立失败</span></span><br><span class="line">                    listener.onSetupFailed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClosed</span><span class="params">(CameraCaptureSession session)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.onClosed(session);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mCameraHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not set up capture session"</span>, ex);</span><br><span class="line">        listener.onSetupFailed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，调用Device的createCaptureSession方法来创建一个会话，并定义了会话的状态回调CameraCaptureSession.StateCallback()，其中，当会话创建成功，则会回调onConfigured()方法,在其中，首先调用repeatingPreview来启动preview，然后处理preview的结果并调用先前定义的CaptureReadyCallback来通知用户进行Capture操作。先分析repeatingPreview方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">repeatingPreview</span><span class="params">(Object tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过CameraDevice对象创建一个CaptureRequest的preview请求</span></span><br><span class="line">        CaptureRequest.Builder builder = mDevice.createCaptureRequest(</span><br><span class="line">                CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        <span class="comment">//添加预览的目标Surface</span></span><br><span class="line">        builder.addTarget(mPreviewSurface);</span><br><span class="line">        <span class="comment">//设置预览模式</span></span><br><span class="line">        builder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);</span><br><span class="line">        addBaselineCaptureKeysToRequest(builder);</span><br><span class="line">        <span class="comment">//利用会话发送请求，mCaptureCallback为</span></span><br><span class="line">        mCaptureSession.setRepeatingRequest(builder.build(), mCaptureCallback,mCameraHandler);</span><br><span class="line">        Log.v(TAG, String.format(<span class="string">"Sent repeating Preview request, zoom = %.2f"</span>, mZoomValue));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not access camera setting up preview."</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用CameraDeviceImpl的createCaptureRequest方法创建类型为TEMPLATE_PREVIEW 的CaptureRequest，然后调用CameraCaptureSessionImpl的setRepeatingRequest方法将此请求发送出去：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]</span><br><span class="line">Override</span><br><span class="line">public synchronized int setRepeatingRequest(CaptureRequest request, CaptureCallback callback,</span><br><span class="line">        Handler handler) throws CameraAccessException &#123;</span><br><span class="line">    if (request == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;request must not be null&quot;);</span><br><span class="line">    &#125; else if (request.isReprocess()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;repeating reprocess requests are not supported&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkNotClosed();</span><br><span class="line">    handler = checkHandler(handler, callback);</span><br><span class="line">    ...</span><br><span class="line">    //将此请求添加到待处理的序列里</span><br><span class="line">    return addPendingSequence(mDeviceImpl.setRepeatingRequest(request,createCaptureCallbackProxy(</span><br><span class="line">        handler, callback), mDeviceHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此应用层的preview的请求流程分析结束，继续分析其结果处理，如果preview开启成功，则会回调CaptureReadyCallback的onReadyForCapture方法，现在分析CaptureReadyCallback回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="keyword">new</span> CaptureReadyCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSetupFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not set up preview."</span>);</span><br><span class="line">        mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Camera closed, aborting."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mCamera.close();</span><br><span class="line">                mCamera = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyForCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Ready for capture."</span>);</span><br><span class="line">                <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Camera closed, aborting."</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                onPreviewStarted();</span><br><span class="line">                onReadyStateChanged(<span class="keyword">true</span>);</span><br><span class="line">                mCamera.setReadyStateChangedListener(CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                mUI.initializeZoom(mCamera.getMaxZoom());</span><br><span class="line">                mCamera.setFocusStateListener(CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面的分析，预览成功后会回调onReadyForCapture方法，它主要是通知主线程的状态改变，并设置Camera的ReadyStateChangedListener的监听，其回调方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyStateChanged</span><span class="params">(<span class="keyword">boolean</span> readyForCapture)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readyForCapture) &#123;</span><br><span class="line">        mAppController.getCameraAppUI().enableModeOptions();</span><br><span class="line">    &#125;</span><br><span class="line">    mAppController.setShutterEnabled(readyForCapture);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，当其状态变成准备好拍照，则将会调用CameraActivity的setShutterEnabled方法，即使能快门按键，此时也就是说预览成功结束，可以按快门进行拍照了，所以，到这里，应用层的preview的流程基本分析完毕，下图是应用层的关键调用的流程时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-01-preview_java_flow.png" alt="Alt text"></p><h5 id="1-2、Camera2-startPreview的Native层流程分析"><a href="#1-2、Camera2-startPreview的Native层流程分析" class="headerlink" title="1.2、Camera2 startPreview的Native层流程分析"></a>1.2、Camera2 startPreview的Native层流程分析</h5><p>分析Preview的Native的代码真是费了九牛二虎之力，若有分析不正确之处，请各位大神指正，在第一小节的后段最后会调用CameraDeviceImpl的setRepeatingRequest方法来提交请求，而在android6.0源码分析之Camera API2.0简介中，分析了Camera2框架Java IPC通信使用了CameraDeviceUser来进行通信，所以看Native层的ICameraDeviceUser的onTransact方法来处理请求的提交：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/camera/aidl/android/hardware/camera2/ICameraDeviceUser.aidl]</span><br><span class="line">status_t BnCameraDeviceUser::onTransact(uint32_t code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, </span><br><span class="line">        uint32_t flags)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="comment">//请求提交</span></span><br><span class="line">        <span class="keyword">case</span> SUBMIT_REQUEST: &#123;</span><br><span class="line">            CHECK_INTERFACE(ICameraDeviceUser, data, reply);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// arg0 = request</span></span><br><span class="line">            sp&lt;CaptureRequest&gt; request;</span><br><span class="line">            <span class="keyword">if</span> (data.readInt32() != <span class="number">0</span>) &#123;</span><br><span class="line">                request = <span class="keyword">new</span> CaptureRequest();</span><br><span class="line">                request-&gt;readFromParcel(const_cast&lt;Parcel*&gt;(&amp;data));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// arg1 = streaming (bool)</span></span><br><span class="line">            bool repeating = data.readInt32();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// return code: requestId (int32)</span></span><br><span class="line">            reply-&gt;writeNoException();</span><br><span class="line">            int64_t lastFrameNumber = -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//将实现BnCameraDeviceUser的对下岗的submitRequest方法代码写入Binder</span></span><br><span class="line">            reply-&gt;writeInt32(submitRequest(request, repeating, &amp;lastFrameNumber));</span><br><span class="line">            reply-&gt;writeInt32(<span class="number">1</span>);</span><br><span class="line">            reply-&gt;writeInt64(lastFrameNumber);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraDeviceClientBase继承了BnCameraDeviceUser类，所以CameraDeviceClientBase相当于IPC Binder中的client，所以会调用其submitRequest方法，此处，至于IPC Binder通信原理不做分析，其参照其它资料：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::submitRequest(sp&lt;CaptureRequest&gt; request,<span class="keyword">bool</span> streaming,</span><br><span class="line">        <span class="comment">/*out*/</span><span class="keyword">int64_t</span>* lastFrameNumber) &#123;</span><br><span class="line">    List&lt;sp&lt;CaptureRequest&gt; &gt; requestList;</span><br><span class="line">    requestList.push_back(request);</span><br><span class="line">    <span class="keyword">return</span> submitRequestList(requestList, streaming, lastFrameNumber);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的调用，继续分析submitRequestList：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::submitRequestList(List&lt;sp&lt;CaptureRequest&gt; &gt; requests,<span class="keyword">bool</span> streaming, </span><br><span class="line">        <span class="keyword">int64_t</span>* lastFrameNumber) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Metadata链表</span></span><br><span class="line">    List&lt;<span class="keyword">const</span> CameraMetadata&gt; metadataRequestList;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (List&lt;sp&lt;CaptureRequest&gt; &gt;::iterator it = requests.begin(); it != requests.end(); ++it) &#123;</span><br><span class="line">        sp&lt;CaptureRequest&gt; request = *it;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//初始化Metadata数据</span></span><br><span class="line">        <span class="function">CameraMetadata <span class="title">metadata</span><span class="params">(request-&gt;mMetadata)</span></span>;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//设置Stream的容量</span></span><br><span class="line">        Vector&lt;<span class="keyword">int32_t</span>&gt; outputStreamIds;</span><br><span class="line">        outputStreamIds.setCapacity(request-&gt;mSurfaceList.size());</span><br><span class="line">        <span class="comment">//循环初始化Surface</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; request-&gt;mSurfaceList.size(); ++i) &#123;</span><br><span class="line">            sp&lt;Surface&gt; surface = request-&gt;mSurfaceList[i];</span><br><span class="line">            <span class="keyword">if</span> (surface == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sp&lt;IGraphicBufferProducer&gt; gbp = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">int</span> idx = mStreamMap.indexOfKey(IInterface::asBinder(gbp));</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">int</span> streamId = mStreamMap.valueAt(idx);</span><br><span class="line">            outputStreamIds.push_back(streamId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新数据</span></span><br><span class="line">        metadata.update(ANDROID_REQUEST_OUTPUT_STREAMS, &amp;outputStreamIds[<span class="number">0</span>],</span><br><span class="line">                        outputStreamIds.size());</span><br><span class="line">        <span class="keyword">if</span> (request-&gt;mIsReprocess) &#123;</span><br><span class="line">            metadata.update(ANDROID_REQUEST_INPUT_STREAMS, &amp;mInputStream.id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        metadata.update(ANDROID_REQUEST_ID, &amp;requestId, <span class="comment">/*size*/</span><span class="number">1</span>);</span><br><span class="line">        loopCounter++; <span class="comment">// loopCounter starts from 1</span></span><br><span class="line">        <span class="comment">//压栈</span></span><br><span class="line">        metadataRequestList.push_back(metadata);</span><br><span class="line">    &#125;</span><br><span class="line">    mRequestIdCounter++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (streaming) &#123;</span><br><span class="line">        <span class="comment">//预览会走此条通道</span></span><br><span class="line">        res = mDevice-&gt;setStreamingRequestList(metadataRequestList, lastFrameNumber);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStreamingRequestList.push_back(requestId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//Capture等走此条通道</span></span><br><span class="line">        res = mDevice-&gt;captureList(metadataRequestList, lastFrameNumber);</span><br><span class="line">        <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> requestId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setStreamingRequestList和captureList方法都调用了submitRequestsHelper方法，只是他们的repeating参数一个ture,一个为false，而本节分析的preview调用的是setStreamingRequestList方法，并且API2.0下Device的实现为Camera3Device，所以看它的submitRequestsHelper实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::submitRequestsHelper(<span class="keyword">const</span> List&lt;<span class="keyword">const</span> CameraMetadata&gt; &amp;requests, </span><br><span class="line">        <span class="keyword">bool</span> repeating,<span class="comment">/*out*/</span><span class="keyword">int64_t</span> *lastFrameNumber) &#123;</span><br><span class="line">    ...</span><br><span class="line">    RequestList requestList;</span><br><span class="line">    <span class="comment">//在这里面会进行CaptureRequest的创建，并调用configureStreamLocked进行stream的配置，主要是设置了一个回调captureResultCb，即后面要分析的重要的回调</span></span><br><span class="line">    res = convertMetadataListToRequestListLocked(requests, <span class="comment">/*out*/</span>&amp;requestList);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (repeating) &#123;</span><br><span class="line">        <span class="comment">//眼熟不，这个方法名和应用层中CameraDevice的setRepeatingRequests一样</span></span><br><span class="line">        res = mRequestThread-&gt;setRepeatingRequests(requestList, lastFrameNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不需重复，即repeating为false时，调用此方法来讲请求提交</span></span><br><span class="line">        res = mRequestThread-&gt;queueRequestList(requestList, lastFrameNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-02-preview_native_architecture.png" alt="Alt text"></p><p>从代码可知，在Camera3Device里创建了要给RequestThread线程，调用它的setRepeatingRequests或者queueRequestList方法来将应用层发送过来的Request提交，继续看setRepeatingRequests方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::RequestThread::setRepeatingRequests(<span class="keyword">const</span> RequestList &amp;requests,</span><br><span class="line">        <span class="comment">/*out*/</span><span class="keyword">int64_t</span> *lastFrameNumber) &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mRequestLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (lastFrameNumber != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *lastFrameNumber = mRepeatingLastFrameNumber;</span><br><span class="line">    &#125;</span><br><span class="line">    mRepeatingRequests.clear();</span><br><span class="line">    <span class="comment">//将其插入mRepeatingRequest链表</span></span><br><span class="line">    mRepeatingRequests.insert(mRepeatingRequests.begin(),</span><br><span class="line">            requests.begin(), requests.end());</span><br><span class="line"></span><br><span class="line">    unpauseForNewRequests();</span><br><span class="line"></span><br><span class="line">    mRepeatingLastFrameNumber = NO_IN_FLIGHT_REPEATING_FRAMES;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Native层的preview过程基本分析结束，下面的工作将会交给Camera HAL层来处理，先给出Native层的调用时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-03-preview_native_flow.png" alt="Alt text"></p><h5 id="1-3、Camera2-startPreview的HAL层流程分析"><a href="#1-3、Camera2-startPreview的HAL层流程分析" class="headerlink" title="1.3、Camera2 startPreview的HAL层流程分析"></a>1.3、Camera2 startPreview的HAL层流程分析</h5><p>本节将不再对Camera的HAL层的初始化以及相关配置进行分析，只对preview等相关流程中的frame metadata的处理流程进行分析，具体的CameraHAL分析请参考前一篇分析，在第二小节的submitRequestsHelper方法中调用convertMetadataListToRequestListLocked的时候会进行CaptureRequest的创建，并调用configureStreamLocked进行stream的配置，主要是设置了一个回调captureResultCb，所以Native层在request提交后，会回调此captureResultCb方法，首先分析captureResultCb：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::captureResultCb(<span class="keyword">mm_camera_super_buf_t</span> *metadata_buf,</span><br><span class="line">        <span class="keyword">camera3_stream_buffer_t</span> *buffer, <span class="keyword">uint32_t</span> frame_number)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata_buf) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mBatchSize) &#123;</span><br><span class="line">            <span class="comment">//批处理模式，但代码也是循环调用handleMetadataWithLock方法</span></span><br><span class="line">            handleBatchMetadata(metadata_buf, <span class="literal">true</span> <span class="comment">/* free_and_bufdone_meta_buf */</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* mBatchSize = 0 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;mMutex);    </span><br><span class="line">            <span class="comment">//处理元数据</span></span><br><span class="line">            handleMetadataWithLock(metadata_buf, <span class="literal">true</span> <span class="comment">/* free_and_bufdone_meta_buf */</span>);</span><br><span class="line">            pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mMutex);</span><br><span class="line">        handleBufferWithLock(buffer, frame_number);</span><br><span class="line">        pthread_mutex_unlock(&amp;mMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种是通过循环来进行元数据的批处理，另一种是直接进行元数据的处理，但是批处理最终也是循环调用handleMetadataWithLock来处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/HAL3/QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::handleMetadataWithLock(<span class="keyword">mm_camera_super_buf_t</span> *metadata_buf, </span><br><span class="line">        <span class="keyword">bool</span> free_and_bufdone_meta_buf)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Partial result on process_capture_result for timestamp</span></span><br><span class="line">    <span class="keyword">if</span> (urgent_frame_number_valid) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i =mPendingRequestsList.begin(); </span><br><span class="line">                i != mPendingRequestsList.end(); i++) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;frame_number == urgent_frame_number &amp;&amp;i-&gt;bUrgentReceived == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">camera3_capture_result_t</span> result;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_capture_result_t</span>));</span><br><span class="line">                i-&gt;partial_result_cnt++;</span><br><span class="line">                i-&gt;bUrgentReceived = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//提取3A数据</span></span><br><span class="line">                result.result =translateCbUrgentMetadataToResultMetadata(metadata);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">//对Capture Result进行处理</span></span><br><span class="line">                mCallbackOps-&gt;process_capture_result(mCallbackOps, &amp;result);</span><br><span class="line">                <span class="comment">//释放camera_metadata_t</span></span><br><span class="line">                free_camera_metadata((<span class="keyword">camera_metadata_t</span> *)result.result);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin();</span><br><span class="line">            i != mPendingRequestsList.end() &amp;&amp; i-&gt;frame_number &lt;= frame_number;) &#123;</span><br><span class="line">        <span class="keyword">camera3_capture_result_t</span> result;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_capture_result_t</span>));</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (i-&gt;frame_number &lt; frame_number) &#123;</span><br><span class="line">            <span class="comment">//清空数据结构</span></span><br><span class="line">            <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line">            <span class="comment">//定义消息类型</span></span><br><span class="line">            notify_msg.type = CAMERA3_MSG_SHUTTER;</span><br><span class="line">            notify_msg.message.shutter.frame_number = i-&gt;frame_number;</span><br><span class="line">            notify_msg.message.shutter.timestamp = (<span class="keyword">uint64_t</span>)capture_time (urgent_frame_number - </span><br><span class="line">                i-&gt;frame_number) * NSEC_PER_33MSEC;</span><br><span class="line">            <span class="comment">//调用回调通知应用层发生CAMERA3_MSG_SHUTTER消息</span></span><br><span class="line">            mCallbackOps-&gt;notify(mCallbackOps, &amp;notify_msg);</span><br><span class="line">            ...</span><br><span class="line">            CameraMetadata dummyMetadata;</span><br><span class="line">            <span class="comment">//更新元数据</span></span><br><span class="line">            dummyMetadata.update(ANDROID_SENSOR_TIMESTAMP,</span><br><span class="line">                    &amp;i-&gt;timestamp, <span class="number">1</span>);</span><br><span class="line">            dummyMetadata.update(ANDROID_REQUEST_ID,</span><br><span class="line">                    &amp;(i-&gt;request_id), <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//得到元数据释放结果</span></span><br><span class="line">            result.result = dummyMetadata.release();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Send shutter notify to frameworks</span></span><br><span class="line">            notify_msg.type = CAMERA3_MSG_SHUTTER;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//从HAL中获得Metadata</span></span><br><span class="line">            result.result = translateFromHalMetadata(metadata,</span><br><span class="line">                    i-&gt;timestamp, i-&gt;request_id, i-&gt;jpegMetadata, i-&gt;pipeline_depth,</span><br><span class="line">                    i-&gt;capture_intent);</span><br><span class="line">            saveExifParams(metadata);</span><br><span class="line">            <span class="keyword">if</span> (i-&gt;blob_request) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (enabled &amp;&amp; metadata-&gt;is_tuning_params_valid) &#123;</span><br><span class="line">                    <span class="comment">//将Metadata复制到文件</span></span><br><span class="line">                    dumpMetadataToFile(metadata-&gt;tuning_params, mMetaFrameCount, enabled,</span><br><span class="line">                        <span class="string">"Snapshot"</span>,frame_number);</span><br><span class="line">                &#125;</span><br><span class="line">                mPictureChannel-&gt;queueReprocMetadata(metadata_buf);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Return metadata buffer</span></span><br><span class="line">                <span class="keyword">if</span> (free_and_bufdone_meta_buf) &#123;</span><br><span class="line">                    mMetadataChannel-&gt;bufDone(metadata_buf);</span><br><span class="line">                    <span class="built_in">free</span>(metadata_buf);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，首先会调用回调的process_capture_result方法来对Capture Result进行处理，然后会调用回调的notify方法来发送一个CAMERA3_MSG_SHUTTER消息，而process_capture_result所对应的实现其实就是Camera3Device的processCaptureResult方法，先分析processCaptureResult：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line">void Camera3Device::processCaptureResult(const camera3_capture_result *result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    //对于HAL3.2+,如果HAL不支持partial，当metadata被包含在result中时，它必须将partial_result设置为1</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock l(mInFlightLock);</span><br><span class="line">        ssize_t idx = mInFlightMap.indexOfKey(frameNumber);</span><br><span class="line">        ...</span><br><span class="line">        InFlightRequest &amp;request = mInFlightMap.editValueAt(idx);</span><br><span class="line">        if (result-&gt;partial_result != 0)</span><br><span class="line">            request.resultExtras.partialResultCount = result-&gt;partial_result;</span><br><span class="line">        // 检查结果是否只有partial metadata</span><br><span class="line">        if (mUsePartialResult &amp;&amp; result-&gt;result != NULL) &#123;</span><br><span class="line">            if (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;//HAL版本高于3.2</span><br><span class="line">                if (result-&gt;partial_result &gt; mNumPartialResults || result-&gt;partial_result &lt; 1) &#123;</span><br><span class="line">                    //Log显示错误</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                isPartialResult = (result-&gt;partial_result &lt; mNumPartialResults);</span><br><span class="line">                if (isPartialResult) &#123;</span><br><span class="line">                    //将结果加入到请求的结果集中</span><br><span class="line">                    request.partialResult.collectedResult.append(result-&gt;result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;//低于3.2</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            if (isPartialResult) &#123;</span><br><span class="line">                // Fire off a 3A-only result if possible</span><br><span class="line">                if (!request.partialResult.haveSent3A) &#123;</span><br><span class="line">                    request.partialResult.haveSent3A =processPartial3AResult(frameNumber,</span><br><span class="line">                        request.partialResult.collectedResult,request.resultExtras);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        if (result-&gt;result != NULL &amp;&amp; !isPartialResult) &#123;</span><br><span class="line">            if (shutterTimestamp == 0) &#123;</span><br><span class="line">                request.pendingMetadata = result-&gt;result;</span><br><span class="line">                request.partialResult.collectedResult = collectedPartialResult;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                CameraMetadata metadata;</span><br><span class="line">                metadata = result-&gt;result;</span><br><span class="line">                //发送Capture Result</span><br><span class="line">                sendCaptureResult(metadata, request.resultExtras, collectedPartialResult, </span><br><span class="line">                    frameNumber, hasInputBufferInRequest,request.aeTriggerCancelOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //结果处理好了，将请求移除</span><br><span class="line">        removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">    &#125; // scope for mInFlightLock</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它会处理局部的或者全部的metadata数据，最后如果result不为空，且得到的是请求处理的全部数据，则会调用sendCaptureResult方法来将请求结果发送出去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::sendCaptureResult(CameraMetadata &amp;pendingMetadata,CaptureResultExtras </span><br><span class="line">        &amp;resultExtras,CameraMetadata &amp;collectedPartialResult,<span class="keyword">uint32_t</span> frameNumber,<span class="keyword">bool</span> reprocess,</span><br><span class="line">        <span class="keyword">const</span> AeTriggerCancelOverride_t &amp;aeTriggerCancelOverride) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingMetadata.isEmpty())<span class="comment">//如果数据为空，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ...</span><br><span class="line">    CaptureResult captureResult;</span><br><span class="line">    captureResult.mResultExtras = resultExtras;</span><br><span class="line">    captureResult.mMetadata = pendingMetadata;</span><br><span class="line">    <span class="comment">//更新metadata</span></span><br><span class="line">    <span class="keyword">if</span> (captureResult.mMetadata.update(ANDROID_REQUEST_FRAME_COUNT(<span class="keyword">int32_t</span>*)&amp;frameNumber, <span class="number">1</span>) </span><br><span class="line">            != OK) &#123;</span><br><span class="line">        SET_ERR(<span class="string">"Failed to set frame# in metadata (%d)"</span>,frameNumber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append any previous partials to form a complete result</span></span><br><span class="line">    <span class="keyword">if</span> (mUsePartialResult &amp;&amp; !collectedPartialResult.isEmpty()) &#123;</span><br><span class="line">        captureResult.mMetadata.append(collectedPartialResult);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    captureResult.mMetadata.sort();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that there's a timestamp in the result metadata</span></span><br><span class="line">    camera_metadata_entry entry = captureResult.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    ...</span><br><span class="line">    overrideResultForPrecaptureCancel(&amp;captureResult.mMetadata, aeTriggerCancelOverride);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有效的结果，将其插入Buffer</span></span><br><span class="line">    List&lt;CaptureResult&gt;::iterator queuedResult =mResultQueue.insert(mResultQueue.end(), </span><br><span class="line">        CaptureResult(captureResult));</span><br><span class="line">    ...</span><br><span class="line">    mResultSignal.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，它将Capture Result插入了结果队列，并释放了结果的信号量，所以到这里，Capture Result处理成功，下面分析前面的notify发送CAMERA3_MSG_SHUTTER消息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::notify(<span class="keyword">const</span> camera3_notify_msg *msg) &#123;</span><br><span class="line"></span><br><span class="line">    NotificationListener *listener;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mOutputLock)</span></span>;</span><br><span class="line">        listener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> CAMERA3_MSG_ERROR: &#123;</span><br><span class="line">            notifyError(msg-&gt;message.error, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> CAMERA3_MSG_SHUTTER: &#123;</span><br><span class="line">            notifyShutter(msg-&gt;message.shutter, listener);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SET_ERR(<span class="string">"Unknown notify message from HAL: %d"</span>,</span><br><span class="line">                    msg-&gt;type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了notifyShutter方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::notifyShutter(<span class="keyword">const</span> <span class="keyword">camera3_shutter_msg_t</span> &amp;msg,</span><br><span class="line">        NotificationListener *listener) &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Set timestamp for the request in the in-flight tracking</span></span><br><span class="line">    <span class="comment">// and get the request ID to send upstream</span></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInFlightLock)</span></span>;</span><br><span class="line">        idx = mInFlightMap.indexOfKey(msg.frame_number);</span><br><span class="line">        <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            InFlightRequest &amp;r = mInFlightMap.editValueAt(idx);</span><br><span class="line">            <span class="comment">// Call listener, if any</span></span><br><span class="line">            <span class="keyword">if</span> (listener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">//调用监听的notifyShutter法国法</span></span><br><span class="line">                listener-&gt;notifyShutter(r.resultExtras, msg.timestamp);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//将待处理的result发送到Buffer</span></span><br><span class="line">            sendCaptureResult(r.pendingMetadata, r.resultExtras,</span><br><span class="line">                r.partialResult.collectedResult, msg.frame_number,</span><br><span class="line">                r.hasInputBuffer, r.aeTriggerCancelOverride);</span><br><span class="line">            returnOutputBuffers(r.pendingOutputBuffers.<span class="built_in">array</span>(),</span><br><span class="line">                r.pendingOutputBuffers.size(), r.shutterTimestamp);</span><br><span class="line">            r.pendingOutputBuffers.clear();</span><br><span class="line">            removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先它会通知listener preview成功，最后会调用sendCaptureResult将结果加入到结果队列。它会调用listener的notifyShutter方法，此处的listener其实是CameraDeviceClient类，所以会调用CameraDeviceClient类的notifyShutter方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">void</span> CameraDeviceClient::notifyShutter(<span class="keyword">const</span> CaptureResultExtras&amp; resultExtras,<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="comment">// Thread safe. Don't bother locking.</span></span><br><span class="line">    sp&lt;ICameraDeviceCallbacks&gt; remoteCb = getRemoteCallback();</span><br><span class="line">    <span class="keyword">if</span> (remoteCb != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//调用应用层的回调(CaptureCallback的onCaptureStarted方法)</span></span><br><span class="line">        remoteCb-&gt;onCaptureStarted(resultExtras, timestamp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的ICameraDeviceCallbacks对应的是Java层的CameraDeviceImpl.java中的内部类CameraDeviceCallbacks，所以会调用它的onCaptureStarted方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line">@Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureStarted</span><span class="params">(final CaptureResultExtras resultExtras, final <span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> requestId = resultExtras.getRequestId();</span><br><span class="line">    final <span class="keyword">long</span> frameNumber = resultExtras.getFrameNumber();</span><br><span class="line">    final CaptureCallbackHolder holder;</span><br><span class="line"></span><br><span class="line">    synchronized(mInterfaceLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoteDevice == null) <span class="keyword">return</span>; <span class="comment">// Camera already closed</span></span><br><span class="line">        <span class="comment">// Get the callback for this frame ID, if there is one</span></span><br><span class="line">        holder = CameraDeviceImpl.<span class="keyword">this</span>.mCaptureCallbackMap.get(requestId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Dispatch capture start notice</span></span><br><span class="line">        holder.getHandler().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run() &#123;</span><br><span class="line">                <span class="keyword">if</span> (!CameraDeviceImpl.<span class="keyword">this</span>.isClosed()) &#123;</span><br><span class="line">                    holder.getCallback().onCaptureStarted(CameraDeviceImpl.<span class="keyword">this</span>,holder.getRequest(</span><br><span class="line">                        resultExtras.getSubsequenceId()),timestamp, frameNumber);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会调用OneCameraImpl.java中的mCaptureCallback的onCaptureStarted方法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="comment">//Common listener for preview frame metadata.  </span></span><br><span class="line"><span class="keyword">private</span> final CameraCaptureSession.CaptureCallback mCaptureCallback =</span><br><span class="line">    <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onCaptureStarted(CameraCaptureSession session,CaptureRequest request, </span><br><span class="line">            <span class="keyword">long</span> timestamp,<span class="keyword">long</span> frameNumber) &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.getTag() == RequestTag.CAPTURE&amp;&amp; mLastPictureCallback != null) &#123;</span><br><span class="line">                mLastPictureCallback.onQuickExpose();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>camera工作时，存在了５中流处理线程和一个专门向hal发送请求的request线程。线程之间通过信号来同步，稍不注意就搞不明白代码是如何运行的了。其中很容易让我们忽视的就是在流发送之前的parent-&gt;registerInFlight()该操作将当前的请求保存到一个数组(可以理解成)中。这个数组对象在后续回帧操作中，会将相应帧的shutter,时间戳信息填充到对应的request中，紧接着就把对应帧的信息返回给app。好了先到这吧，下一篇分析Camera recording流程。</p></blockquote><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-04-preview_hal_architecture.png" alt="Alt text"></p><p>注意：Capture,preview以及autoFocus都是使用的这个回调，而Capture调用的时候，其RequestTag为CAPTURE，而autoFocus的时候为TAP_TO_FOCUS,而preview请求时没有对RequestTag进行设置，所以回调到onCaptureStarted方法时，不需要进行处理，但是到此时，preview已经启动成功，可以进行预览了，其数据都在buffer里。所以到此时，preview的流程全部分析结束，下面给出HAL层上的流程时序图 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-05-preview_hal_flow.png" alt="Alt text"></p><h4 id="（二）、Camera-System-takePicture流程分析"><a href="#（二）、Camera-System-takePicture流程分析" class="headerlink" title="（二）、Camera System takePicture流程分析"></a>（二）、Camera System takePicture流程分析</h4><p>与TakePicture息息相关的主要有4个线程CaptureSequencer,JpegProcessor,Camera3Device::RequestThread,FrameProcessorBase如下面的代码可以发现，在Camera2client对象初始化后，已经有３个线程已经run起来了，还有有一个RequestThread线程会在Camera3Device初始化时创建的。他们工作非常密切，如下大概画了一个他们的工作机制，４个线程都是通过Conditon条件变量来同步的。 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-06-Camera3Device-RequestThread.png" alt="Alt text"></p><p>前面分析preview的时候，当预览成功后，会使能ShutterButton，即可以进行拍照，定位到ShutterButton的监听事件为onShutterButtonClick方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShutterButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Camera未打开</span></span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> countDownDuration = mSettingsManager.getInteger(SettingsManager</span><br><span class="line">        .SCOPE_GLOBAL,Keys.KEY_COUNTDOWN_DURATION);</span><br><span class="line">    <span class="keyword">if</span> (countDownDuration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始倒计时</span></span><br><span class="line">        mAppController.getCameraAppUI().transitionToCancel();</span><br><span class="line">        mAppController.getCameraAppUI().hideModeOptions();</span><br><span class="line">        mUI.setCountdownFinishedListener(<span class="keyword">this</span>);</span><br><span class="line">        mUI.startCountdown(countDownDuration);</span><br><span class="line">        <span class="comment">// Will take picture later via listener callback.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//即刻拍照</span></span><br><span class="line">        takePictureNow();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，读取Camera的配置，判断配置是否需要延时拍照，此处分析不需延时的情况，即调用takePictureNow方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePictureNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCamera == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.i(TAG, <span class="string">"Not taking picture since Camera is closed."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Capture会话并开启会话</span></span><br><span class="line">    CaptureSession session = createAndStartCaptureSession();</span><br><span class="line">    <span class="comment">//获取Camera的方向</span></span><br><span class="line">    <span class="keyword">int</span> orientation = mAppController.getOrientationManager()</span><br><span class="line">        .getDeviceOrientation().getDegrees();</span><br><span class="line">    <span class="comment">//初始化图片参数</span></span><br><span class="line">    PhotoCaptureParameters params = <span class="keyword">new</span> PhotoCaptureParameters(</span><br><span class="line">            session.getTitle(), orientation, session.getLocation(),</span><br><span class="line">            mContext.getExternalCacheDir(), <span class="keyword">this</span>, mPictureSaverCallback,</span><br><span class="line">            mHeadingSensor.getCurrentHeading(), mZoomValue, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//装配Session</span></span><br><span class="line">    decorateSessionAtCaptureTime(session);</span><br><span class="line">    <span class="comment">//拍照</span></span><br><span class="line">    mCamera.takePicture(params, session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它首先调用createAndStartCaptureSession来创建一个CaptureSession并且启动会话,这里并且会进行初始参数的设置，譬如设置CaptureModule(此处实参为this)为图片处理的回调(后面再分析)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> CaptureSession <span class="title">createAndStartCaptureSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取会话时间</span></span><br><span class="line">    <span class="keyword">long</span> sessionTime = getSessionTime();</span><br><span class="line">    <span class="comment">//当前位置</span></span><br><span class="line">    Location location = mLocationManager.getCurrentLocation();</span><br><span class="line">    <span class="comment">//设置picture name</span></span><br><span class="line">    String title = CameraUtil.instance().createJpegName(sessionTime);</span><br><span class="line">    <span class="comment">//创建会话</span></span><br><span class="line">    CaptureSession session = getServices().getCaptureSessionManager()</span><br><span class="line">           .createNewSession(title, sessionTime, location);</span><br><span class="line">    <span class="comment">//开启会话</span></span><br><span class="line">    session.startEmpty(<span class="keyword">new</span> CaptureStats(mHdrPlusEnabled),<span class="keyword">new</span> Size(</span><br><span class="line">        (<span class="keyword">int</span>) mPreviewArea.width(), (<span class="keyword">int</span>) mPreviewArea.height()));</span><br><span class="line">    <span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">首先，获取会话的相关参数，包括会话时间，拍照的照片名字以及位置信息等，然后调用Session管理来创建CaptureSession，最后将此CaptureSession启动。到这里，会话就创建并启动了，所以接着分析上面的拍照流程，它会调用OneCameraImpl的takePicture方法来进行拍照：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">(<span class="keyword">final</span> PhotoCaptureParameters params, <span class="keyword">final</span> CaptureSession session)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 除非拍照已经返回，否则就广播一个未准备好状态的广播，即等待本次拍照结束</span></span><br><span class="line">    broadcastReadyState(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//创建一个线程</span></span><br><span class="line">    mTakePictureRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//拍照</span></span><br><span class="line">            takePictureNow(params, session);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//设置回调，此回调后面将分析，它其实就是CaptureModule,它实现了PictureCallback</span></span><br><span class="line">    mLastPictureCallback = params.callback;</span><br><span class="line">    mTakePictureStartMillis = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果需要自动聚焦</span></span><br><span class="line">    <span class="keyword">if</span> (mLastResultAFState == AutoFocusState.ACTIVE_SCAN) &#123;</span><br><span class="line">        mTakePictureWhenLensIsStopped = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//拍照</span></span><br><span class="line">        takePictureNow(params, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在拍照里，首先广播一个未准备好的状态广播，然后进行拍照的回调设置，并且判断是否有自动聚焦，如果是则将mTakePictureWhenLensIsStopped 设为ture，即即刻拍照被停止了，否则则调用OneCameraImpl的takePictureNow方法来发起拍照请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takePictureNow</span><span class="params">(PhotoCaptureParameters params, CaptureSession </span></span></span><br><span class="line"><span class="function"><span class="params">        session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> dt = SystemClock.uptimeMillis() - mTakePictureStartMillis;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造JPEG图片拍照的请求</span></span><br><span class="line">        CaptureRequest.Builder builder = mDevice.createCaptureRequest(</span><br><span class="line">            CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">        builder.setTag(RequestTag.CAPTURE);</span><br><span class="line">        addBaselineCaptureKeysToRequest(builder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enable lens-shading correction for even better DNGs.</span></span><br><span class="line">        <span class="keyword">if</span> (sCaptureImageFormat == ImageFormat.RAW_SENSOR) &#123;</span><br><span class="line">            builder.set(CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE,</span><br><span class="line">                CaptureRequest.STATISTICS_LENS_SHADING_MAP_MODE_ON);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sCaptureImageFormat == ImageFormat.JPEG) &#123;</span><br><span class="line">            builder.set(CaptureRequest.JPEG_QUALITY, JPEG_QUALITY);</span><br><span class="line">                .getJpegRotation(params.orientation, mCharacteristics));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用于preview的控件</span></span><br><span class="line">        builder.addTarget(mPreviewSurface);</span><br><span class="line">        <span class="comment">//用于图片显示的控件</span></span><br><span class="line">        builder.addTarget(mCaptureImageReader.getSurface());</span><br><span class="line">        CaptureRequest request = builder.build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_WRITE_CAPTURE_DATA) &#123;</span><br><span class="line">            <span class="keyword">final</span> String debugDataDir = makeDebugDir(params.debugDataFolder,</span><br><span class="line">                        <span class="string">"normal_capture_debug"</span>);</span><br><span class="line">            Log.i(TAG, <span class="string">"Writing capture data to: "</span> + debugDataDir);</span><br><span class="line">            CaptureDataSerializer.toFile(<span class="string">"Normal Capture"</span>, request, </span><br><span class="line">                <span class="keyword">new</span> File(debugDataDir,<span class="string">"capture.txt"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拍照，mCaptureCallback为回调</span></span><br><span class="line">        mCaptureSession.capture(request, mCaptureCallback, mCameraHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not access camera for still image capture."</span>);</span><br><span class="line">        broadcastReadyState(<span class="keyword">true</span>);</span><br><span class="line">        params.callback.onPictureTakingFailed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mCaptureQueue) &#123;</span><br><span class="line">        mCaptureQueue.add(<span class="keyword">new</span> InFlightCapture(params, session));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与preview类似，都是通过CaptureRequest来与Camera进行通信的，通过session的capture来进行拍照，并设置拍照的回调函数为mCaptureCallback：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/base/core/java/android/hardware/camera2/impl/CameraCaptureSessionImpl.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">capture</span><span class="params">(CaptureRequest request,CaptureCallback callback,Handler handler)</span><span class="keyword">throws</span> CameraAccessException</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    handler = checkHandler(handler,callback);</span><br><span class="line">    <span class="keyword">return</span> addPendingSequence(mDeviceImpl.capture(request,createCaptureCallbackProxy(</span><br><span class="line">        handler,callback),mDeviceHandler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码与preview中的类似，都是将请求加入到待处理的请求集，现在看CaptureCallback回调：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraCaptureSession.CaptureCallback mCaptureCallback = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureStarted</span><span class="params">(CameraCaptureSession session,CaptureRequest request,<span class="keyword">long</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            timestamp,<span class="keyword">long</span> frameNumber)</span></span>&#123;</span><br><span class="line">　　　　　<span class="comment">//与preview类似</span></span><br><span class="line">        <span class="keyword">if</span>(request.getTag() == RequestTag.CAPTURE&amp;&amp;mLastPictureCallback!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            mLastPictureCallback.onQuickExpose();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(CameraCaptureSession session,CaptureRequest request</span></span></span><br><span class="line"><span class="function"><span class="params">            ,TotalCaptureResult result)</span></span>&#123;</span><br><span class="line">        autofocusStateChangeDispatcher(result);</span><br><span class="line">        <span class="keyword">if</span>(result.get(CaptureResult.CONTROL_AF_STATE) == <span class="keyword">null</span>)&#123;</span><br><span class="line">　　　　　　　<span class="comment">//检查自动聚焦的状态</span></span><br><span class="line">            AutoFocusHelper.checkControlAfState(result);</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span>(request.getTag() == RequestTag.CAPTURE)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(mCaptureQueue)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mCaptureQueue.getFirst().setCaptureResult(result).isCaptureComplete())&#123;</span><br><span class="line">                    capture = mCaptureQueue.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(capture != <span class="keyword">null</span>)&#123;</span><br><span class="line">　　　　　　　　　<span class="comment">//拍照结束</span></span><br><span class="line">                OneCameraImpl.<span class="keyword">this</span>.onCaptureCompleted(capture);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.onCaptureCompleted(session,request,result);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是Native层在处理请求时，会调用相应的回调，如capture开始时，会回调onCaptureStarted,具体的在preview中有过分析，当拍照结束时，会回调onCaptureCompleted方法，其中会根据CaptureResult来检查自动聚焦的状态，并通过TAG判断其是Capture动作时，再来看它是否是队列中的第一个请求，如果是，则将请求移除，因为请求已经处理成功，最后再调用OneCameraImpl的onCaptureCompleted方法来进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(InFlightCapture capture)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isCaptureImageFormat == ImageFormat.RAW_SENSOR)&#123;</span><br><span class="line">        ...</span><br><span class="line">        File dngFile = <span class="keyword">new</span> File(RAW_DIRECTORY,capture.session.getTitle()+<span class="string">".dng"</span>);</span><br><span class="line">        writeDngBytesAndClose(capture.image,capture.totalCaptureResult,mCharacteristics,dngFile);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//解析result中的图片数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] imageBytes = acquireJpegBytesAndClose(capture.image);</span><br><span class="line">        <span class="comment">//保存Jpeg图片</span></span><br><span class="line">        saveJpegPicture(imageBytes,capture.parameters,capture.session,capture.totalCaptureResult);</span><br><span class="line">    &#125;</span><br><span class="line">    broadcastReadyState(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//调用回调</span></span><br><span class="line">    capture.parameters.callback.onPictureTaken(capture.session);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，首先，对result中的图片数据进行了解析，然后调用saveJpegPicture方法将解析得到的图片数据进行保存，最后再调用里面的回调(即CaptureModule，前面在初始化Parameters时说明了，它实现了PictureCallbak接口)的onPictureTaken方法，所以，接下来先分析saveJpegPicture方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/OneCameraImpl.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveJpegPicture</span><span class="params">(<span class="keyword">byte</span>[] jpegData,<span class="keyword">final</span> PhotoCaptureParameters captureParams,CaptureSession session,CaptureResult result)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    ListenableFuture&lt;Optional&lt;Uri&gt;&gt; futureUri = session.saveAndFinish(jpegData,width,</span><br><span class="line">            height,rotation,exif);</span><br><span class="line">    Futures.addCallback(futureUri,<span class="keyword">new</span> FutureCallback&lt;Optional&lt;Uri&gt;&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Optional&lt;Uri&gt; uriOptional)</span></span>&#123;</span><br><span class="line">            captureParams.callback.onPictureSaved(mOptional.orNull());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable throwable)</span></span>&#123;</span><br><span class="line">            captureParams.callback.onPictureSaved(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它最后会回调onPictureSaved方法来对图片进行保存，所以需要分析CaptureModule的onPictureSaved方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPictureSaved</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    mAppController.notifyNewMedia(uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mAppController的实现为CameraActivity，所以分析notifyNewMedia方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyNewMedia</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span>(FilmstripItemUtils.isMimeTypeVideo(mimeType))&#123;</span><br><span class="line">　　　　<span class="comment">//如果拍摄的是video</span></span><br><span class="line">        sendBroadcast(<span class="keyword">new</span> Intent(CameraUtil.ACTION_NEW_VIDEO,uri));</span><br><span class="line">        newData = mVideoItemFactory.queryContentUri(uri);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(FilmstripItemUtils.isMimeTypeImage(mimeType))&#123;</span><br><span class="line">　　　　<span class="comment">//如果是拍摄图片</span></span><br><span class="line">        CameraUtil.broadcastNewPicture(mAppContext,uri);</span><br><span class="line">        newData = mPhotoItemFactory.queryCotentUri(uri);</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> AsyncTask&lt;FilmstripItem,Void,FilmstripItem&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> FilmstripItem <span class="title">doInBackground</span><span class="params">(FilmstripItem... Params)</span></span>&#123;</span><br><span class="line">            FilmstripItem data = params[<span class="number">0</span>];</span><br><span class="line">            MetadataLoader.loadMetadata(getAndroidContet(),data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，这里有两种数据的处理，一种是video，另一种是image。而我们这里分析的是capture图片数据，所以首先会根据在回调函数传入的参数Uri和PhotoItemFactory来查询到相应的拍照数据，然后再开启一个异步的Task来对此数据进行处理，即通过MetadataLoader的loadMetadata来加载数据，并返回。至此，capture的流程就基本分析结束了，下面将给出capture流程的整个过程中的时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-07-capture_over_flow.png" alt="Alt text"></p><h4 id="（三）、Camera-System-takepicture-ZSL-流程分析（本小节基于-Android-5-1-API11源码）"><a href="#（三）、Camera-System-takepicture-ZSL-流程分析（本小节基于-Android-5-1-API11源码）" class="headerlink" title="（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）"></a>（三）、Camera System takepicture(ZSL)流程分析（本小节基于 Android 5.1 API11源码）</h4><p>ZSL(zear shutter lag)即零延时，就是在拍照时不停预览就可以拍照.由于有较好的用户体验度，该feature是现在大部分手机都拥有的功能。<br>面不再贴出大量代码来描述过程，直接上图。下图是画了2个小时整理出来的Android5.1 Zsl的基本流程，可以看到与ZSL密切相关的有5个线程frameprocessor、captureSequencer、ZslProcessor3、JpegProcessor、Camera3Device:requestThread。其实还有一个主线程用于更新参数。针对Android5.1看代码所得，ZSL过程中大概分成下面7个流程.</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-08-ZSL_takepicture.png" alt="Alt text"></p><p>更正：图中左上角的FrameProcessor线程起来后会在waitForNextFrame中执行mResultSignal.waitRelative()，图中没有更改过来。</p><h5 id="3-0、注册帧监听对象"><a href="#3-0、注册帧监听对象" class="headerlink" title="3.0、注册帧监听对象"></a>3.0、注册帧监听对象</h5><h5 id="3-0-1、captureSequence线程注册帧监听对象"><a href="#3-0-1、captureSequence线程注册帧监听对象" class="headerlink" title="3.0.1、captureSequence线程注册帧监听对象"></a>3.0.1、captureSequence线程注册帧监听对象</h5><h5 id="3-0-1-1、注册时机"><a href="#3-0-1-1、注册时机" class="headerlink" title="3.0.1.1、注册时机"></a>3.0.1.1、注册时机</h5><p>当上层发出ZSL拍照请求时，底层就会触发拍照捕获状态机，改状态机的基本流程图在上篇笔记中已经整理出来过，这里就不多说了。由于camera2Client与其它处理线程对象基本符合金字塔形的架构，可以看到这里是通过camera2Client的对象将帧可用监听对象注册到FrameProcess对象中的List<rangelistener> mRangeListeners;对象中。</rangelistener></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line">CaptureSequencer::CaptureState CaptureSequencer::manageZslStart(</span><br><span class="line">        sp&lt;Camera2Client&gt; &amp;client) &#123;</span><br><span class="line">    ALOGV(<span class="string">"%s"</span>, __FUNCTION__);</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;ZslProcessorInterface&gt; processor = mZslProcessor.promote();</span><br><span class="line">    <span class="comment">// We don't want to get partial results for ZSL capture.</span></span><br><span class="line">    client-&gt;registerFrameListener(mCaptureId, mCaptureId + <span class="number">1</span>,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*sendPartials*/</span><span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Actually select the right thing here.</span></span><br><span class="line">    res = processor-&gt;pushToReprocess(mCaptureId);</span><br><span class="line">    <span class="comment">//.......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：可以看到在注册帧监听对象时，传入的两个参数是mCaptureId, mCaptureId + 1,为什么会是这样呢,因为这个就是标记我们想抓的是哪一帧,当拍照buffer从hal上来之后,Camera3Device就会回调帧可用监听对象，然后得到拍照帧的时间戳，紧接着根据时间戳从ZSL RingBuffer中找到最理想的inputBuffer，然后下发给hal进行Jpeg编解码。对比下面ZSL线程的CaptureId,应该就理解了.</p><h5 id="3-0-1-2、捕获时机"><a href="#3-0-1-2、捕获时机" class="headerlink" title="3.0.1.2、捕获时机"></a>3.0.1.2、捕获时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="keyword">void</span> CaptureSequencer::onResultAvailable(<span class="keyword">const</span> CaptureResult &amp;result) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s: New result available."</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mNewFrameId = result.mResultExtras.requestId;</span><br><span class="line">    mNewFrame = result.mMetadata;</span><br><span class="line">    <span class="keyword">if</span> (!mNewFrameReceived) &#123;</span><br><span class="line">        mNewFrameReceived = <span class="literal">true</span>;</span><br><span class="line">        .signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面即是拍照状态机注册的回调函数，其中当ZSL拍照帧上来之后，机会激活正在等待中的CaptureSequencer线程，以进行后续的操作。</p><h5 id="3-0-2、ZslProcess3线程注册帧监听对象"><a href="#3-0-2、ZslProcess3线程注册帧监听对象" class="headerlink" title="3.0.2、ZslProcess3线程注册帧监听对象"></a>3.0.2、ZslProcess3线程注册帧监听对象</h5><h5 id="3-0-2-1、注册时机"><a href="#3-0-2-1、注册时机" class="headerlink" title="3.0.2.1、注册时机"></a>3.0.2.1、注册时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ZslProcessor::updateStream(<span class="keyword">const</span> Parameters &amp;params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mZslStreamId == NO_STREAM) &#123;</span><br><span class="line">        <span class="comment">// Create stream for HAL production</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Sort out better way to select resolution for ZSL</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that format specified internally in Camera3ZslStream</span></span><br><span class="line">        res = device-&gt;createZslStream(</span><br><span class="line">                params.fastInfo.arrayWidth, params.fastInfo.arrayHeight,</span><br><span class="line">                mBufferQueueDepth,</span><br><span class="line">                &amp;mZslStreamId,</span><br><span class="line">                &amp;mZslStream);</span><br><span class="line">        <span class="comment">// Only add the camera3 buffer listener when the stream is created.</span></span><br><span class="line">        mZslStream-&gt;addBufferListener(<span class="keyword">this</span>);<span class="comment">//这里是在BufferQueue注册的callback，暂时不用关心。</span></span><br><span class="line">    &#125;</span><br><span class="line">    client-&gt;registerFrameListener(Camera2Client::kPreviewRequestIdStart,</span><br><span class="line">            Camera2Client::kPreviewRequestIdEnd,</span><br><span class="line">            <span class="keyword">this</span>,</span><br><span class="line">            <span class="comment">/*sendPartials*/</span><span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的即为更新zsl流时调用的函数,可以看到其中使用registerFrameListener注册了RingBuffer可用监听对象，这里我们要特别注意的是下面2个宏。这个是专门为预览预留的requestId，考虑这样也会有录像和拍照的requestId,每次更新参数后，这个requestId会有+1操作，没有参数更新，则不会+1，这个可以在各自的Debug手机上发现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/Camera2Client.h]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kPreviewRequestIdStart = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int32_t</span> kPreviewRequestIdEnd   = <span class="number">20000000</span>;</span><br></pre></td></tr></table></figure><h5 id="3-0-2-2、捕获时机"><a href="#3-0-2-2、捕获时机" class="headerlink" title="3.0.2.2、捕获时机"></a>3.0.2.2、捕获时机</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="keyword">void</span> ZslProcessor::onResultAvailable(<span class="keyword">const</span> CaptureResult &amp;result) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s:"</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    <span class="keyword">camera_metadata_ro_entry_t</span> entry;</span><br><span class="line">    entry = result.mMetadata.find(ANDROID_SENSOR_TIMESTAMP);</span><br><span class="line">    <span class="keyword">nsecs_t</span> timestamp = entry.data.i64[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    entry = result.mMetadata.find(ANDROID_REQUEST_FRAME_COUNT);</span><br><span class="line">    <span class="keyword">int32_t</span> frameNumber = entry.data.i32[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Corresponding buffer has been cleared. No need to push into mFrameList</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp &lt;= mLatestClearedBufferTimestamp) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mFrameList.editItemAt(mFrameListHead) = result.mMetadata;</span><br><span class="line">    mFrameListHead = (mFrameListHead + <span class="number">1</span>) % mFrameListDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉错误检查代码，上面由于CaptureID是下面2个，也就是ZSL的所有预览Buffer可用之后都会回调这个方法,当队列满之后，新buffer会覆盖旧buffer位置。上面可以看到mFrameList中会保存每一帧的metadata数据，mFrameListHead用来标识下一次存放数据的位置。</p><h5 id="3-1、查找ZSL拍照最合适的buffer"><a href="#3-1、查找ZSL拍照最合适的buffer" class="headerlink" title="3.1、查找ZSL拍照最合适的buffer"></a>3.1、查找ZSL拍照最合适的buffer</h5><p>一开始我以为是是根据想要抓取那帧的captureId来找到zsl拍照buffer的，但是现在看来就是找时间戳最近的那个buffer来进行jpeg编解码(而且google工程师在源码中注释也是这样说的).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/ZslProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ZslProcessor::pushToReprocess(<span class="keyword">int32_t</span> requestId) &#123;</span><br><span class="line">    ALOGV(<span class="string">"%s: Send in reprocess request with id %d"</span>,</span><br><span class="line">            __FUNCTION__, requestId);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;Camera2Client&gt; client = mClient.promote();</span><br><span class="line">    <span class="comment">//下面是就是在mFrameList查找时间戳最近的帧。</span></span><br><span class="line">    <span class="keyword">size_t</span> metadataIdx;</span><br><span class="line">    <span class="keyword">nsecs_t</span> candidateTimestamp = getCandidateTimestampLocked(&amp;metadataIdx);</span><br><span class="line">   <span class="comment">//根据上一次查找的时间戳，从ZSL BufferQueue中查找时间最接近的Buffer，并将</span></span><br><span class="line">   <span class="comment">//buffer保存到mInputBufferQueue队列中。</span></span><br><span class="line">    res = mZslStream-&gt;enqueueInputBufferByTimestamp(candidateTimestamp,</span><br><span class="line">                                                    <span class="comment">/*actualTimestamp*/</span><span class="literal">NULL</span>);</span><br><span class="line">   <span class="comment">//-----------------</span></span><br><span class="line">    &#123;<span class="comment">//获取zsl 编解码的metadataId，稍后会传入给hal编解码。</span></span><br><span class="line">        CameraMetadata request = mFrameList[metadataIdx];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that the frame is reasonable for reprocessing</span></span><br><span class="line">        <span class="keyword">camera_metadata_entry_t</span> entry;</span><br><span class="line">        entry = request.find(ANDROID_CONTROL_AE_STATE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.data.u8[<span class="number">0</span>] != ANDROID_CONTROL_AE_STATE_CONVERGED &amp;&amp;</span><br><span class="line">                entry.data.u8[<span class="number">0</span>] != ANDROID_CONTROL_AE_STATE_LOCKED) &#123;</span><br><span class="line">            ALOGV(<span class="string">"%s: ZSL queue frame AE state is %d, need full capture"</span>,</span><br><span class="line">                    __FUNCTION__, entry.data.u8[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> NOT_ENOUGH_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//这中间会更新输入stream的流ID、更新捕获意图为静态拍照、判断这一帧是否AE稳定、</span></span><br><span class="line">       <span class="comment">//获取jpegStreamID并更新到metadata中、更新请求ID，最后根据更新后的request metadata</span></span><br><span class="line">       <span class="comment">//更新jpeg metadata。最后一步启动Camera3Device抓取图片。</span></span><br><span class="line">        <span class="comment">// Update post-processing settings</span></span><br><span class="line">        res = updateRequestWithDefaultStillRequest(request);</span><br><span class="line">        mLatestCapturedRequest = request;</span><br><span class="line">        res = client-&gt;getCameraDevice()-&gt;capture(request);</span><br><span class="line">        mState = LOCKED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 还记得在启动状态机器时，注册的帧监听对象吧。这里参数requestId就是我们想要抓拍的图片的请求ID,目前发现该请求ID后面会更新到metadata中。这里只要知道该函数功能就可以了。</p><p>☯ 1、从mFrameList中查找时间戳最小的metadata。<br>☯ 2、根据从第一步获取到时间戳，从ZSL BufferQueue选择时间最接近Buffer.<br>☯3、将Buffer放到mInputBufferQueue中，更新jpeg编解码metadata，启动Capture功能。</p><h5 id="3-2、设置zsl-input-buffer和-jpeg-out-buffer"><a href="#3-2、设置zsl-input-buffer和-jpeg-out-buffer" class="headerlink" title="3.2、设置zsl input buffer和 jpeg out buffer"></a>3.2、设置zsl input buffer和 jpeg out buffer</h5><p>  其实这一步之前已经讨论过，inputBuffer是ZslProcess3线程查找到最合适的用于jpeg编解码的buffer。outputBuffer为JpegProcessor线程更新的buffer用于存放hal编解码之后的jpeg图片。其中准备jpeg OutBuffer的操作就是在下面操作的。可以看到将outputStream的ID，保存到metadata中了。这样就会在Camera3Device中根据这项metadata来添加outputBuffer到hal。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> ZslProcessor::pushToReprocess(<span class="keyword">int32_t</span> requestId) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Shouldn't we also update the latest preview frame?</span></span><br><span class="line">        <span class="keyword">int32_t</span> outputStreams[<span class="number">1</span>] =</span><br><span class="line">                &#123; client-&gt;getCaptureStreamId() &#125;;</span><br><span class="line">        res = request.update(ANDROID_REQUEST_OUTPUT_STREAMS,</span><br><span class="line">                outputStreams, <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="3-3、归还jpeg-Buffer干了什么"><a href="#3-3、归还jpeg-Buffer干了什么" class="headerlink" title="3.3、归还jpeg Buffer干了什么."></a>3.3、归还jpeg Buffer干了什么.</h5><p>  当framework将ZSL inputBuffer和jpeg outputBuffer,传给hal后，hal就会启动STLL_CAPTURE流程，将inputBuffer中的图像数据，进行一系列的后处理流程。当后处理完成后，hal则会将临时Buffer拷贝到outPutBuffer中(注意：这里要记得做flush操作，即刷新Buffer,要不然图片有可能会出现绿条).<br>  因为JpegBuffer也是从BufferQueue Dequeue出来的buffer,而且在创建BufferQueue时，也注册了帧监听对象(即：onFrameAvailable()回调).这样的话当帧可用(即：进行了enqueue操作），就会回调onFrameAvailable()方法，这样当hal归还jpegBuffer时就是要进行enqueue()操作。在onFrameAvailable()方法中，会激活jpegproces线程，进行后续的处理，最后激活captureSequeue拍照状态机线程。</p><h5 id="3-4、保存ZSLBuffer"><a href="#3-4、保存ZSLBuffer" class="headerlink" title="3.4、保存ZSLBuffer."></a>3.4、保存ZSLBuffer.</h5><p>  这里由于ZSL Buffer一直会从hal上来，所以当zslBuffer上来后，就会激活FrameProcesor线程保存这一ZslBuffer，目前FrameWork那边默认是4个buffer，这样的话当队列满之后，就会覆盖之前最老的buffer,如此反复操作。</p><h5 id="3-5、获取拍照jpeg-Buffer"><a href="#3-5、获取拍照jpeg-Buffer" class="headerlink" title="3.5、获取拍照jpeg Buffer"></a>3.5、获取拍照jpeg Buffer</h5><p>  当hal上来jpeg帧后，就会激活jpegProcess线程,并从BufferQueue中拿到jpegbuffer，下面可以发现进行lockNextBuffer,unlockBuffer操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/JpegProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> JpegProcessor::processNewCapture() &#123;</span><br><span class="line">    res = mCaptureConsumer-&gt;lockNextBuffer(&amp;imgBuffer);</span><br><span class="line">    mCaptureConsumer-&gt;unlockBuffer(imgBuffer);</span><br><span class="line">    sp&lt;CaptureSequencer&gt; sequencer = mSequencer.promote();</span><br><span class="line">   <span class="comment">//...... </span></span><br><span class="line">    <span class="keyword">if</span> (sequencer != <span class="number">0</span>) &#123;</span><br><span class="line">        sequencer-&gt;onCaptureAvailable(imgBuffer.timestamp, captureBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以发现最后回调了captureSequencer线程的onCaptureAvailable()回调方法。该回调方法主要作用就是将时间戳和jpeg buffer的传送到CaptureSequencer线程中,然后激活CaptureSequencer线程。最后将Buffer CallBack到应用层。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="keyword">void</span> CaptureSequencer::onCaptureAvailable(<span class="keyword">nsecs_t</span> timestamp,</span><br><span class="line">        sp&lt;MemoryBase&gt; captureBuffer) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s"</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mCaptureTimestamp = timestamp;</span><br><span class="line">    mCaptureBuffer = captureBuffer;</span><br><span class="line">    <span class="keyword">if</span> (!mNewCaptureReceived) &#123;</span><br><span class="line">        mNewCaptureReceived = <span class="literal">true</span>;</span><br><span class="line">        mNewCaptureSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6、拍照帧可用回调"><a href="#3-6、拍照帧可用回调" class="headerlink" title="3.6、拍照帧可用回调"></a>3.6、拍照帧可用回调</h5><p>当拍照帧回到Framework后，就会回调CaptureSequencer的onResultAvailable()接口，用于设置captureSequencer状态机的标志位和条件激活,如下代码所示。条件变量和标志位的使用可以在状态机方法manageStandardCaptureWait()看到使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line"><span class="keyword">void</span> CaptureSequencer::onResultAvailable(<span class="keyword">const</span> CaptureResult &amp;result) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    ALOGV(<span class="string">"%s: New result available."</span>, __FUNCTION__);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mInputMutex)</span></span>;</span><br><span class="line">    mNewFrameId = result.mResultExtras.requestId;</span><br><span class="line">    mNewFrame = result.mMetadata;</span><br><span class="line">    <span class="keyword">if</span> (!mNewFrameReceived) &#123;</span><br><span class="line">        mNewFrameReceived = <span class="literal">true</span>;</span><br><span class="line">        mNewFrameSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-7、jpeg-buffer回调到app"><a href="#3-7、jpeg-buffer回调到app" class="headerlink" title="3.7、jpeg buffer回调到app"></a>3.7、jpeg buffer回调到app</h5><p>该callback是应用注册过来的一个代理对象，下面就是通过binder进程间调用将jpeg Buffer传送到APP端，注意这里的msgTyep = CAMERA_MSG_COMPRESSED_IMAGE,就是告诉上层这是一个压缩的图像数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/CaptureSequencer.cpp]</span><br><span class="line">CaptureSequencer::CaptureState CaptureSequencer::manageDone(sp&lt;Camera2Client&gt; &amp;client) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res = OK;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    mCaptureId++;</span><br><span class="line">        ......</span><br><span class="line">            Camera2Client::SharedCameraCallbacks::Lock</span><br><span class="line">            l(client-&gt;mSharedCameraCallbacks);</span><br><span class="line">        ALOGV(<span class="string">"%s: Sending still image to client"</span>, __FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (l.mRemoteCallback != <span class="number">0</span>) &#123;</span><br><span class="line">            l.mRemoteCallback-&gt;dataCallback(CAMERA_MSG_COMPRESSED_IMAGE,</span><br><span class="line">                    mCaptureBuffer, <span class="literal">NULL</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGV(<span class="string">"%s: No client!"</span>, __FUNCTION__);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、Camera-System-Recorder流程分析"><a href="#（四）、Camera-System-Recorder流程分析" class="headerlink" title="（四）、Camera System Recorder流程分析"></a>（四）、Camera System Recorder流程分析</h4><p>camera Video.虽然标题是recording流程分析，但这里很多和preview是相似的(包含更新，创建Stream,创建Request)，这里主要分析MediaRecorder对象创建、video帧监听对象注册、帧可用事件以及一系列callback流程分析。</p><h5 id="4-1、认识video-mediaRecorder-状态机"><a href="#4-1、认识video-mediaRecorder-状态机" class="headerlink" title="4.1、认识video(mediaRecorder)状态机"></a>4.1、认识video(mediaRecorder)状态机</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-09-mediaRecorder-status.png" alt="Alt text"></p><blockquote><p>Used to record audio and video. The recording control is based on a<br>simple state machine (see below).状态机请看上面源码中给的流程图。<br>A common case of using MediaRecorder to record audio works as follows:<br>1.MediaRecorder recorder = new MediaRecorder();<br>2.recorder.setAudioSource(MediaRecorder.AudioSource.MIC);<br>3.recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);<br>4.recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);<br>5.recorder.setOutputFile(PATH_NAME);<br>6.recorder.prepare();<br>7.recorder.start(); // Recording is now started<br>8….<br>9.recorder.stop();<br>10.recorder.reset(); // You can reuse the object by going back to setAudioSource() step<br>recorder.release(); // Now the object cannot be reused<br>  Applications may want to register for informational and error<br>events in order to be informed of some internal update and possible<br>runtime errors during recording. Registration for such events is<br>done by setting the appropriate listeners (via calls<br>(to {@link #setOnInfoListener(OnInfoListener)}setOnInfoListener and/or<br>{@link #setOnErrorListener(OnErrorListener)}setOnErrorListener).<br>In order to receive the respective callback associated with these listeners,<br>applications are required to create MediaRecorder objects on threads with a<br>Looper running (the main UI thread by default already has a Looper running).</p></blockquote><p>上面是googole工程师加的注释，最权威的资料。大概意思就是说“使用mediaRecorder记录音视频，需要一个简单的状态机来控制”。上面的1,2,3…就是在操作时需要准守的步骤。算了吧，翻译水平有限，重点还是放到camera这边吧。</p><h5 id="4-2、Camera-app如何启动录像"><a href="#4-2、Camera-app如何启动录像" class="headerlink" title="4.2、Camera app如何启动录像"></a>4.2、Camera app如何启动录像</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码路径:pdk/apps/TestingCamera/src/com/android/testingcamera/TestingCamera.java</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecording</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log(<span class="string">"Starting recording"</span>);</span><br><span class="line">        logIndent(<span class="number">1</span>);</span><br><span class="line">        log(<span class="string">"Configuring MediaRecoder"</span>);</span><br><span class="line">        <span class="comment">//这里会检查是否打开了录像功能。这里我们省略了，直接不如正题</span></span><br><span class="line"><span class="comment">//上面首先创建了一个MediaRecorder的java对象(注意这里同camera.java类似，java对象中肯定包含了一个mediaRecorder jni本地对象，继续往下看)</span></span><br><span class="line">        mRecorder = <span class="keyword">new</span> MediaRecorder();</span><br><span class="line">        <span class="comment">//下面就是设置一些callback.</span></span><br><span class="line">        mRecorder.setOnErrorListener(mRecordingErrorListener);</span><br><span class="line">        mRecorder.setOnInfoListener(mRecordingInfoListener);</span><br><span class="line">        <span class="keyword">if</span> (!mRecordHandoffCheckBox.isChecked()) &#123;</span><br><span class="line">    <span class="comment">//将当前camera java对象设置给了mediaRecorder java对象。</span></span><br><span class="line">    <span class="comment">//这里setCamera是jni接口，后面我们贴代码在分析。</span></span><br><span class="line">            mRecorder.setCamera(mCamera);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将preview surface java对象设置给mediaRecorder java对象，后面贴代码</span></span><br><span class="line">    <span class="comment">//详细说明。</span></span><br><span class="line">        mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());</span><br><span class="line">　　　　<span class="comment">//下面２个是设置音频和视频的资源。</span></span><br><span class="line">        mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">        mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line">        mRecorder.setProfile(mCamcorderProfiles.get(mCamcorderProfile));</span><br><span class="line">        <span class="comment">//从app控件选择录像帧大小，并设置给mediaRecorder</span></span><br><span class="line">        Camera.Size videoRecordSize = mVideoRecordSizes.get(mVideoRecordSize);</span><br><span class="line">        <span class="keyword">if</span> (videoRecordSize.width &gt; <span class="number">0</span> &amp;&amp; videoRecordSize.height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从app控件选择录像帧率，并设置给mediaRecorder.</span></span><br><span class="line">        <span class="keyword">if</span> (mVideoFrameRates.get(mVideoFrameRate) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mRecorder.setVideoFrameRate(mVideoFrameRates.get(mVideoFrameRate));</span><br><span class="line">        &#125;</span><br><span class="line">        File outputFile = getOutputMediaFile(MEDIA_TYPE_VIDEO);</span><br><span class="line">        log(<span class="string">"File name:"</span> + outputFile.toString());</span><br><span class="line">        mRecorder.setOutputFile(outputFile.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">        log(<span class="string">"Preparing MediaRecorder"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//准备一下，请看下面google给的使用mediaRecorder标准流程</span></span><br><span class="line">            mRecorder.prepare();</span><br><span class="line">            ready = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//------异常处理省略</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ready) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log(<span class="string">"Starting MediaRecorder"</span>);</span><br><span class="line">                mRecorder.start();<span class="comment">//启动录像</span></span><br><span class="line">                mState = CAMERA_RECORD;</span><br><span class="line">                log(<span class="string">"Recording active"</span>);</span><br><span class="line">                mRecordingFile = outputFile;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;<span class="comment">//-----异常处理省略</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//------------</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到应用启动录像功能是是符合状态机流程的。在应用开发中，也要这样来做。</p><p>☯ 1.创建mediaRecorderjava对象，mRecorder = new MediaRecorder();<br>☯ 2.设置camera java对象到mediaRecorder中，mRecorder.setCamera(mCamera);<br>☯ 3.将preview surface对象设置给mediaRecorder,mRecorder.setPreviewDisplay(mPreviewHolder.getSurface());<br>☯ 4.设置音频源，mRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);<br>☯ 5.设置视频源，mRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);<br>☯ 6.设置录像帧大小和帧率，以及setOutputFile<br>☯ 8.准备工作，mRecorder.prepare();<br>☯ 9.启动mdiaRecorder,mRecorder.start();</p><h5 id="4-3、与MediaPlayerService相关的类接口之间的关系简介"><a href="#4-3、与MediaPlayerService相关的类接口之间的关系简介" class="headerlink" title="4.3、与MediaPlayerService相关的类接口之间的关系简介"></a>4.3、与MediaPlayerService相关的类接口之间的关系简介</h5><h5 id="4-3-1、mediaRecorder何时与MediaPlayerService发送关系"><a href="#4-3-1、mediaRecorder何时与MediaPlayerService发送关系" class="headerlink" title="4.3.1、mediaRecorder何时与MediaPlayerService发送关系"></a>4.3.1、mediaRecorder何时与MediaPlayerService发送关系</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-10-MediaRecorder.png" alt="Alt text"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/frameworks/base/media/java/android/media/MediaRecorder.java</span><br><span class="line">MediaRecorder::MediaRecorder() : mSurfaceMediaSource(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"constructor"</span>);</span><br><span class="line">    <span class="keyword">const</span> sp&lt;IMediaPlayerService&gt;&amp; service(getMediaPlayerService());</span><br><span class="line">    <span class="keyword">if</span> (service != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaRecorder = service-&gt;createMediaRecorder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mMediaRecorder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mCurrentState = MEDIA_RECORDER_IDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    doCleanUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在jni中创建mediaRecorder对象时，其实在构造函数中偷偷的链接了mediaPlayerService，这也是Android习惯用的方法。获取到MediaPlayerService代理对象后，通过匿名binder获取mediaRecorder代理对象。 </p><h5 id="4-3-2、mediaPlayerService类和接口之间关系"><a href="#4-3-2、mediaPlayerService类和接口之间关系" class="headerlink" title="4.3.2、mediaPlayerService类和接口之间关系"></a>4.3.2、mediaPlayerService类和接口之间关系</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-11-mediaPlayerService.png" alt="Alt text"></p><table><thead><tr><th style="text-align:left">接口类型</th><th>接口说明</th></tr></thead><tbody><tr><td style="text-align:left">virtual sp createMediaRecorder() = 0;</td><td>创建mediaRecorder录视频服务对象的接口</td></tr><tr><td style="text-align:left">virtual sp create(const sp&amp; client, int　audioSessionId = 0) = 0;</td><td>创建mediaPlayer播放音乐服务对象的接口，播放音乐都是通过mediaPlayer对象播放的</td></tr><tr><td style="text-align:left">virtual status_t decode() = 0;</td><td>音频解码器</td></tr></tbody></table><h5 id="4-3-3、MediaRecorder类和接口之间关系"><a href="#4-3-3、MediaRecorder类和接口之间关系" class="headerlink" title="4.3.3、MediaRecorder类和接口之间关系"></a>4.3.3、MediaRecorder类和接口之间关系</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-12-IMediaRecorder.png" alt="Alt text"></p><p>mediaRecorder功能就是来录像的。其中MediaRecorder类中，包含了BpMediaRecorder代理对象引用。MediaRecorderClient本地对象驻留在mediaPlayService中。它的接口比较多，这里就列出我们今天关注的几个接口。其它接口查看源码吧<br>详细介绍可以参考源码：frameworks/av/include/media/IMediaRecorder.h<br>| 接口类型 |     接口说明|<br>| :——– |: ——–|<br>| virtual status_t setCamera(const sp&amp; camera,const sp&amp; proxy) = 0;        |   这个接口也是非常需要我们关注的，这里获取到了启动录像操作的本地对象(BnCameraRecordingProxy），并通过匿名binder通信方式，第二个参数就是本地对象.然后在startRecording时将帧监听对象注册到camera本地对象中了|<br>| virtual status_t setPreviewSurface(const sp&amp; surface) = 0;            |   将preview预览surface对象设置给medaiRecorder，因为mediaRecorder也有一个camera本地client,所以这个surface对象最终还是会设置到cameraService用于显示。而录像的帧会在CameraService本地创建一个bufferQueue，具体下面会详细说明|<br>| virtual status_t setListener(const sp&amp; listener) = 0;        |   这里一看就是设置监听对象，监听对象是jni中的JNIMediaRecorderListener对象，该对象可以回调MediaRecorder.java类中的postEventFromNative方法，将时间送到java层。其实MediaRecorder实现了BnMediaRecorderClient接口，即实现notify接口，那么这里其实将本地对象传到MediaRecorder本地的客户端对象中（本地对象拿到的就是代理对象了），参考代码片段1|<br>| virtual status_t start() = 0;        |   启动录像功能，函数追究下去和Camera关系不大了，这里就不细说了|  </p><h5 id="4-3-3-1、代码片段1"><a href="#4-3-3-1、代码片段1" class="headerlink" title="4.3.3.1、代码片段1"></a>4.3.3.1、代码片段1</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">源码路径：frameworks/base/media/jni/android_media_MediaRecorder.cpp</span><br><span class="line"><span class="comment">// create new listener and give it to MediaRecorder</span></span><br><span class="line">sp&lt;JNIMediaRecorderListener&gt; listener = <span class="keyword">new</span> JNIMediaRecorderListener(env, thiz, weak_this);</span><br><span class="line">mr-&gt;setListener(listener);</span><br></pre></td></tr></table></figure><p>mediaRecorder jni接口回调java方法，通知上层native事件。</p><h5 id="4-3-3-2、代码片段2"><a href="#4-3-3-2、代码片段2" class="headerlink" title="4.3.3.2、代码片段2"></a>4.3.3.2、代码片段2</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaRecorder.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaRecorder_setCamera</span><span class="params">(JNIEnv* env, jobject thiz, jobject camera)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// we should not pass a null camera to get_native_camera() call.</span></span><br><span class="line"><span class="comment">//这里检查camera是不是空的，显然不是空的。</span></span><br><span class="line">    <span class="comment">//这个地方需要好好研究一下，其中camera是java层的camera对象(即camera.java)</span></span><br><span class="line">    <span class="comment">//这里由java对象获取到camera应用端本地对象。</span></span><br><span class="line">    sp&lt;Camera&gt; c = get_native_camera(env, camera, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// get_native_camera will throw an exception in this case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取mediaRecorder本地对象</span></span><br><span class="line">    sp&lt;MediaRecorder&gt; mr = getMediaRecorder(env, thiz);</span><br><span class="line">    <span class="comment">//下面要特别注意，这里为什么传入的不是Camera对象而是c-&gt;remote()，当时琢磨</span></span><br><span class="line">    <span class="comment">//着，camera.cpp也没实现什么代理类的接口啊，不过后来在cameraBase类中发现</span></span><br><span class="line">    <span class="comment">//重载了remote()方法，该方法返回ICamera代理对象，呵呵。这样的话就会在</span></span><br><span class="line">    <span class="comment">//mediaRecorder中创建一个新的ICamera代理对象。并在mediaPlayerService中</span></span><br><span class="line">    <span class="comment">//创建了一个本地的Camera对象。</span></span><br><span class="line">    <span class="comment">//c-&gt;getRecordingProxy():获取camera本地对象实现的Recording本地对象。这里</span></span><br><span class="line">    <span class="comment">//调用setCamera设置到mediaRecorder本地对象中了(见代码片段３)</span></span><br><span class="line">   process_media_recorder_call(env, mr-&gt;setCamera(c-&gt;remote(), c-&gt;getRecordingProxy()),</span><br><span class="line">            <span class="string">"java/lang/RuntimeException"</span>, <span class="string">"setCamera failed."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//camera端</span></span><br><span class="line">sp&lt;ICameraRecordingProxy&gt; Camera::getRecordingProxy() &#123;</span><br><span class="line">    ALOGV(<span class="string">"getProxy"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecordingProxy(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//看看下面RecordingProxy实现了BnCameraRecordingProxy接口，</span></span><br><span class="line"><span class="comment">//是个本地对象，水落石出了。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordingProxy</span> :</span> <span class="keyword">public</span> BnCameraRecordingProxy</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        RecordingProxy(<span class="keyword">const</span> sp&lt;Camera&gt;&amp; camera);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ICameraRecordingProxy interface</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> status_t <span class="title">startRecording</span><span class="params">(<span class="keyword">const</span> sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">stopRecording</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">releaseRecordingFrame</span><span class="params">(<span class="keyword">const</span> sp&lt;IMemory&gt;&amp; mem)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//这里的是mCamera已经不再是之前preview启动时对应的那个本地Camera对象</span></span><br><span class="line">    <span class="comment">//这是mediaRecorder重新创建的camera本地对象。</span></span><br><span class="line">        sp&lt;Camera&gt;         mCamera;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h5 id="4-3-3-3、代码片段3-setCamera本地实现"><a href="#4-3-3-3、代码片段3-setCamera本地实现" class="headerlink" title="4.3.3.3、代码片段3-setCamera本地实现"></a>4.3.3.3、代码片段3-setCamera本地实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaRecorderClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaRecorderClient::setCamera(<span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera,</span><br><span class="line">                                        <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setCamera"</span>);</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecorder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"recorder is not initialized"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mRecorder-&gt;setCamera(camera, proxy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数中可以看到创建了一个StagefrightRecorder对象，后续的其它操作</span></span><br><span class="line"><span class="comment">//都是通过mRecorder对象实现的</span></span><br><span class="line">MediaRecorderClient::MediaRecorderClient(<span class="keyword">const</span> sp&lt;MediaPlayerService&gt;&amp; service, <span class="keyword">pid_t</span> pid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"Client constructor"</span>);</span><br><span class="line">    mPid = pid;</span><br><span class="line">    mRecorder = <span class="keyword">new</span> StagefrightRecorder;</span><br><span class="line">    mMediaPlayerService = service;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//StagefrightRecorder::setCamera实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StagefrightRecorder</span> :</span> <span class="keyword">public</span> MediaRecorderBase &#123;&#125;</span><br><span class="line"><span class="keyword">status_t</span> StagefrightRecorder::setCamera(<span class="keyword">const</span> sp&lt;ICamera&gt; &amp;camera,</span><br><span class="line">                                        <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt; &amp;proxy) &#123;</span><br><span class="line"><span class="comment">//省去一些错误检查代码</span></span><br><span class="line">    mCamera = camera;</span><br><span class="line">    mCameraProxy = proxy;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终ICamera,ICameraRecordingProxy代理对象都存放到StagefrightRecorder对应的成员变量中，看来猪脚就在这个类中。</p><h5 id="4-3-3-4、代码片段4"><a href="#4-3-3-4、代码片段4" class="headerlink" title="4.3.3.4、代码片段4"></a>4.3.3.4、代码片段4</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraSource::isCameraAvailable(</span><br><span class="line">    <span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera, <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy,</span><br><span class="line">    <span class="keyword">int32_t</span> cameraId, <span class="keyword">const</span> String16&amp; clientName, <span class="keyword">uid_t</span> clientUid) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (camera == <span class="number">0</span>) &#123;</span><br><span class="line">        mCamera = Camera::connect(cameraId, clientName, clientUid);</span><br><span class="line">        <span class="keyword">if</span> (mCamera == <span class="number">0</span>) <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        mCameraFlags &amp;= ~FLAGS_HOT_CAMERA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We get the proxy from Camera, not ICamera. We need to get the proxy</span></span><br><span class="line">        <span class="comment">// to the remote Camera owned by the application. Here mCamera is a</span></span><br><span class="line">        <span class="comment">// local Camera object created by us. We cannot use the proxy from</span></span><br><span class="line">        <span class="comment">// mCamera here.</span></span><br><span class="line">        <span class="comment">//根据ICamera代理对象重新创建Camera本地对象</span></span><br><span class="line">        mCamera = Camera::create(camera);</span><br><span class="line">        <span class="keyword">if</span> (mCamera == <span class="number">0</span>) <span class="keyword">return</span> -EBUSY;</span><br><span class="line">        mCameraRecordingProxy = proxy;</span><br><span class="line">        <span class="comment">//目前还不清楚是什么标记，权且理解成支持热插拔标记</span></span><br><span class="line">        mCameraFlags |= FLAGS_HOT_CAMERA;</span><br><span class="line">        <span class="comment">//代理对象绑定死亡通知对象</span></span><br><span class="line">        mDeathNotifier = <span class="keyword">new</span> DeathNotifier();</span><br><span class="line">        <span class="comment">// isBinderAlive needs linkToDeath to work.</span></span><br><span class="line">        mCameraRecordingProxy-&gt;asBinder()-&gt;linkToDeath(mDeathNotifier);</span><br><span class="line">    &#125;</span><br><span class="line">    mCamera-&gt;lock();</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　由上面的类图之间的关系的，就知道mediaRecorder间接包含了cameaSource对象，这里为了简单直接要害代码。</p><p>☯ 1.在创建CameraSource对象时，会去检查一下Camera对象是否可用，可用的话就会根据传进来的代理对象重新创建Camera本地对象（注意这个时候Camera代理对象在mediaRecorder中）<br>☯ 2.然后保存RecordingProxy代理对象到mCameraRecordingProxy成员中，然后绑定死亡通知对象到RecordingProxy代理对象。</p><h5 id="4-3-3-5、代码片段5"><a href="#4-3-3-5、代码片段5" class="headerlink" title="4.3.3.5、代码片段5"></a>4.3.3.5、代码片段5</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libstagefright/CameraSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraSource::startCameraRecording() &#123;</span><br><span class="line">    ALOGV(<span class="string">"startCameraRecording"</span>);</span><br><span class="line">    <span class="comment">// Reset the identity to the current thread because media server owns the</span></span><br><span class="line">    <span class="comment">// camera and recording is started by the applications. The applications</span></span><br><span class="line">    <span class="comment">// will connect to the camera in ICameraRecordingProxy::startRecording.</span></span><br><span class="line">    <span class="keyword">int64_t</span> token = IPCThreadState::self()-&gt;clearCallingIdentity();</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNumInputBuffers &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        err = mCamera-&gt;sendCommand(</span><br><span class="line">            CAMERA_CMD_SET_VIDEO_BUFFER_COUNT, mNumInputBuffers, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = OK;</span><br><span class="line">    <span class="keyword">if</span> (mCameraFlags &amp; FLAGS_HOT_CAMERA) &#123;<span class="comment">//前面已经置位FLAGS_HOT_CAMERA，成立</span></span><br><span class="line">        mCamera-&gt;unlock();</span><br><span class="line">        mCamera.clear();</span><br><span class="line">        <span class="comment">//通过recording代理对象，直接启动camera本地端的recording</span></span><br><span class="line">        <span class="keyword">if</span> ((err = mCameraRecordingProxy-&gt;startRecording(</span><br><span class="line">                <span class="keyword">new</span> ProxyListener(<span class="keyword">this</span>))) != OK) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    IPCThreadState::self()-&gt;restoreCallingIdentity(token);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码需要我们注意的是在启动startRecording()时，创建的监听对象new ProxyListener(this),该监听对象会传到Camera本地对象中。当帧可用时，用来通知mediaRecorder有帧可以使用了，赶紧编码吧。</p><h5 id="4-3-3-6、代码片段6-mediaRecorder注册帧可用监听对象"><a href="#4-3-3-6、代码片段6-mediaRecorder注册帧可用监听对象" class="headerlink" title="4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象"></a>4.3.3.6、代码片段6-mediaRecorder注册帧可用监听对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/include/media/stagefright/CameraSource.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyListener</span>:</span> <span class="keyword">public</span> BnCameraRecordingProxyListener &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ProxyListener(<span class="keyword">const</span> sp&lt;CameraSource&gt;&amp; source);</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dataCallbackTimestamp</span><span class="params">(<span class="keyword">int64_t</span> timestampUs, <span class="keyword">int32_t</span> msgType,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">const</span> sp&lt;IMemory&gt; &amp;data)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        sp&lt;CameraSource&gt; mSource;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//frameworks/av/camera/Camera.cpp</span></span><br><span class="line"><span class="keyword">status_t</span> Camera::RecordingProxy::startRecording(<span class="keyword">const</span> sp&lt;ICameraRecordingProxyListener&gt;&amp; listener)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"RecordingProxy::startRecording"</span>);</span><br><span class="line">    mCamera-&gt;setRecordingProxyListener(listener);</span><br><span class="line">    mCamera-&gt;reconnect();</span><br><span class="line">    <span class="keyword">return</span> mCamera-&gt;startRecording();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册帧监听对象就是在启动Recording时注册，主要有下面几步：</p><p>☯ 1.使用setRecordingProxyListener接口，将监听对象设置给mRecordingProxyListener 成员。<br>☯ 2.重新和cameraService握手(preview停止时就会断开链接，在切换瞬间就断开了)<br>☯ 3.使用ICamera代理对象启动录像。</p><h5 id="4-4、阶段小结"><a href="#4-4、阶段小结" class="headerlink" title="4.4、阶段小结"></a>4.4、阶段小结</h5><p>到这里Camera如何使用medaiRecorder录像的基本流程已经清楚了，这里我画了一个流程图，大概包含下面9个流程。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/02-13-medaiRecorder-java-native.png" alt="Alt text"></p><p>☯ 过程1：上层点击了录像功能，或者录像preview模式下，会创建一个mediaRecorDer Java层对象。<br>☯ 过程2:java层mediaRecorder对象调用native_jni native_setup方法，创建一个native的mediaRecorder对象。创建的过程中连接mediaPlayerService,并通过匿名binder通信方式获取到一个mediaRecorderClient代理对象，并保存到mediaRecorder对象的成员变量mMediaRecorder中。<br>☯ 过程3:ava层的Camera对象传给mediaRecorder native层时，可以通过本地方法获取到Camera本地对象和ICamera代理对象。这里是获取ICamera代理对象和RecordingProxy本地对象<br>☯ 过程4:将ICamera代理对象和RecordingProxy本地对象传给在MedaiService本地端的MediaRecorderClient对象，这时ICamera是重新创建的ICamer代理对象，以及获取到RecordingProxy代理对象。<br>☯ 过程5：根据过程４获取到的新的ICamera代理对象和RecordingProxy代理对象，创建新的本地Camera对象Camera2，以及注册录像帧监听对象到Camera2中。<br>☯ 过程6：启动StartRecording<br>☯ 过程7:当录像帧可用时，通知驻留在MedaiRecorderClient中的Camera2本地对象收帧，于此同时Camera2又是通过注册的帧监听对象告知MediaClientClient对象。MediaClientClient对象拿到帧后进行录像编码。<br>☯ 过程8,过程９：通过回调函数，将一些消息发送给应用端。</p><h5 id="4-5、Camera-video创建BufferQueue"><a href="#4-5、Camera-video创建BufferQueue" class="headerlink" title="4.5、Camera video创建BufferQueue."></a>4.5、Camera video创建BufferQueue.</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> StreamingProcessor::updateRecordingStream(<span class="keyword">const</span> Parameters &amp;params) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">m</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    sp&lt;CameraDeviceBase&gt; device = mDevice.promote();</span><br><span class="line">    <span class="comment">//----------------</span></span><br><span class="line">    <span class="keyword">bool</span> newConsumer = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mRecordingConsumer == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"%s: Camera %d: Creating recording consumer with %zu + 1 "</span></span><br><span class="line">                <span class="string">"consumer-side buffers"</span>, __FUNCTION__, mId, mRecordingHeapCount);</span><br><span class="line">        <span class="comment">// Create CPU buffer queue endpoint. We need one more buffer here so that we can</span></span><br><span class="line">        <span class="comment">// always acquire and free a buffer when the heap is full; otherwise the consumer</span></span><br><span class="line">        <span class="comment">// will have buffers in flight we'll never clear out.</span></span><br><span class="line">        sp&lt;IGraphicBufferProducer&gt; producer;</span><br><span class="line">        sp&lt;IGraphicBufferConsumer&gt; consumer;</span><br><span class="line">        <span class="comment">//创建bufferQueue，同时获取到生产者和消费者对象。</span></span><br><span class="line">        BufferQueue::createBufferQueue(&amp;producer, &amp;consumer);</span><br><span class="line">        <span class="comment">//注意下面设置buffer的用处是GRALLOC_USAGE_HW_VIDEO_ENCODER，这个会在</span></span><br><span class="line">        <span class="comment">//mediaRecorder中使用到。</span></span><br><span class="line">        mRecordingConsumer = <span class="keyword">new</span> BufferItemConsumer(consumer,</span><br><span class="line">                GRALLOC_USAGE_HW_VIDEO_ENCODER,</span><br><span class="line">                mRecordingHeapCount + <span class="number">1</span>);</span><br><span class="line">        mRecordingConsumer-&gt;setFrameAvailableListener(<span class="keyword">this</span>);</span><br><span class="line">        mRecordingConsumer-&gt;setName(String8(<span class="string">"Camera2-RecordingConsumer"</span>));</span><br><span class="line">        mRecordingWindow = <span class="keyword">new</span> Surface(producer);</span><br><span class="line">        newConsumer = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// Allocate memory later, since we don't know buffer size until receipt</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//更新部分代码，就不贴出来了－－－－</span></span><br><span class="line"><span class="comment">//注意下面video 录像buffer的像素格式是CAMERA2_HAL_PIXEL_FORMAT_OPAQUE</span></span><br><span class="line">    <span class="keyword">if</span> (mRecordingStreamId == NO_STREAM) &#123;</span><br><span class="line">        mRecordingFrameCount = <span class="number">0</span>;</span><br><span class="line">        res = device-&gt;createStream(mRecordingWindow,</span><br><span class="line">                params.videoWidth, params.videoHeight,</span><br><span class="line">                CAMERA2_HAL_PIXEL_FORMAT_OPAQUE, &amp;mRecordingStreamId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要处理下面几件事情。</p><p>☯ 1.由于录像不需要显示，这里创建CameraService BufferQueue本地对象，这个时候获取到的生产者和消费者都是本地的，只有BufferQueue保存的有IGraphicBufferAlloc代理对象mAllocator，专门用来分配buffer。<br>☯ 2.由于StremingProcess.cpp中实现了FrameAvailableListener监听接口方法onFrameAvailable()。这里会通过setFrameAvailableListener方法注册到BufferQueue中。<br>☯ 3.根据生产者对象创建surface对象，并传给Camera3Device申请录像buffer.<br>☯ 4.如果参数有偏差或者之前已经创建过video Stream.这里会删除或者更新videoStream.如果压根没有创建VideoStream,直接创建VideoStream并根据参数更新流信息。</p><h5 id="4-6、何时录像帧可用"><a href="#4-6、何时录像帧可用" class="headerlink" title="4.6、何时录像帧可用"></a>4.6、何时录像帧可用</h5><h5 id="4-6-1、onFrameAvailable"><a href="#4-6-1、onFrameAvailable" class="headerlink" title="4.6.1、onFrameAvailable()"></a>4.6.1、onFrameAvailable()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">void</span> StreamingProcessor::onFrameAvailable(<span class="keyword">const</span> BufferItem&amp; <span class="comment">/*item*/</span>) &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mRecordingFrameAvailable) &#123;</span><br><span class="line">        mRecordingFrameAvailable = <span class="literal">true</span>;</span><br><span class="line">        mRecordingFrameAvailableSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当video buffer进行enqueue操作后,该函数会被调用。函数中可用发现，激活了StreamingProcessor主线程。</p><h5 id="4-6-2、StreamingProcessor线程loop"><a href="#4-6-2、StreamingProcessor线程loop" class="headerlink" title="4.6.2、StreamingProcessor线程loop"></a>4.6.2、StreamingProcessor线程loop</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/api1/client2/StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">bool</span> StreamingProcessor::threadLoop() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">l</span><span class="params">(mMutex)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (!mRecordingFrameAvailable) &#123;</span><br><span class="line">        <span class="comment">//之前是在这里挂起的,现在有帧可用就会从这里唤醒。</span></span><br><span class="line">            res = mRecordingFrameAvailableSignal.waitRelative(</span><br><span class="line">                mMutex, kWaitDuration);</span><br><span class="line">            <span class="keyword">if</span> (res == TIMED_OUT) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRecordingFrameAvailable = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        res = processRecordingFrame();<span class="comment">//进一步处理。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (res == OK);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里发现，原来StreamingProcessor主线程只为录像服务，previewStream只是使用了它的几个方法而已。</p><h5 id="4-6-3、帧可用消息发送给Camera本地对象"><a href="#4-6-3、帧可用消息发送给Camera本地对象" class="headerlink" title="4.6.3、帧可用消息发送给Camera本地对象"></a>4.6.3、帧可用消息发送给Camera本地对象</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api1\client2\StreamingProcessor.cpp]</span><br><span class="line"><span class="keyword">status_t</span> StreamingProcessor::processRecordingFrame() &#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    sp&lt;Camera2Heap&gt; recordingHeap;</span><br><span class="line">    <span class="keyword">size_t</span> heapIdx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">nsecs_t</span> timestamp;</span><br><span class="line">    sp&lt;Camera2Client&gt; client = mClient.promote();</span><br><span class="line"></span><br><span class="line">    BufferItemConsumer::BufferItem imgBuffer;</span><br><span class="line">    <span class="comment">//取出buffer消费，就是拿给mediaRecorder编码</span></span><br><span class="line">    res = mRecordingConsumer-&gt;acquireBuffer(&amp;imgBuffer, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line">    <span class="comment">// Call outside locked parameters to allow re-entrancy from notification</span></span><br><span class="line">    Camera2Client::SharedCameraCallbacks::<span class="function">Lock <span class="title">l</span><span class="params">(client-&gt;mSharedCameraCallbacks)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (l.mRemoteCallback != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//调用Callback通知Camea本地对象。</span></span><br><span class="line">        l.mRemoteCallback-&gt;dataCallbackTimestamp(timestamp,</span><br><span class="line">                CAMERA_MSG_VIDEO_FRAME,</span><br><span class="line">                recordingHeap-&gt;mBuffers[heapIdx]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGW(<span class="string">"%s: Camera %d: Remote callback gone"</span>, __FUNCTION__, mId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br></pre></td></tr></table></figure><p>之前我们已经知道Camera运行时存在类型为ICameraClient的两个对象,其中一个代理对象保存在CameraService中，本地对象保存的Camera本地对象中。这里代理对象通知本地对象取帧了。注意这里消息发送的是“CAMERA_MSG_VIDEO_FRAME”。</p><h5 id="4-6-4、Camera本地对象转发消息给mediaRecorder"><a href="#4-6-4、Camera本地对象转发消息给mediaRecorder" class="headerlink" title="4.6.4、Camera本地对象转发消息给mediaRecorder."></a>4.6.4、Camera本地对象转发消息给mediaRecorder.</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/camera/Camera.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera::dataCallbackTimestamp(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> msgType, <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; dataPtr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// If recording proxy listener is registered, forward the frame and return.</span></span><br><span class="line">    <span class="comment">// The other listener (mListener) is ignored because the receiver needs to</span></span><br><span class="line">    <span class="comment">// call releaseRecordingFrame.</span></span><br><span class="line">    sp&lt;ICameraRecordingProxyListener&gt; proxylistener;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">//这里mRecordingProxyListener就是mediaRecorder注册过来的监听代理对象</span></span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        proxylistener = mRecordingProxyListener;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proxylistener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//这里就把buffer送到了mediaRecorder中进行编码</span></span><br><span class="line">        proxylistener-&gt;dataCallbackTimestamp(timestamp, msgType, dataPtr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//---------省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里Camera本地对象就会调用mediaRecorder注册来的帧监听对象。前面我们已经做了那么长的铺垫，我想应该可以理解了。好了,mediaRecorder有饭吃了。</p><h5 id="4-7、总结"><a href="#4-7、总结" class="headerlink" title="4.7、总结"></a>4.7、总结</h5><p>1.一开始我自以为preview和Video使用同一个camera本地对象，看了代码发现，原来是不同的对象。<br>2.预览的BufferQueue是在CameraService中创建的，和surfaceFlinger没有关系，只是保留了IGraphicBufferAlloc代理对象mAllocator，用于分配buffer.<br>3.之匿名binder没有理解透彻，以为只有传递本地对象才能使用writeStrongBinder()接口保存binder对象，同时在使用端使用readStrongBinder()就可以获取到代理对象了。其实也可以传递代理对象，只不过代码会走另外一套逻辑，在kernel中重新创建一个binder_ref索引对象返回给另一端。如下mediaRecorder设置camera时就是传递的ICamera代理对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/media/libmedia/IMediaRecorder.cpp]</span><br><span class="line">    <span class="keyword">status_t</span> setCamera(<span class="keyword">const</span> sp&lt;ICamera&gt;&amp; camera, <span class="keyword">const</span> sp&lt;ICameraRecordingProxy&gt;&amp; proxy)</span><br><span class="line">    &#123;</span><br><span class="line">        ALOGV(<span class="string">"setCamera(%p,%p)"</span>, camera.get(), proxy.get());</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        data.writeInterfaceToken(IMediaRecorder::getInterfaceDescriptor());</span><br><span class="line">        <span class="comment">//camera-&gt;asBinder()是ICamera代理对象</span></span><br><span class="line">        data.writeStrongBinder(camera-&gt;asBinder());</span><br><span class="line">        data.writeStrongBinder(proxy-&gt;asBinder());</span><br><span class="line">        remote()-&gt;transact(SET_CAMERA, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> reply.readInt32();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://source.android.com/devices/camera/" target="_blank" rel="noopener">Android Camera官方文档</a><br><a href="https://blog.csdn.net/eternity9255" target="_blank" rel="noopener">Android 5.0 Camera系统源码分析-CSDN博客</a><br><a href="http://www.cnblogs.com/stonedemo/category/1080451.html" target="_blank" rel="noopener">Android Camera 流程学习记录 - StoneDemo - 博客园</a><br><a href="https://blog.csdn.net/shell812/article/category/5905525" target="_blank" rel="noopener">Android Camera 系统架构源码分析 - CSDN博客</a><br><a href="https://blog.csdn.net/hbw1992322/article/details/75259311" target="_blank" rel="noopener">Camera安卓源码-高通mm_camera架构剖析 - CSDN博客</a><br><a href="https://blog.csdn.net/yanbixing123/article/details/52294305/" target="_blank" rel="noopener">5.2 应用程序和驱动程序中buffer的传输流程 - CSDN博客</a><br><a href="https://www.jianshu.com/p/ecb1be82e6a8" target="_blank" rel="noopener">Camera2 数据流从framework到Hal源码分析 - 简书</a><br><a href="https://www.jianshu.com/p/1baad2a5281d" target="_blank" rel="noopener">mm-camera层frame数据流源码分析 - 简书</a><br><a href="https://blog.csdn.net/yanbixing123/article/month/2016/08/4?" target="_blank" rel="noopener">v4l2_capture.c分析—probe函数分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">@@Android Camera fw学习 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">@@Android Camera API2分析 - CSDN博客</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">@@Android Camera 流程学习记录 7.12- CSDN博客</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">@@专栏：古冥的android6.0下的Camera API2.0的源码分析之旅 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/17751109" target="_blank" rel="noopener">linux3.3 v4l2视频采集驱动框架(vfe, camera i2c driver，v4l2_subdev等之间的联系) - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48974523" target="_blank" rel="noopener">Android Camera从Camera HAL1到Camera HAL3的过渡（已更新到Android6.0 HAL3.3） - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48972477" target="_blank" rel="noopener">我心依旧之Android Camera模块FW/HAL3探学序 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/73709808" target="_blank" rel="noopener">Android Camera fw学习(四)-recording流程分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/52076879" target="_blank" rel="noopener">android camera动态库加载过程 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/49468475" target="_blank" rel="noopener">Android Camera API2.0下全新的Camera FW/HAL架构简述 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera System（1）：Camera System(Camera 系统)框架、Open()过程分析</title>
    <link href="http://zhoujinjian.cc/2018/06/30/Android%20Camera%20System%EF%BC%881%EF%BC%89%EF%BC%9ACamera%20System%5BCamera%20%E7%B3%BB%E7%BB%9F%5D%E6%A1%86%E6%9E%B6%E3%80%81Open%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/30/Android Camera System（1）：Camera System[Camera 系统]框架、Open过程分析/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2018-05-25T12:12:49.774Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/camera.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">【特别感谢 - Android Camera fw学习-Armwind】</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">【特别感谢 - Android Camera API2分析-Gzzaigcnforever】</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">【特别感谢 - Android Camera 流程学习记录 Android 7.12-QQ_16775897】</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">【特别感谢 - 专栏：古冥的android6.0下的Camera API2.0的源码分析之旅】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><p> 🌀🌀：专注于Linux &amp;&amp; Android Multimedia（Camera、Video、Audio、Display）系统分析与研究</p><hr><p>☯ Application：<br>☯ /packages/apps/Camera2/src/com/android/camera/</p><p>☯ Framework：<br>☯ /frameworks/base/core/java/android/hardware/Camera.java</p><p>☯ JNI:<br>☯ /frameworks/base/core/jni/android_hardware_Camera.cpp</p><p>☯ Native:<br>☯ Client：<br>frameworks/av/camera/CameraBase.cpp<br>frameworks/av/camera/Camera.cpp<br>frameworks/av/camera/ICamera.cpp<br>frameworks/av/camera/aidl/android/hardware/ICamera.aidl<br>frameworks/av/camera/aidl/android/hardware/ICameraClient.aidl<br>☯ Server：<br>frameworks/av/camera/cameraserver/main_cameraserver.cpp<br>frameworks/av/services/camera/libcameraservice/CameraService.cpp<br>frameworks/av/services/camera/libcameraservice/api1/CameraClient.cpp<br>frameworks/av/camera/aidl/android/hardware/ICameraService.aidl</p><p>☯ HAL：<br>☯ /frameworks/av/services/camera/libcameraservice/device3/<br>☯ /hardware/qcom/camera/QCamera2(高通HAL)<br>☯ /vendor/qcom/proprietary/mm-camera(高通mm-camera)<br>☯ /vendor/qcom/proprietary/mm-still(高通JPEG)</p><p>☯ Kernel：<br>☯ /kernel/drivers/media/platform/msm/camera_v2(高通V4L2)<br>☯ /kernel/arch/arm/boot/dts/(高通dts)</p><hr><h4 id="（一）、Android-Camera-System-Architecture（Camera系统框架）"><a href="#（一）、Android-Camera-System-Architecture（Camera系统框架）" class="headerlink" title="（一）、Android Camera System Architecture（Camera系统框架）"></a>（一）、Android Camera System Architecture（Camera系统框架）</h4><h5 id="1-1、Android-Camera-System总体框架（Qualcomm平台）"><a href="#1-1、Android-Camera-System总体框架（Qualcomm平台）" class="headerlink" title="1.1、Android Camera System总体框架（Qualcomm平台）"></a>1.1、Android Camera System总体框架（Qualcomm平台）</h5><h5 id="1-1-1、首先看看Android-官方Camera总体架构："><a href="#1-1-1、首先看看Android-官方Camera总体架构：" class="headerlink" title="1.1.1、首先看看Android 官方Camera总体架构："></a>1.1.1、首先看看Android 官方Camera总体架构：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-01-android_ape_fwk_camera.png" alt="Alt text"></p><p><strong>☯应用框架</strong><br>应用代码位于应用框架级别，它利用 android.hardware.Camera API 来与相机硬件进行互动。在内部，此代码会调用相应的 JNI 粘合类，以访问与该相机互动的原生代码。<br><strong>☯JNI</strong><br>与 android.hardware.Camera 关联的 JNI 代码位于 frameworks/base/core/jni/android_hardware_Camera.cpp 中。此代码会调用较低级别的原生代码以获取对物理相机的访问权限，并返回用于在框架级别创建 android.hardware.Camera 对象的数据。<br><strong>☯原生框架</strong><br>在 frameworks/av/camera/Camera.cpp 中定义的原生框架可提供相当于 android.hardware.Camera 类的原生类。此类会调用 IPC binder 代理，以获取对相机服务的访问权限。<br><strong>☯Binder IPC 代理</strong><br>IPC binder 代理用于促进跨越进程边界的通信。调用相机服务的 frameworks/av/camera 目录中有 3 个相机 binder 类。ICameraService 是相机服务的接口，ICamera 是已打开的特定相机设备的接口，ICameraClient 是返回应用框架的设备接口。<br><strong>☯相机服务</strong><br>位于 frameworks/av/services/camera/libcameraservice/CameraService.cpp 下的相机服务是与 HAL 进行互动的实际代码。<br><strong>☯HAL</strong><br>硬件抽象层定义了由相机服务调用且您必须实现以确保相机硬件正常运行的标准接口。<br><strong>☯内核驱动程序</strong><br>相机的驱动程序可与实际相机硬件以及您的 HAL 实现进行互动。相机和驱动程序必须支持 YV12 和 NV21 图片格式，以便在显示和视频录制时支持预览相机图片。</p><h5 id="1-1-2、Qualcomm平台Camera-架构"><a href="#1-1-2、Qualcomm平台Camera-架构" class="headerlink" title="1.1.2、Qualcomm平台Camera 架构"></a>1.1.2、Qualcomm平台Camera 架构</h5><p>Qualcomm平台Camera 架构主要区别在于HAL层和Kernel层的变化，总体架构图如下：</p><h5 id="1-1-2-1、Qualcomm平台Camera总体架构"><a href="#1-1-2-1、Qualcomm平台Camera总体架构" class="headerlink" title="1.1.2.1、Qualcomm平台Camera总体架构"></a>1.1.2.1、Qualcomm平台Camera总体架构</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-02-Android-Camera-Software-Architecture.png" alt="Alt text"></p><h5 id="1-1-2-2、Qualcomm平台Camera的HAL、mm-camera"><a href="#1-1-2-2、Qualcomm平台Camera的HAL、mm-camera" class="headerlink" title="1.1.2.2、Qualcomm平台Camera的HAL、mm-camera"></a>1.1.2.2、Qualcomm平台Camera的HAL、mm-camera</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-03-HAL-and-mm-camera-interface.png" alt="Alt text"></p><h5 id="1-1-2-3、Qualcomm平台Camera的Kernel"><a href="#1-1-2-3、Qualcomm平台Camera的Kernel" class="headerlink" title="1.1.2.3、Qualcomm平台Camera的Kernel"></a>1.1.2.3、Qualcomm平台Camera的Kernel</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-04-Camera-Kernel-Architecture.png" alt="Alt text"></p><h5 id="1-2、Android-Camera-API-2-0-全新的HAL-子系统"><a href="#1-2、Android-Camera-API-2-0-全新的HAL-子系统" class="headerlink" title="1.2、Android Camera API 2.0 全新的HAL 子系统"></a>1.2、Android Camera API 2.0 全新的HAL 子系统</h5><p>Android 7.1.2现在使用的是Camera API 2.0 和 Camera Device 3以及 HAL3。</p><h5 id="1-2-1、请求"><a href="#1-2-1、请求" class="headerlink" title="1.2.1、请求"></a>1.2.1、请求</h5><p>应用框架针对捕获的结果向相机子系统发出请求。一个请求对应一组结果。请求包含有关捕获和处理这些结果的所有配置信息。其中包括分辨率和像素格式；手动传感器、镜头和闪光灯控件；3A 操作模式；RAW 到 YUV 处理控件；以及统计信息的生成。这样一来，便可更好地控制结果的输出和处理。一次可发起多个请求，而且提交的请求不会出现阻塞的情况。请求始终按照接收的顺序进行处理。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-05-camera2api.png.png" alt="Alt text"></p><h5 id="1-2-2、HAL-和相机子系统"><a href="#1-2-2、HAL-和相机子系统" class="headerlink" title="1.2.2、HAL 和相机子系统"></a>1.2.2、HAL 和相机子系统</h5><p>相机子系统包括相机管道中组件的实现，例如 3A 算法和处理控件。相机 HAL 为您提供了实现您版本的这些组件所需的接口。为了保持多个设备制造商和图像信号处理器（ISP，也称为相机传感器）供应商之间的跨平台兼容性，相机管道模型是虚拟的，且不直接对应任何真正的 ISP。不过，它与真正的处理管道足够相似，因此您可以有效地将其映射到硬件。此外，它足够抽象，可支持多种不同的算法和操作顺序，而不会影响质量、效率或跨设备兼容性。<br>相机管道还支持应用框架开启自动对焦等功能的触发器。它还会将通知发送回应用框架，以通知应用自动对焦锁定或错误等事件。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-06-camera_hal_request_control.png.png" alt="Alt text"></p><blockquote><p>RAW Bayer 输出在 ISP 内部不经过任何处理。<br>统计信息根据原始传感器数据生成。<br>将原始传感器数据转换为 YUV 的各种处理块按任意顺序排列。<br>当显示多个刻度和剪裁单元时，所有的缩放器单元共享输出区域控件（数字缩放）。不过，每个单元都可能具有不同的输出分辨率和像素格式。</p></blockquote><h5 id="1-2-3、HAL-操作摘要"><a href="#1-2-3、HAL-操作摘要" class="headerlink" title="1.2.3、HAL 操作摘要"></a>1.2.3、HAL 操作摘要</h5><p>☯ 捕获的异步请求来自于框架。<br>☯ HAL 设备必须按顺序处理请求。对于每个请求，均产生输出结果元数据以及一个或多个输出图片缓冲区。<br>☯ 请求和结果以及后续请求引用的流遵守先进先出规则。<br>☯ 指定请求的所有输出的时间戳必须完全相同，以便框架可以根据需要将它们匹配在一起。<br>☯ 所有捕获配置和状态（不包括 3A 例程）都包含在请求和结果中。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-07-camera-hal-overview-oo.png.png" alt="Alt text"></p><h5 id="1-2-4、启动和预期操作顺序"><a href="#1-2-4、启动和预期操作顺序" class="headerlink" title="1.2.4、启动和预期操作顺序"></a>1.2.4、启动和预期操作顺序</h5><p>1、框架调用 camera_module_t-&gt;common.open()，而这会返回一个 hardware_device_t 结构。<br>2、框架检查 hardware_device_t-&gt;version 字段，并为该版本的相机硬件设备实例化相应的处理程序。如果版本是 CAMERA_DEVICE_API_VERSION_3_0，则该设备会转型为 camera3_device_t。<br>3、框架调用 camera3_device_t-&gt;ops-&gt;initialize() 并显示框架回调函数指针。在调用 ops 结构中的任何其他函数之前，这只会在 open() 之后调用一次。<br>4、框架调用 camera3_device_t-&gt;ops-&gt;configure_streams() 并显示到 HAL 设备的输入/输出流列表。<br>5、框架为 configure_streams 中列出的至少一个输出流分配 gralloc 缓冲区并调用 camera3_device_t-&gt;ops-&gt;register_stream_buffers()。相同的流仅注册一次。<br>6、框架通过调用 camera3_device_t-&gt;ops-&gt;construct_default_request_settings() 来为某些使用情形请求默认设置。这可能会在第 3 步之后的任何时间发生。<br>7、框架通过基于其中一组默认设置的设置以及至少一个框架之前注册的输出流来构建第一个捕获请求并将其发送到 HAL。它通过 camera3_device_t-&gt;ops-&gt;process_capture_request() 发送到 HAL。HAL 必须阻止此调用返回，直到准备好发送下一个请求。<br>8、框架继续提交请求，并且可能会为尚未注册的流调用 register_stream_buffers()，并调用 construct_default_request_settings 来为其他使用情形获取默认设置缓冲区。<br>9、当请求捕获开始（传感器开始曝光以进行捕获）时，HAL 会调用 camera3_callback_ops_t-&gt;notify() 并显示 SHUTTER 事件，包括帧号和开始曝光的时间戳。此通知调用必须在第一次调用该帧号的 process_capture_result() 之前进行。<br>10、在某个管道延迟后，HAL 开始使用 camera3_callback_ops_t-&gt;process_capture_result() 将完成的捕获返回到框架。这些捕获按照与提交请求相同的顺序返回。一次可发起多个请求，具体取决于相机 HAL 设备的管道深度。<br>11、一段时间后，框架可能会停止提交新的请求、等待现有捕获完成（所有缓冲区都已填充，所有结果都已返回），然后再次调用 configure_streams()。这会重置相机硬件和管道，以获得一组新的输入/输出流。可重复使用先前配置中的部分流；如果这些流的缓冲区已经过 HAL 注册，则不会再次注册。如果至少还有一个已注册的输出流，则框架从第 7 步继续（否则，需要先完成第 5 步）。<br>12、或者，框架可能会调用 camera3_device_t-&gt;common-&gt;close() 以结束相机会话。当框架中没有其他处于活动状态的调用时，它可能随时会被调用；尽管在所有发起的捕获完成（所有结果都已返回，所有缓冲区都已填充）之前，调用可能会阻塞。在 close 调用返回后，不允许再从 HAL 对 camera3_callback_ops_t 函数进行更多调用。一旦进行 close() 调用，该框架可能不会调用任何其他 HAL 设备函数。<br>13、在发生错误或其他异步事件时，HAL 必须调用 camera3_callback_ops_t-&gt;notify() 并返回相应的错误/事件消息。从严重的设备范围错误通知返回后，HAL 应表现为在其上调用了 close()。但是，HAL 必须在调用 notify() 之前取消或完成所有待处理的捕获，以便在调用 notify() 并返回严重错误时，框架不会收到来自设备的更多回调。在严重的错误消息返回 notify() 方法后，close() 之外的方法应该返回 -ENODEV 或 NULL。</p><h5 id="1-3、Android-Graphics-学习－生产者、消费者、BufferQueue介绍"><a href="#1-3、Android-Graphics-学习－生产者、消费者、BufferQueue介绍" class="headerlink" title="1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍"></a>1.3、Android Graphics 学习－生产者、消费者、BufferQueue介绍</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-08-Android-graphics-SurfaceFlinger-BufferQueue.jpg.png" alt="Alt text"></p><p>Graphics 系统详细分析请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】(<a href="http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/">http://zhoujinjian.cc/2018/02/01/Android-7-1-2-Android-N-Android-Graphics-%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/</a>)</p><h5 id="1-4、Camera类之间的关系和作用"><a href="#1-4、Camera类之间的关系和作用" class="headerlink" title="1.4、Camera类之间的关系和作用"></a>1.4、Camera类之间的关系和作用</h5><h5 id="1-4-1、Camera类关系总体概览"><a href="#1-4-1、Camera类关系总体概览" class="headerlink" title="1.4.1、Camera类关系总体概览"></a>1.4.1、Camera类关系总体概览</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-09-Android-Camera-class.png" alt="Alt text"></p><p>☯ 1、ICameraClient: 这主要是一些消息发送的接口，包括帧可用通知，回调一些信息给client等消息。不过这里要注意的是，BnCameraClient对象其实是在client这端，不在CameraService端。<br>☯ 2、ICamera:camera的一些标准操作接口，比如startpreview，takepicuture,autofocus,所有的操作动作都是用的这一套接口。<br>☯ 3、ICameraService: 链接Camera服务，Camera device,获取Camera数量，Camera硬件信息，视厂角，镜头等信息。</p><h5 id="1-4-2、ICameraClient"><a href="#1-4-2、ICameraClient" class="headerlink" title="1.4.2、ICameraClient"></a>1.4.2、ICameraClient</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-10-ICameraClient.png" alt="Alt text"></p><h5 id="1-4-3、ICamera"><a href="#1-4-3、ICamera" class="headerlink" title="1.4.3、ICamera"></a>1.4.3、ICamera</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-11-ICamera.png" alt="Alt text"></p><h5 id="1-4-4、ICameraService"><a href="#1-4-4、ICameraService" class="headerlink" title="1.4.4、ICameraService"></a>1.4.4、ICameraService</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-12-ICameraService.png" alt="Alt text"></p><h4 id="（二）、Android-CameraService开机初始化分析"><a href="#（二）、Android-CameraService开机初始化分析" class="headerlink" title="（二）、Android CameraService开机初始化分析"></a>（二）、Android CameraService开机初始化分析</h4><p>首先看下总体时序图：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-13-CameraService_onFirstRef.png" alt="Alt text"></p><h5 id="2-1、CameraService-初始化过程"><a href="#2-1、CameraService-初始化过程" class="headerlink" title="2.1、CameraService 初始化过程"></a>2.1、CameraService 初始化过程</h5><p>Android启动的时候会收集系统的.rc文件，启动对应的Native Service：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\camera\cameraserver\cameraserver.rc]</span><br><span class="line">service cameraserver /system/bin/cameraserver</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">main</span></span></span><br><span class="line"><span class="class">    <span class="title">user</span> <span class="title">cameraserver</span></span></span><br><span class="line"><span class="class">    <span class="title">group</span> <span class="title">audio</span> <span class="title">camera</span> <span class="title">input</span> <span class="title">drmrpc</span></span></span><br><span class="line"><span class="class">    <span class="title">ioprio</span> <span class="title">rt</span> 4</span></span><br><span class="line"><span class="class">    <span class="title">writepid</span> /<span class="title">dev</span>/<span class="title">cpuset</span>/<span class="title">camera</span>-<span class="title">daemon</span>/<span class="title">tasks</span> /<span class="title">dev</span>/<span class="title">stune</span>/<span class="title">top</span>-<span class="title">app</span>/<span class="title">tasks</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\camera\cameraserver\main_cameraserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span>** argv __unused)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">    sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">    ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">    CameraService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraService继承自BinderService，instantiate也是在BinderService中定义的，此方法就是调用publish方法，所以来看publish方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\include\binder\BinderService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    <span class="comment">//将服务添加到ServiceManager</span></span><br><span class="line">    <span class="keyword">return</span> sm-&gt;addService(String16(SERVICE::getServiceName()),<span class="keyword">new</span> SERVICE(), allowIsolated);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，将会把CameraService服务加入到ServiceManager进行管理。 CameraService的构造时，会调用CameraService的onFirstRef方法：</p><h5 id="2-1-1、CameraService-onFirstRef"><a href="#2-1-1、CameraService-onFirstRef" class="headerlink" title="2.1.1、CameraService::onFirstRef()"></a>2.1.1、CameraService::onFirstRef()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CameraService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">"CameraService process starting"</span>);</span><br><span class="line"></span><br><span class="line">    BnCameraService::onFirstRef();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update battery life tracking if service is restarting</span></span><br><span class="line">    BatteryNotifier&amp; notifier(BatteryNotifier::getInstance());</span><br><span class="line">    notifier.noteResetCamera();</span><br><span class="line">    notifier.noteResetFlashlight();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">camera_module_t</span> *rawModule;</span><br><span class="line">    <span class="keyword">int</span> err = hw_get_module(CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">            (<span class="keyword">const</span> <span class="keyword">hw_module_t</span> **)&amp;rawModule);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    mModule = <span class="keyword">new</span> CameraModule(rawModule);</span><br><span class="line">    err = mModule-&gt;init();</span><br><span class="line">    ......</span><br><span class="line">    mFlashlight = <span class="keyword">new</span> CameraFlashlight(*mModule, *<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">status_t</span> res = mFlashlight-&gt;findFlashUnits();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mModule-&gt;getModuleApiVersion() &gt;= CAMERA_MODULE_API_VERSION_2_1) &#123;</span><br><span class="line">        mModule-&gt;setCallbacks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CameraService::pingCameraServiceProxy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会通过HAL框架的hw_get_module来创建CameraModule对象，然后会对其进行相应的初始化，并会进行一些参数的设置，如camera的数量，闪光灯的初始化，以及回调函数的设置等，到这里，Camera2 HAL的模块就初始化结束了。</p><h5 id="2-1-2、Camera-动态库加载过程"><a href="#2-1-2、Camera-动态库加载过程" class="headerlink" title="2.1.2、Camera 动态库加载过程"></a>2.1.2、Camera 动态库加载过程</h5><p>在源码中不知大家有没有注意到第二个参数是hw_module_t <strong>module,这里是指针的指针，而我们刚才传的是camera_module_t</strong>指针。大家可以看到camera_module_t 结构第一个域就是hw_module_t 所以这里就不难理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">源码路径：hardware/libhardware/hardware.c</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Base path of the hal modules */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">"/system/lib/hw"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">"/vendor/lib/hw"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id, <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hw_get_module_by_class(id, <span class="literal">NULL</span>, <span class="keyword">module</span>); </span><br><span class="line">    <span class="comment">//这里的id就是camera模块的id，每一个hal module都有对应的id，</span></span><br><span class="line">    <span class="comment">//区分他们就通过这个id来区分了。</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hw_get_module_by_class</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *class_id, <span class="keyword">const</span> <span class="keyword">char</span> *inst,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **<span class="keyword">module</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> *<span class="title">hmi</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">char</span> prop[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> path[PATH_MAX];</span><br><span class="line">    <span class="keyword">char</span> name[PATH_MAX];</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Loop through the configuration variants looking for a module */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span> ; i&lt;HAL_VARIANT_KEYS_COUNT+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; HAL_VARIANT_KEYS_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (property_get(variant_keys[i], prop, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123; <span class="comment">//关键字数组，上面有宏代码。</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.%s.so"</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH2, name, prop);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.%s.so"</span>, <span class="comment">//拼接完整的camera库。</span></span><br><span class="line">                     HAL_LIBRARY_PATH1, name, prop);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.default.so"</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH2, name);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">"%s/%s.default.so"</span>,</span><br><span class="line">                     HAL_LIBRARY_PATH1, name);</span><br><span class="line">            <span class="keyword">if</span> (access(path, R_OK) == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    status = -ENOENT;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; HAL_VARIANT_KEYS_COUNT+<span class="number">1</span>) &#123;</span><br><span class="line">        status = load(class_id, path, <span class="keyword">module</span>); <span class="comment">//如果上面都进行完毕，走到这里，说明已经找到库了，这里就去加载。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据id来加载hal的module</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *id,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *path,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> **pHmi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">void</span> *handle;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hw_module_t</span> *<span class="title">hmi</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = dlopen(path, RTLD_NOW); <span class="comment">//动态加载内存的api，这里的path=/system/lib/hw/camera.msm8996.so</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* Get the address of the struct hal_module_info. */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *sym = HAL_MODULE_INFO_SYM_AS_STR;   <span class="comment">//别的地方定义#define HAL_MODULE_INFO_SYM_AS_STR  "HMI"</span></span><br><span class="line">    hmi = (struct <span class="keyword">hw_module_t</span> *)dlsym(handle, sym); <span class="comment">//我们动态链接的是"HMI"这个符号。</span></span><br><span class="line">    ......</span><br><span class="line">    *pHmi = hmi; <span class="comment">//最后将这个指针，赋给我们之前定义的 struct camera_module变量。这里模块就加载进来了。</span></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hal代码</span></span><br><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Hal.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">hw_module_t</span> camera_common = &#123;</span><br><span class="line">    .tag                    = HARDWARE_MODULE_TAG,</span><br><span class="line">    .module_api_version     = CAMERA_MODULE_API_VERSION_2_4,</span><br><span class="line">    .hal_api_version        = HARDWARE_HAL_API_VERSION,</span><br><span class="line">    .id                     = CAMERA_HARDWARE_MODULE_ID,</span><br><span class="line">    .name                   = <span class="string">"QCamera Module"</span>,</span><br><span class="line">    .author                 = <span class="string">"Qualcomm Innovation Center Inc"</span>,</span><br><span class="line">    .methods                = &amp;qcamera::QCamera2Factory::mModuleMethods, <span class="comment">//它的方法数组里绑定了open接口</span></span><br><span class="line">    .dso                    = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">camera_module_t</span> HAL_MODULE_INFO_SYM = &#123;</span><br><span class="line">    .common                 = camera_common,</span><br><span class="line">    .get_number_of_cameras  = qcamera::QCamera2Factory::get_number_of_cameras,</span><br><span class="line">    .get_camera_info        = qcamera::QCamera2Factory::get_camera_info,</span><br><span class="line">    .set_callbacks          = qcamera::QCamera2Factory::set_callbacks,</span><br><span class="line">    .get_vendor_tag_ops     = qcamera::QCamera3VendorTags::get_vendor_tag_ops,</span><br><span class="line">    .open_legacy            = qcamera::QCamera2Factory::open_legacy,</span><br><span class="line">    .set_torch_mode         = qcamera::QCamera2Factory::set_torch_mode,</span><br><span class="line">    .init                   = <span class="literal">NULL</span>,</span><br><span class="line">    .reserved               = &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hw_module_methods_t</span> <span class="title">QCamera2Factory</span>:</span>:mModuleMethods = &#123;</span><br><span class="line">    <span class="comment">//open方法的绑定</span></span><br><span class="line">    open: QCamera2Factory::camera_device_open,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Camera HAL层的open入口其实就是camera_device_open方法：</p><h5 id="2-1-3、图解camera-module和camera-device-t关系"><a href="#2-1-3、图解camera-module和camera-device-t关系" class="headerlink" title="2.1.3、图解camera_module和camera_device_t关系"></a>2.1.3、图解camera_module和camera_device_t关系</h5><p>camer module在系统中转指camera模块，camera_device_t 转指某一个camera 设备。在流程上，native framwork 先加载在hal层定义的camer_module对象，然后通过camera_module的methods open方法填充camera_device_t 结构体，并最终获取到camera ops这一整个camera最重要的操作集合。下图中我们可以看到struct hw_module_t在camera_module最上面 而camera_device_t最开始保存的是struct hw_device_t. 由此我们平时在看代码时，要注意一些指针转换。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-14-camera_module camera_device_t.png" alt="Alt text"></p><h4 id="（三）、Android-Camera-Open过程"><a href="#（三）、Android-Camera-Open过程" class="headerlink" title="（三）、Android Camera Open过程"></a>（三）、Android Camera Open过程</h4><h5 id="3-1、Camera2-HAL层Open-过程分析"><a href="#3-1、Camera2-HAL层Open-过程分析" class="headerlink" title="3.1、Camera2 HAL层Open()过程分析"></a>3.1、Camera2 HAL层Open()过程分析</h5><p>高通的Camera，它在后台会有一个守护进程daemon，daemon是介于应用和驱动之间翻译ioctl的中间层(委托处理)。本节将以Camera中的open流程为例，来分析Camera HAL的工作过程，在应用对硬件发出open请求后，会通过Camera HAL来发起open请求，而Camera HAL的open入口在QCamera2Hal.cpp进行了定义，即前面分析的Camera HAL层的open入口其实就是camera_device_open方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Factory.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::camera_device_open(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span> *<span class="keyword">module</span>, <span class="keyword">const</span> <span class="keyword">char</span> *id,</span><br><span class="line">        struct <span class="keyword">hw_device_t</span> **hw_device)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> gQCamera2Factory-&gt;cameraDeviceOpen(atoi(id), hw_device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了cameraDeviceOpen方法，而其中的hw_device就是最后要返回给应用层的CameraDeviceImpl在Camera HAL层的对象，继续分析cameraDeviceOpen方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\QCamera2Factory.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera2Factory::cameraDeviceOpen(<span class="keyword">int</span> camera_id, struct <span class="keyword">hw_device_t</span> **hw_device)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//Camera2采用的Camera HAL版本为HAL3.0</span></span><br><span class="line">    <span class="keyword">if</span> ( mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_3_0 ) &#123;</span><br><span class="line">        <span class="comment">//初始化QCamera3HardwareInterface对象，这里构造函数里将会进行configure_streams以及</span></span><br><span class="line">        <span class="comment">//process_capture_result等的绑定</span></span><br><span class="line">        QCamera3HardwareInterface *hw = <span class="keyword">new</span> QCamera3HardwareInterface(</span><br><span class="line">            mHalDescriptors[camera_id].cameraId, mCallbacks);</span><br><span class="line">        <span class="comment">//通过QCamera3HardwareInterface来打开Camera</span></span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mHalDescriptors[camera_id].device_version == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">        <span class="comment">//HAL API为2.0</span></span><br><span class="line">        QCamera2HardwareInterface *hw = <span class="keyword">new</span> QCamera2HardwareInterface((<span class="keyword">uint32_t</span>)camera_id);</span><br><span class="line">        rc = hw-&gt;openCamera(hw_device);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法有两个关键点：一个是QCamera3HardwareInterface对象的创建，它是用户空间与内核空间进行交互的接口；另一个是调用它的openCamera方法来打开Camera，下面将分别进行分析。</p><h5 id="3-1-1、QCamera3HardwareInterface构造函数分析"><a href="#3-1-1、QCamera3HardwareInterface构造函数分析" class="headerlink" title="3.1.1、QCamera3HardwareInterface构造函数分析"></a>3.1.1、QCamera3HardwareInterface构造函数分析</h5><p>在它的构造函数里面有一个关键的初始化，即mCameraDevice.ops = &amp;mCameraOps，它会定义Device操作的接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">camera3_device_ops_t</span> QCamera3HardwareInterface::mCameraOps = &#123;</span><br><span class="line">    initialize:                         QCamera3HardwareInterface::initialize,</span><br><span class="line">    <span class="comment">//配置流数据的相关处理</span></span><br><span class="line">    configure_streams:                  QCamera3HardwareInterface::configure_streams,</span><br><span class="line">    register_stream_buffers:            <span class="literal">NULL</span>,</span><br><span class="line">    construct_default_request_settings: </span><br><span class="line">        QCamera3HardwareInterface::construct_default_request_settings,</span><br><span class="line">    <span class="comment">//处理结果的接口</span></span><br><span class="line">    process_capture_request:            </span><br><span class="line">        QCamera3HardwareInterface::process_capture_request,</span><br><span class="line">    get_metadata_vendor_tag_ops:        <span class="literal">NULL</span>,</span><br><span class="line">    dump:                               QCamera3HardwareInterface::dump,</span><br><span class="line">    flush:                              QCamera3HardwareInterface::flush,</span><br><span class="line">    reserved:                           &#123;<span class="number">0</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，会在configure_streams中配置好流的处理handle：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::configure_streams(<span class="keyword">const</span> struct camera3_device *device,</span><br><span class="line">        <span class="keyword">camera3_stream_configuration_t</span> *stream_list)&#123;</span><br><span class="line">    <span class="comment">//获得QCamera3HardwareInterface对象</span></span><br><span class="line">    QCamera3HardwareInterface *hw =<span class="keyword">reinterpret_cast</span>&lt;QCamera3HardwareInterface *&gt;(device-&gt;priv);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用它的configureStreams进行配置</span></span><br><span class="line">    <span class="keyword">int</span> rc = hw-&gt;configureStreams(stream_list);</span><br><span class="line">    ..</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续追踪configureStream方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\core\java\android\hardware\camera2\impl\CameraDeviceImpl.java]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::configureStreams(<span class="keyword">camera3_stream_configuration_t</span> *streamList)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化Camera版本</span></span><br><span class="line">    al_version = CAM_HAL_V3;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//开始配置stream</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化相关Channel为NULL</span></span><br><span class="line">    <span class="keyword">if</span> (mMetadataChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mMetadataChannel;</span><br><span class="line">        mMetadataChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSupportChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mSupportChannel;</span><br><span class="line">        mSupportChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAnalysisChannel) &#123;</span><br><span class="line">        <span class="keyword">delete</span> mAnalysisChannel;</span><br><span class="line">        mAnalysisChannel = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Metadata Channel，并对其进行初始化</span></span><br><span class="line">    mMetadataChannel = <span class="keyword">new</span> QCamera3MetadataChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">        mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-&gt;padding_info, </span><br><span class="line">        CAM_QCOM_FEATURE_NONE, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    rc = mMetadataChannel-&gt;initialize(IS_TYPE_NONE);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//如果h/w support可用，则创建分析stream的Channel</span></span><br><span class="line">    <span class="keyword">if</span> (gCamCapability[mCameraId]-&gt;hw_analysis_supported) &#123;</span><br><span class="line">        mAnalysisChannel = <span class="keyword">new</span> QCamera3SupportChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                mCameraHandle-&gt;ops,&amp;gCamCapability[mCameraId]-&gt;padding_info,</span><br><span class="line">                CAM_QCOM_FEATURE_PP_SUPERSET_HAL3,CAM_STREAM_TYPE_ANALYSIS,</span><br><span class="line">                &amp;gCamCapability[mCameraId]-&gt;analysis_recommended_res,<span class="keyword">this</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isRawStreamRequested = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//清空stream配置信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;mStreamConfigInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cam_stream_size_info_t</span>));</span><br><span class="line">    <span class="comment">//为requested stream分配相关的channel对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; streamList-&gt;num_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">camera3_stream_t</span> *newStream = streamList-&gt;streams[i];</span><br><span class="line">        <span class="keyword">uint32_t</span> stream_usage = newStream-&gt;usage;</span><br><span class="line">        mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].width = (<span class="keyword">int32_t</span>)newStream-</span><br><span class="line">                &gt;width;</span><br><span class="line">        mStreamConfigInfo.stream_sizes[mStreamConfigInfo.num_streams].height = (<span class="keyword">int32_t</span>)newStream-</span><br><span class="line">                &gt;height;</span><br><span class="line">        <span class="keyword">if</span> ((newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL||newStream-&gt;usage &amp; </span><br><span class="line">                GRALLOC_USAGE_HW_CAMERA_ZSL) &amp;&amp;newStream-&gt;format == </span><br><span class="line">                HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED &amp;&amp; jpegStream)&#123;</span><br><span class="line">            mStreamConfigInfo.type[mStreamConfigInfo.num_streams] = CAM_STREAM_TYPE_SNAPSHOT;</span><br><span class="line">            mStreamConfigInfo.postprocess_mask[mStreamConfigInfo.num_streams] = </span><br><span class="line">                CAM_QCOM_FEATURE_NONE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (newStream-&gt;format) &#123;</span><br><span class="line">                <span class="comment">//为非zsl streams查找他们的format</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newStream-&gt;priv == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//为新的stream构造Channel</span></span><br><span class="line">            <span class="keyword">switch</span> (newStream-&gt;stream_type) &#123;<span class="comment">//分类型构造</span></span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_INPUT:</span><br><span class="line">                newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_READ;</span><br><span class="line">                newStream-&gt;usage |= GRALLOC_USAGE_HW_CAMERA_WRITE;<span class="comment">//WR for inplace algo's</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_BIDIRECTIONAL:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CAMERA3_STREAM_OUTPUT:</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据前面的得到的stream的参数类型以及format分别对各类型的channel进行构造</span></span><br><span class="line">            <span class="keyword">if</span> (newStream-&gt;stream_type == CAMERA3_STREAM_OUTPUT ||</span><br><span class="line">                    newStream-&gt;stream_type == CAMERA3_STREAM_BIDIRECTIONAL) &#123;</span><br><span class="line">                QCamera3Channel *channel = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">switch</span> (newStream-&gt;format) &#123;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED:</span><br><span class="line">                    <span class="comment">/* use higher number of buffers for HFR mode */</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//创建Regular Channel</span></span><br><span class="line">                    channel = <span class="keyword">new</span> QCamera3RegularChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">                        mCameraHandle-&gt;ops, captureResultCb,&amp;gCamCapability[mCameraId]-</span><br><span class="line">                        &gt;padding_info,<span class="keyword">this</span>,newStream,(<span class="keyword">cam_stream_type_t</span>)mStreamConfigInfo.type[</span><br><span class="line">                        mStreamConfigInfo.num_streams],mStreamConfigInfo.postprocess_mask[</span><br><span class="line">                        mStreamConfigInfo.num_streams],mMetadataChannel,numBuffers);</span><br><span class="line">                    ...</span><br><span class="line">                    newStream-&gt;max_buffers = channel-&gt;getNumBuffers();</span><br><span class="line">                    newStream-&gt;priv = channel;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_YCbCr_420_888:</span><br><span class="line">                    <span class="comment">//创建YWV Channel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW_OPAQUE:</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW16:</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_RAW10:</span><br><span class="line">                    <span class="comment">//创建Raw Channel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> HAL_PIXEL_FORMAT_BLOB:</span><br><span class="line">                    <span class="comment">//创建QCamera3PicChannel</span></span><br><span class="line">                    ...</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStream-&gt;stream_type == CAMERA3_STREAM_INPUT) &#123;</span><br><span class="line">                newStream-&gt;max_buffers = MAX_INFLIGHT_REPROCESS_REQUESTS;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;<span class="keyword">stream_info_t</span>*&gt;::iterator it=mStreamInfo.begin();it != mStreamInfo.end(); </span><br><span class="line">                    it++) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((*it)-&gt;stream == newStream) &#123;</span><br><span class="line">                    (*it)-&gt;channel = (QCamera3Channel*) newStream-&gt;priv;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newStream-&gt;stream_type != CAMERA3_STREAM_INPUT)</span><br><span class="line">            mStreamConfigInfo.num_streams++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isZsl) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPictureChannel) &#123;</span><br><span class="line">           mPictureChannel-&gt;overrideYuvSize(zslStream-&gt;width, zslStream-&gt;height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPictureChannel &amp;&amp; m_bIs4KVideo) &#123;</span><br><span class="line">        mPictureChannel-&gt;overrideYuvSize(videoWidth, videoHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RAW DUMP channel</span></span><br><span class="line">    <span class="keyword">if</span> (mEnableRawDump &amp;&amp; isRawStreamRequested == <span class="literal">false</span>)&#123;</span><br><span class="line">        <span class="keyword">cam_dimension_t</span> rawDumpSize;</span><br><span class="line">        rawDumpSize = getMaxRawSize(mCameraId);</span><br><span class="line">        mRawDumpChannel = <span class="keyword">new</span> QCamera3RawDumpChannel(mCameraHandle-&gt;camera_handle,</span><br><span class="line">            mCameraHandle-&gt;ops,rawDumpSize,&amp;gCamCapability[mCameraId]-&gt;padding_info,</span><br><span class="line">            <span class="keyword">this</span>, CAM_QCOM_FEATURE_NONE);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行相关Channel的配置</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Initialize mPendingRequestInfo and mPendnigBuffersMap */</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;PendingRequestInfo&gt;::iterator i = mPendingRequestsList.begin();</span><br><span class="line">                i != mPendingRequestsList.end(); i++) &#123;</span><br><span class="line">        clearInputBuffer(i-&gt;input_buffer);</span><br><span class="line">        i = mPendingRequestsList.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingFrameDropList.clear();</span><br><span class="line">    <span class="comment">// Initialize/Reset the pending buffers list</span></span><br><span class="line">    mPendingBuffersMap.num_buffers = <span class="number">0</span>;</span><br><span class="line">    mPendingBuffersMap.mPendingBufferList.clear();</span><br><span class="line">    mPendingReprocessResultList.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法内容比较多，只抽取其中核心的代码进行说明，它首先会根据HAL的版本来对stream进行相应的配置初始化，然后再根据stream类型对stream_list的stream创建相应的Channel，主要有QCamera3MetadataChannel，QCamera3SupportChannel等，然后再进行相应的配置，其中QCamera3MetadataChannel在后面的处理capture request的时候会用到，这里就不做分析，而Camerametadata则是Java层和CameraService之间传递的元数据，见android6.0源码分析之Camera API2.0简介中的Camera2架构图，至此，QCamera3HardwareInterface构造结束，与本文相关的就是配置了mCameraDevice.ops。</p><h5 id="3-1-2、openCamera-分析"><a href="#3-1-2、openCamera-分析" class="headerlink" title="3.1.2、openCamera()分析"></a>3.1.2、openCamera()分析</h5><p>本节主要分析Module是如何打开Camera的，openCamera的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::openCamera(struct <span class="keyword">hw_device_t</span> **hw_device)&#123;</span><br><span class="line">    <span class="keyword">int</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOpened) &#123;<span class="comment">//如果Camera已经被打开，则此次打开的设备为NULL，并且打开结果为PERMISSION_DENIED</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调用openCamera方法来打开</span></span><br><span class="line">    rc = openCamera();</span><br><span class="line">    <span class="comment">//打开结果处理</span></span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//获取打开成功的hw_device_t对象</span></span><br><span class="line">        *hw_device = &amp;mCameraDevice.common;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *hw_device = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用了openCamera()方法来打开Camera:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">int</span> QCamera3HardwareInterface::openCamera()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开camera，获取mCameraHandle</span></span><br><span class="line">    mCameraHandle = camera_open((<span class="keyword">uint8_t</span>)mCameraId);</span><br><span class="line">    ...</span><br><span class="line">    mCameraOpened = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//注册mm-camera-interface里的事件处理,其中camEctHandle为事件处理Handle</span></span><br><span class="line">    rc = mCameraHandle-&gt;ops-&gt;register_event_notify(mCameraHandle-&gt;camera_handle,camEvtHandle</span><br><span class="line">            ,(<span class="keyword">void</span> *)<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用camera_open方法来打开Camera，并且向CameraHandle注册了Camera 时间处理的Handle–camEvtHandle，首先分析camera_open方法，这里就将进入高通的Camera的实现了，而Mm_camera_interface.c是高通提供的相关操作的接口，接下来分析高通Camera的camera_open方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\vendor\qcom\proprietary\mm-camera\apps\appslib\mm_camera_interface.c]</span><br><span class="line"><span class="keyword">mm_camera_vtbl_t</span> * camera_open(<span class="keyword">uint8_t</span> camera_idx)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> rc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span>* cam_obj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/* opened already 如果已经打开*/</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != g_cam_ctrl.cam_obj[camera_idx]) &#123;</span><br><span class="line">        <span class="comment">/* Add reference */</span></span><br><span class="line">        g_cam_ctrl.cam_obj[camera_idx]-&gt;ref_count++;</span><br><span class="line">        pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">        <span class="keyword">return</span> &amp;g_cam_ctrl.cam_obj[camera_idx]-&gt;vtbl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cam_obj = (<span class="keyword">mm_camera_obj_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* initialize camera obj */</span></span><br><span class="line">    <span class="built_in">memset</span>(cam_obj, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">mm_camera_obj_t</span>));</span><br><span class="line">    cam_obj-&gt;ctrl_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ds_fd = <span class="number">-1</span>;</span><br><span class="line">    cam_obj-&gt;ref_count++;</span><br><span class="line">    cam_obj-&gt;my_hdl = mm_camera_util_generate_handler(camera_idx);</span><br><span class="line">    cam_obj-&gt;vtbl.camera_handle = cam_obj-&gt;my_hdl; <span class="comment">/* set handler */</span></span><br><span class="line">    <span class="comment">//mm_camera_ops里绑定了相关的操作接口</span></span><br><span class="line">    cam_obj-&gt;vtbl.ops = &amp;mm_camera_ops;</span><br><span class="line">    pthread_mutex_init(&amp;cam_obj-&gt;cam_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;cam_obj-&gt;cam_lock);</span><br><span class="line">    pthread_mutex_unlock(&amp;g_intf_lock);</span><br><span class="line">    <span class="comment">//调用mm_camera_open方法来打开camera</span></span><br><span class="line">    rc = mm_camera_open(cam_obj);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;g_intf_lock);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//结果处理，并返回</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，这里将会初始化一个mm_camera_obj_t对象，其中，ds_fd为socket fd，而mm_camera_ops则绑定了相关的接口，最后调用mm_camera_open来打开Camera，首先来看看mm_camera_ops绑定了哪些方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\vendor\qcom\proprietary\mm-camera\apps\appslib\mm_camera_interface.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mm_camera_ops_t</span> mm_camera_ops = &#123;</span><br><span class="line">    .query_capability = mm_camera_intf_query_capability,</span><br><span class="line">    <span class="comment">//注册事件通知的方法</span></span><br><span class="line">    .register_event_notify = mm_camera_intf_register_event_notify,</span><br><span class="line">    .close_camera = mm_camera_intf_close,</span><br><span class="line">    .set_parms = mm_camera_intf_set_parms,</span><br><span class="line">    .get_parms = mm_camera_intf_get_parms,</span><br><span class="line">    .do_auto_focus = mm_camera_intf_do_auto_focus,</span><br><span class="line">    .cancel_auto_focus = mm_camera_intf_cancel_auto_focus,</span><br><span class="line">    .prepare_snapshot = mm_camera_intf_prepare_snapshot,</span><br><span class="line">    .start_zsl_snapshot = mm_camera_intf_start_zsl_snapshot,</span><br><span class="line">    .stop_zsl_snapshot = mm_camera_intf_stop_zsl_snapshot,</span><br><span class="line">    .map_buf = mm_camera_intf_map_buf,</span><br><span class="line">    .unmap_buf = mm_camera_intf_unmap_buf,</span><br><span class="line">    .add_channel = mm_camera_intf_add_channel,</span><br><span class="line">    .delete_channel = mm_camera_intf_del_channel,</span><br><span class="line">    .get_bundle_info = mm_camera_intf_get_bundle_info,</span><br><span class="line">    .add_stream = mm_camera_intf_add_stream,</span><br><span class="line">    .link_stream = mm_camera_intf_link_stream,</span><br><span class="line">    .delete_stream = mm_camera_intf_del_stream,</span><br><span class="line">    <span class="comment">//配置stream的方法</span></span><br><span class="line">    .config_stream = mm_camera_intf_config_stream,</span><br><span class="line">    .qbuf = mm_camera_intf_qbuf,</span><br><span class="line">    .get_queued_buf_count = mm_camera_intf_get_queued_buf_count,</span><br><span class="line">    .map_stream_buf = mm_camera_intf_map_stream_buf,</span><br><span class="line">    .unmap_stream_buf = mm_camera_intf_unmap_stream_buf,</span><br><span class="line">    .set_stream_parms = mm_camera_intf_set_stream_parms,</span><br><span class="line">    .get_stream_parms = mm_camera_intf_get_stream_parms,</span><br><span class="line">    .start_channel = mm_camera_intf_start_channel,</span><br><span class="line">    .stop_channel = mm_camera_intf_stop_channel,</span><br><span class="line">    .request_super_buf = mm_camera_intf_request_super_buf,</span><br><span class="line">    .cancel_super_buf_request = mm_camera_intf_cancel_super_buf_request,</span><br><span class="line">    .flush_super_buf_queue = mm_camera_intf_flush_super_buf_queue,</span><br><span class="line">    .configure_notify_mode = mm_camera_intf_configure_notify_mode,</span><br><span class="line">    <span class="comment">//处理capture的方法</span></span><br><span class="line">    .process_advanced_capture = mm_camera_intf_process_advanced_capture</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着分析mm_camera_open方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/<span class="built_in">stack</span>/mm-camera-interface/src/mm_camera.c]</span><br><span class="line"><span class="keyword">int32_t</span> mm_camera_open(<span class="keyword">mm_camera_obj_t</span> *my_obj)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        <span class="comment">//根据设备名字，打开相应的设备驱动fd</span></span><br><span class="line">        my_obj-&gt;ctrl_fd = open(dev_name, O_RDWR | O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span>((my_obj-&gt;ctrl_fd &gt;= <span class="number">0</span>) || (errno != EIO) || (n_try &lt;= <span class="number">0</span> )) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开domain socket</span></span><br><span class="line">    n_try = MM_CAMERA_DEV_OPEN_TRIES;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        n_try--;</span><br><span class="line">        my_obj-&gt;ds_fd = mm_camera_socket_create(cam_idx, MM_CAMERA_SOCK_TYPE_UDP);</span><br><span class="line">        usleep(sleep_msec * <span class="number">1000U</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span> (n_try &gt; <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化锁</span></span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;msg_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;cb_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_init(&amp;my_obj-&gt;evt_lock, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;my_obj-&gt;evt_cond, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启线程，它的线程体在mm_camera_dispatch_app_event方法中</span></span><br><span class="line">    mm_camera_cmd_thread_launch(&amp;my_obj-&gt;evt_thread,</span><br><span class="line">                                mm_camera_dispatch_app_event,</span><br><span class="line">                                (<span class="keyword">void</span> *)my_obj);</span><br><span class="line">    mm_camera_poll_thread_launch(&amp;my_obj-&gt;evt_poll_thread,</span><br><span class="line">                                 MM_CAMERA_POLL_TYPE_EVT);</span><br><span class="line">    mm_camera_evt_sub(my_obj, TRUE);</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它会打开Camera的设备文件，然后开启dispatch_app_event线程，线程方法体mm_camera_dispatch_app_event方法代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/hardware/qcom/camera/QCamera2/<span class="built_in">stack</span>/mm-camera-interface/src/mm_camera.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mm_camera_dispatch_app_event</span><span class="params">(<span class="keyword">mm_camera_cmdcb_t</span> *cmd_cb,<span class="keyword">void</span>* user_data)</span></span>&#123;</span><br><span class="line">    mm_camera_cmd_thread_name(<span class="string">"mm_cam_event"</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">mm_camera_event_t</span> *event = &amp;cmd_cb-&gt;u.evt;</span><br><span class="line">    <span class="keyword">mm_camera_obj_t</span> * my_obj = (<span class="keyword">mm_camera_obj_t</span> *)user_data;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != my_obj) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;my_obj-&gt;cb_lock);</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; MM_CAMERA_EVT_ENTRY_MAX; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(my_obj-&gt;evt.evt[i].evt_cb) &#123;</span><br><span class="line">                <span class="comment">//调用camEvtHandle方法</span></span><br><span class="line">                my_obj-&gt;evt.evt[i].evt_cb(</span><br><span class="line">                    my_obj-&gt;my_hdl,</span><br><span class="line">                    event,</span><br><span class="line">                    my_obj-&gt;evt.evt[i].user_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;my_obj-&gt;cb_lock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后会调用mm-camera-interface中注册好的事件处理evt_cb，它就是在前面注册好的camEvtHandle：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::camEvtHandle(<span class="keyword">uint32_t</span> <span class="comment">/*camera_handle*/</span>,<span class="keyword">mm_camera_event_t</span> *evt,</span><br><span class="line">        <span class="keyword">void</span> *user_data)&#123;</span><br><span class="line">    <span class="comment">//获取QCamera3HardwareInterface接口指针</span></span><br><span class="line">    QCamera3HardwareInterface *obj = (QCamera3HardwareInterface *)user_data;</span><br><span class="line">    <span class="keyword">if</span> (obj &amp;&amp; evt) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(evt-&gt;server_event_type) &#123;</span><br><span class="line">            <span class="keyword">case</span> CAM_EVENT_TYPE_DAEMON_DIED:</span><br><span class="line">                <span class="keyword">camera3_notify_msg_t</span> notify_msg;</span><br><span class="line">                <span class="built_in">memset</span>(&amp;notify_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">camera3_notify_msg_t</span>));</span><br><span class="line">                notify_msg.type = CAMERA3_MSG_ERROR;</span><br><span class="line">                notify_msg.message.error.error_code = CAMERA3_MSG_ERROR_DEVICE;</span><br><span class="line">                notify_msg.message.error.error_stream = <span class="literal">NULL</span>;</span><br><span class="line">                notify_msg.message.error.frame_number = <span class="number">0</span>;</span><br><span class="line">                obj-&gt;mCallbackOps-&gt;notify(obj-&gt;mCallbackOps, &amp;notify_msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CAM_EVENT_TYPE_DAEMON_PULL_REQ:</span><br><span class="line">                pthread_mutex_lock(&amp;obj-&gt;mMutex);</span><br><span class="line">                obj-&gt;mWokenUpByDaemon = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//开启process_capture_request</span></span><br><span class="line">                obj-&gt;unblockRequestIfNecessary();</span><br><span class="line">                pthread_mutex_unlock(&amp;obj-&gt;mMutex);</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它会调用QCamera3HardwareInterface的unblockRequestIfNecessary来发起结果处理请求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\camera\QCamera2\HAL3\QCamera3HWI.cpp]</span><br><span class="line"><span class="keyword">void</span> QCamera3HardwareInterface::unblockRequestIfNecessary()</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Unblock process_capture_request</span></span><br><span class="line">   <span class="comment">//开启process_capture_request</span></span><br><span class="line">   pthread_cond_signal(&amp;mRequestCond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化QCamera3HardwareInterface对象的时候，就绑定了处理Metadata的回调captureResultCb方法：它主要是对数据源进行相应的处理，而具体的capture请求的结果处理还是由process_capture_request来进行处理的，而这里会调用方法unblockRequestIfNecessary来触发process_capture_request方法执行，而在Camera框架中，发起请求时会启动一个RequestThread线程，在它的threadLoop方法中，会不停的调用process_capture_request方法来进行请求的处理，而它最后会回调Camera3Device中的processCaptureResult方法来进行结果处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::processCaptureResult(<span class="keyword">const</span> camera3_capture_result *result) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (mUsePartialResult &amp;&amp; result-&gt;result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDeviceVersion &gt;= CAMERA_DEVICE_API_VERSION_3_2) &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                    request.partialResult.collectedResult.append(result-&gt;result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">camera_metadata_ro_entry_t</span> partialResultEntry;</span><br><span class="line">                res = find_camera_metadata_ro_entry(result-&gt;result,</span><br><span class="line">                        ANDROID_QUIRKS_PARTIAL_RESULT, &amp;partialResultEntry);</span><br><span class="line">                <span class="keyword">if</span> (res != NAME_NOT_FOUND &amp;&amp;partialResultEntry.count &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        partialResultEntry.data.u8[<span class="number">0</span>] ==ANDROID_QUIRKS_PARTIAL_RESULT_PARTIAL) &#123;</span><br><span class="line">                    isPartialResult = <span class="literal">true</span>;</span><br><span class="line">                    request.partialResult.collectedResult.append(</span><br><span class="line">                        result-&gt;result);</span><br><span class="line">                    request.partialResult.collectedResult.erase(</span><br><span class="line">                        ANDROID_QUIRKS_PARTIAL_RESULT);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPartialResult) &#123;</span><br><span class="line">                <span class="comment">// Fire off a 3A-only result if possible</span></span><br><span class="line">                <span class="keyword">if</span> (!request.partialResult.haveSent3A) &#123;</span><br><span class="line">                    <span class="comment">//处理3A结果</span></span><br><span class="line">                    request.partialResult.haveSent3A =processPartial3AResult(frameNumber,</span><br><span class="line">                        request.partialResult.collectedResult,request.resultExtras);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//查找camera元数据入口</span></span><br><span class="line">        <span class="keyword">camera_metadata_ro_entry_t</span> entry;</span><br><span class="line">        res = find_camera_metadata_ro_entry(result-&gt;result,</span><br><span class="line">                ANDROID_SENSOR_TIMESTAMP, &amp;entry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">            request.pendingOutputBuffers.appendArray(result-&gt;output_buffers,</span><br><span class="line">                result-&gt;num_output_buffers);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            重要的分析<span class="comment">//返回处理的outputbuffer</span></span><br><span class="line">            returnOutputBuffers(result-&gt;output_buffers,</span><br><span class="line">                result-&gt;num_output_buffers, shutterTimestamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result-&gt;result != <span class="literal">NULL</span> &amp;&amp; !isPartialResult) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shutterTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">                request.pendingMetadata = result-&gt;result;</span><br><span class="line">                request.partialResult.collectedResult = collectedPartialResult;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                CameraMetadata metadata;</span><br><span class="line">                metadata = result-&gt;result;</span><br><span class="line">                <span class="comment">//发送Capture结构，即调用通知回调</span></span><br><span class="line">                sendCaptureResult(metadata, request.resultExtras,</span><br><span class="line">                    collectedPartialResult, frameNumber, hasInputBufferInRequest,</span><br><span class="line">                    request.aeTriggerCancelOverride);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        removeInFlightRequestIfReadyLocked(idx);</span><br><span class="line">    &#125; <span class="comment">// scope for mInFlightLock</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result-&gt;input_buffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasInputBufferInRequest) &#123;</span><br><span class="line">            Camera3Stream *stream =</span><br><span class="line">                Camera3Stream::cast(result-&gt;input_buffer-&gt;stream);</span><br><span class="line">            重要的分析<span class="comment">//返回处理的inputbuffer</span></span><br><span class="line">            res = stream-&gt;returnInputBuffer(*(result-&gt;input_buffer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析returnOutputBuffers方法，inputbuffer的runturnInputBuffer方法流程类似：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Device.cpp]</span><br><span class="line"><span class="keyword">void</span> Camera3Device::returnOutputBuffers(<span class="keyword">const</span> <span class="keyword">camera3_stream_buffer_t</span> *outputBuffers, <span class="keyword">size_t</span> </span><br><span class="line">        numBuffers, <span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numBuffers; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Camera3Stream *stream = Camera3Stream::cast(outputBuffers[i].stream);</span><br><span class="line">        <span class="keyword">status_t</span> res = stream-&gt;returnBuffer(outputBuffers[i], timestamp);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法里调用了returnBuffer方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3Stream.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Stream::returnBuffer(<span class="keyword">const</span> camera3_stream_buffer &amp;buffer,<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">    <span class="comment">//返回buffer</span></span><br><span class="line">    <span class="keyword">status_t</span> res = returnBufferLocked(buffer, timestamp);</span><br><span class="line">    <span class="keyword">if</span> (res == OK) &#123;</span><br><span class="line">        fireBufferListenersLocked(buffer, <span class="comment">/*acquired*/</span><span class="literal">false</span>, <span class="comment">/*output*/</span><span class="literal">true</span>);</span><br><span class="line">        mOutputBufferReturnedSignal.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再继续看returnBufferLocked,它调用了returnAnyBufferLocked方法，而returnAnyBufferLocked方法又调用了returnBufferCheckedLocked方法，现在分析returnBufferCheckedLocked：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/frameworks/av/services/camera/libcameraservice/device3/Camera3OutputStream.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3OutputStream::returnBufferCheckedLocked(<span class="keyword">const</span> camera3_stream_buffer &amp;buffer,</span><br><span class="line">            <span class="keyword">nsecs_t</span> timestamp,<span class="keyword">bool</span> output,<span class="comment">/*out*/</span>sp&lt;Fence&gt; *releaseFenceOut) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Fence management - always honor release fence from HAL</span></span><br><span class="line">    sp&lt;Fence&gt; releaseFence = <span class="keyword">new</span> Fence(buffer.release_fence);</span><br><span class="line">    <span class="keyword">int</span> anwReleaseFence = releaseFence-&gt;dup();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer.status == CAMERA3_BUFFER_STATUS_ERROR) &#123;</span><br><span class="line">        <span class="comment">// Cancel buffer</span></span><br><span class="line">        res = currentConsumer-&gt;cancelBuffer(currentConsumer.get(),</span><br><span class="line">                container_of(buffer.buffer, ANativeWindowBuffer, handle),</span><br><span class="line">                anwReleaseFence);</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        res = currentConsumer-&gt;queueBuffer(currentConsumer.get(),</span><br><span class="line">                container_of(buffer.buffer, ANativeWindowBuffer, handle),</span><br><span class="line">                anwReleaseFence);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，如果Buffer没有出现状态错误，它会调用currentConsumer的queueBuffer方法，而具体的Consumer则是在应用层初始化Camera时进行绑定的，典型的Consumer有SurfaceTexture，ImageReader等，而在Native层中，它会调用BufferQueueProducer的queueBuffer方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\native\libs\gui\BufferQueueProducer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> BufferQueueProducer::queueBuffer(<span class="keyword">int</span> slot,</span><br><span class="line">        <span class="keyword">const</span> QueueBufferInput &amp;input, QueueBufferOutput *output) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化Frame可用的监听器</span></span><br><span class="line">    sp&lt;IConsumerListener&gt; frameAvailableListener;</span><br><span class="line">    sp&lt;IConsumerListener&gt; frameReplacedListener;</span><br><span class="line">    <span class="keyword">int</span> callbackTicket = <span class="number">0</span>;</span><br><span class="line">    BufferItem item;</span><br><span class="line">    &#123; <span class="comment">// Autolock scope</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">const</span> sp&lt;GraphicBuffer&gt;&amp; graphicBuffer(mSlots[slot].mGraphicBuffer);</span><br><span class="line">        Rect bufferRect(graphicBuffer-&gt;getWidth(), graphicBuffer-&gt;getHeight());</span><br><span class="line">        Rect croppedRect;</span><br><span class="line">        crop.intersect(bufferRect, &amp;croppedRect);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (mCore-&gt;mQueue.empty()) &#123;</span><br><span class="line">            mCore-&gt;mQueue.push_back(item);</span><br><span class="line">            frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，不为空，对Buffer进行处理，并获取FrameAvailableListener监听</span></span><br><span class="line">            BufferQueueCore::Fifo::iterator front(mCore-&gt;mQueue.begin());</span><br><span class="line">            <span class="keyword">if</span> (front-&gt;mIsDroppable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mCore-&gt;stillTracking(front)) &#123;</span><br><span class="line">                    mSlots[front-&gt;mSlot].mBufferState = BufferSlot::FREE;</span><br><span class="line">                    mCore-&gt;mFreeBuffers.push_front(front-&gt;mSlot);</span><br><span class="line">                &#125;</span><br><span class="line">                *front = item;</span><br><span class="line">                frameReplacedListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mCore-&gt;mQueue.push_back(item);</span><br><span class="line">                frameAvailableListener = mCore-&gt;mConsumerListener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;mBufferHasBeenQueued = <span class="literal">true</span>;</span><br><span class="line">        mCore-&gt;mDequeueCondition.broadcast();</span><br><span class="line"></span><br><span class="line">        output-&gt;inflate(mCore-&gt;mDefaultWidth, mCore-&gt;mDefaultHeight,mCore-&gt;mTransformHint,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(mCore-&gt;mQueue.size()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Take a ticket for the callback functions</span></span><br><span class="line">        callbackTicket = mNextCallbackTicket++;</span><br><span class="line"></span><br><span class="line">        mCore-&gt;validateConsistencyLocked();</span><br><span class="line">    &#125; <span class="comment">// Autolock scope</span></span><br><span class="line">    ...</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (frameAvailableListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">//回调SurfaceTexture中定义好的监听IConsumerListener的onFrameAvailable方法来对数据进行处理</span></span><br><span class="line">            frameAvailableListener-&gt;onFrameAvailable(item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frameReplacedListener != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            frameReplacedListener-&gt;onFrameReplaced(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++mCurrentCallbackTicket;</span><br><span class="line">        mCallbackCondition.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它最后会调用Consumer的回调FrameAvailableListener的onFrameAvailable方法，到这里，就比较清晰为什么我们在写Camera应用，为其初始化Surface时，我们需要重写FrameAvailableListener了，因为在此方法里面，会进行结果的处理，至此，Camera HAL的Open流程就分析结束了。下面给出流程的时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-15-open_camera.png" alt="Alt text"></p><h4 id="（四）、Camera-API2-0-初始化流程分析"><a href="#（四）、Camera-API2-0-初始化流程分析" class="headerlink" title="（四）、Camera API2.0 初始化流程分析"></a>（四）、Camera API2.0 初始化流程分析</h4><h5 id="4-1、Camera2-应用层（Java层）Open-过程分析"><a href="#4-1、Camera2-应用层（Java层）Open-过程分析" class="headerlink" title="4.1、Camera2 应用层（Java层）Open()过程分析"></a>4.1、Camera2 应用层（Java层）Open()过程分析</h5><p>Camera2的初始化流程与Camera1.0有所区别，本文将就Camera2的内置应用来分析Camera2.0的初始化过程。Camera2.0首先启动的是CameraActivity，而它继承自QuickActivity，在代码中你会发现没有重写OnCreate等生命周期方法，因为此处采用的是模板方法的设计模式，在QuickActivity中的onCreate方法调用的是onCreateTasks等方法，所以要看onCreate方法就只须看onCreateTasks方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CameraActivity.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateTasks</span><span class="params">(Bundle state)</span> </span>&#123;</span><br><span class="line">    Profile profile = mProfiler.create(<span class="string">"CameraActivity.onCreateTasks"</span>)</span><br><span class="line">                            .start();</span><br><span class="line">    ...</span><br><span class="line">    mOnCreateTime = System.currentTimeMillis();</span><br><span class="line">    mAppContext = getApplicationContext();</span><br><span class="line">    mMainHandler = <span class="keyword">new</span> MainHandler(<span class="keyword">this</span>, getMainLooper());</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初始化OneCameraOpener对象</span></span><br><span class="line">        ①mOneCameraOpener = OneCameraModule.provideOneCameraOpener(</span><br><span class="line">                mFeatureConfig, mAppContext,mActiveCameraDeviceTracker,</span><br><span class="line">                ResolutionUtil.getDisplayMetrics(<span class="keyword">this</span>));</span><br><span class="line">        mOneCameraManager = OneCameraModule.provideOneCameraManager();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OneCameraException e) &#123;...&#125;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//建立模块信息</span></span><br><span class="line">    ②ModulesInfo.setupModules(mAppContext, mModuleManager, mFeatureConfig);</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//进行初始化</span></span><br><span class="line">    ③mCurrentModule.init(<span class="keyword">this</span>, isSecureCamera(), isCaptureIntent());</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，重要的有以上三点，先看第一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OneCameraOpener <span class="title">provideOneCameraOpener</span><span class="params">(OneCameraFeatureConfig     </span></span></span><br><span class="line"><span class="function"><span class="params">            featureConfig, Context context, ActiveCameraDeviceTracker </span></span></span><br><span class="line"><span class="function"><span class="params">            activeCameraDeviceTracker,DisplayMetrics displayMetrics)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> OneCameraException </span>&#123;</span><br><span class="line">    <span class="comment">//创建OneCameraOpener对象</span></span><br><span class="line">    Optional&lt;OneCameraOpener&gt; manager = Camera2OneCameraOpenerImpl.create(</span><br><span class="line">              featureConfig, context, activeCameraDeviceTracker, displayMetrics);</span><br><span class="line">    <span class="keyword">if</span> (!manager.isPresent()) &#123;</span><br><span class="line">        manager = LegacyOneCameraOpenerImpl.create();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> manager.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用Camera2OneCameraOpenerImpl的create方法来获得一个OneCameraOpener对象，以供CameraActivity之后的操作使用，继续看create方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/OneCameraModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Optional&lt;OneCameraOpener&gt; <span class="title">create</span><span class="params">(OneCameraFeatureConfig </span></span></span><br><span class="line"><span class="function"><span class="params">            featureConfig, Context context, ActiveCameraDeviceTracker </span></span></span><br><span class="line"><span class="function"><span class="params">            activeCameraDeviceTracker, DisplayMetrics displayMetrics)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    CameraManager cameraManager;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cameraManager = AndroidServices.instance().provideCameraManager();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;...&#125;</span><br><span class="line">    <span class="comment">//新建一个Camera2OneCameraOpenerImpl对象</span></span><br><span class="line">    OneCameraOpener oneCameraOpener = <span class="keyword">new</span> Camera2OneCameraOpenerImpl(</span><br><span class="line">                featureConfig, context, cameraManager,</span><br><span class="line">                activeCameraDeviceTracker, displayMetrics);</span><br><span class="line">    <span class="keyword">return</span> Optional.of(oneCameraOpener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，它首先获取一个cameraManger对象，然后根据这个cameraManager对象来新创建了一个Camera2OneCameraOpenerImpl对象，所以第一步主要是为了获取一个OneCameraOpener对象，它的实现为Camera2OneCameraOpenerImpl类。<br>继续看第二步，ModulesInfo.setupModules:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/<span class="keyword">module</span>/ModulesInfo.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setupModules</span><span class="params">(Context context, ModuleManager moduleManager,</span></span></span><br><span class="line"><span class="function"><span class="params">            OneCameraFeatureConfig config)</span> </span>&#123;</span><br><span class="line">        Resources res = context.getResources();</span><br><span class="line">        <span class="keyword">int</span> photoModuleId = context.getResources().getInteger(</span><br><span class="line">            R.integer.camera_mode_photo);</span><br><span class="line">        <span class="comment">//注册Photo模块</span></span><br><span class="line">        registerPhotoModule(moduleManager, photoModuleId, </span><br><span class="line">            SettingsScopeNamespaces.PHOTO,config.isUsingCaptureModule());</span><br><span class="line">        <span class="comment">//计算你还Photo模块设置为默认的模块</span></span><br><span class="line">        moduleManager.setDefaultModuleIndex(photoModuleId);</span><br><span class="line">        <span class="comment">//注册Videa模块</span></span><br><span class="line">        registerVideoModule(moduleManager, res.getInteger(</span><br><span class="line">            R.integer.camera_mode_video),SettingsScopeNamespaces.VIDEO);</span><br><span class="line">        <span class="keyword">if</span> (PhotoSphereHelper.hasLightCycleCapture(context)) &#123;<span class="comment">//开启闪光</span></span><br><span class="line">            <span class="comment">//注册广角镜头</span></span><br><span class="line">            registerWideAngleModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_panorama),SettingsScopeNamespaces</span><br><span class="line">                .PANORAMA);</span><br><span class="line">            <span class="comment">//注册光球模块</span></span><br><span class="line">            registerPhotoSphereModule(moduleManager,res.getInteger(</span><br><span class="line">                R.integer.camera_mode_photosphere),</span><br><span class="line">                SettingsScopeNamespaces.PANORAMA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若需重新聚焦</span></span><br><span class="line">        <span class="keyword">if</span> (RefocusHelper.hasRefocusCapture(context)) &#123;</span><br><span class="line">            <span class="comment">//注册重聚焦模块</span></span><br><span class="line">            registerRefocusModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_refocus),</span><br><span class="line">                SettingsScopeNamespaces.REFOCUS);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有色分离模块</span></span><br><span class="line">        <span class="keyword">if</span> (GcamHelper.hasGcamAsSeparateModule(config)) &#123;</span><br><span class="line">            <span class="comment">//注册色分离模块</span></span><br><span class="line">            registerGcamModule(moduleManager, res.getInteger(</span><br><span class="line">                R.integer.camera_mode_gcam),SettingsScopeNamespaces.PHOTO,</span><br><span class="line">                config.getHdrPlusSupportLevel(OneCamera.Facing.BACK));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> imageCaptureIntentModuleId = res.getInteger(</span><br><span class="line">            R.integer.camera_mode_capture_intent);</span><br><span class="line">        registerCaptureIntentModule(moduleManager, </span><br><span class="line">            imageCaptureIntentModuleId,SettingsScopeNamespaces.PHOTO,</span><br><span class="line">            config.isUsingCaptureModule());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码根据配置信息，进行一系列模块的注册，其中PhotoModule和VideoModule被注册，而其他的module则是根据配置来进行的，因为打开Camera应用，既可以拍照片也可以拍视频，此处，只分析PhoneModule的注册：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/<span class="keyword">module</span>/ModulesInfo.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerPhotoModule</span><span class="params">(ModuleManager moduleManager, final </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> moduleId, final String <span class="keyword">namespace</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">            final boolean enableCaptureModule)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//向ModuleManager注册PhotoModule模块</span></span><br><span class="line">        moduleManager.registerModule(<span class="keyword">new</span> ModuleManager.ModuleAgent() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">int</span> getModuleId() &#123;</span><br><span class="line">                <span class="keyword">return</span> moduleId;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> boolean requestAppForCamera() &#123;</span><br><span class="line">                <span class="keyword">return</span> !enableCaptureModule;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> String getScopeNamespace() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">namespace</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            <span class="keyword">public</span> ModuleController createModule(AppController app, Intent </span><br><span class="line">                    intent) &#123;</span><br><span class="line">                Log.v(TAG, <span class="string">"EnableCaptureModule = "</span> + enableCaptureModule);</span><br><span class="line">                <span class="comment">//创建ModuleController</span></span><br><span class="line">                <span class="keyword">return</span> enableCaptureModule ? <span class="keyword">new</span> CaptureModule(app) </span><br><span class="line">                        : <span class="keyword">new</span> PhotoModule(app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，它最终是由ModuleManager来新建一个CaptureModule实例，而CaptureModule其实实现了ModuleController ，即创建了一个CaptureModule模式下的ModuleController对象，而真正的CaptureModule的具体实现为ModuleManagerImpl。<br>至此，前两步已经获得了OneCameraOpener以及新建了ModuleController，并进行了注册，接下来分析第三步，mCurrentModule.init(this, isSecureCamera(), isCaptureIntent()):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(CameraActivity activity, <span class="keyword">boolean</span> isSecureCamera, <span class="keyword">boolean</span> </span></span></span><br><span class="line"><span class="function"><span class="params">            isCaptureIntent)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"CaptureModule.mCameraHandler"</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        mCameraHandler = <span class="keyword">new</span> Handler(thread.getLooper());</span><br><span class="line">        <span class="comment">//获取第一步中创建的OneCameraOpener对象</span></span><br><span class="line">        mOneCameraOpener = mAppController.getCameraOpener();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取前面创建的OneCameraManager对象</span></span><br><span class="line">            mOneCameraManager = OneCameraModule.provideOneCameraManager();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (OneCameraException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Unable to provide a OneCameraManager. "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">       `...</span><br><span class="line">        <span class="comment">//新建CaptureModule的UI</span></span><br><span class="line">        mUI = <span class="keyword">new</span> CaptureModuleUI(activity, mAppController.</span><br><span class="line">                getModuleLayoutRoot(), mUIListener);</span><br><span class="line">        <span class="comment">//设置预览状态的监听</span></span><br><span class="line">        mAppController.setPreviewStatusListener(mPreviewStatusListener);</span><br><span class="line">        <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">            <span class="comment">//获取SurfaceTexture</span></span><br><span class="line">            mPreviewSurfaceTexture = mAppController.getCameraAppUI()</span><br><span class="line">                .getSurfaceTexture();</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取前面创建的OneCameraOpener对象以及OneCameraManager对象，然后再设置预览状态监听，这里主要分析预览状态的监听：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PreviewStatusListener mPreviewStatusListener = <span class="keyword">new</span> </span><br><span class="line">    PreviewStatusListener() &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureAvailable</span><span class="params">(SurfaceTexture surface, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            updatePreviewTransform(width, height, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">                mPreviewSurfaceTexture = surface;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打开Camera</span></span><br><span class="line">            reopenCamera();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onSurfaceTextureDestroyed</span><span class="params">(SurfaceTexture surface)</span> </span>&#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"onSurfaceTextureDestroyed"</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (mSurfaceTextureLock) &#123;</span><br><span class="line">                mPreviewSurfaceTexture = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//关闭Camera</span></span><br><span class="line">            closeCamera();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceTextureSizeChanged</span><span class="params">(SurfaceTexture surface, </span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//更新预览尺寸</span></span><br><span class="line">            updatePreviewBufferSize();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">``` </span><br><span class="line">由代码可知，当SurfaceTexture的状态变成可用的时候，会调用reopenCamera()方法来打开Camera，所以继续分析reopenCamera()方法：</span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reopenCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AsyncTask.THREAD_POOL_EXECUTOR.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            closeCamera();</span><br><span class="line">            <span class="keyword">if</span>(!mAppController.isPaused()) &#123;</span><br><span class="line">                <span class="comment">//开启Camera并开始预览</span></span><br><span class="line">                openCameraAndStartPreview();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">它采用异步任务的方法，开启一个异步线程来进行启动操作，首先关闭打开的Camera，然后如果AppController不处于暂停状态，则打开Camera并启动Preview操作，所以继续分析openCameraAndStartPreview方法：</span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/CaptureModule.java]</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCameraAndStartPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mOneCameraOpener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"no available OneCameraManager, showing error dialog"</span>);</span><br><span class="line">        <span class="comment">//释放CameraOpenCloseLock锁</span></span><br><span class="line">        mCameraOpenCloseLock.release();</span><br><span class="line">        mAppController.getFatalErrorHandler().onGenericCameraAccessFailure();</span><br><span class="line">        guard.stop(<span class="string">"No OneCameraManager"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Derive objects necessary for camera creation.</span></span><br><span class="line">    MainThread mainThread = MainThread.create();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找需要打开的CameraId</span></span><br><span class="line">    CameraId cameraId = mOneCameraManager.findFirstCameraFacing(</span><br><span class="line">        mCameraFacing);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//打开Camera</span></span><br><span class="line">    mOneCameraOpener.open(cameraId, captureSetting, mCameraHandler,</span><br><span class="line">        mainThread, imageRotationCalculator, mBurstController, </span><br><span class="line">        mSoundPlayer,<span class="keyword">new</span> OpenCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//进行失败的处理</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCameraOpened</span><span class="params">(@Nonnull <span class="keyword">final</span> OneCamera camera)</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"onCameraOpened: "</span> + camera);</span><br><span class="line">                mCamera = camera;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mAppController.isPaused()) &#123;</span><br><span class="line">                    onFailure();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">//通知UI，Camera状态变化</span></span><br><span class="line">                        mAppController.getCameraAppUI().onChangeCamera();</span><br><span class="line">                        <span class="comment">//使能拍照按钮</span></span><br><span class="line">                        mAppController.getButtonManager().enableCameraButton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">//至此，Camera打开成功，开始预览                    </span></span><br><span class="line">                camera.startPreview(<span class="keyword">new</span> Surface(getPreviewSurfaceTexture()), </span><br><span class="line">                    <span class="keyword">new</span> CaptureReadyCallback() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSetupFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            ...</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReadyForCapture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="comment">//释放锁</span></span><br><span class="line">                            mCameraOpenCloseLock.release();</span><br><span class="line">                            mMainThread.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                    ...</span><br><span class="line">                                    onPreviewStarted();</span><br><span class="line">                                    ...</span><br><span class="line">                                    onReadyStateChanged(<span class="keyword">true</span>);</span><br><span class="line">                                    <span class="comment">//设置CaptureModule为Capture准备的状态监听</span></span><br><span class="line">                                    mCamera.setReadyStateChangedListener(</span><br><span class="line">                                        CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                                        mUI.initializeZoom(mCamera.getMaxZoom());                                 </span><br><span class="line">                                        mCamera.setFocusStateListener(</span><br><span class="line">                                            CaptureModule.<span class="keyword">this</span>);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; </span><br><span class="line">              &#125;, mAppController.getFatalErrorHandler());</span><br><span class="line">        guard.stop(<span class="string">"mOneCameraOpener.open()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">首先，它主要会调用Camera2OneCameraOpenerImpl的open方法来打开Camera，并定义了开启的回调函数，对开启结束后的结果进行处理，如失败则释放mCameraOpenCloseLock，并暂停mAppController，如果打开成功，通知UI成功，并开启Camera的Preview，并且定义了Preview的各种回调操作，这里主要分析Open过程，所以继续分析：</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line">[-&gt;/packages/apps/Camera2/src/com/android/camera/one/v2/Camera2OneCameraOpenerImpl.java]</span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">    mActiveCameraDeviceTracker.onCameraOpening(cameraKey)</span></span>;</span><br><span class="line">    <span class="comment">//打开Camera，此处调用框架层的CameraManager类的openCamera，进入frameworks层</span></span><br><span class="line">    mCameraManager.openCamera(cameraKey.getValue(), </span><br><span class="line">        <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isFirstCallback = <span class="keyword">true</span>;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(CameraDevice device)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//第一次调用此回调</span></span><br><span class="line">            <span class="keyword">if</span> (isFirstCallback) &#123;</span><br><span class="line">                isFirstCallback = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    CameraCharacteristics characteristics = mCameraManager</span><br><span class="line">                        .getCameraCharacteristics(device.getId());</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//创建OneCamera对象</span></span><br><span class="line">                    OneCamera oneCamera = OneCameraCreator.create(device,</span><br><span class="line">                        characteristics, mFeatureConfig, captureSetting,</span><br><span class="line">                        mDisplayMetrics, mContext, mainThread,</span><br><span class="line">                        imageRotationCalculator, burstController, soundPlayer,</span><br><span class="line">                        fatalErrorHandler);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (oneCamera != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果oneCamera不为空，则回调onCameraOpened，后面将做分析</span></span><br><span class="line">                        openCallback.onCameraOpened(oneCamera);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ...</span><br><span class="line">                        openCallback.onFailure();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                    openCallback.onFailure();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OneCameraAccessException e) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Could not create OneCamera"</span>, e);</span><br><span class="line">                    openCallback.onFailure();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>至此，Camera的初始化流程中应用层的分析就差不多了，下一步将会调用CameraManager的openCamera方法来进入框架层，并进行Camera的初始化，下面将应用层的初始化时序图： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-16-camera_open_java.png" alt="Alt text"></p><h5 id="4-2、Camera2-框架层（JNI-amp-Native）Open-过程分析"><a href="#4-2、Camera2-框架层（JNI-amp-Native）Open-过程分析" class="headerlink" title="4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析"></a>4.2、Camera2 框架层（JNI &amp; Native）Open()过程分析</h5><p>由上面的分析可知，将由应用层进入到框架层处理，将会调用CameraManager的openCamera方法，并且定义了CameraDevice的状态回调函数，具体的回调操作此处不做分析，继续跟踪openCamera()方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)</span></span><br><span class="line">@RequiresPermission(android.Manifest.permission.CAMERA)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(@NonNull String cameraId,@NonNull final </span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, @Nullable Handler handler)</span></span></span><br><span class="line"><span class="function">        throws CameraAccessException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    openCameraDeviceUserAsync(cameraId, callback, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由代码可知，此处与Camera1.0有明显不同，Camera1.0是通过一个异步的线程以及JNI来调用android_hardware_camera.java里面的native_setup方法来连接Camera，其使用的是C++的Binder来与CameraService进行通信的，而此处则不一样，它直接使用的是Java层的Binder来进行通信，先看openCameraDeviceUserAsync代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CameraManager.java(frameworks/base/core/java/android/hardware/camera2)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> CameraDevice <span class="title">openCameraDeviceUserAsync</span><span class="params">(String cameraId,</span></span></span><br><span class="line"><span class="function"><span class="params">        CameraDevice.StateCallback callback, Handler handler)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CameraAccessException </span>&#123;</span><br><span class="line">    CameraCharacteristics characteristics = getCameraCharacteristics(</span><br><span class="line">        cameraId);</span><br><span class="line">    CameraDevice device = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            ICameraDeviceUser cameraUser = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//初始化一个CameraDevice对象</span></span><br><span class="line">            android.hardware.camera2.impl.CameraDeviceImpl deviceImpl =</span><br><span class="line">                <span class="keyword">new</span> android.hardware.camera2.impl.CameraDeviceImpl(cameraId,</span><br><span class="line">                callback, handler, characteristics);</span><br><span class="line">            BinderHolder holder = <span class="keyword">new</span> BinderHolder();</span><br><span class="line">            <span class="comment">//获取回调</span></span><br><span class="line">            ICameraDeviceCallbacks callbacks = deviceImpl.getCallbacks();</span><br><span class="line">            <span class="keyword">int</span> id = Integer.parseInt(cameraId);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (supportsCamera2ApiLocked(cameraId)) &#123;</span><br><span class="line">                    <span class="comment">//通过Java层的Binder获取CameraService                        </span></span><br><span class="line">                    ICameraService cameraService = CameraManagerGlobal.get()</span><br><span class="line">                        .getCameraService();</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//通过CameraService连接Camera设备</span></span><br><span class="line">                    cameraService.connectDevice(callbacks, id, mContext</span><br><span class="line">                        .getOpPackageName(), USE_CALLING_UID, holder);</span><br><span class="line">                    <span class="comment">//获取连接成功的CameraUser对象，它用来与CameraService通信</span></span><br><span class="line">                    cameraUser = ICameraDeviceUser.Stub.asInterface(</span><br><span class="line">                        holder.getBinder());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//使用遗留的API</span></span><br><span class="line">                    cameraUser = CameraDeviceUserShim.connectBinderShim(</span><br><span class="line">                        callbacks, id);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CameraRuntimeException e) &#123;</span><br><span class="line">                ...</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//将其包装成DeviceImpl对象，供应用层使用</span></span><br><span class="line">            deviceImpl.setRemoteDevice(cameraUser);</span><br><span class="line">            device = deviceImpl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.asChecked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的目的是通过CameraService来连接并获取CameraDevice对象，该对象用来与Camera进行通信操作。代码首先通过Java层的Binder机制获取CameraService，然后调用其connectDevice方法来连接CaneraDevice，最后Camera返回的是CameraDeviceUser对象，而接着将其封装成Jav层CameraDevice对象，而之后所有与Camera的通信都通过CameraDevice的接口来进行。接下来分析一下Native层下的CameraDevice的初始化过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.cpp]</span><br><span class="line"><span class="comment">//CameraService.cpp，其中device为输出对象</span></span><br><span class="line"><span class="keyword">status_t</span> CameraService::connectDevice(<span class="keyword">const</span> sp&lt;ICameraDeviceCallbacks&gt;&amp; cameraCb,<span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,<span class="keyword">int</span> clientUid,<span class="comment">/*out*/</span>sp&lt;ICameraDeviceUser&gt;&amp; device) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> ret = NO_ERROR;</span><br><span class="line">    String8 id = String8::format(<span class="string">"%d"</span>, cameraId);</span><br><span class="line">    sp&lt;CameraDeviceClient&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    ret = connectHelper&lt;ICameraDeviceCallbacks,CameraDeviceClient&gt;(cameraCb, id,</span><br><span class="line">            CAMERA_HAL_API_VERSION_UNSPECIFIED, clientPackageName, clientUid, API_2, <span class="literal">false</span>, <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">/*out*/</span>client);<span class="comment">//client为输出对象</span></span><br><span class="line">    ...</span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Native层的connectDevice方法就是调用了connectHelper方法，所以继续分析connectHelper：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.h]</span><br><span class="line"><span class="comment">//CameraService.h</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">CALLBACK</span>, <span class="title">class</span> <span class="title">CLIENT</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">CameraService</span>:</span>:connectHelper(<span class="keyword">const</span> sp&lt;CALLBACK&gt;&amp; cameraCb, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">const</span> String16&amp; clientPackageName, <span class="keyword">int</span> clientUid,</span><br><span class="line">        apiLevel effectiveApiLevel, <span class="keyword">bool</span> legacyMode, <span class="keyword">bool</span> shimUpdateOnly,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;CLIENT&gt;&amp; device) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> ret = NO_ERROR;</span><br><span class="line">    <span class="function">String8 <span class="title">clientName8</span><span class="params">(clientPackageName)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> clientPid = getCallingPid();</span><br><span class="line">    ...</span><br><span class="line">    sp&lt;CLIENT&gt; client = <span class="literal">nullptr</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有必要，给FlashLight关闭设备的机会</span></span><br><span class="line">        mFlashlight-&gt;prepareDeviceOpen(cameraId);</span><br><span class="line">        <span class="comment">//获取CameraId</span></span><br><span class="line">        <span class="keyword">int</span> id = cameraIdToInt(cameraId);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取Device的版本，此处为Device3</span></span><br><span class="line">        <span class="keyword">int</span> deviceVersion = getDeviceVersion(id, <span class="comment">/*out*/</span>&amp;facing);</span><br><span class="line">        sp&lt;BasicClient&gt; tmp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//获取client对象</span></span><br><span class="line">        <span class="keyword">if</span>((ret = makeClient(<span class="keyword">this</span>, cameraCb, clientPackageName, cameraId, facing, clientPid,</span><br><span class="line">                clientUid, getpid(), legacyMode, halVersion, deviceVersion, effectiveApiLevel,</span><br><span class="line">                <span class="comment">/*out*/</span>&amp;tmp)) != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        client = <span class="keyword">static_cast</span>&lt;CLIENT*&gt;(tmp.get());</span><br><span class="line">        <span class="comment">//调用client的初始化函数来初始化模块</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = client-&gt;initialize(mModule)) != OK) &#123;</span><br><span class="line">            ALOGE(<span class="string">"%s: Could not initialize client from HAL module."</span>, __FUNCTION__);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sp&lt;IBinder&gt; remoteCallback = client-&gt;getRemote();</span><br><span class="line">        <span class="keyword">if</span> (remoteCallback != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            remoteCallback-&gt;linkToDeath(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// lock is destroyed, allow further connect calls</span></span><br><span class="line">    <span class="comment">//将client赋值给输出Device</span></span><br><span class="line">    device = client;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CameraService根据Camera的相关参数来获取一个client，如makeClient方法，然后再调用client的initialize来进行初始化，首先看makeClient：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\CameraService.cpp]</span><br><span class="line"><span class="comment">//CameraService.cpp，其中device为输出对象</span></span><br><span class="line"><span class="keyword">status_t</span> CameraService::makeClient(<span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IInterface&gt;&amp; cameraCb, <span class="keyword">const</span> String16&amp; packageName, <span class="keyword">const</span> String8&amp; cameraId,</span><br><span class="line">        <span class="keyword">int</span> facing, <span class="keyword">int</span> clientPid, <span class="keyword">uid_t</span> clientUid, <span class="keyword">int</span> servicePid, <span class="keyword">bool</span> legacyMode,</span><br><span class="line">        <span class="keyword">int</span> halVersion, <span class="keyword">int</span> deviceVersion, apiLevel effectiveApiLevel,</span><br><span class="line">        <span class="comment">/*out*/</span>sp&lt;BasicClient&gt;* client) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将字符串的CameraId转换成整形</span></span><br><span class="line">    <span class="keyword">int</span> id = cameraIdToInt(cameraId);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (halVersion &lt; <span class="number">0</span> || halVersion == deviceVersion) &#123;<span class="comment">//判断Camera HAL版本是否和Device的版本相同</span></span><br><span class="line">        <span class="keyword">switch</span>(deviceVersion) &#123;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_1_0:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123;  <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                        clientPid, clientUid, getpid(), legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                ALOGW(<span class="string">"Camera using old HAL version: %d"</span>, deviceVersion);</span><br><span class="line">                <span class="keyword">return</span> -EOPNOTSUPP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_2_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_2_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_0:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_1:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_2:</span><br><span class="line">          <span class="keyword">case</span> CAMERA_DEVICE_API_VERSION_3_3:</span><br><span class="line">            <span class="keyword">if</span> (effectiveApiLevel == API_1) &#123; <span class="comment">// Camera1 API route</span></span><br><span class="line">                sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> Camera2Client(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                        clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// Camera2 API route</span></span><br><span class="line">                sp&lt;ICameraDeviceCallbacks&gt; tmp =</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;ICameraDeviceCallbacks*&gt;(cameraCb.get());</span><br><span class="line">                *client = <span class="keyword">new</span> CameraDeviceClient(cameraService, tmp, packageName, id,</span><br><span class="line">                        facing, clientPid, clientUid, servicePid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Should not be reachable</span></span><br><span class="line">            ALOGE(<span class="string">"Unknown camera device HAL version: %d"</span>, deviceVersion);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// A particular HAL version is requested by caller. Create CameraClient</span></span><br><span class="line">        <span class="comment">// based on the requested HAL version.</span></span><br><span class="line">        <span class="keyword">if</span> (deviceVersion &gt; CAMERA_DEVICE_API_VERSION_1_0 &amp;&amp;</span><br><span class="line">            halVersion == CAMERA_DEVICE_API_VERSION_1_0) &#123;</span><br><span class="line">            <span class="comment">// Only support higher HAL version device opened as HAL1.0 device.</span></span><br><span class="line">            sp&lt;ICameraClient&gt; tmp = <span class="keyword">static_cast</span>&lt;ICameraClient*&gt;(cameraCb.get());</span><br><span class="line">            *client = <span class="keyword">new</span> CameraClient(cameraService, tmp, packageName, id, facing,</span><br><span class="line">                    clientPid, clientUid, servicePid, legacyMode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Other combinations (e.g. HAL3.x open as HAL2.x) are not supported yet.</span></span><br><span class="line">            ALOGE(<span class="string">"Invalid camera HAL version %x: HAL %x device can only be"</span></span><br><span class="line">                    <span class="string">" opened as HAL %x device"</span>, halVersion, deviceVersion,</span><br><span class="line">                    CAMERA_DEVICE_API_VERSION_1_0);</span><br><span class="line">            <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中就是创建一个Client对象，由于此处分析的是Camera API2.0，其HAL的版本是3.0+，而Device的版本则其Device的版本即为3.0+，所以会创建一个CameraDeviceClient对象，至此，makeClient已经创建了client对象，并返回了，接着看它的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\api2\CameraDeviceClient.cpp]</span><br><span class="line"><span class="keyword">status_t</span> CameraDeviceClient::initialize(CameraModule *<span class="keyword">module</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    <span class="keyword">status_t</span> res;</span><br><span class="line">    <span class="comment">//调用Camera2ClientBase的初始化函数来初始化CameraModule模块</span></span><br><span class="line">    res = Camera2ClientBase::initialize(<span class="keyword">module</span>);</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String8 threadName;</span><br><span class="line">    <span class="comment">//初始化FrameProcessor</span></span><br><span class="line">    mFrameProcessor = <span class="keyword">new</span> FrameProcessorBase(mDevice);</span><br><span class="line">    threadName = String8::format(<span class="string">"CDU-%d-FrameProc"</span>, mCameraId);</span><br><span class="line">    mFrameProcessor-&gt;run(threadName.<span class="built_in">string</span>());</span><br><span class="line">    <span class="comment">//并注册监听，监听的实现就在CameraDeviceClient类中</span></span><br><span class="line">    mFrameProcessor-&gt;registerListener(FRAME_PROCESSOR_LISTENER_MIN_ID,</span><br><span class="line">            FRAME_PROCESSOR_LISTENER_MAX_ID, <span class="comment">/*listener*/</span><span class="keyword">this</span>,<span class="comment">/*sendPartials*/</span><span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会调用Camera2ClientBase的initialize方法来初始化，并且会初始化一个FrameProcessor来进行帧处理，主要是回调每一帧的ExtraResult到应用中，也就是3A相关的数据信息。而Camera1.0中各种Processor模块，即将数据打包处理后再返回到应用的模块都已经不存在，而Camera2.0中将由MediaRecorder、SurfaceView、ImageReader等来直接处理，总体来说效率更好。继续看initialize：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\common\Camera2ClientBase.cpp]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line"><span class="keyword">status_t</span> Camera2ClientBase&lt;TClientBase&gt;::initialize(CameraModule *<span class="keyword">module</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//调用Device的initialie方法</span></span><br><span class="line">    res = mDevice-&gt;initialize(<span class="keyword">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    res = mDevice-&gt;setNotifyCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是调用了Device的initialize方法，此处的Device是在Camera2ClientBase的构造函数中创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\common\Camera2ClientBase.cpp]</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> TClientBase&gt;</span><br><span class="line">Camera2ClientBase&lt;TClientBase&gt;::Camera2ClientBase(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CameraService&gt;&amp; cameraService,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;TCamCallbacks&gt;&amp; remoteCallback,</span><br><span class="line">        <span class="keyword">const</span> String16&amp; clientPackageName,</span><br><span class="line">        <span class="keyword">int</span> cameraId,</span><br><span class="line">        <span class="keyword">int</span> cameraFacing,</span><br><span class="line">        <span class="keyword">int</span> clientPid,</span><br><span class="line">        <span class="keyword">uid_t</span> clientUid,</span><br><span class="line">        <span class="keyword">int</span> servicePid):</span><br><span class="line">        TClientBase(cameraService, remoteCallback, clientPackageName,</span><br><span class="line">                cameraId, cameraFacing, clientPid, clientUid, servicePid),</span><br><span class="line">        mSharedCameraCallbacks(remoteCallback),</span><br><span class="line">        mDeviceVersion(cameraService-&gt;getDeviceVersion(cameraId)),</span><br><span class="line">        mDeviceActive(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGI(<span class="string">"Camera %d: Opened. Client: %s (PID %d, UID %d)"</span>, cameraId,</span><br><span class="line">            String8(clientPackageName).<span class="built_in">string</span>(), clientPid, clientUid);</span><br><span class="line"></span><br><span class="line">    mInitialClientPid = clientPid;</span><br><span class="line">    mDevice = <span class="keyword">new</span> Camera3Device(cameraId);</span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDevice == <span class="number">0</span>, <span class="string">"Device should never be NULL here."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前Camera API是2.0，而Device的API已经是3.0+了，继续看Camera3Device的构造方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line">Camera3Device::Camera3Device(<span class="keyword">int</span> id):</span><br><span class="line">        mId(id),</span><br><span class="line">        mIsConstrainedHighSpeedConfiguration(<span class="literal">false</span>),</span><br><span class="line">        mHal3Device(<span class="literal">NULL</span>),</span><br><span class="line">        mStatus(STATUS_UNINITIALIZED),</span><br><span class="line">        mStatusWaiters(<span class="number">0</span>),</span><br><span class="line">        mUsePartialResult(<span class="literal">false</span>),</span><br><span class="line">        mNumPartialResults(<span class="number">1</span>),</span><br><span class="line">        mTimestampOffset(<span class="number">0</span>),</span><br><span class="line">        mNextResultFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextReprocessResultFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextShutterFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mNextReprocessShutterFrameNumber(<span class="number">0</span>),</span><br><span class="line">        mListener(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ATRACE_CALL();</span><br><span class="line">    camera3_callback_ops::notify = &amp;sNotify;</span><br><span class="line">    camera3_callback_ops::process_capture_result = &amp;sProcessCaptureResult;</span><br><span class="line">    ALOGV(<span class="string">"%s: Created device for camera %d"</span>, __FUNCTION__, id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，它将会创建一个Camera3Device对象，所以，Device的initialize就是调用了Camera3Device的initialize方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\camera\libcameraservice\device3\Camera3Device.cpp]</span><br><span class="line"><span class="keyword">status_t</span> Camera3Device::initialize(CameraModule *<span class="keyword">module</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">camera3_device_t</span> *device;</span><br><span class="line">    <span class="comment">//打开Camera HAL层的Deivce</span></span><br><span class="line">    res = <span class="keyword">module</span>-&gt;open(deviceName.<span class="built_in">string</span>(),</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hw_device_t</span>**&gt;(&amp;device));</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交叉检查Device的版本</span></span><br><span class="line">    <span class="keyword">if</span> (device-&gt;common.version &lt; CAMERA_DEVICE_API_VERSION_3_0) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">"Could not open camera: "</span></span><br><span class="line">                <span class="string">"Camera device should be at least %x, reports %x instead"</span>,</span><br><span class="line">                CAMERA_DEVICE_API_VERSION_3_0,</span><br><span class="line">                device-&gt;common.version);</span><br><span class="line">        device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">        <span class="keyword">return</span> BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用回调函数来进行初始化，即调用打开Device的initialize方法来进行初始化</span></span><br><span class="line">    res = device-&gt;ops-&gt;initialize(device, <span class="keyword">this</span>);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动请求队列线程</span></span><br><span class="line">    mRequestThread = <span class="keyword">new</span> RequestThread(<span class="keyword">this</span>, mStatusTracker, device, aeLockAvailable);</span><br><span class="line">    res = mRequestThread-&gt;run(String8::format(<span class="string">"C3Dev-%d-ReqQueue"</span>, mId).<span class="built_in">string</span>());</span><br><span class="line">    <span class="keyword">if</span> (res != OK) &#123;</span><br><span class="line">        SET_ERR_L(<span class="string">"Unable to start request queue thread: %s (%d)"</span>,</span><br><span class="line">                strerror(-res), res);</span><br><span class="line">        device-&gt;common.close(&amp;device-&gt;common);</span><br><span class="line">        mRequestThread.clear();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//返回初始成功</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，会依赖HAL框架打开并获得相应的Device对象，具体的流程请参考android6.0源码分析之Camera2 HAL分析，然后再回调此对象的initialize方法进行初始化，最后再启动RequestThread等线程，并返回initialize成功。至此Camera API2.0下的初始化过程就分析结束了。框架层的初始化时序图如下： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-17-camera_open_native.png" alt="Alt text"></p><h5 id="4-2、总结"><a href="#4-2、总结" class="headerlink" title="4.2、总结"></a>4.2、总结</h5><p>Open()过程道路艰辛，主要为了后续Camera正常工作，添砖加瓦，铺路。下面我们列举一下，主要都准备了什么。<br>1、Camera应用将一些Callback函数，注册到Camera.java中，以使在线程处理函数中可以调用到相应的回调函数。<br>2、camera connect成功后，创建了BpCamera代理对象和BnCameraClient本地对象。<br>3、在JNICameraContext实现CameraListener接口，并将接口注册到客户端camera本地对象中，并在BnCameraClient本地对象中回调这些接口。<br>4、CameraService connect过程中，根据hal硬件版本，创建对应的CameraClient对象。在后续的初始化过程中，创建6大线程。<br>最后以一个简单的工作流程图来结束博文 </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/camera.system/01-18-Camera_open_overview.png" alt="Alt text"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://source.android.com/devices/camera/" target="_blank" rel="noopener">Android Camera官方文档</a><br><a href="https://blog.csdn.net/eternity9255" target="_blank" rel="noopener">Android 5.0 Camera系统源码分析-CSDN博客</a><br><a href="http://www.cnblogs.com/stonedemo/category/1080451.html" target="_blank" rel="noopener">Android Camera 流程学习记录 - StoneDemo - 博客园</a><br><a href="https://blog.csdn.net/shell812/article/category/5905525" target="_blank" rel="noopener">Android Camera 系统架构源码分析 - CSDN博客</a><br><a href="https://blog.csdn.net/hbw1992322/article/details/75259311" target="_blank" rel="noopener">Camera安卓源码-高通mm_camera架构剖析 - CSDN博客</a><br><a href="https://blog.csdn.net/yanbixing123/article/details/52294305/" target="_blank" rel="noopener">5.2 应用程序和驱动程序中buffer的传输流程 - CSDN博客</a><br><a href="https://www.jianshu.com/p/ecb1be82e6a8" target="_blank" rel="noopener">Camera2 数据流从framework到Hal源码分析 - 简书</a><br><a href="https://www.jianshu.com/p/1baad2a5281d" target="_blank" rel="noopener">mm-camera层frame数据流源码分析 - 简书</a><br><a href="https://blog.csdn.net/yanbixing123/article/month/2016/08/4?" target="_blank" rel="noopener">v4l2_capture.c分析—probe函数分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/category/6282972" target="_blank" rel="noopener">@@Android Camera fw学习 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/3066721" target="_blank" rel="noopener">@@Android Camera API2分析 - CSDN博客</a><br><a href="https://blog.csdn.net/qq_16775897/article/category/7112759" target="_blank" rel="noopener">@@Android Camera 流程学习记录 7.12- CSDN博客</a><br><a href="https://blog.csdn.net/column/details/guming-camera.html" target="_blank" rel="noopener">@@专栏：古冥的android6.0下的Camera API2.0的源码分析之旅 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/17751109" target="_blank" rel="noopener">linux3.3 v4l2视频采集驱动框架(vfe, camera i2c driver，v4l2_subdev等之间的联系) - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48974523" target="_blank" rel="noopener">Android Camera从Camera HAL1到Camera HAL3的过渡（已更新到Android6.0 HAL3.3） - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/48972477" target="_blank" rel="noopener">我心依旧之Android Camera模块FW/HAL3探学序 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/73709808" target="_blank" rel="noopener">Android Camera fw学习(四)-recording流程分析 - CSDN博客</a><br><a href="https://blog.csdn.net/armwind/article/details/52076879" target="_blank" rel="noopener">android camera动态库加载过程 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/49468475" target="_blank" rel="noopener">Android Camera API2.0下全新的Camera FW/HAL架构简述 - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析</title>
    <link href="http://zhoujinjian.cc/2018/06/18/Android%20Video%20System%EF%BC%883%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6Recorder%E3%80%81%E7%BC%96%E7%A0%81Encoder%E3%80%81%E6%B7%B7%E5%90%88MediaMuxer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/18/Android Video System（3）：音视频录制Recorder、编码Encoder、混合MediaMuxer源码分析/</id>
    <published>2018-06-17T16:00:00.000Z</published>
    <updated>2018-07-03T12:51:51.638Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><p>首先看一下使用MediaRecorder 录制音频的Java实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MediaRecorder recorder=newMediaRecorder();</span><br><span class="line">recorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);</span><br><span class="line">recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);</span><br><span class="line">recorder.setOutputFile(PATH_NAME);</span><br><span class="line">recorder.prepare();</span><br><span class="line">recorder.start();  <span class="comment">// Recording is now started</span></span><br><span class="line">...</span><br><span class="line">recorder.stop();  <span class="comment">//</span></span><br><span class="line">recorder.reset();  <span class="comment">// You can reuse the object by going back to setAudioSource() step</span></span><br><span class="line">recorder.release();<span class="comment">// Now the object cannot be reused</span></span><br></pre></td></tr></table></figure><p>之前在<a href="http://zhoujinjian.cc/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/#%EF%BC%88%E5%85%AB%EF%BC%89%E3%80%81tinyplay-playback%E3%80%81capture">Audio System（2）：Linux ALSA音频系统分析</a> 第（八）节画过tinyplay capture录音时序图，但当时没有仔细分析，今天来分析Audio录音如何从Java层一步步最终到达tinyalsa层的pcm_open()、pcm_read()函数的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;E:\android<span class="number">-7.1</span><span class="number">.2</span>_r1\external\tinyalsa\tinycap.c]</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">capture_sample</span><span class="params">(FILE *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> card, <span class="keyword">unsigned</span> <span class="keyword">int</span> device,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> channels, <span class="keyword">unsigned</span> <span class="keyword">int</span> rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">enum</span> pcm_format format, <span class="keyword">unsigned</span> <span class="keyword">int</span> period_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> period_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcm_config</span> <span class="title">config</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line">    <span class="keyword">char</span> *buffer;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;config, <span class="number">0</span>, <span class="keyword">sizeof</span>(config));</span><br><span class="line">    config.channels = channels;</span><br><span class="line">    config.rate = rate;</span><br><span class="line">    config.period_size = period_size;</span><br><span class="line">    config.period_count = period_count;</span><br><span class="line">    config.format = format;</span><br><span class="line">    config.start_threshold = <span class="number">0</span>;</span><br><span class="line">    config.stop_threshold = <span class="number">0</span>;</span><br><span class="line">    config.silence_threshold = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//打开录制节点</span></span><br><span class="line">    pcm = pcm_open(card, device, PCM_IN, &amp;config);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并读取从Kernel内核传过来的数据最终合成音频文件的过程<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;E:\android<span class="number">-7.1</span><span class="number">.2</span>_r1\external\tinyalsa\tinycap.c]</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">capture_sample</span><span class="params">(FILE *file, <span class="keyword">unsigned</span> <span class="keyword">int</span> card, <span class="keyword">unsigned</span> <span class="keyword">int</span> device,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> channels, <span class="keyword">unsigned</span> <span class="keyword">int</span> rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">enum</span> pcm_format format, <span class="keyword">unsigned</span> <span class="keyword">int</span> period_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">unsigned</span> <span class="keyword">int</span> period_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//循环读取音频数据</span></span><br><span class="line">    size = pcm_frames_to_bytes(pcm, pcm_get_buffer_size(pcm));</span><br><span class="line">    buffer = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">while</span> (capturing &amp;&amp; !pcm_read(pcm, buffer, size)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fwrite(buffer, <span class="number">1</span>, size, file) != size) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error capturing sample\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes_read += size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>开始分析音频录制编码合成之旅，之后分析视频录制编码合成过程。</p><h4 id="（一）、Audio-Recorder-音频录制源码分析"><a href="#（一）、Audio-Recorder-音频录制源码分析" class="headerlink" title="（一）、Audio Recorder 音频录制源码分析"></a>（一）、Audio Recorder 音频录制源码分析</h4><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-03-01-MediaRecorder-flow.png" alt="Alt text"></p><h4 id="（二）、Media-Recorder-视频录制源码分析"><a href="#（二）、Media-Recorder-视频录制源码分析" class="headerlink" title="（二）、Media Recorder 视频录制源码分析"></a>（二）、Media Recorder 视频录制源码分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mCamera = getCameraInstance();</span><br><span class="line">mCamera .open()</span><br><span class="line">mCamera.startPreview() </span><br><span class="line"></span><br><span class="line">      mMediaRecorder = new MediaRecorder();</span><br><span class="line">      mMediaRecorder.setCamera(mCamera);</span><br><span class="line"> </span><br><span class="line">      mMediaRecorder.setPreviewDisplay(android.view.SurfaceHolder);</span><br><span class="line">      mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);</span><br><span class="line">      mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);</span><br><span class="line"></span><br><span class="line">      mMediaRecorder.setVideoSize(videoRecordSize.width, videoRecordSize.height);</span><br><span class="line">mMediaRecorder.setProfile(CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH));</span><br><span class="line">      mMediaRecorder.setOutputFile(outputFile.toString());</span><br><span class="line">      //MediaRecorder.OutputFormat.MPEG_4.</span><br><span class="line"></span><br><span class="line">      mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)</span><br><span class="line">      mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.MPEG_4_SP)</span><br><span class="line">      </span><br><span class="line">      mMediaRecorder.prepare();</span><br><span class="line">      mMediaRecorder.start();</span><br><span class="line"></span><br><span class="line">mMediaRecorder.stop()</span><br><span class="line">mMediaRecorder.release()</span><br><span class="line">mCamera.stopPreview()</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-03-02-MediaRecorder-video-flow.png" alt="Alt text"></p><h4 id="（三）、音频Recorder编码Encoder"><a href="#（三）、音频Recorder编码Encoder" class="headerlink" title="（三）、音频Recorder编码Encoder"></a>（三）、音频Recorder编码Encoder</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Line 3036: 07-02 17:00:07.175  8430  8479 V ACodec  : Now uninitialized</span><br><span class="line">Line 3674: 07-02 17:00:35.717   745  1949 V ACodec  : Now uninitialized</span><br><span class="line">Line 3675: 07-02 17:00:35.718   745  8649 V ACodec  : onAllocateComponent</span><br><span class="line">Line 3678: 07-02 17:00:35.721   731   921 I OMXMaster: makeComponentInstance(OMX.google.amrnb.encoder) in mediacodec process</span><br><span class="line">Line 3679: 07-02 17:00:35.742   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Loaded</span><br><span class="line">Line 3680: 07-02 17:00:35.742   745  8649 I MediaCodec: MediaCodec will operate in async mode</span><br><span class="line">Line 3680: 07-02 17:00:35.742   745  8649 I MediaCodec: MediaCodec will operate in async mode</span><br><span class="line">Line 3681: 07-02 17:00:35.742   745  8649 V MediaCodec: Found 0 pieces of codec specific data.</span><br><span class="line">Line 3682: 07-02 17:00:35.742   745  8649 V ACodec  : onConfigureComponent</span><br><span class="line">Line 3684: 07-02 17:00:35.744   745  8649 I ACodec  : codec does not support config priority (err -2147483648)</span><br><span class="line">Line 3686: 07-02 17:00:35.751   745  8649 I ACodec  : codec does not support config priority (err -2147483648)</span><br><span class="line">Line 3687: 07-02 17:00:35.755   745  8649 V MediaCodec: [OMX.google.amrnb.encoder] configured as input format: AMessage(what = 0x00000000) = &#123;</span><br><span class="line">Line 3688: 07-02 17:00:35.755   745  8649 V MediaCodec:       string mime = &quot;audio/raw&quot;</span><br><span class="line">Line 3689: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t channel-count = 1</span><br><span class="line">Line 3690: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t sample-rate = 8000</span><br><span class="line">Line 3691: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t pcm-encoding = 2</span><br><span class="line">Line 3692: 07-02 17:00:35.755   745  8649 V MediaCodec:     &#125;, output format: AMessage(what = 0x00000000) = &#123;</span><br><span class="line">Line 3693: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t bitrate = 12200</span><br><span class="line">Line 3694: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t max-bitrate = 12200</span><br><span class="line">Line 3695: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t channel-count = 1</span><br><span class="line">Line 3696: 07-02 17:00:35.755   745  8649 V MediaCodec:       string mime = &quot;audio/3gpp&quot;</span><br><span class="line">Line 3697: 07-02 17:00:35.755   745  8649 V MediaCodec:       int32_t sample-rate = 8000</span><br><span class="line">Line 3698: 07-02 17:00:35.755   745  8649 V MediaCodec:     &#125;</span><br><span class="line">Line 3699: 07-02 17:00:35.757   745  8649 V ACodec  : onStart</span><br><span class="line">Line 3700: 07-02 17:00:35.758   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Loaded-&gt;Idle</span><br><span class="line">Line 3701: 07-02 17:00:35.758   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 2048/2048 (from 2048 using Invalid) on input port</span><br><span class="line">Line 3702: 07-02 17:00:35.766   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 8192/8192 (from 8192 using Invalid) on output port</span><br><span class="line">Line 3703: 07-02 17:00:35.771   745  8649 V MediaCodec: input buffers allocated</span><br><span class="line">Line 3704: 07-02 17:00:35.771   745  8649 V MediaCodec: output buffers allocated</span><br><span class="line">Line 3705: 07-02 17:00:35.772   745  8646 I MediaCodecSource: MediaCodecSource (audio) starting</span><br><span class="line">    Line 3706: 07-02 17:00:35.772   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Idle-&gt;Executing</span><br><span class="line">Line 3701: 07-02 17:00:35.758   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 2048/2048 (from 2048 using Invalid) on input port</span><br><span class="line">Line 3702: 07-02 17:00:35.766   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Allocating 4 buffers of size 8192/8192 (from 8192 using Invalid) on output port</span><br><span class="line">Line 3706: 07-02 17:00:35.772   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Idle-&gt;Executing</span><br><span class="line">Line 3707: 07-02 17:00:35.773   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 5</span><br><span class="line">Line 3708: 07-02 17:00:35.773   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 6</span><br><span class="line">Line 3711: 07-02 17:00:35.775   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 7</span><br><span class="line">Line 3715: 07-02 17:00:35.775   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 8</span><br><span class="line">Line 3717: 07-02 17:00:35.776   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Executing</span><br><span class="line">Line 3833: 07-02 17:00:35.902   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 20000 us</span><br><span class="line">Line 3834: 07-02 17:00:35.904   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1</span><br><span class="line">Line 3835: 07-02 17:00:35.907   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20000 us, flags = 0x00000010</span><br><span class="line">Line 3836: 07-02 17:00:35.911   745  8649 V MediaCodec: [OMX.google.amrnb.encoder] output format changed to: AMessage(what = 0x00000000) = &#123;</span><br><span class="line">Line 3843: 07-02 17:00:35.913   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 5</span><br><span class="line">Line 3844: 07-02 17:00:35.925   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 2 w/ time 40000 us</span><br><span class="line">Line 3845: 07-02 17:00:35.926   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 2</span><br><span class="line">Line 3846: 07-02 17:00:35.927   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 6 time 40000 us, flags = 0x00000010</span><br><span class="line">Line 3847: 07-02 17:00:35.927   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 6</span><br><span class="line">Line 3848: 07-02 17:00:35.942   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 3 w/ time 60000 us</span><br><span class="line">Line 3849: 07-02 17:00:35.945   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 3</span><br><span class="line">Line 3850: 07-02 17:00:35.945   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 7 time 60000 us, flags = 0x00000010</span><br><span class="line">Line 3851: 07-02 17:00:35.946   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 7</span><br><span class="line">Line 3852: 07-02 17:00:35.963   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 4 w/ time 80000 us</span><br><span class="line">Line 3853: 07-02 17:00:35.965   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 4</span><br><span class="line">Line 3854: 07-02 17:00:35.966   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 8 time 80000 us, flags = 0x00000010</span><br><span class="line">Line 3855: 07-02 17:00:35.967   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 8</span><br><span class="line">Line 3856: 07-02 17:00:35.982   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 100000 us</span><br><span class="line">Line 3857: 07-02 17:00:35.983   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1</span><br><span class="line">Line 3858: 07-02 17:00:35.985   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 100000 us, flags = 0x00000010</span><br><span class="line">......</span><br><span class="line">Line 8217: 07-02 17:00:56.446   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 8</span><br><span class="line">Line 8218: 07-02 17:00:56.462   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling emptyBuffer 1 w/ time 20580000 us</span><br><span class="line">Line 8219: 07-02 17:00:56.464   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXEmptyBufferDone 1</span><br><span class="line">Line 8220: 07-02 17:00:56.466   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20580000 us, flags = 0x00000010</span><br><span class="line">Line 8221: 07-02 17:00:56.467   745  8649 V ACodec  : [OMX.google.amrnb.encoder] calling fillBuffer 5</span><br><span class="line">Line 8222: 07-02 17:00:56.468   745  8646 I MediaCodecSource: encoder (audio) stopping</span><br><span class="line">Line 8223: 07-02 17:00:56.483   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Executing-&gt;Idle</span><br><span class="line">Line 8224: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 5 time 20580000 us, flags = 0x00000000</span><br><span class="line">Line 8225: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 6 time 20520000 us, flags = 0x00000000</span><br><span class="line">Line 8226: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 7 time 20540000 us, flags = 0x00000000</span><br><span class="line">Line 8227: 07-02 17:00:56.484   745  8649 V ACodec  : [OMX.google.amrnb.encoder] onOMXFillBufferDone 8 time 20560000 us, flags = 0x00000000</span><br><span class="line">Line 8228: 07-02 17:00:56.496   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Idle-&gt;Loaded</span><br><span class="line">Line 8229: 07-02 17:00:56.496   745  8649 V ACodec  : [OMX.google.amrnb.encoder] Now Loaded</span><br><span class="line">Line 8231: 07-02 17:00:56.499   745  8646 I MediaCodecSource: encoder (audio) stopped</span><br></pre></td></tr></table></figure><h4 id="（四）、视频Recorder编码Encoder"><a href="#（四）、视频Recorder编码Encoder" class="headerlink" title="（四）、视频Recorder编码Encoder"></a>（四）、视频Recorder编码Encoder</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.947</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: startVideoRecording</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.974</span>  <span class="number">6238</span>  <span class="number">6238</span> D CameraStorage: External storage state=mounted</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.995</span>  <span class="number">6238</span>  <span class="number">6238</span> D CameraStorage: External storage state=mounted</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">44.998</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: initializeRecorder</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.003</span>   <span class="number">741</span>  <span class="number">1966</span> V MediaPlayerService: Create <span class="keyword">new</span> media recorder client from pid <span class="number">6238</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.009</span>  <span class="number">6238</span>  <span class="number">6238</span> I CAM_VideoModule: NOTE: hfr = off : hsr = off</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">378</span>: tintless40_algo_process_be: failed: update_func rc <span class="number">-4</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">851</span>: tintless40_algo_execute: failed: tintless40_trigger_algo</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">98</span>: isp_algo_execute_internal_algo: failed to run algo tintless</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.024</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">710</span>: isp_parser_thread_func: failed: isp_parser_process</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.031</span>  <span class="number">6238</span>  <span class="number">6238</span> D LocationManager: No location received yet.</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.033</span>  <span class="number">6238</span>  <span class="number">6238</span> D LocationManager: No location received yet.</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.033</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: New video filename: /storage/emulated/<span class="number">0</span>/DCIM/Camera/VID_20180703_114345.mp4</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.059</span>  <span class="number">1391</span>  <span class="number">2526</span> I MediaFocusControl:  AudioFocus  requestAudioFocus() from uid/pid <span class="number">10025</span>/<span class="number">6238</span> clientId=android.media.AudioManager@<span class="number">11f</span>939d req=<span class="number">2</span> flags=<span class="number">0x0</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.062</span>  <span class="number">4966</span>  <span class="number">4966</span> D AudioManager: AudioManager dispatching onAudioFocusChange(<span class="number">-2</span>) <span class="keyword">for</span> android.media.AudioManager@e6fb066com.android.music.MediaPlaybackService$<span class="number">4</span>@<span class="number">2315f</span>a7</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.063</span>  <span class="number">4966</span>  <span class="number">4966</span> V MediaPlaybackService: AudioFocus: received AUDIOFOCUS_LOSS_TRANSIENT</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.079</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15184</span>: gpw <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): str=off , prev_str=off</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.079</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15302</span>: gpw   <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.079</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>): <span class="number">15232</span>: ggw3 <span class="number">-1</span> <span class="number">-1</span>  </span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.091</span>   <span class="number">726</span>  <span class="number">2209</span> E CameraClient: setVideoBufferMode: <span class="number">535</span>: videoBufferMode <span class="number">2</span> is <span class="keyword">not</span> supported.</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.100</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">378</span>: tintless40_algo_process_be: failed: update_func rc <span class="number">-4</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.101</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">851</span>: tintless40_algo_execute: failed: tintless40_trigger_algo</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.101</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">98</span>: isp_algo_execute_internal_algo: failed to run algo tintless</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.101</span>   <span class="number">802</span>  <span class="number">6282</span> E mm-camera: &lt;ISP   &gt;&lt;ERROR&gt; <span class="number">710</span>: isp_parser_thread_func: failed: isp_parser_process</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.105</span>   <span class="number">802</span>  <span class="number">6296</span> E mm-camera: &lt;IMGLIB&gt;&lt;ERROR&gt; <span class="number">318</span>: faceproc_comp_set_param: Error param=<span class="number">523</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.111</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15184</span>: gpw <span class="keyword">status_t</span> qcamera::QCameraParameters::setSkinBeautify(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): str=off , prev_str=off</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.111</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">const</span> qcamera::QCameraParameters &amp;): <span class="number">15302</span>: gpw   <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.111</span>   <span class="number">726</span>  <span class="number">6266</span> E QCamera : &lt;HAL&gt;&lt;ERROR&gt; <span class="keyword">int32_t</span> qcamera::QCameraParameters::setAjustLevel(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>): <span class="number">15232</span>: ggw3 <span class="number">-1</span> <span class="number">-1</span>  </span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.121</span>   <span class="number">741</span>  <span class="number">6349</span> I MediaPlayerService: MediaPlayerService::getOMX</span><br><span class="line"><span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.122</span>   <span class="number">741</span>  <span class="number">6349</span> I OMXClient: MuxOMX ctor</span><br><span class="line"></span><br><span class="line">Line <span class="number">5362</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.712</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Video Encoder selected = <span class="number">2</span></span><br><span class="line">Line <span class="number">5363</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.712</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Audio Encoder selected = <span class="number">3</span></span><br><span class="line">Line <span class="number">5449</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.944</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Video Encoder selected = <span class="number">2</span></span><br><span class="line">Line <span class="number">5450</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">41.944</span>  <span class="number">6238</span>  <span class="number">6238</span> V CAM_VideoModule: Audio Encoder selected = <span class="number">3</span></span><br><span class="line">Line <span class="number">6011</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.123</span>   <span class="number">732</span>  <span class="number">2029</span> I OMXMaster: makeComponentInstance(OMX.qcom.video.encoder.avc) in mediacodec process</span><br><span class="line">Line <span class="number">6014</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.170</span>   <span class="number">732</span>  <span class="number">2029</span> I OMX-VENC: Component_init : OMX.qcom.video.encoder.avc : <span class="keyword">return</span> = <span class="number">0x0</span></span><br><span class="line">Line <span class="number">6017</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.180</span>   <span class="number">732</span>  <span class="number">2168</span> E OMXNodeInstance: getParameter(<span class="number">2</span>dc0040:qcom.encoder.avc, ParamConsumerUsageBits(<span class="number">0x6f800004</span>)) ERROR: UnsupportedIndex(<span class="number">0x8000101a</span>)</span><br><span class="line">Line <span class="number">6019</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.181</span>   <span class="number">732</span>  <span class="number">1863</span> W OMXNodeInstance: [<span class="number">2</span>dc0040:qcom.encoder.avc] component does <span class="keyword">not</span> support metadata mode; <span class="keyword">using</span> fallback</span><br><span class="line">Line <span class="number">6020</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.181</span>   <span class="number">741</span>  <span class="number">6349</span> E ACodec  : [OMX.qcom.video.encoder.avc] storeMetaDataInBuffers (output) failed w/ err <span class="number">-1010</span></span><br><span class="line">Line <span class="number">6021</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.182</span>   <span class="number">741</span>  <span class="number">6349</span> I ExtendedACodec: setupVideoEncoder()</span><br><span class="line">Line <span class="number">6026</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.231</span>   <span class="number">741</span>  <span class="number">6349</span> I ACodec  : setupAVCEncoderParameters with [profile: Baseline] [level: Level1]</span><br><span class="line">Line <span class="number">6028</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.241</span>   <span class="number">732</span>  <span class="number">1863</span> E OMXNodeInstance: getConfig(<span class="number">2</span>dc0040:qcom.encoder.avc, ??(<span class="number">0x7f000062</span>)) ERROR: UnsupportedSetting(<span class="number">0x80001019</span>)</span><br><span class="line">Line <span class="number">6029</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.245</span>   <span class="number">741</span>  <span class="number">6349</span> I ACodec  : [OMX.qcom.video.encoder.avc] cannot encode HDR <span class="keyword">static</span> metadata. Ignoring.</span><br><span class="line">Line <span class="number">6030</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.245</span>   <span class="number">741</span>  <span class="number">6349</span> I ACodec  : setupVideoEncoder succeeded</span><br><span class="line">Line 6031: 07-03 11:43:45.245   741  6349 I ExtendedACodec: [OMX.qcom.video.encoder.avc] configure, AMessage : AMessage(what = 'conf', target = 75) = &#123;</span><br><span class="line">Line <span class="number">6044</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.245</span>   <span class="number">741</span>  <span class="number">6349</span> I ExtendedACodec:   <span class="keyword">int32_t</span> encoder = <span class="number">1</span></span><br><span class="line">Line <span class="number">6174</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.455</span>   <span class="number">732</span>  <span class="number">2169</span> I OMXMaster: makeComponentInstance(OMX.qcom.audio.encoder.aac) in mediacodec process</span><br><span class="line">Line <span class="number">6180</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.460</span>   <span class="number">732</span>  <span class="number">2169</span> E QC_AACENC:  component init: role = OMX.qcom.audio.encoder.aac</span><br><span class="line">Line <span class="number">6182</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.491</span>   <span class="number">732</span>   <span class="number">732</span> E OMXNodeInstance: setConfig(<span class="number">2</span>dc0041:qcom.encoder.aac, ConfigPriority(<span class="number">0x6f800002</span>)) ERROR: UnsupportedIndex(<span class="number">0x8000101a</span>)</span><br><span class="line">Line <span class="number">6184</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.502</span>   <span class="number">732</span>  <span class="number">2169</span> E OMXNodeInstance: setConfig(<span class="number">2</span>dc0041:qcom.encoder.aac, ConfigPriority(<span class="number">0x6f800002</span>)) ERROR: UnsupportedIndex(<span class="number">0x8000101a</span>)</span><br><span class="line">Line <span class="number">6193</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.537</span>   <span class="number">741</span>  <span class="number">6363</span> I CameraSource: Using encoder format: <span class="number">0x22</span></span><br><span class="line">Line <span class="number">6194</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">45.537</span>   <span class="number">741</span>  <span class="number">6363</span> I CameraSource: Using encoder data space: <span class="number">0x104</span></span><br><span class="line">Line <span class="number">7431</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.472</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (video) stopping</span><br><span class="line">Line <span class="number">7456</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.611</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (video) stopped</span><br><span class="line">Line <span class="number">7494</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.677</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (audio) stopping</span><br><span class="line">Line <span class="number">7534</span>: <span class="number">07</span><span class="number">-03</span> <span class="number">11</span>:<span class="number">43</span>:<span class="number">56.800</span>   <span class="number">741</span>  <span class="number">6347</span> I MediaCodecSource: encoder (audio) stopped</span><br></pre></td></tr></table></figure><h4 id="（五）、音视频混合MediaMuxer源码分析"><a href="#（五）、音视频混合MediaMuxer源码分析" class="headerlink" title="（五）、音视频混合MediaMuxer源码分析"></a>（五）、音视频混合MediaMuxer源码分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;MediaWriter&gt; mWriter;</span><br><span class="line">[-&gt;\android\frameworks\av\media\libstagefright\MediaMuxer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaMuxer::start() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mMuxerLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (mState == INITIALIZED) &#123;</span><br><span class="line">        mState = STARTED;</span><br><span class="line">        mFileMeta-&gt;setInt32(kKeyRealTimeRecording, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> mWriter-&gt;start(mFileMeta.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">"start() is called in invalid state %d"</span>, mState);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到具体还是调用的MediaWriter实现的。我们来分析具体实例：MPEG4Writer.cpp，即MP4文件的格式封装过程。</p><p>1)       录制开始时，写入文件头部。</p><p>2)       录制进行时，实时写入音视频轨迹的数据块。</p><p>3)       录制结束时，写入索引信息并更新头部参数。</p><p>  索引负责描述音视频轨迹的特征，会随着音视频轨迹的存储而变化，所以通常做法会将录像文件索引信息放在音视频轨迹流后面，在媒体流数据写完（录像结束）后才能写入。可以看到，存放音视频数据的mdat box是位于第二位的，而负责检索音视频的moov box是位于最后的，这与通常的MP4封装的排列顺序不同，当然这是为了符合录制而产生的结果。因为 moov的大小是随着 mdat 变化的，而我们录制视频的时间预先是不知道的，所以需要先将mdat 数据写入，最后再写入moov，完成封装。 </p><p>  现有Android系统上录像都是录制是MP4或3GP格式，底层就是使用MPEG4Writer组合器类来完成的，它将编码后的音视频轨迹按照MPEG4规范进行封装，填入各个参数，就组合成完整的MP4格式文件。MPEG4Writer的组合功能主要由两种线程完成，一种是负责音视频数据写入封装文件的写线程（WriterThread），一种是音视频数据读取处理的轨迹线程（TrackThread）。轨迹线程一般有两个：视频轨迹数据读取线程和音频轨迹数据读取线程，而写线程只有一个，负责将轨迹线程中打包成Chunk的数据写入封装文件。</p><p>  如下图所示，轨迹线程是以帧为单位获取数据帧（Sample），并将每帧中的信息及系统环境信息提取汇总存储在内存的trak表中，其中需要维持的信息有Chunk写入文件的偏移地址Stco（Chunk Offset）、Sample与Chunk的映射关系Stsc（Sample-to-Chunk）、关键帧Stss（Sync Sample）、每一帧的持续时间Stts（Time-to-Sample）等，这些信息是跟每一帧的信息密切相关的，由图可以看出trak表由各自的线程维护，当录像结束时trak表会就会写入封装文件。而每一帧的数据流会先存入一个链表缓存中，当帧的数量达到一定值时，轨迹线程会将这些帧数据打包成块（Chunk）并通知写线程写入到封装文件。写线程接到Chunk已准备好的通知后就马上搜索Chunk链表（链表个数与轨迹线程个数相关，一般有两个，音视频轨迹线程各有一个），将找到的第一个Chunk后便写入封装文件，并会将写入的偏移地址更新到相应的trak表的Stco项（但trak表中其它数据是由轨迹线程更新）。音视频的Chunk数据是存储于同一mdat box中，按添加到Chunk链表时间先后顺序排列。等到录像结束时，录像应用会调用MPEG4Writer的stop方法，此时就会将音视频的trak表分别写入moov。</p><p>  <img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/VS-03-03-MPEG4Writer.png" alt="Alt text"></p><p> 其实看完上面的内容，应该对Android录制视频过程中，录制的视频的封装过程有一个大体了解，我们平时所说的视频后缀名.mp4/.mkv等等就是视频封装的各种格式。<br>先看看构造函数：在这里将实现一些参数的初始化，fd是传进来的录制文件的文件描述符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\android\frameworks\av\media\libstagefright\MPEG4Writer.cpp]</span><br><span class="line">MPEG4Writer::MPEG4Writer(<span class="keyword">int</span> fd)</span><br><span class="line">    : mFd(dup(fd)),</span><br><span class="line">      mInitCheck(mFd &lt; <span class="number">0</span>? NO_INIT: OK),</span><br><span class="line">      mIsRealTimeRecording(<span class="literal">true</span>),</span><br><span class="line">      mUse4ByteNalLength(<span class="literal">true</span>),</span><br><span class="line">      mUse32BitOffset(<span class="literal">true</span>),</span><br><span class="line">      mIsFileSizeLimitExplicitlyRequested(<span class="literal">false</span>),</span><br><span class="line">      mPaused(<span class="literal">false</span>),</span><br><span class="line">      mStarted(<span class="literal">false</span>),</span><br><span class="line">      mWriterThreadStarted(<span class="literal">false</span>),</span><br><span class="line">      mOffset(<span class="number">0</span>),</span><br><span class="line">      mMdatOffset(<span class="number">0</span>),</span><br><span class="line">      mMoovBoxBuffer(<span class="literal">NULL</span>),</span><br><span class="line">      mMoovBoxBufferOffset(<span class="number">0</span>),</span><br><span class="line">      mWriteMoovBoxToMemory(<span class="literal">false</span>),</span><br><span class="line">      mFreeBoxOffset(<span class="number">0</span>),</span><br><span class="line">      mStreamableFile(<span class="literal">false</span>),</span><br><span class="line">      mEstimatedMoovBoxSize(<span class="number">0</span>),</span><br><span class="line">      mMoovExtraSize(<span class="number">0</span>),</span><br><span class="line">      mInterleaveDurationUs(<span class="number">1000000</span>),</span><br><span class="line">      mTimeScale(<span class="number">-1</span>),</span><br><span class="line">      mStartTimestampUs(<span class="number">-1l</span>l),</span><br><span class="line">      mLatitudex10000(<span class="number">0</span>),</span><br><span class="line">      mLongitudex10000(<span class="number">0</span>),</span><br><span class="line">      mAreGeoTagsAvailable(<span class="literal">false</span>),</span><br><span class="line">      mStartTimeOffsetMs(<span class="number">-1</span>),</span><br><span class="line">      mMetaKeys(<span class="keyword">new</span> AMessage()),</span><br><span class="line">      mIsAudioAMR(<span class="literal">false</span>) &#123;</span><br><span class="line">    addDeviceMeta();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify mFd is seekable</span></span><br><span class="line">    <span class="keyword">off64_t</span> off = lseek64(mFd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">    <span class="keyword">if</span> (off &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot seek mFd: %s (%d)"</span>, strerror(errno), errno);</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着从 MPEG4Writer.cpp 的start()函数开始：<br>在start部分，我们看到在这一部分，writeFtypBox(param) 将实现录制文件文件头部信息的相关信息的写入操作；startWriterThread() 开启封装视频文件的写线程；startTracks(param) 开启视频数据的读线程，也就是前面文件部分所说的轨迹线程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">status_t MPEG4Writer::start(MetaData *param) &#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    if (mStarted) &#123;</span><br><span class="line">        if (mPaused) &#123;</span><br><span class="line">            mPaused = false;</span><br><span class="line">            return startTracks(param);</span><br><span class="line">        &#125;</span><br><span class="line">        return OK;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mWriteMoovBoxToMemory = false;</span><br><span class="line">    mMoovBoxBuffer = NULL;</span><br><span class="line">    mMoovBoxBufferOffset = 0;</span><br><span class="line"></span><br><span class="line">    writeFtypBox(param);</span><br><span class="line"></span><br><span class="line">    mFreeBoxOffset = mOffset;</span><br><span class="line"></span><br><span class="line">    if (mEstimatedMoovBoxSize == 0) &#123;</span><br><span class="line">        int32_t bitRate = -1;</span><br><span class="line">        if (param) &#123;</span><br><span class="line">            param-&gt;findInt32(kKeyBitRate, &amp;bitRate);</span><br><span class="line">        &#125;</span><br><span class="line">        mEstimatedMoovBoxSize = estimateMoovBoxSize(bitRate);</span><br><span class="line">    &#125;</span><br><span class="line">    CHECK_GE(mEstimatedMoovBoxSize, 8);</span><br><span class="line">    if (mStreamableFile) &#123;</span><br><span class="line">        // Reserve a &apos;free&apos; box only for streamable file</span><br><span class="line">        lseek64(mFd, mFreeBoxOffset, SEEK_SET);</span><br><span class="line">        writeInt32(mEstimatedMoovBoxSize);</span><br><span class="line">        write(&quot;free&quot;, 4);</span><br><span class="line">        mMdatOffset = mFreeBoxOffset + mEstimatedMoovBoxSize;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mMdatOffset = mOffset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffset = mMdatOffset;</span><br><span class="line">    lseek64(mFd, mMdatOffset, SEEK_SET);</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    status_t err = startWriterThread();</span><br><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    err = startTracks(param);</span><br><span class="line">   ......</span><br><span class="line">    mStarted = true;</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  继续看下 startWriterThread（）部分，在startWriterThread（）函数中，将真正建立新的子线程，并在子线程中执行ThreadWrappe函数中的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::startWriterThread() &#123;</span><br><span class="line">    ALOGV(<span class="string">"startWriterThread"</span>);</span><br><span class="line"></span><br><span class="line">    mDone = <span class="literal">false</span>;</span><br><span class="line">    mIsFirstChunk = <span class="literal">true</span>;</span><br><span class="line">    mDriftTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Track *&gt;::iterator it = mTracks.begin();</span><br><span class="line">         it != mTracks.end(); ++it) &#123;</span><br><span class="line">        ChunkInfo info;</span><br><span class="line">        info.mTrack = *it;</span><br><span class="line">        info.mPrevChunkTimestampUs = <span class="number">0</span>;</span><br><span class="line">        info.mMaxInterChunkDurUs = <span class="number">0</span>;</span><br><span class="line">        mChunkInfos.push_back(info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line">    pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, <span class="keyword">this</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    mWriterThreadStarted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着继续看 ThreadWrapper（）函数,在这里new 了一个MPEGWriter对象，真正的操作在threadFunc()中体现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *MPEG4Writer::ThreadWrapper(<span class="keyword">void</span> *me) &#123;</span><br><span class="line">    ALOGV(<span class="string">"ThreadWrapper: %p"</span>, me);</span><br><span class="line">    MPEG4Writer *writer = <span class="keyword">static_cast</span>&lt;MPEG4Writer *&gt;(me);</span><br><span class="line">    writer-&gt;threadFunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下threadFun()。在这个函数中，将根据变量mDone 进行while循环，一直检测是否有数据块Chunk可写。轨迹线程是一直将读数据的数据往buffer中写入，buffer到了一定量后，就是chunk,这时就会通过信号量 mChunkReadyCondition来通知封装文件的写线程去检测链表，然后将检索到的Chunk数据写入文件的数据区，当然写之前，肯定会去判断下是否真的有数据可写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MPEG4Writer::threadFunc() &#123;</span><br><span class="line">    ALOGV(<span class="string">"threadFunc"</span>);</span><br><span class="line"></span><br><span class="line">    prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"MPEG4Writer"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (!mDone) &#123;</span><br><span class="line">        Chunk chunk;</span><br><span class="line">        <span class="keyword">bool</span> chunkFound = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!mDone &amp;&amp; !(chunkFound = findChunkToWrite(&amp;chunk))) &#123;</span><br><span class="line">            mChunkReadyCondition.wait(mLock);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chunkFound) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mIsRealTimeRecording) &#123;</span><br><span class="line">                mLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            writeChunkToFile(&amp;chunk);</span><br><span class="line">            <span class="keyword">if</span> (mIsRealTimeRecording) &#123;</span><br><span class="line">                mLock.lock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeAllChunks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 下面看下writerChunkToFile(&amp;chunk);轨迹线程读数据时是以数据帧Sample为单位，所以这里将Chunk写入封装文件，也是以Sample为单位，遍历整个链表，将数据写入封装文件，真正的写入操作是addSamole_l(*it);</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MPEG4Writer::writeAllChunks() &#123;</span><br><span class="line">    ALOGV(<span class="string">"writeAllChunks"</span>);</span><br><span class="line">    <span class="keyword">size_t</span> outstandingChunks = <span class="number">0</span>;</span><br><span class="line">    Chunk chunk;</span><br><span class="line">    <span class="keyword">while</span> (findChunkToWrite(&amp;chunk)) &#123;</span><br><span class="line">        writeChunkToFile(&amp;chunk);</span><br><span class="line">        ++outstandingChunks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sendSessionSummary();</span><br><span class="line"></span><br><span class="line">    mChunkInfos.clear();</span><br><span class="line">    ALOGD(<span class="string">"%zu chunks are written in the last batch"</span>, outstandingChunks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MPEG4Writer::writeChunkToFile(Chunk* chunk) &#123;</span><br><span class="line">    ALOGV(<span class="string">"writeChunkToFile: %"</span> PRId64 <span class="string">" from %s track"</span>,</span><br><span class="line">        chunk-&gt;mTimeStampUs, chunk-&gt;mTrack-&gt;isAudio()? <span class="string">"audio"</span>: <span class="string">"video"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> isFirstSample = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!chunk-&gt;mSamples.empty()) &#123;</span><br><span class="line">        List&lt;MediaBuffer *&gt;::iterator it = chunk-&gt;mSamples.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">off64_t</span> offset = (chunk-&gt;mTrack-&gt;isAvc() || chunk-&gt;mTrack-&gt;isHevc())</span><br><span class="line">                                ? addMultipleLengthPrefixedSamples_l(*it)</span><br><span class="line">                                : addSample_l(*it);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isFirstSample) &#123;</span><br><span class="line">            chunk-&gt;mTrack-&gt;addChunkOffset(offset);</span><br><span class="line">            isFirstSample = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        (*it)-&gt;release();</span><br><span class="line">        (*it) = <span class="literal">NULL</span>;</span><br><span class="line">        chunk-&gt;mSamples.erase(it);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk-&gt;mSamples.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  下面看下addSamole_l(*it) 函数，wirte写入操作，mFd 是上层设置录制的文件路径传下来的文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off64_t</span> MPEG4Writer::addSample_l(MediaBuffer *buffer) &#123;</span><br><span class="line">    <span class="keyword">off64_t</span> old_offset = mOffset;</span><br><span class="line"></span><br><span class="line">    ::write(mFd,</span><br><span class="line">          (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data() + buffer-&gt;range_offset(),</span><br><span class="line">          buffer-&gt;range_length());</span><br><span class="line"></span><br><span class="line">    mOffset += buffer-&gt;range_length();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  到此，封装文件的写入线程的操作大体走完，下面看轨迹线程的操作。</p><hr><p>   startTracks(param) 轨迹线程的开启。文件的录制过程中是有2条轨迹线程，一个是视频的轨迹线程，另一条则是音频的轨迹线程，在starTrack（param）中是在for 循环中start了两条轨迹线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::startTracks(MetaData *params) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mTracks.empty()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"No source added"</span>);</span><br><span class="line">        <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;Track *&gt;::iterator it = mTracks.begin();</span><br><span class="line">         it != mTracks.end(); ++it) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = (*it)-&gt;start(params);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Track *&gt;::iterator it2 = mTracks.begin();</span><br><span class="line">                 it2 != it; ++it2) &#123;</span><br><span class="line">                (*it2)-&gt;stop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（<em>it)-&gt;start(params) 将会执行status_t MPEG4Writer::Track::start(MetaData </em>params) {} 。在这边也是同样新建子线程，在子线程中执行轨迹线程的相应操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::Track::start(MetaData *params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> startTimeUs;</span><br><span class="line">    ......</span><br><span class="line">    mStartTimeRealUs = startTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> rotationDegrees;</span><br><span class="line">    ......</span><br><span class="line">    initTrackingProgressStatus(params);</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; meta = <span class="keyword">new</span> MetaData;</span><br><span class="line">    <span class="keyword">if</span> (mOwner-&gt;isRealTimeRecording() &amp;&amp; mOwner-&gt;numTracks() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> startTimeOffsetUs = mOwner-&gt;getStartTimeOffsetMs() * <span class="number">1000L</span>L;</span><br><span class="line">        <span class="keyword">if</span> (startTimeOffsetUs &lt; <span class="number">0</span>) &#123;  <span class="comment">// Start time offset was not set</span></span><br><span class="line">            startTimeOffsetUs = kInitialDelayTimeUs;</span><br><span class="line">        &#125;</span><br><span class="line">        startTimeUs += startTimeOffsetUs;</span><br><span class="line">        ALOGI(<span class="string">"Start time offset: %"</span> PRId64 <span class="string">" us"</span>, startTimeOffsetUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    meta-&gt;setInt64(kKeyTime, startTimeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mSource-&gt;start(meta.get());</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_JOINABLE);</span><br><span class="line"></span><br><span class="line">    mDone = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mTrackDurationUs = <span class="number">0</span>;</span><br><span class="line">    mReachedEOS = <span class="literal">false</span>;</span><br><span class="line">    mEstimatedTrackSizeBytes = <span class="number">0</span>;</span><br><span class="line">    mMdatSizeBytes = <span class="number">0</span>;</span><br><span class="line">    mMaxChunkDurationUs = <span class="number">0</span>;</span><br><span class="line">    mLastDecodingTimeUs = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;mThread, &amp;attr, ThreadWrapper, <span class="keyword">this</span>);</span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看下上面ThreadWrapper函数,真正的操作又是放到了threadEntry()中去执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *MPEG4Writer::Track::ThreadWrapper(<span class="keyword">void</span> *me) &#123;</span><br><span class="line"> </span><br><span class="line">    Track *track = <span class="keyword">static_cast</span>&lt;Track *&gt;(me);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">status_t</span> err = track-&gt;threadEntry();</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *) err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> MPEG4Writer::Track::threadEntry() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> interleaveDurationUs = mOwner-&gt;interleaveDuration();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> hasMultipleTracks = (mOwner-&gt;numTracks() &gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> chunkTimestampUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> nChunks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> nActualFrames = <span class="number">0</span>;        <span class="comment">// frames containing non-CSD data (non-0 length)</span></span><br><span class="line">    <span class="keyword">int32_t</span> nZeroLengthFrames = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> lastTimestampUs = <span class="number">0</span>;      <span class="comment">// Previous sample time stamp</span></span><br><span class="line">    <span class="keyword">int64_t</span> lastDurationUs = <span class="number">0</span>;       <span class="comment">// Between the previous two samples</span></span><br><span class="line">    <span class="keyword">int64_t</span> currDurationTicks = <span class="number">0</span>;    <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int64_t</span> lastDurationTicks = <span class="number">0</span>;    <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int32_t</span> sampleCount = <span class="number">1</span>;          <span class="comment">// Sample count in the current stts table entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> previousSampleSize = <span class="number">0</span>;  <span class="comment">// Size of the previous sample</span></span><br><span class="line">    <span class="keyword">int64_t</span> previousPausedDurationUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> timestampUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cttsOffsetTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> currCttsOffsetTimeTicks = <span class="number">0</span>;   <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int64_t</span> lastCttsOffsetTimeTicks = <span class="number">-1</span>;  <span class="comment">// Timescale based ticks</span></span><br><span class="line">    <span class="keyword">int32_t</span> cttsSampleCount = <span class="number">0</span>;           <span class="comment">// Sample count in the current ctts table entry</span></span><br><span class="line">    <span class="keyword">uint32_t</span> lastSamplesPerChunk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsAudio) &#123;</span><br><span class="line">        prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"AudioTrackEncoding"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prctl(PR_SET_NAME, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="string">"VideoTrackEncoding"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOwner-&gt;isRealTimeRecording()) &#123;</span><br><span class="line">        androidSetThreadPriority(<span class="number">0</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; meta_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    MediaBuffer *buffer;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *trackName = mIsAudio ? <span class="string">"Audio"</span> : <span class="string">"Video"</span>;</span><br><span class="line">    <span class="keyword">while</span> (!mDone &amp;&amp; (err = mSource-&gt;read(&amp;buffer)) == OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer-&gt;range_length() == <span class="number">0</span>) &#123;</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">            ++nZeroLengthFrames;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the codec specific data has not been received yet, delay pause.</span></span><br><span class="line">        <span class="comment">// After the codec specific data is received, discard what we received</span></span><br><span class="line">        <span class="comment">// when the track is to be paused.</span></span><br><span class="line">        <span class="keyword">if</span> (mPaused &amp;&amp; !mResumed) &#123;</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> isCodecConfig;</span><br><span class="line">        <span class="keyword">if</span> (buffer-&gt;meta_data()-&gt;findInt32(kKeyIsCodecConfig, &amp;isCodecConfig)</span><br><span class="line">                &amp;&amp; isCodecConfig) &#123;</span><br><span class="line">            <span class="comment">// if config format (at track addition) already had CSD, keep that</span></span><br><span class="line">            <span class="comment">// UNLESS we have not received any frames yet.</span></span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> for now the entire CSD has to come in one frame for encoders, even though</span></span><br><span class="line">            <span class="comment">// they need to be spread out for decoders.</span></span><br><span class="line">            <span class="keyword">if</span> (mGotAllCodecSpecificData &amp;&amp; nActualFrames &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ALOGI(<span class="string">"ignoring additional CSD for video track after first frame"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mMeta = mSource-&gt;getFormat(); <span class="comment">// get output format after format change</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (mIsAvc) &#123;</span><br><span class="line">                    <span class="keyword">status_t</span> err = makeAVCCodecSpecificData(</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data()</span><br><span class="line">                                + buffer-&gt;range_offset(),</span><br><span class="line">                            buffer-&gt;range_length());</span><br><span class="line">                    CHECK_EQ((<span class="keyword">status_t</span>)OK, err);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsHevc) &#123;</span><br><span class="line">                    <span class="keyword">status_t</span> err = makeHEVCCodecSpecificData(</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data()</span><br><span class="line">                                + buffer-&gt;range_offset(),</span><br><span class="line">                            buffer-&gt;range_length());</span><br><span class="line">                    CHECK_EQ((<span class="keyword">status_t</span>)OK, err);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsMPEG4) &#123;</span><br><span class="line">                    copyCodecSpecificData((<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)buffer-&gt;data() + buffer-&gt;range_offset(),</span><br><span class="line">                            buffer-&gt;range_length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">                <span class="keyword">int32_t</span> fps;</span><br><span class="line">                mMeta-&gt;findInt32(kKeyFrameRate, &amp;fps);</span><br><span class="line">                <span class="keyword">int64_t</span> cttsOffsetTimeUs = <span class="number">1000000L</span>L/fps;</span><br><span class="line">                mCttsOffsetTimeUs = cttsOffsetTimeUs + kMinCttsOffsetTimeUs; <span class="comment">//delta factor</span></span><br><span class="line">            &#125;</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            mGotAllCodecSpecificData = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++nActualFrames;</span><br><span class="line"></span><br><span class="line">        MediaBuffer *copy = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// Check if the upstream source hints it is OK to hold on to the</span></span><br><span class="line">        <span class="comment">// buffer without releasing immediately and avoid cloning the buffer</span></span><br><span class="line">        <span class="keyword">if</span> (AVUtils::get()-&gt;canDeferRelease(buffer-&gt;meta_data())) &#123;</span><br><span class="line">            copy = buffer;</span><br><span class="line">            meta_data = <span class="keyword">new</span> MetaData(*buffer-&gt;meta_data().get());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Make a deep copy of the MediaBuffer and Metadata and release</span></span><br><span class="line">            <span class="comment">// the original as soon as we can</span></span><br><span class="line">            copy = <span class="keyword">new</span> MediaBuffer(buffer-&gt;range_length());</span><br><span class="line">            <span class="built_in">memcpy</span>(copy-&gt;data(), (<span class="keyword">uint8_t</span> *)buffer-&gt;data() + buffer-&gt;range_offset(),</span><br><span class="line">                    buffer-&gt;range_length());</span><br><span class="line">            copy-&gt;set_range(<span class="number">0</span>, buffer-&gt;range_length());</span><br><span class="line">            meta_data = <span class="keyword">new</span> MetaData(*buffer-&gt;meta_data().get());</span><br><span class="line">            buffer-&gt;release();</span><br><span class="line">            buffer = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mIsAvc || mIsHevc) StripStartcode(copy);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">size_t</span> sampleSize = copy-&gt;range_length();</span><br><span class="line">        <span class="keyword">if</span> (mIsAvc || mIsHevc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOwner-&gt;useNalLengthFour()) &#123;</span><br><span class="line">                sampleSize += <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sampleSize += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Max file size or duration handling</span></span><br><span class="line">        mMdatSizeBytes += sampleSize;</span><br><span class="line">        updateTrackSizeEstimate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOwner-&gt;exceedsFileSizeLimit()) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Recorded file size exceeds limit %"</span> PRId64 <span class="string">"bytes"</span>,</span><br><span class="line">                    mOwner-&gt;mMaxFileSizeLimitBytes);</span><br><span class="line">            mOwner-&gt;notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED, <span class="number">0</span>);</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOwner-&gt;exceedsFileDurationLimit()) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Recorded file duration exceeds limit %"</span> PRId64 <span class="string">"microseconds"</span>,</span><br><span class="line">                    mOwner-&gt;mMaxFileDurationLimitUs);</span><br><span class="line">            mOwner-&gt;notify(MEDIA_RECORDER_EVENT_INFO, MEDIA_RECORDER_INFO_MAX_DURATION_REACHED, <span class="number">0</span>);</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> isSync = <span class="literal">false</span>;</span><br><span class="line">        meta_data-&gt;findInt32(kKeyIsSyncFrame, &amp;isSync);</span><br><span class="line">        CHECK(meta_data-&gt;findInt64(kKeyTime, &amp;timestampUs));</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">0</span>) &#123;</span><br><span class="line">            mFirstSampleTimeRealUs = systemTime() / <span class="number">1000</span>;</span><br><span class="line">            mStartTimestampUs = timestampUs;</span><br><span class="line">            mOwner-&gt;setStartTimestampUs(mStartTimestampUs);</span><br><span class="line">            previousPausedDurationUs = mStartTimestampUs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mResumed) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> durExcludingEarlierPausesUs = timestampUs - previousPausedDurationUs;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(durExcludingEarlierPausesUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int64_t</span> pausedDurationUs = durExcludingEarlierPausesUs - mTrackDurationUs;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(pausedDurationUs &gt;= lastDurationUs, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousPausedDurationUs += pausedDurationUs - lastDurationUs;</span><br><span class="line">            mResumed = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        timestampUs -= previousPausedDurationUs;</span><br><span class="line">        <span class="keyword">if</span> (WARN_UNLESS(timestampUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Composition time: timestampUs</span></span><br><span class="line"><span class="comment">             * Decoding time: decodingTimeUs</span></span><br><span class="line"><span class="comment">             * Composition time offset = composition time - decoding time</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int64_t</span> decodingTimeUs;</span><br><span class="line">            CHECK(meta_data-&gt;findInt64(kKeyDecodingTime, &amp;decodingTimeUs));</span><br><span class="line">            decodingTimeUs -= previousPausedDurationUs;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ensure non-negative, monotonic decoding time</span></span><br><span class="line">            <span class="keyword">if</span> (mLastDecodingTimeUs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                decodingTimeUs = <span class="built_in">std</span>::max((<span class="keyword">int64_t</span>)<span class="number">0</span>, decodingTimeUs);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// increase decoding time by at least 1 tick</span></span><br><span class="line">                decodingTimeUs = <span class="built_in">std</span>::max(</span><br><span class="line">                        mLastDecodingTimeUs + divUp(<span class="number">1000000</span>, mTimeScale), decodingTimeUs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mLastDecodingTimeUs = decodingTimeUs;</span><br><span class="line">            cttsOffsetTimeUs =</span><br><span class="line">                    timestampUs + mCttsOffsetTimeUs - decodingTimeUs;</span><br><span class="line">            <span class="keyword">if</span> (cttsOffsetTimeUs &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                cttsOffsetTimeUs = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(cttsOffsetTimeUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timestampUs = decodingTimeUs;</span><br><span class="line">            ALOGV(<span class="string">"decoding time: %"</span> PRId64 <span class="string">" and ctts offset time: %"</span> PRId64,</span><br><span class="line">                timestampUs, cttsOffsetTimeUs);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update ctts box table if necessary</span></span><br><span class="line">            currCttsOffsetTimeTicks =</span><br><span class="line">                    (cttsOffsetTimeUs * mTimeScale + <span class="number">500000L</span>L) / <span class="number">1000000L</span>L;</span><br><span class="line">            <span class="keyword">if</span> (WARN_UNLESS(currCttsOffsetTimeTicks &lt;= <span class="number">0x0FFFFFFFF</span>LL, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">                copy-&gt;release();</span><br><span class="line">                mSource-&gt;stop();</span><br><span class="line">                mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">0</span>) &#123;</span><br><span class="line">                lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks;</span><br><span class="line">                <span class="comment">//addOneCttsTableEntry(1, currCttsOffsetTimeTicks);</span></span><br><span class="line">                <span class="comment">//cttsSampleCount = 0;      // No sample in ctts box is pending</span></span><br><span class="line">                cttsSampleCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (currCttsOffsetTimeTicks != lastCttsOffsetTimeTicks) &#123;</span><br><span class="line">                    addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks);</span><br><span class="line">                    lastCttsOffsetTimeTicks = currCttsOffsetTimeTicks;</span><br><span class="line">                    cttsSampleCount = <span class="number">1</span>;  <span class="comment">// One sample in ctts box is pending</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ++cttsSampleCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Update ctts time offset range</span></span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">0</span>) &#123;</span><br><span class="line">                mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">                mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (currCttsOffsetTimeTicks &gt; mMaxCttsOffsetTimeUs) &#123;</span><br><span class="line">                    mMaxCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currCttsOffsetTimeTicks &lt; mMinCttsOffsetTimeUs) &#123;</span><br><span class="line">                    mMinCttsOffsetTimeUs = currCttsOffsetTimeTicks;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mOwner-&gt;isRealTimeRecording()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mIsAudio) &#123;</span><br><span class="line">                updateDriftTime(meta_data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (WARN_UNLESS(timestampUs &gt;= <span class="number">0l</span>l, <span class="string">"for %s track"</span>, trackName)) &#123;</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ALOGV(<span class="string">"%s media time stamp: %"</span> PRId64 <span class="string">" and previous paused duration %"</span> PRId64,</span><br><span class="line">                trackName, timestampUs, previousPausedDurationUs);</span><br><span class="line">        <span class="keyword">if</span> (timestampUs &gt; mTrackDurationUs) &#123;</span><br><span class="line">            mTrackDurationUs = timestampUs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to use the time scale based ticks, rather than the</span></span><br><span class="line">        <span class="comment">// timestamp itself to determine whether we have to use a new</span></span><br><span class="line">        <span class="comment">// stts entry, since we may have rounding errors.</span></span><br><span class="line">        <span class="comment">// The calculation is intended to reduce the accumulated</span></span><br><span class="line">        <span class="comment">// rounding errors.</span></span><br><span class="line">        currDurationTicks =</span><br><span class="line">            ((timestampUs * mTimeScale + <span class="number">500000L</span>L) / <span class="number">1000000L</span>L -</span><br><span class="line">                (lastTimestampUs * mTimeScale + <span class="number">500000L</span>L) / <span class="number">1000000L</span>L);</span><br><span class="line">        <span class="keyword">if</span> (currDurationTicks &lt; <span class="number">0l</span>l) &#123;</span><br><span class="line">            ALOGE(<span class="string">"do not support out of order frames (timestamp: %lld &lt; last: %lld for %s track"</span>,</span><br><span class="line">                    (<span class="keyword">long</span> <span class="keyword">long</span>)timestampUs, (<span class="keyword">long</span> <span class="keyword">long</span>)lastTimestampUs, trackName);</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            mSource-&gt;stop();</span><br><span class="line">            mIsMalformed = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the duration is different for this sample, see if it is close enough to the previous</span></span><br><span class="line">        <span class="comment">// duration that we can fudge it and use the same value, to avoid filling the stts table</span></span><br><span class="line">        <span class="comment">// with lots of near-identical entries.</span></span><br><span class="line">        <span class="comment">// "close enough" here means that the current duration needs to be adjusted by less</span></span><br><span class="line">        <span class="comment">// than 0.1 milliseconds</span></span><br><span class="line">        <span class="keyword">if</span> (lastDurationTicks &amp;&amp; (currDurationTicks != lastDurationTicks)) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> deltaUs = ((lastDurationTicks - currDurationTicks) * <span class="number">1000000L</span>L</span><br><span class="line">                    + (mTimeScale / <span class="number">2</span>)) / mTimeScale;</span><br><span class="line">            <span class="keyword">if</span> (deltaUs &gt; <span class="number">-100</span> &amp;&amp; deltaUs &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="comment">// use previous ticks, and adjust timestamp as if it was actually that number</span></span><br><span class="line">                <span class="comment">// of ticks</span></span><br><span class="line">                currDurationTicks = lastDurationTicks;</span><br><span class="line">                timestampUs += deltaUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mStszTableEntries-&gt;add(htonl(sampleSize));</span><br><span class="line">        <span class="keyword">if</span> (mStszTableEntries-&gt;count() &gt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Force the first sample to have its own stts entry so that</span></span><br><span class="line">            <span class="comment">// we can adjust its value later to maintain the A/V sync.</span></span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">3</span> || currDurationTicks != lastDurationTicks) &#123;</span><br><span class="line">                addOneSttsTableEntry(sampleCount, lastDurationTicks);</span><br><span class="line">                sampleCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++sampleCount;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mSamplesHaveSameSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mStszTableEntries-&gt;count() &gt;= <span class="number">2</span> &amp;&amp; previousSampleSize != sampleSize) &#123;</span><br><span class="line">                mSamplesHaveSameSize = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            previousSampleSize = sampleSize;</span><br><span class="line">        &#125;</span><br><span class="line">        ALOGV(<span class="string">"%s timestampUs/lastTimestampUs: %"</span> PRId64 <span class="string">"/%"</span> PRId64,</span><br><span class="line">                trackName, timestampUs, lastTimestampUs);</span><br><span class="line">        lastDurationUs = timestampUs - lastTimestampUs;</span><br><span class="line">        lastDurationTicks = currDurationTicks;</span><br><span class="line">        lastTimestampUs = timestampUs;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSync != <span class="number">0</span>) &#123;</span><br><span class="line">            addOneStssTableEntry(mStszTableEntries-&gt;count());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTrackingProgressStatus) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPreviousTrackTimeUs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mPreviousTrackTimeUs = mStartTimestampUs;</span><br><span class="line">            &#125;</span><br><span class="line">            trackProgressStatus(timestampUs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasMultipleTracks) &#123;</span><br><span class="line">            <span class="keyword">off64_t</span> offset = (mIsAvc || mIsHevc) ? mOwner-&gt;addMultipleLengthPrefixedSamples_l(copy)</span><br><span class="line">                                 : mOwner-&gt;addSample_l(copy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint32_t</span> count = (mOwner-&gt;use32BitFileOffset()</span><br><span class="line">                        ? mStcoTableEntries-&gt;count()</span><br><span class="line">                        : mCo64TableEntries-&gt;count());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                addChunkOffset(offset);</span><br><span class="line">            &#125;</span><br><span class="line">            copy-&gt;release();</span><br><span class="line">            copy = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mChunkSamples.push_back(copy);</span><br><span class="line">        <span class="keyword">if</span> (interleaveDurationUs == <span class="number">0</span>) &#123;</span><br><span class="line">            addOneStscTableEntry(++nChunks, <span class="number">1</span>);</span><br><span class="line">            bufferChunk(timestampUs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (chunkTimestampUs == <span class="number">0</span>) &#123;</span><br><span class="line">                chunkTimestampUs = timestampUs;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> chunkDurationUs = timestampUs - chunkTimestampUs;</span><br><span class="line">                <span class="keyword">if</span> (chunkDurationUs &gt; interleaveDurationUs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chunkDurationUs &gt; mMaxChunkDurationUs) &#123;</span><br><span class="line">                        mMaxChunkDurationUs = chunkDurationUs;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++nChunks;</span><br><span class="line">                    <span class="keyword">if</span> (nChunks == <span class="number">1</span> ||  <span class="comment">// First chunk</span></span><br><span class="line">                        lastSamplesPerChunk != mChunkSamples.size()) &#123;</span><br><span class="line">                        lastSamplesPerChunk = mChunkSamples.size();</span><br><span class="line">                        addOneStscTableEntry(nChunks, lastSamplesPerChunk);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bufferChunk(timestampUs);</span><br><span class="line">                    chunkTimestampUs = timestampUs;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isTrackMalFormed()) &#123;</span><br><span class="line">        err = ERROR_MALFORMED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOwner-&gt;trackProgressStatus(mTrackId, <span class="number">-1</span>, err);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last chunk</span></span><br><span class="line">    <span class="keyword">if</span> (!hasMultipleTracks) &#123;</span><br><span class="line">        addOneStscTableEntry(<span class="number">1</span>, mStszTableEntries-&gt;count());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mChunkSamples.empty()) &#123;</span><br><span class="line">        addOneStscTableEntry(++nChunks, mChunkSamples.size());</span><br><span class="line">        bufferChunk(timestampUs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't really know how long the last frame lasts, since</span></span><br><span class="line">    <span class="comment">// there is no frame time after it, just repeat the previous</span></span><br><span class="line">    <span class="comment">// frame's duration.</span></span><br><span class="line">    <span class="keyword">if</span> (mStszTableEntries-&gt;count() == <span class="number">1</span>) &#123;</span><br><span class="line">        lastDurationUs = <span class="number">0</span>;  <span class="comment">// A single sample's duration</span></span><br><span class="line">        lastDurationTicks = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ++sampleCount;  <span class="comment">// Count for the last sample</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStszTableEntries-&gt;count() &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        addOneSttsTableEntry(<span class="number">1</span>, lastDurationTicks);</span><br><span class="line">        <span class="keyword">if</span> (sampleCount - <span class="number">1</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            addOneSttsTableEntry(sampleCount - <span class="number">1</span>, lastDurationTicks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addOneSttsTableEntry(sampleCount, lastDurationTicks);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The last ctts box may not have been written yet, and this</span></span><br><span class="line">    <span class="comment">// is to make sure that we write out the last ctts box.</span></span><br><span class="line">    <span class="keyword">if</span> (currCttsOffsetTimeTicks == lastCttsOffsetTimeTicks) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cttsSampleCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            addOneCttsTableEntry(cttsSampleCount, lastCttsOffsetTimeTicks);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTrackDurationUs += lastDurationUs;</span><br><span class="line">    mReachedEOS = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    sendTrackSummary(hasMultipleTracks);</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">"Received total/0-length (%d/%d) buffers and encoded %d frames. - %s"</span>,</span><br><span class="line">            count, nZeroLengthFrames, mStszTableEntries-&gt;count(), trackName);</span><br><span class="line">    <span class="keyword">if</span> (mIsAudio) &#123;</span><br><span class="line">        ALOGI(<span class="string">"Audio track drift time: %"</span> PRId64 <span class="string">" us"</span>, mOwner-&gt;getDriftTimeUs());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if err is ERROR_IO (ex: during SSR), return OK to save the</span></span><br><span class="line">    <span class="comment">// recorded file successfully. Session tear down will happen as part of</span></span><br><span class="line">    <span class="comment">// client callback</span></span><br><span class="line">    <span class="keyword">if</span> ((err == ERROR_IO) || (err == ERROR_END_OF_STREAM)) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p> 下面看下，录制文件结束时的一些操作。录制文件结束时，上层应用分别是调用 MediaRecorder的stop()、reset()和release()法，下面看下MPEG4Writer.cpp中相对应的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> MPEG4Writer::Track::stop() &#123;</span><br><span class="line">    ALOGD(<span class="string">"%s track stopping"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mStarted) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Stop() called but track is not started"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR_END_OF_STREAM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDone) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    mDone = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"%s track source stopping"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line">    mSource-&gt;stop();</span><br><span class="line">    ALOGD(<span class="string">"%s track source stopped"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *dummy;</span><br><span class="line">    pthread_join(mThread, &amp;dummy);</span><br><span class="line">    <span class="keyword">status_t</span> err = <span class="keyword">static_cast</span>&lt;<span class="keyword">status_t</span>&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(dummy));</span><br><span class="line"></span><br><span class="line">    ALOGD(<span class="string">"%s track stopped"</span>, mIsAudio? <span class="string">"Audio"</span>: <span class="string">"Video"</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MPEG4Writer::release() &#123;</span><br><span class="line">    close(mFd);</span><br><span class="line">    mFd = <span class="number">-1</span>;</span><br><span class="line">    mInitCheck = NO_INIT;</span><br><span class="line">    mStarted = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">free</span>(mMoovBoxBuffer);</span><br><span class="line">    mMoovBoxBuffer = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://developer.android.com/guide/topics/media/camera#capture-video" target="_blank" rel="noopener">Camera#capture-video</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/16222.html" target="_blank" rel="noopener">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a href="https://blog.csdn.net/nonmarking/article/category/6746500" target="_blank" rel="noopener">深入理解Android音视频同步机制（总共五篇）</a><br><a href="https://blog.csdn.net/junzia/article/details/54018671" target="_blank" rel="noopener">Android硬编码——音频编码、视频编码及音视频混合</a><br><a href="https://blog.csdn.net/mr_zjc/article/details/46822833" target="_blank" rel="noopener">Android 高通平台Camera录制–MPEG4Writer.cpp 简单跟读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析</title>
    <link href="http://zhoujinjian.cc/2018/06/06/Android%20Video%20System%EF%BC%882%EF%BC%89%EF%BC%9A%E9%9F%B3%E8%A7%86%E9%A2%91%E5%88%86%E7%A6%BBMediaExtractor%E3%80%81%E8%A7%A3%E7%A0%81Decoder%E3%80%81%E6%B8%B2%E6%9F%93Renderer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/06/Android Video System（2）：音视频分离MediaExtractor、解码Decoder、渲染Renderer源码分析/</id>
    <published>2018-06-05T16:00:00.000Z</published>
    <updated>2018-05-17T16:23:42.126Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a><br>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>前面第一章节已经分析过mMediaPlayer.setDataSource()、mMediaPlayer.setDisplay()下来的分析尝试分析解答如下疑问：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong></p></blockquote><h4 id="（一）、多媒体文件解析-MediaExtractor分离音视频"><a href="#（一）、多媒体文件解析-MediaExtractor分离音视频" class="headerlink" title="（一）、多媒体文件解析 - MediaExtractor分离音视频"></a>（一）、多媒体文件解析 - MediaExtractor分离音视频</h4><p>接下来继续分析mMediaPlayer.prepareAsync()</p><h5 id="1-1、mMediaPlayer-prepareAsync"><a href="#1-1、mMediaPlayer-prepareAsync" class="headerlink" title="1.1、mMediaPlayer.prepareAsync()"></a>1.1、mMediaPlayer.prepareAsync()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span> <span class="keyword">throws</span> IllegalStateException</span>;</span><br></pre></td></tr></table></figure><p>通过JNI调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">android_media_MediaPlayer_prepareAsync(JNIEnv *env, jobject thiz)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">        jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle the case where the display surface was set before the mp was</span></span><br><span class="line">    <span class="comment">// initialized. We try again to make it stick.</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(st);</span><br><span class="line"></span><br><span class="line">    process_media_player_call( env, thiz, mp-&gt;prepareAsync(), <span class="string">"java/io/IOException"</span>, <span class="string">"Prepare Async failed."</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先设置视频的 display surface（关于IGraphicBufferProducer相关知识请参考：Android 7.1.2 (Android N) Android Graphics 系统 分析 [i.wonder~]），</p><h5 id="1-1-1、MediaPlayer-setVideoSurfaceTexture"><a href="#1-1-1、MediaPlayer-setVideoSurfaceTexture" class="headerlink" title="1.1.1、MediaPlayer.setVideoSurfaceTexture()"></a>1.1.1、MediaPlayer.setVideoSurfaceTexture()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::setVideoSurfaceTexture(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt;&amp; bufferProducer)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"setVideoSurfaceTexture"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">if</span> (mPlayer == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> mPlayer-&gt;setVideoSurfaceTexture(bufferProducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面setDataSource()分析过，此处会调用NuPlayer的setVideoSurfaceTexture()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处首先构造了一个AMessage消息，然后new Surface()，接下来看看消息处理过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,</span><br><span class="line">                                           FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                    <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                        mDeferredActions.push_back(</span><br><span class="line">                                <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDeferredActions.push_back(</span><br><span class="line">                    <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line"></span><br><span class="line">            processDeferredActions();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::performSetSurface(<span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface) &#123;</span><br><span class="line">    ALOGV(<span class="string">"performSetSurface"</span>);</span><br><span class="line"></span><br><span class="line">    mSurface = surface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX - ignore error from setVideoScalingMode for now</span></span><br><span class="line">    setVideoScalingMode(mVideoScalingMode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDriver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            driver-&gt;notifySetSurfaceComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到将surface 赋值给NuPlayer的mSurface ，待视频解码后就可以在此surface 上渲染画面了，<br>这个稍后再作分析。</p><h5 id="1-1-2、MediaPlayer-prepareAsync"><a href="#1-1-2、MediaPlayer-prepareAsync" class="headerlink" title="1.1.2、MediaPlayer.prepareAsync()"></a>1.1.2、MediaPlayer.prepareAsync()</h5><p>然后接着调用MediaPlayer prepareAsync()函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\mediaplayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync()</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(<span class="string">"prepareAsync"</span>);</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="keyword">return</span> prepareAsync_l();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> MediaPlayer::prepareAsync_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( (mPlayer != <span class="number">0</span>) &amp;&amp; ( mCurrentState &amp; (MEDIA_PLAYER_INITIALIZED | MEDIA_PLAYER_STOPPED) ) ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioAttributesParcel != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mPlayer-&gt;setParameter(KEY_PARAMETER_AUDIO_ATTRIBUTES, *mAudioAttributesParcel);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPlayer-&gt;setAudioStreamType(mStreamType);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurrentState = MEDIA_PLAYER_PREPARING;</span><br><span class="line">        <span class="keyword">return</span> mPlayer-&gt;prepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGE(<span class="string">"prepareAsync called in state %d, mPlayer(%p)"</span>, mCurrentState, mPlayer.get());</span><br><span class="line">    <span class="keyword">return</span> INVALID_OPERATION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处会调用NuPlayer的prepareAsync()函数，prepareAsync()发送了一个kWhatPrepare的AMessage，我们直接看看消息处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;        </span><br><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处又调用了GenericSource的prepareAsync()函数，发送了一个kWhatPrepareAsync消息。直接看看GenericSource如何处理的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::prepareAsync() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">        mLooper-&gt;setName(<span class="string">"generic"</span>);</span><br><span class="line">        mLooper-&gt;start();</span><br><span class="line"></span><br><span class="line">        mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatPrepareAsync, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">      <span class="keyword">case</span> kWhatPrepareAsync:</span><br><span class="line">      &#123;</span><br><span class="line">          onPrepareAsync();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::GenericSource::onPrepareAsync() &#123;</span><br><span class="line">    <span class="comment">// delayed data source creation</span></span><br><span class="line">    <span class="keyword">if</span> (mDataSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// set to false first, if the extractor</span></span><br><span class="line">        <span class="comment">// comes back as secure, set it to true then.</span></span><br><span class="line">        mIsSecure = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mUri.empty()) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>* uri = mUri.c_str();</span><br><span class="line">            String8 contentType;</span><br><span class="line">            mIsWidevine = !strncasecmp(uri, <span class="string">"widevine://"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!strncasecmp(<span class="string">"http://"</span>, uri, <span class="number">7</span>)</span><br><span class="line">                    || !strncasecmp(<span class="string">"https://"</span>, uri, <span class="number">8</span>)</span><br><span class="line">                    || mIsWidevine) &#123;</span><br><span class="line">                mHttpSource = DataSource::CreateMediaHTTP(mHTTPService);</span><br><span class="line">                ......</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mDataSource = DataSource::CreateFromURI(</span><br><span class="line">                   mHTTPService, uri, &amp;mUriHeaders, &amp;contentType,</span><br><span class="line">                   <span class="keyword">static_cast</span>&lt;HTTPBase *&gt;(mHttpSource.get()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mIsWidevine = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            mDataSource = <span class="keyword">new</span> FileSource(mFd, mOffset, mLength);</span><br><span class="line">            mFd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDataSource-&gt;flags() &amp; DataSource::kIsCachingDataSource) &#123;</span><br><span class="line">        mCachedSource = <span class="keyword">static_cast</span>&lt;NuCachedSource2 *&gt;(mDataSource.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsStreaming = (mIsWidevine || mCachedSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init extractor from data source</span></span><br><span class="line">    <span class="keyword">status_t</span> err = initFromDataSource();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoTrack.mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;MetaData&gt; meta = doGetFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage;</span><br><span class="line">        err = convertMetaDataToMessage(meta, &amp;msg);</span><br><span class="line">        ......</span><br><span class="line">        notifyVideoSizeChanged(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (mIsSecure) &#123;</span><br><span class="line">        <span class="comment">// secure decoders must be instantiated before starting widevine source</span></span><br><span class="line">        sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatSecureDecodersInstantiated, <span class="keyword">this</span>);</span><br><span class="line">        notifyInstantiateSecureDecoders(reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        finishPrepareAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先构造了  mDataSource = new FileSource，然后调用了initFromDataSource()，这里面包含多媒体文件格式探测，。</p><h5 id="1-1-3、GenericSource-initFromDataSource"><a href="#1-1-3、GenericSource-initFromDataSource" class="headerlink" title="1.1.3、GenericSource.initFromDataSource()"></a>1.1.3、GenericSource.initFromDataSource()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\GenericSource.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::GenericSource::initFromDataSource() &#123;</span><br><span class="line">    sp&lt;IMediaExtractor&gt; extractor;</span><br><span class="line">    String8 mimeType;</span><br><span class="line">    <span class="keyword">float</span> confidence;</span><br><span class="line">    sp&lt;AMessage&gt; dummy;</span><br><span class="line">    <span class="keyword">bool</span> isWidevineStreaming = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    CHECK(mDataSource != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsWidevine) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mIsStreaming) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mDataSource-&gt;sniff(&amp;mimeType, &amp;confidence, &amp;dummy)) &#123;</span><br><span class="line">            <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        isWidevineStreaming = !strcasecmp(</span><br><span class="line">                mimeType.<span class="built_in">string</span>(), MEDIA_MIMETYPE_CONTAINER_WVM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isWidevineStreaming) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        extractor = MediaExtractor::Create(mDataSource,</span><br><span class="line">                mimeType.isEmpty() ? <span class="literal">NULL</span> : mimeType.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (extractor-&gt;getDrmFlag()) &#123;</span><br><span class="line">        checkDrmStatus(mDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFileMeta = extractor-&gt;getMetaData();</span><br><span class="line">    <span class="keyword">if</span> (mFileMeta != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> duration;</span><br><span class="line">        <span class="keyword">if</span> (mFileMeta-&gt;findInt64(kKeyDuration, &amp;duration)) &#123;</span><br><span class="line">            mDurationUs = duration;</span><br><span class="line">        &#125;......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> totalBitrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> numtracks = extractor-&gt;countTracks();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; numtracks; ++i) &#123;</span><br><span class="line">        sp&lt;IMediaSource&gt; track = extractor-&gt;getTrack(i);</span><br><span class="line">        </span><br><span class="line">        sp&lt;MetaData&gt; meta = extractor-&gt;getTrackMetaData(i);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">        CHECK(meta-&gt;findCString(kKeyMIMEType, &amp;mime));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Do the string compare immediately with "mime",</span></span><br><span class="line">        <span class="comment">// we can't assume "mime" would stay valid after another</span></span><br><span class="line">        <span class="comment">// extractor operation, some extractors might modify meta</span></span><br><span class="line">        <span class="comment">// during getTrack() and make it invalid.</span></span><br><span class="line">        <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"audio/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mAudioTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mAudioTrack.mIndex = i;</span><br><span class="line">                mAudioTrack.mSource = track;</span><br><span class="line">                mAudioTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mAudioTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_VORBIS)) &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mAudioIsVorbis = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strncasecmp(mime, <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mVideoTrack.mSource == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mVideoTrack.mIndex = i;</span><br><span class="line">                mVideoTrack.mSource = track;</span><br><span class="line">                mVideoTrack.mPackets =</span><br><span class="line">                    <span class="keyword">new</span> AnotherPacketSource(mVideoTrack.mSource-&gt;getFormat());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// check if the source requires secure buffers</span></span><br><span class="line">                <span class="keyword">int32_t</span> secure;</span><br><span class="line">                <span class="keyword">if</span> (meta-&gt;findInt32(kKeyRequiresSecureBuffers, &amp;secure)</span><br><span class="line">                        &amp;&amp; secure) &#123;</span><br><span class="line">                    mIsSecure = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (mUIDValid) &#123;</span><br><span class="line">                        extractor-&gt;setUID(mUID);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSources.push(track);</span><br><span class="line">        <span class="keyword">int64_t</span> durationUs;</span><br><span class="line">        <span class="keyword">if</span> (meta-&gt;findInt64(kKeyDuration, &amp;durationUs)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (durationUs &gt; mDurationUs) &#123;</span><br><span class="line">                mDurationUs = durationUs;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> bitrate;</span><br><span class="line">        <span class="keyword">if</span> (totalBitrate &gt;= <span class="number">0</span> &amp;&amp; meta-&gt;findInt32(kKeyBitRate, &amp;bitrate)) &#123;</span><br><span class="line">            totalBitrate += bitrate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            totalBitrate = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    mBitrate = totalBitrate;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过MediaExtractor::Create()得到MediaExtractor，然后将数据解析成track 赋值给mAudioTrack.mSource、mVideoTrack.mSource。</p><h5 id="1-1-4、MediaExtractor-Create"><a href="#1-1-4、MediaExtractor-Create" class="headerlink" title="1.1.4、MediaExtractor::Create()"></a>1.1.4、MediaExtractor::Create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaExtractor.cpp]</span><br><span class="line">sp&lt;IMediaExtractor&gt; MediaExtractor::Create(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source, <span class="keyword">const</span> <span class="keyword">char</span> *mime) &#123;</span><br><span class="line">    ALOGV(<span class="string">"MediaExtractor::Create %s"</span>, mime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"media.stagefright.extractremote"</span>, value, <span class="literal">NULL</span>)</span><br><span class="line">            &amp;&amp; (!<span class="built_in">strcmp</span>(<span class="string">"0"</span>, value) || !strcasecmp(<span class="string">"false"</span>, value))) &#123;</span><br><span class="line">        <span class="comment">// local extractor</span></span><br><span class="line">        ALOGW(<span class="string">"creating media extractor in calling process"</span>);</span><br><span class="line">        <span class="keyword">return</span> CreateFromService(source, mime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Check if it's WVM, since WVMExtractor needs to be created in the media server process,</span></span><br><span class="line">        <span class="comment">// not the extractor process.</span></span><br><span class="line">        String8 mime8;</span><br><span class="line">        <span class="keyword">float</span> confidence;</span><br><span class="line">        sp&lt;AMessage&gt; meta;</span><br><span class="line">        <span class="keyword">if</span> (SniffWVM(source, &amp;mime8, &amp;confidence, &amp;meta) &amp;&amp;</span><br><span class="line">                !strcasecmp(mime8, MEDIA_MIMETYPE_CONTAINER_WVM)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WVMExtractor(source);</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (SniffDRM(source, &amp;mime8, &amp;confidence, &amp;meta)) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *drmMime = mime8.<span class="built_in">string</span>();</span><br><span class="line">            ALOGV(<span class="string">"Detected media content as '%s' with confidence %.2f"</span>, drmMime, confidence);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(drmMime, <span class="string">"drm+es_based+"</span>, <span class="number">13</span>)) &#123;</span><br><span class="line">                <span class="comment">// DRMExtractor sets container metadata kKeyIsDRM to 1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> DRMExtractor(source, drmMime + <span class="number">14</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remote extractor</span></span><br><span class="line">        ALOGV(<span class="string">"get service manager"</span>);</span><br><span class="line">        sp&lt;IBinder&gt; binder = defaultServiceManager()-&gt;getService(String16(<span class="string">"media.extractor"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binder != <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;IMediaExtractorService&gt; mediaExService(interface_cast&lt;IMediaExtractorService&gt;(binder));</span><br><span class="line">            sp&lt;IMediaExtractor&gt; ex = mediaExService-&gt;makeExtractor(RemoteDataSource::wrap(source), mime);</span><br><span class="line">            <span class="keyword">return</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过Binder通信获取”media.extractor”服务得到一个Extractor。</p><h5 id="1-1-5、IMediaExtractor-gt-getTrack"><a href="#1-1-5、IMediaExtractor-gt-getTrack" class="headerlink" title="1.1.5、IMediaExtractor-&gt;getTrack()"></a>1.1.5、IMediaExtractor-&gt;getTrack()</h5><p>根据不同类别解析出不同的Track</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\]</span><br><span class="line"></span><br><span class="line">AACExtractor.cpp sp&lt;IMediaSource&gt; AACExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">AMRExtractor.cpp sp&lt;IMediaSource&gt; AMRExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MP3Extractor.cpp sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">NuMediaExtractor.cpp sp&lt;IMediaSource&gt; source = mImpl-&gt;getTrack(index)</span><br><span class="line">WAVExtractor.cpp sp&lt;IMediaSource&gt; WAVExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">FLACExtractor.cpp sp&lt;IMediaSource&gt; FLACExtractor::getTrack(<span class="keyword">size_t</span> index) </span><br><span class="line">StagefrightMetadataRetriever.cpp sp&lt;IMediaSource&gt; source = mExtractor-&gt;getTrack(i)</span><br><span class="line">AVIExtractor.cpp sp&lt;MediaSource&gt; AVIExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">OggExtractor.cpp sp&lt;IMediaSource&gt; OggExtractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line">MPEG4Extractor.cpp sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">//MP3</span></span><br><span class="line">sp&lt;IMediaSource&gt; MP3Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MP3Source(</span><br><span class="line">            mMeta, mDataSource, mFirstFramePos, mFixedHeader,</span><br><span class="line">            mSeeker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MPEG4</span></span><br><span class="line">sp&lt;IMediaSource&gt; MPEG4Extractor::getTrack(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    ......</span><br><span class="line">    Track *track = mFirstTrack;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (track == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        track = track-&gt;next;</span><br><span class="line">        --index;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    Trex *trex = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int32_t</span> trackId;</span><br><span class="line">    <span class="keyword">if</span> (track-&gt;meta-&gt;findInt32(kKeyTrackID, &amp;trackId)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mTrex.size(); i++) &#123;</span><br><span class="line">            Trex *t = &amp;mTrex.editItemAt(i);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;track_ID == (<span class="keyword">uint32_t</span>) trackId) &#123;</span><br><span class="line">                trex = t;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mime;</span><br><span class="line">    .......</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyAVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> type;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">void</span> *data;</span><br><span class="line">        <span class="keyword">size_t</span> size;</span><br><span class="line">        <span class="keyword">if</span> (!track-&gt;meta-&gt;findData(kKeyHVCC, &amp;type, &amp;data, &amp;size)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data;</span><br><span class="line">       ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MPEG4Source(<span class="keyword">this</span>,</span><br><span class="line">            track-&gt;meta, mDataSource, track-&gt;timescale, track-&gt;sampleTable,</span><br><span class="line">            mSidxEntries, trex, mMoofOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到不同格式的 MP3Extractor、MPEG4Source ……</p><p>还记的前面提出的第一点疑问吗，现在我们知道了如何分离音视频了并且得到了相应的文件Source了。<br>图示（红线部分）：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-01-source-demux-decoder-output-MediaExtractor.jpg" alt="Alt text"></p><h4 id="（二）、多媒体文件-音视频解码（Decoder）"><a href="#（二）、多媒体文件-音视频解码（Decoder）" class="headerlink" title="（二）、多媒体文件 - 音视频解码（Decoder）"></a>（二）、多媒体文件 - 音视频解码（Decoder）</h4><p>音频解码、视频解码在何处，答案就在mMediaPlayer.start()流程当中，先看看start()总体时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-02-NuPlayer-Start-instantiateDecoder.png" alt="Alt text"></p><p>由于从Java层到JNI前面已多次分析，这里直接从NuPlayer::start()开始分析</p><h5 id="2-1、NuPlayer-start"><a href="#2-1、NuPlayer-start" class="headerlink" title="2.1、NuPlayer::start()"></a>2.1、NuPlayer::start()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            ALOGV(<span class="string">"kWhatStart"</span>);</span><br><span class="line">            <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">                <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">                <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">                    onResume();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                onStart();</span><br><span class="line">            &#125;</span><br><span class="line">            mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startPositionUs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        performSeek(startPositionUs);</span><br><span class="line">        <span class="keyword">if</span> (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOffloadAudio = <span class="literal">false</span>;</span><br><span class="line">    mAudioEOS = <span class="literal">false</span>;</span><br><span class="line">    mVideoEOS = <span class="literal">false</span>;</span><br><span class="line">    mStarted = <span class="literal">true</span>;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mSource-&gt;isRealTime()) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_REAL_TIME;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; audioMeta = mSource-&gt;getFormatMeta(<span class="literal">true</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    sp&lt;MetaData&gt; videoMeta = mSource-&gt;getFormatMeta(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line">    ......</span><br><span class="line">    ALOGV_IF(audioMeta == <span class="literal">NULL</span>, <span class="string">"no metadata for audio source"</span>);  <span class="comment">// video only stream</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">audio_stream_type_t</span> streamType = AUDIO_STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        streamType = mAudioSink-&gt;getAudioStreamType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; videoFormat = mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>);</span><br><span class="line"></span><br><span class="line">    mOffloadAudio =</span><br><span class="line">        canOffloadStream(audioMeta, (videoFormat != <span class="literal">NULL</span>), mSource-&gt;isStreaming(), streamType)</span><br><span class="line">                &amp;&amp; (mPlaybackSettings.mSpeed == <span class="number">1.f</span> &amp;&amp; mPlaybackSettings.mPitch == <span class="number">1.f</span>);</span><br><span class="line">    <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">        flags |= Renderer::FLAG_OFFLOAD_AUDIO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration;</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了名为NuPlayerRenderer的Renderer对象，然后启动循环，看看初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line">NuPlayer::Renderer::Renderer(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;MediaPlayerBase::AudioSink&gt; &amp;sink,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags)</span><br><span class="line">    : mAudioSink(sink),</span><br><span class="line">      mUseVirtualAudioSink(<span class="literal">false</span>),</span><br><span class="line">      mNotify(notify),</span><br><span class="line">      mFlags(flags),</span><br><span class="line">      mNumFramesWritten(<span class="number">0</span>),</span><br><span class="line">      mDrainAudioQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mDrainVideoQueuePending(<span class="literal">false</span>),</span><br><span class="line">      mAudioQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoQueueGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mVideoDrainGeneration(<span class="number">0</span>),</span><br><span class="line">      mAudioEOSGeneration(<span class="number">0</span>),</span><br><span class="line">      mPlaybackSettings(AUDIO_PLAYBACK_RATE_DEFAULT),</span><br><span class="line">      ......</span><br><span class="line">      mWakeLock(<span class="keyword">new</span> AWakeLock()) &#123;</span><br><span class="line">    mMediaClock = <span class="keyword">new</span> MediaClock;</span><br><span class="line">    mPlaybackRate = mPlaybackSettings.mSpeed;</span><br><span class="line">    mMediaClock-&gt;setPlaybackRate(mPlaybackRate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2、postScanSources"><a href="#2-2、postScanSources" class="headerlink" title="2.2、postScanSources()"></a>2.2、postScanSources()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::postScanSources() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatScanSources, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"generation"</span>, mScanSourcesGeneration);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int32_t</span> generation;</span><br><span class="line">            mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">bool</span> mHadAnySourcesBefore =</span><br><span class="line">                (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">            <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">            <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">                    rescan = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>此处调用了instantiateDecoder()来初始化音视频解码器Decoder</p><h5 id="2-3、instantiateDecoder"><a href="#2-3、instantiateDecoder" class="headerlink" title="2.3、instantiateDecoder()"></a>2.3、instantiateDecoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">status_t</span> NuPlayer::instantiateDecoder(</span><br><span class="line">        <span class="keyword">bool</span> audio, sp&lt;DecoderBase&gt; *decoder, <span class="keyword">bool</span> checkAudioModeChange) &#123;</span><br><span class="line">    ......</span><br><span class="line">    sp&lt;AMessage&gt; format = mSource-&gt;getFormat(audio);</span><br><span class="line"></span><br><span class="line">    format-&gt;setInt32(<span class="string">"priority"</span>, <span class="number">0</span> <span class="comment">/* realtime */</span>);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatAudioNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mAudioDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mAudioDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkAudioModeChange) &#123;</span><br><span class="line">            determineAudioModeChange(format);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mOffloadAudio) &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">true</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">bool</span> hasVideo = (mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/*audio */</span>) != <span class="literal">NULL</span>);</span><br><span class="line">            format-&gt;setInt32(<span class="string">"has-video"</span>, hasVideo);</span><br><span class="line">            *decoder = <span class="keyword">new</span> DecoderPassThrough(notify, mSource, mRenderer);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSource-&gt;setOffloadAudio(<span class="literal">false</span> <span class="comment">/* offload */</span>);</span><br><span class="line"></span><br><span class="line">            *decoder = <span class="keyword">new</span> Decoder(notify, mSource, mPID, mRenderer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatVideoNotify, <span class="keyword">this</span>);</span><br><span class="line">        ++mVideoDecoderGeneration;</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"generation"</span>, mVideoDecoderGeneration);</span><br><span class="line"></span><br><span class="line">        *decoder = <span class="keyword">new</span> Decoder(</span><br><span class="line">                notify, mSource, mPID, mRenderer, mSurface, mCCDecoder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enable FRC if high-quality AV sync is requested, even if not</span></span><br><span class="line">        <span class="comment">// directly queuing to display, as this will even improve textureview</span></span><br><span class="line">        <span class="comment">// playback.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> value[PROPERTY_VALUE_MAX];</span><br><span class="line">            <span class="keyword">if</span> (property_get(<span class="string">"persist.sys.media.avsync"</span>, value, <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (!<span class="built_in">strcmp</span>(<span class="string">"1"</span>, value) || !strcasecmp(<span class="string">"true"</span>, value))) &#123;</span><br><span class="line">                format-&gt;setInt32(<span class="string">"auto-frc"</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    (*decoder)-&gt;init();</span><br><span class="line">    (*decoder)-&gt;configure(format);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-1、创建音视频解码器new-Decoder"><a href="#2-3-1、创建音视频解码器new-Decoder" class="headerlink" title="2.3.1、创建音视频解码器new Decoder()"></a>2.3.1、创建音视频解码器new Decoder()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line">NuPlayer::Decoder::Decoder(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Source&gt; &amp;source,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Renderer&gt; &amp;renderer,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;CCDecoder&gt; &amp;ccDecoder)</span><br><span class="line">    : DecoderBase(notify),</span><br><span class="line">      mSurface(surface),</span><br><span class="line">      mSource(source),</span><br><span class="line">      mRenderer(renderer),</span><br><span class="line">      mCCDecoder(ccDecoder),</span><br><span class="line">      ......</span><br><span class="line">      mVideoWidth(<span class="number">0</span>),</span><br><span class="line">      mVideoHeight(<span class="number">0</span>),</span><br><span class="line">      mIsAudio(<span class="literal">true</span>),</span><br><span class="line">      ......</span><br><span class="line">      mComponentName(<span class="string">"decoder"</span>) &#123;</span><br><span class="line">    mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mCodecLooper-&gt;setName(<span class="string">"NPDecoder-CL"</span>);</span><br><span class="line">    mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mVideoTemporalLayerAggregateFps[<span class="number">0</span>] = mFrameRateTotal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建音视频解码器（NuPlayer::Decoder），为其创建名为NPDecoder-CL的mCodecLooper 【其父类NuPlayer::DecoderBase的构造中则会创建NPDecoder】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line">NuPlayer::DecoderBase::DecoderBase(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;notify)</span><br><span class="line">    :  mNotify(notify),</span><br><span class="line">       mBufferGeneration(<span class="number">0</span>),</span><br><span class="line">       mPaused(<span class="literal">false</span>),</span><br><span class="line">       mStats(<span class="keyword">new</span> AMessage),</span><br><span class="line">       mRequestInputBuffersPending(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// Every decoder has its own looper because MediaCodec operations</span></span><br><span class="line">    <span class="comment">// are blocking, but NuPlayer needs asynchronous operations.</span></span><br><span class="line">    mDecoderLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mDecoderLooper-&gt;setName(<span class="string">"NPDecoder"</span>);</span><br><span class="line">    mDecoderLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2、初始化Decoder-gt-init"><a href="#2-3-2、初始化Decoder-gt-init" class="headerlink" title="2.3.2、初始化Decoder-&gt;init()"></a>2.3.2、初始化Decoder-&gt;init()</h5><p>对该解码器进行init()操作，调用NuPlayer::DecoderBase::init()为mDecoderLooper注册handler【init()和configure()都是NuPlayerDecoder继承自NuPlayer::DecoderBase的方法】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoderBase.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::configure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setMessage(<span class="string">"format"</span>, format);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NuPlayer::DecoderBase::init() &#123;</span><br><span class="line">    mDecoderLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            CHECK(msg-&gt;findMessage(<span class="string">"format"</span>, &amp;format));</span><br><span class="line">            onConfigure(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>对该解码器进行configure(format)操作，调用NuPlayer::DecoderBase::configure(…)产生一个kWhatConfigure消息，然后消息处理中调用NuPlayer::Decoder::onConfigure(…)</p><h5 id="2-3-3、配置Decoder-gt-configure"><a href="#2-3-3、配置Decoder-gt-configure" class="headerlink" title="2.3.3、配置Decoder-&gt;configure()"></a>2.3.3、配置Decoder-&gt;configure()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onConfigure(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format) &#123;</span><br><span class="line">  </span><br><span class="line">    mFormatChangePending = <span class="literal">false</span>;</span><br><span class="line">    mTimeChangePending = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    ++mBufferGeneration;</span><br><span class="line"></span><br><span class="line">    AString mime;</span><br><span class="line"></span><br><span class="line">    mIsAudio = !strncasecmp(<span class="string">"audio/"</span>, mime.c_str(), <span class="number">6</span>);</span><br><span class="line">    mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str());</span><br><span class="line"></span><br><span class="line">    mComponentName = mime;</span><br><span class="line">    mComponentName.append(<span class="string">" decoder"</span>);</span><br><span class="line">    ALOGV(<span class="string">"[%s] onConfigure (surface=%p)"</span>, mComponentName.c_str(), mSurface.get());</span><br><span class="line"></span><br><span class="line">    mCodec = MediaCodec::CreateByType(</span><br><span class="line">            mCodecLooper, mime.c_str(), <span class="literal">false</span> <span class="comment">/* encoder */</span>, <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">    <span class="keyword">int32_t</span> secure = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (format-&gt;findInt32(<span class="string">"secure"</span>, &amp;secure) &amp;&amp; secure != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line">            mComponentName.append(<span class="string">".secure"</span>);</span><br><span class="line">            mCodec-&gt;release();</span><br><span class="line">            ALOGI(<span class="string">"[%s] creating"</span>, mComponentName.c_str());</span><br><span class="line">            mCodec = MediaCodec::CreateByComponentName(</span><br><span class="line">                    mCodecLooper, mComponentName.c_str(), <span class="literal">NULL</span> <span class="comment">/* err */</span>, mPid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    mIsSecure = secure;</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;getName(&amp;mComponentName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// disconnect from surface as MediaCodec will reconnect</span></span><br><span class="line">        err = native_window_api_disconnect(</span><br><span class="line">                mSurface.get(), NATIVE_WINDOW_API_MEDIA);</span><br><span class="line">        <span class="comment">// We treat this as a warning, as this is a preparatory step.</span></span><br><span class="line">        <span class="comment">// Codec will try to connect to the surface, which is where</span></span><br><span class="line">        <span class="comment">// any error signaling will occur.</span></span><br><span class="line">        ALOGW_IF(err != OK, <span class="string">"failed to disconnect from surface: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    err = mCodec-&gt;configure(</span><br><span class="line">            format, mSurface, <span class="literal">NULL</span> <span class="comment">/* crypto */</span>, <span class="number">0</span> <span class="comment">/* flags */</span>);</span><br><span class="line">    ......</span><br><span class="line">    rememberCodecSpecificData(format);</span><br><span class="line">    mStats-&gt;setString(<span class="string">"mime"</span>, mime.c_str());</span><br><span class="line">    mStats-&gt;setString(<span class="string">"component-name"</span>, mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int32_t</span> width, height;</span><br><span class="line">        <span class="keyword">if</span> (mOutputFormat-&gt;findInt32(<span class="string">"width"</span>, &amp;width)</span><br><span class="line">                &amp;&amp; mOutputFormat-&gt;findInt32(<span class="string">"height"</span>, &amp;height)) &#123;</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"width"</span>, width);</span><br><span class="line">            mStats-&gt;setInt32(<span class="string">"height"</span>, height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>);</span><br><span class="line">    mCodec-&gt;setCallback(reply);</span><br><span class="line"></span><br><span class="line">    err = mCodec-&gt;start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    releaseAndResetMediaBuffers();</span><br><span class="line"></span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    mResumePending = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在onConfigure中，首先会调用MediaCodec::CreateByType(…)或者MediaCodec::CreateByComponentName(…)根据情况创建MediaCodec，接着调用MediaCodec::init(…)，随后调用MediaCodec::configure(…)对MediaCodec进行配置使其转入Configured状态;然后又调用MediaCodec::start()使MediaCodec转入Executing状态。</p><h5 id="2-3-4、MediaCodec-init-…"><a href="#2-3-4、MediaCodec-init-…" class="headerlink" title="2.3.4、MediaCodec::init(…)"></a>2.3.4、MediaCodec::init(…)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByComponentName(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;name, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(name, <span class="literal">false</span> <span class="comment">/* nameIsType */</span>, <span class="literal">false</span> <span class="comment">/* encoder */</span>);</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;MediaCodec&gt; MediaCodec::CreateByType(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ALooper&gt; &amp;looper, <span class="keyword">const</span> AString &amp;mime, <span class="keyword">bool</span> encoder, <span class="keyword">status_t</span> *err, <span class="keyword">pid_t</span> pid) &#123;</span><br><span class="line">    sp&lt;MediaCodec&gt; codec = <span class="keyword">new</span> MediaCodec(looper, pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">status_t</span> ret = codec-&gt;init(mime, <span class="literal">true</span> <span class="comment">/* nameIsType */</span>, encoder);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *err = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret == OK ? codec : <span class="literal">NULL</span>; <span class="comment">// NULL deallocates codec.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::init(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType, <span class="keyword">bool</span> encoder) &#123;</span><br><span class="line">    mResourceManagerService-&gt;init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save init parameters for reset</span></span><br><span class="line">    mInitName = name;</span><br><span class="line">    mInitNameIsType = nameIsType;</span><br><span class="line">    mInitIsEncoder = encoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current video decoders do not return from OMX_FillThisBuffer</span></span><br><span class="line">    <span class="comment">// quickly, violating the OpenMAX specs, until that is remedied</span></span><br><span class="line">    <span class="comment">// we need to invest in an extra looper to free the main event</span></span><br><span class="line">    <span class="comment">// queue.</span></span><br><span class="line"></span><br><span class="line">    mCodec = GetCodecBase(name, nameIsType);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> secureCodec = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (nameIsType &amp;&amp; !strncasecmp(name.c_str(), <span class="string">"video/"</span>, <span class="number">6</span>)) &#123;</span><br><span class="line">        mIsVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AString tmp = name;</span><br><span class="line">        <span class="keyword">if</span> (tmp.endsWith(<span class="string">".secure"</span>)) &#123;</span><br><span class="line">            secureCodec = <span class="literal">true</span>;</span><br><span class="line">            tmp.erase(tmp.size() - <span class="number">7</span>, <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMediaCodecList&gt; mcl = MediaCodecList::getInstance();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">ssize_t</span> codecIdx = mcl-&gt;findCodecByName(tmp.c_str());</span><br><span class="line">        <span class="keyword">if</span> (codecIdx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;MediaCodecInfo&gt; info = mcl-&gt;getCodecInfo(codecIdx);</span><br><span class="line">            Vector&lt;AString&gt; mimes;</span><br><span class="line">            info-&gt;getSupportedMimes(&amp;mimes);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mimes.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mimes[i].startsWith(<span class="string">"video/"</span>)) &#123;</span><br><span class="line">                    mIsVideo = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mIsVideo) &#123;</span><br><span class="line">        <span class="comment">// video codec needs dedicated looper</span></span><br><span class="line">        <span class="keyword">if</span> (mCodecLooper == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mCodecLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">            mCodecLooper-&gt;setName(<span class="string">"CodecLooper"</span>);</span><br><span class="line">            mCodecLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mCodecLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mLooper-&gt;registerHandler(mCodec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper-&gt;registerHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mCodec-&gt;setNotificationMessage(<span class="keyword">new</span> AMessage(kWhatCodecNotify, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatInit, <span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;setString(<span class="string">"name"</span>, name);</span><br><span class="line">    msg-&gt;setInt32(<span class="string">"nameIsType"</span>, nameIsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nameIsType) &#123;</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"encoder"</span>, encoder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    Vector&lt;MediaResource&gt; resources;</span><br><span class="line">    MediaResource::Type type =</span><br><span class="line">            secureCodec ? MediaResource::kSecureCodec : MediaResource::kNonSecureCodec;</span><br><span class="line">    MediaResource::SubType subtype =</span><br><span class="line">            mIsVideo ? MediaResource::kVideoCodec : MediaResource::kAudioCodec;</span><br><span class="line">    resources.push_back(MediaResource(type, subtype, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= kMaxRetry; ++i) &#123;</span><br><span class="line">        </span><br><span class="line">        sp&lt;AMessage&gt; response;</span><br><span class="line">        err = PostAndAwaitResponse(msg, &amp;response);</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-1、GetCodecBase"><a href="#2-3-4-1、GetCodecBase" class="headerlink" title="2.3.4.1、GetCodecBase"></a>2.3.4.1、GetCodecBase</h5><p>当编解码以”omx.”开头则创建ACodec对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">sp&lt;CodecBase&gt; MediaCodec::GetCodecBase(<span class="keyword">const</span> AString &amp;name, <span class="keyword">bool</span> nameIsType) &#123;</span><br><span class="line">    <span class="comment">// at this time only ACodec specifies a mime type.</span></span><br><span class="line">    <span class="keyword">if</span> (nameIsType || name.startsWithIgnoreCase(<span class="string">"omx."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ACodec;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWithIgnoreCase(<span class="string">"android.filter."</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MediaFilter;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-3-4-2、MediaCodecList-getInstance"><a href="#2-3-4-2、MediaCodecList-getInstance" class="headerlink" title="2.3.4.2、MediaCodecList::getInstance()"></a>2.3.4.2、MediaCodecList::getInstance()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getInstance() &#123;</span><br><span class="line">    Mutex::Autolock _l(sRemoteInitMutex);</span><br><span class="line">    <span class="keyword">if</span> (sRemoteList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sp&lt;IBinder&gt; binder =</span><br><span class="line">            defaultServiceManager()-&gt;getService(String16(<span class="string">"media.player"</span>));</span><br><span class="line">        sp&lt;IMediaPlayerService&gt; service =</span><br><span class="line">            interface_cast&lt;IMediaPlayerService&gt;(binder);</span><br><span class="line">        <span class="keyword">if</span> (service.get() != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sRemoteList = service-&gt;getCodecList();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sRemoteList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Binder通信获取MediaCodec列表。getCodecList()函数实现在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\MediaPlayerService.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaPlayerService::getCodecList() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MediaCodecList::getLocalInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodecList.cpp]</span><br><span class="line">sp&lt;IMediaCodecList&gt; MediaCodecList::getLocalInstance() &#123;</span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(sInitMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sCodecList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MediaCodecList *codecList = <span class="keyword">new</span> MediaCodecList;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sCodecList;</span><br><span class="line">&#125;</span><br><span class="line">MediaCodecList::MediaCodecList()</span><br><span class="line">    : mInitCheck(NO_INIT),</span><br><span class="line">      mUpdate(<span class="literal">false</span>),</span><br><span class="line">      mGlobalSettings(<span class="keyword">new</span> AMessage()) &#123;</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs.xml"</span>);</span><br><span class="line">    parseTopLevelXMLFile(<span class="string">"/etc/media_codecs_performance.xml"</span>, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">    parseTopLevelXMLFile(kProfilingResults, <span class="literal">true</span><span class="comment">/* ignore_errors */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O(∩_∩)O哈哈~，终于分析到Codecs加载的地方了。还记得第一章节分析的附录吗，高通的音视频硬解码，这里再贴一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line"></span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br></pre></td></tr></table></figure><h5 id="2-3-5、MediaCodec-gt-configure"><a href="#2-3-5、MediaCodec-gt-configure" class="headerlink" title="2.3.5、MediaCodec-&gt;configure()"></a>2.3.5、MediaCodec-&gt;configure()</h5><p>产生kWhatConfigure消息，在消息处理中调用ACodec::initiateConfigureComponent(…)又产生消息kWhatConfigureComponent，然后该消息处理中又调用了ACodec::LoadedState::onConfigureComponent(…)。然后在其中又会先调用ACodec::configureCodec(…)，在configureCodec中会对IOMX进行一系列的设置以及配置操作，通过Binder通信就对OMXNodeInstance进行相应的设置和配置操作，最终就对OMX组件进行了相应的设置和配置。然后向MediaCodec发送kWhatComponentConfigured消息，在消息处理中将MediaCodec状态设为CONFIGURED；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::configure(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;format,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;Surface&gt; &amp;surface,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ICrypto&gt; &amp;crypto,</span><br><span class="line">        <span class="keyword">uint32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatConfigure, <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">case</span> kWhatConfigure:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            sp&lt;AMessage&gt; format;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                format-&gt;setObject(<span class="string">"native-window"</span>, obj);</span><br><span class="line">                <span class="keyword">status_t</span> err = handleSetSurface(<span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                handleSetSurface(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mReplyID = replyID;</span><br><span class="line">            setState(CONFIGURING);</span><br><span class="line">            ......</span><br><span class="line">            extractCSD(format);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateConfigureComponent(format);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateConfigureComponent(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    msg-&gt;setWhat(kWhatConfigureComponent);</span><br><span class="line">    msg-&gt;setTarget(<span class="keyword">this</span>);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatConfigureComponent:</span><br><span class="line">        &#123;</span><br><span class="line">            onConfigureComponent(msg);</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">bool</span> ACodec::LoadedState::onConfigureComponent(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    AString mime;</span><br><span class="line">    <span class="keyword">if</span> (!msg-&gt;findString(<span class="string">"mime"</span>, &amp;mime)) &#123;</span><br><span class="line">        err = BAD_VALUE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = mCodec-&gt;configureCodec(mime.c_str(), msg);</span><br><span class="line">    &#125;</span><br><span class="line">   ......</span><br><span class="line">    &#123;</span><br><span class="line">        sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">        notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatComponentConfigured);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"input-format"</span>, mCodec-&gt;mInputFormat);</span><br><span class="line">        notify-&gt;setMessage(<span class="string">"output-format"</span>, mCodec-&gt;mOutputFormat);</span><br><span class="line">        notify-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-6、MediaCodec-gt-start"><a href="#2-3-6、MediaCodec-gt-start" class="headerlink" title="2.3.6、MediaCodec-&gt;start()"></a>2.3.6、MediaCodec-&gt;start()</h5><p>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> MediaCodec::start() &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">case</span> kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            sp&lt;AReplyToken&gt; replyID;</span><br><span class="line">            ......</span><br><span class="line">            setState(STARTING);</span><br><span class="line"></span><br><span class="line">            mCodec-&gt;initiateStart();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::initiateStart() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> ACodec::kWhatStart:</span><br><span class="line">        &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            handled = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::LoadedState::onStart() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;sendCommand(mCodec-&gt;mNode, OMX_CommandStateSet, OMX_StateIdle);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mCodec-&gt;changeState(mCodec-&gt;mLoadedToIdleState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦缓冲区成功分配到输入和输出端口，OMX组件（编解码）会为Loaded-to-Idle状态生成OMX_EventCmdComplete事件转换并使用EventHandlerCallback将其发送给客户端。</p><h4 id="（三）、音视频解码数据处理"><a href="#（三）、音视频解码数据处理" class="headerlink" title="（三）、音视频解码数据处理"></a>（三）、音视频解码数据处理</h4><h5 id="3-1、音视频解码数据处理-emptyBuffer"><a href="#3-1、音视频解码数据处理-emptyBuffer" class="headerlink" title="3.1、音视频解码数据处理-emptyBuffer"></a>3.1、音视频解码数据处理-emptyBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-03-acodec-emptyBuffer.png" alt="Alt text"></p><p>1、    MediaCodec::start()之后ACodec是在LoadedToIdleState状态，此时若ACodec::LoadedToIdleState::onOMXEvent(…)接收到组件转换至Idle状态后的OMX_EventCmdComplete事件，会向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Executing状态（这里OMX会发送OMX_EventCmdComplete事件），然后ACodec进行changeState至IdleToExecutingState。<br>2、    此时ACodec::IdleToExecutingState::onOMXEvent(…)检测到上面的OMX_EventCmdComplete事件后，会首先调用函数ACodec::ExecutingState::resume()，然后对ACodec进行changeState至ExecutingState。</p><h5 id="3-1-1、ACodec-ExecutingState-resume"><a href="#3-1-1、ACodec-ExecutingState-resume" class="headerlink" title="3.1.1、ACodec::ExecutingState::resume()"></a>3.1.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::postFillThisBuffer(BufferInfo *info) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CHECK_EQ((<span class="keyword">int</span>)info-&gt;mStatus, (<span class="keyword">int</span>)BufferInfo::OWNED_BY_US);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatFillThisBuffer);</span><br><span class="line">    notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    info-&gt;mData-&gt;meta()-&gt;clear();</span><br><span class="line">    notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatInputBufferFilled, mCodec);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">    notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">    notify-&gt;post();</span><br><span class="line"></span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_UPSTREAM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数ACodec::ExecutingState::resume()中会调用ACodec::BaseState::postFillThisBuffer(…)，然后其中会先向MediaCodec发送kWhatFillThisBuffer消息，消息处理中在满足相应的条件下就会去调用函数MediaCodec::onInputBufferAvailable()来通知NuPlayer::Decoder有可用的inputbuffer；然后再生成kWhatInputBufferFilled消息，消息处理中调用ACodec::BaseState::onInputBufferFilled(…)。<br>【产生两个消息，一个向上(MediaCodec)处理，一个向下(OMX)处理】</p><h5 id="3-1-1-1、kWhatFillThisBuffer消息处理"><a href="#3-1-1-1、kWhatFillThisBuffer消息处理" class="headerlink" title="3.1.1.1、kWhatFillThisBuffer消息处理"></a>3.1.1.1、kWhatFillThisBuffer消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line">                <span class="keyword">case</span> CodecBase::kWhatFillThisBuffer:</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* size_t index = */</span>updateBuffers(kPortIndexInput, msg);</span><br><span class="line">                    ......</span><br><span class="line">                    <span class="keyword">if</span> (mFlags &amp; kFlagIsAsync) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mHaveInputSurface) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (mState == FLUSHED) &#123;</span><br><span class="line">                                mHavePendingInputBuffers = <span class="literal">true</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                onInputBufferAvailable();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFlags &amp; kFlagDequeueInputPending) &#123;</span><br><span class="line">                        ++mDequeueInputTimeoutGeneration;</span><br><span class="line">                        mFlags &amp;= ~kFlagDequeueInputPending;</span><br><span class="line">                        mDequeueInputReplyID = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        postActivityNotificationIfPossible();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onInputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexInput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_INPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 1：MediaCodec::onInputBufferAvailable()的调用：<br>其中会先调用函数MediaCodec::dequeuePortBuffer(…)获取buffer的索引，然后将一个新消息发送给NuPlayer::Decoder，并设置消息的callbackID为CB_INPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_INPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnInputBuffer(…)，其会：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">case</span> MediaCodec::CB_INPUT_AVAILABLE:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"index"</span>, &amp;index));</span><br><span class="line"></span><br><span class="line">    handleAnInputBuffer(index);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnInputBuffer(<span class="keyword">size_t</span> index) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getInputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mInputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mInputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mInputBuffers.add();</span><br><span class="line">            mMediaBuffers.add();</span><br><span class="line">            mInputBufferIsDequeued.add();</span><br><span class="line">            mMediaBuffers.editItemAt(i) = <span class="literal">NULL</span>;</span><br><span class="line">            mInputBufferIsDequeued.editItemAt(i) = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mMediaBuffers[index] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mMediaBuffers[index]-&gt;release();</span><br><span class="line">        mMediaBuffers.editItemAt(index) = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mInputBufferIsDequeued.editItemAt(index) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCSDsToSubmit.isEmpty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage();</span><br><span class="line">        msg-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line"></span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mCSDsToSubmit.itemAt(<span class="number">0</span>);</span><br><span class="line">        msg-&gt;setBuffer(<span class="string">"buffer"</span>, buffer);</span><br><span class="line">        mCSDsToSubmit.removeAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mPendingInputMessages.empty()) &#123;</span><br><span class="line">        sp&lt;AMessage&gt; msg = *mPendingInputMessages.begin();</span><br><span class="line">        <span class="keyword">if</span> (!onInputBufferFetched(msg)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingInputMessages.erase(mPendingInputMessages.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mInputBufferIsDequeued.editItemAt(index)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDequeuedInputBuffers.push_back(index);</span><br><span class="line"></span><br><span class="line">    onRequestInputBuffers();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>○1、先通过MediaCodec::getInputBuffer(…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer</p><p>○2、然后调用NuPlayer::Decoder::onInputBufferFetched(…)执行内存拷贝将buffer拷贝到编解码器，然后又调用了MediaCodec::queueInputBuffer(…)将buffer提交给解码器，其会产生消息kWhatQueueInputBuffer，消息处理中调用MediaCodec::onQueueInputBuffer(…)</p><p>○3、之后调用函数NuPlayer::DecoderBase::onRequestInputBuffers()，处理是否需要更多的数据。其中会调用NuPlayer::Decoder::doRequestBuffers，若返回true则需要更多的数据，则会产生新消息kWhatRequestInputBuffers，消息处理中又将调用onRequestInputBuffers。（实际获取更多缓冲的操作在下面ACodec部分完成）</p><h5 id="3-1-1-2、kWhatInputBufferFilled消息处理"><a href="#3-1-1-2、kWhatInputBufferFilled消息处理" class="headerlink" title="3.1.1.2、kWhatInputBufferFilled消息处理"></a>3.1.1.2、kWhatInputBufferFilled消息处理</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line">        <span class="keyword">case</span> kWhatInputBufferFilled:</span><br><span class="line">        &#123;</span><br><span class="line">            onInputBufferFilled(msg);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onInputBufferFilled(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    <span class="keyword">int32_t</span> err = OK;</span><br><span class="line">    <span class="keyword">bool</span> eos = <span class="literal">false</span>;</span><br><span class="line">    PortMode mode = getPortMode(kPortIndexInput);</span><br><span class="line">    <span class="keyword">int32_t</span> tmp;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexInput, bufferID);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (buffer != <span class="literal">NULL</span> &amp;&amp; !mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">                CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">                OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;</span><br><span class="line"></span><br><span class="line">                MetadataBufferType metaType = mCodec-&gt;mInputMetadataType;</span><br><span class="line">                <span class="keyword">int32_t</span> isCSD = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (buffer-&gt;meta()-&gt;findInt32(<span class="string">"csd"</span>, &amp;isCSD) &amp;&amp; isCSD != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mCodec-&gt;mIsLegacyVP9Decoder) &#123;</span><br><span class="line">                        postFillThisBuffer(info);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flags |= OMX_BUFFERFLAG_CODECCONFIG;</span><br><span class="line">                    metaType = kMetadataBufferTypeInvalid;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">               ......</span><br><span class="line">                <span class="keyword">if</span> (buffer != info-&gt;mCodecData) &#123;</span><br><span class="line">                    sp&lt;DataConverter&gt; converter = mCodec-&gt;mConverter[kPortIndexInput];</span><br><span class="line">                    <span class="keyword">status_t</span> err = converter-&gt;convert(buffer, info-&gt;mCodecData);</span><br><span class="line">                &#125;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">status_t</span> err2 = OK;</span><br><span class="line">                <span class="keyword">switch</span> (metaType) &#123;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeInvalid:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeNativeHandleSource:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeHandleMetadata)) &#123;</span><br><span class="line">                        VideoNativeHandleMetadata *vnhmd =</span><br><span class="line">                            (VideoNativeHandleMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateNativeHandleInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                NativeHandle::create(vnhmd-&gt;pHandle, <span class="literal">false</span> <span class="comment">/* ownsHandle */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> kMetadataBufferTypeANWBuffer:</span><br><span class="line">                    <span class="keyword">if</span> (info-&gt;mCodecData-&gt;size() &gt;= <span class="keyword">sizeof</span>(VideoNativeMetadata)) &#123;</span><br><span class="line">                        VideoNativeMetadata *vnmd = (VideoNativeMetadata*)info-&gt;mCodecData-&gt;base();</span><br><span class="line">                        err2 = mCodec-&gt;mOMX-&gt;updateGraphicBufferInMeta(</span><br><span class="line">                                mCodec-&gt;mNode, kPortIndexInput,</span><br><span class="line">                                <span class="keyword">new</span> GraphicBuffer(vnmd-&gt;pBuffer, <span class="literal">false</span> <span class="comment">/* keepOwnership */</span>),</span><br><span class="line">                                bufferID);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    err2 = ERROR_UNSUPPORTED;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (err2 == OK) &#123;</span><br><span class="line">                    err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mCodecData-&gt;size(),</span><br><span class="line">                        flags,</span><br><span class="line">                        timeUs,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!eos &amp;&amp; err == OK) &#123;</span><br><span class="line">                    getMoreInputDataIfPossible();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ALOGV(<span class="string">"[%s] Signalled EOS (%d) on the input port"</span>,</span><br><span class="line">                         mCodec-&gt;mComponentName.c_str(), err);</span><br><span class="line"></span><br><span class="line">                    mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                    mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mCodec-&gt;mPortEOS[kPortIndexInput]) &#123;</span><br><span class="line">                ......</span><br><span class="line"></span><br><span class="line">                info-&gt;checkReadFence(<span class="string">"onInputBufferFilled"</span>);</span><br><span class="line">                <span class="keyword">status_t</span> err2 = mCodec-&gt;mOMX-&gt;emptyBuffer(</span><br><span class="line">                        mCodec-&gt;mNode,</span><br><span class="line">                        bufferID,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        OMX_BUFFERFLAG_EOS,</span><br><span class="line">                        <span class="number">0</span>,</span><br><span class="line">                        info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexInput] = <span class="literal">true</span>;</span><br><span class="line">                mCodec-&gt;mInputEOSResult = err;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. 2：ACodec::BaseState::onInputBufferFilled(…)的调用：<br>因为当前ACodec在ExecutingState，所以PortMode为RESUBMIT_BUFFERS，故会调用IOMX的emptyBuffer(…)方法，经过进程间通信调用到OMX::emptyBuffer(…)，并最终调用OMXNodeInstance::emptyBuffer(…)，其中又会调用到函数OMXNodeInstance::emptyBuffer_l(…)，其则会调用OMX_EmptyThisBuffer宏对OMX组件进行相关的操作（根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent</p><p>○1、其的构造函数的初始化列表中有mComponent-&gt;EmptyThisBuffer = EmptyThisBufferWrapper;故实际会调用其EmptyThisBufferWrapper(…)函数，而其中调用SoftOMXComponent的虚函数emptyThisBuffer。</p><p>○2、所以调用子类的emptyThisBuffer即SimpleSoftOMXComponent::emptyThisBuffer(…)产生kWhatEmptyThisBuffer消息，消息处理中实际的解码器就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyEmptyBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。</p><p>○4、调用到OMXNodeInstance::OnEmptyBufferDone(…)，其又会调用OMX::OnEmptyBufferDone(…)，然后在其中会发送omx_message::EMPTY_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState::onOMXEmptyBufferDone(…)</p><p>○5、在onOMXEmptyBufferDone中获取PortMode，为RESUBMIT_BUFFERS则ACodec::BaseState::postFillThisBuffer(…)被调用，从而又从3中的postFillThisBuffer开始循环执行相关操作以处理更多的输入缓冲。</p><h5 id="3-2、音视频解码数据处理-fillBuffer"><a href="#3-2、音视频解码数据处理-fillBuffer" class="headerlink" title="3.2、音视频解码数据处理-fillBuffer"></a>3.2、音视频解码数据处理-fillBuffer</h5><p>还是老样子，先看看时序图，然后一步步分析</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-04-acodec-fillBuffer.png" alt="Alt text"></p><h5 id="3-2-1、ACodec-ExecutingState-resume"><a href="#3-2-1、ACodec-ExecutingState-resume" class="headerlink" title="3.2.1、ACodec::ExecutingState::resume()"></a>3.2.1、ACodec::ExecutingState::resume()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::resume() &#123;</span><br><span class="line">    submitOutputBuffers();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexInput].size(); i++) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexInput].editItemAt(i);</span><br><span class="line">        <span class="keyword">if</span> (info-&gt;mStatus == BufferInfo::OWNED_BY_US) &#123;</span><br><span class="line">            postFillThisBuffer(info);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitOutputBuffers() &#123;</span><br><span class="line">    submitRegularOutputBuffers();</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        submitOutputMetaBuffers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ACodec::ExecutingState::submitRegularOutputBuffers() &#123;</span><br><span class="line">    <span class="keyword">bool</span> failed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mCodec-&gt;mBuffers[kPortIndexOutput].size(); ++i) &#123;</span><br><span class="line">        BufferInfo *info = &amp;mCodec-&gt;mBuffers[kPortIndexOutput].editItemAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;checkWriteFence(<span class="string">"submitRegularOutputBuffers"</span>);</span><br><span class="line">        <span class="keyword">status_t</span> err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        ......</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、ACodec::ExecutingState::resume()函数，在resume()中调用ACodec::BaseState::postFillThisBuffer(…)前会先调用函数ACodec::ExecutingState::submitOutputBuffers()，即在获取输入数据前会先把输出端的数据提交出去。</p><p>2、在submitOutputBuffers()中调用ACodec::ExecutingState::submitRegularOutputBuffers()，其中又会调用到IOMX的fillBuffer (…)方法，经过进程间通信调用到OMX:: fillBuffer (…)，并最终调用OMXNodeInstance:: fillBuffer (…)，其中又会调用到OMX_FillThisBuffer宏对OMX组件进行相关的操作（同样根据需要选择相应的软解组件或者硬解组件）。对于软解组件SoftOMXComponent：（下面的操作与emptyBuffer时类似）</p><p>○1、在其构造函数的初始化列表中有mComponent-&gt;FillThisBuffer = FillThisBufferWrapper;所以实际会调用到其FillThisBufferWrapper (…)函数<br>○2、然后调用SimpleSoftOMXComponent::fillThisBuffer(…)产生kWhatFillThisBuffer消息，消息处理中实际的组件就要调用onQueueFilled(…)函数【实际组件继承自SimpleSoftOMXComponent】</p><p>○3、接着会调用SoftOMXComponent::notifyFillBufferDone(…)使用OMX的回调机制，闭环发送消息到OMX客户端ACodec。<br>○4之后调用到OMXNodeInstance:: OnFillBufferDone (…)函数，其又会调用OMX:: OnFillBufferDone (…)，然后在其中会发送omx_message:: FILL_BUFFER_DONE消息，ACodec中收到该消息【CodecObserver中先收到，但只设置消息】调用ACodec::BaseState:: onOMXFillBufferDone (…)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">bool</span> ACodec::BaseState::onOMXFillBufferDone(</span><br><span class="line">        IOMX::buffer_id bufferID,</span><br><span class="line">        <span class="keyword">size_t</span> rangeOffset, <span class="keyword">size_t</span> rangeLength,</span><br><span class="line">        OMX_U32 flags,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int</span> fenceFd) &#123;</span><br><span class="line">    ALOGV(<span class="string">"[%s] onOMXFillBufferDone %u time %"</span> PRId64 <span class="string">" us, flags = 0x%08x"</span>,</span><br><span class="line">         mCodec-&gt;mComponentName.c_str(), bufferID, timeUs, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    <span class="keyword">status_t</span> err= OK;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACK_BUFFER_TIMING</span></span><br><span class="line">    index = mCodec-&gt;mBufferStats.indexOfKey(timeUs);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ACodec::BufferStats *stats = &amp;mCodec-&gt;mBufferStats.editValueAt(index);</span><br><span class="line">        stats-&gt;mFillBufferDoneTimeUs = ALooper::GetNowUs();</span><br><span class="line"></span><br><span class="line">        ALOGI(<span class="string">"frame PTS %lld: %lld"</span>,</span><br><span class="line">                timeUs,</span><br><span class="line">                stats-&gt;mFillBufferDoneTimeUs - stats-&gt;mEmptyBufferTimeUs);</span><br><span class="line"></span><br><span class="line">        mCodec-&gt;mBufferStats.removeItemsAt(index);</span><br><span class="line">        stats = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    BufferInfo *info =</span><br><span class="line">        mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_COMPONENT) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in FBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">if</span> (fenceFd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ::close(fenceFd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    info-&gt;mDequeuedAt = ++mCodec-&gt;mDequeueCounter;</span><br><span class="line">    info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info-&gt;mRenderInfo != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// The fence for an emptied buffer must have signaled, but there still could be queued</span></span><br><span class="line">        <span class="comment">// or out-of-order dequeued buffers in the render queue prior to this buffer. Drop these,</span></span><br><span class="line">        <span class="comment">// as we will soon requeue this buffer to the surface. While in theory we could still keep</span></span><br><span class="line">        <span class="comment">// track of buffers that are requeued to the surface, it is better to add support to the</span></span><br><span class="line">        <span class="comment">// buffer-queue to notify us of released buffers and their fences (in the future).</span></span><br><span class="line">        mCodec-&gt;notifyOfRenderedFrames(<span class="literal">true</span> <span class="comment">/* dropIncomplete */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte buffers cannot take fences, so wait for any fence now</span></span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mCodec-&gt;waitForFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line">        fenceFd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info-&gt;setReadFence(fenceFd, <span class="string">"onOMXFillBufferDone"</span>);</span><br><span class="line"></span><br><span class="line">    PortMode mode = getPortMode(kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">        <span class="keyword">case</span> KEEP_BUFFERS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> RESUBMIT_BUFFERS:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (rangeLength == <span class="number">0</span> &amp;&amp; (!(flags &amp; OMX_BUFFERFLAG_EOS)</span><br><span class="line">                    || mCodec-&gt;mPortEOS[kPortIndexOutput])) &#123;</span><br><span class="line">                ......</span><br><span class="line">                err = mCodec-&gt;mOMX-&gt;fillBuffer(mCodec-&gt;mNode, info-&gt;mBufferID, info-&gt;mFenceFd);</span><br><span class="line">                info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">                ......</span><br><span class="line">                info-&gt;mStatus = BufferInfo::OWNED_BY_COMPONENT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; reply =</span><br><span class="line">                <span class="keyword">new</span> AMessage(kWhatOutputBufferDrained, mCodec);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mOutputFormat != mCodec-&gt;mLastOutputFormat &amp;&amp; rangeLength &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// pretend that output format has changed on the first frame (we used to do this)</span></span><br><span class="line">                <span class="keyword">if</span> (mCodec-&gt;mBaseOutputFormat == mCodec-&gt;mOutputFormat) &#123;</span><br><span class="line">                    mCodec-&gt;onOutputFormatChanged(mCodec-&gt;mOutputFormat);</span><br><span class="line">                &#125;</span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">                mCodec-&gt;sendFormatChange();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeLength &gt; <span class="number">0</span> &amp;&amp; mCodec-&gt;mNativeWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// If potentially rendering onto a surface, always save key format data (crop &amp;</span></span><br><span class="line">                <span class="comment">// data space) so that we can set it if and once the buffer is rendered.</span></span><br><span class="line">                mCodec-&gt;addKeyFormatChangesToRenderBufferNotification(reply);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;usingMetadataOnEncoderOutput()) &#123;</span><br><span class="line">                <span class="keyword">native_handle_t</span> *handle = <span class="literal">NULL</span>;</span><br><span class="line">                VideoNativeHandleMetadata &amp;nativeMeta =</span><br><span class="line">                    *(VideoNativeHandleMetadata *)info-&gt;mData-&gt;data();</span><br><span class="line">                <span class="keyword">if</span> (info-&gt;mData-&gt;size() &gt;= <span class="keyword">sizeof</span>(nativeMeta)</span><br><span class="line">                        &amp;&amp; nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS</span></span><br><span class="line">                    <span class="comment">// handle is only valid on 32-bit/mediaserver process</span></span><br><span class="line">                    handle = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">                    handle = (<span class="keyword">native_handle_t</span> *)nativeMeta.pHandle;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">                &#125;</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setPointer(<span class="string">"handle"</span>, handle);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeOffset"</span>, rangeOffset);</span><br><span class="line">                info-&gt;mData-&gt;meta()-&gt;setInt32(<span class="string">"rangeLength"</span>, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info-&gt;mData == info-&gt;mCodecData) &#123;</span><br><span class="line">                info-&gt;mData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                info-&gt;mCodecData-&gt;setRange(rangeOffset, rangeLength);</span><br><span class="line">                <span class="comment">// in this case we know that mConverter is not null</span></span><br><span class="line">                <span class="keyword">status_t</span> err = mCodec-&gt;mConverter[kPortIndexOutput]-&gt;convert(</span><br><span class="line">                        info-&gt;mCodecData, info-&gt;mData);</span><br><span class="line">                <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                    mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCodec-&gt;mSkipCutBuffer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                mCodec-&gt;mSkipCutBuffer-&gt;submit(info-&gt;mData);</span><br><span class="line">            &#125;</span><br><span class="line">            info-&gt;mData-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">            sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatDrainThisBuffer);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line">            notify-&gt;setBuffer(<span class="string">"buffer"</span>, info-&gt;mData);</span><br><span class="line">            notify-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">            reply-&gt;setInt32(<span class="string">"buffer-id"</span>, info-&gt;mBufferID);</span><br><span class="line"></span><br><span class="line">            notify-&gt;setMessage(<span class="string">"reply"</span>, reply);</span><br><span class="line"></span><br><span class="line">            notify-&gt;post();</span><br><span class="line"></span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_DOWNSTREAM;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">                ALOGV(<span class="string">"[%s] saw output EOS"</span>, mCodec-&gt;mComponentName.c_str());</span><br><span class="line"></span><br><span class="line">                sp&lt;AMessage&gt; notify = mCodec-&gt;mNotify-&gt;dup();</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"what"</span>, CodecBase::kWhatEOS);</span><br><span class="line">                notify-&gt;setInt32(<span class="string">"err"</span>, mCodec-&gt;mInputEOSResult);</span><br><span class="line">                notify-&gt;post();</span><br><span class="line"></span><br><span class="line">                mCodec-&gt;mPortEOS[kPortIndexOutput] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> FREE_BUFFERS:</span><br><span class="line">            err = mCodec-&gt;freeBuffer(kPortIndexOutput, index);</span><br><span class="line">            <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">                mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"Invalid port mode: %d"</span>, mode);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>○5、在onOMXFillBufferDone中获取PortMode，为RESUBMIT_BUFFERS则首先如果需要继续调用到IOMX的fillBuffer (…)填充输出缓冲重复做相关操作，接着ACodec又会生成一个kWhatOutputBufferDrained消息存在reply中，作为kWhatDrainThisBuffer消息的返回消息【notify-&gt;setMessage(“reply”, reply);】，然后向MediaCodec发送消息kWhatDrainThisBuffer，消息处理中调用函数MediaCodec::onOutputBufferAvailable()通知NuPlayer::Decoder有可用的output buffer，其中会设置消息的callbackID为CB_OUTPUT_AVAILABLE，同时设置index，接着NuPlayer::Decoder接收到该CB_OUTPUT_AVAILABLE消息，在消息处理中调用NuPlayer::Decoder::handleAnOutputBuffer(…)，在其中会进行如下处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\MediaCodec.cpp]</span><br><span class="line"><span class="keyword">void</span> MediaCodec::onOutputBufferAvailable() &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> index;</span><br><span class="line">    <span class="keyword">while</span> ((index = dequeuePortBuffer(kPortIndexOutput)) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> sp&lt;ABuffer&gt; &amp;buffer =</span><br><span class="line">            mPortBuffers[kPortIndexOutput].itemAt(index).mData;</span><br><span class="line">        sp&lt;AMessage&gt; msg = mCallback-&gt;dup();</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"callbackID"</span>, CB_OUTPUT_AVAILABLE);</span><br><span class="line">        msg-&gt;setInt32(<span class="string">"index"</span>, index);</span><br><span class="line">        msg-&gt;setSize(<span class="string">"offset"</span>, buffer-&gt;offset());</span><br><span class="line">        msg-&gt;setSize(<span class="string">"size"</span>, buffer-&gt;size());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs));</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int32_t</span> omxFlags;</span><br><span class="line">        CHECK(buffer-&gt;meta()-&gt;findInt32(<span class="string">"omxFlags"</span>, &amp;omxFlags));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">uint32_t</span> flags = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_SYNCFRAME) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_SYNCFRAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_CODECCONFIG) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_CODECCONFIG;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (omxFlags &amp; OMX_BUFFERFLAG_EOS) &#123;</span><br><span class="line">            flags |= BUFFER_FLAG_EOS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg-&gt;setInt32(<span class="string">"flags"</span>, flags);</span><br><span class="line"></span><br><span class="line">        msg-&gt;post();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（四）、多媒体文件-音视频渲染（Renderer）"><a href="#（四）、多媒体文件-音视频渲染（Renderer）" class="headerlink" title="（四）、多媒体文件 - 音视频渲染（Renderer）"></a>（四）、多媒体文件 - 音视频渲染（Renderer）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">bool</span> NuPlayer::Decoder::handleAnOutputBuffer(</span><br><span class="line">        <span class="keyword">size_t</span> index,</span><br><span class="line">        <span class="keyword">size_t</span> offset,</span><br><span class="line">        <span class="keyword">size_t</span> size,</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs,</span><br><span class="line">        <span class="keyword">int32_t</span> flags) &#123;</span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    mCodec-&gt;getOutputBuffer(index, &amp;buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= mOutputBuffers.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = mOutputBuffers.size(); i &lt;= index; ++i) &#123;</span><br><span class="line">            mOutputBuffers.add();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mOutputBuffers.editItemAt(index) = buffer;</span><br><span class="line"></span><br><span class="line">    buffer-&gt;setRange(offset, size);</span><br><span class="line">    buffer-&gt;meta()-&gt;clear();</span><br><span class="line">    buffer-&gt;meta()-&gt;setInt64(<span class="string">"timeUs"</span>, timeUs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> eos = flags &amp; MediaCodec::BUFFER_FLAG_EOS;</span><br><span class="line">    <span class="comment">// we do not expect CODECCONFIG or SYNCFRAME for decoder</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; reply = <span class="keyword">new</span> AMessage(kWhatRenderBuffer, <span class="keyword">this</span>);</span><br><span class="line">    reply-&gt;setSize(<span class="string">"buffer-ix"</span>, index);</span><br><span class="line">    reply-&gt;setInt32(<span class="string">"generation"</span>, mBufferGeneration);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eos) &#123;</span><br><span class="line">        buffer-&gt;meta()-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">        reply-&gt;setInt32(<span class="string">"eos"</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSkipRenderingUntilMediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (timeUs &lt; mSkipRenderingUntilMediaTimeUs) &#123;</span><br><span class="line">            reply-&gt;post();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSkipRenderingUntilMediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mNumFramesTotal += !mIsAudio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait until 1st frame comes out to signal resume complete</span></span><br><span class="line">    notifyResumeCompleteIfNecessary();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// send the buffer to renderer.</span></span><br><span class="line">        mRenderer-&gt;queueBuffer(mIsAudio, buffer, reply);</span><br><span class="line">        <span class="keyword">if</span> (eos &amp;&amp; !isDiscontinuityPending()) &#123;</span><br><span class="line">            mRenderer-&gt;queueEOS(mIsAudio, ERROR_END_OF_STREAM);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>a.    在kWhatRenderBuffer消息处理中会调用NuPlayer::Decoder::onRenderBuffer(…)，在其中根据情况调用函数MediaCodec::renderOutputBufferAndRelease(..)渲染并释放，或者调用MediaCodec::releaseOutputBuffer(…)不渲染直接释放，两中情况都会产生kWhatReleaseOutputBuffer消息，该消息处理中调用函数MediaCodec::onReleaseOutputBuffer(…)，其中判断若SoftRenderer非空则进行软件渲染，不然就会通过○5中的reply让ACodec去硬件渲染，在kWhatOutputBufferDrained消息处理就会中调用到函数ACodec::BaseState::onOutputBufferDrained(…)进行真正的硬件渲染。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerDecoder.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Decoder::onRenderBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">size_t</span> bufferIx;</span><br><span class="line">    <span class="keyword">int32_t</span> eos;</span><br><span class="line">    CHECK(msg-&gt;findSize(<span class="string">"buffer-ix"</span>, &amp;bufferIx));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsAudio) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timeUs;</span><br><span class="line">        sp&lt;ABuffer&gt; buffer = mOutputBuffers[bufferIx];</span><br><span class="line">        buffer-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timeUs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mCCDecoder != <span class="literal">NULL</span> &amp;&amp; mCCDecoder-&gt;isSelected()) &#123;</span><br><span class="line">            mCCDecoder-&gt;display(timeUs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs;</span><br><span class="line">        CHECK(msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs));</span><br><span class="line">        err = mCodec-&gt;renderOutputBufferAndRelease(bufferIx, timestampNs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mNumOutputFramesDropped += !mIsAudio;</span><br><span class="line">        err = mCodec-&gt;releaseOutputBuffer(bufferIx);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b.    MediaCodec:: getOutputBuffer (…) -&gt; MediaCodec::getBufferAndFormat(…)获取该buffer的信息<br>c.    若Renderer非空则会调用NuPlayer::Renderer::queueBuffer(…)进行Renderer的相关处理同时消耗产生的kWhatRenderBuffer消息。queueBuffer()会产生kWhatQueueBuffer消息，消息处理中会调用函数NuPlayer::Renderer::onQueueBuffer(…) –&gt; NuPlayer::Renderer::postDrainVideoQueue() 【另外有audio的相关处理】，其中产生kWhatDrainVideoQueue消息，消息处理中调用先NuPlayer::Renderer::onDrainVideoQueue()在VideoQueue中取相关数据，再调用NuPlayer::Renderer::postDrainVideoQueue()循环取video数据，接着还会发送kWhatRenderBuffer消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayerRenderer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::Renderer::onQueueBuffer(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">int32_t</span> audio;</span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        mHasAudio = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasVideo = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mHasVideo) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mVideoScheduler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            mVideoScheduler = <span class="keyword">new</span> VideoFrameScheduler();</span><br><span class="line">            mVideoScheduler-&gt;init();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; buffer;</span><br><span class="line">    CHECK(msg-&gt;findBuffer(<span class="string">"buffer"</span>, &amp;buffer));</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notifyConsumed;</span><br><span class="line">    CHECK(msg-&gt;findMessage(<span class="string">"notifyConsumed"</span>, &amp;notifyConsumed));</span><br><span class="line"></span><br><span class="line">    QueueEntry entry;</span><br><span class="line">    entry.mBuffer = buffer;</span><br><span class="line">    entry.mNotifyConsumed = notifyConsumed;</span><br><span class="line">    entry.mOffset = <span class="number">0</span>;</span><br><span class="line">    entry.mFinalResult = OK;</span><br><span class="line">    entry.mBufferOrdinal = ++mTotalBuffersQueued;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audio) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        mAudioQueue.push_back(entry);</span><br><span class="line">        postDrainAudioQueue_l();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mVideoQueue.push_back(entry);</span><br><span class="line">        postDrainVideoQueue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!mSyncQueues || mAudioQueue.empty() || mVideoQueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;ABuffer&gt; firstAudioBuffer = (*mAudioQueue.begin()).mBuffer;</span><br><span class="line">    sp&lt;ABuffer&gt; firstVideoBuffer = (*mVideoQueue.begin()).mBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (firstAudioBuffer == <span class="literal">NULL</span> || firstVideoBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        syncQueuesDone_l();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> firstAudioTimeUs;</span><br><span class="line">    <span class="keyword">int64_t</span> firstVideoTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> diff = firstVideoTimeUs - firstAudioTimeUs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (diff &gt; <span class="number">100000l</span>l) &#123;</span><br><span class="line">        (*mAudioQueue.begin()).mNotifyConsumed-&gt;post();</span><br><span class="line">        mAudioQueue.erase(mAudioQueue.begin());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    syncQueuesDone_l();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-05-source-demux-decoder-output-render.jpg" alt="Alt text"></p><h4 id="（五）、视频解码输出到SurfaceFlinger"><a href="#（五）、视频解码输出到SurfaceFlinger" class="headerlink" title="（五）、视频解码输出到SurfaceFlinger"></a>（五）、视频解码输出到SurfaceFlinger</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    IOMX::buffer_id bufferID;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"buffer-id"</span>, (<span class="keyword">int32_t</span>*)&amp;bufferID));</span><br><span class="line">    <span class="keyword">ssize_t</span> index;</span><br><span class="line">    BufferInfo *info = mCodec-&gt;findBufferByID(kPortIndexOutput, bufferID, &amp;index);</span><br><span class="line">    BufferInfo::Status status = BufferInfo::getSafeStatus(info);</span><br><span class="line">    <span class="keyword">if</span> (status != BufferInfo::OWNED_BY_DOWNSTREAM) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Wrong ownership in OBD: %s(%d) buffer #%u"</span>, _asString(status), status, bufferID);</span><br><span class="line">        mCodec-&gt;dumpBuffers(kPortIndexOutput);</span><br><span class="line">        mCodec-&gt;signalError(OMX_ErrorUndefined, FAILED_TRANSACTION);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">android_native_rect_t</span> crop;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findRect(<span class="string">"crop"</span>, &amp;crop.left, &amp;crop.top, &amp;crop.right, &amp;crop.bottom)</span><br><span class="line">            &amp;&amp; <span class="built_in">memcmp</span>(&amp;crop, &amp;mCodec-&gt;mLastNativeWindowCrop, <span class="keyword">sizeof</span>(crop)) != <span class="number">0</span>) &#123;</span><br><span class="line">        mCodec-&gt;mLastNativeWindowCrop = crop;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_crop(mCodec-&gt;mNativeWindow.get(), &amp;crop);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set crop: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> dataSpace;</span><br><span class="line">    <span class="keyword">if</span> (msg-&gt;findInt32(<span class="string">"dataspace"</span>, &amp;dataSpace)</span><br><span class="line">            &amp;&amp; dataSpace != mCodec-&gt;mLastNativeWindowDataSpace) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> err = native_window_set_buffers_data_space(</span><br><span class="line">                mCodec-&gt;mNativeWindow.get(), (android_dataspace)dataSpace);</span><br><span class="line">        mCodec-&gt;mLastNativeWindowDataSpace = dataSpace;</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set dataspace: %d"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int32_t</span> render;</span><br><span class="line">    <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span></span><br><span class="line">            &amp;&amp; msg-&gt;findInt32(<span class="string">"render"</span>, &amp;render) &amp;&amp; render != <span class="number">0</span></span><br><span class="line">            &amp;&amp; info-&gt;mData != <span class="literal">NULL</span> &amp;&amp; info-&gt;mData-&gt;size() != <span class="number">0</span>) &#123;</span><br><span class="line">        ATRACE_NAME(<span class="string">"render"</span>);</span><br><span class="line">        <span class="comment">// The client wants this buffer to be rendered.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// save buffers sent to the surface so we can get render time when they return</span></span><br><span class="line">        <span class="keyword">int64_t</span> mediaTimeUs = <span class="number">-1</span>;</span><br><span class="line">        info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;mediaTimeUs);</span><br><span class="line">        <span class="keyword">if</span> (mediaTimeUs &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mCodec-&gt;mRenderTracker.onFrameQueued(</span><br><span class="line">                    mediaTimeUs, info-&gt;mGraphicBuffer, <span class="keyword">new</span> Fence(::dup(info-&gt;mFenceFd)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int64_t</span> timestampNs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!msg-&gt;findInt64(<span class="string">"timestampNs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">            <span class="comment">// use media timestamp if client did not request a specific render timestamp</span></span><br><span class="line">            <span class="keyword">if</span> (info-&gt;mData-&gt;meta()-&gt;findInt64(<span class="string">"timeUs"</span>, &amp;timestampNs)) &#123;</span><br><span class="line">                ALOGV(<span class="string">"using buffer PTS of %lld"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)timestampNs);</span><br><span class="line">                timestampNs *= <span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">status_t</span> err;</span><br><span class="line">        err = native_window_set_buffers_timestamp(mCodec-&gt;mNativeWindow.get(), timestampNs);</span><br><span class="line">        ALOGW_IF(err != NO_ERROR, <span class="string">"failed to set buffer timestamp: %d"</span>, err);</span><br><span class="line"></span><br><span class="line">        info-&gt;checkReadFence(<span class="string">"onOutputBufferDrained before queueBuffer"</span>);</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        info-&gt;mFenceFd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (err == OK) &#123;</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_NATIVE_WINDOW;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGE(<span class="string">"queueBuffer failed in onOutputBufferDrained: %d"</span>, err);</span><br><span class="line">            mCodec-&gt;signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));</span><br><span class="line">            info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">            <span class="comment">// keeping read fence as write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCodec-&gt;mNativeWindow != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            (info-&gt;mData == <span class="literal">NULL</span> || info-&gt;mData-&gt;size() != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// move read fence into write fence to avoid clobbering</span></span><br><span class="line">            info-&gt;mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">            ATRACE_NAME(<span class="string">"frame-drop"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        info-&gt;mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1、Surfaceflinger-视频解码缓存申请"><a href="#5-1、Surfaceflinger-视频解码缓存申请" class="headerlink" title="5.1、Surfaceflinger 视频解码缓存申请"></a>5.1、Surfaceflinger 视频解码缓存申请</h5><p>前面2.3.6、MediaCodec-&gt;start()分析过：<br>产生kWhatStart消息，消息处理中先将MediaCodec状态设为STARTING，然后调用ACodec::initiateStart()产生kWhatStart消息，在其消息处理中又调用ACodec::LoadedState::onStart()，然后在其中首先向IOMX发送状态转换命令，经过OMXNodeInstance最终对将OMX组件状态转换成Idle（转换完成时OMX会发送OMX_EventCmdComplete事件），接着对ACodec进行changeState至LoadedToIdleState。而在changeState过程中会调用ACodec::LoadedToIdleState::stateEntered() =&gt;  ACodec::LoadedToIdleState::allocateBuffers() =&gt; ACodec::allocateBuffersOnPort(…)，其中会为OMX组件端口分配缓冲，并向MediaCodec发送消息kWhatBuffersAllocated，消息处理中将MediaCodec状态设为STARTED而若allocateBuffers失败则由IOMX经OMXNodeInstance将OMX组件转换回Loaded状态，同时把ACodec状态转换回LoadedState<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="comment">//使用surface渲染，为输出分配图形缓存GraphicBuffer  </span></span><br><span class="line"><span class="keyword">status_t</span> ACodec::LoadedToIdleState::allocateBuffers() &#123;</span><br><span class="line">    <span class="keyword">status_t</span> err = mCodec-&gt;allocateBuffersOnPort(kPortIndexInput);</span><br><span class="line">    <span class="keyword">if</span> (err != OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCodec-&gt;allocateBuffersOnPort(kPortIndexOutput);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateBuffersOnPort(OMX_U32 portIndex) &#123;</span><br><span class="line">    CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);</span><br><span class="line"></span><br><span class="line">    CHECK(mDealer[portIndex] == <span class="literal">NULL</span>);</span><br><span class="line">    CHECK(mBuffers[portIndex].isEmpty());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line">    <span class="keyword">if</span> (mNativeWindow != <span class="literal">NULL</span> &amp;&amp; portIndex == kPortIndexOutput) &#123;</span><br><span class="line">        <span class="keyword">if</span> (storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">            err = allocateOutputMetadataBuffers();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err = allocateOutputBuffersFromNativeWindow();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-1-1、allocateOutputBuffersFromNativeWindow-的实现"><a href="#5-1-1、allocateOutputBuffersFromNativeWindow-的实现" class="headerlink" title="5.1.1、allocateOutputBuffersFromNativeWindow()的实现"></a>5.1.1、allocateOutputBuffersFromNativeWindow()的实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    OMX_U32 bufferCount, bufferSize, minUndequeuedBuffers;</span><br><span class="line">    <span class="keyword">status_t</span> err = configureOutputBuffersFromNativeWindow(</span><br><span class="line">            &amp;bufferCount, &amp;bufferSize, &amp;minUndequeuedBuffers, <span class="literal">true</span> <span class="comment">/* preregister */</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    mNumUndequeuedBuffers = minUndequeuedBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!storingMetadataInDecodedBuffers()) &#123;</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">                -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// Dequeue buffers and send them to OMX</span></span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">        sp&lt;GraphicBuffer&gt; graphicBuffer(<span class="keyword">new</span> GraphicBuffer(buf, <span class="literal">false</span>));</span><br><span class="line">        BufferInfo info;</span><br><span class="line">        info.mStatus = BufferInfo::OWNED_BY_US;</span><br><span class="line">        info.mFenceFd = fenceFd;</span><br><span class="line">        info.mIsReadFence = <span class="literal">false</span>;</span><br><span class="line">        info.mRenderInfo = <span class="literal">NULL</span>;</span><br><span class="line">        info.mData = <span class="keyword">new</span> ABuffer(<span class="literal">NULL</span> <span class="comment">/* data */</span>, bufferSize <span class="comment">/* capacity */</span>);</span><br><span class="line">        info.mCodecData = info.mData;</span><br><span class="line">        info.mGraphicBuffer = graphicBuffer;</span><br><span class="line">        mBuffers[kPortIndexOutput].push(info);</span><br><span class="line"></span><br><span class="line">        IOMX::buffer_id bufferId;</span><br><span class="line">        err = mOMX-&gt;useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,</span><br><span class="line">                &amp;bufferId);</span><br><span class="line">        ......</span><br><span class="line">        mBuffers[kPortIndexOutput].editItemAt(i).mBufferID = bufferId;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-1-1、首先为视频编码输出准备Surface"><a href="#5-1-1-1、首先为视频编码输出准备Surface" class="headerlink" title="5.1.1.1、首先为视频编码输出准备Surface"></a>5.1.1.1、首先为视频编码输出准备Surface</h5><p>此处通过Binder通信使用IGraphicBufferProducer请求分配一个Native Surface<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;Surface*&gt;(mNativeWindow.get())</span><br><span class="line">        -&gt;getIGraphicBufferProducer()-&gt;allowAllocation(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-06-Surface-ANativeWindow.png" alt="Alt text"></p><h5 id="5-1-1-2、Surface-gt-dequeueBuffer"><a href="#5-1-1-2、Surface-gt-dequeueBuffer" class="headerlink" title="5.1.1.2、Surface-&gt;dequeueBuffer"></a>5.1.1.2、Surface-&gt;dequeueBuffer</h5><p>为Surface分配Buffer，提供给视频解码后数据使用<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">status_t</span> ACodec::allocateOutputBuffersFromNativeWindow() &#123;</span><br><span class="line">    <span class="keyword">for</span> (OMX_U32 i = <span class="number">0</span>; i &lt; bufferCount; i++) &#123;</span><br><span class="line">        ANativeWindowBuffer *buf;</span><br><span class="line">        <span class="keyword">int</span> fenceFd;</span><br><span class="line">        err = mNativeWindow-&gt;dequeueBuffer(mNativeWindow.get(), &amp;buf, &amp;fenceFd);</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="5-2、Surface-gt-queueBuffer"><a href="#5-2、Surface-gt-queueBuffer" class="headerlink" title="5.2、Surface-&gt;queueBuffer()"></a>5.2、Surface-&gt;queueBuffer()</h5><p>待视频解码后，使用queueBuffer()交给SurfaceFlinger渲染，就可以在屏幕上看到视频画面了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libstagefright\ACodec.cpp]</span><br><span class="line"><span class="keyword">void</span> ACodec::BaseState::onOutputBufferDrained(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">        err = mCodec-&gt;mNativeWindow-&gt;queueBuffer(</span><br><span class="line">                    mCodec-&gt;mNativeWindow.get(), info-&gt;mGraphicBuffer.get(), info-&gt;mFenceFd);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/02-07-OpenMax-Based video decode-surfaceflinger.png" alt="Alt text"></p><p>关于SurfaceFlinger的知识请参考：【Android 7.1.2 (Android N) Android Graphics 系统分析】</p><p><strong>（ ͡° ͜ʖ ͡°）、（ಡωಡ）累~~~，有时间再继续Todo的分析吧，(๑乛◡乛๑) ！！！</strong><br><strong>Todo：Android OpenMax机制 实现分析</strong><br><strong>Todo：Android 音视频同步机制 源码分析</strong><br><strong>Todo：Android 音视频录制（Recoder）、编码（Encode）、混合（MediaMuxer）源码分析</strong></p><h4 id="（六）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（六）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（六）、参考资料(特别感谢各位前辈的分析和图示)："></a>（六）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/16222.html" target="_blank" rel="noopener">ffmpeg开发之旅(1)-(7)（总共七篇）</a><br><a href="https://blog.csdn.net/nonmarking/article/category/6746500" target="_blank" rel="noopener">深入理解Android音视频同步机制（总共五篇）</a><br><a href="https://blog.csdn.net/junzia/article/details/54018671" target="_blank" rel="noopener">Android硬编码——音频编码、视频编码及音视频混合</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Video System（1）：Video System(视频系统)框架分析</title>
    <link href="http://zhoujinjian.cc/2018/06/01/Android%20Video%20System%EF%BC%881%EF%BC%89%EF%BC%9AVideo%20System%5B%E8%A7%86%E9%A2%91%E7%B3%BB%E7%BB%9F%5D%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/06/01/Android Video System（1）：Video System[视频系统]框架分析/</id>
    <published>2018-05-31T16:00:00.000Z</published>
    <updated>2018-05-17T16:21:51.537Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/video.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">【特别感谢 -  Android NuPlayer播放框架】</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">【特别感谢 -  android ACodec MediaCodec NuPlayer flow】</a></p><p>Google Pixel、Pixel XL 内核代码（文章基于 Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>☯ V4l2 框架代码<br>☯ kernel/drivers/media/v4l2-core/（文件前缀为 videobuf2）</p><p>☯ MSM 视频驱动程序文件<br>☯ kernel/drivers/media/platform/msm/vidc/</p><p>☯ 设备树<br>☯ /kernel/arch/arm/boot/dts/qcom（Venus 的寄存器基址，时钟频率）</p><p>☯ Stagefright、libmedia、libmediaplayerservice、mediaserver<br>☯ /frameworks/av/media/</p><p>☯ OMX<br>☯ /hardware/qcom/media/mam8996/mm-video-v4l2/vidc/</p><p>☯ OMX 核心<br>☯ /hardware/qcom/media/mm-core</p><p>☯ 软件编解码器路径<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?)→ 解码器代码<br>☯ /vendor/qcom/proprietary/mm-video/omx_vpp(?) → 编码器代码</p><hr><h4 id="一-、Android-Video-Overview"><a href="#一-、Android-Video-Overview" class="headerlink" title="(一)、Android Video Overview"></a>(一)、Android Video Overview</h4><p>基于 OpenMAX 的视频解码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-01-OpenMax-Based video decode - data flow.png" alt="Alt text"></p><blockquote><p>YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。<a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV</a><br>VPU，Video processing unit </p></blockquote><p>基于 OpenMAX 的视频编码 – 数据流<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-02-OpenMax-Based video encode - data flow.png.png" alt="Alt text"></p><p>视频框架：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-03-Video Architecture Software Stack.png" alt="Alt text"></p><p>组件描述：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-04-Q Component Description.png" alt="Alt text"></p><p>总结：<br>    从视频框架可以了解到。视频文件先经Stagefright传到OMX decoder解码（软解或硬解）、OMX decoder将解码后的YUV数据回传到Stagefright，不断循环播放同时经由SurfaceFlinger渲染到LCD屏幕上。</p><h4 id="二-、Android-MediaPlayer-amp-Nuplayer-框架分析"><a href="#二-、Android-MediaPlayer-amp-Nuplayer-框架分析" class="headerlink" title="(二)、Android MediaPlayer &amp; Nuplayer 框架分析"></a>(二)、Android MediaPlayer &amp; Nuplayer 框架分析</h4><h5 id="2-1、MediaPlayer"><a href="#2-1、MediaPlayer" class="headerlink" title="2.1、MediaPlayer"></a>2.1、MediaPlayer</h5><p>Android在Java层中提供了一个MediaPlayer的类来作为播放媒体资源的接口，在使用中我们通常会编写以下的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mMediaPlayer = <span class="keyword">new</span> MediaPlayer();</span><br><span class="line">mMediaPlayer.setDataSource(Environment.getExternalStorageDirectory()+<span class="string">"/test_video.mp4"</span>);</span><br><span class="line">mMediaPlayer.setDisplay(...);</span><br><span class="line">mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);</span><br><span class="line">mMediaPlayer.prepareAsync();</span><br><span class="line">mMediaPlayer.start();</span><br><span class="line">mediaPlayer.pause(); </span><br><span class="line">mediaPlayer.stop();</span><br><span class="line">mediaPlayer.reset();</span><br><span class="line">mediaPlayer.release();</span><br></pre></td></tr></table></figure><p>通常MediaPlayer的调用逻辑是，构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，按照实际需求还会调用pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法。</p><h5 id="2-1-1、MediaPlayer状态图"><a href="#2-1-1、MediaPlayer状态图" class="headerlink" title="2.1.1、MediaPlayer状态图:"></a>2.1.1、MediaPlayer状态图:</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-05-MediaPlayer-status-turn-.png" alt="Alt text"></p><p>☯ Idle状态<br>调用new或reset()方法创建MediaPlayer后进入空闲<br>☯ End状态<br>调用release()后就结束<br>☯ Error状态<br>播放控制操作出错或无效状态下调用播放控制操作<br>☯ Initialized状态</p><p>调用setDataSource之后完成初始化<br>☯ Prepared状态<br>同步prepare()或异步prepareAsync()完成准备<br>☯ Preparing状态<br>是一种瞬时状态，调用prepareAsync()时会先进入此状态<br>☯ Started  状态<br>要开始播放必须调用start()<br>☯ Paused  状态<br>调用pause()并成功返回后播放可以被暂停<br>☯ Stopped状态<br>调用stop()会停止播放<br>☯ PlaybackCompleted状态<br>当播放到达流末端时，播放完成</p><h5 id="2-1-2、MediaPlayer和MediaPlayerService"><a href="#2-1-2、MediaPlayer和MediaPlayerService" class="headerlink" title="2.1.2、MediaPlayer和MediaPlayerService"></a>2.1.2、MediaPlayer和MediaPlayerService</h5><p>mediaserver 启动后会把media相关一些服务添加到servicemanager中，其中就有mediaPlayerService。这样应用启动前，系统就有了mediaPlayerService这个服务程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\mediaserver\main_mediaserver.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-06-Main_mediaserver.png" alt="Alt text"></p><h5 id="2-1-3、创建MediaPlayer"><a href="#2-1-3、创建MediaPlayer" class="headerlink" title="2.1.3、创建MediaPlayer"></a>2.1.3、创建MediaPlayer</h5><p>☯ Java应用程序中创建MediaPlayer对象<br>MediaPlayer mediaPlayer = new MediaPlayer();<br>☯ MediaPlayer的构造函数中比较重要的就是本地的native函数：native_setup()其对应的JNI函数为<br>android_media_MediaPlayer_native_setup()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-07-android_media_MediaPlayer_native_setup.png" alt="Alt text"></p><p>构造Native层的MediaPlayer对象的时候【MediaPlayer.cpp】，也会构造其父类的对象。在MediaPlayer的父类IMediaDeathNotifier中有个很重要的方法getMediaPlayerService()来获取MediaPlayerService，其关系到MediaPlayer和MediaPlayerService之间的通信。</p><h5 id="2-1-4、setDataSource-设置播放资源"><a href="#2-1-4、setDataSource-设置播放资源" class="headerlink" title="2.1.4、setDataSource()设置播放资源"></a>2.1.4、setDataSource()设置播放资源</h5><p>在整个应用程序的进程中，Mediaplayer.cpp 中 setDataSource会从service manager中获得mediaPlayerService 服务，然后通过服务来创建player，这个player就是播放器的真实实例，同时也使MediaPlayer和MediaPlayerService建立了联系。<br>在java层MediaPlayer.java中的setDataSource最终会调用_setDataSource方法，对应native层MediaPlayer.cpp中的setDataSource方法。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-08-mp_setDataSource.png" alt="Alt text"></p><p>通过 getMediaPlayerService 得到的BpMediaPlayerService类型的service，和mediaPlayerService进程中的BnMediaPlayerService 相对应负责binder通讯。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-09-MediaPlayerService_Create.png" alt="Alt text"></p><p>在create函数中创建了一个MediaPlayerService::Client的实例，是MediaPlayerService的内部类，也就是说MediaPlayerService会为每个client应用进程创建一个相应的MediaPlayerService::Client的实例，来实现播放以及播放过程的控制，向MediaPlayer发事件通知。到这里，在Server端的对象就创建完成了。</p><p>然后在MediaPlayer.cpp中就得到了一个sever端的player实例，它和本地其他类的实例没什么用法上的区别，而实际上则是通过binder机制运行在另外一个进程中的。获得此实例后继续player-&gt;setDataSource操作。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-10-player-setDataSource.png" alt="Alt text"></p><p>小结：<br>Java应用程序中使用MediaPlayer.java的setDataSource()会传递到Native层中MediaPlayer.cpp的setDataSource()去执行，而MediaPlayer.cpp又会把这个方法交给MediaPlayerservice去执行。MediaPlayerService则是使用NuPlayer实现的，最后， setDataSource还是交给了NuPlayer去执行了。这个过程把MediaPlayer和MediaPlayerService之间的联系建立起来，同时又把MediaPlayerService和NuPlayer的关系建立了起来。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-11-GenericSource-setDataSource.png" alt="Alt text"></p><h5 id="2-1-5、setDisplay"><a href="#2-1-5、setDisplay" class="headerlink" title="2.1.5、setDisplay()"></a>2.1.5、setDisplay()</h5><p> 下一步就是java层的setDisplay，依然查看java层MediaPlayer：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\java\android\media\MediaPlayer.java]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDisplay</span><span class="params">(SurfaceHolder sh)</span> </span>&#123;</span><br><span class="line">        mSurfaceHolder = sh;</span><br><span class="line">        Surface surface;</span><br><span class="line">        <span class="keyword">if</span> (sh != null) &#123;</span><br><span class="line">            surface = sh.getSurface();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            surface = null;</span><br><span class="line">        &#125;</span><br><span class="line">        _setVideoSurface(surface);</span><br><span class="line">        updateSurfaceScreenOn();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后会调用本地方法_setVideoSurface，我们继续找到它的jni实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\base\media\jni\android_media_MediaPlayer.cpp]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_media_MediaPlayer_setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    setVideoSurface(env, thiz, jsurface, <span class="literal">true</span> <span class="comment">/* mediaPlayerMustBeAlive */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setVideoSurface</span><span class="params">(JNIEnv *env, jobject thiz, jobject jsurface, jboolean mediaPlayerMustBeAlive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);<span class="comment">//获取C++的MediaPlayer</span></span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mediaPlayerMustBeAlive) &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalStateException"</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line">    decVideoSurfaceRef(env, thiz);</span><br><span class="line"><span class="comment">//IGraphicBufferProducer图层缓冲区合成器</span></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; new_st;</span><br><span class="line">    <span class="keyword">if</span> (jsurface) &#123;</span><br><span class="line">    <span class="comment">//得到java层的surface</span></span><br><span class="line">        sp&lt;Surface&gt; surface(android_view_Surface_getSurface(env, jsurface));</span><br><span class="line">        <span class="keyword">if</span> (surface != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">//获取IGraphicBufferProducer</span></span><br><span class="line">            new_st = surface-&gt;getIGraphicBufferProducer();</span><br><span class="line">            <span class="keyword">if</span> (new_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface does not have a binding SurfaceTexture!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加IGraphicBufferProducer的强引用+1</span></span><br><span class="line">            new_st-&gt;incStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jniThrowException(env, <span class="string">"java/lang/IllegalArgumentException"</span>,</span><br><span class="line">                    <span class="string">"The surface has been released"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//上面我们在native_init方法中将java层mNativeSurfaceTexture查找给了jni层，正好，在这里将IGraphicBufferProducer赋给它</span></span><br><span class="line">    env-&gt;SetLongField(thiz, fields.surface_texture, (jlong)new_st.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will fail if the media player has not been initialized yet. This</span></span><br><span class="line">    <span class="comment">// can be the case if setDisplay() on MediaPlayer.java has been called</span></span><br><span class="line">    <span class="comment">// before setDataSource(). The redundant call to setVideoSurfaceTexture()</span></span><br><span class="line">    <span class="comment">// in prepare/prepareAsync covers for this case.</span></span><br><span class="line">    <span class="comment">//如果MediaPlayer没有初始化，这一步会失败。原因可能是setDisplay在setDataSource之前。如果在prepare/prepareAsync 时想规避这个错误而去调用setVideoSurfaceTexture是多余的。</span></span><br><span class="line">    <span class="comment">//最终会调用C++层的setVideoSurfaceTexture方法，下一节在分析</span></span><br><span class="line">    mp-&gt;setVideoSurfaceTexture(new_st);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将旧的IGraphicBufferProducer的强引用减一</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decVideoSurfaceRef</span><span class="params">(JNIEnv *env, jobject thiz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sp&lt;MediaPlayer&gt; mp = getMediaPlayer(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (mp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sp&lt;IGraphicBufferProducer&gt; old_st = getVideoSurfaceTexture(env, thiz);</span><br><span class="line">    <span class="keyword">if</span> (old_st != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        old_st-&gt;decStrong((<span class="keyword">void</span>*)decVideoSurfaceRef);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步主要是对图像显示的surface的保存，然后将旧的IGraphicBufferProducer强引用减一，再获得新的IGraphicBufferProducer，最后会调用C++的MediaPlayer的setVideoSurfaceTexture将它折纸进去。</p><p>IGraphicBufferProducer是SurfaceFlinger的内容，一个UI完全显示到diplay的过程，SurfaceFlinger扮演着重要的角色但是它的职责是“Flinger”，即把系统中所有应用程序的最终的“绘图结果”进行“混合”，然后统一显示到物理屏幕上，而其他方面比如各个程序的绘画过程，就由其他东西来担任了。这个光荣的任务自然而然地落在了BufferQueue的肩膀上，它是每个应用程序“一对一”的辅导老师，指导着UI程序的“画板申请”、“作画流程”等一系列细节。下面的图描述了这三者的关系：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-12-IGraphicBufferProducer.png" alt="Alt text"></p><p>   虽说是三者的关系，但是他们所属的层却只有两个，app属于Java层，BufferQueue/SurfaceFlinger属于native层。也就是说BufferQueue也是隶属SurfaceFlinger，所有工作围绕SurfaceFlinger展开。<br>       这里IGraphicBufferProducer就是app和BufferQueue重要桥梁，GraphicBufferProducer承担着单个应用进程中的UI显示需求，与BufferQueue打交道的就是它。</p><h5 id="2-1-6、播放器基本模型"><a href="#2-1-6、播放器基本模型" class="headerlink" title="2.1.6、播放器基本模型"></a>2.1.6、播放器基本模型</h5><p>NuPlayer不管有多么神秘，说到底还是个播放器。在播放器的基本模型上，他与VCL、mplayer、ffmpeg等开源的结构是一致的。只是组织实现的方式不同。<br>深入了解NuPlayer之前，把播放器的基本模型总结一下，然后按照模型的各个部分来深入研究NuPlayer的实现方式。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-13-source-demux-decoder-output.jpg" alt="Alt text"></p><p>☯ datasource数据源：数据源，数据的来源不一定都是本地file，也有可能是网路上的各种协议例如：http、rtsp、HLS等。source的任务就是把数据源抽象出来，为下一个demux模块提供它需要的稳定的数据流。demux不用关信数据到底是从什么地方来的。</p><p>☯ demuxer解复用：视频文件一般情况下都是把音视频的ES流交织的通过某种规则放在一起。这种规则就是容器规则。现在有很多不同的容器格式。如ts、mp4、flv、mkv、avi、rmvb等等。demux的功能就是把音视频的ES流从容器中剥离出来，然后分别送到不同的解码器中。其实音频和视频本身就是2个独立的系统。容器把它们包在了一起。但是他们都是独立解码的，所以解码之前，需要把它分别 独立出来。demux就是干这活的，他为下一步decoder解码提供了数据流。</p><p>☯ decoder解码：解码器—-播放器的核心模块。分为音频和视频解码器。影像在录制后, 原始的音视频都是占用大量空间, 而且是冗余度较高的数据. 因此, 通常会在制作的时候就会进行某种压缩 ( 压缩技术就是将数据中的冗余信息去除数据之间的相关性 ). 这就是我们熟知的音视频编码格式, 包括MPEG1（VCD）\ MPEG2（DVD）\ MPEG4 \ H.264 等等. 音视频解码器的作用就是把这些压缩了的数据还原成原始的音视频数据. 当然, 编码解码过程基本上都是有损的 .解码器的作用就是把编码后的数据还原成原始数据。</p><p>☯ output输出：输出部分分为音频和视频输出。解码后的音频（pcm）和视频（yuv）的原始数据需要得到音视频的output模块的支持才能真正的让人的感官系统（眼和耳）辨识到。</p><p>所以，播放器大致分成上述4部分。怎么抽象的实现这4大部分、以及找到一种合理的方式将这几部分组织并运动起来。是每个播放器不同的实现方式而已。接下来就围绕这4大部分做深入学习，看看NuPlayer的工作原理。</p><h5 id="2-2、NuPlayer分析"><a href="#2-2、NuPlayer分析" class="headerlink" title="2.2、NuPlayer分析"></a>2.2、NuPlayer分析</h5><h5 id="2-2-0、NuPlayer简介"><a href="#2-2-0、NuPlayer简介" class="headerlink" title="2.2.0、NuPlayer简介"></a>2.2.0、NuPlayer简介</h5><p>Android2.3时引入流媒体框架，而流媒体框架的核心是NuPlayer。在之前的版本中一般认为Local Playback就用Stagefrightplayer+Awesomeplayer，流媒体用NuPlayer。Android4.0之后HttpLive和RTSP协议开始使用NuPlayer播放器，Android5.0（L版本）之后本地播放也开始使用NuPlayer播放器。 Android7.0(N版本)则完全去掉了Awesomeplayer。<br>通俗点说，NuPlayer是AOSP中提供的多媒体播放框架，能够支持本地文件、HTTP（HLS）、RTSP等协议的播放，通常支持H.264、H.265/HEVC、AAC编码格式，支持MP4、MPEG-TS封装。<br>在实现上NuPlayer和Awesomeplayer不同，NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来异步地处理请求，ALooper列队消息请求，AHandler中去处理，所以有更少的Mutex/Lock在NuPlayer中。Awesomeplayer中利用了omxcodec而NuPlayer中利用了Acodec。</p><h5 id="2-2-1、NuPlayer整体类关系图"><a href="#2-2-1、NuPlayer整体类关系图" class="headerlink" title="2.2.1、NuPlayer整体类关系图"></a>2.2.1、NuPlayer整体类关系图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-14-NuPlayer-arc.jpg" alt="Alt text"></p><p>NuPlayer由NuPlayerDriver封装，利用了底层的ALooper/AHandler机制来异步地处理请求，ALooper保存消息请求，然后在AHandler中处理。另外，NuPlayer中利用到了Acodec。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-15-NuPlayer-class.jpg" alt="Alt text"></p><p>☯ NuPlayer::Source<br>解析模块（parser，功能类似FFmpeg的avformat）。其接口与MediaExtractor和<br>MediaSource组合的接口差不多，同时提供了用于快速定位的seekTo接口。</p><p>☯ NuPlayer::Decoder<br>解码模块（decoder，功能类似FFmpeg的avcodec），封装了用于AVC、AAC解码的接口，<br>通过ACodec实现解码（包含OMX硬解码和软解码）。</p><p>☯ NuPlayer::Render<br>渲染模块（render，功能类似声卡驱动和显卡驱动），主要用于音视频渲染和同步，与<br>NativeWindow有关。</p><p>☯ NuPlayer  是播放框架中连接Source、Decoder、Renderer的纽带</p><p>☯ NuPlayerDriver<br>作为NuPlayer类的封装，直接调用NuPlayer。</p><p>NuPlayer框架中最顶层的类是NuPlayerDriver，继承自MediaPlayerInterface，主要提供一个状态转换机制，作为NuPlayer类的Wrapper。NuPlayerDriver类中最重要的成员是以下几个：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; State mState 播放器状体标志 </span><br><span class="line">&gt; sp &lt;ALooper&gt; mLooper 内部消息驱动机制 </span><br><span class="line">&gt; sp &lt;NuPlayer&gt;  mPlayer 真正完成播放器的类</span><br></pre></td></tr></table></figure><p>NuPlayerDriver主要是 构造函数-&gt; setDataSource -&gt; SetVideoSurfaceTexture-&gt; prepare/prepareAsync -&gt; start-&gt; stop-&gt; reset-&gt; 析构函数，实际需求pause、isPlaying、getDuration、getCurrentPosition、setLooping、seekTo等方法</p><h5 id="2-2-2、NuPlayer框架需要关注知识点"><a href="#2-2-2、NuPlayer框架需要关注知识点" class="headerlink" title="2.2.2、NuPlayer框架需要关注知识点"></a>2.2.2、NuPlayer框架需要关注知识点</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">NuPlayer的框架，其内部实现逻辑。那么最终就落实到如何从一个类中提取出需要的框架及知识点。那么一个类的对外接口部分通常包括：</span><br><span class="line">--- 构造函数和析构函数</span><br><span class="line">--- 必须调用的接口</span><br><span class="line">--- 可选的调用接口</span><br><span class="line"></span><br><span class="line">在多媒体播放中，通过关注的点有：</span><br><span class="line">--- 如何实现解复用，得到音频、视频、字幕等数据</span><br><span class="line">--- 如何实现解码</span><br><span class="line">--- 如何实现音视频同步</span><br><span class="line">--- 如何渲染视频</span><br><span class="line">--- 如何播放音频</span><br><span class="line">--- 如何实现快速定位</span><br></pre></td></tr></table></figure><h4 id="三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper"><a href="#三-、Android-MediaPlayer框架分析-AHandler-AMessage-ALooper" class="headerlink" title="(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper"></a>(三)、Android MediaPlayer框架分析 - AHandler AMessage ALooper</h4><p>前文中提到过NuPlayer基于StagefrightPlayer的基础类构建，利用了更底层的ALooper/AHandler机制来<strong>异步地处理请求</strong>，ALooper保存消息请求，然后调用AHandler接口去处理。<br>实际上在代码中NuPlayer本身继承自AHandler类，而ALooper对象保存在NuPlayerDriver中。<br>ALooper/AHandler机制是模拟的消息循环处理方式，通常有三个主要部分：消息（message，通常包含Handler）、消息队列（queue）、消息处理线程（looper thread）。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/video.system/01-16-AHandler-ALooper-AMessage.png" alt="Alt text"></p><p>对于handler消息机制，构成就必须包括一个Loop，message。那么对应的AHandler，也应该有对应的ALooper、AMessage。<br>因此本小节主要涉及到三个类ALooper、AHandler、AMessage。</p><h5 id="3-1、AHandler接口分析（消息处理类）"><a href="#3-1、AHandler接口分析（消息处理类）" class="headerlink" title="3.1、AHandler接口分析（消息处理类）"></a>3.1、AHandler接口分析（消息处理类）</h5><p>下面代码是AHandler接口:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AHandler.h"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AHandler</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AHandler();</span><br><span class="line"></span><br><span class="line">    ALooper::<span class="function">handler_id <span class="title">id</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    sp&lt;ALooper&gt; looper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;ALooper&gt; getLooper() <span class="keyword">const</span>;</span><br><span class="line">    wp&lt;AHandler&gt; getHandler() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>      <span class="comment">// deliverMessage()</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooperRoster</span>;</span> <span class="comment">// setID()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mMessageCounter;</span><br><span class="line">    KeyedVector&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint32_t</span>&gt; mMessages;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setID</span><span class="params">(ALooper::handler_id id, wp&lt;ALooper&gt; looper)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliverMessage</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上面接口，初步印象是AHandler没有直接对外的接口（只有获取成员变量的接口），基本上只有一个onMessageReceived用于子类继承，deliverMessage用于给类AMessage使用，setID用于给友元类ALooperRoster使用。从这点来说，真正代码应该在AMessage里边。</p><h5 id="3-2、AMessage接口分析（消息载体）"><a href="#3-2、AMessage接口分析（消息载体）" class="headerlink" title="3.2、AMessage接口分析（消息载体）"></a>3.2、AMessage接口分析（消息载体）</h5><p>下面代码是AMessage的声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/AMessage.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    AMessage();</span><br><span class="line">    AMessage(<span class="keyword">uint32_t</span> what, <span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler); <span class="comment">// 代码中常用的构造函数</span></span><br><span class="line">    <span class="keyword">static</span> sp&lt;AMessage&gt; FromParcel(<span class="keyword">const</span> Parcel &amp;parcel, <span class="keyword">size_t</span> maxNestingLevel = <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write this AMessage to a parcel.</span></span><br><span class="line">    <span class="comment">// All items in the AMessage must have types that are recognized by</span></span><br><span class="line">    <span class="comment">// FromParcel(); otherwise, TRESPASS error will occur.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel *parcel)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWhat</span><span class="params">(<span class="keyword">uint32_t</span> what)</span></span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> what() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这是一个AHandler，通过这个可以获得ALooper对象引用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除所有设置的消息属性参数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一系列设置/获取 Message 属性的函数。。。</span></span><br><span class="line">    <span class="keyword">void</span> setInt32/setInt64/setSize/setFloat/setDouble/setPointer/setPointer/setString/setRect/setObject/setBuffer/setMessage(...);</span><br><span class="line">    <span class="keyword">bool</span> findInt32/findInt64/findSize/findFloat/findDouble/findPointer/findString/findObject/findBuffer/findMessage/findRect(...) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过这个函数检索下指定名称的消息属性是否存在</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息的接口，顾名思义直接投递给构造函数的ALooper，注意支持延时消息，但不支持提前消息，delayUS &gt; 0</span></span><br><span class="line">    <span class="keyword">status_t</span> post(<span class="keyword">int64_t</span> delayUs = <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 投递消息并等待执行结束后发送response消息</span></span><br><span class="line">    <span class="keyword">status_t</span> postAndAwaitResponse(sp&lt;AMessage&gt; *response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this returns true, the sender of this message is synchronously</span></span><br><span class="line">    <span class="comment">// awaiting a response and the reply token is consumed from the message</span></span><br><span class="line">    <span class="comment">// and stored into replyID. The reply token must be used to send the response</span></span><br><span class="line">    <span class="comment">// using "postReply" below.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">senderAwaitsResponse</span><span class="params">(sp&lt;AReplyToken&gt; *replyID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Posts the message as a response to a reply token.  A reply token can</span></span><br><span class="line">    <span class="comment">// only be used once. Returns OK if the response could be posted; otherwise,</span></span><br><span class="line">    <span class="comment">// an error.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    sp&lt;AMessage&gt; dup() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较两个消息，并返回差异</span></span><br><span class="line">    sp&lt;AMessage&gt; changesFrom(<span class="keyword">const</span> sp&lt;<span class="keyword">const</span> AMessage&gt; &amp;other, <span class="keyword">bool</span> deep = <span class="literal">false</span>) <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取消息属性存储的个数及特定索引上的消息属性参数</span></span><br><span class="line">    <span class="keyword">size_t</span> countEntries() <span class="keyword">const</span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getEntryNameAt</span><span class="params">(<span class="keyword">size_t</span> index, Type *type)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AMessage();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span>;</span> <span class="comment">// deliver()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> mWhat;</span><br><span class="line"></span><br><span class="line">    wp&lt;AHandler&gt; mHandler;</span><br><span class="line">    wp&lt;ALooper&gt; mLooper;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于ALooper调用的，发送消息的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deliver</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的接口可以看出在使用AMessage是只需要指定消息的id和要处理该消息的AHandler即可，可以通过构造函数，也可以单独调用setWhat和setTarget接口。AMessage构造完成之后，可以调用setXXX设置对应的参数，通过findXXX获取传递的参数。最后通过post即可将消息投递到AHandler的消息队列中。</p><h5 id="3-3、ALooper接口分析（消息处理循环及后台线程）"><a href="#3-3、ALooper接口分析（消息处理循环及后台线程）" class="headerlink" title="3.3、ALooper接口分析（消息处理循环及后台线程）"></a>3.3、ALooper接口分析（消息处理循环及后台线程）</h5><p>其简化的声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"./frameworks/av/include/media/stagefright/ALooper.h"</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ALooper</span> :</span> <span class="keyword">public</span> RefBase &#123;</span><br><span class="line">    ALooper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Takes effect in a subsequent call to start().</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">handler_id <span class="title">registerHandler</span><span class="params">(<span class="keyword">const</span> sp&lt;AHandler&gt; &amp;handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregisterHandler</span><span class="params">(handler_id handlerID)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> start(<span class="keyword">bool</span> runOnCallingThread = <span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">bool</span> canCallJava = <span class="literal">false</span>, <span class="keyword">int32_t</span> priority = PRIORITY_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> stop();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> int64_t <span class="title">GetNowUs</span><span class="params">()</span></span>;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~ALooper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">AMessage</span>;</span>       <span class="comment">// post()</span></span><br><span class="line"></span><br><span class="line">    AString mName;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">        <span class="keyword">int64_t</span> mWhenUs;</span><br><span class="line">        sp&lt;AMessage&gt; mMessage;</span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;Event&gt; mEventQueue;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LooperThread</span>;</span></span><br><span class="line">    sp&lt;LooperThread&gt; mThread;</span><br><span class="line">    <span class="keyword">bool</span> mRunningLocally;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// START --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// posts a message on this looper with the given timeout</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg, <span class="keyword">int64_t</span> delayUs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creates a reply token to be used with this looper</span></span><br><span class="line">    sp&lt;AReplyToken&gt; createReplyToken();</span><br><span class="line">    <span class="comment">// waits for a response for the reply token.  If status is OK, the response</span></span><br><span class="line">    <span class="comment">// is stored into the supplied variable.  Otherwise, it is unchanged.</span></span><br><span class="line">    <span class="keyword">status_t</span> awaitResponse(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, sp&lt;AMessage&gt; *response);</span><br><span class="line">    <span class="comment">// posts a reply for a reply token.  If the reply could be successfully posted,</span></span><br><span class="line">    <span class="comment">// it returns OK. Otherwise, it returns an error value.</span></span><br><span class="line">    <span class="keyword">status_t</span> postReply(<span class="keyword">const</span> sp&lt;AReplyToken&gt; &amp;replyToken, <span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// END --- methods used only by AMessage</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">loop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ALooper对外接口比较简单，通常就是NuPlayerDriver构造函数中的调用逻辑。先创建一个ALooper对象，然后调用setName和start接口，之后调用registerHandler设置一个AHandler，这样就完成了初始化。在析构之前需要调用stop接口。<br>这里需要说明下，ALooper::start接口会启动一个线程，并调用ALooper::loop函数，该函数主要实现消息的实际执行。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ALooper::loop() &#123;</span><br><span class="line">    Event event;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mLock)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (mThread == <span class="literal">NULL</span> &amp;&amp; !mRunningLocally) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从mEventQueue取出消息，判断是否需要执行，不需要的话就等待</span></span><br><span class="line">        <span class="comment">// 需要的话就调用handler执行，并删除对应消息</span></span><br><span class="line">        <span class="keyword">if</span> (mEventQueue.empty()) &#123;</span><br><span class="line">            mQueueChangedCondition.wait(mLock);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int64_t</span> whenUs = (*mEventQueue.begin()).mWhenUs;</span><br><span class="line">        <span class="keyword">int64_t</span> nowUs = GetNowUs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (whenUs &gt; nowUs) &#123;</span><br><span class="line">            <span class="keyword">int64_t</span> delayUs = whenUs - nowUs;</span><br><span class="line">            mQueueChangedCondition.waitRelative(mLock, delayUs * <span class="number">1000l</span>l);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        event = *mEventQueue.begin();</span><br><span class="line">        mEventQueue.erase(mEventQueue.begin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event.mMessage-&gt;deliver();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么消息是通过那个函数添加进来的呢？ 这就是友元类AMessage的作用，通过调用ALooper::post接口，将AMessage添加到mEventQueue中。</p><h5 id="3-4、一个调用实例"><a href="#3-4、一个调用实例" class="headerlink" title="3.4、一个调用实例"></a>3.4、一个调用实例</h5><p>以NuPlayer::setVideoSurfaceTextureAsync为示例分析下ALooper/AHandler机制。<br>这里不解释ALooper的初始化过程，有兴趣的可以参考资料Android Native层异步消息处理框架的内容。<br>下面是setVideoSurfaceTextureAsync的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync(</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码功能很简单，创建一个AMessage对象，并设置下参数，参数类型为Object，名称是”surface”，然后通过AMessage::post接口，间接调用ALooper::post接口，将消息发送给ALooper-NuPlayerDriver::mLooper；ALooper的消息循环线程检测到这个消息，在ALooper::loop函数中通过AMessage的deliver接口，调用AHandler::deliverMessage接口，这个函数会调动NuPlayer::onMessageReceived（通过继承机制实现）接口。这样绕了一圈。我们就可以通过ALooper/AHandler机制处理消息了。<br>具体处理代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::onMessageReceived(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg-&gt;what()) &#123;</span><br><span class="line">        <span class="keyword">case</span> kWhatSetVideoSurface:</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            sp&lt;RefBase&gt; obj;</span><br><span class="line">            CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">            sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">            ALOGD(<span class="string">"onSetVideoSurface(%p video decoder)"</span>, surface.get());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">            <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">            <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">            <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">                    <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">                    || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">                performSetSurface(surface);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 省略其他部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四-、NuPlayer源码分析"><a href="#四-、NuPlayer源码分析" class="headerlink" title="(四)、NuPlayer源码分析"></a>(四)、NuPlayer源码分析</h4><p>这次我们需要深入分析的是NuPlayer类，相比于NuPlayerDriver的接口功能，NuPlayer继承自AHandler类，是AOSP播放框架中连接Source、Decoder、Render的纽带。</p><h5 id="4-1、主要接口和核心的类成员"><a href="#4-1、主要接口和核心的类成员" class="headerlink" title="4.1、主要接口和核心的类成员"></a>4.1、主要接口和核心的类成员</h5><p>NuPlayer类被NuPlayerDriver直接调用，其主要接口如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code from NuPlayer.h (~/frameworks/av/media/libmediaplayerservice/nuplayer/)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NuPlayer</span> :</span> <span class="keyword">public</span> AHandler &#123;</span><br><span class="line">    NuPlayer(<span class="keyword">pid_t</span> pid);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setUID</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDriver</span><span class="params">(<span class="keyword">const</span> wp&lt;NuPlayerDriver&gt; &amp;driver)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareAsync</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setVideoSurfaceTextureAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifyResetComplete" once finished.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetAsync</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Will notify the driver through "notifySeekComplete" once finished</span></span><br><span class="line">    <span class="comment">// and needNotify is true.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">seekToAsync</span><span class="params">(<span class="keyword">int64_t</span> seekTimeUs, <span class="keyword">bool</span> needNotify = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> setVideoScalingMode(<span class="keyword">int32_t</span> mode);</span><br><span class="line">    <span class="keyword">status_t</span> getTrackInfo(Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> getSelectedTrack(<span class="keyword">int32_t</span> type, Parcel* reply) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">status_t</span> selectTrack(<span class="keyword">size_t</span> trackIndex, <span class="keyword">bool</span> select, <span class="keyword">int64_t</span> timeUs);</span><br><span class="line">    <span class="keyword">status_t</span> getCurrentPosition(<span class="keyword">int64_t</span> *mediaUs);</span><br><span class="line"></span><br><span class="line">    sp&lt;MetaData&gt; getFileMeta();</span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">getFrameRate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~NuPlayer();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onMessageReceived</span><span class="params">(<span class="keyword">const</span> sp&lt;AMessage&gt; &amp;msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口分类下，无外乎几个分类：</p><p>☯ 用于初始化的（比如构造函数、setDriver/setDataSourceAsync/prepareAsync/setVideoSurfaceTextureAsync）<br>☯ 用于销毁的（比如析构函数、resetAsync）<br>☯ 用于播放控制的（比如start/pause/seekToAsync）<br>☯ 用于状态获取的（比如getCurrentPosition/getFileMeta）<br>下面是主要的类成员部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line">wp&lt;NuPlayerDriver&gt; mDriver; <span class="comment">// 接口调用方</span></span><br><span class="line">sp&lt;Source&gt; mSource; <span class="comment">// 相当于FFmpeg中的demuxer</span></span><br><span class="line">sp&lt;Surface&gt; mSurface; <span class="comment">// 显示用的Surface</span></span><br><span class="line">sp&lt;DecoderBase&gt; mVideoDecoder; <span class="comment">// 视频解码器</span></span><br><span class="line">sp&lt;DecoderBase&gt; mAudioDecoder; <span class="comment">// 音频解码器</span></span><br><span class="line">sp&lt;CCDecoder&gt; mCCDecoder; </span><br><span class="line">sp&lt;Renderer&gt; mRenderer; <span class="comment">// 渲染器</span></span><br><span class="line">sp&lt;ALooper&gt; mRendererLooper;</span><br></pre></td></tr></table></figure><h5 id="4-2、setDataSourceAsync-现分析"><a href="#4-2、setDataSourceAsync-现分析" class="headerlink" title="4.2、setDataSourceAsync()现分析"></a>4.2、setDataSourceAsync()现分析</h5><p>这个函数有多重不同的重载形式，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.h]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IStreamSource&gt; &amp;source)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService, <span class="keyword">const</span> <span class="keyword">char</span> *url,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDataSourceAsync</span><span class="params">(<span class="keyword">const</span> sp&lt;DataSource&gt; &amp;source)</span></span>;</span><br></pre></td></tr></table></figure><p>需要根据实际情况选择，这里以第三个接口为例，说明下多本地媒体文件是如何处理的。<br>下面是这个函数的实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::setDataSourceAsync(<span class="keyword">int</span> fd, <span class="keyword">int64_t</span> offset, <span class="keyword">int64_t</span> length) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetDataSource, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatSourceNotify, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建对象用于读取本地文件</span></span><br><span class="line">    sp&lt;GenericSource&gt; source =</span><br><span class="line">            <span class="keyword">new</span> GenericSource(notify, mUIDValid, mUID);</span><br><span class="line">    <span class="comment">// 实际干活的的代码</span></span><br><span class="line">    <span class="keyword">status_t</span> err = source-&gt;setDataSource(fd, offset, length);</span><br><span class="line">    </span><br><span class="line">    msg-&gt;setObject(<span class="string">"source"</span>, source);</span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看实现很简单，创建GenericSource对象，并调用其setDataSource接口，然后发送kWhatSetDataSource消息。<br>我们看看如何处理然后发送kWhatSetDataSource消息呢？代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSetDataSource:</span><br><span class="line">&#123;</span><br><span class="line">    CHECK(mSource == <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = OK;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"source"</span>, &amp;obj));</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Mutex::<span class="function">Autolock <span class="title">autoLock</span><span class="params">(mSourceLock)</span></span>;</span><br><span class="line">        mSource = <span class="keyword">static_cast</span>&lt;Source *&gt;(obj.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err = UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知Driver函数调用完成</span></span><br><span class="line">    CHECK(mDriver != <span class="literal">NULL</span>);</span><br><span class="line">    sp&lt;NuPlayerDriver&gt; driver = mDriver.promote();</span><br><span class="line">    <span class="keyword">if</span> (driver != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        driver-&gt;notifySetDataSourceCompleted(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里发现，其实没做什么就是直接通知NuPlayerDriver。我们还注意到这里构建了一个特殊消息（AMessage）notify，这个消息用于在Source和NuPlayer直接传递。下面这是消息循环中的处理函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">case</span> kWhatSourceNotify:</span><br><span class="line">&#123;</span><br><span class="line">    onSourceNotify(msg);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续讨论Source的时候详细说明这个消息通知的意义。</p><h5 id="4-3、prepareAsync"><a href="#4-3、prepareAsync" class="headerlink" title="4.3、prepareAsync()"></a>4.3、prepareAsync()</h5><p>这个函数实现的功能对应于MediaPlayerBase::prepare/prepareAsync接口，实现异步的prepare功能，一般就是做一些额外的初始化工作。那么直接看一下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmediaplayerservice\nuplayer\NuPlayer.cpp]</span><br><span class="line"><span class="keyword">void</span> NuPlayer::prepareAsync() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatPrepare, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码就是发了一个kWhatPrepare的消息。接下来是如何处理这个消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPrepare:</span><br><span class="line">&#123;</span><br><span class="line">    mSource-&gt;prepareAsync();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终还是调用了Source::prepareAsync接口。后面会解释其功能。（这里面可能会解析下码流，读取音频、视频、字幕流信息，读取时长、元数据等）。</p><h5 id="4-4、setVideoSurfaceTextureAsync"><a href="#4-4、setVideoSurfaceTextureAsync" class="headerlink" title="4.4、setVideoSurfaceTextureAsync()"></a>4.4、setVideoSurfaceTextureAsync()</h5><p>调用这个接口主要为了设置视频渲染窗口。其实现相对简单，创建一个Surface，然后发送异步的kWhatSetVideoSurface消息。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::setVideoSurfaceTextureAsync( <span class="keyword">const</span> sp&lt;IGraphicBufferProducer&gt; &amp;bufferProducer) &#123;</span><br><span class="line">    sp&lt;AMessage&gt; msg = <span class="keyword">new</span> AMessage(kWhatSetVideoSurface, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferProducer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg-&gt;setObject(<span class="string">"surface"</span>, <span class="keyword">new</span> Surface(bufferProducer, <span class="literal">true</span> <span class="comment">/* controlledByApp */</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么看看如何处理kWhatSetVideoSurface消息呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatSetVideoSurface: &#123;</span><br><span class="line">    sp&lt;RefBase&gt; obj;</span><br><span class="line">    CHECK(msg-&gt;findObject(<span class="string">"surface"</span>, &amp;obj));</span><br><span class="line">    sp&lt;Surface&gt; surface = <span class="keyword">static_cast</span>&lt;Surface *&gt;(obj.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to check mStarted before calling mSource-&gt;getFormat because NuPlayer might</span></span><br><span class="line">    <span class="comment">// be in preparing state and it could take long time.</span></span><br><span class="line">    <span class="comment">// When mStarted is true, mSource must have been set.</span></span><br><span class="line">    <span class="keyword">if</span> (mSource == <span class="literal">NULL</span> || !mStarted || mSource-&gt;getFormat(<span class="literal">false</span> <span class="comment">/* audio */</span>) == <span class="literal">NULL</span></span><br><span class="line">            <span class="comment">// <span class="doctag">NOTE:</span> mVideoDecoder's mSurface is always non-null</span></span><br><span class="line">            || (mVideoDecoder != <span class="literal">NULL</span> &amp;&amp; mVideoDecoder-&gt;setVideoSurface(surface) == OK)) &#123;</span><br><span class="line">        performSetSurface(surface); <span class="comment">// 通知NuPlayerDriver设置完成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空音频、视频缓冲</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> FlushDecoderAction(FLUSH_CMD_FLUSH <span class="comment">/* audio */</span>,FLUSH_CMD_SHUTDOWN <span class="comment">/* video */</span>));</span><br><span class="line">    <span class="comment">// 最终调用NuPlayer::performSetSurface接口</span></span><br><span class="line">    mDeferredActions.push_back(<span class="keyword">new</span> SetSurfaceAction(surface));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span> || mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">            <span class="comment">// Issue a seek to refresh the video screen only if started otherwise</span></span><br><span class="line">            <span class="comment">// the extractor may not yet be started and will assert.</span></span><br><span class="line">            <span class="comment">// If the video decoder is not set (perhaps audio only in this case)</span></span><br><span class="line">            <span class="comment">// do not perform a seek as it is not needed.</span></span><br><span class="line">            <span class="keyword">int64_t</span> currentPositionUs = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (getCurrentPosition(&amp;currentPositionUs) == OK) &#123;</span><br><span class="line">                mDeferredActions.push_back(</span><br><span class="line">                        <span class="keyword">new</span> SeekAction(currentPositionUs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于新的surface设置，重置下解码器</span></span><br><span class="line">        mDeferredActions.push_back(<span class="keyword">new</span> SimpleAction(&amp;NuPlayer::performScanSources));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// After a flush without shutdown, decoder is paused.</span></span><br><span class="line">    <span class="comment">// Don't resume it until source seek is done, otherwise it could</span></span><br><span class="line">    <span class="comment">// start pulling stale data too soon.</span></span><br><span class="line">    mDeferredActions.push_back(</span><br><span class="line">            <span class="keyword">new</span> ResumeDecoderAction(<span class="literal">false</span> <span class="comment">/* needNotify */</span>));</span><br><span class="line">    <span class="comment">// 把上面mDeferredActions中缓存的所有Action处理下，并清空</span></span><br><span class="line">    processDeferredActions();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码相对复杂点，涉及到很多，其实主要是为了设置Surface之后，可以正常解码显示，因为某些情况下解码器初始化需要依赖于具体的Surface。当然，里边还涉及到NuPlayer状态及初始化判断。</p><h5 id="4-5、start-pause"><a href="#4-5、start-pause" class="headerlink" title="4.5、start()/pause()"></a>4.5、start()/pause()</h5><p>start函数实现很简单，实际就发送了kWhatStart消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::start() &#123;</span><br><span class="line">    (<span class="keyword">new</span> AMessage(kWhatStart, <span class="keyword">this</span>))-&gt;post();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在消息处理函数中的处理如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatStart:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStarted) &#123;</span><br><span class="line">        <span class="comment">// do not resume yet if the source is still buffering</span></span><br><span class="line">        <span class="keyword">if</span> (!mPausedForBuffering) &#123;</span><br><span class="line">            onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onStart();</span><br><span class="line">    &#125;</span><br><span class="line">    mPausedByClient = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了OnStart/OnResume函数。<br>pause函数实现类似，只是发送的是kWhatPause消息。在消息处理函数中的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatPause:</span><br><span class="line">&#123;</span><br><span class="line">    onPause();</span><br><span class="line">    mPausedByClient = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用的onPause函数。下面单独分析下这三个函数。先从简单的函数开始OnPause/onResume</p><p>NuPlayer::onPause<br>这个函数实现暂停功能，总体来说就是把Source和Render暂停就可以了，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onPause() &#123;</span><br><span class="line">    <span class="keyword">if</span> (mPaused) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;pause();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onResume<br>这个函数实现恢复功能，代码逻辑跟onPause差不多，把Source和Render恢复，还可能涉及其它操作。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onResume() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPaused || mResetting) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mPaused = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mSource != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mSource-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// |mAudioDecoder| may have been released due to the pause timeout, so re-create it if</span></span><br><span class="line">    <span class="comment">// needed.</span></span><br><span class="line">    <span class="keyword">if</span> (audioDecoderStillNeeded() &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        instantiateDecoder(<span class="literal">true</span> <span class="comment">/* audio */</span>, &amp;mAudioDecoder);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRenderer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mRenderer-&gt;resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NuPlayer::onStart<br>这个接口实现启动的操作，相对复杂点，需要初始化解码器、初始化Render、设置Source状态，并将三者关联起来。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> NuPlayer::onStart(<span class="keyword">int64_t</span> startPositionUs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSourceStarted) &#123;</span><br><span class="line">        mSourceStarted = <span class="literal">true</span>;</span><br><span class="line">        mSource-&gt;start(); <span class="comment">// 设置Source状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... (省略部分代码)</span></span><br><span class="line"></span><br><span class="line">    sp&lt;AMessage&gt; notify = <span class="keyword">new</span> AMessage(kWhatRendererNotify, <span class="keyword">this</span>);</span><br><span class="line">    ++mRendererGeneration; <span class="comment">// 创建Render和RenderLooper，属性设置、与解码器关联</span></span><br><span class="line">    notify-&gt;setInt32(<span class="string">"generation"</span>, mRendererGeneration);</span><br><span class="line">    mRenderer = <span class="keyword">new</span> Renderer(mAudioSink, notify, flags);</span><br><span class="line">    mRendererLooper = <span class="keyword">new</span> ALooper;</span><br><span class="line">    mRendererLooper-&gt;setName(<span class="string">"NuPlayerRenderer"</span>);</span><br><span class="line">    mRendererLooper-&gt;start(<span class="literal">false</span>, <span class="literal">false</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">    mRendererLooper-&gt;registerHandler(mRenderer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = mRenderer-&gt;setPlaybackSettings(mPlaybackSettings);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> rate = getFrameRate();</span><br><span class="line">    <span class="keyword">if</span> (rate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mRenderer-&gt;setVideoFrameRate(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mVideoDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mVideoDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioDecoder-&gt;setRenderer(mRenderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postScanSources();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中没有解码器的初始化，那只能继续看看postScanSources代码了。看实现发现就是发送了kWhatScanSources消息。那么消息循环里边是怎么处理的呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> kWhatScanSources:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span> generation;</span><br><span class="line">    CHECK(msg-&gt;findInt32(<span class="string">"generation"</span>, &amp;generation));</span><br><span class="line">    <span class="keyword">if</span> (generation != mScanSourcesGeneration) &#123;</span><br><span class="line">        <span class="comment">// Drop obsolete msg.</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mScanSourcesPending = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> mHadAnySourcesBefore = (mAudioDecoder != <span class="literal">NULL</span>) || (mVideoDecoder != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">bool</span> rescan = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize video before audio because successful initialization of</span></span><br><span class="line">    <span class="comment">// video may change deep buffer mode of audio.</span></span><br><span class="line">    <span class="keyword">if</span> (mSurface != <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化视频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">false</span>, &amp;mVideoDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't try to re-open audio sink if there's an existing decoder.</span></span><br><span class="line">    <span class="keyword">if</span> (mAudioSink != <span class="literal">NULL</span> &amp;&amp; mAudioDecoder == <span class="literal">NULL</span>) &#123; <span class="comment">// 初始化音频解码器</span></span><br><span class="line">        <span class="keyword">if</span> (instantiateDecoder(<span class="literal">true</span>, &amp;mAudioDecoder) == -EWOULDBLOCK) &#123;</span><br><span class="line">            rescan = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHadAnySourcesBefore &amp;&amp; (mAudioDecoder != <span class="literal">NULL</span> || mVideoDecoder != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// This is the first time we've found anything playable.</span></span><br><span class="line">        <span class="comment">// 设置定期查询时长</span></span><br><span class="line">        <span class="keyword">if</span> (mSourceFlags &amp; Source::FLAG_DYNAMIC_DURATION) &#123;</span><br><span class="line">            schedulePollDuration();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err; <span class="comment">// 一些异常处理逻辑</span></span><br><span class="line">    <span class="keyword">if</span> ((err = mSource-&gt;feedMoreTSData()) != OK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioDecoder == <span class="literal">NULL</span> &amp;&amp; mVideoDecoder == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// We're not currently decoding anything (no audio or</span></span><br><span class="line">            <span class="comment">// video tracks found) and we just ran out of input data.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (err == ERROR_END_OF_STREAM) &#123;</span><br><span class="line">                notifyListener(MEDIA_PLAYBACK_COMPLETE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                notifyListener(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要的话，重新扫描Source</span></span><br><span class="line">    <span class="keyword">if</span> (rescan) &#123;</span><br><span class="line">        msg-&gt;post(<span class="number">100000l</span>l);</span><br><span class="line">        mScanSourcesPending = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有seekToAsync()、resetAsync()、getCurrentPosition()、getFileMeta()。由于实现类似，就不一一介绍了。</p><h5 id="4-6、小结结和疑问"><a href="#4-6、小结结和疑问" class="headerlink" title="4.6、小结结和疑问"></a>4.6、小结结和疑问</h5><p>到这里，我们已经把NuPlayer主要的函数分析完了，但是问题依旧在。比如下面几个：</p><blockquote><p><strong>不同格式的多媒体文件如何探测并解析的？音视频数据缓冲区在哪里？（Source）</strong><br><strong>视频如何显示的？音频如何播放的？音视频同步在哪里？（Renderer）</strong><br><strong>音频解码线程、视频解码线程在哪里？ （DecoderBase）</strong></p></blockquote><p>我想接下来的分析就是解决这些疑问的。</p><h5 id="4-7、Codec-Encoder-、Decoder列表附录"><a href="#4-7、Codec-Encoder-、Decoder列表附录" class="headerlink" title="4.7、Codec Encoder 、Decoder列表附录"></a>4.7、Codec Encoder 、Decoder列表附录</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[AOSP/device/qcom/msm8996/media_codecs.xml(system/etc/media_codecs.xml)]</span><br><span class="line">&lt;!--</span><br><span class="line"> <span class="number">8996</span> Decoder capabilities</span><br><span class="line"> __________________________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    | Secure-dec |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">60</span>      <span class="number">100</span>     <span class="number">1958400</span> |  Y         |</span><br><span class="line"> |          | (<span class="number">4096</span>)  (<span class="number">2160</span>)  (<span class="number">56</span>)    (<span class="number">100</span>)           |            |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  N         |</span><br><span class="line"> | vc1      | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |  Y         |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  N         |</span><br><span class="line"> | vp9      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |  Y         |</span><br><span class="line"> | divx3    | <span class="number">720</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">40500</span>   |  N         |</span><br><span class="line"> | div4/<span class="number">5</span>/<span class="number">6</span> | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">10</span>      <span class="number">244800</span>  |  N         |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |  N         |</span><br><span class="line"> | mpeg2    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">30</span>      <span class="number">40</span>      <span class="number">244800</span>  |  Y         |</span><br><span class="line"> |__________|_________________________________________|____________|</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="number">8996</span> Encoder capabilities</span><br><span class="line"> ______________________________________________________</span><br><span class="line"> | Codec    | W       H       fps     Mbps    MB/s    |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line"> | h264     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | hevc     | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | mpeg4    | <span class="number">1920</span>    <span class="number">1088</span>    <span class="number">60</span>      <span class="number">60</span>      <span class="number">489600</span>  |</span><br><span class="line"> | vp8      | <span class="number">3840</span>    <span class="number">2160</span>    <span class="number">30</span>      <span class="number">100</span>     <span class="number">979200</span>  |</span><br><span class="line"> | h263     | <span class="number">864</span>     <span class="number">480</span>     <span class="number">30</span>      <span class="number">2</span>       <span class="number">48600</span>   |</span><br><span class="line"> |__________|_________________________________________|</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;MediaCodecs&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_audio.xml"</span> /&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_telephony.xml"</span> /&gt;</span><br><span class="line">    &lt;Settings&gt;</span><br><span class="line">        &lt;Setting name=<span class="string">"max-video-encoder-input-buffers"</span> value=<span class="string">"11"</span> /&gt;</span><br><span class="line">    &lt;/Settings&gt;</span><br><span class="line">    &lt;Encoders&gt;</span><br><span class="line">        &lt;!-- Audio Hardware  --&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-loaded-to-idle-after-allocation"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"96x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"979200"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">          ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.encoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">    &lt;/Encoders&gt;</span><br><span class="line">    &lt;Decoders&gt;</span><br><span class="line">       &lt;!-- Video Hardware  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-input-ports"</span> /&gt;</span><br><span class="line">            &lt;Quirk name=<span class="string">"requires-allocate-on-output-ports"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"size"</span> min=<span class="string">"64x64"</span> max=<span class="string">"4096x2160"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"alignment"</span> value=<span class="string">"2x2"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"block-size"</span> value=<span class="string">"16x16"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"blocks-per-second"</span> min=<span class="string">"1"</span> max=<span class="string">"1958400"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"bitrate"</span> range=<span class="string">"1-100000000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"frame-rate"</span> range=<span class="string">"1-240"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-version"</span> value=<span class="string">"65537"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-low-latency"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-macroblock-processing-rate"</span> value=<span class="string">"972000"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-level"</span> value=<span class="string">"52"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"vt-max-instances"</span> value=<span class="string">"16"</span> /&gt;</span><br><span class="line">            &lt;Feature name=<span class="string">"adaptive-playback"</span> /&gt;</span><br><span class="line">            &lt;Limit name=<span class="string">"concurrent-instances"</span> max=<span class="string">"16"</span> /&gt;</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.avc.secure"</span> type=<span class="string">"video/avc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg4"</span> type=<span class="string">"video/mp4v-es"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.mpeg2.secure"</span> type=<span class="string">"video/mpeg2"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.h263"</span> type=<span class="string">"video/3gpp"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vc1.secure"</span> type=<span class="string">"video/x-ms-wmv"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx"</span> type=<span class="string">"video/divx"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx311"</span> type=<span class="string">"video/divx311"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.divx4"</span> type=<span class="string">"video/divx4"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp8"</span> type=<span class="string">"video/x-vnd.on2.vp8"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.vp9.secure"</span> type=<span class="string">"video/x-vnd.on2.vp9"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qcom.video.decoder.hevc.secure"</span> type=<span class="string">"video/hevc"</span> &gt;</span><br><span class="line">            ......</span><br><span class="line">        &lt;/MediaCodec&gt;</span><br><span class="line">        &lt;!-- Audio Software  --&gt;</span><br><span class="line">        &lt;MediaCodec name=<span class="string">"OMX.qti.audio.decoder.flac"</span> type=<span class="string">"audio/flac"</span> /&gt;</span><br><span class="line">    &lt;/Decoders&gt;</span><br><span class="line">    &lt;Include href=<span class="string">"media_codecs_google_video.xml"</span> /&gt;</span><br><span class="line">&lt;/MediaCodecs&gt;</span><br></pre></td></tr></table></figure><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">Android NuPlayer播放框架 </a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="windrunnerlihuan.com">Android多媒体开发-归档 | April is your lie</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57409783" target="_blank" rel="noopener">Android-7.0-MediaPlayer状态机 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://zh.wikipedia.org/wiki/YUV" target="_blank" rel="noopener">YUV - 维基百科，自由的百科全书</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/category/2135451/1?" target="_blank" rel="noopener">Android 4.2.2 stagefright架构 - CSDN博客</a><br><a href="https://blog.csdn.net/gzzaigcnforever/article/details/26849549" target="_blank" rel="noopener">android4.2.2的stagefright架构下基于SurfaceFlinger的视频解码输出缓存创建机制 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/category/7610722" target="_blank" rel="noopener">husanlim 的专栏 参考 - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/54926526" target="_blank" rel="noopener">android ACodec MediaCodec NuPlayer flow - CSDN博客</a><br><a href="https://blog.csdn.net/dfhuang09/article/details/60132620" target="_blank" rel="noopener">android MediaCodec ACodec - CSDN博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Audio System（3）：Android audio system(音频系统)分析</title>
    <link href="http://zhoujinjian.cc/2018/05/25/Audio%20System%EF%BC%883%EF%BC%89%EF%BC%9AAndroid%20audio%20system%5B%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%5D%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/05/25/Audio System（3）：Android audio system[音频系统]分析/</id>
    <published>2018-05-24T16:00:00.000Z</published>
    <updated>2018-05-09T15:03:52.335Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">【特别感谢 - 林学森的Android专栏】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Yangwen123 - 深入剖析Android音频系统】</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">【特别感谢 - Zyuanyun - Android 音频系统：从 AudioTrack 到 AudioFlinger】</a><br>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（文章基于 Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio 高通HAL 源码)</strong> </p><p>• <strong>/libhardware/modules/audio/ – (Audio 原生HAL 源码)</strong> </p><p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/hardware/libhardware_legacy/audio – (Audio legacy 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><h4 id="一-、深入剖析Android音频之AudioFlinger"><a href="#一-、深入剖析Android音频之AudioFlinger" class="headerlink" title="(一)、深入剖析Android音频之AudioFlinger"></a>(一)、深入剖析Android音频之AudioFlinger</h4><h5 id="1-0、总体框架图"><a href="#1-0、总体框架图" class="headerlink" title="1.0、总体框架图"></a>1.0、总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/31-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><p>系统启动时将执行 /system/etc/init/audioserver.rc ，运行 /system/bin/ 目录下的 audioserver 服务。audioserver.rc 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\audioserver.rc]</span><br><span class="line">service audioserver /system/bin/audioserver</span><br><span class="line">    class main</span><br><span class="line">    user audioserver</span><br><span class="line">    # media gid needed for /dev/fm (radio ) and for  /data/misc/media (tee)</span><br><span class="line">    group audio radio camera drmpc inet media mediarm net_bt net_bt_admin net_bw_acct</span><br><span class="line">    ioprio rt 4</span><br><span class="line">    writepid /dev/cpuset/forground/tasks /dev/stune/foreground/tasks</span><br></pre></td></tr></table></figure><p>audioserver 是由同目录下main_audioserver编译生成的。</p><h5 id="1-1、AudioFlinger"><a href="#1-1、AudioFlinger" class="headerlink" title="1.1、AudioFlinger"></a>1.1、AudioFlinger</h5><p>AudioFlinger是整个音频系统的核心与难点。作为Android系统中的音频中枢，它同时也是一个系统服务，启到承上(为上层提供访问接口)启下(通过HAL来管理音频设备)的作用。只有理解了AudioFlinger，才能以此为基础更好地深入到其它模块，并且Audioserver最先启动的也是AudioFlinger，因而我们把它放在前面进行分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。<br>AudioFlinger注册名为”media.audio_flinger”的服务。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_flinger"</span>; &#125;</span><br></pre></td></tr></table></figure></p><h5 id="1-1-1-AudioFlinger服务的启动和运行"><a href="#1-1-1-AudioFlinger服务的启动和运行" class="headerlink" title="1.1.1 AudioFlinger服务的启动和运行"></a>1.1.1 AudioFlinger服务的启动和运行</h5><p>AudioFlinger的构造函数，发现它只是简单地为内部一些变量做了初始化，除此之外就没有任何代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::AudioFlinger()</span><br><span class="line">    : BnAudioFlinger(),</span><br><span class="line">      mPrimaryHardwareDev(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioHwDevs(<span class="literal">NULL</span>),</span><br><span class="line">      mHardwareStatus(AUDIO_HW_IDLE),</span><br><span class="line">      mMasterVolume(<span class="number">1.0f</span>),</span><br><span class="line">      mMasterMute(<span class="literal">false</span>),</span><br><span class="line">      <span class="comment">// mNextUniqueId(AUDIO_UNIQUE_ID_USE_MAX),</span></span><br><span class="line">      mMode(AUDIO_MODE_INVALID),</span><br><span class="line">      mBtNrecIsOff(<span class="literal">false</span>),</span><br><span class="line">      mIsLowRamDevice(<span class="literal">true</span>),</span><br><span class="line">      mIsDeviceTypeKnown(<span class="literal">false</span>),</span><br><span class="line">      mGlobalEffectEnableTime(<span class="number">0</span>),</span><br><span class="line">      mSystemReady(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// unsigned instead of audio_unique_id_use_t, because ++ operator is unavailable for enum</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> use = AUDIO_UNIQUE_ID_USE_UNSPECIFIED; use &lt; AUDIO_UNIQUE_ID_USE_MAX; use++) &#123;</span><br><span class="line">        <span class="comment">// zero ID has a special meaning, so unavailable</span></span><br><span class="line">        mNextUniqueIds[use] = AUDIO_UNIQUE_ID_USE_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BnAudioFlinger是由RefBase层层继承而来的，并且IServiceManager::addService的第二个参数实际上是一个强指针引用(constsp<ibinder>&amp;),因而AudioFlinger具备了强指针被第一次引用时调用onFirstRef的程序逻辑。</ibinder></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioFlinger::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> move all this work into an Init() function */</span></span><br><span class="line">    <span class="keyword">char</span> val_str[PROPERTY_VALUE_MAX] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (property_get(<span class="string">"ro.audio.flinger_standbytime_ms"</span>, val_str, <span class="literal">NULL</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> int_val;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="built_in">sscanf</span>(val_str, <span class="string">"%u"</span>, &amp;int_val)) &#123;</span><br><span class="line">            mStandbyTimeInNsecs = milliseconds(int_val);</span><br><span class="line">            ALOGI(<span class="string">"Using %u mSec as standby time."</span>, int_val);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs;</span><br><span class="line">            ALOGI(<span class="string">"Using default %u mSec as standby time."</span>,</span><br><span class="line">                    (<span class="keyword">uint32_t</span>)(mStandbyTimeInNsecs / <span class="number">1000000</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPatchPanel = <span class="keyword">new</span> PatchPanel(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    mMode = AUDIO_MODE_NORMAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这时开始，AudioFlinger就是一个“有意义”的实体了</p><h5 id="1-2、音频设备的管理"><a href="#1-2、音频设备的管理" class="headerlink" title="1.2、音频设备的管理"></a>1.2、音频设备的管理</h5><p>虽然AudioFlinger实体已经成功创建并初始化，但到目前为止它还是一块静态的内存空间，没有涉及到具体的工作。</p><p>从职能分布上来讲，AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。</p><p>目前Audio系统中支持的音频设备接口(Audio Interface)分为三大类，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">static const char * const audio_interfaces[] = &#123;</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_PRIMARY,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_A2DP,</span><br><span class="line">    AUDIO_HARDWARE_MODULE_ID_USB,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每种音频设备接口由一个对应的so库提供支持。那么AudioFlinger怎么会知道当前设备中支持上述的哪些接口，每种接口又支持哪些具体的音频设备呢？这是AudioPolicyService的责任之一，即根据用户配置来指导AudioFlinger加载设备接口。</p><p>当AudioPolicyManagerBase(AudioPolicyService中持有的Policy管理者，后面小节有详细介绍)构造时，它会读取厂商关于音频设备的描述文件(audio_policy.conf)，然后据此来打开以上三类音频接口(如果存在的话)。这一过程最终会调用loadHwModule@AudioFlinger，如下所示：</p><h5 id="1-2-1、加载设备loadHwModule"><a href="#1-2-1、加载设备loadHwModule" class="headerlink" title="1.2.1、加载设备loadHwModule()"></a>1.2.1、加载设备loadHwModule()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">/*name就是前面audio_interfaces 数组成员中的字符串*/</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    if (name == NULL) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!settingsAllowed()) &#123;</span><br><span class="line">        return AUDIO_MODULE_HANDLE_NONE;</span><br><span class="line">    &#125;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    return loadHwModule_l(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数没有做实质性的工作，只是执行了加锁动作，然后接着调用下面的函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">// loadHwModule_l() must be called with AudioFlinger::mLock held</span><br><span class="line">audio_module_handle_t AudioFlinger::loadHwModule_l(const char *name)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    /* Step 1. 是否已经添加了这个interface ? */</span><br><span class="line">    for (size_t i = 0; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">        if (strncmp(mAudioHwDevs.valueAt(i)-&gt;moduleName(), name, strlen(name)) == 0) &#123;</span><br><span class="line">            ALOGW(&quot;loadHwModule() module %s already loaded&quot;, name);</span><br><span class="line">            return mAudioHwDevs.keyAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audio_hw_device_t *dev;</span><br><span class="line">    /* Step 2. 加载audio interface */</span><br><span class="line">    int rc = load_audio_interface(name, &amp;dev);</span><br><span class="line">    ......</span><br><span class="line">    </span><br><span class="line">    /* Step 3. 初始化 */</span><br><span class="line">    mHardwareStatus = AUDIO_HW_INIT;</span><br><span class="line">    rc = dev-&gt;init_check(dev);</span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">    /* Step 4. 添加到全局变量中 */</span><br><span class="line">    audio_module_handle_t handle = (audio_module_handle_t) nextUniqueId(AUDIO_UNIQUE_ID_USE_MODULE);</span><br><span class="line">    mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags));</span><br><span class="line"></span><br><span class="line">    return handle;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1@ loadHwModule_l. 首先查找mAudioHwDevs是否已经添加了变量name所指示的audio interface，如果是的话直接返回。第一次进入时mAudioHwDevs的size为0，所以还会继续往下执行。</p><p>Step2@ loadHwModule_l. 加载指定的audiointerface，比如“primary”、“a2dp”或者“usb”。函数load_audio_interface用来加载设备所需的库文件，然后打开设备并创建一个audio_hw_device_t实例。音频接口设备所对应的库文件名称是有一定格式的，比如a2dp的模块名可能是audio.a2dp.so或者audio.a2dp.default.so等等。查找路径主要有两个，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware\hardware.c]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH1 <span class="meta-string">"/system/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH2 <span class="meta-string">"/vendor/lib64/hw"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_LIBRARY_PATH3 <span class="meta-string">"/odm/lib64/hw"</span></span></span><br></pre></td></tr></table></figure><p>当然，因为Android是完全开源的，各开发商可以根据自己的需要来进行相应的修改，比如下面是Google pixel 设备的音频库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell &amp;&amp; cd system/lib64/hw &amp;&amp; ls -l</span><br><span class="line">-rw-r--r-- 1 root root   30440 2009-01-01 00:00 audio.a2dp.default.so</span><br><span class="line">-rw-r--r-- 1 root root   18156 2009-01-01 00:00 audio.primary.default.so</span><br><span class="line">-rw-r--r-- 1 root root  275612 2009-01-01 00:00 audio.primary.msm8996.so</span><br><span class="line">-rw-r--r-- 1 root root   34540 2009-01-01 00:00 audio.r_submix.default.so</span><br><span class="line">-rw-r--r-- 1 root root   22248 2009-01-01 00:00 audio.usb.default.so</span><br><span class="line">-rw-r--r-- 1 root root   96096 2009-01-01 00:00 audio_policy.default.so</span><br><span class="line">-rw-r--r-- 1 root root 1637208 2009-01-01 00:00 bluetooth.default.so</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>Step3@ loadHwModule_l，进行初始化操作。其中init_check是为了确定这个audio interface是否已经成功初始化，0是成功，其它值表示失败。接下来如果这个device支持主音量，我们还需要通过set_master_volume进行设置。在每次操作device前，都要先改变mHardwareStatus的状态值，操作结束后将其复原为AUDIO_HW_IDLE(根据源码中的注释，这样做是为了方便dump时正确输出内部状态，这里我们就不去深究了)。</p><p>Step4@ loadHwModule_l. 把加载后的设备添加入mAudioHwDevs键值对中，其中key的值是由nextUniqueId生成的，这样做保证了这个audiointerface拥有全局唯一的id号。</p><p>完成了audiointerface的模块加载只是万里长征的第一步。因为每一个interface包含的设备通常不止一个，Android系统目前支持的音频设备如下列表所示：<br> Android系统支持的音频设备列表(输出)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</span><br><span class="line">static uint32_t audio_device_conv_table[][HAL_API_REV_NUM] =</span><br><span class="line">&#123;</span><br><span class="line">    /* output devices */</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_EARPIECE, AUDIO_DEVICE_OUT_EARPIECE &#125;,//</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_SPEAKER, AUDIO_DEVICE_OUT_SPEAKER &#125;,//SPEAKER</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADSET, AUDIO_DEVICE_OUT_WIRED_HEADSET &#125;,//HEADSET</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_WIRED_HEADPHONE, AUDIO_DEVICE_OUT_WIRED_HEADPHONE &#125;,//HEADPHONE</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO, AUDIO_DEVICE_OUT_BLUETOOTH_SCO &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_HEADSET, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_SCO_CARKIT, AUDIO_DEVICE_OUT_BLUETOOTH_SCO_CARKIT &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER, AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_AUX_DIGITAL, AUDIO_DEVICE_OUT_AUX_DIGITAL &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_ANLG_DOCK_HEADSET, AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DGTL_DOCK_HEADSET, AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET &#125;,</span><br><span class="line">    &#123; AudioSystem::DEVICE_OUT_DEFAULT, AUDIO_DEVICE_OUT_DEFAULT &#125;,//默认设备</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可能会有疑问：</p><p>Ø 这么多的输出设备，那么当我们回放音频流(录音也是类似的情况)时，该选择哪一种呢？</p><p>Ø 而且当前系统中audio interface也很可能不止一个，应该如何选择？</p><p>显然这些决策工作将由AudioPolicyService来完成，我们会在下一小节做详细阐述。这里先给大家分析下，AudioFlinger是如何打开一个Output通道的(一个audiointerface可能包含若干个output)。</p><h5 id="1-2-2、打开音频输出通道openOutput"><a href="#1-2-2、打开音频输出通道openOutput" class="headerlink" title="1.2.2、打开音频输出通道openOutput()"></a>1.2.2、打开音频输出通道openOutput()</h5><p>打开音频输出通道(output)在AudioFlinger中对应的接口是openOutput()，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">status_t</span> AudioFlinger::openOutput(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                  <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                  <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                  <span class="keyword">audio_devices_t</span> *devices,</span><br><span class="line">                                  <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> *latencyMs,</span><br><span class="line">                                  <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(<span class="keyword">module</span>, output, config, *devices, address, flags);</span><br><span class="line">    <span class="keyword">if</span> (thread != <span class="number">0</span>) &#123;</span><br><span class="line">        *latencyMs = thread-&gt;latency();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// notify client processes of the new output creation</span></span><br><span class="line">        thread-&gt;ioConfigChanged(AUDIO_OUTPUT_OPENED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the first primary output opened designates the primary hw device</span></span><br><span class="line">        <span class="keyword">if</span> ((mPrimaryHardwareDev == <span class="literal">NULL</span>) &amp;&amp; (flags &amp; AUDIO_OUTPUT_FLAG_PRIMARY)) &#123;</span><br><span class="line">            ALOGI(<span class="string">"Using module %d has the primary audio interface"</span>, <span class="keyword">module</span>);</span><br><span class="line">            mPrimaryHardwareDev = thread-&gt;getOutput()-&gt;audioHwDev;</span><br><span class="line"></span><br><span class="line">            <span class="function">AutoMutex <span class="title">lock</span><span class="params">(mHardwareLock)</span></span>;</span><br><span class="line">            mHardwareStatus = AUDIO_HW_SET_MODE;</span><br><span class="line">            mPrimaryHardwareDev-&gt;hwDevice()-&gt;set_mode(mPrimaryHardwareDev-&gt;hwDevice(), mMode);</span><br><span class="line">            mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_INIT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续调用 openOutput_l()函数从处理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">                                                            <span class="keyword">audio_io_handle_t</span> *output,</span><br><span class="line">                                                            <span class="keyword">audio_config_t</span> *config,</span><br><span class="line">                                                            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">                                                            <span class="keyword">const</span> String8&amp; address,</span><br><span class="line">                                                            <span class="keyword">audio_output_flags_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*Step 1. 查找相应的audio interface</span></span><br><span class="line"><span class="comment">    AudioHwDevice *outHwDev = findSuitableHwDev_l(module, devices);</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     ......</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    AudioStreamOut *outputStream = NULL;</span></span><br><span class="line"><span class="comment">     /*Step 2. 为设备打开一个输出流*/</span></span><br><span class="line">    <span class="keyword">status_t</span> status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.<span class="built_in">string</span>());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line">    <span class="comment">/*Step 3.创建PlaybackThread*/</span></span><br><span class="line">    <span class="keyword">if</span> (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> OffloadThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created offload output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> DirectOutputThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created direct output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            thread = <span class="keyword">new</span> MixerThread(<span class="keyword">this</span>, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(<span class="string">"openOutput_l() created mixer output: ID %d thread %p"</span>, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这段代码中，颜色加深的部分是我们接下来分析的重点，主要还是围绕outHwDev这个变量所做的一系列操作，即：</p><p>·        查找合适的音频接口设备( findSuitableHwDev_l() )</p><p>·        创建音频输出流( 通过openOutputStream()创建AudioStreamOut )</p><p>·        创建播放线程( PlaybackThread )</p><p>outHwDev用于记录一个打开的音频接口设备，它的数据类型是audio_hw_device_t，是由HAL规定的一个音频接口设备所应具有的属性集合，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.h]</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AudioHwDevice</span> &#123;</span></span><br><span class="line">......</span><br><span class="line">    <span class="keyword">audio_module_handle_t</span> handle() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHandle; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">moduleName</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mModuleName; &#125;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> *hwDevice() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice; &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> version() <span class="keyword">const</span> &#123; <span class="keyword">return</span> mHwDevice-&gt;common.version; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">status_t</span> openOutputStream(</span><br><span class="line">            AudioStreamOut **ppStreamOut,</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> handle,</span><br><span class="line">            <span class="keyword">audio_devices_t</span> devices,</span><br><span class="line">            <span class="keyword">audio_output_flags_t</span> flags,</span><br><span class="line">            struct audio_config *config,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *address);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">audio_module_handle_t</span> mHandle;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span>          mModuleName;</span><br><span class="line">    <span class="keyword">audio_hw_device_t</span> * <span class="keyword">const</span>   mHwDevice;</span><br><span class="line">    <span class="keyword">const</span> Flags                 mFlags;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中common代表了HAL层所有设备的共有属性;set_master_volume、set_mode、open_output_stream分别为我们设置audio interface的主音量、设置音频模式类型(比如AUDIO_MODE_RINGTONE、AUDIO_MODE_IN_CALL等等)、打开输出数据流提供了接口。</p><p>接下来我们分步来阐述。</p><h5 id="1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l"><a href="#1-2-2-1、查找合适的音频接口设备findSuitableHwDev-l" class="headerlink" title="1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()"></a>1.2.2.1、查找合适的音频接口设备findSuitableHwDev_l()</h5><p>Step1@ AudioFlinger::openOutput. 在openOutput中，设备outHwDev是通过查找当前系统来得到的，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioHwDevice* AudioFlinger::findSuitableHwDev_l(</span><br><span class="line">        <span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span><br><span class="line">        <span class="keyword">audio_devices_t</span> devices)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if module is 0, the request comes from an old policy manager and we should load</span></span><br><span class="line">    <span class="comment">// well known modules</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"findSuitableHwDev_l() loading well know audio hw modules"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE(audio_interfaces); i++) &#123;</span><br><span class="line">            loadHwModule_l(audio_interfaces[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// then try to find a module supporting the requested device.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mAudioHwDevs.size(); i++) &#123;</span><br><span class="line">            AudioHwDevice *audioHwDevice = mAudioHwDevs.valueAt(i);</span><br><span class="line">            <span class="keyword">audio_hw_device_t</span> *dev = audioHwDevice-&gt;hwDevice();</span><br><span class="line">            <span class="keyword">if</span> ((dev-&gt;get_supported_devices != <span class="literal">NULL</span>) &amp;&amp;</span><br><span class="line">                    (dev-&gt;get_supported_devices(dev) &amp; devices) == devices)</span><br><span class="line">                <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// check a match for the requested module handle</span></span><br><span class="line">        AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(<span class="keyword">module</span>);</span><br><span class="line">        <span class="keyword">if</span> (audioHwDevice != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> audioHwDevice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量module值为0的情况，是为了兼容之前的Audio Policy而特别做的处理。当module等于0时，首先加载所有已知的音频接口设备，然后再根据devices来确定其中符合要求的。入参devices的值实际上来源于“ Android系统支持的音频设备列表(输出)”所示的设备。可以看到，enum中每个设备类型都对应一个特定的比特位，因而上述代码段中可以通过“与运算”来找到匹配的设备。</p><p>当modules为非0值时，说明Audio Policy指定了具体的设备id号，这时就通过查找全局的mAudioHwDevs变量来确认是否存在符合要求的设备。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.h]</span><br><span class="line">DefaultKeyedVector&lt;audio_module_handle_t, AudioHwDevice*&gt;  mAudioHwDevs;</span><br></pre></td></tr></table></figure><p>变量mAudioHwDevs是一个Vector，以audio_module_handle_t为key，每一个handle值唯一确定了已经添加的音频设备。那么在什么时候添加设备呢？</p><p>一种情况就是前面看到的modules为0时，会load所有潜在设备，另一种情况就是AudioPolicyManagerBase在构造时会预加载所有audio_policy.conf中所描述的output。不管是哪一种情况，最终都会调用loadHwModuleàloadHwModule_l，这个函数我们开头就分析过了。</p><p>如果modules为非0，且从mAudioHwDevs中也找不到符合要求的设备，程序并不会就此终结——它会退而求其次，遍历数组中的所有元素寻找支持devices的任何一个audio interface。</p><h5 id="1-2-2-2、创建音频输出流openOutputStream"><a href="#1-2-2-2、创建音频输出流openOutputStream" class="headerlink" title="1.2.2.2、创建音频输出流openOutputStream()"></a>1.2.2.2、创建音频输出流openOutputStream()</h5><p>Step2@ AudioFlinger::openOutput，调用openOutputStream()函数打开一个AudioStreamOut 。源码实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioHwDevice.cpp]</span><br><span class="line">status_t AudioHwDevice::openOutputStream(</span><br><span class="line">        AudioStreamOut **ppStreamOut,</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        audio_output_flags_t flags,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct audio_config originalConfig = *config;</span><br><span class="line">    AudioStreamOut *outputStream = new AudioStreamOut(this, flags);</span><br><span class="line">    </span><br><span class="line">    status_t status = outputStream-&gt;open(handle, devices, config, address);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    *ppStreamOut = outputStream;</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成AudioStreamOut对象并赋值给ppStreamOut ，进一步调用了AudioStreamOut-&gt;open()函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioStreamOut.cpp]</span><br><span class="line">status_t AudioStreamOut::open(</span><br><span class="line">        audio_io_handle_t handle,</span><br><span class="line">        audio_devices_t devices,</span><br><span class="line">        struct audio_config *config,</span><br><span class="line">        const char *address)</span><br><span class="line">&#123;</span><br><span class="line">    audio_stream_out_t *outStream;</span><br><span class="line">    .......</span><br><span class="line">    int status = hwDev()-&gt;open_output_stream(</span><br><span class="line">            hwDev(),</span><br><span class="line">            handle,</span><br><span class="line">            devices,</span><br><span class="line">            customFlags,</span><br><span class="line">            config,</span><br><span class="line">            &amp;outStream,</span><br><span class="line">            address);</span><br><span class="line">    ......</span><br><span class="line">    return status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即会通过audio_hw_device_t-&gt;-&gt;open_output_stream()创建音频输出流</p><h5 id="1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream"><a href="#1-2-2-2-1、audio-hw-device-t-gt-gt-open-output-stream" class="headerlink" title="1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()"></a>1.2.2.2.1、audio_hw_device_t-&gt;-&gt;open_output_stream()</h5><p>我们先看一下HAL层代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open(const hw_module_t *module, const char *name,</span><br><span class="line">                     hw_device_t **device)</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    adev = calloc(1, sizeof(struct audio_device));</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;adev-&gt;lock, (const pthread_mutexattr_t *) NULL);</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    adev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    adev-&gt;device.common.module = (struct hw_module_t *)module;</span><br><span class="line">    adev-&gt;device.common.close = adev_close;</span><br><span class="line"></span><br><span class="line">    adev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    adev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    adev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    adev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    adev-&gt;device.set_master_mute = adev_set_master_mute;</span><br><span class="line">    adev-&gt;device.get_master_mute = adev_get_master_mute;</span><br><span class="line">    adev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    adev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    adev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    adev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    adev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    adev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    adev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    adev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    adev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    adev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当调用open_output_stream 就会调用adev_open_output_stream。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\hardware\qcom\audio\hal\audio_hw.c]</span><br><span class="line">static int adev_open_output_stream(struct audio_hw_device *dev,</span><br><span class="line">                                   audio_io_handle_t handle,</span><br><span class="line">                                   audio_devices_t devices,</span><br><span class="line">                                   audio_output_flags_t flags,</span><br><span class="line">                                   struct audio_config *config,</span><br><span class="line">                                   struct audio_stream_out **stream_out,</span><br><span class="line">                                   const char *address __unused)</span><br><span class="line">&#123;</span><br><span class="line">    struct audio_device *adev = (struct audio_device *)dev;</span><br><span class="line">    struct stream_out *out;</span><br><span class="line">    int i, ret;</span><br><span class="line">    </span><br><span class="line">    *stream_out = NULL;</span><br><span class="line">    out = (struct stream_out *)calloc(1, sizeof(struct stream_out));</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    out-&gt;stream.common.get_sample_rate = out_get_sample_rate;</span><br><span class="line">    out-&gt;stream.common.set_sample_rate = out_set_sample_rate;</span><br><span class="line">    out-&gt;stream.common.get_buffer_size = out_get_buffer_size;</span><br><span class="line">    out-&gt;stream.common.get_channels = out_get_channels;</span><br><span class="line">    out-&gt;stream.common.get_format = out_get_format;</span><br><span class="line">    out-&gt;stream.common.set_format = out_set_format;</span><br><span class="line">    out-&gt;stream.common.standby = out_standby;</span><br><span class="line">    out-&gt;stream.common.dump = out_dump;</span><br><span class="line">    out-&gt;stream.common.set_parameters = out_set_parameters;</span><br><span class="line">    out-&gt;stream.common.get_parameters = out_get_parameters;</span><br><span class="line">    out-&gt;stream.common.add_audio_effect = out_add_audio_effect;</span><br><span class="line">    out-&gt;stream.common.remove_audio_effect = out_remove_audio_effect;</span><br><span class="line">    out-&gt;stream.get_latency = out_get_latency;</span><br><span class="line">    out-&gt;stream.set_volume = out_set_volume;</span><br><span class="line">#ifdef NO_AUDIO_OUT</span><br><span class="line">    out-&gt;stream.write = out_write_for_no_output;</span><br><span class="line">#else</span><br><span class="line">    out-&gt;stream.write = out_write;</span><br><span class="line">#endif</span><br><span class="line">    out-&gt;stream.get_render_position = out_get_render_position;</span><br><span class="line">    out-&gt;stream.get_next_write_timestamp = out_get_next_write_timestamp;</span><br><span class="line">    out-&gt;stream.get_presentation_position = out_get_presentation_position;</span><br><span class="line"></span><br><span class="line">    out-&gt;af_period_multiplier  = out-&gt;realtime ? af_period_multiplier : 1;</span><br><span class="line">    out-&gt;standby = 1;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    *stream_out = &amp;out-&gt;stream;</span><br><span class="line">    ALOGV(&quot;%s: exit&quot;, __func__);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据音频流的熟悉做一系列初始化操作。转了一大圈，继续看看</p><h5 id="1-2-2-3、创建播放线程-PlaybackThread"><a href="#1-2-2-3、创建播放线程-PlaybackThread" class="headerlink" title="1.2.2.3、创建播放线程(PlaybackThread)"></a>1.2.2.3、创建播放线程(PlaybackThread)</h5><p>Step3@ AudioFlinger::openOutput. 既然通道已经打开，那么由谁来往通道里放东西呢？这就是PlaybackThread。这里分三种不同的情况：<br>·        OffloadThread</p><p>·        DirectOutput</p><p>如果不需要混音</p><p>·        Mixer</p><p>需要混音</p><p>这三种情况分别对应DirectOutputThread、OffloadThread和MixerThread两种线程。我们以后者为例来分析下PlaybackThread的工作模式，也会后面小节打下基础。回放线程（PlaybackThread 及其派生的子类）和录制线程（RecordThread）进行的，先简单看看回放线程和录制线程类关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/32-Audio-system-mixerthread.jpg" alt="Alt text"></p><p>·       ThreadBase：PlaybackThread 和 RecordThread 的基类<br>·       RecordThread：录制线程类，由 ThreadBase 派生<br>·       PlaybackThread：回放线程基类，同由 ThreadBase 派生<br>·       MixerThread：混音回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_PRIMARY、AUDIO_OUTPUT_FLAG_FAST、AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流，MixerThread 可以把多个音轨的数据混音后再输出<br>·       DirectOutputThread：直输回放线程类，由 PlaybackThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_DIRECT 的音频流，这种音频流数据不需要软件混音，直接输出到音频设备即可<br>·       DuplicatingThread：复制回放线程类，由 MixerThread 派生，负责复制音频流数据到其他输出设备，使用场景如主声卡设备、蓝牙耳机设备、USB 声卡设备同时输出<br>·       OffloadThread：硬解回放线程类，由 DirectOutputThread 派生，负责处理标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流，这种音频流未经软件解码的（一般是 MP3、AAC 等格式的数据），需要输出到硬件解码器，由硬件解码器解码成 PCM 数据</p><p>PlaybackThread 中有个极为重要的函数 threadLoop()，当 PlaybackThread 被强引用时，threadLoop() 会真正运行起来进入循环主体，处理音频流数据相关事务，threadLoop() 大致流程如下（以 MixerThread 为例）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\Threads.cpp]</span><br><span class="line">bool AudioFlinger::PlaybackThread::threadLoop()</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    while (!exitPending())</span><br><span class="line">    &#123;</span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        &#123; // scope for mLock</span><br><span class="line"></span><br><span class="line">            Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">            processConfigEvents_l();</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line"></span><br><span class="line">            if ((!mActiveTracks.size() &amp;&amp; systemTime() &gt; mStandbyTimeNs) ||</span><br><span class="line">                                   isSuspended()) &#123;</span><br><span class="line">                // put audio hardware into standby after short delay</span><br><span class="line">                if (shouldStandby_l()) &#123;</span><br><span class="line"></span><br><span class="line">                    threadLoop_standby();</span><br><span class="line"></span><br><span class="line">                    mStandby = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // mMixerStatusIgnoringFastTracks is also updated internally</span><br><span class="line">            mMixerStatus = prepareTracks_l(&amp;tracksToRemove);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125; // mLock scope ends</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (mBytesRemaining == 0) &#123;</span><br><span class="line">            mCurrentWriteLength = 0;</span><br><span class="line">            if (mMixerStatus == MIXER_TRACKS_READY) &#123;</span><br><span class="line">                // threadLoop_mix() sets mCurrentWriteLength</span><br><span class="line">                threadLoop_mix();</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!waitingAsyncCallback()) &#123;</span><br><span class="line">            // mSleepTimeUs == 0 means we must write to audio hardware</span><br><span class="line">            if (mSleepTimeUs == 0) &#123;</span><br><span class="line">                // ......</span><br><span class="line">                if (mBytesRemaining) &#123;</span><br><span class="line">                    // FIXME rewrite to reduce number of system calls</span><br><span class="line">                    ret = threadLoop_write();</span><br><span class="line">                    lastWriteFinished = systemTime();</span><br><span class="line">                    delta = lastWriteFinished - mLastWriteTime;</span><br><span class="line">                    if (ret &lt; 0) &#123;</span><br><span class="line">                        mBytesRemaining = 0;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mBytesWritten += ret;</span><br><span class="line">                        mBytesRemaining -= ret;</span><br><span class="line">                        mFramesWritten += ret / mFrameSize;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // ......</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Finally let go of removed track(s), without the lock held</span><br><span class="line">        // since we can&apos;t guarantee the destructors won&apos;t acquire that</span><br><span class="line">        // same lock.  This will also mutate and push a new fast mixer state.</span><br><span class="line">        threadLoop_removeTracks(tracksToRemove);</span><br><span class="line">        tracksToRemove.clear();</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threadLoop_exit();</span><br><span class="line"></span><br><span class="line">    if (!mStandby) &#123;</span><br><span class="line">        threadLoop_standby();</span><br><span class="line">        mStandby = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>threadLoop() 循环的条件是 exitPending() 返回 false，如果想要 PlaybackThread 结束循环，则可以调用 requestExit() 来请求退出；<br>processConfigEvents_l() ：处理配置事件；当有配置改变的事件发生时，需要调用 sendConfigEvent_l() 来通知 PlaybackThread，这样 PlaybackThread 才能及时处理配置事件；常见的配置事件是切换音频通路；<br>检查此时此刻是否符合 standby 条件，比如当前并没有 ACTIVE 状态的 Track（mActiveTracks.size() = 0），那么调用 threadLoop_standby() 关闭音频硬件设备以节省能耗；<br>prepareTracks_l()： 准备音频流和混音器，该函数非常复杂，这里不详细分析了，仅列一下流程要点：<br>遍历 mActiveTracks，逐个处理 mActiveTracks 上的 Track，检查该 Track 是否为 ACTIVE 状态；<br>如果 Track 设置是 ACTIVE 状态，则再检查该 Track 的数据是否准备就绪了；<br>根据音频流的音量值、格式、声道数、音轨的采样率、硬件设备的采样率，配置好混音器参数；<br>如果 Track 的状态是 PAUSED 或 STOPPED，则把该 Track 添加到 tracksToRemove 向量中；<br>threadLoop_mix()：读取所有置了 ACTIVE 状态的音频流数据，混音器开始处理这些数据；<br>threadLoop_write()： 把混音器处理后的数据写到输出流设备；<br>threadLoop_removeTracks()： 把 tracksToRemove 上的所有 Track 从 mActiveTracks 中移除出来；这样下一次循环时就不会处理这些 Track 了。<br>这里说说 PlaybackThread 与输出流设备的关系：PlaybackThread 实例与输出流设备是一一对应的，比方说 OffloadThread 只会将音频数据输出到 compress_offload 设备中，MixerThread(with FastMixer) 只会将音频数据输出到 low_latency 设备中。</p><p>从 Audio HAL 中，我们通常看到如下 4 种输出流设备，分别对应着不同的播放场景：</p><p>primary_out：主输出流设备，用于铃声类声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_PRIMARY 的音频流和一个 MixerThread 回放线程实例<br>low_latency：低延迟输出流设备，用于按键音、游戏背景音等对时延要求高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_FAST 的音频流和一个 MixerThread 回放线程实例<br>deep_buffer：音乐音轨输出流设备，用于音乐等对时延要求不高的声音输出，对应着标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER 的音频流和一个 MixerThread 回放线程实例<br>compress_offload：硬解输出流设备，用于需要硬件解码的数据输出，对应着标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流和一个 OffloadThread 回放线程实例<br>其中 primary_out 设备是必须声明支持的，而且系统启动时就已经打开 primary_out 设备并创建好对应的 MixerThread 实例。其他类型的输出流设备并非必须声明支持的，主要是看硬件上有无这个能力。</p><p>可能有人产生这样的疑问：既然 primary_out 设备一直保持打开，那么能耗岂不是很大？这里阐释一个概念：输出流设备属于逻辑设备，并不是硬件设备。所以即使输出流设备一直保持打开，只要硬件设备不工作，那么就不会影响能耗。那么硬件设备什么时候才会打开呢？答案是 PlaybackThread 将音频数据写入到输出流设备时。</p><p>下图简单描述 AudioTrack、PlaybackThread、输出流设备三者的对应关系：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/33-Audio-system-Audio-playback-.png" alt="Alt text"></p><p>我们可以这么说：输出流设备决定了它对应的 PlaybackThread 是什么类型。怎么理解呢？意思是说：只有支持了该类型的输出流设备，那么该类型的 PlaybackThread 才有可能被创建。举个例子：只有硬件上具备硬件解码器，系统才建立 compress_offload 设备，然后播放 mp3 格式的音乐文件时，才会创建 OffloadThread 把数据输出到 compress_offload 设备上；反之，如果硬件上并不具备硬件解码器，系统则不应该建立 compress_offload 设备，那么播放 mp3 格式的音乐文件时，通过 MixerThread 把数据输出到其他输出流设备上。</p><p>那么有无可能出现这种情况：底层并不支持 compress_offload 设备，但偏偏有个标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流送到 AudioFlinger 了呢？这是不可能的。系统启动时，会检查并保存输入输出流设备的支持信息；播放器在播放 mp3 文件时，首先看 compress_offload 设备是否支持了，如果支持，那么不进行软件解码，直接把数据标识为 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD；如果不支持，那么先进行软件解码，然后把解码好的数据标识为 AUDIO_OUTPUT_FLAG_DEEP_BUFFER，前提是 deep_buffer 设备是支持了的；如果 deep_buffer 设备也不支持，那么把数据标识为 AUDIO_OUTPUT_FLAG_PRIMARY。</p><p>系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 MixerThread 了；而此时 DirectOutputThread 与 OffloadThread 不会被创建，直到标识为 AUDIO_OUTPUT_FLAG_DIRECT/AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 的音频流需要输出时，才开始创建 DirectOutputThread/OffloadThread 和打开 direct_out/compress_offload 设备。这一点请参考如下代码，注释非常清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    // ......</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    // mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span><br><span class="line">    // open all output streams needed to access attached devices</span><br><span class="line">    // ......</span><br><span class="line">    for (size_t i = 0; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        // ......</span><br><span class="line">        // open all output streams needed to access attached devices</span><br><span class="line">        // except for direct output streams that are only opened when they are actually</span><br><span class="line">        // required by an app.</span><br><span class="line">        // This also validates mAvailableOutputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            if ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // ......</span><br><span class="line">            audio_io_handle_t output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            status_t status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">        // open input streams needed to access attached devices to validate</span><br><span class="line">        // mAvailableInputDevices list</span><br><span class="line">        for (size_t j = 0; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            // ......</span><br><span class="line">            status_t status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            // ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 mpClientInterface-&gt;openOutput() 最终会调用到 AudioFlinger::openOutput()：打开输出流设备，并创建 PlaybackThread 对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">status_t AudioFlinger::openOutput(audio_module_handle_t module,</span><br><span class="line">                                  audio_io_handle_t *output,</span><br><span class="line">                                  audio_config_t *config,</span><br><span class="line">                                  audio_devices_t *devices,</span><br><span class="line">                                  const String8&amp; address,</span><br><span class="line">                                  uint32_t *latencyMs,</span><br><span class="line">                                  audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">    sp&lt;PlaybackThread&gt; thread = openOutput_l(module, output, config, *devices, address, flags);</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread&gt; AudioFlinger::openOutput_l(audio_module_handle_t module,</span><br><span class="line">                                                            audio_io_handle_t *output,</span><br><span class="line">                                                            audio_config_t *config,</span><br><span class="line">                                                            audio_devices_t devices,</span><br><span class="line">                                                            const String8&amp; address,</span><br><span class="line">                                                            audio_output_flags_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    // ......</span><br><span class="line">    // 分配全局唯一的 audio_io_handle_t，可以理解它是回放线程的索引号</span><br><span class="line">    if (*output == AUDIO_IO_HANDLE_NONE) &#123;</span><br><span class="line">        *output = nextUniqueId(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_OUTPUT_OPEN;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 打开音频输出流设备，HAL 层根据 flags 选择打开相关类型的输出流设备</span><br><span class="line">    AudioStreamOut *outputStream = NULL;</span><br><span class="line">    status_t status = outHwDev-&gt;openOutputStream(</span><br><span class="line">            &amp;outputStream,</span><br><span class="line">            *output,</span><br><span class="line">            devices,</span><br><span class="line">            flags,</span><br><span class="line">            config,</span><br><span class="line">            address.string());</span><br><span class="line"></span><br><span class="line">    mHardwareStatus = AUDIO_HW_IDLE;</span><br><span class="line"></span><br><span class="line">    if (status == NO_ERROR) &#123;</span><br><span class="line"></span><br><span class="line">        PlaybackThread *thread;</span><br><span class="line">        if (flags &amp; AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 音频流，创建 OffloadThread 实例</span><br><span class="line">            thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created offload output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else if ((flags &amp; AUDIO_OUTPUT_FLAG_DIRECT)</span><br><span class="line">                || !isValidPcmSinkFormat(config-&gt;format)</span><br><span class="line">                || !isValidPcmSinkChannelMask(config-&gt;channel_mask)) &#123;</span><br><span class="line">            // AUDIO_OUTPUT_FLAG_DIRECT 音频流，创建 DirectOutputThread 实例</span><br><span class="line">            thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created direct output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 其他标识的音频流，创建 MixerThread 实例</span><br><span class="line">            thread = new MixerThread(this, outputStream, *output, devices, mSystemReady);</span><br><span class="line">            ALOGV(&quot;openOutput_l() created mixer output: ID %d thread %p&quot;, *output, thread);</span><br><span class="line">        &#125;</span><br><span class="line">        // 把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中</span><br><span class="line">        // 键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一</span><br><span class="line">        // 一对应的关系，所以拿到一个 audio_io_handle_t，就能找到它对应的 PlaybackThread</span><br><span class="line">        // 所以可以理解 audio_io_handle_t 为 PlaybackThread 的索引号</span><br><span class="line">        mPlaybackThreads.add(*output, thread);</span><br><span class="line">        return thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-2-3、AudioFlinger-音频流管理"><a href="#1-2-3、AudioFlinger-音频流管理" class="headerlink" title="1.2.3、AudioFlinger 音频流管理"></a>1.2.3、AudioFlinger 音频流管理</h5><p>AudioFlinger 音频流管理由 AudioFlinger::PlaybackThread::Track 实现，Track 与 AudioTrack 是一对一的关系，一个 AudioTrack 创建后，那么 AudioFlinger 会创建一个 Track 与之对应；PlaybackThread 与 AudioTrack/Track 是一对多的关系，一个 PlaybackThread 可以挂着多个 Track。</p><p>具体来说：AudioTrack 创建后，AudioPolicyManager 根据 AudioTrack 的输出标识和流类型，找到对应的输出流设备和 PlaybackThread（如果没有找到的话，则系统会打开对应的输出流设备并新建一个 PlaybackThread），然后创建一个 Track 并挂到这个 PlaybackThread 下面。</p><p>PlaybackThread 有两个私有成员向量与此强相关：</p><p>·       mTracks：该 PlaybackThread 创建的所有 Track 均添加保存到这个向量中<br>·       mActiveTracks：只有需要播放（设置了 ACTIVE 状态）的 Track 会添加到这个向量中；PlaybackThread 会从该向量上找到所有设置了 ACTIVE 状态的 Track，把这些 Track 数据混音后写到输出流设备<br>音频流控制最常用的三个接口：</p><p>AudioFlinger::PlaybackThread::Track::start：开始播放：把该 Track 置 ACTIVE 状态，然后添加到 mActiveTracks 向量中，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::Track::stop：停止播放：把该 Track 置 STOPPED 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::Track::pause：暂停播放：把该 Track 置 PAUSING 状态，最后调用 AudioFlinger::PlaybackThread::broadcast_l() 告知 PlaybackThread 情况有变<br>·       AudioFlinger::PlaybackThread::threadLoop() 得悉情况有变后，调用 prepareTracks_l() 重新准备音频流和混音器：ACTIVE 状态的 Track 会添加到 mActiveTracks，此外的 Track 会从 mActiveTracks 上移除出来，然后重新准备 AudioMixer。</p><p>可见这三个音频流控制接口是非常简单的，主要是设置一下 Track 的状态，然后发个事件通知 PlaybackThread 就行，复杂的处理都在 AudioFlinger::PlaybackThread::threadLoop() 中了。</p><h4 id="二-、深入剖析Android音频之AudioPolicyService"><a href="#二-、深入剖析Android音频之AudioPolicyService" class="headerlink" title="(二)、深入剖析Android音频之AudioPolicyService"></a>(二)、深入剖析Android音频之AudioPolicyService</h4><p>AudioPolicyService是策略的制定者，比如什么时候打开音频接口设备、某种Stream类型的音频对应什么设备等等。而AudioFlinger则是策略的执行者，例如具体如何与音频设备通信，如何维护现有系统中的音频设备，以及多个音频流的混音如何处理等等都得由它来完成。AudioPolicyService根据用户配置来指导AudioFlinger加载设备接口，起到路由功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\audioserver\main_audioserver.cpp]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc __unused, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">    ......</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// all other services</span></span><br><span class="line">        <span class="keyword">if</span> (doLog) &#123;</span><br><span class="line">            prctl(PR_SET_PDEATHSIG, SIGKILL);   <span class="comment">// if parent media.log dies before me, kill me also</span></span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);                      <span class="comment">// but if I die first, don't kill my parent</span></span><br><span class="line">        &#125;</span><br><span class="line">        sp&lt;ProcessState&gt; proc(ProcessState::self());</span><br><span class="line">        sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">        ALOGI(<span class="string">"ServiceManager: %p"</span>, sm.get());</span><br><span class="line">        AudioFlinger::instantiate();</span><br><span class="line">        AudioPolicyService::instantiate();</span><br><span class="line">        RadioService::instantiate();</span><br><span class="line">        SoundTriggerHwService::instantiate();</span><br><span class="line">        ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">        IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService继承了模板类BinderService，该类用于注册native service。<br>BinderService是一个模板类，该类的publish函数就是完成向ServiceManager注册服务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getServiceName</span><span class="params">()</span> ANDROID_API </span>&#123; <span class="keyword">return</span> <span class="string">"media.audio_policy"</span>; &#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyService注册名为”media.audio_policy”的服务。<br>首先看看AudioPolicyService的onFirstRef()函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"></span><br><span class="line">AudioPolicyService::AudioPolicyService()</span><br><span class="line">    : BnAudioPolicyService(), mpAudioPolicyDev(<span class="literal">NULL</span>), mpAudioPolicy(<span class="literal">NULL</span>),</span><br><span class="line">      mAudioPolicyManager(<span class="literal">NULL</span>), mAudioPolicyClient(<span class="literal">NULL</span>), mPhoneState(AUDIO_MODE_INVALID)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        <span class="comment">/* Step 1:创建AudioCommandThread线程 */</span></span><br><span class="line">        <span class="comment">// start tone playback thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmTone"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start audio commands thread</span></span><br><span class="line">        mAudioCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmAudio"</span>), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// start output activity command thread</span></span><br><span class="line">        mOutputCommandThread = <span class="keyword">new</span> AudioCommandThread(String8(<span class="string">"ApmOutput"</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_LEGACY_AUDIO_POLICY</span></span><br><span class="line">         <span class="comment">// 使用老版本的 audio policy 初始化方式</span></span><br><span class="line">        ....</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="comment">// 使用最新的 audio policy 初始化方式</span></span><br><span class="line">        ALOGI(<span class="string">"AudioPolicyService CSTOR in new mode"</span>);</span><br><span class="line">        <span class="comment">/* Step 2:创建AudioPolicyClient、 AudioPolicyManager */</span></span><br><span class="line">        mAudioPolicyClient = <span class="keyword">new</span> AudioPolicyClient(<span class="keyword">this</span>);</span><br><span class="line">        mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load audio processing modules</span></span><br><span class="line">    sp&lt;AudioPolicyEffects&gt;audioPolicyEffects = <span class="keyword">new</span> AudioPolicyEffects();</span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        mAudioPolicyEffects = audioPolicyEffects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看总体时序图：</p><h5 id="2-1、Step-1-创建AudioCommandThread线程"><a href="#2-1、Step-1-创建AudioCommandThread线程" class="headerlink" title="2.1、Step 1:创建AudioCommandThread线程"></a>2.1、Step 1:创建AudioCommandThread线程</h5><p>在AudioPolicyService对象构造过程中，分别创建了ApmTone、ApmAudio、ApmOutput三个AudioCommandThread线程：</p><p>1、 ApmTone用于播放tone音；</p><p>2、 ApmAudio用于执行audio命令；</p><p>3、ApmOutput用于执行输出命令；</p><p>在第一次强引用AudioCommandThread线程对象时，AudioCommandThread的onFirstRef函数被回调，在此启动线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyService::AudioCommandThread::onFirstRef()</span><br><span class="line">&#123;</span><br><span class="line">    run(mName.<span class="built_in">string</span>(), ANDROID_PRIORITY_AUDIO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里采用异步方式来执行audio command，当需要执行上表中的命令时，首先将命令投递到AudioCommandThread的mAudioCommands命令向量表中，然后通过mWaitWorkCV.signal()唤醒AudioCommandThread线程，被唤醒的AudioCommandThread线程执行完command后，又通过mWaitWorkCV.waitRelative(mLock, waitTime)睡眠等待命令到来。</p><h5 id="2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager"><a href="#2-2、Step-2-创建AudioPolicyClient、-AudioPolicyManager" class="headerlink" title="2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager"></a>2.2、Step 2: 创建AudioPolicyClient、 AudioPolicyManager</h5><p>首先创建AudioPolicyClient </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\service\AudioPolicyService.h]</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">AudioPolicyClient</span> :</span> <span class="keyword">public</span> AudioPolicyClientInterface</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        AudioPolicyClient(AudioPolicyService *service) : mAudioPolicyService(service) &#123;&#125;</span><br><span class="line">        <span class="keyword">virtual</span> ~AudioPolicyClient() &#123;&#125;</span><br><span class="line">        <span class="comment">// loads a HW module.</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_module_handle_t <span class="title">loadHwModule</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> status_t <span class="title">openOutput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_io_handle_t</span> *output,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">uint32_t</span> *latencyMs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">audio_output_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// opens an audio input</span></span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> audio_io_handle_t <span class="title">openInput</span><span class="params">(<span class="keyword">audio_module_handle_t</span> <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_io_handle_t</span> *input,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_config_t</span> *config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_devices_t</span> *devices,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> String8&amp; address,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_source_t</span> source,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">audio_input_flags_t</span> flags)</span></span>;</span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">        AudioPolicyService *mAudioPolicyService;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>createAudioPolicyManager() 函数的实现位于 frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cpp文件中。查看源码后我们会发现它实际上是直接调用了 AudioPolicyManager 的构造函数。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\manager\AudioPolicyFactory.cpp]</span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function">AudioPolicyInterface* <span class="title">createAudioPolicyManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        AudioPolicyClientInterface *clientInterface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AudioPolicyManager(clientInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3、创建AudioPolicyManager"><a href="#2-3、创建AudioPolicyManager" class="headerlink" title="2.3、创建AudioPolicyManager()"></a>2.3、创建AudioPolicyManager()</h5><p>总体流程图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/34-Audio-system-CreateAudioPolicyManager.png" alt="Alt text"></p><p>AudioPolicyManager 的构造函数将解析音频策略配置文件，从而获取到设备所支持的音频设备信息（包括设备是否支持 Offload、Direct 模式输出，各输入输出 profile 所支持的采样率、通道数、数据格式等），加载全部 HwModule，为之创建所有非 direct 输出类型的 outputStream 和所有 inputStream，并创建相应的 playbackThread 或 recordThread 线程。需要注意的是，Android 7.0上的音频策略配置文件开始使用 XML 格式，其文件名为 audio_policy_configuration.xml，</p><p>而在之前的版本上音频策略配置文件为 audio_policy.conf。frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp 中 AudioPolicyManager 构造函数的关键代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line">AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    :</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AUDIO_POLICY_TEST</span></span><br><span class="line">    Thread(<span class="literal">false</span>),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//AUDIO_POLICY_TEST</span></span></span><br><span class="line">    mLimitRingtoneVolume(<span class="literal">false</span>), mLastVoiceVolume(<span class="number">-1.0f</span>),</span><br><span class="line">    mA2dpSuspended(<span class="literal">false</span>),</span><br><span class="line">    mAudioPortGeneration(<span class="number">1</span>),</span><br><span class="line">    mBeaconMuteRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconPlayingRefCount(<span class="number">0</span>),</span><br><span class="line">    mBeaconMuted(<span class="literal">false</span>),</span><br><span class="line">    mTtsOutputAvailable(<span class="literal">false</span>),</span><br><span class="line">    mMasterMono(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_XML_AUDIO_POLICY_CONF</span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy_configuration.xml</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> VolumeCurvesCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled,</span></span></span><br><span class="line">                             static_cast&lt;VolumeCurvesCollection *&gt;(mVolumeCurves));</span><br><span class="line">    PolicySerializer serializer;</span><br><span class="line">    <span class="comment">// 解析 xml 配置文件，将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> (serializer.deserialize(AUDIO_POLICY_XML_CONFIG_FILE, config) != NO_ERROR) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 设备使用的配置文件为 audio_policy.conf</span></span><br><span class="line">    mVolumeCurves = <span class="keyword">new</span> StreamDescriptorCollection();</span><br><span class="line">    <span class="function">AudioPolicyConfig <span class="title">config</span><span class="params">(mHwModules, mAvailableOutputDevices, mAvailableInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">                             mDefaultOutputDevice, speakerDrcEnabled)</span></span>;</span><br><span class="line">    <span class="comment">// 优先解析 vendor 目录下的 conf 配置文件，然后解析 device 目录下的 conf 配置文件。</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输出设备保存在 mAvailableOutputDevices 变量中，</span></span><br><span class="line">    <span class="comment">// 将设备支持的音频输入设备保存在 mAvailableInputDevices 变量中，将设备的默认音频输出</span></span><br><span class="line">    <span class="comment">// 设备保存在 mDefaultOutputDevice 变量中。</span></span><br><span class="line">    <span class="keyword">if</span> ((ConfigParsingUtils::loadConfig(AUDIO_POLICY_VENDOR_CONFIG_FILE, config) != NO_ERROR) &amp;&amp;</span><br><span class="line">            (ConfigParsingUtils::loadConfig(AUDIO_POLICY_CONFIG_FILE, config) != NO_ERROR)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ALOGE(<span class="string">"could not load audio policy configuration file, setting defaults"</span>);</span><br><span class="line">        config.setDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></span><br><span class="line">    mVolumeCurves-&gt;initializeVolumeCurves(speakerDrcEnabled);    <span class="comment">// 设置音量调节曲线</span></span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 依次加载 HwModule 并打开其所含 profile 的 outputStream 及 inputStream</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.size(); i++) &#123;</span><br><span class="line">        mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;getName());</span><br><span class="line">        <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"could not open HW module %s"</span>, mHwModules[i]-&gt;getName());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open all output streams needed to access attached devices</span></span><br><span class="line">        <span class="comment">// except for direct output streams that are only opened when they are actually</span></span><br><span class="line">        <span class="comment">// required by an app.</span></span><br><span class="line">        <span class="comment">// This also validates mAvailableOutputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有非 direct 类型 profile 的 outputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 如果当前操作的 module.profile 是 direct 类型，则不为其打开 outputStream</span></span><br><span class="line">            <span class="keyword">if</span> ((outProfile-&gt;getFlags() &amp; AUDIO_OUTPUT_FLAG_DIRECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ....</span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            sp&lt;SwAudioOutputDescriptor&gt; outputDesc = <span class="keyword">new</span> SwAudioOutputDescriptor(outProfile,</span><br><span class="line">                                                                                 mpClientInterface);</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;supportedDevices = outProfile-&gt;getSupportedDevices();</span><br><span class="line">            <span class="keyword">const</span> DeviceVector &amp;devicesForType = supportedDevices.getDevicesFromType(profileType);</span><br><span class="line">            String8 address = devicesForType.size() &gt; <span class="number">0</span> ? devicesForType.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            outputDesc-&gt;mDevice = profileType;</span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = outputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = outputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = outputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 outputStream 并创建 playbackThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openOutput(outProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            address,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open input streams needed to access attached devices to validate</span></span><br><span class="line">        <span class="comment">// mAvailableInputDevices list</span></span><br><span class="line">        <span class="comment">// 打开当前 module 下所有 profile 的 inputStream</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mInputProfiles.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IOProfile&gt; inProfile = mHwModules[i]-&gt;mInputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">            sp&lt;AudioInputDescriptor&gt; inputDesc =</span><br><span class="line">                    <span class="keyword">new</span> AudioInputDescriptor(inProfile);</span><br><span class="line"></span><br><span class="line">            inputDesc-&gt;mDevice = profileType;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取采样率、通道数、数据格式等各音频参数</span></span><br><span class="line">            <span class="comment">// find the address</span></span><br><span class="line">            DeviceVector inputDevices = mAvailableInputDevices.getDevicesFromType(profileType);</span><br><span class="line">            <span class="comment">//   the inputs vector must be of size 1, but we don't want to crash here</span></span><br><span class="line">            String8 address = inputDevices.size() &gt; <span class="number">0</span> ? inputDevices.itemAt(<span class="number">0</span>)-&gt;mAddress</span><br><span class="line">                    : String8(<span class="string">""</span>);</span><br><span class="line">            ALOGV(<span class="string">"  for input device 0x%x using address %s"</span>, profileType, address.<span class="built_in">string</span>());</span><br><span class="line">            ALOGE_IF(inputDevices.size() == <span class="number">0</span>, <span class="string">"Input device list is empty!"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = inputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = inputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = inputDesc-&gt;mFormat;</span><br><span class="line">            <span class="keyword">audio_io_handle_t</span> input = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">            <span class="comment">// 为当前 module.profile 打开对应的 inputStream 并创建 recordThread 线程</span></span><br><span class="line">            <span class="keyword">status_t</span> status = mpClientInterface-&gt;openInput(inProfile-&gt;getModuleHandle(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    updateDevicesAndOutputs();    <span class="comment">// 更新系统缓存的音频输出设备信息</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioPolicyManager对象构造过程中主要完成以下几个步骤：</p><p>1、  加载audio_policy_configuration.xml或者audio_policy.conf配置文件</p><p>2、 初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</p><p>3、  加载audio policy硬件抽象库：mpClientInterface-&gt;loadHwModule(mHwModules[i]-&gt;mName)</p><p>4、  打开对应的outputStream和inputStream  ： mpClientInterface-&gt;openOutput()、mpClientInterface-&gt;openInput</p><p>5、   更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</p><h5 id="2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件"><a href="#2-3-1、加载audio-policy-configuration-xml或者audio-policy-conf配置文件" class="headerlink" title="2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件"></a>2.3.1、加载audio_policy_configuration.xml或者audio_policy.conf配置文件</h5><p><a href="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/audio_policy_configuration.xml" target="_blank" rel="noopener">audio_policy_configuration.xml</a><br>audio_policy.conf同时定义了多个audio 接口，每一个audio 接口包含若干output和input，而每个output和input又同时支持多种输入输出模式，每种输入输出模式又支持若干种设备。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/35-Audio-system-audio_policy.conf.png" alt="Alt text"></p><h5 id="2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled"><a href="#2-3-2、初始化音量调节点initializeVolumeCurves-speakerDrcEnabled" class="headerlink" title="2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)"></a>2.3.2、初始化音量调节点initializeVolumeCurves(speakerDrcEnabled)</h5><p>在AudioPolicyManagerBase中定义了音量调节对应的音频流描述符数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//audio_policy_volumes.xml</span><br><span class="line">const AudioPolicyManagerBase::VolumeCurvePoint</span><br><span class="line">            *AudioPolicyManagerBase::sVolumeProfiles[AudioSystem::NUM_STREAM_TYPES]</span><br><span class="line">                                                   [AudioPolicyManagerBase::DEVICE_CATEGORY_CNT] = &#123;</span><br><span class="line">    &#123; // AUDIO_STREAM_VOICE_CALL</span><br><span class="line">        sDefaultVoiceVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sSpeakerVoiceVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultVoiceVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123; // AUDIO_STREAM_SYSTEM</span><br><span class="line">        sHeadsetSystemVolumeCurve, // DEVICE_CATEGORY_HEADSET</span><br><span class="line">        sDefaultSystemVolumeCurve, // DEVICE_CATEGORY_SPEAKER</span><br><span class="line">        sDefaultSystemVolumeCurve  // DEVICE_CATEGORY_EARPIECE</span><br><span class="line">    &#125;,</span><br><span class="line">    ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>initializeVolumeCurves()函数就是初始化该数组元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManagerBase::initializeVolumeCurves()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; AudioSystem::NUM_STREAM_TYPES; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; DEVICE_CATEGORY_CNT; j++) &#123;</span><br><span class="line">            mStreams[i].mVolumeCurve[j] =</span><br><span class="line">                    sVolumeProfiles[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check availability of DRC on speaker path: if available, override some of the speaker curves</span></span><br><span class="line">    <span class="keyword">if</span> (mSpeakerDrcEnabled) &#123;</span><br><span class="line">        mStreams[AUDIO_STREAM_SYSTEM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sDefaultSystemVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_RING].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_ALARM].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">        mStreams[AUDIO_STREAM_NOTIFICATION].mVolumeCurve[DEVICE_CATEGORY_SPEAKER] =</span><br><span class="line">                sSpeakerSonificationVolumeCurveDrc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-3、加载audio-policy硬件抽象库loadHwModule"><a href="#2-3-3、加载audio-policy硬件抽象库loadHwModule" class="headerlink" title="2.3.3、加载audio policy硬件抽象库loadHwModule()"></a>2.3.3、加载audio policy硬件抽象库loadHwModule()</h5><p>我们直接分析AudioFlinger::loadHwModule_l()中的load_audio_interface()函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">static int load_audio_interface(const char *if_name, audio_hw_device_t **dev)</span><br><span class="line">&#123;</span><br><span class="line">    const hw_module_t *mod;</span><br><span class="line">    int rc;</span><br><span class="line">    //根据名字加载audio_module模块  </span><br><span class="line">    rc = hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID, if_name, &amp;mod);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t load audio hw module %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    //打开audio_device设备</span><br><span class="line">    rc = audio_hw_device_open(mod, dev);</span><br><span class="line">    ALOGE_IF(rc, &quot;%s couldn&apos;t open audio hw device in %s.%s (%s)&quot;, __func__,</span><br><span class="line">                 AUDIO_HARDWARE_MODULE_ID, if_name, strerror(-rc));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">audio_hw_device_open</span><span class="params">(<span class="keyword">const</span> struct <span class="keyword">hw_module_t</span>* <span class="keyword">module</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       struct audio_hw_device** device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>-&gt;methods-&gt;open(<span class="keyword">module</span>, AUDIO_HARDWARE_INTERFACE,</span><br><span class="line">                                 (struct <span class="keyword">hw_device_t</span>**)device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[-&gt;\hardware\libhardware_legacy\audio\audio_hw_hal.cpp]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">static int legacy_adev_open(const hw_module_t* module, const char* name,</span><br><span class="line">                            hw_device_t** device)</span><br><span class="line">&#123;</span><br><span class="line">    struct legacy_audio_device *ladev;</span><br><span class="line">    int ret;</span><br><span class="line">    ladev = (struct legacy_audio_device *)calloc(1, sizeof(*ladev));</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.common.tag = HARDWARE_DEVICE_TAG;</span><br><span class="line">    ladev-&gt;device.common.version = AUDIO_DEVICE_API_VERSION_2_0;</span><br><span class="line">    ladev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module);</span><br><span class="line">    ladev-&gt;device.common.close = legacy_adev_close;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;device.init_check = adev_init_check;</span><br><span class="line">    ladev-&gt;device.set_voice_volume = adev_set_voice_volume;</span><br><span class="line">    ladev-&gt;device.set_master_volume = adev_set_master_volume;</span><br><span class="line">    ladev-&gt;device.get_master_volume = adev_get_master_volume;</span><br><span class="line">    ladev-&gt;device.set_mode = adev_set_mode;</span><br><span class="line">    ladev-&gt;device.set_mic_mute = adev_set_mic_mute;</span><br><span class="line">    ladev-&gt;device.get_mic_mute = adev_get_mic_mute;</span><br><span class="line">    ladev-&gt;device.set_parameters = adev_set_parameters;</span><br><span class="line">    ladev-&gt;device.get_parameters = adev_get_parameters;</span><br><span class="line">    ladev-&gt;device.get_input_buffer_size = adev_get_input_buffer_size;</span><br><span class="line">    ladev-&gt;device.open_output_stream = adev_open_output_stream;</span><br><span class="line">    ladev-&gt;device.close_output_stream = adev_close_output_stream;</span><br><span class="line">    ladev-&gt;device.open_input_stream = adev_open_input_stream;</span><br><span class="line">    ladev-&gt;device.close_input_stream = adev_close_input_stream;</span><br><span class="line">    ladev-&gt;device.dump = adev_dump;</span><br><span class="line"></span><br><span class="line">    ladev-&gt;hwif = createAudioHardware();</span><br><span class="line"></span><br><span class="line">    *device = &amp;ladev-&gt;device.common;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此就加载完系统定义的所有音频接口，并生成相应的数据对象，如下图所示：’<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/36-Audio-system-audiohwdevice.png" alt="Alt text"></p><h5 id="2-3-4、打开对应的outputStream和inputStream"><a href="#2-3-4、打开对应的outputStream和inputStream" class="headerlink" title="2.3.4、打开对应的outputStream和inputStream"></a>2.3.4、打开对应的outputStream和inputStream</h5><p>前面一小节已经分析过outputStream，这里不再分析了<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/37-Audio-system-AudioStreamOut.png" alt="Alt text"></p><p>打开音频输出后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/38-Audio-system-audiohwdevice-openoutput.png" alt="Alt text"></p><p>打开音频输入:<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/39-Audio-system-AudioStreamIn.png" alt="Alt text"><br>打开音频输入后，在AudioFlinger与AudioPolicyService中的表现形式如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/310-Audio-system-audiohwdevice-openinput.png" alt="Alt text"></p><h5 id="2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs"><a href="#2-3-5、-更新系统缓存的音频输出设备信息updateDevicesAndOutputs" class="headerlink" title="2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()"></a>2.3.5、 更新系统缓存的音频输出设备信息updateDevicesAndOutputs()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audiopolicy\managerdefault\AudioPolicyManager.cpp]</span><br><span class="line"><span class="keyword">void</span> AudioPolicyManager::updateDevicesAndOutputs()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_STRATEGIES; i++) &#123;</span><br><span class="line">        mDeviceForStrategy[i] = getDeviceForStrategy((routing_strategy)i, <span class="literal">false</span> <span class="comment">/*fromCache*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mPreviousOutputs = mOutputs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h5><p>-&gt;打开音频输出时创建一个audio_stream_out通道，并创建AudioStreamOut对象以及新建PlaybackThread播放线程。</p><p>-&gt; 打开音频输入时创建一个audio_stream_in通道，并创建AudioStreamIn对象以及创建RecordThread录音线程。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/311-Audio-system-audio_stream_in-out.png" alt="Alt text"></p><h4 id="三-、深入剖析Android音频之AudioTrack"><a href="#三-、深入剖析Android音频之AudioTrack" class="headerlink" title="(三)、深入剖析Android音频之AudioTrack"></a>(三)、深入剖析Android音频之AudioTrack</h4><p>现在我们开始分析 AudioTrack 的创建过程，特别留意 AudioTrack 与 AudioFlinger 如何建立联系、用于 AudioTrack 与 AudioFlinger 交换数据的匿名共享内存如何分配。</p><h5 id="3-1-AudioTrack-amp-AudioFlinger-相关类"><a href="#3-1-AudioTrack-amp-AudioFlinger-相关类" class="headerlink" title="3.1. AudioTrack &amp; AudioFlinger 相关类"></a>3.1. AudioTrack &amp; AudioFlinger 相关类</h5><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/312-Audio-system-create_audiotrack-flow.png" alt="Alt text"></p><p>首先看一下 AudioTrack &amp; AudioFlinger 的类图，理一下 AudioFlinger 的主要类及其关系、AudioTrack 与 AudioFlinger 之间的联系，后面将以该图为脉络展开分析。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/313-Audio-system-create_audiotrack.jpg" alt="Alt text"></p><p>☯ AudioFlinger::PlaybackThread：回放线程基类，不同输出标识的音频流对应不同类型的 PlaybackThread 实例（分为四种：MixerThread、DirectOutputThread、DuplicatingThread、OffloadThread），具体见 3.4. AudioFlinger 回放录制线程 小节，所有的 PlaybackThread 实例都会添加到 AudioFlinger.mPlaybackThreads 向量中；这个向量的定义： DefaultKeyedVector&lt; audio_io_handle_t, sp<playbackthread> &gt; mPlaybackThreads;，可见 audio_io_handle_t 是与 PlaybackThread 是一一对应的，由已知的 audio_io_handle_t 就能找到对应的 PlaybackThread；audio_io_handle_t 在创建 PlaybackThread 时由系统分配，这个值是全局唯一的<br>☯ AudioFlinger::PlaybackThread::Track：音频流管理类，创建一块匿名共享内存用于 AudioTrack 与 AudioFlinger 之间的数据交换（方便起见，这块匿名共享内存，以后均简单称为 FIFO），同时实现 start()、stop()、pause() 等音频流常用控制手段；注意，多个 Track 对象可能都注册到同一个 PlaybackThread 中（尤其对于 MixerThread 而言，一个 MixerThread 往往挂着多个 Track 对象），这多个 Track 对象都会添加到 PlaybackThread.mTracks 向量中统一管理<br>☯ AudioFlinger::TrackHandle：Track 对象只负责音频流管理业务，对外并没有提供跨进程的 Binder 调用接口，而应用进程又需要对音频流进行控制，所以需要一个对象来代理 Track 的跨进程通讯，这个角色就是 TrackHandle，AudioTrack 通过它与 Track 交互<br>☯ AudioTrack：Android 音频系统对外提供的一个 API 类，负责音频流数据输出；每个音频流对应着一个 AudioTrack 实例，不同输出标识的 AudioTrack 会匹配到不同的 AudioFlinger::PlaybackThread；AudioTrack 与 AudioFlinger::PlaybackThread 之间通过 FIFO 来交换音频数据，AudioTrack 是 FIFO 生产者，AudioFlinger::PlaybackThread 是 FIFO 消费者<br>☯ AudioTrack::AudioTrackThread：数据传输模式为 TRANSFER_CALLBACK 时，需要创建该线程，它通过调用 audioCallback 回调函数主动从用户进程处索取数据并填充到 FIFO 上；数据传输模式为 TRANSFER_SYNC 时，则不需要创建这个线程，因为用户进程会持续调用 AudioTrack.write() 填充数据到 FIFO；数据传输模式为 TRANSFER_SHARED 时，也不需要创建这个线程，因为用户进程会创建一块匿名共享内存，并把要播放的音频数据一次性拷贝到这块匿名共享内存上了<br>☯ IAudioTrack：IAudioTrack 是链结 AudioTrack 与 AudioFlinger 的桥梁；它在 AudioTrack 端的对象是 BpAudioTrack，在 AudioFlinger 端的对象是 BnAudioTrack，从图中不难看出，AudioFlinger::TrackHandle 继承自 BnAudioTrack，而 AudioFlinger::TrackHandle 恰恰是AudioFlinger::PlaybackThread::Track 的代理对象，所以 AudioTrack 得到 IAudioTrack 实例后，就可以调用 IAudioTrack 的接口与 AudioFlinger::PlaybackThread::Track 交互</playbackthread></p><p><strong>audio_io_handle_t：</strong></p><p>这里再详细说明一下 audio_io_handle_t，它是 AudioTrack/AudioRecord/AudioSystem、AudioFlinger、AudioPolicyManager 之间一个重要的链结点。3.4. AudioFlinger 回放录制线程 小节在 AudioFlinger::openOutput_l() 注释中大致说明了它的来历及其作用，现在回顾下：当打开输出流设备及创建 PlaybackThread 时，系统会分配一个全局唯一的值作为 audio_io_handle_t，并把 audio_io_handle_t 和 PlaybackThread 添加到键值对向量 mPlaybackThreads 中，由于 audio_io_handle_t 和 PlaybackThread 是一一对应的关系，因此拿到一个 audio_io_handle_t，就能遍历键值对向量 mPlaybackThreads 找到它对应的 PlaybackThread，可以简单理解 audio_io_handle_t 为 PlaybackThread 的索引号或线程 id。由于 audio_io_handle_t 具有 PlaybackThread 索引特性，所以应用进程想获取 PlaybackThread 某些信息的话，只需要传入对应的 audio_io_handle_t 即可。例如 AudioFlinger::format(audio_io_handle_t output)，这是 AudioFlinger 的一个服务接口，用户进程可以通过该接口获取某个 PlaybackThread 配置的音频格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line"><span class="keyword">audio_format_t</span> AudioFlinger::format(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(mLock);</span><br><span class="line">    <span class="comment">// checkPlaybackThread_l() 根据传入的 audio_io_handle_t，从键值对向量</span></span><br><span class="line">    <span class="comment">// mPlaybackThreads 中找到它对应的 PlaybackThread</span></span><br><span class="line">    PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"format() unknown thread %d"</span>, output);</span><br><span class="line">        <span class="keyword">return</span> AUDIO_FORMAT_INVALID;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread-&gt;format();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::PlaybackThread *AudioFlinger::checkPlaybackThread_l(<span class="keyword">audio_io_handle_t</span> output) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mPlaybackThreads.valueFor(output).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-AudioTrack-构造过程"><a href="#3-2-AudioTrack-构造过程" class="headerlink" title="3.2. AudioTrack 构造过程"></a>3.2. AudioTrack 构造过程</h5><p>当我们构造一个 AudioTrack 实例时（以 MODE_STREAM/TRANSFER_SYNC 模式为例，这也是最常用的模式了，此时 sharedBuffer 为空），系统都发生了什么事？阐述下大致流程：</p><p>如果 cbf（audioCallback 回调函数）非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数（MODE_STREAM 模式时，cbf 为空）；<br>根据 streamType（流类型）、flags（输出标识）等参数调用 AudioSystem::getOutputForAttr()；经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()：<br>如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相应的 PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；<br>如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；别忘了在 3.4. AudioFlinger 回放录制线程 小节中提到：系统启动时，就已经打开 primary_out、low_latency、deep_buffer 这三种输出流设备，并创建对应的 PlaybackThread 了；<br>通过 Binder 机制调用 AudioFlinger::createTrack()（注意 step2 中 AudioTrack 已经拿到一个 audio_io_handle_t 了，此时把这个 audio_io_handle_t 传入给 createTrack()）：<br>根据传入的 audio_io_handle_t 找到它对应的 PlaybackThread；<br>PlaybackThread 新建一个音频流管理对象 Track；Track 构造时会分配一块匿名共享内存用于 AudioFlinger 与 AudioTrack 的数据交换缓冲区（FIFO）及其控制块（audio_track_cblk_t），并创建一个 AudioTrackServerProxy 对象（PlaybackThread 将使用它从 FIFO 上取得可读数据的位置）；<br>最后新建一个 Track 的通讯代理 TrackHandle，并以 IAudioTrack 作为返回值给 AudioTrack（TrackHandle、BnAudioTrack、BpAudioTrack、IAudioTrack 的关系见上一个小节）；<br>通过 IAudioTrack 接口，取得 AudioFlinger 中的 FIFO 控制块（audio_track_cblk_t），由此再计算得到 FIFO 的首地址；<br>创建一个 AudioTrackClientProxy 对象（AudioTrack 将使用它从 FIFO 上取得可用空间的位置）；<br>AudioTrack 由此建立了和 AudioFlinger 的全部联系工作：</p><p>通过 IAudioTrack 接口可以控制该音轨的状态，例如 start、stop、pause<br>持续写入数据到 FIFO 上，实现音频连续播放<br>通过 audio_io_handle_t，可以找到它对应的 PlaybackThread，从而查询该 PlaybackThread 的相关信息，如所设置的采样率、格式等等<br>构造 1 个 AudioTrack 实例时，AudioFlinger 会有 1 个 PlaybackThread 实例、1 个 Track 实例、1 个 TrackHandle 实例、1 个 AudioTrackServerProxy 实例、1 块 FIFO 与之对应。</p><p>当同时构造 1 个 AudioTrack with AUDIO_OUTPUT_FLAG_PRIMARY、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_FAST、3 个 AudioTrack with AUDIO_OUTPUT_FLAG_DEEP_BUFFER、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD、1 个 AudioTrack with AUDIO_OUTPUT_FLAG_DIRECT 时（事实上，Android 音频策略不允许出现这种情形的），AudioFlinger 拥有的 PlaybackThread、Track、TrackHandle 实例如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/314-Audio-system-PlaybackThread-Track-TrackHandle.png" alt="Alt text"></p><p>最后附上相关代码的流程分析，我本意是不多贴代码的，但不上代码总觉得缺点什么，这里我尽量把代码精简，提取主干，忽略细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">AudioTrack::AudioTrack(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,    <span class="comment">// 音频流类型：如 Music、Voice-Call、DTMF、Alarm 等等</span></span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,               <span class="comment">// 采样率：如 16KHz、44.1KHz、48KHz 等等</span></span><br><span class="line">        <span class="keyword">audio_format_t</span> format,             <span class="comment">// 音频格式：如 PCM、MP3、AAC 等等</span></span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,  <span class="comment">// 声道数：如 Mono（单声道）、Stereo（双声道）</span></span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,   <span class="comment">// 共享内存缓冲区：数据模式是 MODE_STATIC 时使用，数据模式是 MODE_STREAM 时为空</span></span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        <span class="comment">// 输出标识位，详见 AUDIO_OUTPUT_FLAG 描述</span></span><br><span class="line">        <span class="keyword">callback_t</span> cbf,                    <span class="comment">// 回调函数</span></span><br><span class="line">        <span class="keyword">void</span>* user,                        <span class="comment">// 回调函数的参数</span></span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,        <span class="comment">// 数据传输类型</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">    : mStatus(NO_INIT),</span><br><span class="line">      mIsTimed(<span class="literal">false</span>),</span><br><span class="line">      mPreviousPriority(ANDROID_PRIORITY_NORMAL),</span><br><span class="line">      mPreviousSchedulingGroup(SP_DEFAULT),</span><br><span class="line">      mPausedPosition(<span class="number">0</span>),</span><br><span class="line">      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)</span><br><span class="line">&#123;</span><br><span class="line">    mStatus = <span class="built_in">set</span>(streamType, sampleRate, format, channelMask,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/*frameCount*/</span>, flags, cbf, user, notificationFrames,</span><br><span class="line">            sharedBuffer, <span class="literal">false</span> <span class="comment">/*threadCanCallJava*/</span>, sessionId, transferType, offloadInfo,</span><br><span class="line">            uid, pid, pAttributes, doNotReconnect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::<span class="built_in">set</span>(</span><br><span class="line">        <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">        <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">        <span class="keyword">audio_format_t</span> format,</span><br><span class="line">        <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">        <span class="keyword">size_t</span> frameCount,</span><br><span class="line">        <span class="keyword">audio_output_flags_t</span> flags,        </span><br><span class="line">        <span class="keyword">callback_t</span> cbf,</span><br><span class="line">        <span class="keyword">void</span>* user,</span><br><span class="line">        <span class="keyword">uint32_t</span> notificationFrames,</span><br><span class="line">        <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        <span class="keyword">bool</span> threadCanCallJava,</span><br><span class="line">        <span class="keyword">int</span> sessionId,</span><br><span class="line">        transfer_type transferType,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_offload_info_t</span> *offloadInfo,</span><br><span class="line">        <span class="keyword">int</span> uid,</span><br><span class="line">        <span class="keyword">pid_t</span> pid,</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">audio_attributes_t</span>* pAttributes,</span><br><span class="line">        <span class="keyword">bool</span> doNotReconnect)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 参数格式合法性检查、音轨音量初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 cbf 非空，那么创建 AudioTrackThread 线程处理 audioCallback 回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (cbf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioTrackThread = <span class="keyword">new</span> AudioTrackThread(*<span class="keyword">this</span>, threadCanCallJava);</span><br><span class="line">        mAudioTrackThread-&gt;run(<span class="string">"AudioTrack"</span>, ANDROID_PRIORITY_AUDIO, <span class="number">0</span> <span class="comment">/*stack*/</span>);</span><br><span class="line">        <span class="comment">// thread begins in paused state, and will not reference us until start()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the IAudioTrack</span></span><br><span class="line">    <span class="keyword">status_t</span> status = createTrack_l();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">status_t</span> AudioTrack::createTrack_l()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取 IAudioFlinger，通过 binder 请求 AudioFlinger 服务</span></span><br><span class="line">    <span class="keyword">const</span> sp&lt;IAudioFlinger&gt;&amp; audioFlinger = AudioSystem::get_audio_flinger();</span><br><span class="line">    <span class="keyword">if</span> (audioFlinger == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get audioflinger"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioSystem::getOutputForAttr() 经过一系列的调用，进入 AudioPolicyManager::getOutputForDevice()</span></span><br><span class="line">    <span class="comment">// 如果输出标识置了 AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD 或 AUDIO_OUTPUT_FLAG_DIRECT，</span></span><br><span class="line">    <span class="comment">// 那么最终调用 AudioFlinger::openOutput() 打开输出标识对应的输出流设备并创建相关的</span></span><br><span class="line">    <span class="comment">// PlaybackThread，保存该 PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack；</span></span><br><span class="line">    <span class="comment">// 如果输出标识是其他类型，那么根据策略选择一个输出流设备和 PlaybackThread，并保存该</span></span><br><span class="line">    <span class="comment">// PlaybackThread 对应的 audio_io_handle_t 给 AudioTrack</span></span><br><span class="line">    <span class="keyword">audio_io_handle_t</span> output;</span><br><span class="line">    status = AudioSystem::getOutputForAttr(attr, &amp;output,</span><br><span class="line">                                           (<span class="keyword">audio_session_t</span>)mSessionId, &amp;streamType, mClientUid,</span><br><span class="line">                                           mSampleRate, mFormat, mChannelMask,</span><br><span class="line">                                           mFlags, mSelectedDeviceId, mOffloadInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 AudioFlinger 发出 createTrack 请求</span></span><br><span class="line">    sp&lt;IAudioTrack&gt; track = audioFlinger-&gt;createTrack(streamType,</span><br><span class="line">                                                      mSampleRate,</span><br><span class="line">                                                      mFormat,</span><br><span class="line">                                                      mChannelMask,</span><br><span class="line">                                                      &amp;temp,</span><br><span class="line">                                                      &amp;trackFlags,</span><br><span class="line">                                                      mSharedBuffer,</span><br><span class="line">                                                      output,</span><br><span class="line">                                                      tid,</span><br><span class="line">                                                      &amp;mSessionId,</span><br><span class="line">                                                      mClientUid,</span><br><span class="line">                                                      &amp;status);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AudioFlinger 创建 Track 对象时会分配一个 FIFO，这里获取 FIFO 的控制块</span></span><br><span class="line">    sp&lt;IMemory&gt; iMem = track-&gt;getCblk();</span><br><span class="line">    <span class="keyword">if</span> (iMem == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匿名共享内存首地址</span></span><br><span class="line">    <span class="keyword">void</span> *iMemPointer = iMem-&gt;pointer();</span><br><span class="line">    <span class="keyword">if</span> (iMemPointer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Could not get control block pointer"</span>);</span><br><span class="line">        <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    &#125;</span><br><span class="line">    mAudioTrack = track; <span class="comment">// 保存 AudioFlinger::PlaybackThread::Track 的代理对象 IAudioTrack</span></span><br><span class="line">    mCblkMemory = iMem; <span class="comment">// 保存匿名共享内存首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制块位于 AudioFlinger 分配的匿名共享内存的首部</span></span><br><span class="line">    <span class="keyword">audio_track_cblk_t</span>* cblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span>*&gt;(iMemPointer);</span><br><span class="line">    mCblk = cblk;</span><br><span class="line">    mOutput = output; <span class="comment">// 保存返回的 audio_io_handle_t，用它可以找到对应的 PlaybackThread</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update proxy</span></span><br><span class="line">    <span class="keyword">if</span> (mSharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 为空，意味着音轨数据模式为 MODE_STREAM，那么创建 AudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy.clear();</span><br><span class="line">        mProxy = <span class="keyword">new</span> AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 mSharedBuffer 非空，意味着音轨数据模式为 MODE_STATIC，那么创建 StaticAudioTrackClientProxy 对象</span></span><br><span class="line">        mStaticProxy = <span class="keyword">new</span> StaticAudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize);</span><br><span class="line">        mProxy = mStaticProxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AudioFlinger::createTrack()，顾名思义，创建一个 Track 对象，将用于音频流的控制：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">sp&lt;IAudioTrack&gt; AudioFlinger::createTrack(</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *frameCount,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        audio_io_handle_t output,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int *sessionId,</span><br><span class="line">        int clientUid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;PlaybackThread::Track&gt; track;</span><br><span class="line">    sp&lt;TrackHandle&gt; trackHandle;</span><br><span class="line">    sp&lt;Client&gt; client;</span><br><span class="line">    status_t lStatus;</span><br><span class="line">    int lSessionId;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line">        // 根据传入来的 audio_io_handle_t，找到对应的 PlaybackThread</span><br><span class="line">        PlaybackThread *thread = checkPlaybackThread_l(output);</span><br><span class="line">        if (thread == NULL) &#123;</span><br><span class="line">            ALOGE(&quot;no playback thread found for output handle %d&quot;, output);</span><br><span class="line">            lStatus = BAD_VALUE;</span><br><span class="line">            goto Exit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        // 在 PlaybackThread 上创建一个音频流管理对象 Track</span><br><span class="line">        track = thread-&gt;createTrack_l(client, streamType, sampleRate, format,</span><br><span class="line">                channelMask, frameCount, sharedBuffer, lSessionId, flags, tid, clientUid, &amp;lStatus);</span><br><span class="line">        //......</span><br><span class="line"></span><br><span class="line">        setAudioHwSyncForSession_l(thread, (audio_session_t)lSessionId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //......</span><br><span class="line"></span><br><span class="line">    // 创建 Track 的通讯代理 TrackHandle 并返回它</span><br><span class="line">    trackHandle = new TrackHandle(track);</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return trackHandle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;AudioFlinger::PlaybackThread::Track&gt; AudioFlinger::PlaybackThread::createTrack_l(</span><br><span class="line">        const sp&lt;AudioFlinger::Client&gt;&amp; client,</span><br><span class="line">        audio_stream_type_t streamType,</span><br><span class="line">        uint32_t sampleRate,</span><br><span class="line">        audio_format_t format,</span><br><span class="line">        audio_channel_mask_t channelMask,</span><br><span class="line">        size_t *pFrameCount,</span><br><span class="line">        const sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">        int sessionId,</span><br><span class="line">        IAudioFlinger::track_flags_t *flags,</span><br><span class="line">        pid_t tid,</span><br><span class="line">        int uid,</span><br><span class="line">        status_t *status)</span><br><span class="line">&#123;</span><br><span class="line">    size_t frameCount = *pFrameCount;</span><br><span class="line">    sp&lt;Track&gt; track;</span><br><span class="line">    status_t lStatus;</span><br><span class="line"></span><br><span class="line">    bool isTimed = (*flags &amp; IAudioFlinger::TRACK_TIMED) != 0;</span><br><span class="line"></span><br><span class="line">    // ......</span><br><span class="line"></span><br><span class="line">    &#123; // scope for mLock</span><br><span class="line">        Mutex::Autolock _l(mLock);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        if (!isTimed) &#123;</span><br><span class="line">            // 创建 Track，等会再看看 Track 构造函数干些啥</span><br><span class="line">            track = new Track(this, client, streamType, sampleRate, format,</span><br><span class="line">                              channelMask, frameCount, NULL, sharedBuffer,</span><br><span class="line">                              sessionId, uid, *flags, TrackBase::TYPE_DEFAULT);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 创建 TimedTrack，带时间戳的 Track？这里不深究</span><br><span class="line">            track = TimedTrack::create(this, client, streamType, sampleRate, format,</span><br><span class="line">                    channelMask, frameCount, sharedBuffer, sessionId, uid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line"></span><br><span class="line">        // 把创建的 Track 添加到 mTracks 向量中，方便 PlaybackThread 统一管理</span><br><span class="line">        mTracks.add(track);</span><br><span class="line"></span><br><span class="line">        // ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lStatus = NO_ERROR;</span><br><span class="line"></span><br><span class="line">Exit:</span><br><span class="line">    *status = lStatus;</span><br><span class="line">    return track;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ----------------------------------------------------------------------------</span><br><span class="line">// 如下是 TrackHandle 的相关代码，可以看到，TrackHandle 其实就是一个壳子，是 Track 的包装类</span><br><span class="line">// 所有 TrackHandle 接口都是调向 Track 的</span><br><span class="line">// Google 为什么要搞这么一则？Track 是 PlaybackThread 内部使用的，不适宜对外暴露，但应用进程</span><br><span class="line">// 又确实需要控制音频流的状态（start、stop、pause），所以就采取这么一种方式实现</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::TrackHandle(const sp&lt;AudioFlinger::PlaybackThread::Track&gt;&amp; track)</span><br><span class="line">    : BnAudioTrack(),</span><br><span class="line">      mTrack(track)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::TrackHandle::~TrackHandle() &#123;</span><br><span class="line">    // just stop the track on deletion, associated resources</span><br><span class="line">    // will be freed from the main thread once all pending buffers have</span><br><span class="line">    // been played. Unless it&apos;s not in the active track list, in which</span><br><span class="line">    // case we free everything now...</span><br><span class="line">    mTrack-&gt;destroy();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sp&lt;IMemory&gt; AudioFlinger::TrackHandle::getCblk() const &#123;</span><br><span class="line">    return mTrack-&gt;getCblk();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">status_t AudioFlinger::TrackHandle::start() &#123;</span><br><span class="line">    return mTrack-&gt;start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::stop() &#123;</span><br><span class="line">    mTrack-&gt;stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::flush() &#123;</span><br><span class="line">    mTrack-&gt;flush();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void AudioFlinger::TrackHandle::pause() &#123;</span><br><span class="line">    mTrack-&gt;pause();</span><br><span class="line">&#125;</span><br><span class="line">// ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>最后，我们看看 Track 的构造过程，主要分析数据 FIFO 及它的控制块是如何分配的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">AudioFlinger::PlaybackThread::Track::Track(</span><br><span class="line">            PlaybackThread *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">audio_stream_type_t</span> streamType,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;IMemory&gt;&amp; sharedBuffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> uid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   TrackBase(thread, client, sampleRate, format, channelMask, frameCount,</span><br><span class="line">                  (sharedBuffer != <span class="number">0</span>) ? sharedBuffer-&gt;pointer() : buffer,</span><br><span class="line">                  sessionId, uid, flags, <span class="literal">true</span> <span class="comment">/*isOut*/</span>,</span><br><span class="line">                  (type == TYPE_PATCH) ? ( buffer == <span class="literal">NULL</span> ? ALLOC_LOCAL : ALLOC_NONE) : ALLOC_CBLK,</span><br><span class="line">                  type),</span><br><span class="line">    mFillingUpStatus(FS_INVALID),</span><br><span class="line">    <span class="comment">// mRetryCount initialized later when needed</span></span><br><span class="line">    mSharedBuffer(sharedBuffer),</span><br><span class="line">    mStreamType(streamType),</span><br><span class="line">    mName(<span class="number">-1</span>),  <span class="comment">// see note below</span></span><br><span class="line">    mMainBuffer(thread-&gt;mixBuffer()),</span><br><span class="line">    mAuxBuffer(<span class="literal">NULL</span>),</span><br><span class="line">    mAuxEffectId(<span class="number">0</span>), mHasVolumeController(<span class="literal">false</span>),</span><br><span class="line">    mPresentationCompleteFrames(<span class="number">0</span>),</span><br><span class="line">    mFastIndex(<span class="number">-1</span>),</span><br><span class="line">    mCachedVolume(<span class="number">1.0</span>),</span><br><span class="line">    mIsInvalid(<span class="literal">false</span>),</span><br><span class="line">    mAudioTrackServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">    mResumeToStopping(<span class="literal">false</span>),</span><br><span class="line">    mFlushHwPending(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// client == 0 implies sharedBuffer == 0</span></span><br><span class="line">    ALOG_ASSERT(!(client == <span class="number">0</span> &amp;&amp; sharedBuffer != <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ALOGV_IF(sharedBuffer != <span class="number">0</span>, <span class="string">"sharedBuffer: %p, size: %d"</span>, sharedBuffer-&gt;pointer(),</span><br><span class="line">            sharedBuffer-&gt;size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 FIFO 控制块（audio_track_cblk_t）是否分配好了，上面代码并未分配 audio_track_cblk_t</span></span><br><span class="line">    <span class="comment">// 因此只可能是构造 TrackBase 时分配的，等下再看看 TrackBase 的构造函数</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sharedBuffer == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STREAM 模式，创建一个 AudioTrackServerProxy 对象</span></span><br><span class="line">        <span class="comment">// PlaybackThread 将持续使用它从 FIFO 上取得可读数据的位置</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> AudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize, !isExternalTrack(), sampleRate);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 数据传输模式为 MODE_STATIC 模式，创建一个 StaticAudioTrackServerProxy 对象</span></span><br><span class="line">        mAudioTrackServerProxy = <span class="keyword">new</span> StaticAudioTrackServerProxy(mCblk, mBuffer, frameCount,</span><br><span class="line">                mFrameSize);</span><br><span class="line">    &#125;</span><br><span class="line">    mServerProxy = mAudioTrackServerProxy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 Track 分配一个名称，AudioMixer 会根据 TrackName 找到对应的 Track</span></span><br><span class="line">    mName = thread-&gt;getTrackName_l(channelMask, format, sessionId);</span><br><span class="line">    <span class="keyword">if</span> (mName &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"no more track names available"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AudioFlinger::ThreadBase::TrackBase::TrackBase(</span><br><span class="line">            ThreadBase *thread,</span><br><span class="line">            <span class="keyword">const</span> sp&lt;Client&gt;&amp; client,</span><br><span class="line">            <span class="keyword">uint32_t</span> sampleRate,</span><br><span class="line">            <span class="keyword">audio_format_t</span> format,</span><br><span class="line">            <span class="keyword">audio_channel_mask_t</span> channelMask,</span><br><span class="line">            <span class="keyword">size_t</span> frameCount,</span><br><span class="line">            <span class="keyword">void</span> *buffer,</span><br><span class="line">            <span class="keyword">int</span> sessionId,</span><br><span class="line">            <span class="keyword">int</span> clientUid,</span><br><span class="line">            IAudioFlinger::<span class="keyword">track_flags_t</span> flags,</span><br><span class="line">            <span class="keyword">bool</span> isOut,</span><br><span class="line">            alloc_type alloc,</span><br><span class="line">            track_type type)</span><br><span class="line">    :   RefBase(),</span><br><span class="line">        mThread(thread),</span><br><span class="line">        mClient(client),</span><br><span class="line">        mCblk(<span class="literal">NULL</span>),</span><br><span class="line">        <span class="comment">// mBuffer</span></span><br><span class="line">        mState(IDLE),</span><br><span class="line">        mSampleRate(sampleRate),</span><br><span class="line">        mFormat(format),</span><br><span class="line">        mChannelMask(channelMask),</span><br><span class="line">        mChannelCount(isOut ?</span><br><span class="line">                audio_channel_count_from_out_mask(channelMask) :</span><br><span class="line">                audio_channel_count_from_in_mask(channelMask)),</span><br><span class="line">        mFrameSize(audio_is_linear_pcm(format) ?</span><br><span class="line">                mChannelCount * audio_bytes_per_sample(format) : <span class="keyword">sizeof</span>(<span class="keyword">int8_t</span>)),</span><br><span class="line">        mFrameCount(frameCount),</span><br><span class="line">        mSessionId(sessionId),</span><br><span class="line">        mFlags(flags),</span><br><span class="line">        mIsOut(isOut),</span><br><span class="line">        mServerProxy(<span class="literal">NULL</span>),</span><br><span class="line">        mId(android_atomic_inc(&amp;nextTrackId)),</span><br><span class="line">        mTerminated(<span class="literal">false</span>),</span><br><span class="line">        mType(type),</span><br><span class="line">        mThreadIoHandle(thread-&gt;id())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ALOGD("Creating track with %d buffers @ %d bytes", bufferCount, bufferSize);</span></span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">    <span class="keyword">size_t</span> bufferSize = (buffer == <span class="literal">NULL</span> ? roundup(frameCount) : frameCount) * mFrameSize;</span><br><span class="line">    <span class="keyword">if</span> (buffer == <span class="literal">NULL</span> &amp;&amp; alloc == ALLOC_CBLK) &#123;</span><br><span class="line">        <span class="comment">// 这个 size 将是分配的匿名共享内存的大小</span></span><br><span class="line">        <span class="comment">// 等于控制块的大小（sizeof(audio_track_cblk_t)加上数据 FIFO的大小（bufferSize）</span></span><br><span class="line">        <span class="comment">// 待会看到这块内存的结构，就明白这样分配的意义了</span></span><br><span class="line">        size += bufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块匿名共享内存</span></span><br><span class="line">        mCblkMemory = client-&gt;heap()-&gt;allocate(size);</span><br><span class="line">        <span class="keyword">if</span> (mCblkMemory == <span class="number">0</span> ||</span><br><span class="line">                (mCblk = <span class="keyword">static_cast</span>&lt;<span class="keyword">audio_track_cblk_t</span> *&gt;(mCblkMemory-&gt;pointer())) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"not enough memory for AudioTrack size=%u"</span>, size);</span><br><span class="line">            client-&gt;heap()-&gt;dump(<span class="string">"AudioTrack"</span>);</span><br><span class="line">            mCblkMemory.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// this syntax avoids calling the audio_track_cblk_t constructor twice</span></span><br><span class="line">        mCblk = (<span class="keyword">audio_track_cblk_t</span> *) <span class="keyword">new</span> <span class="keyword">uint8_t</span>[size];</span><br><span class="line">        <span class="comment">// assume mCblk != NULL</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the shared structure in-place.</span></span><br><span class="line">    <span class="keyword">if</span> (mCblk != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 这是 C++ 的 placement new（定位创建对象）语法：new(@BUFFER) @CLASS();</span></span><br><span class="line">        <span class="comment">// 可以在特定内存位置上构造一个对象</span></span><br><span class="line">        <span class="comment">// 这里，在匿名共享内存首地址上构造了一个 audio_track_cblk_t 对象</span></span><br><span class="line">        <span class="comment">// 这样 AudioTrack 与 AudioFlinger 都能访问这个 audio_track_cblk_t 对象了</span></span><br><span class="line">        <span class="keyword">new</span>(mCblk) <span class="keyword">audio_track_cblk_t</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如下分配数据 FIFO，将用于 AudioTrack 与 AudioFlinger 的数据交换</span></span><br><span class="line">        <span class="keyword">switch</span> (alloc) &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="keyword">case</span> ALLOC_CBLK:</span><br><span class="line">            <span class="comment">// clear all buffers</span></span><br><span class="line">            <span class="keyword">if</span> (buffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STREAM/TRANSFER_SYNC 时，数据 FIFO 的分配</span></span><br><span class="line">                <span class="comment">// 数据 FIFO 的首地址紧靠控制块（audio_track_cblk_t）之后</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   | -------------------&gt; mCblkMemory &lt;--------------------- |</span></span><br><span class="line">                <span class="comment">//   |                                                         |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |             Buffer                 |</span></span><br><span class="line">                <span class="comment">//   +--------------------+------------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                    ^</span></span><br><span class="line">                <span class="comment">//   |                    |</span></span><br><span class="line">                <span class="comment">//   mCblk               mBuffer</span></span><br><span class="line">                mBuffer = (<span class="keyword">char</span>*)mCblk + <span class="keyword">sizeof</span>(<span class="keyword">audio_track_cblk_t</span>);</span><br><span class="line">                <span class="built_in">memset</span>(mBuffer, <span class="number">0</span>, bufferSize);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 数据传输模式为 MODE_STATIC/TRANSFER_SHARED 时，直接指向 sharedBuffer</span></span><br><span class="line">                <span class="comment">// sharedBuffer 是应用进程分配的匿名共享内存，应用进程已经一次性把数据</span></span><br><span class="line">                <span class="comment">// 写到 sharedBuffer 来了，AudioFlinger 可以直接从这里读取</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   | audio_track_cblk_t |    |            sharedBuffer           |</span></span><br><span class="line">                <span class="comment">//   +--------------------+    +-----------------------------------+</span></span><br><span class="line">                <span class="comment">//   ^                         ^</span></span><br><span class="line">                <span class="comment">//   |                         |</span></span><br><span class="line">                <span class="comment">//   mCblk                    mBuffer</span></span><br><span class="line">                mBuffer = buffer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-AudioTrack-数据写入"><a href="#3-3-AudioTrack-数据写入" class="headerlink" title="3.3. AudioTrack 数据写入"></a>3.3. AudioTrack 数据写入</h5><p>AudioTrack 实例构造后，应用程序接着可以写入音频数据了。如之前所描述：AudioTrack 与 AudioFlinger 是 生产者-消费者 的关系：</p><p>☯ AudioTrack：AudioTrack 在 FIFO 中找到一块可用空间，把用户传入的音频数据写入到这块可用空间上，然后更新写位置（对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据了）；如果用户传入的数据量比可用空间要大，那么要把用户传入的数据拆分多次写入到 FIFO 中（AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地读取数据，所以 FIFO 可用空间是在不停变化的）<br>☯ AudioFlinger：AudioFlinger 在 FIFO 中找到一块可读数据块，把可读数据拷贝到目的缓冲区上，然后更新读位置（对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间了）；如果FIFO 上可读数据量比预期的要小，那么要进行多次的读取，才能积累到预期的数据量（AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地写入数据，所以 FIFO 可读的数据量是在不停变化的）<br>上面的过程中，如果 AudioTrack 总能及时生产数据，并且 AudioFlinger 总能及时消耗掉这些数据，那么整个过程将是非常和谐的；但系统可能会发生异常，出现如下的状态：</p><p>☯ Block：AudioFlinger 长时间不读取 FIFO 上的可读数据，使得 AudioTrack 长时间获取不到可用空间，无法写入数据；这种情况的根本原因大多是底层驱动发生阻塞异常，导致 AudioFlinger 无法继续写数据到硬件设备中，AudioFlinger 本身并没有错<br>☯ Underrun：AudioTrack 写入数据的速度跟不上 AudioFlinger 读取数据的速度，使得 AudioFlinger 不能及时获取到预期的数据量，反映到现实的后果就是声音断续；这种情况的根本原因大多是应用程序不能及时写入数据或者缓冲区分配过小，AudioTrack 本身并没有错；AudioFlinger 针对这点做了容错处理：当发现 underrun 时，先陷入短时间的睡眠，不急着读取数据，让应用程序准备更多的数据（如果某一天做应用的哥们意识到自己的错误原来由底层的兄弟默默埋单了，会不会感动得哭了^_^）</p><h5 id="3-3-1-AudioTrack-写数据流程"><a href="#3-3-1-AudioTrack-写数据流程" class="headerlink" title="3.3. 1. AudioTrack 写数据流程"></a>3.3. 1. AudioTrack 写数据流程</h5><p>我们看一下 AudioTrack 写数据的代码，流程很简单：obtainBuffer() 在 FIFO 中找到一块可用区间，memcpy() 把用户传入的音频数据拷贝到这个可用区间上，releaseBuffer() 更新写位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\media\libmedia\AudioTrack.cpp]</span><br><span class="line">ssize_t AudioTrack::write(const void* buffer, size_t userSize, bool blocking)</span><br><span class="line">&#123;</span><br><span class="line">    if (mTransfer != TRANSFER_SYNC) &#123;</span><br><span class="line">        return INVALID_OPERATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isDirect()) &#123;</span><br><span class="line">        AutoMutex lock(mLock);</span><br><span class="line">        int32_t flags = android_atomic_and(</span><br><span class="line">                            ~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END),</span><br><span class="line">                            &amp;mCblk-&gt;mFlags);</span><br><span class="line">        if (flags &amp; CBLK_INVALID) &#123;</span><br><span class="line">            return DEAD_OBJECT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ssize_t(userSize) &lt; 0 || (buffer == NULL &amp;&amp; userSize != 0)) &#123;</span><br><span class="line">        // Sanity-check: user is most-likely passing an error code, and it would</span><br><span class="line">        // make the return value ambiguous (actualSize vs error).</span><br><span class="line">        ALOGE(&quot;AudioTrack::write(buffer=%p, size=%zu (%zd)&quot;, buffer, userSize, userSize);</span><br><span class="line">        return BAD_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size_t written = 0;</span><br><span class="line">    Buffer audioBuffer;</span><br><span class="line"></span><br><span class="line">    while (userSize &gt;= mFrameSize) &#123;</span><br><span class="line">        // 单帧数据量 frameSize = channelCount * bytesPerSample</span><br><span class="line">        //   对于双声道，16位采样的音频数据来说，frameSize = 2 * 2 = 4(bytes)</span><br><span class="line">        // 用户传入的数据帧数 frameCount = userSize / frameSize</span><br><span class="line">        audioBuffer.frameCount = userSize / mFrameSize;</span><br><span class="line"></span><br><span class="line">        // obtainBuffer() 从 FIFO 上得到一块可用区间</span><br><span class="line">        status_t err = obtainBuffer(&amp;audioBuffer,</span><br><span class="line">                blocking ? &amp;ClientProxy::kForever : &amp;ClientProxy::kNonBlocking);</span><br><span class="line">        if (err &lt; 0) &#123;</span><br><span class="line">            if (written &gt; 0) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (err == TIMED_OUT || err == -EINTR) &#123;</span><br><span class="line">                err = WOULD_BLOCK;</span><br><span class="line">            &#125;</span><br><span class="line">            return ssize_t(err);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // toWrite 是 FIFO 可用区间的大小，可能比 userSize（用户传入数据的大小）要小</span><br><span class="line">        //   因此用户传入的数据可能要拆分多次拷贝到 FIFO 上</span><br><span class="line">        // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioFlinger 同时也在不停地</span><br><span class="line">        //   消耗数据，所以 FIFO 可用区间是在不停变化的</span><br><span class="line">        size_t toWrite = audioBuffer.size;</span><br><span class="line">        memcpy(audioBuffer.i8, buffer, toWrite); // 把用户数据拷贝到 FIFO 可用区间</span><br><span class="line">        buffer = ((const char *) buffer) + toWrite; // 未拷贝数据的位置</span><br><span class="line">        userSize -= toWrite; // 未拷贝数据的大小</span><br><span class="line">        written += toWrite; // 已拷贝数据的大小</span><br><span class="line"></span><br><span class="line">        // releaseBuffer() 更新 FIFO 写位置</span><br><span class="line">        // 对于 AudioFinger 来说，意味 FIFO 上有更多的可读数据</span><br><span class="line">        releaseBuffer(&amp;audioBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (written &gt; 0) &#123;</span><br><span class="line">        mFramesWritten += written / mFrameSize;</span><br><span class="line">    &#125;</span><br><span class="line">    return written;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-AudioFlinger-读数据流程"><a href="#3-3-2-AudioFlinger-读数据流程" class="headerlink" title="3.3. 2. AudioFlinger 读数据流程"></a>3.3. 2. AudioFlinger 读数据流程</h5><p>AudioFlinger 消费数据的流程稍微复杂一点，3.4. AudioFlinger 回放录制线程 小节中描述了 AudioFlinger::PlaybackThread::threadLoop() 工作流程，这里不累述了，我们把焦点放在“如何从 FIFO 读取数据”节点上。</p><p>我们以 DirectOutputThread/OffloadThread 为例说明（MixerThread 读数据也是类似的过程，只不过是在 AudioMixer 中进行的）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;\frameworks\av\services\audioflinger\AudioFlinger.cpp]</span><br><span class="line">void AudioFlinger::DirectOutputThread::threadLoop_mix()</span><br><span class="line">&#123;</span><br><span class="line">    // mFrameCount 是硬件设备（PCM 设备）处理单个数据块的帧数（周期大小）</span><br><span class="line">    //   上层必须积累了足够多（mFrameCount）的数据，才写入到 PCM 设备</span><br><span class="line">    //   所以 mFrameCount 也就是 AudioFlinger 预期的数据量</span><br><span class="line">    size_t frameCount = mFrameCount;</span><br><span class="line">    // mSinkBuffer 目的缓冲区，threadLoop_write() 会把 mSinkBuffer 上的数据写到 PCM 设备</span><br><span class="line">    int8_t *curBuf = (int8_t *)mSinkBuffer;</span><br><span class="line">    // output audio to hardware</span><br><span class="line">    // FIFO 上可读的数据量可能要比预期的要小，因此可能需要多次读取才能积累足够的数据量</span><br><span class="line">    // 注意：AudioTrack 和 AudioFlinger 是不同的进程，AudioTrack 同时也在不停地生产数据</span><br><span class="line">    //   所以 FIFO 可读的数据量是在不停变化的</span><br><span class="line">    while (frameCount) &#123;</span><br><span class="line">        AudioBufferProvider::Buffer buffer;</span><br><span class="line">        buffer.frameCount = frameCount;</span><br><span class="line">        // getNextBuffer() 从 FIFO 上获取可读数据块</span><br><span class="line">        status_t status = mActiveTrack-&gt;getNextBuffer(&amp;buffer);</span><br><span class="line">        if (status != NO_ERROR || buffer.raw == NULL) &#123;</span><br><span class="line">            memset(curBuf, 0, frameCount * mFrameSize);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // memcpy() 把 FIFO 可读数据拷贝到 mSinkBuffer 目的缓冲区</span><br><span class="line">        memcpy(curBuf, buffer.raw, buffer.frameCount * mFrameSize);</span><br><span class="line">        frameCount -= buffer.frameCount;</span><br><span class="line">        curBuf += buffer.frameCount * mFrameSize;</span><br><span class="line">        // releaseBuffer() 更新 FIFO 读位置</span><br><span class="line">        // 对于 AudioTrack 来说，意味着 FIFO 上有更多的可用空间</span><br><span class="line">        mActiveTrack-&gt;releaseBuffer(&amp;buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentWriteLength = curBuf - (int8_t *)mSinkBuffer;</span><br><span class="line">    mSleepTimeUs = 0;</span><br><span class="line">    mStandbyTimeNs = systemTime() + mStandbyDelayNs;</span><br><span class="line">    mActiveTrack.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-3-环形-FIFO-管理"><a href="#3-3-3-环形-FIFO-管理" class="headerlink" title="3.3. 3. 环形 FIFO 管理"></a>3.3. 3. 环形 FIFO 管理</h5><p>在上述过程中，不知大家有无意识到：整个过程中，最难的是如何协调生产者与消费者之间的步调。上文所说的 FIFO 是环形 FIFO，AudioTrack 写指针、AudioFlinger 读指针都是基于 FIFO 当前的读写位置来计算的。</p><p>☯AudioTrack 与 AudioFlinger 不在同一个进程上，怎么保证读写指针的线程安全<br>☯读写指针越过 FIFO 后，怎么处理<br>☯AudioTrack 写数据完成后，需要同步状态给 AudioFlinger，让 AudioFlinger 知道当前有可读数据了，而 AudioFlinger 读数据完成后，也需要同步状态给 AudioTrack，让 AudioTrack 知道当前有可用空间了；这里采取什么同步机制<br>我们回顾下创建 AudioTrack 对象时，FIFO 及其控制块的结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MODE_STREAM 模式下的匿名共享内存结构：</span><br><span class="line">  |                                                         |</span><br><span class="line">  | -------------------&gt; mCblkMemory &lt;--------------------- |</span><br><span class="line">  |                                                         |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  | audio_track_cblk_t |               FIFO                 |</span><br><span class="line">  +--------------------+------------------------------------+</span><br><span class="line">  ^                    ^</span><br><span class="line">  |                    |</span><br><span class="line">mCblk               mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = static_cast&lt;audio_track_cblk_t *&gt;(mCblkMemory-&gt;pointer());</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = (char*)mCblk + sizeof(audio_track_cblk_t);</span><br></pre></td></tr></table></figure><p>☯MODE_STATIC 模式下的匿名共享内存结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  | audio_track_cblk_t |    |         FIFO (sharedBuffer)       |</span><br><span class="line">  +--------------------+    +-----------------------------------+</span><br><span class="line">  ^                         ^</span><br><span class="line">  |                         |</span><br><span class="line">mCblk                    mBuffer</span><br><span class="line"></span><br><span class="line">mCblk = (audio_track_cblk_t *) new uint8_t[size];</span><br><span class="line">new(mCblk) audio_track_cblk_t();</span><br><span class="line">mBuffer = sharedBuffer-&gt;pointer()</span><br></pre></td></tr></table></figure><p>FIFO 管理相关的类图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/315-Audio-system-FIFO.jpg" alt="Alt text"></p><p>☯AudioTrackClientProxy：MODE_STREAM 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯AudioTrackServerProxy：MODE_STREAM 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯StaticAudioTrackClientProxy：MODE_STATIC 模式下，生产者 AudioTrack 使用它在 FIFO 中找到可用空间的位置<br>☯StaticAudioTrackServerProxy：MODE_STATIC 模式下，消费者 AudioFlinger::PlaybackThread 使用它在 FIFO 中找到可读数据的位置<br>☯AudioRecordClientProxy：消费者 AudioRecord 使用它在 FIFO 中找到可读数据的位置<br>☯AudioTrackServerProxy：生产者 AudioFlinger::RecordThread 使用它在 FIFO 中找到可用空间的位置<br>到这里，我决定结束本文了。环形 FIFO 管理是 Android 音频系统的精髓，一个小节并不足以描述其原理及实现细节；Android 环形 FIFO 的实现可说得上精妙绝伦，其他项目如果要用到环形 FIFO，不妨多借鉴它。</p><h4 id="四-、深入剖析MediaPlayer播放音频流程"><a href="#四-、深入剖析MediaPlayer播放音频流程" class="headerlink" title="(四)、深入剖析MediaPlayer播放音频流程"></a>(四)、深入剖析MediaPlayer播放音频流程</h4><p>时序图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/316-Audio-system-mediaplayer-playback.png" alt="Alt text"></p><h4 id="（五）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（五）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（五）、参考资料(特别感谢各位前辈的分析和图示)："></a>（五）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Audio System（2）：Linux ALSA音频系统分析</title>
    <link href="http://zhoujinjian.cc/2018/05/15/Audio%20System%EF%BC%882%EF%BC%89%EF%BC%9ALinux%20ALSA%E9%9F%B3%E9%A2%91%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/05/15/Audio System（2）：Linux ALSA音频系统分析/</id>
    <published>2018-05-14T16:00:00.000Z</published>
    <updated>2018-05-09T15:03:49.790Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p><a href="https://blog.csdn.net/zyuanyun" target="_blank" rel="noopener">【特别感谢 - 雲和山的彼端 - 音频系统分析】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><p>源码（主要源码路径）：</p><blockquote><p>User space audio code 源码：</p></blockquote><p>• <strong>/hardware/qcom/audio/hal/ – (Audio HAL 源码)</strong> </p><p>• <strong>/external/tinyalsa/ –  (tinymix, tinyplay, tinycap 源码)</strong></p><p>• <strong>/vendor/qcom/proprietary/mm-audio/ – (QTI OMX  audio encoder and decoders 源码，未公开)</strong></p><p>• <strong>/frameworks/av/media/audioserver/ – (Audioserver 源码)</strong></p><p>• <strong>/frameworks/av/media/libstagefright/ – (Google Stagefright 多媒体框架源码)</strong></p><p>• <strong>/frameworks/av/services/audioflinger/ – (Audioflinger 相关源码)</strong></p><p>• <strong>/external/bluetooth/bluedroid/ – (A2DP audio HAL 相关源码)</strong>/</p><p>• <strong>/hardware/libhardware/modules/usbaudio/ – (USB HAL 源码)</strong>/</p><p>• <strong>/vendor/qcom/proprietary/wfd/mm/source/framework/src/ – (Wi-Fi Display (WFD)、 WFDMMSourceAudioSource.cpp，未公开)</strong></p><p>• <strong>/system/core/include/system/ – (audio.h)</strong>/</p><blockquote><p>Kernel space audio code 源码：</p></blockquote><p>• <strong>/kernel/sound/soc/msm/ –  msm8996.c machine driver 源码 </strong></p><p>• <strong>/kernel/sound/soc/msm/qdsp6v2 –  platform drivers, front end (FE), and back-end (BE) DAI driver, Hexagon DSP drivers for AFE, ADM, and ASM, voice driver 相关源码</strong></p><p>• <strong>kernel/sound/soc/soc-<em>.c – All the SoC-</em>.c  ALSA SoCs framework 源码</strong></p><p>• <strong>kernel/drivers/slimbus/ –  SLIMbus driver 源码 </strong></p><p>• <strong>kernel/arch/arm/mach-msm/ – 包含比如 acpuclock-8996.c, board-8996-gpiomux.c, board-8996.c, and clock-8996.c related to the GPIO, clock, and board-specific information on the MSM8996 相关源码</strong></p><p>• <strong>/kernel/arch/arm/mach-msm/qdsp6v2/ – Contains the drivers for DSP-based encoders and decoders, code for the aDSP loader, APR driver, Ion memory driver, and other utility files</strong></p><p>• <strong>/kernel/arch/arm/boot/dts – Contains MSM8996-<em>.its and MSM8996-</em>.Dtsi files that contain MSM8996-specific information; audio-related customization is available in files such as MSM8996.dtsi, msm8996-mtp.dtsi, and msm8996-cdp.dtsi</strong></p><p>• <strong>/kernel/sound/soc/codecs/ – Contains the source code for the codec driver for WCD9335; codec driver-related source files are wcd9335.c, wcd9xxx-mbhc.c, wcd9xxx-resmgr.c, wcd9xxx-common.c, and so on.</strong></p><p>• <strong>/kernel/drivers/mfd/ – Contains the source code for the codec driver; wcd9xxx-core.c, wcd9xxx-slimslave.c, and wcd9xxx-irq.c are the codec driverrelated files</strong></p><h4 id="（一）-Overview"><a href="#（一）-Overview" class="headerlink" title="（一） Overview"></a>（一） Overview</h4><p>硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><p>Linux ALSA 音频系统架构大致如下：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/21-Audio-system-Android-Linux-ASoc-arc.png.png" alt="Alt text"></p><p>• Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>• ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>• ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>• ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>• Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><p>Platform：指某款 SoC 平台的音频模块，如 exynos、omap、qcom 等等。Platform 又可细分两部分：</p><p>  • cpu dai：在嵌入式系统里面通常指 SoC 的 I2S、PCM 总线控制器，负责把音频数据从 I2S tx FIFO 搬运到 CODEC（这是回放的情形，录制则方向相反）。cpu_dai 通过 <strong>snd_soc_register_dai()</strong> 来注册。注：DAI 是 Digital Audio Interface 的简称，分为 cpu_dai 和 codec_dai，这两者通过 I2S/PCM 总线连接；AIF 是 Audio Interface 的简称，嵌入式系统中一般是 I2S 和 PCM 接口。<br>  • pcm dma：负责把 dma buffer 中的音频数据搬运到 I2S tx FIFO。值得留意的是：某些情形下是不需要 dma 操作的，比如 Modem 和 CODEC 直连，因为 Modem 本身已经把数据送到 FIFO 了，这时只需启动 codec_dai 接收数据即可；该情形下，Machine 驱动 dai_link 中需要设定 .platform_name = “msm-pcm-xxx”。</p><p>Codec：对于回放来说，userspace 送过来的音频数据是经过采样量化的数字信号，在 codec 经过 DAC 转换成模拟信号然后输出到外放或耳机，这样我们就可以听到声音了。Codec 字面意思是编解码器，但芯片里面的功能部件很多，常见的有 AIF、DAC、ADC、Mixer、PGA、Line-in、Line-out，有些高端的 codec 芯片还有 EQ、DSP、SRC、DRC、AGC、Echo-Canceller、Noise-Suppression 等部件。</p><p>Machine：指某款机器，通过配置 dai_link 把 cpu_dai、codec_dai、modem_dai 各个音频接口给链结成一条条音频链路，然后注册 snd_soc_card。和上面两个不一样，Platform 和 CODEC 驱动一般是可以重用的，而 Machine 有它特定的硬件特性，几乎是不可重用的。所谓的硬件特性指：SoC Platform 与 Codec 的差异；DAIs 之间的链结方式；通过某个 GPIO 打开 Amplifier；通过某个 GPIO 检测耳机插拔；使用某个时钟如 MCLK/External-OSC 作为 I2S、CODEC 的时钟源等等。</p><p>从上面的描述来看，对于回放的情形，PCM 数据流向大致是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        copy_from_user           DMA                 I2S           DAC</span><br><span class="line">              ^                   ^                   ^             ^</span><br><span class="line">+---------+   |    +----------+   |   +-----------+   |   +-----+   |   +------+</span><br><span class="line">|userspace+--------&gt;DMA Buffer+-------&gt;I2S TX FIFO+-------&gt;CODEC+-------&gt;SPK/HP|</span><br><span class="line">+---------+        +----------+       +-----------+       +-----+       +------+</span><br></pre></td></tr></table></figure><p>几个音频物理链路的概念：</p><p>dai_link：machine 驱动中定义的音频数据链路，它指定链路用到的 codec、codec_dai、cpu_dai、platform。比如对于 WCD9335 平台的 media 链路：.codec_dai_name = “snd-soc-dummy-dai”, .codec_name = “snd-soc-dummy”, .cpu_dai_name = “MultiMediaX”, .platform_name = “msm-pcm-dsp.0”，这四者就构成了一条音频数据链路用于多媒体声音的回放和录制。一个系统可能有多个音频数据链路，比如 media 和 voice，因此可以定义多个 dai_link 。<br>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"MSM8996 Media1"</span>,</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-dsp.0"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/22-MSM8996-Linux-Android-Audio-ASoc-Architectre.png" alt="Alt text"></p><p>高通平台因DSP而存在特殊性，如上图，Frontend 链接 “Platform”，经由 “Platform”-&gt;Backend链接到Codec。<br>Front-end DAI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm-dai-fe.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">msm_fe_dais</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.playback = &#123;</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1 Playback"</span>,</span><br><span class="line">.aif_name = <span class="string">"MM_DL1"</span>,</span><br><span class="line">.rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">SNDRV_PCM_RATE_KNOT),</span><br><span class="line">.formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">8</span>,</span><br><span class="line">.rate_min =     <span class="number">8000</span>,</span><br><span class="line">.rate_max =<span class="number">192000</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.capture = &#123;</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1 Capture"</span>,</span><br><span class="line">.aif_name = <span class="string">"MM_UL1"</span>,</span><br><span class="line">.rates = (SNDRV_PCM_RATE_8000_192000|</span><br><span class="line">SNDRV_PCM_RATE_KNOT),</span><br><span class="line">.formats = (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">    SNDRV_PCM_FMTBIT_S24_LE|</span><br><span class="line">    SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">4</span>,</span><br><span class="line">.rate_min =     <span class="number">8000</span>,</span><br><span class="line">.rate_max =<span class="number">48000</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;msm_fe_Multimedia_dai_ops,</span><br><span class="line">.name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.probe = fe_dai_probe,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Back-end DAI：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_tasha_be_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* Backend DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = LPASS_BE_SLIMBUS_0_RX,</span><br><span class="line">.stream_name = <span class="string">"Slimbus Playback"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"msm-dai-q6-dev.16384"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-routing"</span>,</span><br><span class="line">.codec_name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"tasha_mix_rx1"</span>,</span><br><span class="line">.no_pcm = <span class="number">1</span>,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_BACKEND_DAI_SLIMBUS_0_RX,</span><br><span class="line">.init = &amp;msm_audrx_init,</span><br><span class="line">.be_hw_params_fixup = msm_slim_0_rx_be_hw_params_fixup,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">.ops = &amp;msm8996_be_ops,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> struct snd_soc_dai_link msm8996_tasha_fe_dai_links[] = &#123;</span><br><span class="line">&#123;</span><br><span class="line">.name = LPASS_BE_SLIMBUS_4_TX,</span><br><span class="line">.stream_name = <span class="string">"Slimbus4 Capture"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"msm-dai-q6-dev.16393"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-hostless"</span>,</span><br><span class="line">.codec_name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"tasha_vifeedback"</span>,</span><br><span class="line">.be_id = MSM_BACKEND_DAI_SLIMBUS_4_TX,</span><br><span class="line">.be_hw_params_fixup = msm_slim_4_tx_be_hw_params_fixup,</span><br><span class="line">.ops = &amp;msm8996_be_ops,</span><br><span class="line">.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hw constraints：指平台本身的硬件限制，如所能支持的通道数/采样率/数据格式、DMA 支持的数据周期大小（period size）、周期次数（period count）等，通过 snd_pcm_hardware 结构体描述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_hardware</span> <span class="title">msm_pcm_hardware_capture</span> = &#123;</span></span><br><span class="line">.info =                 (SNDRV_PCM_INFO_MMAP |</span><br><span class="line">SNDRV_PCM_INFO_BLOCK_TRANSFER |</span><br><span class="line">SNDRV_PCM_INFO_MMAP_VALID |</span><br><span class="line">SNDRV_PCM_INFO_INTERLEAVED |</span><br><span class="line">SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME),</span><br><span class="line">.formats =              (SNDRV_PCM_FMTBIT_S16_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_LE |</span><br><span class="line">SNDRV_PCM_FMTBIT_S24_3LE),</span><br><span class="line">.rates =                SNDRV_PCM_RATE_8000_48000,</span><br><span class="line">.rate_min =             <span class="number">8000</span>,</span><br><span class="line">.rate_max =             <span class="number">48000</span>,</span><br><span class="line">.channels_min =         <span class="number">1</span>,</span><br><span class="line">.channels_max =         <span class="number">4</span>,</span><br><span class="line">.buffer_bytes_max =     CAPTURE_MAX_NUM_PERIODS *</span><br><span class="line">CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">.period_bytes_min =CAPTURE_MIN_PERIOD_SIZE,</span><br><span class="line">.period_bytes_max =     CAPTURE_MAX_PERIOD_SIZE,</span><br><span class="line">.periods_min =          CAPTURE_MIN_NUM_PERIODS,</span><br><span class="line">.periods_max =          CAPTURE_MAX_NUM_PERIODS,</span><br><span class="line">.fifo_size =            <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>hw params：用户层设置的硬件参数，如 channels、sample rate、pcm format、period size、period count；这些参数受 hw constraints 约束。</p><p>sw params：用户层设置的软件参数，如 start threshold、stop threshold、silence threshold。</p><h4 id="（二）ASoC-Core"><a href="#（二）ASoC-Core" class="headerlink" title="（二）ASoC Core"></a>（二）ASoC Core</h4><p>ASoC：ALSA System on Chip，是建立在标准 ALSA 驱动之上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系，它依赖于标准 ALSA 驱动框架。内核文档 Documentation/alsa/soc/overview.txt 中详细介绍了 ASoC 的设计初衷，这里不一一引用，简单陈述如下：</p><p>• 独立的 codec 驱动，标准的 ALSA 驱动框架里面 codec 驱动往往与 SoC/CPU 耦合过于紧密，不利于在多样化的平台/机器上移植复用<br>• 方便 codec 与 SoC 通过 PCM/I2S 总线建立链接<br>• 动态音频电源管理 DAPM，使得 codec 任何时候都工作在最低功耗状态，同时负责音频路由的创建<br>• POPs 和 click 音抑制弱化处理，在 ASoC 中通过正确的音频部件上下电次序来实现<br>• Machine 驱动的特定控制，比如耳机、麦克风的插拔检测，外放功放的开关<br>在概述中已经介绍了 ASoC 硬件设备驱动的三大构成：Codec、Platform 和 Machine，下面列举各驱动的功能构成：</p><p>ASoC Codec Driver：</p><p>• Codec DAI 和 PCM 的配置信息<br>• Codec 的控制接口，如 I2C/SPI<br>• Mixer 和其他音频控件<br>• Codec 的音频接口函数，见 snd_soc_dai_ops 结构体定义<br>• DAPM 描述信息<br>• DAPM 事件处理句柄<br>• DAC 数字静音控制</p><p>ASoC Platform Driver： 包括 dma 和 cpu_dai 两部分：</p><p>• dma 驱动实现音频 dma 操作，具体见 snd_pcm_ops 结构体定义<br>• cpu_dai 驱动实现音频数字接口控制器的描述和配置<br>• ASoC Machine Driver：</p><p>作为链结 Platform 和 Codec 的载体，它必须配置 dai_link 为音频数据链路指定 Platform 和 Codec<br>处理机器特有的音频控件和音频事件，例如回放时打开外放功放<br>硬件设备驱动相关结构体：</p><p>• snd_soc_codec_driver：音频编解码芯片描述及操作函数，如控件/微件/音频路由的描述信息、时钟配置、IO 控制等<br>• snd_soc_dai_driver：音频数据接口描述及操作函数，根据 codec 端和 soc 端，分为 codec_dai 和 cpu_dai<br>• snd_soc_platform_driver：音频 dma 设备描述及操作函数<br>• snd_soc_dai_link：音频链路描述及板级操作函数</p><h4 id="（三）Codec-Driver"><a href="#（三）Codec-Driver" class="headerlink" title="（三）Codec Driver"></a>（三）Codec Driver</h4><p>基本是以内核文档 Documentation/sound/alsa/soc/codec.txt 中的内容为脉络来分析的。Codec 的作用，之前已有描述，本章主要罗列下 Codec driver 中重要的数据结构及注册流程。<br>其中有着各种功能部件，包括但不限于 ：</p><blockquote><p>ADC    把麦克风拾取的模拟信号转换成数字信号<br>DAC    把音频接口过来的数字信号转换成模拟信号<br>MIXER    混音器，把多路输入信号混合成单路输出</p></blockquote><h5 id="3-1-Codec-DAI-and-PCM-configuration"><a href="#3-1-Codec-DAI-and-PCM-configuration" class="headerlink" title="3.1. Codec DAI and PCM configuration"></a>3.1. Codec DAI and PCM configuration</h5><p>codec_dai 和 pcm 配置信息通过结构体 snd_soc_dai_driver 描述，包括 dai 的能力描述和操作接口，snd_soc_dai_driver 最终会被注册到 soc-core 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Digital Audio Interface Driver.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Describes the Digital Audio Interface in terms of its ALSA, DAI and AC97</span></span><br><span class="line"><span class="comment"> * operations and capabilities. Codec and platform drivers will register this</span></span><br><span class="line"><span class="comment"> * structure for every DAI they have.</span></span><br><span class="line"><span class="comment"> * This structure covers the clocking, formating and ALSA operations for each</span></span><br><span class="line"><span class="comment"> * interface.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> &#123;</span></span><br><span class="line">    <span class="comment">/* DAI description */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> ac97_control;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI driver callbacks */</span></span><br><span class="line">    <span class="keyword">int</span> (*probe)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*remove)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*suspend)(struct snd_soc_dai *dai);</span><br><span class="line">    <span class="keyword">int</span> (*resume)(struct snd_soc_dai *dai);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ops */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DAI capabilities */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">capture</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> <span class="title">playback</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* probe ordering - for components with runtime dependencies */</span></span><br><span class="line">    <span class="keyword">int</span> probe_order;</span><br><span class="line">    <span class="keyword">int</span> remove_order;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>name：codec_dai 的名称标识，dai_link 通过配置 codec_dai_name 来找到对应的 codec_dai；<br>probe：codec_dai 的初始化函数，注册声卡时回调；<br>playback：回放能力描述，如回放设备所支持的声道数、采样率、音频格式；<br>capture：录制能力描述，如录制设备所支持声道数、采样率、音频格式；<br>ops：codec_dai 的操作函数集，这些函数集非常重要，用于 dai 的时钟配置、格式配置、硬件参数配置。</p><p>codec_dai：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_driver</span> <span class="title">tasha_i2s_dai</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_i2s_rx1"</span>,</span><br><span class="line">.id = AIF1_PB,</span><br><span class="line">.playback = &#123;</span><br><span class="line">.stream_name = <span class="string">"AIF1 Playback"</span>,</span><br><span class="line">.rates = WCD9335_RATES_MASK,</span><br><span class="line">.formats = TASHA_FORMATS_S16_S24_LE,</span><br><span class="line">.rate_max = <span class="number">192000</span>,</span><br><span class="line">.rate_min = <span class="number">8000</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">2</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;tasha_dai_ops,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_i2s_tx1"</span>,</span><br><span class="line">.id = AIF1_CAP,</span><br><span class="line">.capture = &#123;</span><br><span class="line">.stream_name = <span class="string">"AIF1 Capture"</span>,</span><br><span class="line">.rates = WCD9335_RATES_MASK,</span><br><span class="line">.formats = TASHA_FORMATS,</span><br><span class="line">.rate_max = <span class="number">192000</span>,</span><br><span class="line">.rate_min = <span class="number">8000</span>,</span><br><span class="line">.channels_min = <span class="number">1</span>,</span><br><span class="line">.channels_max = <span class="number">4</span>,</span><br><span class="line">&#125;,</span><br><span class="line">.ops = &amp;tasha_dai_ops,</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="3-2-Codec-control-IO"><a href="#3-2-Codec-control-IO" class="headerlink" title="3.2. Codec control IO"></a>3.2. Codec control IO</h5><p>移动设备的音频 Codec，其控制接口一般是 I2C 或 SPI，控制接口用于读写 codec 的寄存器。在 snd_soc_codec_driver 结构体中，有如下字段描述 Codec 的控制接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="comment">/* codec driver */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec_driver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">/* codec IO */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regmap</span> *(*<span class="title">get_regmap</span>)(<span class="title">struct</span> <span class="title">device</span> *);</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*read)</span><span class="params">(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*write)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*display_register)(struct snd_soc_codec *, <span class="keyword">char</span> *,</span><br><span class="line"><span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*volatile_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*readable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> (*writable_register)(struct snd_soc_codec *, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> reg_cache_size;</span><br><span class="line"><span class="keyword">short</span> reg_cache_step;</span><br><span class="line"><span class="keyword">short</span> reg_word_size;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *reg_cache_default;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>• read：读寄存器；<br>• write：写寄存器；<br>• volatile_register：判断指定的寄存器是否是 volatile 属性；假如是，则读取寄存器时不是读 cache，而直接访问硬件；<br>• readable_register：判断指定的寄存器是否可读；<br>• reg_cache_default：寄存器的缺省值；<br>• reg_cache_size：缺省的寄存器值数组大小；<br>• reg_word_size：寄存器宽度。<br>在 Linux-3.4.5 中，很多 codec 的控制接口都改用 regmap 了。soc-core 中判断是否用的是 regmap，如果是，则调用 regmap 接口。</p><h5 id="3-3-Mixers-and-audio-controls"><a href="#3-3-Mixers-and-audio-controls" class="headerlink" title="3.3. Mixers and audio controls"></a>3.3. Mixers and audio controls</h5><p>音频控件多用于部件开关和音量的设定，音频控件可通过 soc.h 中的宏来定义，例如单一型控件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;   .iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">    .info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">    .put = snd_soc_put_volsw, \</span><br><span class="line">    .private_value =  SOC_SINGLE_VALUE(reg, shift, max, invert) &#125;</span><br></pre></td></tr></table></figure><p>这种控件只有一个设置量，一般用于部件开关。宏定义的参数说明：</p><p>• xname：控件的名称标识；<br>• reg：控件对应的寄存器地址；<br>• shift：控件控制位在寄存器中的偏移；<br>• max：控件设置值范围；<br>• invert：设定值是否取反。<br>其他类型控件类似，不一一介绍了。</p><p>上述只是宏定义，音频控件真正的结构是 snd_kcontrol_new：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line">    <span class="keyword">snd_ctl_elem_iface_t</span> iface; <span class="comment">/* interface identifier */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> device;        <span class="comment">/* device/client number */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;     <span class="comment">/* subdevice (substream) number */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;  <span class="comment">/* ASCII name of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;     <span class="comment">/* index of item */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> access;        <span class="comment">/* access rights */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count;     <span class="comment">/* count of same elements */</span></span><br><span class="line">    <span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line">    <span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line">    <span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">    &#125; tlv;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Codec 初始化时，通过 snd_soc_add_codec_controls() 把所有定义好的音频控件注册到 alsa-core ，上层可以通过 tinymix、alsa_amixer 等工具查看修改这些控件的设定。</p><h5 id="3-6-Codec-audio-operations"><a href="#3-6-Codec-audio-operations" class="headerlink" title="3.6. Codec audio operations"></a>3.6. Codec audio operations</h5><p>Codec 音频操作接口通过结构体 snd_soc_dai_ops 描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/soc-dai.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI clocking configuration, all optional.</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*set_sysclk)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">int</span> clk_id, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq, <span class="keyword">int</span> dir);</span><br><span class="line"><span class="keyword">int</span> (*set_pll)(struct snd_soc_dai *dai, <span class="keyword">int</span> pll_id, <span class="keyword">int</span> source,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> freq_in, <span class="keyword">unsigned</span> <span class="keyword">int</span> freq_out);</span><br><span class="line"><span class="keyword">int</span> (*set_clkdiv)(struct snd_soc_dai *dai, <span class="keyword">int</span> div_id, <span class="keyword">int</span> div);</span><br><span class="line"><span class="keyword">int</span> (*set_bclk_ratio)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> ratio);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * DAI format configuration</span></span><br><span class="line"><span class="comment"> * Called by soc_card drivers, normally in their hw_params.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> (*set_fmt)(struct snd_soc_dai *dai, <span class="keyword">unsigned</span> <span class="keyword">int</span> fmt);</span><br><span class="line"><span class="keyword">int</span> (*xlate_tdm_slot_mask)(<span class="keyword">unsigned</span> <span class="keyword">int</span> slots,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_mask);</span><br><span class="line"><span class="keyword">int</span> (*set_tdm_slot)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tx_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> rx_mask,</span><br><span class="line"><span class="keyword">int</span> slots, <span class="keyword">int</span> slot_width);</span><br><span class="line"><span class="keyword">int</span> (*set_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"><span class="keyword">int</span> (*set_tristate)(struct snd_soc_dai *dai, <span class="keyword">int</span> tristate);</span><br><span class="line"><span class="keyword">int</span> (*get_channel_map)(struct snd_soc_dai *dai,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *tx_slot,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_num, <span class="keyword">unsigned</span> <span class="keyword">int</span> *rx_slot);</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注释比较详细的了，Codec 音频操作接口分为 5 大部分：时钟配置、格式配置、数字静音、PCM 音频接口、FIFO 延迟。着重说下时钟配置及格式配置接口：</p><p>• set_sysclk：codec_dai 系统时钟设置，当上层打开 pcm 设备时，需要回调该接口设置 Codec 的系统时钟，Codec 才能正常工作；<br>• set_pll：Codec FLL 设置，Codec 一般接了一个 MCLK 输入时钟，回调该接口基于 MCLK 来产生 Codec FLL 时钟，接着 codec_dai 的 sysclk、bclk、lrclk 均可从 FLL 分频出来（假设 Codec 作为 master）；<br>• set_fmt：codec_dai 格式设置，具体见 soc-dai.h；<br>  • SND_SOC_DAIFMT_I2S：音频数据是 I2S 格式，常用于多媒体音频；<br>  • SND_SOC_DAIFMT_DSP_A：音频数据是 PCM 格式，常用于通话语音；<br>  • SND_SOC_DAIFMT_CBM_CFM：Codec 作为 master，BCLK 和 LRCLK 由 Codec 提供；<br>  • SND_SOC_DAIFMT_CBS_CFS：Codec 作为 slave，BCLK 和 LRCLK 由 SoC/CPU 提供；<br>• hw_params：codec_dai 硬件参数设置，根据上层设定的声道数、采样率、数据格式，来配置 codec_dai 相关寄存器。</p><p>WCD9335的snd_soc_dai_ops ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_ops</span> <span class="title">tasha_dai_ops</span> = &#123;</span></span><br><span class="line">.startup = tasha_startup,</span><br><span class="line">.shutdown = tasha_shutdown,</span><br><span class="line">.hw_params = tasha_hw_params,</span><br><span class="line">.prepare = tasha_prepare,</span><br><span class="line">.set_sysclk = tasha_set_dai_sysclk,</span><br><span class="line">.set_fmt = tasha_set_dai_fmt,</span><br><span class="line">.set_channel_map = tasha_set_channel_map,</span><br><span class="line">.get_channel_map = tasha_get_channel_map,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h5 id="3-6-Codec-register"><a href="#3-6-Codec-register" class="headerlink" title="3.6. Codec register"></a>3.6. Codec register</h5><p>当 platform_driver：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">tasha_codec_driver</span> = &#123;</span></span><br><span class="line">.probe = tasha_probe,</span><br><span class="line">.remove = tasha_remove,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">.pm = &amp;tasha_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与.name = “tasha_codec”  的 platform_device（该 platform_device 在 drivers/mfd/wcd9xxx-core.c 中注册wcd9xxx_device_init-&gt;wcd9xxx_check_codec_type-&gt;tasha_devs）匹配后，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/mfd/wcd9xxx-core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mfd_cell</span> <span class="title">tasha_devs</span>[] = &#123;</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"tasha_codec"</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>立即回调 tasha_probe() 注册 Codec：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tasha_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasha_priv</span> *<span class="title">tasha</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">wcd_ext_clk</span>, *<span class="title">wcd_native_clk</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_resmgr_v2</span> *<span class="title">resmgr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wcd9xxx_power_region</span> *<span class="title">cdc_pwr</span>;</span></span><br><span class="line">......</span><br><span class="line">tasha = devm_kzalloc(&amp;pdev-&gt;dev, <span class="keyword">sizeof</span>(struct tasha_priv),</span><br><span class="line">    GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line">    tasha-&gt;resmgr = resmgr;</span><br><span class="line">tasha-&gt;swr_plat_data.handle = (<span class="keyword">void</span> *) tasha;</span><br><span class="line">tasha-&gt;swr_plat_data.read = tasha_swrm_read;</span><br><span class="line">tasha-&gt;swr_plat_data.write = tasha_swrm_write;</span><br><span class="line">tasha-&gt;swr_plat_data.bulk_write = tasha_swrm_bulk_write;</span><br><span class="line">tasha-&gt;swr_plat_data.clk = tasha_swrm_clock;</span><br><span class="line">tasha-&gt;swr_plat_data.handle_irq = tasha_swrm_handle_irq;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register for Clock */</span></span><br><span class="line">wcd_ext_clk = clk_get(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">"wcd_clk"</span>);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(wcd_ext_clk)) &#123;</span><br><span class="line">dev_err(tasha-&gt;wcd9xxx-&gt;dev, <span class="string">"%s: clk get %s failed\n"</span>,</span><br><span class="line">__func__, <span class="string">"wcd_ext_clk"</span>);</span><br><span class="line"><span class="keyword">goto</span> err_clk;</span><br><span class="line">&#125;</span><br><span class="line">tasha-&gt;wcd_ext_clk = wcd_ext_clk;</span><br><span class="line">tasha-&gt;sido_voltage = SIDO_VOLTAGE_NOMINAL_MV;</span><br><span class="line">set_bit(AUDIO_NOMINAL, &amp;tasha-&gt;status_mask);</span><br><span class="line">tasha-&gt;sido_ccl_cnt = <span class="number">0</span>;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_SLIMBUS)</span><br><span class="line">ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">     tasha_dai, ARRAY_SIZE(tasha_dai));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wcd9xxx_get_intf_type() == WCD9XXX_INTERFACE_TYPE_I2C)</span><br><span class="line">ret = snd_soc_register_codec(&amp;pdev-&gt;dev, &amp;soc_codec_dev_tasha,</span><br><span class="line">     tasha_i2s_dai,</span><br><span class="line">     ARRAY_SIZE(tasha_i2s_dai));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = -EINVAL;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snd_soc_register_codec：将 codec_driver 和 codec_dai_driver 注册到 soc-core。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snd_soc_register_codec - Register a codec with the ASoC core</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @codec: codec to register</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_register_codec</span><span class="params">(struct device *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">const</span> struct snd_soc_codec_driver *codec_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               struct snd_soc_dai_driver *dai_drv,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> num_dai)</span></span></span><br></pre></td></tr></table></figure><p>创建一个 snd_soc_codec 实例，包含 codec_drv（snd_soc_dai_driver）相关信息，封装给 soc-core 使用，相关代码段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"></span><br><span class="line">    dev_dbg(dev, <span class="string">"codec register %s\n"</span>, dev_name(dev));</span><br><span class="line"></span><br><span class="line">    codec = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_codec), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create CODEC component name */</span></span><br><span class="line">    codec-&gt;name = fmt_single_name(dev, &amp;codec-&gt;id);</span><br><span class="line">    <span class="keyword">if</span> (codec-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        kfree(codec);</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 Codec 的寄存器缓存配置及读写接口</span></span><br><span class="line">    codec-&gt;write = codec_drv-&gt;write;</span><br><span class="line">    codec-&gt;read = codec_drv-&gt;read;</span><br><span class="line">    codec-&gt;volatile_register = codec_drv-&gt;volatile_register;</span><br><span class="line">    codec-&gt;readable_register = codec_drv-&gt;readable_register;</span><br><span class="line">    codec-&gt;writable_register = codec_drv-&gt;writable_register;</span><br><span class="line">    codec-&gt;ignore_pmdown_time = codec_drv-&gt;ignore_pmdown_time;</span><br><span class="line">    codec-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;</span><br><span class="line">    codec-&gt;dapm.dev = dev;</span><br><span class="line">    codec-&gt;dapm.codec = codec;</span><br><span class="line">    codec-&gt;dapm.seq_notifier = codec_drv-&gt;seq_notifier;</span><br><span class="line">    codec-&gt;dapm.stream_event = codec_drv-&gt;stream_event;</span><br><span class="line">    codec-&gt;dev = dev;</span><br><span class="line">    codec-&gt;driver = codec_drv;</span><br><span class="line">    codec-&gt;num_dai = num_dai;</span><br><span class="line">    mutex_init(&amp;codec-&gt;mutex);</span><br></pre></td></tr></table></figure><p>把以上 codec 实例插入到 codec_list链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec 并绑定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;codec-&gt;<span class="built_in">list</span>, &amp;codec_list);</span><br></pre></td></tr></table></figure><p>把 codec_drv 中的 snd_soc_dai_driver（tasha_dai 或者tasha_i2s_dai ）注册到 soc-core：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">snd_soc_register_dais(&amp;codec-&gt;component, dai_drv, num_dai, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>snd_soc_register_dais() 会把 dai 插入到 dai_list 链表中（声卡注册时会遍历该链表，找到 dai_link 声明的 codec_dai 并绑定）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c: snd_soc_register_codec]</span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;dai_list);</span><br></pre></td></tr></table></figure><p>最后顺便提下 codec 和 codec_dai 的区别：codec 指音频芯片共有的部分，包括 codec 初始化函数、控制接口、寄存器缓存、控件、dapm 部件、音频路由、偏置电压设置函数等描述信息；而 codec_dai 指 codec 上的音频接口驱动描述，包括时钟配置、格式配置、能力描述等等，各个接口的描述信息不一定都是一致的，所以每个音频接口都有着各自的驱动描述。</p><h4 id="（四）Platform-Driver"><a href="#（四）Platform-Driver" class="headerlink" title="（四）Platform Driver"></a>（四）Platform Driver</h4><p>概述中提到音频 Platform 驱动主要用于音频数据传输，这里又细分为两步：</p><p>启动 dma 设备，把音频数据从 dma buffer 搬运到 cpu_dai FIFO，这部分驱动用 snd_soc_platform_driver 描述，后面分析用 pcm_dma 指代它。<br>启动数字音频接口控制器（I2S/PCM/AC97），把音频数据从 cpu_dai FIFO 传送到 codec_dai（高通平台会将数据传送到ADSP）这部分驱动用 snd_soc_dai_driver 描述，后面分析用 cpu_dai 指代它。</p><blockquote><p>MSM8996 包含三个 Hexagon DSP ：application, modem, and sensor。<br>Application  DSP：不仅可以处理语音和音频，还可以处理计算机 视觉、视频、图像和Camera。<br> Sensor DSP：也叫做SLPI，所有的sensor都链接到SLPI上面，它管理所有的Sensor及相关算法。</p></blockquote><p>对于 cpu_dai 驱动，从上面的类图我们可知，主要工作有：</p><p>实现 dai 操作函数，见 snd_soc_dai_ops 定义，用于配置和操作音频数字接口控制器，如时钟配置 set_sysclk()、格式配置 set_fmt()、硬件参数配置 hw_params()、启动/停止数据传输 trigger() 等；<br>实现 probe 函数（初始化）、remove 函数（卸载）、suspend/resume 函数（电源管理）；<br>初始化 snd_soc_dai_driver 实例，包括回放和录制的能力描述、dai 操作函数集、probe/remove 回调、电源管理相关的 suspend/resume 回调；<br>通过 snd_soc_register_dai() 把初始化完成的 snd_soc_dai_driver 注册到 soc-core：首先创建一个 snd_soc_dai 实例，然后把该 snd_soc_dai 实例插入到 dai_list 链表（声卡注册时会遍历该链表，找到 dai_link 声明的 cpu_dai 并绑定）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[sound/soc/soc-core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_register_dais</span><span class="params">(struct snd_soc_component *component,</span></span></span><br><span class="line"><span class="function"><span class="params">struct snd_soc_dai_driver *dai_drv, <span class="keyword">size_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">bool</span> legacy_dai_naming)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">component</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">dai</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">dev_dbg(dev, <span class="string">"ASoC: dai register %s #%Zu\n"</span>, dev_name(dev), count);</span><br><span class="line"></span><br><span class="line">component-&gt;dai_drv = dai_drv;</span><br><span class="line">component-&gt;num_dai = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"></span><br><span class="line">dai = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dai), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; legacy_dai_naming) &#123;</span><br><span class="line">dai-&gt;name = fmt_single_name(dev, &amp;dai-&gt;id);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dai-&gt;name = fmt_multiple_name(dev, &amp;dai_drv[i]);</span><br><span class="line"><span class="keyword">if</span> (dai_drv[i].id)</span><br><span class="line">dai-&gt;id = dai_drv[i].id;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dai-&gt;id = i;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">dai-&gt;component = component;</span><br><span class="line">dai-&gt;dev = dev;</span><br><span class="line">dai-&gt;driver = &amp;dai_drv[i];</span><br><span class="line"><span class="keyword">if</span> (!dai-&gt;driver-&gt;ops)</span><br><span class="line">dai-&gt;driver-&gt;ops = &amp;null_dai_ops;</span><br><span class="line"></span><br><span class="line">list_add(&amp;dai-&gt;<span class="built_in">list</span>, &amp;component-&gt;dai_list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dai 操作函数的实现是 cpu_dai 驱动的主体，需要配置好相关寄存器让 I2S/PCM 总线控制器正常运转，snd_soc_dai_ops 字段的详细说明见 3.6. Codec audio operations 章节。</p><p>cpu_dai 驱动应该算是这个系列中最简单的一环，因此不多花费笔墨在这里了。倒是某些平台上，dma 设备信息（总线地址、通道号、传输单元大小）是在这里初始化的，这点要留意，这些 dma 设备信息在 pcm_dma 驱动中用到。</p><h5 id="4-1-pcm-operations"><a href="#4-1-pcm-operations" class="headerlink" title="4.1. pcm operations"></a>4.1. pcm operations</h5><p>操作函数的实现是本模块的主体，见 snd_pcm_ops 结构体描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;include/sound/pcm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm_ops</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> (*open)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*close)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*ioctl)(struct snd_pcm_substream * substream,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">int</span> (*compat_ioctl)(struct snd_pcm_substream *substream,</span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">int</span> (*hw_params)(struct snd_pcm_substream *substream,</span><br><span class="line"> struct snd_pcm_hw_params *params);</span><br><span class="line"><span class="keyword">int</span> (*hw_free)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*prepare)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*trigger)(struct snd_pcm_substream *substream, <span class="keyword">int</span> cmd);</span><br><span class="line"><span class="keyword">snd_pcm_uframes_t</span> (*pointer)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*delay_blk)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*wall_clock)(struct snd_pcm_substream *substream,</span><br><span class="line">  struct timespec *audio_ts);</span><br><span class="line"><span class="keyword">int</span> (*copy)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">    <span class="keyword">snd_pcm_uframes_t</span> pos,</span><br><span class="line">    <span class="keyword">void</span> __user *buf, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line"><span class="keyword">int</span> (*silence)(struct snd_pcm_substream *substream, <span class="keyword">int</span> channel,</span><br><span class="line">       <span class="keyword">snd_pcm_uframes_t</span> pos, <span class="keyword">snd_pcm_uframes_t</span> count);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *(*<span class="title">page</span>)(<span class="title">struct</span> <span class="title">snd_pcm_substream</span> *<span class="title">substream</span>,</span></span><br><span class="line"><span class="class">     <span class="title">unsigned</span> <span class="title">long</span> <span class="title">offset</span>);</span></span><br><span class="line"><span class="keyword">int</span> (*mmap)(struct snd_pcm_substream *substream, struct vm_area_struct *vma);</span><br><span class="line"><span class="keyword">int</span> (*ack)(struct snd_pcm_substream *substream);</span><br><span class="line"><span class="keyword">int</span> (*restart)(struct snd_pcm_substream *substream);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-1-platform-driver-注册"><a href="#4-1-platform-driver-注册" class="headerlink" title="4.1. platform_driver 注册"></a>4.1. platform_driver 注册</h5><p>当 platform_driver：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">msm_pcm_driver</span> = &#123;</span></span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">"msm-pcm-dsp"</span>,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.of_match_table = msm_pcm_dt_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = msm_pcm_probe,</span><br><span class="line">.remove = msm_pcm_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与 .name = “msm-pcm-dsp” 的 platform_device 注册 匹配后，系统会回调 msm_pcm_probe() 注册 platform：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm_pcm_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_plat_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *latency_level;</span><br><span class="line"></span><br><span class="line">rc = of_property_read_u32(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,msm-pcm-dsp-id"</span>, &amp;id);</span><br><span class="line">......</span><br><span class="line">pdata = kzalloc(<span class="keyword">sizeof</span>(struct msm_plat_data), GFP_KERNEL);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (of_property_read_bool(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,msm-pcm-low-latency"</span>)) &#123;</span><br><span class="line">pdata-&gt;perf_mode = LOW_LATENCY_PCM_MODE;</span><br><span class="line">rc = of_property_read_string(pdev-&gt;dev.of_node,</span><br><span class="line"><span class="string">"qcom,latency-level"</span>, &amp;latency_level);</span><br><span class="line"><span class="keyword">if</span> (!rc) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">"ultra"</span>))</span><br><span class="line">pdata-&gt;perf_mode = ULTRA_LOW_LATENCY_PCM_MODE;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(latency_level, <span class="string">"ull-pp"</span>))</span><br><span class="line">pdata-&gt;perf_mode =</span><br><span class="line">ULL_POST_PROCESSING_PCM_MODE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pdata-&gt;perf_mode = LEGACY_PCM_MODE;</span><br><span class="line"></span><br><span class="line">dev_set_drvdata(&amp;pdev-&gt;dev, pdata);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> snd_soc_register_platform(&amp;pdev-&gt;dev,</span><br><span class="line">   &amp;msm_soc_platform);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>snd_soc_register_platform：将 platform_drv 注册到 soc-core。<br>创建一个 snd_soc_platform 实例，包含 platform_drv（snd_soc_platform_driver）的相关信息，封装给 soc-core 使用；<br>把以上创建的 platform 实例插入到 platform_list 链表上（声卡注册时会遍历该链表，找到 dai_link 声明的 platform 并绑定）。<br>代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int snd_soc_register_platform(struct device *dev,</span><br><span class="line">const struct snd_soc_platform_driver *platform_drv)</span><br><span class="line">&#123;</span><br><span class="line">struct snd_soc_platform *platform;</span><br><span class="line">int ret;</span><br><span class="line"></span><br><span class="line">platform = kzalloc(sizeof(struct snd_soc_platform), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">ret = snd_soc_add_platform(dev, platform, platform_drv);</span><br><span class="line"></span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，完成了 Platform 驱动的实现。回放情形下，pcm_dma 设备负责把 dma buffer 中的数据搬运到 I2S tx FIFO，I2S 总线控制器负责把 I2S tx FIFO 中的数据传送DSP，DSP经处理后传送到到 Codec。</p><h4 id="（五）-Machine-Driver"><a href="#（五）-Machine-Driver" class="headerlink" title="（五）  Machine Driver"></a>（五）  Machine Driver</h4><p>章节 3. Codec 和 4. Platform 介绍了 Codec、Platform 驱动，但仅有 Codec、Platform 驱动是不能工作的，需要一个角色把 codec、codec_dai、cpu_dai、platform 给链结起来才能构成一个完整的音频链路，这个角色就由 machine_drv 承担了。</p><p>snd_soc_dai_link 结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* Codec name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *stream_name;<span class="comment">/* Stream name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpu_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">cpu_of_node</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cpu_dai_name;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *codec_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">codec_of_node</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *codec_dai_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link_component</span> *<span class="title">codecs</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> num_codecs;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *platform_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">platform_of_node</span>;</span></span><br><span class="line"><span class="keyword">int</span> be_id;<span class="comment">/* optional ID for machine driver BE identification */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dai_fmt;           <span class="comment">/* format to set on init */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dpcm_trigger trigger[<span class="number">2</span>]; <span class="comment">/* trigger type for DPCM */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_suspend:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_rates:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_channels:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> symmetric_samplebits:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> no_pcm:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dynamic:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> no_host_mode:<span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_capture:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dpcm_playback:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ignore_pmdown_time:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> (*init)(struct snd_soc_pcm_runtime *rtd);</span><br><span class="line"><span class="keyword">int</span> (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *rtd,</span><br><span class="line">struct snd_pcm_hw_params *params);</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_compr_ops</span> *<span class="title">compr_ops</span>;</span></span><br><span class="line"><span class="keyword">bool</span> playback_only;</span><br><span class="line"><span class="keyword">bool</span> capture_only;</span><br><span class="line"><span class="keyword">enum</span> snd_soc_async_ops async_ops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点介绍如下几个字段：</p><p>• codec_name：音频链路需要绑定的 codec 名称，声卡注册时会遍历 codec_list，找到同名的 codec 并绑定；<br>• platform_name：音频链路需要绑定的 platform 名称，声卡注册时会遍历 platform_list，找到同名的 platform 并绑定；<br>• cpu_dai_name：音频链路需要绑定的 cpu_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>• codec_dai_name：音频链路需要绑定的 codec_dai 名称，声卡注册时会遍历 dai_list，找到同名的 dai 并绑定；<br>ops：重点留意 hw_params() 回调，一般来说这个回调是要实现的，用于配置 codec、codec_dai、cpu_dai 的数据格式和系统时钟。在 3.6. Codec audio operations 小节中有描述。<br>/sound/soc/msm/msm8996.c 中的 dai_link 定义，两个音频链路分别用于 Media和 Voice：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="comment">/* Digital audio interface glue - connects codec &lt;---&gt; CPU */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai_link</span> <span class="title">msm8996_common_dai_links</span>[] = &#123;</span></span><br><span class="line"><span class="comment">/* FrontEnd DAI Links */</span></span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"MSM8996 Media1"</span>,</span><br><span class="line">.stream_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"MultiMedia1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-dsp.0"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.async_ops = ASYNC_DPCM_SND_SOC_PREPARE,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line"><span class="comment">/* this dainlink has playback support */</span></span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_MULTIMEDIA1</span><br><span class="line">&#125;,</span><br><span class="line">......</span><br><span class="line">&#123;</span><br><span class="line">.name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.stream_name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.cpu_dai_name = <span class="string">"VoiceMMode1"</span>,</span><br><span class="line">.platform_name = <span class="string">"msm-pcm-voice"</span>,</span><br><span class="line">.dynamic = <span class="number">1</span>,</span><br><span class="line">.dpcm_playback = <span class="number">1</span>,</span><br><span class="line">.dpcm_capture = <span class="number">1</span>,</span><br><span class="line">.trigger = &#123;SND_SOC_DPCM_TRIGGER_POST,</span><br><span class="line">    SND_SOC_DPCM_TRIGGER_POST&#125;,</span><br><span class="line">.no_host_mode = SND_SOC_DAI_LINK_NO_HOST,</span><br><span class="line">.ignore_suspend = <span class="number">1</span>,</span><br><span class="line">.ignore_pmdown_time = <span class="number">1</span>,</span><br><span class="line">.codec_dai_name = <span class="string">"snd-soc-dummy-dai"</span>,</span><br><span class="line">.codec_name = <span class="string">"snd-soc-dummy"</span>,</span><br><span class="line">.be_id = MSM_FRONTEND_DAI_VOICEMMODE1,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 dai_link，机器中一些特定的音频控件和音频事件也可以在 machine_drv 定义，如耳机插拔检测、外部功放打开关闭等。</p><p>我们再分析 machine_drv 初始化过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line">static struct platform_driver msm8996_asoc_machine_driver = &#123;</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = DRV_NAME,</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.pm = &amp;snd_soc_pm_ops,</span><br><span class="line">.of_match_table = msm8996_asoc_machine_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">.probe = msm8996_asoc_machine_probe,</span><br><span class="line">.remove = msm8996_asoc_machine_remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/msm/msm8996.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">msm8996_asoc_machine_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_card</span> *<span class="title">card</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm8996_asoc_mach_data</span> *<span class="title">pdata</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *mbhc_audio_jack_type = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *mclk_freq_prop_name;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> *<span class="title">match</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line">    ......</span><br><span class="line">pdata = devm_kzalloc(&amp;pdev-&gt;dev,</span><br><span class="line"><span class="keyword">sizeof</span>(struct msm8996_asoc_mach_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">card = populate_snd_card_dailinks(&amp;pdev-&gt;dev);</span><br><span class="line">......</span><br><span class="line">match = of_match_node(msm8996_asoc_machine_of_match,</span><br><span class="line">pdev-&gt;dev.of_node);</span><br><span class="line">ret = msm8996_populate_dai_link_component_of_node(card);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">ret = snd_soc_register_card(card);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置dailinks后，继而调用 snd_soc_register_card() 注册声卡。由于该过程很冗长，这里不一一贴代码分析了，但整个流程是比较简单的，流程图如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/23-Audio-system-msm8996-probe-snd-card-register.png" alt="Alt text"></p><p>• 取出 platform_device 的私有数据，该私有数据就是 snd_soc_card ；<br>• snd_soc_register_card() 为每个 dai_link 分配一个 snd_soc_pcm_runtime 实例，别忘了之前提过 snd_soc_pcm_runtime 是 ASoC 的桥梁，保存着 codec、codec_dai、cpu_dai、platform 等硬件设备实例。<br>• 随后的工作都在 snd_soc_instantiate_card() 进行：<br>• 遍历 dai_list、codec_list、platform_list 链表，为每个音频链路找到对应的 cpu_dai、codec_dai、codec、platform；找到的 cpu_dai、codec_dai、codec、platform 保存到 snd_soc_pcm_runtime ，完成音频链路的设备绑定；<br>• 调用 snd_card_create() 创建声卡；<br>• soc_probe_dai_link() 依次回调 cpu_dai、codec、platform、codec_dai 的 probe() 函数，完成各音频设备的初始化，随后调用<br>• soc_new_pcm() 创建 pcm 逻辑设备（因为涉及到本系列的重点内容，后面具体分析这个函数）；<br>最后调用 snd_card_register() 注册声卡。</p><p>[-&gt;sound/soc/soc-core.c]</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/24-Audio-system-msm8996-probe-snd-card.png" alt="Alt text"></p><p>soc_new_pcm 源码分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-pcm.c]</span><br><span class="line"><span class="comment">/* create a new pcm */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">soc_new_pcm</span><span class="params">(struct snd_soc_pcm_runtime *rtd, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_platform</span> *<span class="title">platform</span> = <span class="title">rtd</span>-&gt;<span class="title">platform</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">codec_dai</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dai</span> *<span class="title">cpu_dai</span> = <span class="title">rtd</span>-&gt;<span class="title">cpu_dai</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_pcm</span> *<span class="title">pcm</span>;</span></span><br><span class="line"><span class="keyword">char</span> new_name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>, playback = <span class="number">0</span>, capture = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic || rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line">playback = rtd-&gt;dai_link-&gt;dpcm_playback;</span><br><span class="line">capture = rtd-&gt;dai_link-&gt;dpcm_capture;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; rtd-&gt;num_codecs; i++) &#123;</span><br><span class="line">codec_dai = rtd-&gt;codec_dais[i];</span><br><span class="line"><span class="keyword">if</span> (codec_dai-&gt;driver-&gt;playback.channels_min)</span><br><span class="line">playback = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (codec_dai-&gt;driver-&gt;capture.channels_min)</span><br><span class="line">capture = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span><br><span class="line">playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;playback_only) &#123;</span><br><span class="line">playback = <span class="number">1</span>;</span><br><span class="line">capture = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;capture_only) &#123;</span><br><span class="line">playback = <span class="number">0</span>;</span><br><span class="line">capture = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create the PCM */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"(%s)"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"></span><br><span class="line">ret = snd_pcm_new_internal(rtd-&gt;card-&gt;snd_card, new_name, num,</span><br><span class="line">playback, capture, &amp;pcm);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic)</span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"%s (*)"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">snprintf</span>(new_name, <span class="keyword">sizeof</span>(new_name), <span class="string">"%s %s-%d"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;stream_name,</span><br><span class="line">(rtd-&gt;num_codecs &gt; <span class="number">1</span>) ?</span><br><span class="line"><span class="string">"multicodec"</span> : rtd-&gt;codec_dai-&gt;name, num);</span><br><span class="line"></span><br><span class="line">ret = snd_pcm_new(rtd-&gt;card-&gt;snd_card, new_name, num, playback,</span><br><span class="line">capture, &amp;pcm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(rtd-&gt;card-&gt;dev, <span class="string">"ASoC: can't create pcm for %s\n"</span>,</span><br><span class="line">rtd-&gt;dai_link-&gt;name);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">dev_dbg(rtd-&gt;card-&gt;dev, <span class="string">"ASoC: registered pcm #%d %s\n"</span>,num, new_name);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DAPM dai link stream work */</span></span><br><span class="line">INIT_DELAYED_WORK(&amp;rtd-&gt;delayed_work, close_delayed_work);</span><br><span class="line"></span><br><span class="line">rtd-&gt;pcm = pcm;</span><br><span class="line">pcm-&gt;private_data = rtd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_pcm) &#123;</span><br><span class="line"><span class="keyword">if</span> (playback)</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;private_data = rtd;</span><br><span class="line"><span class="keyword">if</span> (capture)</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;private_data = rtd;</span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new)</span><br><span class="line">rtd-&gt;platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setup any hostless PCMs - i.e. no host IO is performed */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;no_host_mode) &#123;</span><br><span class="line"><span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream) &#123;</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">snd_soc_set_runtime_hwparams(</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_PLAYBACK].substream,</span><br><span class="line">&amp;no_host_hardware);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream) &#123;</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream-&gt;hw_no_buffer = <span class="number">1</span>;</span><br><span class="line">snd_soc_set_runtime_hwparams(</span><br><span class="line">pcm-&gt;streams[SNDRV_PCM_STREAM_CAPTURE].substream,</span><br><span class="line">&amp;no_host_hardware);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ASoC PCM operations */</span></span><br><span class="line"><span class="keyword">if</span> (rtd-&gt;dai_link-&gt;dynamic) &#123;</span><br><span class="line">rtd-&gt;ops.open= dpcm_fe_dai_open;</span><br><span class="line">rtd-&gt;ops.hw_params= dpcm_fe_dai_hw_params;</span><br><span class="line">rtd-&gt;ops.prepare= dpcm_fe_dai_prepare;</span><br><span class="line">rtd-&gt;ops.trigger= dpcm_fe_dai_trigger;</span><br><span class="line">rtd-&gt;ops.hw_free= dpcm_fe_dai_hw_free;</span><br><span class="line">rtd-&gt;ops.close= dpcm_fe_dai_close;</span><br><span class="line">rtd-&gt;ops.pointer= soc_pcm_pointer;</span><br><span class="line">rtd-&gt;ops.delay_blk= soc_pcm_delay_blk;</span><br><span class="line">rtd-&gt;ops.ioctl= soc_pcm_ioctl;</span><br><span class="line">rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rtd-&gt;ops.open= soc_pcm_open;</span><br><span class="line">rtd-&gt;ops.hw_params= soc_pcm_hw_params;</span><br><span class="line">rtd-&gt;ops.prepare= soc_pcm_prepare;</span><br><span class="line">rtd-&gt;ops.trigger= soc_pcm_trigger;</span><br><span class="line">rtd-&gt;ops.hw_free= soc_pcm_hw_free;</span><br><span class="line">rtd-&gt;ops.close= soc_pcm_close;</span><br><span class="line">rtd-&gt;ops.pointer= soc_pcm_pointer;</span><br><span class="line">rtd-&gt;ops.delay_blk= soc_pcm_delay_blk;</span><br><span class="line">rtd-&gt;ops.ioctl= soc_pcm_ioctl;</span><br><span class="line">rtd-&gt;ops.compat_ioctl   = soc_pcm_compat_ioctl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;ops) &#123;</span><br><span class="line">rtd-&gt;ops.ack= platform-&gt;driver-&gt;ops-&gt;ack;</span><br><span class="line">rtd-&gt;ops.copy= platform-&gt;driver-&gt;ops-&gt;copy;</span><br><span class="line">rtd-&gt;ops.silence= platform-&gt;driver-&gt;ops-&gt;silence;</span><br><span class="line">rtd-&gt;ops.page= platform-&gt;driver-&gt;ops-&gt;page;</span><br><span class="line">rtd-&gt;ops.mmap= platform-&gt;driver-&gt;ops-&gt;mmap;</span><br><span class="line">rtd-&gt;ops.restart= platform-&gt;driver-&gt;ops-&gt;restart;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (playback)</span><br><span class="line">snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (capture)</span><br><span class="line">snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &amp;rtd-&gt;ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (platform-&gt;driver-&gt;pcm_new) &#123;</span><br><span class="line">ret = platform-&gt;driver-&gt;pcm_new(rtd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">dev_err(platform-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: pcm constructor failed: %d\n"</span>,</span><br><span class="line">ret);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pcm-&gt;private_free = platform-&gt;driver-&gt;pcm_free;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 soc_new_pcm() 最主要的工作是创建 pcm 逻辑设备，创建回放子流和录制子流实例，并初始化回放子流和录制子流的 pcm 操作函数（数据搬运时，需要调用这些函数来驱动 codec、codec_dai、cpu_dai、dma 设备工作）。</p><h4 id="（六）、声卡和-PCM-设备的建立过程"><a href="#（六）、声卡和-PCM-设备的建立过程" class="headerlink" title="（六）、声卡和 PCM 设备的建立过程"></a>（六）、声卡和 PCM 设备的建立过程</h4><p>前面几章分析了 Codec、Platform、Machine 驱动的组成部分及其注册过程，这三者都是物理设备相关的，大家应该对音频物理链路有了一定的认知。接着分析音频驱动的中间层，由于这些并不是真正的物理设备，故我们称之为逻辑设备。</p><p>PCM 逻辑设备，我们又习惯称之为 PCM 中间层或 pcm native，起着承上启下的作用：往上是与用户态接口的交互，实现音频数据在用户态和内核态之间的拷贝；往下是触发 codec、platform、machine 的操作函数，实现音频数据在 dma_buffer &lt;-&gt; cpu_dai &lt;-&gt; codec 之间的传输。后面章节将会详细分析这个过程，这里还是先从声卡的注册谈起。<br>声卡驱动中，一般挂载着多个逻辑设备，看看我们计算机的声卡驱动有几个逻辑设备：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat /proc/asound/devices </span><br><span class="line">  2: [ 0]   : control</span><br><span class="line">  3: [ 0- 0]: digital audio playback</span><br><span class="line">  4: [ 0- 0]: digital audio capture</span><br><span class="line">  5: [ 0- 1]: digital audio playback</span><br><span class="line">  6: [ 0- 1]: digital audio capture</span><br><span class="line"> ......</span><br><span class="line"> 27: [ 0-16]: digital audio playback</span><br><span class="line"> 28: [ 0-16]: digital audio capture</span><br><span class="line"> 29: [ 0-17]: digital audio playback</span><br><span class="line"> 30: [ 0-17]: digital audio capture</span><br><span class="line"> 33:        : timer</span><br></pre></td></tr></table></figure><blockquote><p>digital audio playback    用于回放的 PCM 设备<br>digital audio capture    用于录制的 PCM 设备<br>control    用于声卡控制的 CTL 设备，如通路控制、音量调整等<br>timer    定时器设备<br>手机系统中，通常我们更关心 PCM 和 CTL 这两种设备。</p></blockquote><p>设备节点如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">adb shell ls -l /dev/snd</span><br><span class="line">crw-rw---- 1 system audio 116,  51 1970-06-19 02:07 comprC0D24</span><br><span class="line">crw-rw---- 1 system audio 116,  52 1970-06-19 02:07 comprC0D27</span><br><span class="line">crw-rw---- 1 system audio 116,  53 1970-06-19 02:07 comprC0D28</span><br><span class="line">......</span><br><span class="line">crw-rw---- 1 system audio 116,   2 1970-06-19 02:07 controlC0</span><br><span class="line">crw-rw---- 1 system audio 116,  59 1970-06-19 02:07 hwC0D1000</span><br><span class="line">crw-rw---- 1 system audio 116,  66 1970-06-19 02:07 hwC0D11</span><br><span class="line">crw-rw---- 1 system audio 116,  67 1970-06-19 02:07 hwC0D12</span><br><span class="line">crw-rw---- 1 system audio 116,  76 1970-06-19 02:07 hwC0D13</span><br><span class="line">......</span><br><span class="line">crw-rw---- 1 system audio 116,  13 1970-06-19 02:07 pcmC0D6c</span><br><span class="line">crw-rw---- 1 system audio 116,  14 1970-06-19 02:07 pcmC0D7p</span><br><span class="line">crw-rw---- 1 system audio 116,  15 1970-06-19 02:07 pcmC0D8c</span><br><span class="line">crw-rw---- 1 system audio 116,  33 1970-06-19 02:07 timer</span><br></pre></td></tr></table></figure><p>可以看到这些设备节点的 Major=116，Minor 则与 /proc/asound/devices 所列的对应起来，都是字符设备。上层可以通过 open/close/read/write/ioctl 等系统调用来操作声卡设备，这和其他字符设备类似，但一般情况下我们会使用已封装好的用户接口库如 tinyalsa、alsa-lib。</p><h5 id="6-1-声卡结构概述"><a href="#6-1-声卡结构概述" class="headerlink" title="6.1. 声卡结构概述"></a>6.1. 声卡结构概述</h5><p>回顾下 ASoC 是如何注册声卡的，详细请参考章节 5. ASoC machine driver，这里仅简单陈述下：</p><p>• Machine 驱动初始化时，.name = “soc-audio” 的 platform_device 与 platform_driver 匹配成功，触发 soc_probe() 调用；<br>• 继而调用 snd_soc_register_card()：<br>  ﹋• 为每个音频物理链路找到对应的 codec、codec_dai、cpu_dai、platform 设备实例，完成 dai_link 的绑定；<br>  ﹋ • 调用 snd_card_create() 创建声卡；<br>  ﹋ • 依次回调 cpu_dai、codec、platform 的 probe() 函数，完成物理设备的初始化；<br>• 随后调用 soc_new_pcm()：<br>  ﹋ • 设置 pcm native 中要使用的 pcm 操作函数，这些函数用于驱动音频物理设备，包括 machine、codec_dai、cpu_dai、platform；<br>  ﹋ • 调用 snd_pcm_new() 创建 pcm 逻辑设备，回放子流和录制子流都在这里创建；<br>  ﹋ • 回调 platform 驱动的 pcm_new()，完成音频 dma 设备初始化和 dma buffer 内存分配；<br>• 最后调用 snd_card_register() 注册声卡。<br>关于音频物理设备部分（Codec/Platform/Machine）不再累述，下面详细分析声卡和 PCM 逻辑设备的注册过程。</p><p>上面提到声卡驱动上挂着多个逻辑子设备，有 pcm 音频数据流、control 混音器、midi 迷笛、timer 定时器等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                  +-----------+</span><br><span class="line">                  | snd_card  |</span><br><span class="line">                  +-----------+</span><br><span class="line">                    |   |   |</span><br><span class="line">        +-----------+   |   +------------+</span><br><span class="line">        |               |                |</span><br><span class="line">+-----------+    +-----------+    +-----------+</span><br><span class="line"> |  snd_pcm  |    |snd_control|    | snd_timer |    ...</span><br><span class="line"> +-----------+    +-----------+    +-----------+</span><br></pre></td></tr></table></figure><p>这些与声音相关的逻辑设备都在结构体 snd_card 管理之下，可以说 snd_card 是 alsa 中最顶层的结构。我们再看看 alsa 声卡驱动的大致结构图（不是严格的 UML 类图，有结构体定义、模块关系、函数调用，方便标示结构模块的层次及关系）：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/25-Audio-system-snd-card-uml.png" alt="Alt text"></p><p>snd_cards：记录着所注册的声卡实例，每个声卡实例有着各自的逻辑设备，如 PCM 设备、CTL 设备、MIDI 设备等，并一一记录到 snd_card 的 devices 链表上<br>snd_minors：记录着所有逻辑设备的上下文信息，它是声卡逻辑设备与系统调用 API 之间的桥梁；每个 snd_minor 在逻辑设备注册时被填充，在逻辑设备使用时就可以从该结构体中得到相应的信息（主要是系统调用函数集 file_operations）</p><h5 id="6-2-声卡的创建snd-card-create"><a href="#6-2-声卡的创建snd-card-create" class="headerlink" title="6.2. 声卡的创建snd_card_create()"></a>6.2. 声卡的创建snd_card_create()</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;sound/core/init.c]</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  snd_card_new - create and initialize a soundcard structure</span></span><br><span class="line"><span class="comment"> *  @parent: the parent device object</span></span><br><span class="line"><span class="comment"> *  @idx: card index (address) [0 ... (SNDRV_CARDS-1)]</span></span><br><span class="line"><span class="comment"> *  @xid: card identification (ASCII string)</span></span><br><span class="line"><span class="comment"> *  @module: top level module for locking</span></span><br><span class="line"><span class="comment"> *  @extra_size: allocate this extra size after the main soundcard structure</span></span><br><span class="line"><span class="comment"> *  @card_ret: the pointer to store the created card instance</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Creates and initializes a soundcard structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  The function allocates snd_card instance via kzalloc with the given</span></span><br><span class="line"><span class="comment"> *  space for the driver to use freely.  The allocated struct is stored</span></span><br><span class="line"><span class="comment"> *  in the given card_ret pointer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Return: Zero if successful or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_card_new</span><span class="params">(struct device *parent, <span class="keyword">int</span> idx, <span class="keyword">const</span> <span class="keyword">char</span> *xid,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct <span class="keyword">module</span> *<span class="keyword">module</span>, <span class="keyword">int</span> extra_size,</span></span></span><br><span class="line"><span class="function"><span class="params">    struct snd_card **card_ret)</span></span></span><br></pre></td></tr></table></figure><p>注释非常详细，简单说下：<br>idx：声卡的编号，如为 -1，则由系统自动分配<br>xid：声卡标识符，如为 NULL，则以 snd_card 的 shortname 或 longname 代替<br>card_ret：返回所创建的声卡实例的指针<br>如下是Google Pixel手机的声卡信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">sailfish:/ $ cat /proc/asound/cards</span><br><span class="line"> 0 [msm8996tashamar]: msm8996-tasha-m - msm8996-tasha-marlin-snd-card</span><br><span class="line">                      msm8996-tasha-marlin-snd-card</span><br></pre></td></tr></table></figure></p><h5 id="6-3-逻辑设备的创建"><a href="#6-3-逻辑设备的创建" class="headerlink" title="6.3. 逻辑设备的创建"></a>6.3. 逻辑设备的创建</h5><p>当声卡实例建立后，接着可以创建声卡下面的各个逻辑设备了。每个逻辑设备创建时，都会调用 snd_device_new() 生成一个 snd_device 实例，并把该实例挂到声卡 snd_card 的 devices 链表上。alsa 驱动为各种逻辑设备提供了创建接口，如下：</p><blockquote><p>PCM    snd_pcm_new()<br>CONTROL    snd_ctl_create()<br>MIDI    snd_rawmidi_new()<br>TIMER    snd_timer_new()<br>SEQUENCER    snd_seq_device_new()<br>JACK    snd_jack_new()</p></blockquote><p>这些接口的一般过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_xxx_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这些接口供逻辑设备注册时回调</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_device_ops</span> <span class="title">ops</span> = &#123;</span></span><br><span class="line">        .dev_free = snd_xxx_dev_free,</span><br><span class="line">        .dev_register = snd_xxx_dev_register,</span><br><span class="line">        .dev_disconnect = snd_xxx_dev_disconnect,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑设备实例初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个设备实例 snd_device，挂到 snd_card 的 devices 链表上，把该逻辑设备纳入声卡的管理当中，SNDRV_DEV_xxx 是逻辑设备的类型</span></span><br><span class="line">    <span class="keyword">return</span> snd_device_new(card, SNDRV_DEV_xxx, card, &amp;ops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 snd_device_ops 是声卡逻辑设备的注册函数集，dev_register() 回调尤其重要，它在声卡注册时被调用，用于建立系统的设备节点，/dev/snd/ 目录的设备节点都是在这里创建的，通过这些设备节点可系统调用 open/release/read/write/ioctl… 访问操作该逻辑设备。</p><p>例如 snd_ctl_dev_register()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/control.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">snd_ctl_f_ops</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">.owner =THIS_MODULE,</span><br><span class="line">.read =snd_ctl_read,</span><br><span class="line">.open =snd_ctl_open,</span><br><span class="line">.release =snd_ctl_release,</span><br><span class="line">.llseek =no_llseek,</span><br><span class="line">.poll =snd_ctl_poll,</span><br><span class="line">.unlocked_ioctl =snd_ctl_ioctl,</span><br><span class="line">.compat_ioctl =snd_ctl_ioctl_compat,</span><br><span class="line">.fasync =snd_ctl_fasync,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * registration of the control device</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_ctl_dev_register</span><span class="params">(struct snd_device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_card</span> *<span class="title">card</span> = <span class="title">device</span>-&gt;<span class="title">device_data</span>;</span></span><br><span class="line"><span class="keyword">int</span> err, cardnum;</span><br><span class="line"><span class="keyword">char</span> name[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_BUG_ON(!card))</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line">cardnum = card-&gt;number;</span><br><span class="line"><span class="keyword">if</span> (snd_BUG_ON(cardnum &lt; <span class="number">0</span> || cardnum &gt;= SNDRV_CARDS))</span><br><span class="line"><span class="keyword">return</span> -ENXIO;</span><br><span class="line"><span class="built_in">sprintf</span>(name, <span class="string">"controlC%i"</span>, cardnum);</span><br><span class="line"><span class="keyword">if</span> ((err = snd_register_device(SNDRV_DEVICE_TYPE_CONTROL, card, <span class="number">-1</span>,</span><br><span class="line">       &amp;snd_ctl_f_ops, card, name)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实是调用 snd_register_device_for_dev ()：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/core/sound.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_register_device_for_dev</span><span class="params">(<span class="keyword">int</span> type, struct snd_card *card, <span class="keyword">int</span> dev,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct file_operations *f_ops,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *private_data,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name, struct device *device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> minor;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_minor</span> *<span class="title">preg</span>;</span></span><br><span class="line">preg = kmalloc(<span class="keyword">sizeof</span> *preg, GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">preg-&gt;type = type;</span><br><span class="line">preg-&gt;card = card ? card-&gt;number : <span class="number">-1</span>;</span><br><span class="line">preg-&gt;device = dev;</span><br><span class="line">preg-&gt;f_ops = f_ops;</span><br><span class="line">preg-&gt;private_data = private_data;</span><br><span class="line">preg-&gt;card_ptr = card;</span><br><span class="line">mutex_lock(&amp;sound_mutex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SND_DYNAMIC_MINORS</span></span><br><span class="line">minor = snd_find_free_minor(type);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">minor = snd_kernel_minor(type, card, dev);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">......</span><br><span class="line">snd_minors[minor] = preg;</span><br><span class="line">preg-&gt;dev = device_create(sound_class, device, MKDEV(major, minor),</span><br><span class="line">  private_data, <span class="string">"%s"</span>, name);</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;sound_mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配并初始化一个 snd_minor 实例；<br>保存该 snd_minor 实例到 snd_minors 数组中；<br>调用 device_create() 生成设备文件节点。</p><p>上面过程是声卡注册时才被回调的。</p><h5 id="6-4-声卡的注册"><a href="#6-4-声卡的注册" class="headerlink" title="6.4. 声卡的注册"></a>6.4. 声卡的注册</h5><p>当声卡下的所有逻辑设备都已经准备就绪后，就可以调用 snd_card_register() 注册声卡了：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/26-Audio-system-snd-card-register.png.png" alt="Alt text"></p><p>• 创建声卡的 sysfs 设备；<br>• 调用 snd_device_register_all() 注册所有挂在该声卡下的逻辑设备；<br>• 建立 proc 信息文件和 sysfs 属性文件。</p><h4 id="（七）、DAPM分析"><a href="#（七）、DAPM分析" class="headerlink" title="（七）、DAPM分析"></a>（七）、DAPM分析</h4><h5 id="7-1、DAPM简介"><a href="#7-1、DAPM简介" class="headerlink" title="7.1、DAPM简介"></a>7.1、DAPM简介</h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><p>DAPM是基于kcontrol改进过后的相应框架，增加了相应的电源管理机制，其电源管理机制其实就是按照相应的音频路径，完美的对各种部件的电源进行控制，而且按照某种顺序进行。</p><h5 id="7-1、kcontrol"><a href="#7-1、kcontrol" class="headerlink" title="7.1、kcontrol"></a>7.1、kcontrol</h5><p>通常，一个kcontrol代表着一个mixer（混音器），或者是一个mux（多路开关），又或者是一个音量控制器等等。 从上述文章中我们知道，定义一个kcontrol主要就是定义一个snd_kcontrol_new 结构，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/control.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> &#123;</span></span><br><span class="line"><span class="keyword">snd_ctl_elem_iface_t</span> iface;<span class="comment">/* interface identifier */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> device;<span class="comment">/* device/client number */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> subdevice;<span class="comment">/* subdevice (substream) number */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *name;<span class="comment">/* ASCII name of item */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> index;<span class="comment">/* index of item */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> access;<span class="comment">/* access rights */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> count;<span class="comment">/* count of same elements */</span></span><br><span class="line"><span class="keyword">snd_kcontrol_info_t</span> *info;</span><br><span class="line"><span class="keyword">snd_kcontrol_get_t</span> *get;</span><br><span class="line"><span class="keyword">snd_kcontrol_put_t</span> *put;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="keyword">snd_kcontrol_tlv_rw_t</span> *c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *p;</span><br><span class="line">&#125; tlv;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> private_value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每个控件，我们需要定义一个和他对应的snd_kcontrol_new结构，这些snd_kcontrol_new结构会在声卡的初始化阶段，通过snd_soc_dapm_new_controls()函数注册到系统中，用户空间就可以通过tinymix查看和设定这些控件的状态。<br>编译/external/tinyalsa/得到tinymix, tinyplay, tinycap，Push到手机执行tinymix可得到如下类似信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">990BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia10    Off</span><br><span class="line">991BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia11    Off</span><br><span class="line">992BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia12    Off</span><br><span class="line">993BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia13    Off</span><br><span class="line">994BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia14    Off</span><br><span class="line">995BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia15    Off</span><br><span class="line">996BOOL1QUAT_MI2S_RX Audio Mixer MultiMedia16    Off</span><br><span class="line">997BOOL1MI2S_RX Audio Mixer MultiMedia1          Off</span><br><span class="line">998BOOL1MI2S_RX Audio Mixer MultiMedia2          Off</span><br><span class="line">999BOOL1MI2S_RX Audio Mixer MultiMedia3          Off</span><br><span class="line">1000BOOL1MI2S_RX Audio Mixer MultiMedia4          Off</span><br><span class="line">1001BOOL1MI2S_RX Audio Mixer MultiMedia5          Off</span><br><span class="line">1002BOOL1MI2S_RX Audio Mixer MultiMedia6          Off</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>snd_kcontrol_new结构中，几个主要的字段是get，put，private_value，get回调函数用于获取该控件当前的状态值，而put回调函数则用于设置控件的状态值，而private_value字段则根据不同的控件类型有不同的意义，比如对于普通的控件，private_value字段可以用来定义该控件所对应的寄存器的地址以及对应的控制位在寄存器中的位置信息。值得庆幸的是，ASoc系统已经为我们准备了大量的宏定义，用于定义常用的控件，这些宏定义位于include/sound/soc.h中。下面我们分别讨论一下如何用这些预设的宏定义来定义一些常用的控件。</p><h5 id="7-1-1、简单型的控件"><a href="#7-1-1、简单型的控件" class="headerlink" title="7.1.1、简单型的控件"></a>7.1.1、简单型的控件</h5><p>SOC_SINGLE    SOC_SINGLE应该算是最简单的控件了，这种控件只有一个控制量，比如一个开关，或者是一个数值变量（比如Codec中某个频率，FIFO大小等等）。我们看看这个宏是如何定义的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE(xname, reg, shift, max, invert) \</span></span><br><span class="line">&#123;.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">.put = snd_soc_put_volsw, \</span><br><span class="line">.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure></p><p>宏定义的参数分别是：xname（该控件的名字），reg（该控件对应的寄存器的地址），shift（控制位在寄存器中的位移），max（控件可设置的最大值），invert（设定值是否逻辑取反）。这里又使用了一个宏来定义private_value字段：SOC_SINGLE_VALUE，我们看看它的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_DOUBLE_VALUE(xreg, shift_left, shift_right, xmax, xinvert, xautodisable) \</span></span><br><span class="line">((<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;(struct soc_mixer_control) \</span><br><span class="line">&#123;.reg = xreg, .rreg = xreg, .shift = shift_left, \</span><br><span class="line">.rshift = shift_right, .max = xmax, .platform_max = xmax, \</span><br><span class="line">.invert = xinvert, .autodisable = xautodisable&#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_VALUE(xreg, xshift, xmax, xinvert, xautodisable) \</span></span><br><span class="line">SOC_DOUBLE_VALUE(xreg, xshift, xshift, xmax, xinvert, xautodisable)</span><br></pre></td></tr></table></figure><p>这里实际上是定义了一个soc_mixer_control结构，然后把该结构的地址赋值给了private_value字段，soc_mixer_control结构是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* mixer control */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_mixer_control</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> min, max, platform_max;</span><br><span class="line"><span class="keyword">int</span> reg, rreg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shift, rshift;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> sign_bit;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> invert:<span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> autodisable:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看来soc_mixer_control是控件特征的真正描述者，它确定了该控件对应寄存器的地址，位移值，最大值和是否逻辑取反等特性，控件的put回调函数和get回调函数需要借助该结构来访问实际的寄存器。<br><strong>SOC_SINGLE_TLV</strong>    <strong>SOC_SINGLE_TLV</strong>是SOC_SINGLE的一种扩展，主要用于定义那些有增益控制的控件，例如音量控制器，EQ均衡器等等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array) \</span></span><br><span class="line">&#123;.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \</span><br><span class="line">.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ |\</span><br><span class="line"> SNDRV_CTL_ELEM_ACCESS_READWRITE,\</span><br><span class="line">.tlv.p = (tlv_array), \</span><br><span class="line">.info = snd_soc_info_volsw, .get = snd_soc_get_volsw,\</span><br><span class="line">.put = snd_soc_put_volsw, \</span><br><span class="line">.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, <span class="number">0</span>) &#125;</span><br></pre></td></tr></table></figure><p>从他的定义可以看出，用于设定寄存器信息的private_value字段的定义和SOC_SINGLE是一样的，甚至put、get回调函数也是使用同一套，唯一不同的是增加了一个tlv_array参数，并把它赋值给了tlv.p字段。用户空间可以通过对声卡的control设备发起以下两种ioctl来访问tlv字段所指向的数组：<br>  •  SNDRV_CTL_IOCTL_TLV_READ<br>  •  SNDRV_CTL_IOCTL_TLV_WRITE<br>  •  SNDRV_CTL_IOCTL_TLV_COMMAND</p><p>SOC_DOUBLE    与SOC_SINGLE相对应，区别是SOC_SINGLE只控制一个变量，而SOC_DOUBLE则可以同时在一个寄存器中控制两个相似的变量，最常用的就是用于一些立体声的控件，我们需要同时对左右声道进行控制，因为多了一个声道，参数也就相应地多了一个shift位移值</p><p>SOC_DOUBLE_R    与SOC_DOUBLE类似，对于左右声道的控制寄存器不一样的情况，使用SOC_DOUBLE_R来定义，参数中需要指定两个寄存器地址。<br>SOC_DOUBLE_TLV    与SOC_SINGLE_TLV对应的立体声版本，通常用于立体声音量控件的定义。</p><p>SOC_DOUBLE_R_TLV    左右声道有独立寄存器控制的SOC_DOUBLE_TLV版本</p><h5 id="7-1-2、Mixer控件"><a href="#7-1-2、Mixer控件" class="headerlink" title="7.1.2、Mixer控件"></a>7.1.2、Mixer控件</h5><p>Mixer控件用于音频通道的路由控制，由多个输入和一个输出组成，多个输入可以自由地混合在一起，形成混合后的输出：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/27-Audio-system-mixer-1525417497024.png" alt="Alt text"></p><p>对于Mixer控件，我们可以认为是多个简单控件的组合，通常，我们会为mixer的每个输入端都单独定义一个简单控件来控制该路输入的开启和关闭，反应在代码上，就是定义一个soc_kcontrol_new数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/codecs/wcd9335.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_kcontrol_new</span> <span class="title">aif4_vi_mixer</span>[] = &#123;</span></span><br><span class="line">SOC_SINGLE_EXT(<span class="string">"SPKR_VI_1"</span>, SND_SOC_NOPM, TASHA_TX14, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">SOC_SINGLE_EXT(<span class="string">"SPKR_VI_2"</span>, SND_SOC_NOPM, TASHA_TX15, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">tasha_vi_feed_mixer_get, tasha_vi_feed_mixer_put),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-1-3、Mux控件"><a href="#7-1-3、Mux控件" class="headerlink" title="7.1.3、Mux控件"></a>7.1.3、Mux控件</h5><p>mux控件与mixer控件类似，也是多个输入端和一个输出端的组合控件，与mixer控件不同的是，mux控件的多个输入端同时只能有一个被选中。因此，mux控件所对应的寄存器，通常可以设定一段连续的数值，每个不同的数值对应不同的输入端被打开，与上述的mixer控件不同，ASoc用soc_enum结构来描述mux控件的寄存器信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc.h]</span><br><span class="line"><span class="comment">/* enumerated kcontrol */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> reg;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift_l;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift_r;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> items;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *texts;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> *values;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个寄存器地址和位移字段：reg，reg2，shift_l，shift_r，用于描述左右声道的控制寄存器信息。字符串数组指针用于描述每个输入端对应的名字，value字段则指向一个数组，该数组定义了寄存器可以选择的值，每个值对应一个输入端，如果value是一组连续的值，通常我们可以忽略values参数。</p><h5 id="7-2、widget、path、route"><a href="#7-2、widget、path、route" class="headerlink" title="7.2、widget、path、route"></a>7.2、widget、path、route</h5><p>前面一节中，我们介绍了音频驱动中对基本控制单元的封装：kcontrol。利用kcontrol，我们可以完成对音频系统中的mixer，mux，音量控制，音效控制，以及各种开关量的控制，通过对各种kcontrol的控制，使得音频硬件能够按照我们预想的结果进行工作。同时我们可以看到，kcontrol还是有以下几点不足：<br>只能描述自身，无法描述各个kcontrol之间的连接关系；<br>没有相应的电源管理机制；<br>没有相应的时间处理机制来响应播放、停止、上电、下电等音频事件；<br>为了防止pop-pop声，需要用户程序关注各个kcontrol上电和下电的顺序；<br>当一个音频路径不再有效时，不能自动关闭该路径上的所有的kcontrol；<br>为此，DAPM框架正是为了要解决以上这些问题而诞生的，DAPM目前已经是ASoc中的重要组成部分，让我们先从DAPM的数据结构开始，了解它的设计思想和工作原理。</p><h5 id="7-2-1、DAPM的基本单元：widget"><a href="#7-2-1、DAPM的基本单元：widget" class="headerlink" title="7.2.1、DAPM的基本单元：widget"></a>7.2.1、DAPM的基本单元：widget</h5><p>文章的开头，我们说明了一下目前kcontrol的一些不足，而DAPM框架为了解决这些问题，引入了widget这一概念，所谓widget，其实可以理解为是kcontrol的进一步升级和封装，她同样是指音频系统中的某个部件，比如mixer，mux，输入输出引脚，电源供应器等等，甚至，我们可以定义虚拟的widget，例如playback stream widget。widget把kcontrol和动态电源管理进行了有机的结合，同时还具备音频路径的连结功能，一个widget可以与它相邻的widget有某种动态的连结关系。在DAPM框架中，widget用结构体snd_soc_dapm_widget来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> &#123;</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type id;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;<span class="comment">/* widget name */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sname;<span class="comment">/* stream name */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_codec</span> *<span class="title">codec</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *priv;<span class="comment">/* widget specific data */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">regulator</span> *<span class="title">regulator</span>;</span><span class="comment">/* attached regulator */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_pcm_stream</span> *<span class="title">params</span>;</span> <span class="comment">/* params for dai links */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* dapm control */</span></span><br><span class="line"><span class="keyword">int</span> reg;<span class="comment">/* negative reg = no direct dapm */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> shift;<span class="comment">/* bits to shift */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> mask;<span class="comment">/* non-shifted mask */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> on_val;<span class="comment">/* on state value */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> off_val;<span class="comment">/* off state value */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> power:<span class="number">1</span>;<span class="comment">/* block power status */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> active:<span class="number">1</span>;<span class="comment">/* active stream on DAC, ADC's */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> connected:<span class="number">1</span>;<span class="comment">/* connected codec pin */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">new</span>:<span class="number">1</span>;<span class="comment">/* cnew complete */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ext:<span class="number">1</span>;<span class="comment">/* has external widgets */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> force:<span class="number">1</span>;<span class="comment">/* force state */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ignore_suspend:<span class="number">1</span>;         <span class="comment">/* kept enabled over suspend */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> new_power:<span class="number">1</span>;<span class="comment">/* power from this run */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> power_checked:<span class="number">1</span>;<span class="comment">/* power checked this run */</span></span><br><span class="line"><span class="keyword">int</span> subseq;<span class="comment">/* sort within widget type */</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">/* widget input and outputs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sources</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sinks</span>;</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>snd_soc_dapm_widget结构比较大，为了简洁一些，这里我没有列出该结构体的完整字段，不过不用担心，下面我会说明每个字段的意义：<br>id    该widget的类型值，比如snd_soc_dapm_output，snd_soc_dapm_mixer等等。</p><p>*name    该widget的名字</p><p>*sname    代表该widget所在stream的名字，比如对于snd_soc_dapm_dai_in类型的widget，会使用该字段。</p><p><em>codec </em>platform    指向该widget所属的codec和platform。</p><p>list    所有注册到系统中的widget都会通过该list，链接到代表声卡的snd_soc_card结构的widgets链表头字段中。</p><p>*dapm    snd_soc_dapm_context结构指针，ASoc把系统划分为多个dapm域，每个widget属于某个dapm域，同一个域代表着同样的偏置电压供电策略，比如，同一个codec中的widget通常位于同一个dapm域，而平台上的widget可能又会位于另外一个platform域中。</p><p>*priv    有些widget可能需要一些专有的数据，可以使用该字段来保存，像snd_soc_dapm_dai_in类型的widget，会使用该字段来记住与之相关联的snd_soc_dai结构指针。</p><p>*regulator    对于snd_soc_dapm_regulator_supply类型的widget，该字段指向与之相关的regulator结构指针。</p><p>*params    目前对于snd_soc_dapm_dai_link类型的widget，指向该dai的配置信息的snd_soc_pcm_stream结构。</p><p>reg shift mask     这3个字段用来控制该widget的电源状态，分别对应控制信息所在的寄存器地址，位移值和屏蔽值。</p><p>value  on_val  off_val    电源状态的当前只，开启时和关闭时所对应的值。</p><p>power invert    用于指示该widget当前是否处于上电状态，invert则用于表明power字段是否需要逻辑反转。</p><p>active connected    分别表示该widget是否处于激活状态和连接状态，当和相邻的widget有连接关系时，connected位会被置1，否则置0。</p><p>new   我们定义好的widget（snd_soc_dapm_widget结构），在注册到声卡中时需要进行实例化，该字段用来表示该widget是否已经被实例化。</p><p>ext    表示该widget当前是否有外部连接，比如连接mic，耳机，喇叭等等。</p><p>force    该位被设置后，将会不管widget当前的状态，强制更新至新的电源状态。</p><p>ignore_suspend new_power power_checked    这些电源管理相关的字段。</p><p>subseq    该widget目前在上电或下电队列中的排序编号，为了防止在上下电的过程中出现pop-pop声，DAPM会给每个widget分配合理的上下电顺序。</p><p>*power_check    用于检查该widget是否应该上电或下电的回调函数指针。<br>event_flags    该字段是一个位或字段，每个位代表该widget会关注某个DAPM事件通知。只有被关注的通知事件会被发送到widget的事件处理回调函数中。</p><p>*event    DAPM事件处理回调函数指针。</p><p>num_kcontrols <em>kcontrol_news *</em>kcontrols    这3个字段用来描述与该widget所包含的kcontrol控件，例如一个mixer控件或者是一个mux控件。</p><p>sources sinks    两个链表字段，两个widget如果有连接关系，会通过一个snd_soc_dapm_path结构进行连接，sources链表用于链接所有的输入path，sinks链表用于链接所有的输出path。</p><p>power_list    每次更新整个dapm的电源状态时，会根据一定的算法扫描所有的widget，然后把需要变更电源状态的widget利用该字段链接到一个上电或下电的链表中，扫描完毕后，dapm系统会遍历这两个链表执行相应的上电或下电操作。</p><p>dirty    链表字段，widget的状态变更后，dapm系统会利用该字段，把该widget加入到一个dirty链表中，稍后会对dirty链表进行扫描，以执行整个路径的更新。</p><p>inputs    该widget的所有有效路径中，连接到输入端的路径数量。</p><p>outputs    该widget的所有有效路径中，连接到输出端的路径数量。</p><p>*clk    对于snd_soc_dapm_clock_supply类型的widget，指向相关联的clk结构指针。</p><p>以上我们对snd_soc_dapm_widget结构的各个字段所代表的意义一一做出了说明，这里只是让大家现有个概念</p><h5 id="7-2-2、widget的种类"><a href="#7-2-2、widget的种类" class="headerlink" title="7.2.2、widget的种类"></a>7.2.2、widget的种类</h5><p>在DAPM框架中，把各种不同的widget划分为不同的种类，snd_soc_dapm_widget结构中的id字段用来表示该widget的种类，可选的种类都定义在一个枚举中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm widget types */</span></span><br><span class="line"><span class="keyword">enum</span> snd_soc_dapm_type &#123;</span><br><span class="line">snd_soc_dapm_input = <span class="number">0</span>,<span class="comment">/* input pin */</span></span><br><span class="line">snd_soc_dapm_output,<span class="comment">/* output pin */</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>下面我们逐个解释一下这些widget的种类：<br>snd_soc_dapm_input     该widget对应一个输入引脚。<br>snd_soc_dapm_output    该widget对应一个输出引脚。<br>snd_soc_dapm_mux    该widget对应一个mux控件。<br>snd_soc_dapm_virt_mux    该widget对应一个虚拟的mux控件。<br>snd_soc_dapm_value_mux    该widget对应一个value类型的mux控件。<br>snd_soc_dapm_mixer    该widget对应一个mixer控件。<br>snd_soc_dapm_mixer_named_ctl    该widget对应一个mixer控件，但是对应的kcontrol的名字不会加入widget的名字作为前缀。<br>snd_soc_dapm_pga    该widget对应一个pga控件（可编程增益控件）。<br>snd_soc_dapm_out_drv    该widget对应一个输出驱动控件<br>snd_soc_dapm_adc    该widget对应一个ADC<br>snd_soc_dapm_dac    该widget对应一个DAC<br>snd_soc_dapm_micbias    该widget对应一个麦克风偏置电压控件<br>snd_soc_dapm_mic    该widget对应一个麦克风。<br>snd_soc_dapm_hp    该widget对应一个耳机。<br>snd_soc_dapm_spk    该widget对应一个扬声器。<br>snd_soc_dapm_line     该widget对应一个线路输入。<br>snd_soc_dapm_switch       该widget对应一个模拟开关。<br>snd_soc_dapm_vmid      该widget对应一个codec的vmid偏置电压。<br>snd_soc_dapm_pre      machine级别的专用widget，会先于其它widget执行检查操作。<br>snd_soc_dapm_post    machine级别的专用widget，会后于其它widget执行检查操作。<br>snd_soc_dapm_supply           对应一个电源或是时钟源。<br>snd_soc_dapm_regulator_supply  对应一个外部regulator稳压器。<br>snd_soc_dapm_clock_supply      对应一个外部时钟源。<br>snd_soc_dapm_aif_in            对应一个数字音频输入接口，比如I2S接口的输入端。<br>snd_soc_dapm_aif_out          对应一个数字音频输出接口，比如I2S接口的输出端。<br>snd_soc_dapm_siggen            对应一个信号发生器。<br>snd_soc_dapm_dai_in           对应一个platform或codec域的输入DAI结构。<br>snd_soc_dapm_dai_out        对应一个platform或codec域的输出DAI结构。<br>snd_soc_dapm_dai_link         用于链接一对输入/输出DAI结构。</p><h5 id="7-2-3、widget之间的连接器：path"><a href="#7-2-3、widget之间的连接器：path" class="headerlink" title="7.2.3、widget之间的连接器：path"></a>7.2.3、widget之间的连接器：path</h5><p>之前已经提到，一个widget是有输入和输出的，而且widget之间是可以动态地进行连接的，那它们是用什么来连接两个widget的呢？DAPM为我们提出了path这一概念，path相当于电路中的一根跳线，它把一个widget的输出端和另一个widget的输入端连接在一起，path用snd_soc_dapm_path结构来描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="comment">/* dapm audio path between two widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* source (input) and sink (output) widgets */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">source</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">sink</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* status */</span></span><br><span class="line">u32 connect:<span class="number">1</span>;<span class="comment">/* source and sink widgets are connected */</span></span><br><span class="line">u32 walked:<span class="number">1</span>;<span class="comment">/* path has been walked */</span></span><br><span class="line">u32 walking:<span class="number">1</span>;  <span class="comment">/* path is in the process of being walked */</span></span><br><span class="line">u32 weak:<span class="number">1</span>;<span class="comment">/* path ignored for power management */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line"> struct snd_soc_dapm_widget *sink);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_source</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_sink</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list_kcontrol</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当widget之间发生连接关系时，snd_soc_dapm_path作为连接者，它的source字段会指向该连接的起始端widget，而它的sink字段会指向该连接的到达端widget，还记得前面snd_soc_dapm_widget结构中的两个链表头字段：sources和sinks么？widget的输入端和输出端可能连接着多个path，所有输入端的snd_soc_dapm_path结构通过list_sink字段挂在widget的souces链表中，同样，所有输出端的snd_soc_dapm_path结构通过list_source字段挂在widget的sinks链表中。这里可能大家会被搞得晕呼呼的，一会source，一会sink，不要紧，只要记住，连接的路径是这样的：起始端widget的输出–&gt;path的输入–&gt;path的输出–&gt;到达端widget输入。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/28-Audio-system-snd_soc_dapm_path.png" alt="Alt text"><br>另外，snd_soc_dapm_path结构的list字段用于把所有的path注册到声卡中，其实就是挂在snd_soc_card结构的paths链表头字段中。如果你要自己定义方法来检查path的当前连接状态，你可以提供自己的connected回调函数指针。</p><p>connect，walked，walking，weak是几个辅助字段，用于帮助所有path的遍历。</p><h5 id="7-2-4、widget的连接关系：route"><a href="#7-2-4、widget的连接关系：route" class="headerlink" title="7.2.4、widget的连接关系：route"></a>7.2.4、widget的连接关系：route</h5><p>通过上一节的内容，我们知道，一个路径的连接至少包含以下几个元素：起始端widget，跳线path，到达端widget，在DAPM中，用snd_soc_dapm_route结构来描述这样一个连接关系：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/include/sound/soc-dapm.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_route</span> &#123;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *sink;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *control;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *source;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: currently only supported for links where source is a supply */</span></span><br><span class="line"><span class="keyword">int</span> (*connected)(struct snd_soc_dapm_widget *source,</span><br><span class="line"> struct snd_soc_dapm_widget *sink);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>sink指向到达端widget的名字字符串，source指向起始端widget的名字字符串，control指向负责控制该连接所对应的kcontrol名字字符串，connected回调则定义了上一节所提到的自定义连接检查回调函数。该结构的意义很明显就是：source通过一个kcontrol，和sink连接在一起，现在是否处于连接状态，请调用connected回调函数检查。<br>这里直接使用名字字符串来描述连接关系，所有定义好的route，最后都要注册到dapm系统中，dapm会根据这些名字找出相应的widget，并动态地生成所需要的snd_soc_dapm_path结构，正确地处理各个链表和指针的关系，实现两个widget之间的连接</p><h5 id="7-3、建立widget之间的连接关系"><a href="#7-3、建立widget之间的连接关系" class="headerlink" title="7.3、建立widget之间的连接关系"></a>7.3、建立widget之间的连接关系</h5><p>前面我们主要着重于codec、platform、machine驱动程序中如何使用和建立dapm所需要的widget，route，这些是音频驱动开发人员必须要了解的内容，经过前几章的介绍，我们应该知道如何在alsa音频驱动的3大部分（codec、platform、machine）中，按照所使用的音频硬件结构，定义出相应的widget，kcontrol，以及必要的音频路径，而在本节中，我们将会深入dapm的核心部分，看看各个widget之间是如何建立连接关系，形成一条完整的音频路径。</p><p>前面我们已经简单地介绍过，驱动程序需要使用以下api函数创建widget：</p><p>• snd_soc_dapm_new_controls()<br>实际上，这个函数只是创建widget的第一步，它为每个widget分配内存，初始化必要的字段，然后把这些widget挂在代表声卡的snd_soc_card的widgets链表字段中。要使widget之间具备连接能力，我们还需要第二个函数：<br>• snd_soc_dapm_new_widgets()<br>这个函数会根据widget的信息，创建widget所需要的dapm kcontrol，这些dapm kcontol的状态变化，代表着音频路径的变化，从而影响着各个widget的电源状态。看到函数的名称可能会迷惑一下，实际上，snd_soc_dapm_new_controls的作用更多地是创建widget，而snd_soc_dapm_new_widget的作用则更多地是创建widget所包含的kcontrol，所以在我看来，这两个函数名称应该换过来叫更好！下面我们分别介绍一下这两个函数是如何工作的。</p><h5 id="7-3-1、创建widget"><a href="#7-3-1、创建widget" class="headerlink" title="7.3.1、创建widget"></a>7.3.1、创建widget</h5><p>snd_soc_dapm_new_controls()函数完成widget的创建工作，并把这些创建好的widget注册在声卡的widgets链表中，我们看看他的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_controls</span><span class="params">(struct snd_soc_dapm_context *dapm,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct snd_soc_dapm_widget *widget,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">w = snd_soc_dapm_new_control(dapm, widget);</span><br><span class="line"><span class="keyword">if</span> (!w) &#123;</span><br><span class="line">dev_err(dapm-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: Failed to create DAPM control %s\n"</span>,</span><br><span class="line">widget-&gt;name);</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">widget++;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是简单的一个循环，为传入的widget模板数组依次调用snd_soc_dapm_new_control函数，实际的工作由snd_soc_dapm_new_control完成，继续进入该函数，看看它做了那些工作。<br>我们之前已经说过，驱动中定义的snd_soc_dapm_widget数组，只是作为一个模板，所以，snd_soc_dapm_new_control所做的第一件事，就是为该widget重新分配内存，并把模板的内容拷贝过来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *</span></span><br><span class="line"><span class="class"><span class="title">snd_soc_dapm_new_control</span>(<span class="title">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span>,</span></span><br><span class="line"><span class="class"> <span class="title">const</span> <span class="title">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">widget</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">w</span>;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *prefix;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((w = dapm_cnew_widget(widget)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//由dapm_cnew_widget完成内存申请和拷贝模板的动作。接下来，根据widget的类型做不同的处理：</span></span><br><span class="line"><span class="keyword">switch</span> (w-&gt;id) &#123;</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:</span><br><span class="line">......</span><br><span class="line">    &#125;</span><br><span class="line">prefix = soc_dapm_prefix(dapm);</span><br><span class="line"><span class="comment">//对于snd_soc_dapm_regulator_supply类型的widget，根据widget的名称获取对应的regulator结构，对于snd_soc_dapm_clock_supply类型的widget，根据widget的名称，获取对应的clock结构。接下来，根据需要，在widget的名称前加入必要的前缀：</span></span><br><span class="line"><span class="keyword">if</span> (prefix) &#123;</span><br><span class="line">w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">"%s %s"</span>, prefix, widget-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">"%s %s"</span>, prefix,</span><br><span class="line">     widget-&gt;sname);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w-&gt;name = kasprintf(GFP_KERNEL, <span class="string">"%s"</span>, widget-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (widget-&gt;sname)</span><br><span class="line">w-&gt;sname = kasprintf(GFP_KERNEL, <span class="string">"%s"</span>, widget-&gt;sname);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/29-Audio-system-widget-1525420992983.png" alt="Alt text"><br>当音频路径发生变化时，power_check回调会被调用，用于检查该widget的电源状态是否需要更新。power_check设置完成后，需要设置widget所属的codec、platform和dapm context，几个用于音频路径的链表也需要初始化，然后，把该widget加入到声卡的widgets链表中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line">w-&gt;dapm = dapm;  </span><br><span class="line">w-&gt;codec = dapm-&gt;codec;  </span><br><span class="line">w-&gt;platform = dapm-&gt;platform;  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sources);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;sinks);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;<span class="built_in">list</span>);  </span><br><span class="line">INIT_LIST_HEAD(&amp;w-&gt;dirty);  </span><br><span class="line">list_add(&amp;w-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;widgets);</span><br></pre></td></tr></table></figure><p>几个链表的作用如下：<br>sources    用于链接所有连接到该widget输入端的snd_soc_path结构<br>sinks    用于链接所有连接到该widget输出端的snd_soc_path结构<br>list    用于链接到声卡的widgets链表<br>dirty    用于链接到声卡的dapm_dirty链表<br>最后，把widget设置为connect状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c：snd_soc_dapm_new_control()</span><br><span class="line"><span class="comment">/* machine layer set ups unconnected pins and insertions */</span>  </span><br><span class="line">w-&gt;connected = <span class="number">1</span>;  </span><br><span class="line"><span class="keyword">return</span> w;</span><br></pre></td></tr></table></figure><p>connected字段代表着引脚的连接状态，目前，只有以下这些widget使用connected字段：<br>snd_soc_dapm_output<br>snd_soc_dapm_input<br>snd_soc_dapm_hp<br>snd_soc_dapm_spk<br>snd_soc_dapm_line<br>snd_soc_dapm_vmid<br>snd_soc_dapm_mic<br>snd_soc_dapm_siggen<br>驱动程序可以使用以下这些api来设置引脚的连接状态：<br>snd_soc_dapm_enable_pin<br>snd_soc_dapm_force_enable_pin<br>snd_soc_dapm_disable_pin<br>snd_soc_dapm_nc_pin<br>到此，widget已经被正确地创建并初始化，而且被挂在声卡的widgets链表中，以后我们就可以通过声卡的widgets链表来遍历所有的widget，再次强调一下snd_soc_dapm_new_controls函数所完成的主要功能：<br>为widget分配内存，并拷贝参数中传入的在驱动中定义好的模板<br>设置power_check回调函数<br>把widget挂在声卡的widgets链表中</p><h5 id="7-3-2、为widget建立dapm-kcontrol"><a href="#7-3-2、为widget建立dapm-kcontrol" class="headerlink" title="7.3.2、为widget建立dapm kcontrol"></a>7.3.2、为widget建立dapm kcontrol</h5><p>定义一个widget，我们需要指定两个很重要的内容：一个是用于控制widget的电源状态的reg/shift等寄存器信息，另一个是用于控制音频路径切换的dapm kcontrol信息，这些dapm kcontrol有它们自己的reg/shift寄存器信息用于切换widget的路径连接方式。前一节的内容中，我们只是创建了widget的实例，并把它们注册到声卡的widgts链表中，但是到目前为止，包含在widget中的dapm kcontrol并没有建立起来，dapm框架在声卡的初始化阶段，等所有的widget（包括machine、platform、codec）都创建好之后，通过snd_soc_dapm_new_widgets函数，创建widget内包含的dapm kcontrol，并初始化widget的初始电源状态和音频路径的初始连接状态。我们看看声卡的初始化函数，都有那些初始化与dapm有关：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_instantiate_card</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="comment">/* card bind complete so register a sound card */</span>  </span><br><span class="line">        ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,  </span><br><span class="line">                        card-&gt;owner, <span class="number">0</span>, &amp;card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">   </span><br><span class="line">        card-&gt;dapm.bias_level = SND_SOC_BIAS_OFF;  </span><br><span class="line">        card-&gt;dapm.dev = card-&gt;dev;  </span><br><span class="line">        card-&gt;dapm.card = card;  </span><br><span class="line">        list_add(&amp;card-&gt;dapm.<span class="built_in">list</span>, &amp;card-&gt;dapm_list);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_widgets)    <span class="comment">/* 创建machine级别的widget  */</span>  </span><br><span class="line">                snd_soc_dapm_new_controls(&amp;card-&gt;dapm, card-&gt;dapm_widgets,  </span><br><span class="line">                                          card-&gt;num_dapm_widgets);  </span><br><span class="line">        ......  </span><br><span class="line">        snd_soc_dapm_link_dai_widgets(card);  <span class="comment">/*  连接dai widget  */</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;controls)    <span class="comment">/*  建立machine级别的普通kcontrol控件  */</span>  </span><br><span class="line">                snd_soc_add_card_controls(card, card-&gt;controls, card-&gt;num_controls);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;dapm_routes)    <span class="comment">/*  注册machine级别的路径连接信息  */</span>  </span><br><span class="line">                snd_soc_dapm_add_routes(&amp;card-&gt;dapm, card-&gt;dapm_routes,  </span><br><span class="line">                                        card-&gt;num_dapm_routes);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (card-&gt;fully_routed)    <span class="comment">/*  如果该标志被置位，自动把codec中没有路径连接信息的引脚设置为无用widget  */</span>  </span><br><span class="line">                list_for_each_entry(codec, &amp;card-&gt;codec_dev_list, card_list)  </span><br><span class="line">                        snd_soc_dapm_auto_nc_codec_pins(codec);  </span><br><span class="line">  </span><br><span class="line">        snd_soc_dapm_new_widgets(card);    <span class="comment">/*初始化widget包含的dapm kcontrol、电源状态和连接状态*/</span>  </span><br><span class="line">  </span><br><span class="line">        ret = snd_card_register(card-&gt;snd_card);  </span><br><span class="line">        ......  </span><br><span class="line">        card-&gt;instantiated = <span class="number">1</span>;  </span><br><span class="line">        snd_soc_dapm_sync(&amp;card-&gt;dapm);  </span><br><span class="line">        ......  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正如我添加的注释中所示，在完成machine级别的widget和route处理之后，调用的snd_soc_dapm_new_widgets函数，来为所有已经注册的widget初始化他们所包含的dapm kcontrol，并初始化widget的电源状态和路径连接状态。下面我们看看snd_soc_dapm_new_widgets函数的工作过程。</p><h5 id="7-3-2-1、snd-soc-dapm-new-widgets函数"><a href="#7-3-2-1、snd-soc-dapm-new-widgets函数" class="headerlink" title="7.3.2.1、snd_soc_dapm_new_widgets函数"></a>7.3.2.1、snd_soc_dapm_new_widgets函数</h5><p>该函数通过声卡的widgets链表，遍历所有已经注册了的widget，其中的new字段用于判断该widget是否已经执行过snd_soc_dapm_new_widgets函数，如果num_kcontrols字段有数值，表明该widget包含有若干个dapm kcontrol，那么就需要为这些kcontrol分配一个指针数组，并把数组的首地址赋值给widget的kcontrols字段，该数组存放着指向这些kcontrol的指针，当然现在这些都是空指针，因为实际的kcontrol现在还没有被创建：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_new_widgets</span><span class="params">(struct snd_soc_card *card)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;card-&gt;widgets, <span class="built_in">list</span>)  </span><br><span class="line">        &#123;                 </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;<span class="keyword">new</span>) <span class="keyword">continue</span>;  </span><br><span class="line">                                  </span><br><span class="line">                <span class="keyword">if</span> (w-&gt;num_kcontrols) &#123;  </span><br><span class="line">                        w-&gt;kcontrols = kzalloc(w-&gt;num_kcontrols *  </span><br><span class="line">                                                <span class="keyword">sizeof</span>(struct snd_kcontrol *),  </span><br><span class="line">                                                GFP_KERNEL);  </span><br><span class="line">                        ......  </span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>接着，对几种能影响音频路径的widget，创建并初始化它们所包含的dapm kcontrol：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="keyword">switch</span>(w-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        dapm_new_mixer(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        dapm_new_mux(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line">        dapm_new_pga(w);  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">default</span>:  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到的创建函数分别是：<br>dapm_new_mixer()    对于mixer类型，用该函数创建dapm kcontrol；<br>dapm_new_mux()   对于mux类型，用该函数创建dapm kcontrol；<br>dapm_new_pga()   对于pga类型，用该函数创建dapm kcontrol；<br>然后，根据widget寄存器的当前值，初始化widget的电源状态，并设置到power字段中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line"><span class="comment">/* Read the initial power state from the device */</span>  </span><br><span class="line"><span class="keyword">if</span> (w-&gt;reg &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        val = soc_widget_read(w, w-&gt;reg) &gt;&gt; w-&gt;shift;  </span><br><span class="line">        val &amp;= w-&gt;mask;  </span><br><span class="line">        <span class="keyword">if</span> (val == w-&gt;on_val)  </span><br><span class="line">                w-&gt;power = <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，设置new字段，表明该widget已经初始化完成，我们还要吧该widget加入到声卡的dapm_dirty链表中，表明该widget的状态发生了变化，稍后在合适的时刻，dapm框架会扫描dapm_dirty链表，统一处理所有已经变化的widget。为什么要统一处理？因为dapm要控制各种widget的上下电顺序，同时也是为了减少寄存器的读写次数（多个widget可能使用同一个寄存器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">w-&gt;<span class="keyword">new</span> = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">dapm_mark_dirty(w, <span class="string">"new widget"</span>);  </span><br><span class="line">dapm_debugfs_add_widget(w);</span><br></pre></td></tr></table></figure><p>最后，通过dapm_power_widgets函数，统一处理所有位于dapm_dirty链表上的widget的状态改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_new_widgets()]</span><br><span class="line">dapm_power_widgets(card, SND_SOC_DAPM_STREAM_NOP);  </span><br><span class="line">......  </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h5 id="7-3-2-2、dapm-mixer-kcontrol"><a href="#7-3-2-2、dapm-mixer-kcontrol" class="headerlink" title="7.3.2.2、dapm mixer kcontrol"></a>7.3.2.2、dapm mixer kcontrol</h5><p>上一节中，我们提到，对于mixer类型的dapm kcontrol，我们会使用dapm_new_mixer来完成具体的创建工作，先看代码后分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mixer</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, ret;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* add kcontrol */</span>  </span><br><span class="line">（<span class="number">1</span>）        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; w-&gt;num_kcontrols; i++) &#123;                                  </span><br><span class="line">                <span class="comment">/* match name */</span>  </span><br><span class="line">（<span class="number">2</span>）                list_for_each_entry(path, &amp;w-&gt;sources, list_sink) &#123;               </span><br><span class="line">                        <span class="comment">/* mixer/mux paths name must match control name */</span>  </span><br><span class="line">（<span class="number">3</span>）                        <span class="keyword">if</span> (path-&gt;name != (<span class="keyword">char</span> *)w-&gt;kcontrol_news[i].name)       </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">4</span>）                        <span class="keyword">if</span> (w-&gt;kcontrols[i]) &#123;                                   </span><br><span class="line">                                dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);  </span><br><span class="line">                                <span class="keyword">continue</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">5</span>）                        ret = dapm_create_or_share_mixmux_kcontrol(w, i);        </span><br><span class="line">                        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                                <span class="keyword">return</span> ret;  </span><br><span class="line">  </span><br><span class="line">（<span class="number">6</span>）                        dapm_kcontrol_add_path(w-&gt;kcontrols[i], path);           </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  因为一个mixer是由多个kcontrol组成的，每个kcontrol控制着mixer的一个输入端的开启和关闭，所以，该函数会根据kcontrol的数量做循环，逐个建立对应的kcontrol。<br>（2）（3）  之前多次提到，widget之间使用snd_soc_path进行连接，widget的sources链表保存着所有和输入端连接的snd_soc_path结构，所以我们可以用kcontrol模板中指定的名字来匹配对应的snd_soc_path结构。<br>（4）  因为一个输入脚可能会连接多个输入源，所以可能在上一个输入源的path关联时已经创建了这个kcontrol，所以这里判断kcontrols指针数组中对应索引中的指针值，如果已经赋值，说明kcontrol已经在之前创建好了，所以我们只要简单地把连接该输入端的path加入到kcontrol的path_list链表中，并且增加一个虚拟的影子widget，该影子widget连接和输入端对应的源widget，因为使用了kcontrol本身的reg/shift等寄存器信息，所以实际上控制的是该kcontrol的开和关，这个影子widget只有在kcontrol的autodisable字段被设置的情况下才会被创建，该特性使得source的关闭时，与之连接的mixer的输入端也可以自动关闭，这个特性通过dapm_kcontrol_add_path来实现这一点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dapm_kcontrol_add_path</span><span class="params">(<span class="keyword">const</span> struct snd_kcontrol *kcontrol,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dapm_kcontrol_data</span> *<span class="title">data</span> = <span class="title">snd_kcontrol_chip</span>(<span class="title">kcontrol</span>);</span>  </span><br><span class="line">        <span class="comment">/*  把kcontrol连接的path加入到paths链表中  */</span>  </span><br><span class="line">        <span class="comment">/*  paths链表所在的dapm_kcontrol_data结构会保存在kcontrol的private_data字段中  */</span>  </span><br><span class="line">        list_add_tail(&amp;path-&gt;list_kcontrol, &amp;data-&gt;paths);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (data-&gt;widget) &#123;  </span><br><span class="line">                snd_soc_dapm_add_path(data-&gt;widget-&gt;dapm, data-&gt;widget,  </span><br><span class="line">                    path-&gt;source, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）  如果kcontrol之前没有被创建，则通过dapm_create_or_share_mixmux_kcontrol创建这个输入端的kcontrol，同理，kcontrol对应的影子widget也会通过dapm_kcontrol_add_path判断是否需要创建。</p><h5 id="7-3-2-3、dapm-mux-kcontrol"><a href="#7-3-2-3、dapm-mux-kcontrol" class="headerlink" title="7.3.2.3、dapm mux kcontrol"></a>7.3.2.3、dapm mux kcontrol</h5><p>因为一个widget最多只会包含一个mux类型的damp kcontrol，所以他的创建方法稍有不同，dapm框架使用dapm_new_mux函数来创建mux类型的dapm kcontrol：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_mux</span><span class="params">(struct snd_soc_dapm_widget *w)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_context</span> *<span class="title">dapm</span> = <span class="title">w</span>-&gt;<span class="title">dapm</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">          </span><br><span class="line">(<span class="number">1</span>)     <span class="keyword">if</span> (w-&gt;num_kcontrols != <span class="number">1</span>) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev,  </span><br><span class="line">                        <span class="string">"ASoC: mux %s has incorrect number of controls\n"</span>,  </span><br><span class="line">                        w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;w-&gt;sources)) &#123;  </span><br><span class="line">                dev_err(dapm-&gt;dev, <span class="string">"ASoC: mux %s has no paths\n"</span>, w-&gt;name);  </span><br><span class="line">                <span class="keyword">return</span> -EINVAL;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">(<span class="number">2</span>)     ret = dapm_create_or_share_mixmux_kcontrol(w, <span class="number">0</span>);  </span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">return</span> ret;  </span><br><span class="line">(<span class="number">3</span>)       list_for_each_entry(path, &amp;w-&gt;sources, list_sink)  </span><br><span class="line">                dapm_kcontrol_add_path(w-&gt;kcontrols[<span class="number">0</span>], path);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  对于mux类型的widget，因为只会有一个kcontrol，所以在这里做一下判断。<br>（2）  同样地，和mixer类型一样，也使用dapm_create_or_share_mixmux_kcontrol来创建这个kcontrol。<br>（3）  对每个输入端所连接的path都加入dapm_kcontrol_data结构的paths链表中，并且创建一个影子widget，用于支持autodisable特性。</p><h5 id="7-3-2-4、dapm-pga-kcontrol"><a href="#7-3-2-4、dapm-pga-kcontrol" class="headerlink" title="7.3.2.4、dapm pga kcontrol"></a>7.3.2.4、dapm pga kcontrol</h5><p>目前对于pga类型的widget，kcontrol的创建函数是个空函数，所以我们不用太关注它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_new_pga</span><span class="params">(struct snd_soc_dapm_widget *w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (w-&gt;num_kcontrols)</span><br><span class="line">dev_err(w-&gt;dapm-&gt;dev,</span><br><span class="line"><span class="string">"ASoC: PGA controls not supported: '%s'\n"</span>, w-&gt;name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dapm_create_or_share_mixmux_kcontrol函数<br>上面所说的mixer类型和mux类型的widget，在创建他们所包含的dapm kcontrol时，最后其实都是使用了dapm_create_or_share_mixmux_kcontrol函数来完成创建工作的，所以在这里我们有必要分析一下这个函数的工作原理。这个函数中有很大一部分代码实在处理kcontrol的名字是否要加入codec的前缀，我们会忽略这部分的代码，感兴趣的读者可以自己查看内核的代码，路径在：sound/soc/soc-dapm.c中，简化后的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_create_or_share_mixmux_kcontrol</span><span class="params">(struct snd_soc_dapm_widget *w,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> kci)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">          ......  </span><br><span class="line">(<span class="number">1</span>)       shared = dapm_is_shared_kcontrol(dapm, w, &amp;w-&gt;kcontrol_news[kci],  </span><br><span class="line">                                         &amp;kcontrol);  </span><br><span class="line">     </span><br><span class="line">(<span class="number">2</span>)       <span class="keyword">if</span> (!kcontrol) &#123;  </span><br><span class="line">(<span class="number">3</span>)            kcontrol = snd_soc_cnew(&amp;w-&gt;kcontrol_news[kci], <span class="literal">NULL</span>, name,prefix）;  </span><br><span class="line">               ......  </span><br><span class="line">               kcontrol-&gt;private_free = dapm_kcontrol_free;  </span><br><span class="line">(<span class="number">4</span>)            ret = dapm_kcontrol_data_alloc(w, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">(<span class="number">5</span>)            ret = snd_ctl_add(card, kcontrol);  </span><br><span class="line">                ......  </span><br><span class="line">        &#125;  </span><br><span class="line">(<span class="number">6</span>)     ret = dapm_kcontrol_add_widget(kcontrol, w);  </span><br><span class="line">        ......  </span><br><span class="line">(<span class="number">7</span>)     w-&gt;kcontrols[kci] = kcontrol;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）  为了节省内存，通过kcontrol名字的匹配查找，如果这个kcontrol已经在其他widget中已经创建好了，那我们不再创建，dapm_is_shared_kcontrol的参数kcontrol会返回已经创建好的kcontrol的指针。<br>（2）  如果kcontrol指针被赋值，说明在（1）中查找到了其他widget中同名的kcontrol，我们不用再次创建，只要共享该kcontrol即可。<br>（3）  标准的kcontrol创建函数，<br>（4）  如果widget支持autodisable特性，创建与该kcontrol所对应的影子widget，该影子widget的类型是：snd_soc_dapm_kcontrol。<br>（5）  标准的kcontrol创建函数，<br>（6）  把所有共享该kcontrol的影子widget（snd_soc_dapm_kcontrol），加入到kcontrol的private_data字段所指向的dapm_kcontrol_data结构中。<br>（7）  把创建好的kcontrol指针赋值到widget的kcontrols数组中。<br>需要注意的是，如果kcontol支持autodisable特性，一旦kcontrol由于source的关闭而被自动关闭，则用户空间只能操作该kcontrol的cache值，只有该kcontrol再次打开时，该cache值才会被真正地更新到寄存器中。<br>现在。我们总结一下，创建一个widget所包含的kcontrol所做的工作：<br>• 循环每一个输入端，为每个输入端依次执行下面的一系列操作<br>• 为每个输入端创建一个kcontrol，能共享的则直接使用创建好的kcontrol<br>• kcontrol的private_data字段保存着这些共享widget的信息<br>• 如果支持autodisable特性，每个输入端还要额外地创建一个虚拟的snd_soc_dapm_kcontrol类型的影子widget，该影子widget也记录在private_data字段中<br>• 创建好的kcontrol会依次存放在widget的kcontrols数组中，供路径的控制和匹配之用。</p><h5 id="7-3-2-5、为widget建立连接关系"><a href="#7-3-2-5、为widget建立连接关系" class="headerlink" title="7.3.2.5、为widget建立连接关系"></a>7.3.2.5、为widget建立连接关系</h5><p>如果widget之间没有连接关系，dapm就无法实现动态的电源管理工作，正是widget之间有了连结关系，这些连接关系形成了一条所谓的完成的音频路径，dapm可以顺着这条路径，统一控制路径上所有widget的电源状态，前面我们已经知道，widget之间是使用snd_soc_path结构进行连接的，驱动要做的是定义一个snd_soc_route结构数组，该数组的每个条目描述了目的widget的和源widget的名称，以及控制这个连接的kcontrol的名称，最终，驱动程序使用api函数snd_soc_dapm_add_routes来注册这些连接信息，接下来我们就是要分析该函数的具体实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snd_soc_dapm_add_routes</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct snd_soc_dapm_route *route, <span class="keyword">int</span> num)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i, r, ret = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">        mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;  </span><br><span class="line">                r = snd_soc_dapm_add_route(dapm, route);  </span><br><span class="line">                ......  </span><br><span class="line">                route++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是一个循环，依次对参数传入的数组调用snd_soc_dapm_add_route，主要的工作由snd_soc_dapm_add_route完成。我们进入snd_soc_dapm_add_route函数看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_route</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> struct snd_soc_dapm_route *route)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wsource</span> = <span class="title">NULL</span>, *<span class="title">wsink</span> = <span class="title">NULL</span>, *<span class="title">w</span>;</span>  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_widget</span> *<span class="title">wtsource</span> = <span class="title">NULL</span>, *<span class="title">wtsink</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *sink;  </span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *source;  </span><br><span class="line">        ......  </span><br><span class="line">        list_for_each_entry(w, &amp;dapm-&gt;card-&gt;widgets, <span class="built_in">list</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!wsink &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, sink))) &#123;  </span><br><span class="line">                        wtsink = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsink = w;  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!wsource &amp;&amp; !(<span class="built_in">strcmp</span>(w-&gt;name, source))) &#123;  </span><br><span class="line">                        wtsource = w;  </span><br><span class="line">                        <span class="keyword">if</span> (w-&gt;dapm == dapm)  </span><br><span class="line">                                wsource = w;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>上面的代码我再次省略了关于名称前缀的处理部分。我们可以看到，用widget的名字来比较，遍历声卡的widgets链表，找出源widget和目的widget的指针，这段代码虽然正确，但我总感觉少了一个判断退出循环的条件，如果链表的开头就找到了两个widget，还是要遍历整个链表才结束循环，好浪费时间。<br>下面，如果在本dapm context中没有找到，则使用别的dapm context中找到的widget：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line"><span class="keyword">if</span> (!wsink)  </span><br><span class="line">        wsink = wtsink;  </span><br><span class="line"><span class="keyword">if</span> (!wsource)  </span><br><span class="line">        wsource = wtsource;</span><br></pre></td></tr></table></figure><p>最后，使用来增加一条连接信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_route()]</span><br><span class="line">        ret = snd_soc_dapm_add_path(dapm, wsource, wsink, route-&gt;control,  </span><br><span class="line">                route-&gt;connected);  </span><br><span class="line">        ......  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>snd_soc_dapm_add_path函数是整个调用链条中的关键，我们来分析一下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">snd_soc_dapm_add_path</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *wsource, struct snd_soc_dapm_widget *wsink,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">char</span> *control,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> (*connected)</span><span class="params">(struct snd_soc_dapm_widget *source,  </span></span></span><br><span class="line">                         struct snd_soc_dapm_widget *sink))  </span><br><span class="line">&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">snd_soc_dapm_path</span> *<span class="title">path</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> ret;  </span><br><span class="line">  </span><br><span class="line">        path = kzalloc(<span class="keyword">sizeof</span>(struct snd_soc_dapm_path), GFP_KERNEL);  </span><br><span class="line">        <span class="keyword">if</span> (!path)  </span><br><span class="line">                <span class="keyword">return</span> -ENOMEM;  </span><br><span class="line">  </span><br><span class="line">        path-&gt;source = wsource;  </span><br><span class="line">        path-&gt;sink = wsink;  </span><br><span class="line">        path-&gt;connected = connected;  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;<span class="built_in">list</span>);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_kcontrol);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_source);  </span><br><span class="line">        INIT_LIST_HEAD(&amp;path-&gt;list_sink);</span><br></pre></td></tr></table></figure><p>函数的一开始，首先为这个连接分配了一个snd_soc_path结构，path的source和sink字段分别指向源widget和目的widget，connected字段保存connected回调函数，初始化几个snd_soc_path结构中的几个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* check for external widgets */</span>  </span><br><span class="line">        <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_input) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_micbias ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_mic ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsource-&gt;id == snd_soc_dapm_output)  </span><br><span class="line">                        wsink-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (wsource-&gt;id == snd_soc_dapm_output) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (wsink-&gt;id == snd_soc_dapm_spk ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_hp ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_line ||  </span><br><span class="line">                        wsink-&gt;id == snd_soc_dapm_input)  </span><br><span class="line">                        wsource-&gt;ext = <span class="number">1</span>;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这段代码用于判断是否有外部连接关系，如果有，置位widget的ext字段。判断方法从代码中可以方便地看出：<br>目的widget是一个输入脚，如果源widget是mic、line、micbias或output，则认为目的widget具有外部连接关系。<br>源widget是一个输出脚，如果目的widget是spk、hp、line或input，则认为源widget具有外部连接关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">dapm_mark_dirty(wsource, <span class="string">"Route added"</span>);  </span><br><span class="line">dapm_mark_dirty(wsink, <span class="string">"Route added"</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* connect static paths */</span>  </span><br><span class="line"><span class="keyword">if</span> (control == <span class="literal">NULL</span>) &#123;  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为增加了连结关系，所以把源widget和目的widget加入到dapm_dirty链表中。如果没有kcontrol来控制该连接关系，则这是一个静态连接，直接用path把它们连接在一起。在接着往下看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="comment">/* connect dynamic paths */</span>  </span><br><span class="line"><span class="keyword">switch</span> (wsink-&gt;id) &#123;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_adc:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dac:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pga:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_out_drv:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_input:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_output:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_siggen:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_micbias:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_vmid:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_pre:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_post:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_regulator_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_clock_supply:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_aif_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_in:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_out:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_dai_link:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_kcontrol:  </span><br><span class="line">        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">        list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">        list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">        path-&gt;connect = <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>按照目的widget来判断，如果属于以上这些类型，直接把它们连接在一起即可，这段感觉有点多余，因为通常以上这些类型的widget本来也没有kcontrol，直接用上一段代码就可以了，也许是dapm的作者们想着以后可能会有所扩展吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_virt_mux:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_value_mux:  </span><br><span class="line">        ret = dapm_connect_mux(dapm, wsource, wsink, path, control,  </span><br><span class="line">                &amp;wsink-&gt;kcontrol_news[<span class="number">0</span>]);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_switch:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer:  </span><br><span class="line"><span class="keyword">case</span> snd_soc_dapm_mixer_named_ctl:  </span><br><span class="line">        ret = dapm_connect_mixer(dapm, wsource, wsink, path, control);  </span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">goto</span> err;  </span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>目的widget如果是mixer和mux类型，分别用dapm_connect_mixer和dapm_connect_mux函数完成连接工作，这两个函数我们后面再讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c:snd_soc_dapm_add_path()]</span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_hp:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_mic:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_line:  </span><br><span class="line">        <span class="keyword">case</span> snd_soc_dapm_spk:  </span><br><span class="line">                list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                list_add(&amp;path-&gt;list_sink, &amp;wsink-&gt;sources);  </span><br><span class="line">                list_add(&amp;path-&gt;list_source, &amp;wsource-&gt;sinks);  </span><br><span class="line">                path-&gt;connect = <span class="number">0</span>;  </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">err:  </span><br><span class="line">        kfree(path);  </span><br><span class="line">        <span class="keyword">return</span> ret;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hp、mic、line和spk这几种widget属于外部器件，也只是简单地连接在一起，不过connect字段默认为是未连接状态。<br>现在，我们回过头来看看目的widget是mixer和mux这两种类型时的连接方式：<br>dapm_connect_mixer  用该函数连接一个目的widget为mixer类型的所有输入端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mixer</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* search for mixer kcontrol */</span>  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; dest-&gt;num_kcontrols; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(control_name, dest-&gt;kcontrol_news[i].name)) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = dest-&gt;kcontrol_news[i].name;  </span><br><span class="line">                        dapm_set_path_status(dest, path, i);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用需要用来连接的kcontrol的名字，和目的widget中的kcontrol模板数组中的名字相比较，找出该kcontrol在widget中的编号，path的名字设置为该kcontrol的名字，然后用dapm_set_path_status函数来初始化该输入端的连接状态。连接两个widget的链表操作和其他widget是一样的。</p><p>dapm_connect_mux 用该函数连接一个目的widget是mux类型的所有输入端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;/sound/soc/soc-dapm.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dapm_connect_mux</span><span class="params">(struct snd_soc_dapm_context *dapm,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_widget *src, struct snd_soc_dapm_widget *dest,  </span></span></span><br><span class="line"><span class="function"><span class="params">        struct snd_soc_dapm_path *path, <span class="keyword">const</span> <span class="keyword">char</span> *control_name,  </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> struct snd_kcontrol_new *kcontrol)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">soc_enum</span> *<span class="title">e</span> = (<span class="title">struct</span> <span class="title">soc_enum</span> *)<span class="title">kcontrol</span>-&gt;<span class="title">private_value</span>;</span>  </span><br><span class="line">        <span class="keyword">int</span> i;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; e-&gt;max; i++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (!(<span class="built_in">strcmp</span>(control_name, e-&gt;texts[i]))) &#123;  </span><br><span class="line">                        list_add(&amp;path-&gt;<span class="built_in">list</span>, &amp;dapm-&gt;card-&gt;paths);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_sink, &amp;dest-&gt;sources);  </span><br><span class="line">                        list_add(&amp;path-&gt;list_source, &amp;src-&gt;sinks);  </span><br><span class="line">                        path-&gt;name = (<span class="keyword">char</span>*)e-&gt;texts[i];  </span><br><span class="line">                        dapm_set_path_status(dest, path, <span class="number">0</span>);  </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> -ENODEV;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和mixer类型一样用名字进行匹配，只不过mux类型的kcontrol只需一个，所以要通过private_value字段所指向的soc_enum结构找出匹配的输入脚编号，最后也是通过dapm_set_path_status函数来初始化该输入端的连接状态，因为只有一个kcontrol，所以第三个参数是0。连接两个widget的链表操作和其他widget也是一样的。<br>dapm_set_path_status    该函数根据传入widget中的kcontrol编号，读取实际寄存器的值，根据寄存器的值来初始化这个path是否处于连接状态，详细的代码这里就不贴了。<br>当widget之间通过path进行连接之后，他们之间的关系就如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/210-Audio-system-snd_soc_dapm_path.png" alt="Alt text"></p><p>到这里为止，我们为声卡创建并初始化好了所需的widget，各个widget也通过path连接在了一起，接下来，dapm等待用户的指令，一旦某个dapm kcontrol被用户空间改变，利用这些连接关系，dapm会重新创建音频路径，脱离音频路径的widget会被下电，加入音频路径的widget会被上电，所有的上下电动作都会自动完成，用户空间的应用程序无需关注这些变化，它只管按需要改变某个dapm kcontrol即可。</p><h4 id="（八）、tinyplay-playback、capture"><a href="#（八）、tinyplay-playback、capture" class="headerlink" title="（八）、tinyplay playback、capture"></a>（八）、tinyplay playback、capture</h4><h5 id="8-1、tinyplay-playback"><a href="#8-1、tinyplay-playback" class="headerlink" title="8.1、tinyplay playback"></a>8.1、tinyplay playback</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/211-tiny-capture.png" alt="Alt text"></p><p>有时序图可知：主要涉及pcm_open()、pcm_write()、pcm_prepare()、pcm_start()。</p><h5 id="8-1-1、使用耳机播放"><a href="#8-1-1、使用耳机播放" class="headerlink" title="8.1.1、使用耳机播放"></a>8.1.1、使用耳机播放</h5><ol><li>启动音频播放</li><li>启用 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘RX1’<br>tinymix ‘RX2 MIX1 INP1’ ‘RX2’<br>tinymix ‘RDAC2 MUX’ ‘RX2’<br>tinymix ‘HPHL’ ‘Switch’<br>tinymix ‘HPHR’ ‘Switch’<br>tinymix ‘MI2S_RX Channels’ ‘Two</li><li>启用用于通过 MI2S 接口进行播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 1</li><li>播放 PCM 音频<br>tinyplay <filename.wav> </filename.wav></li><li>停止音频播放</li><li>禁用接收 Rx codec 路径<br>tinymix ‘RX1 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RX2 MIX1 INP1’ ‘ZERO’<br>tinymix ‘RDAC2 MUX’ ‘ZERO’<br>tinymix ‘HPHL’ ‘ZERO’<br>tinymix ‘HPHR’ ‘ZERO’<br>tinymix ‘MI2S_RX Channels’ ‘One’</li><li>禁用用于通过 I2S 接口进行音频播放的 DSP AFE<br>tinymix ‘PRI_MI2S_RX Audio Mixer MultiMedia1’ 0</li></ol><h5 id="8-2、tinyplay-capture"><a href="#8-2、tinyplay-capture" class="headerlink" title="8.2、tinyplay capture"></a>8.2、tinyplay capture</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/212-tiny-playback.png" alt="Alt text"></p><p>有时序图可知：主要涉及pcm_open()、pcm_read()、pcm_start()。</p><h5 id="8-2-1、使用音频录制"><a href="#8-2-1、使用音频录制" class="headerlink" title="8.2.1、使用音频录制"></a>8.2.1、使用音频录制</h5><ol><li>输入以下命令：<br>//Enable DSP AFE for Audio Recording over I2S<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 1<br>//Enable Codec TX Path<br>tinymix ‘DEC1 MUX’ ‘ADC2’<br>tinymix ‘ADC2 MUX’ ‘INP2’</li><li>启动录音功能：<br>tinycap /data/rec.wav</li><li>禁用 HeadsetX 设备 (AMIC2)：<br>tinymix ‘MultiMedia1 Mixer TERT_MI2S_TX’ 0<br>tinymix ‘DEC1 MUX’ ‘ZERO’<br>tinymix ‘ADC2 MUX’ ‘ZERO’</li></ol><h4 id="（九）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（九）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（九）、参考资料(特别感谢各位前辈的分析和图示)："></a>（九）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析</title>
    <link href="http://zhoujinjian.cc/2018/05/01/Audio%20System%EF%BC%881%EF%BC%89%EF%BC%9ALinux%20&amp;&amp;%20Android%20Audio%20%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://zhoujinjian.cc/2018/05/01/Audio System（1）：Linux &amp;&amp; Android Audio 系统框架分析/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-09T15:03:51.779Z</updated>
    
    <content type="html"><![CDATA[<hr><p>注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;&amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内容整理自互联网，如有侵权，请联系删除，禁止转载（©Qualcomm Technologies, Inc. 版权所有），谢谢。</p><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/audio.system" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：<br> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><p>AOSP 源码（Android 7.1.2）：<br> <a href="https://testerhome.com/topics/2229" target="_blank" rel="noopener"> Android 系统全套源代码分享 (更新到 8.1.0_r1)</a></p><hr><h4 id="（一）、音频基础知识"><a href="#（一）、音频基础知识" class="headerlink" title="（一）、音频基础知识"></a>（一）、音频基础知识</h4><p>理解音频的一些基础知识，对于我们分析整个音频系统是大有裨益的。它可以让我们从实现的层面去思考，音频系统的目的是什么，然后才是怎么样去完成这个目的</p><p>#####（1）声音有哪些重要属性呢？</p><h5 id="1-1、响度-Loudness"><a href="#1-1、响度-Loudness" class="headerlink" title="1.1、响度(Loudness)"></a>1.1、响度(Loudness)</h5><p>响度就是人类可以感知到的各种声音的大小，也就是音量。响度与声波的振幅有直接关系。</p><h5 id="1-2、音调-Pitch"><a href="#1-2、音调-Pitch" class="headerlink" title="1.2、音调(Pitch)"></a>1.2、音调(Pitch)</h5><p>音调与声音的频率有关系，当声音的频率越大时，人耳所感知到的音调就越高，否则就越低。</p><h5 id="1-3、音色-Quality"><a href="#1-3、音色-Quality" class="headerlink" title="1.3、音色(Quality)"></a>1.3、音色(Quality)</h5><p>同一种乐器，使用不同的材质来制作，所表现出来的音色效果是不一样的，这是由物体本身的结构特性所决定的。</p><p>如何将各种媒体源数字化呢？<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/11-Audio-system-1024px-A-D-A_Flow.svg.png" alt="Alt text"></p><p>将声波波形信号通过ADC转换成计算机支持的二进制的过程叫做音频采样(Audio Sampling)。采样(Sampling)的核心是把连续的模拟信号转换成离散的数字信号。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/12-Audio-system-sampling.png" alt="Alt text"></p><h5 id="1-4、样本-Sample"><a href="#1-4、样本-Sample" class="headerlink" title="1.4、样本(Sample)"></a>1.4、样本(Sample)</h5><p>这是我们进行采样的初始资料，比如一段连续的声音波形。</p><h5 id="1-5、采样器-Sampler"><a href="#1-5、采样器-Sampler" class="headerlink" title="1.5、采样器(Sampler)"></a>1.5、采样器(Sampler)</h5><p>采样器是将样本转换成终态信号的关键。它可以是一个子系统，也可以指一个操作过程，甚至是一个算法，取决于不同的信号处理场景。理想的采样器要求尽可能不产生信号失真。</p><h5 id="1-6、量化-Quantization"><a href="#1-6、量化-Quantization" class="headerlink" title="1.6、量化(Quantization)"></a>1.6、量化(Quantization)</h5><p>采样后的值还需要通过量化，也就是将连续值近似为某个范围内有限多个离散值的处理过程。因为原始数据是模拟的连续信号，而数字信号则是离散的，它的表达范围是有限的，所以量化是必不可少的一个步骤。</p><h5 id="1-7、编码-Coding"><a href="#1-7、编码-Coding" class="headerlink" title="1.7、编码(Coding)"></a>1.7、编码(Coding)</h5><p>计算机的世界里，所有数值都是用二进制表示的，因而我们还需要把量化值进行二进制编码。这一步通常与量化同时进行。</p><h5 id="1-8、采样率（samplerate）"><a href="#1-8、采样率（samplerate）" class="headerlink" title="1.8、采样率（samplerate）"></a>1.8、采样率（samplerate）</h5><p>采样就是把模拟信号数字化的过程，不仅仅是音频需要采样，所有的模拟信号都需要通过采样转换为可以用0101来表示的数字信号，示意图如下所示：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/13-Audio-system-sampling-rate.png.png" alt="Alt text"></p><p>蓝色代表模拟音频信号，红色的点代表采样得到的量化数值。</p><p>采样频率越高，红色的间隔就越密集，记录这一段音频信号所用的数据量就越大，同时音频质量也就越高。</p><p>根据奈奎斯特理论，采样频率只要不低于音频信号最高频率的两倍，就可以无损失地还原原始的声音。</p><p>通常人耳能听到频率范围大约在20Hz～20kHz之间的声音，为了保证声音不失真，采样频率应在40kHz以上。常用的音频采样频率有：8kHz、11.025kHz、22.05kHz、16kHz、37.8kHz、44.1kHz、48kHz、96kHz、192kHz等。</p><h5 id="1-9、量化精度（位宽）"><a href="#1-9、量化精度（位宽）" class="headerlink" title="1.9、量化精度（位宽）"></a>1.9、量化精度（位宽）</h5><p>上图（1.8）中，每一个红色的采样点，都需要用一个数值来表示大小，这个数值的数据类型大小可以是：4bit、8bit、16bit、32bit等等，位数越多，表示得就越精细，声音质量自然就越好，当然，数据量也会成倍增大。</p><p>常见的位宽是：8bit 或者 16bit</p><h5 id="1-10、-声道数（channels）"><a href="#1-10、-声道数（channels）" class="headerlink" title="1.10、 声道数（channels）"></a>1.10、 声道数（channels）</h5><p>由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。</p><p>单声道（Mono）和双声道（Stereo）比较常见，顾名思义，前者的声道数为1，后者为2</p><h5 id="1-11、音频帧（frame）"><a href="#1-11、音频帧（frame）" class="headerlink" title="1.11、音频帧（frame）"></a>1.11、音频帧（frame）</h5><p>这个概念在应用开发中非常重要，网上很多文章都没有专门介绍这个概念。</p><p>音频跟视频很不一样，视频每一帧就是一张图像，而从上面的正玄波可以看出，音频数据是流式的，本身没有明确的一帧帧的概念，在实际的应用中，为了音频算法处理/传输的方便，一般约定俗成取2.5ms~60ms为单位的数据量为一帧音频。</p><p>这个时间被称之为“采样时间”，其长度没有特别的标准，它是根据编解码器和具体应用的需求来决定的，我们可以计算一下一帧音频帧的大小：</p><p>假设某音频信号是采样率为8kHz、双通道、位宽为16bit，20ms一帧，则一帧音频数据的大小为：</p><p>int size = 8000 x 2 x 16bit x 0.02s = 5120 bit = 640 byte</p><h5 id="1-12、常见的音频编码方式有哪些？"><a href="#1-12、常见的音频编码方式有哪些？" class="headerlink" title="1.12、常见的音频编码方式有哪些？"></a>1.12、常见的音频编码方式有哪些？</h5><p>上面提到过，模拟的音频信号转换为数字信号需要经过采样和量化，量化的过程被称之为编码，根据不同的量化策略，产生了许多不同的编码方式，常见的编码方式有：PCM 和 ADPCM，这些数据代表着无损的原始数字音频信号，添加一些文件头信息，就可以存储为WAV文件了，它是一种由微软和IBM联合开发的用于音频数字存储的标准，可以很容易地被解析和播放。</p><p>我们在音频开发过程中，会经常涉及到WAV文件的读写，以验证采集、传输、接收的音频数据的正确性。</p><h5 id="1-13、常见的音频压缩格式有哪些？"><a href="#1-13、常见的音频压缩格式有哪些？" class="headerlink" title="1.13、常见的音频压缩格式有哪些？"></a>1.13、常见的音频压缩格式有哪些？</h5><p>首先简单介绍一下音频数据压缩的最基本的原理：因为有冗余信息，所以可以压缩。</p><p>（1） 频谱掩蔽效应： 人耳所能察觉的声音信号的频率范围为20Hz～20KHz，在这个频率范围以外的音频信号属于冗余信号。</p><p>（2） 时域掩蔽效应： 当强音信号和弱音信号同时出现时，弱信号会听不到，因此，弱音信号也属于冗余信号。</p><p>下面简单列出常见的音频压缩格式：</p><p>MP3，AAC，OGG，WMA，Opus，FLAC，APE，M4A，AMR，等等</p><h5 id="1-14、奈奎斯特采样理论"><a href="#1-14、奈奎斯特采样理论" class="headerlink" title="1.14、奈奎斯特采样理论"></a>1.14、奈奎斯特采样理论</h5><p>“当对被采样的模拟信号进行还原时，其最高频率只有采样频率的一半”。<br>换句话说，如果我们要完整重构原始的模拟信号，则采样频率就必须是它的两倍以上。比如人的声音范围是2~ 20kHZ,那么选择的采样频率就应该在40kHZ左右，数值太小则声音将产生失真现象，而数值太大也无法明显提升人耳所能感知的音质。</p><h5 id="1-15、总结（音频处理和播放过程）："><a href="#1-15、总结（音频处理和播放过程）：" class="headerlink" title="1.15、总结（音频处理和播放过程）："></a>1.15、总结（音频处理和播放过程）：</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/14-Audio-system-how-audio-works.png" alt="Alt text"></p><h4 id="（二）、Audio-系统框架"><a href="#（二）、Audio-系统框架" class="headerlink" title="（二）、Audio 系统框架"></a>（二）、Audio 系统框架</h4><h5 id="总体Audio框架图"><a href="#总体Audio框架图" class="headerlink" title="总体Audio框架图"></a>总体Audio框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/15-Audio-system-Android-Linux-arc.png" alt="Alt text"></p><h5 id="2-1、APP"><a href="#2-1、APP" class="headerlink" title="2.1、APP"></a>2.1、APP</h5><p>音乐播放器软件等等。</p><h5 id="2-2、Framework"><a href="#2-2、Framework" class="headerlink" title="2.2、Framework"></a>2.2、Framework</h5><p>Android也提供了另两个相似功能的类，即AudioTrack和AudioRecorder，MediaPlayerService内部的实现就是通过它们来完成的,只不过MediaPlayer/MediaRecorder提供了更强大的控制功能，相比前者也更易于使用。除此以外，Android系统还为我们控制音频系统提供了AudioManager、AudioService及AudioSystem类。这些都是framework为便利上层应用开发所设计的。</p><h5 id="2-3、Libraries"><a href="#2-3、Libraries" class="headerlink" title="2.3、Libraries"></a>2.3、Libraries</h5><p>framework只是向应用程序提供访问Android库的桥梁，具体功能实现放在库中完成。比如上面的AudioTrack、AudioRecorder、MediaPlayer和MediaRecorder等等在库中都能找到相对应的类。</p><p>1、frameworks/av/media/libmedia【libmedia.so】<br>2、frameworks/av/services/audioflinger【libaudioflinger.so】<br>3、frameworks/av/media/libmediaplayerservice【libmediaplayerservice.so】</p><h5 id="2-4、HAL"><a href="#2-4、HAL" class="headerlink" title="2.4、HAL"></a>2.4、HAL</h5><p>从设计上来看，硬件抽象层是AudioFlinger直接访问的对象。这说明了两个问题，一方面AudioFlinger并不直接调用底层的驱动程序;另一方面，AudioFlinger上层模块只需要与它进行交互就可以实现音频相关的功能了。因而我们可以认为AudioFlinger是Android音频系统中真正的“隔离板”，无论下面如何变化，上层的实现都可以保持兼容。</p><p>音频方面的硬件抽象层主要分为两部分，即AudioFlinger和AudioPolicyService。实际上后者并不是一个真实的设备，只是采用虚拟设备的方式来让厂商可以方便地定制出自己的策略。抽象层的任务是将AudioFlinger/AudioPolicyService真正地与硬件设备关联起来，但又必须提供灵活的结构来应对变化——特别是对于Android这个更新相当频繁的系统。比如以前Android系统中的Audio系统依赖于ALSA-lib，但后期就变为了tinyalsa，这样的转变不应该对上层造成破坏。因而Audio HAL提供了统一的接口来定义它与AudioFlinger/AudioPolicyService之间的通信方式，这就是audio_hw_device、audio_stream_in及audio_stream_out等等存在的目的，这些Struct数据类型内部大多只是函数指针的定义，是一些“壳”。当AudioFlinger/AudioPolicyService初始化时，它们会去寻找系统中最匹配的实现(这些实现驻留在以audio.primary.<em>,audio.a2dp.</em>为名的各种库中)来填充这些“壳”。根据产品的不同，音频设备存在很大差异，在Android的音频架构中，这些问题都是由HAL层的audio.primary等等库来解决的，而不需要大规模地修改上层实现。换句话说，厂商在定制时的重点就是如何提供这部分库的高效实现了。</p><h5 id="2-5、Tinyalsa"><a href="#2-5、Tinyalsa" class="headerlink" title="2.5、Tinyalsa"></a>2.5、Tinyalsa</h5><p>源码在external/tinyalsa目录下<br>Tinyalsa：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制</p><h5 id="2-6、Kernel部分"><a href="#2-6、Kernel部分" class="headerlink" title="2.6、Kernel部分"></a>2.6、Kernel部分</h5><h5 id="2-6-1、ALSA-和-ASoC"><a href="#2-6-1、ALSA-和-ASoC" class="headerlink" title="2.6.1、ALSA 和 ASoC"></a>2.6.1、ALSA 和 ASoC</h5><p>Native ALSA Application：tinyplay/tinycap/tinymix，这些用户程序直接调用 alsa 用户库接口来实现放音、录音、控制<br>ALSA Library API：alsa 用户库接口，常见有 tinyalsa、alsa-lib<br>ALSA CORE：alsa 核心层，向上提供逻辑设备（PCM/CTL/MIDI/TIMER/…）系统调用，向下驱动硬件设备（Machine/I2S/DMA/CODEC）<br>ASoC CORE：asoc 是建立在标准 alsa core 基础上，为了更好支持嵌入式系统和应用于移动设备的音频 codec 的一套软件体系<br>Hardware Driver：音频硬件设备驱动，由三大部分组成，分别是 Machine、Platform、Codec</p><h5 id="2-6-2、ASoC"><a href="#2-6-2、ASoC" class="headerlink" title="2.6.2、ASoC"></a>2.6.2、ASoC</h5><p>ASoC被分为Machine、Platform和Codec三大部分。其中的Machine驱动负责Platform和Codec之间的耦合和设备或板子特定的代码。Platform驱动的主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。</p><h5 id="2-6-2-1、Machine"><a href="#2-6-2-1、Machine" class="headerlink" title="2.6.2.1、Machine"></a>2.6.2.1、<strong>Machine</strong></h5><p>用于描述设备组件信息和特定的控制如耳机/外放等。</p><blockquote><p>是指某一款机器，可以是某款设备，某款开发板，又或者是某款智能手机，由此可以看出Machine几乎是不可重用的，每个Machine上的硬件实现可能都不一样，CPU不一样，Codec不一样，音频的输入、输出设备也不一样，Machine为CPU、Codec、输入输出设备提供了一个载体。</p></blockquote><p>这一部分将平台驱动和Codec驱动绑定在一起，描述了板级的硬件特征。主要负责Platform和Codec之间的耦合以及部分和设备或板子特定的代码。Machine驱动负责处理机器特有的一些控件和音频事件（例如，当播放音频时，需要先行打开一个放大器）；单独的Platform和Codec驱动是不能工作的，它必须由Machine驱动把它们结合在一起才能完成整个设备的音频处理工作。ASoC的一切都从Machine驱动开始，包括声卡的注册，绑定Platform和Codec驱动等等</p><h5 id="2-6-2-2、Platform"><a href="#2-6-2-2、Platform" class="headerlink" title="2.6.2.2、Platform"></a>2.6.2.2、<strong>Platform</strong></h5><p>用于实现平台相关的DMA驱动和音频接口等。</p><blockquote><p>一般是指某一个SoC平台，比如pxaxxx,s3cxxxx,omapxxx等等，与音频相关的通常包含该SoC中的时钟、DMA、I2S、PCM等等，只要指定了SoC，那么我们可以认为它会有一个对应的Platform，它只与SoC相关，与Machine无关，这样我们就可以把Platform抽象出来，使得同一款SoC不用做任何的改动，就可以用在不同的Machine中。实际上，把Platform认为是某个SoC更好理解。</p></blockquote><p>这一部分只关心CPU本身，不关心Codec。主要处理两个问题：DMA引擎和SoC集成的PCM、I2S或AC ‘97数字接口控制。主要作用是完成音频数据的管理，最终通过CPU的数字音频接口（DAI）把音频数据传送给Codec进行处理，最终由Codec输出驱动耳机或者是喇叭的音信信号。在具体实现上，ASoC有把Platform驱动分为两个部分：snd_soc_platform_driver和snd_soc_dai_driver。其中，platform_driver负责管理音频数据，把音频数据通过dma或其他操作传送至cpu dai中，dai_driver则主要完成cpu一侧的dai的参数配置，同时也会通过一定的途径把必要的dma等参数与snd_soc_platform_driver进行交互。</p><h5 id="2-6-2-3、Codec"><a href="#2-6-2-3、Codec" class="headerlink" title="2.6.2.3、Codec"></a>2.6.2.3、<strong>Codec</strong></h5><p>用于实现平台无关的功能，如寄存器读写接口，音频接口，各widgets的控制接口和DAPM的实现等</p><blockquote><p>字面上的意思就是编解码器，Codec里面包含了I2S接口、D/A、A/D、Mixer、PA（功放），通常包含多种输入（Mic、Line-in、I2S、PCM）和多个输出（耳机、喇叭、听筒，Line-out），Codec和Platform一样，是可重用的部件，同一个Codec可以被不同的Machine使用。嵌入式Codec通常通过I2C对内部的寄存器进行控制。</p></blockquote><p>这一部分只关心Codec本身，与CPU平台相关的特性不由此部分操作。在移动设备中，Codec的作用可以归结为4种，分别是：</p><p>1、对PCM等信号进行D/A转换，把数字的音频信号转换为模拟信号。<br>2、对Mic、Linein或者其他输入源的模拟信号进行A/D转换，把模拟的声音信号转变CPU能够处理的数字信号。<br>3、对音频通路进行控制，比如播放音乐，收听调频收音机，又或者接听电话时，音频信号在codec内的流通路线是不一样的。<br>4、对音频信号做出相应的处理，例如音量控制，功率放大，EQ控制等等。</p><p>ASoC对Codec的这些功能都定义好了一些列相应的接口，以方便地对Codec进行控制。ASoC对Codec驱动的一个基本要求是：驱动程序的代码必须要做到平台无关性，以方便同一个Codec的代码不经修改即可用在不同的平台上。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/16-Audio-system-asoc-pcm-control.png" alt="Alt text"></p><p>ASoC对于Alsa来说，就是分别注册PCM/CONTROL类型的snd_device设备，并实现相应的操作方法集。图中DAI是数字音频接口，用于配置音频数据格式等。</p><p>☁ Codec驱动向ASoC注册snd_soc_codec和snd_soc_dai设备。<br>☁ Platform驱动向ASoC注册snd_soc_platform和snd_soc_dai设备。<br>☁ Machine驱动通过snd_soc_dai_link绑定codec/dai/platform。</p><p>Widget是各个组件内部的小单元。处在活动通路上电，不在活动通路下电。ASoC的DAPM正是通过控制这些Widget的上下电达到动态电源管理的效果。</p><p>☁ path描述与其它widget的连接关系。<br>☁ event用于通知该widget的上下电状态。<br>☁ power指示当前的上电状态。<br>☁ control实现空间用户接口用于控制widget的音量/通路切换等。</p><p>对驱动开者来说，就可以很好的解耦了：</p><p>☁ codec驱动的开发者，实现codec的IO读写方法，描述DAI支持的数据格式/操作方法和Widget的连接关系就可以了;<br>☁ soc芯片的驱动开发者，Platform实现snd_pcm的操作方法集和DAI的配置如操作 DMA，I2S/AC97/PCM的设定等;<br>☁ 板级的开发者，描述Machine上codec与platform之间的总线连接， earphone/Speaker的布线情况就可以了。</p><h5 id="2-6-3、DAPM"><a href="#2-6-3、DAPM" class="headerlink" title="2.6.3、DAPM"></a>2.6.3、<strong>DAPM</strong></h5><p> DAPM是Dynamic Audio Power Management的缩写，直译过来就是动态音频电源管理的意思，DAPM是为了使基于linux的移动设备上的音频子系统，在任何时候都工作在最小功耗状态下。DAPM对用户空间的应用程序来说是透明的，所有与电源相关的开关都在ASoc core中完成。用户空间的应用程序无需对代码做出修改，也无需重新编译，DAPM根据当前激活的音频流（playback/capture）和声卡中的mixer等的配置来决定那些音频控件的电源开关被打开或关闭。</p><h5 id="2-6-4、DPCM"><a href="#2-6-4、DPCM" class="headerlink" title="2.6.4、DPCM"></a>2.6.4、<strong>DPCM</strong></h5><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/Documentation/sound/soc/dpcm.rst?h=v4.16-rc5" target="_blank" rel="noopener">Dynamic PCM</a></p><h5 id="2-7、Audio-devices"><a href="#2-7、Audio-devices" class="headerlink" title="2.7、Audio devices"></a>2.7、Audio devices</h5><p>具体的Audio硬件设备。</p><h4 id="（三）、Qualcomm平台-Audio系统框架"><a href="#（三）、Qualcomm平台-Audio系统框架" class="headerlink" title="（三）、Qualcomm平台 - Audio系统框架"></a>（三）、Qualcomm平台 - Audio系统框架</h4><p>由于接下来的一系列Android &amp;&amp; kernel 源码分析都是基于Qualcomm 平台的，十分有必要介绍Qualcomm 平台的Audio 系统框架。硬件平台及软件版本：<br>☁ Kernel - 3.18<br>☁ SoC - Qualcomm snapdragon<br>☁ CODEC - WCD9335<br>☁ Machine - msm8996<br>☁ Userspace - tinyalsa</p><h5 id="3-1、Qualcomm-Audio系统总体框架图"><a href="#3-1、Qualcomm-Audio系统总体框架图" class="headerlink" title="3.1、Qualcomm Audio系统总体框架图"></a>3.1、Qualcomm Audio系统总体框架图</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/17-MSM8996-Linux-Android-Audio-Software-Overview-Architecture.png" alt="Alt text"></p><h5 id="3-2、ASoC-driver"><a href="#3-2、ASoC-driver" class="headerlink" title="3.2、ASoC driver"></a>3.2、ASoC driver</h5><p>ALSA 片上系统 (ASoC) 驱动程序将音频系统分为四个组成部分Machine driver、Platform driver、CPU driver、Codec driver。</p><h5 id="3-2-1、Machine-driver"><a href="#3-2-1、Machine-driver" class="headerlink" title="3.2.1、Machine driver"></a>3.2.1、Machine driver</h5><p>将平台、CPU 和编解码驱动程序整合在一起<br>kernel/sound/soc/msm/<chipset>.c<br>定义Frontend (FE) and Backend (BE), Digital Audio Interface (DAI) links</chipset></p><h5 id="3-2-2、Platform-driver"><a href="#3-2-2、Platform-driver" class="headerlink" title="3.2.2、Platform driver"></a>3.2.2、Platform driver</h5><p>包含用于流数据传输与路由的平台特定的控件（control）， 细分为 FE 和 BE 平台驱动程序<br><strong>FE</strong><br> Audio – 实例化 PCM 播放和录制会话；借助 ASM 接口，将 PCM 数据从用户空间传输到 DSP 进行播放<br>以及从 DSP 传输到用户空间进行录制 – 在 kernel/sound/soc/msm-pcm-q6-v2.c 中实现<br> Voice – 初始化/取消初始化语音呼叫设置 – 在 kernel/sound/soc/msm-pcm-voice-v2.c 中实现<br> VoIP – 初始化/取消初始化 MVS 接口以传输自/至 DSP 的 PCM 数据 – 在kernel/sound/soc/msm-pcmvoip-v2.c<br>中实现<br> Compressed offload – 支持将压缩数据发送到 DSP 进行压缩分流播放 – 在 kernel/sound/soc/msm-compress-q6-<br>v2.c 中实现<br><strong>BE</strong><br> 路由 – 执行音频路由任务 – 在 /kernel/sound/soc/msm-pcm-routing-v2.c 中实现</p><h5 id="3-2-3、CPU-driver"><a href="#3-2-3、CPU-driver" class="headerlink" title="3.2.3、CPU driver"></a>3.2.3、CPU driver</h5><p><strong>FE</strong><br> 向 ASoC 框架提供关于 FE PCM 设备的信息<br> ASoC 框架与平台驱动程序提供的路由表共同将 PCM 播放/捕获从 FE 传递至 BE<br> 没有针对播放和录制的内置逻辑<br> 定义 FE CPU DAI – 在 kernel/sound/soc/msm/msm-dai-fe.c 中实现<br><strong>BE</strong><br> 要在初始化 PCM 播放/捕获时激活所需音频硬件端口，则配置 DSP AFE 模块<br> 定义 BE CPU DAI – 在 kernel/sound/soc/msm/qdsp6v2/msm-dai-q6-v2.c 中实现</p><h5 id="3-2-4、Codec-driver"><a href="#3-2-4、Codec-driver" class="headerlink" title="3.2.4、Codec driver"></a>3.2.4、Codec driver</h5><p>与平台无关，其中包含音频控制、音频接口功能、编解码器 DAPM 定义以及编解<br>码器输入输出功能<br> 此外，实现 MBHC 状态机，用于检测有线耳机插入/拔出、附件类型、连接器类型<br>和多按钮检测</p><h5 id="3-3、DSP-driver"><a href="#3-3、DSP-driver" class="headerlink" title="3.3、DSP driver"></a>3.3、DSP driver</h5><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/audio.system/18-MSM8996-Linux-Android-Audio-ADSP-Architecture.png" alt="Alt text"></p><p><strong>ASM（Audio Stream Manager）</strong><br> 用于与 DSP ASM 模块通信的接口<br> 提供将 PCM 数据路由至 DSP 的机制，支持按数据流进行后期处理/预处理<br><strong>ADM（Audio Device Manager）</strong><br> 允许在 DSP 中使用 ADM 服务<br> 配置 COPP 和路由矩阵<br> 与音频校准数据库 (ACDB) 进行通信，使用正确的校准数据配置 COPP<br> 将 ASM 会话 ID 路由至 ADM 会话<br><strong>AFE（Audio Front-End）</strong><br> 允许在 DSP 中使用 AFE 服务<br> 激活/禁用音频硬件端口<br> 子系统管理器 – 发生 MDSP 复位事件时，通知音频和语音驱动程序关闭待处理<br>会话、执行清理操作并等待一个指示 MDSP 已启动的事件<br><strong>APR（Asynchronous Packet Router）</strong><br> 为处理器间通信提供异步框架<br> 用于与 Hexagon 和调制解调器处理器进行通信<br> Image loader PIL  – 载入 MDSP 图像</p><h5 id="3-4、User-Space"><a href="#3-4、User-Space" class="headerlink" title="3.4、User Space"></a>3.4、User Space</h5><p> Audio Hardware Abstraction Layer (AHAL) – 通过 tinyALSA 将 AudioFlinger<br> 调用映射至ASoC 驱动程序的硬件抽象层。<br> ACDB loader – 检索特定设备的校准信息，并写入 PMEM。ACDB 驱动程<br>序在启动过程中分配该 PMEM。在设备切换时，此校准将被发送到 DSP。<br> tinyALSA – 连接至内核 ASoC 驱动程序的接口，供音频 HAL 使用。提供用<br>于音频流和设备管理的基本 PCM 和混音控件 API。<br> Audio route – 此模块会从一个 .xml 文件读取 ALSA 混音控件，并根据音频<br>HAL 所选的设备设置混音控件。<br> Concurrency Manager - 在MSM8x10中，视频解码和编码在DSP中完成; 因此，有<br>对可支持的并发性有一些限制。MSM8x10中引入的并发管理器管理并发性<br>可以支持涉及语音和音频的不同用例</p><p>Multimedia framework – Stagefright<br> 支持标准音频格式的播放/录制<br> 与解码器/编码器库以及 OpenMAX IL 组件通信，以便进行解码和编码</p><p>Audio service<br> 由系统服务器启动并由服务管理器管理的运行时服务之一<br> 意图注册；当从各种应用程序（HDMI、蓝牙等）接收到这些意图时，通知音频<br>系统</p><p>AudioFlinger<br> 通过 libaudio 接口、蓝牙 A2DP 接口管理所有音频输出/输入设备<br> 将多个音频流处理为单一的 PCM 音频；混合后的输出被传送到输出设备<br> 播放音乐流时的音量</p><p>Audio Policy Manager (APM)<br> 定义多个音频用例之间的并发规则<br> 用例示例 – 电话通话、音乐播放、系统声音和通知<br> 定义播放的音频（例如：语音、播放、铃声）以及播放的设备（蓝牙、扬声器<br>和耳机）<br>APM 用途：<br> 管理各种输入输出设备接口<br> 管理各种输入输出设备，例如：麦克风、扬声器、耳机、听筒、A2DP、蓝牙 SCO<br> 基于音频流、模式和方法选择和定义适当的路由策略<br> 管理每个音频流的音量/静音设置（在它们激活或禁用时）</p><h4 id="（四）、参考资料-特别感谢各位前辈的分析和图示-："><a href="#（四）、参考资料-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的分析和图示)："></a>（四）、参考资料(特别感谢各位前辈的分析和图示)：</h4><p><a href="https://zhuanlan.zhihu.com/p/27480328" target="_blank" rel="noopener">Android音频模块启动流程分析</a><br><a href="https://zhuanlan.zhihu.com/jhuster" target="_blank" rel="noopener">Jhuster的专栏​ Android音频开发</a><br><a href="http://thinks.me/2016/09/13/audio_qcom_offload/" target="_blank" rel="noopener">高通audio offload学习 | Thinking</a><br><a href="https://blog.csdn.net/droidphone/article/category/1118446" target="_blank" rel="noopener">DroidPhone的专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8866071" target="_blank" rel="noopener">alsa音频架构1-CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8982771" target="_blank" rel="noopener">alsa音频架构2-ASoc - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8995163" target="_blank" rel="noopener">alsa音频架构3-Pcm - CSDN博客</a><br><a href="https://blog.csdn.net/orz415678659/article/details/8999364" target="_blank" rel="noopener">alsa音频架构4-声卡控制 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59180272" target="_blank" rel="noopener">Linux ALSA 音频系统：逻辑设备篇 - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/59170418" target="_blank" rel="noopener">Linux ALSA 音频系统：物理链路篇 - CSDN博客</a><br><a href="https://blog.csdn.net/column/details/12812.html" target="_blank" rel="noopener">专栏：MultiMedia框架总结(基于6.0源码) - CSDN博客</a><br><a href="https://blog.csdn.net/zyuanyun/article/details/60890534" target="_blank" rel="noopener">Android 音频系统：从 AudioTrack 到 AudioFlinger - CSDN博客</a><br><a href="https://blog.csdn.net/azloong/article/category/778492" target="_blank" rel="noopener">AZURE - CSDN博客 - ALSA-Android Audio</a><br><a href="https://blog.csdn.net/azloong/article/category/777239" target="_blank" rel="noopener">AZURE - CSDN博客 - ANDROID音频系统</a><br><a href="https://winddoing.github.io/2017/07/10/audio_alsa/" target="_blank" rel="noopener">Audio驱动总结–ALSA | Winddoing’s Blog</a><br><a href="http://www.cnblogs.com/muhe221/articles/4461543.html" target="_blank" rel="noopener">audio HAL - 牧 天 - 博客园</a><br><a href="https://blog.csdn.net/xuesen_lin/article/category/1390680" target="_blank" rel="noopener">林学森的Android专栏 - CSDN博客</a><br><a href="https://blog.csdn.net/yangwen123/article/category/2589087" target="_blank" rel="noopener">深入剖析Android音频 - CSDN博客Yangwen123</a><br><a href="http://www.cnblogs.com/tocy/tag/%E6%92%AD%E6%94%BE%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">播放框架 - 标签 - Tocy - 博客园</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/57415505" target="_blank" rel="noopener">Android-7.0-Nuplayer概述 - CSDN博客</a><br><a href="https://blog.csdn.net/miaomiao12345678/article/details/56961370" target="_blank" rel="noopener">Android-7.0-Nuplayer-启动流程 - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53386010" target="_blank" rel="noopener">Android Media Player 框架分析-Nuplayer（1） - CSDN博客</a><br><a href="https://blog.csdn.net/harman_zjc/article/details/53397945" target="_blank" rel="noopener">Android Media Player 框架分析-AHandler AMessage ALooper - CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/category/6344583" target="_blank" rel="noopener">Android N Audio播放 start真面目- (六篇) CSDN博客</a><br><a href="https://blog.csdn.net/nonmarking/article/details/78746671" target="_blank" rel="noopener">深入理解Android音视频同步机制（五篇）NuPlayer的avsync逻辑 - CSDN博客</a><br><a href="https://blog.csdn.net/u014310046/article/category/6571854" target="_blank" rel="noopener">wangyf的专栏 - CSDN博客-MT6737 Android N 平台 Audio系统学习</a><br><a href="https://blog.csdn.net/xiashaohua/article/details/53638780" target="_blank" rel="noopener">Android 7.0 Audio: Mediaplayer - CSDN博客</a><br><a href="https://blog.csdn.net/xiashaohua/article/category/6549668" target="_blank" rel="noopener">Android 7.0 Audio-相关类浅析- CSDN博客</a><br><a href="https://blog.csdn.net/liu1314you/article/details/59119144" target="_blank" rel="noopener">Android N Audio播放六：如何读取buffer - CSDN博客</a><br><a href="https://blog.csdn.net/jinzhuojun/article/details/78007568" target="_blank" rel="noopener">Fuchsia OS中的RPC机制-FIDL - CSDN博客</a><br><a href="http://www.cnblogs.com/linhaostudy/category/1145404.html" target="_blank" rel="noopener">高通Audio中ASOC的codec驱动 - yooooooo - 博客园</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;注：文章都是通过阅读各位前辈总结的资料、Android 7.1.2 &amp;amp;&amp;amp; Linux（kernel 3.18）Qualcomm平台源码、加上自己的思考分析总结出来的，其中难免有理解不对的地方，欢迎大家批评指正。文章为个人学习、研究、欣赏之用，图文内
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功 [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/04/20/Google%20Pixel%20Oreo%208.1%20OPM2.171019.029%20Root%20%E4%BA%B2%E6%B5%8B%E6%88%90%E5%8A%9F/"/>
    <id>http://zhoujinjian.cc/2018/04/20/Google Pixel Oreo 8.1 OPM2.171019.029 Root 亲测成功/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-21T06:06:04.591Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">Root教程原文 Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP</a></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>✢ 电池电量高于80％。<br>✢ 数据会完全丢失不可恢复，请提前备份您的数据。<br>✢ 解锁你的Bootloader。<br>✢ 仅限Google Pixel Oreo 8.1。<br>✢ 仅限奥利奥版本。<br>✢ 笔者手机如图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/others/google-pixel.jpg" alt="enter image description here"></p><h4 id="一、解锁Bootloader"><a href="#一、解锁Bootloader" class="headerlink" title="一、解锁Bootloader"></a>一、解锁Bootloader</h4><p>在Google Pixel Oreo 8.1 OPM2.171019.029中解锁引导加载程序bootloader</p><h5 id="1-1、OEM解锁"><a href="#1-1、OEM解锁" class="headerlink" title="1.1、OEM解锁"></a>1.1、OEM解锁</h5><p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">解锁BootLoader教程 Unlocking Bootloader in Google Pixel and Pixel XL</a><br>✢ <a href="https://bitbucket.org/Serverbee/downloadbee/downloads/adb-setup-1.4.3.exe" target="_blank" rel="noopener">下载</a>（Windows）/<a href="https://bitbucket.org/Serverbee/downloadbee/downloads/adb-mac.zip" target="_blank" rel="noopener">下载</a>（Mac）相应的ADB、Fastboot、驱动程序并将其安装到您的系统中。<br>✢ 进入 设置-&gt;关于手机 连续点击5次版本号，直到提示”你已处于开发者模式，无需进行此操作”<br>✢ 点击返回进入 “开发者模式” 打开 “OEM解锁” 和 “USB调试”<br>✢ 连接手机，若弹出提示框请选择是/允许，命令行执行：adb devices，成功会有以下类似提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List of devices attached</span><br><span class="line">* daemon not running; starting now at tcp:5037</span><br><span class="line">* daemon started successfully</span><br><span class="line">FA7240301112    device</span><br></pre></td></tr></table></figure><p>✢ 命令行执行：adb reboot bootloader<br>✢ 执行：fastboot oem unlock<br>✢ 您需要通过增大音量按钮来确认手机中的操作。您将成功解除成功消息。当您收到此消息时，请按音量键并导航开始，然后按电源按钮。手机将重新启动。启动第一次启动需要一些时间。<br>✢ 解锁成功在开机界面会有一个打开的小锁图标</p><h5 id="1-2、将系统升级到Oreo-8-1-OPM2-171019-029稳定版"><a href="#1-2、将系统升级到Oreo-8-1-OPM2-171019-029稳定版" class="headerlink" title="1.2、将系统升级到Oreo 8.1 OPM2.171019.029稳定版"></a>1.2、将系统升级到Oreo 8.1 OPM2.171019.029稳定版</h5><p>Root Google Pixel Oreo 8.1 OPM2.171019.029稳定的版本于2018年4月发布。<br>1、<a href="https://developers.google.cn/android/images#sailfish" target="_blank" rel="noopener">Sailfish-OPM2.171019.029下载地址</a><br>2、解压运行update-all.bat（Windows）/ update-all.bat（Mac）</p><h5 id="1-3、Root-Pixel-Oreo-8-1-OPM2-171019-029有四个步骤"><a href="#1-3、Root-Pixel-Oreo-8-1-OPM2-171019-029有四个步骤" class="headerlink" title="1.3、Root Pixel Oreo 8.1 OPM2.171019.029有四个步骤"></a>1.3、Root Pixel Oreo 8.1 OPM2.171019.029有四个步骤</h5><p>✢ Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029<br>✢ Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0<br>✢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0<br>✢ Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</p><h4 id="二、Install-TWRP-Recovery-Officially-in-Google-Pixel-Oreo-8-1-OPM2-171019-029"><a href="#二、Install-TWRP-Recovery-Officially-in-Google-Pixel-Oreo-8-1-OPM2-171019-029" class="headerlink" title="二、Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029"></a>二、Install TWRP Recovery Officially in Google Pixel Oreo 8.1 OPM2.171019.029</h4><p><strong>步骤：</strong><br>1、确保 系统OEM解锁成功、手机版本为Oreo 8.1 OPM2.171019.029，然后执行接下来的操作<br>2、<a href="https://www.firmwares.androidinfotech.com/google-pixel-official-twrp-3-2-0-0-sailfish-img/" target="_blank" rel="noopener">下载 twrp-3.2.1-2-sailfish.img</a> Google Pixel Oreo 8.1 OPM2.171019.029的TWRP恢复镜像<br>3、通过USB连接您的手机，执行：adb reboot bootloader进入BootLoader模式（或者关机状态 Power键+音量下键进入）<br>4、确保您的手机已被系统检测到，执行：fastboot devices 会看到设备号<br>5、fastboot boot twrp-3.2.1-2-sailfish.img<br>6、重启进入下一步操作</p><h4 id="三、Install-Root-Files-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#三、Install-Root-Files-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="三、Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>三、Install Root Files in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.firmwares.androidinfotech.com/twrp-pixel-installer-sailfish-3-1-1-0-zip/" target="_blank" rel="noopener">下载 twrp-pixel-installer-sailfish-3.1.1-0.zip</a>，将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/others/twrp-3-0.jpg" alt="enter image description here"><br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select twrp-pixel-installer-sailfish-3.1.1-0.zip<br>安装后重新启动您的手机。</p><h4 id="四、Install-SuperSu-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#四、Install-SuperSu-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="四、Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>四、Install SuperSu in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.firmwares.androidinfotech.com/sr5-supersu-v2-82-sr5-20171001224502-zip/" target="_blank" rel="noopener">下载 SR5-SuperSU-v2.82-SR5-20171001224502.zip</a> 将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select SR5-SuperSU-v2.82-SR5-20171001224502.zip<br>安装后重新启动您的手机。</p><h4 id="五、Install-Magisk-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0"><a href="#五、Install-Magisk-in-Google-Pixel-Oreo-8-1-OPM2-171019-029-Using-TWRP-Recovery-3-2-0" class="headerlink" title="五、Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0"></a>五、Install Magisk in Google Pixel Oreo 8.1 OPM2.171019.029 Using TWRP Recovery 3.2.0</h4><p><strong>步骤：</strong><br>1、<a href="https://www.androidinfotech.com/2017/07/magisk-versions-download.html" target="_blank" rel="noopener">下载 Magisk-v16.1(1610).zip</a> 将手机USB使用方式切换为传输文件模式，并将其复制到手机存储根目录<br>2、关掉你的手机<br>3、Power键+音量下键进入BootLoader模式模式 ，然后音量键选择 recovery mode，按power键进入Recovery模式<br>4、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>5、返回到TWRP主界面：select Install<br>6、Select Magisk-v16.1(1610).zip<br>安装后重新启动您的手机。</p><h4 id="六、出现的问题"><a href="#六、出现的问题" class="headerlink" title="六、出现的问题"></a>六、出现的问题</h4><p>（一）问题：adb 出现 device offline，更新adb版本到1.0.39<br>（二）问题：笔者Pixel手机执行上述步骤后，无法开机，执行以下步骤就可以开机了：<br>1、关掉你的手机<br>2、Power键+音量下键进入BootLoader模式模式，然后音量键选择 recovery mode，按power键进入Recovery模式<br>3、Select Wipe-&gt;Advance Wipe-&gt;Select  Data<br>4、滑动清除Data</p><p>Root成功，(o゜▽゜)o☆[BINGO!]</p><h4 id="七、参考资料-特别感谢各位前辈的辛苦奉献-："><a href="#七、参考资料-特别感谢各位前辈的辛苦奉献-：" class="headerlink" title="七、参考资料(特别感谢各位前辈的辛苦奉献)："></a>七、参考资料(特别感谢各位前辈的辛苦奉献)：</h4><p><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">解锁BootLoader教程 Unlocking Bootloader in Google Pixel and Pixel XL</a><br><a href="https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html" target="_blank" rel="noopener">Root教程原文 Root Google Pixel Oreo 8.1 OPM2.171019.029 Install TWRP</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.androidinfotech.com/2018/04/root-google-pixel-oreo-8-1-opm2-171019-029.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Root教程原文
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>个人网站(分享一个有趣的的Loading gif) [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/04/03/%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99(%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9A%84Loading%20gif)/"/>
    <id>http://zhoujinjian.cc/2018/04/03/个人网站(分享一个有趣的的Loading gif)/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-19T14:30:15.322Z</updated>
    
    <content type="html"><![CDATA[<h4 id="（一）、-Loading-gif："><a href="#（一）、-Loading-gif：" class="headerlink" title="（一）、 Loading gif："></a>（一）、 Loading gif：</h4><p>茶不思饭不想、不眠不夜折腾近两周，总算把个人网站搭建好了(๑乛◡乛๑)。</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/01-zhoujinjian.home.loading.gif" alt="Markdown"></p><h4 id="（二）、个人网站（zhoujinjian-cc）"><a href="#（二）、个人网站（zhoujinjian-cc）" class="headerlink" title="（二）、个人网站（zhoujinjian.cc）"></a>（二）、个人网站（zhoujinjian.cc）</h4><p>闷骚的主题，我想基本也不会有人来浏览我的个人网站，闷骚就闷骚点吧(๑乛◡乛๑)：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/02-zhoujinjian.home.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/03-zhoujinjian.home-2.png" alt="Markdown"><br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/04-zhoujinjian.home-404.png" alt="Markdown"></p><h4 id="（三）、总结"><a href="#（三）、总结" class="headerlink" title="（三）、总结"></a>（三）、总结</h4><p>个人网站先暂时告一段落了，接下来还是继续老本行分析Android 源代码，之前分析虽已大致打通 App层 -&gt; Framework层 -&gt; Native层 -&gt; Kernel层，冒似有一定经验了然并卵，路漫漫其修远兮，生命不息，学无止境（其实嘛就是 -&gt; 人丑就要多读书๑乛◡乛๑）。好想读读书去看看外面的世界啊。</p><p>where you want to go-&gt;(Castelluccio di Norcia卡斯特鲁奇奥公园,意大利):</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/05-zhoujinjian.home-norcaia.png" alt="Markdown"></p><p>Or-&gt;(Lofoten, Reinebringen(雷訥),挪威):</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/personal.website/06-zhoujinjian.home-lofoten.png" alt="Markdown"></p><p>PS：哇哦，好美，算了我就想想<strong>（ಡωಡ）</strong>。</p><h4 id="（四）、参考资料-特别感谢各位前辈的辛苦奉献-："><a href="#（四）、参考资料-特别感谢各位前辈的辛苦奉献-：" class="headerlink" title="（四）、参考资料(特别感谢各位前辈的辛苦奉献)："></a>（四）、参考资料(特别感谢各位前辈的辛苦奉献)：</h4><p><a href="https://bing.ioliu.cn/v1?p=1&amp;d=0&amp;w=1280&amp;h=768" target="_blank" rel="noopener">Bing 壁纸 API</a><br><a href="https://api.lylares.com/bing/image/?w=1920&amp;h=1080" target="_blank" rel="noopener">Api-bing-wallpaper</a><br><a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank" rel="noopener">Mrminfive - Hexo-theme-skapp</a><br><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener">Molunerfinn - Hexo-theme-melody</a><br><a href="https://github.com/stkevintan/canoe-blog" target="_blank" rel="noopener">Stkevintan - canoe-blog</a><br><a href="https://www.designernews.co/404" target="_blank" rel="noopener">(404) The page you were looking for doesn’t exist</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;（一）、-Loading-gif：&quot;&gt;&lt;a href=&quot;#（一）、-Loading-gif：&quot; class=&quot;headerlink&quot; title=&quot;（一）、 Loading gif：&quot;&gt;&lt;/a&gt;（一）、 Loading gif：&lt;/h4&gt;&lt;p&gt;茶不思饭不想、不眠不
      
    
    </summary>
    
      <category term="Hexo" scheme="http://zhoujinjian.cc/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://zhoujinjian.cc/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核（Kernel-3.18） - Linux Input 子系统分析 [i.wonder~]</title>
    <link href="http://zhoujinjian.cc/2018/04/01/Linux%E5%86%85%E6%A0%B8%EF%BC%88Kernel-3-18%EF%BC%89-Input-%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90-i-wonder/"/>
    <id>http://zhoujinjian.cc/2018/04/01/Linux内核（Kernel-3-18）-Input-子系统分析-i-wonder/</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-19T14:30:10.486Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input" target="_blank" rel="noopener">【博客原图链接】</a></p><p>源码（部分）：</p><p><strong>kernel/msm-3.18/include/linux</strong></p><ul><li>Input.h</li><li>evdev.h</li></ul><p><strong>kernel/msm-3.18/drivers/input</strong></p><ul><li>Input.c</li><li>evdev.c</li><li>gpio_keys.c</li></ul><p><strong>kernel/msm-3.18/drivers/input/touchscreen/synaptics_dsx_htc_2.6</strong></p><ul><li>Makefile</li><li>Kconfig</li><li>synaptics_dsx_core.c</li></ul><p><a href="https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input" target="_blank" rel="noopener">【博客原图链接】</a></p><p>Google Pixel、Pixel XL 内核代码（Kernel-3.18）：</p><p><a href="https://android.googlesource.com/kernel/msm/+/android-msm-marlin-3.18-nougat-mr2-pixel" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - Google</a> <a href="https://github.com/matthewdalex/marlin" target="_blank" rel="noopener">Kernel source for Pixel and Pixel XL - GitHub</a></p><hr><h2 id="（一）、Linux-Input-子系统框架"><a href="#（一）、Linux-Input-子系统框架" class="headerlink" title="（一）、Linux Input 子系统框架"></a>（一）、Linux Input 子系统框架</h2><p>输入(Input)子系统是分层架构的，总共分为5 层，从上到下分别是：用户空间层（User Space）事件处理层(Event Handler)、输入子系统核心层(Input Core)、硬件驱动层(Input Driver) 、硬件设备层（Hardware）。</p><p>驱动根据CORE提供的接口，向上报告发生的按键动作。然后CORE根据驱动的类型，分派这个报告给对应的事件处理层进行处理。事件处理层把数据变化反应到设备模型的文件中（事件缓冲区）。并通知在这些设备模型文件上等待的进程。</p><p>input子系统框架： </p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/01-Linux-kernel-input-subsystem-framework.png" alt="Markdown"></p><p>(1) “硬件驱动层”负责操作具体的硬件设备，这层的代码是针对具体的驱动程序的，比如你的设备是触摸输入设备，还是鼠标输入设备，还是键盘输入设备，这些不同的设备，自然有不同的硬件操作，驱动工程师往往只需要完成这层的代码编写。</p><p>(2) “输入子系统核心层”是链接其他两层之间的纽带与桥梁，向下提供硬件驱动层的接口，向上提供事件处理层的接口。</p><p>(3) “事件处理层” 负责与用户程序打交道，将硬件驱动层传来的事件报告给用户程序。</p><p>各层之间通信的基本单位就是事件，任何一个输入设备的动作都可以抽象成一种事件，如键盘的按下，触摸屏的按下，鼠标的移动等。事件有三种属性：类型（type），编码(code)，值(value)， Input 子系统支持的所有事件都定义在 input.h中，包括所有支持的类型，所属类型支持的编码等。事件传送的方向是 硬件驱动层–&gt;子系统核心–&gt;事件处理层–&gt;用户空间。</p><h2 id="（二）、Input-主要通用数据结构"><a href="#（二）、Input-主要通用数据结构" class="headerlink" title="（二）、Input 主要通用数据结构"></a>（二）、Input 主要通用数据结构</h2><h2 id="2-1、input-dev"><a href="#2-1、input-dev" class="headerlink" title="2.1、input_dev"></a>2.1、input_dev</h2><p>输入设备 input_dev，这是input设备基本的设备结构，每个input驱动程序中都必须分配初始化这样一个结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//输入设备的名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *phys;    <span class="comment">//输入设备节点名称  </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *uniq;    <span class="comment">//指定唯一的ID号，就像MAC地址一样</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_id</span> <span class="title">id</span>;</span>    <span class="comment">//输入设备标识ID，用于和事件处理层进行匹配</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> propbit[BITS_TO_LONGS(INPUT_PROP_CNT)];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> evbit[BITS_TO_LONGS(EV_CNT)];    <span class="comment">//位图，记录设备支持的事件类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> keybit[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，记录设备支持的按键类型      </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> relbit[BITS_TO_LONGS(REL_CNT)];    <span class="comment">//位图，记录设备支持的相对坐标  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> absbit[BITS_TO_LONGS(ABS_CNT)];    <span class="comment">//位图，记录设备支持的绝对坐标</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mscbit[BITS_TO_LONGS(MSC_CNT)];    <span class="comment">//位图，记录设备支持的其他功能</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ledbit[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，记录设备支持的指示灯</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sndbit[BITS_TO_LONGS(SND_CNT)];   <span class="comment">//位图，记录设备支持的声音或警报</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ffbit[BITS_TO_LONGS(FF_CNT)];     <span class="comment">//位图，记录设备支持的作用力功能  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> swbit[BITS_TO_LONGS(SW_CNT)];     <span class="comment">//位图，记录设备支持的开关功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hint_events_per_packet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodemax;      <span class="comment">//设备支持的最大按键值个数  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> keycodesize;    <span class="comment">//每个按键的字节大小</span></span><br><span class="line">    <span class="keyword">void</span> *keycode;      <span class="comment">//指向按键池，即指向按键值数组首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*setkeycode)(struct input_dev *dev,</span><br><span class="line">              <span class="keyword">const</span> struct input_keymap_entry *ke,</span><br><span class="line">              <span class="keyword">unsigned</span> <span class="keyword">int</span> *old_keycode);    <span class="comment">//修改按键值</span></span><br><span class="line">    <span class="keyword">int</span> (*getkeycode)(struct input_dev *dev,</span><br><span class="line">              struct input_keymap_entry *ke);   <span class="comment">//获取按键值</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ff_device</span> *<span class="title">ff</span>;</span>     <span class="comment">//用于强制更新输入设备的部分内容  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> repeat_key;    <span class="comment">//重复按键的键值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span>   <span class="comment">//设置当有连击时的延时定时器  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rep[REP_CNT];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_mt</span> *<span class="title">mt</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_absinfo</span> *<span class="title">absinfo</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> key[BITS_TO_LONGS(KEY_CNT)];    <span class="comment">//位图，按键的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> led[BITS_TO_LONGS(LED_CNT)];    <span class="comment">//位图，led的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> snd[BITS_TO_LONGS(SND_CNT)];    <span class="comment">//位图，声音的状态  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sw[BITS_TO_LONGS(SW_CNT)];   <span class="comment">//位图，开关的状态  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> (*open)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">void</span> (*close)(struct input_dev *dev);</span><br><span class="line">    <span class="keyword">int</span> (*flush)(struct input_dev *dev, struct file *file);</span><br><span class="line">    <span class="keyword">int</span> (*event)(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> __<span class="title">rcu</span> *<span class="title">grab</span>;</span> <span class="comment">//类似私有指针，可以直接访问到事件处理接口event  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">spinlock_t</span> event_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> users;</span><br><span class="line">    <span class="keyword">bool</span> going_away;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span> <span class="comment">//该链表头用于链接此设备所关联的input_handle   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span> <span class="comment">//用于将此设备链接到input_dev_list(链接了所有注册到内核的事件处理器)  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num_vals;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_vals;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">vals</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> devres_managed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-1、input-handler"><a href="#2-1、input-handler" class="headerlink" title="2.1、input_handler"></a>2.1、input_handler</h2><p>input_handler 这是事件处理器的数据结构，代表一个事件处理器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/* 当事件处理器接收到来自Input设备传来的事件时调用的处理函数,</span></span><br><span class="line"><span class="comment">        event、events用于处理事件 */</span>  </span><br><span class="line">    <span class="keyword">void</span> (*event)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="keyword">void</span> (*events)(struct input_handle *handle,</span><br><span class="line">               <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count);</span><br><span class="line">    <span class="keyword">bool</span> (*filter)(struct input_handle *handle, <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value);</span><br><span class="line">    <span class="comment">/* 比较 device's id with handler's id_table ，匹配device and handler*/</span></span><br><span class="line">    <span class="keyword">bool</span> (*match)(struct input_handler *handler, struct input_dev *dev);</span><br><span class="line">    <span class="comment">/* connect用于建立intput_handler和input_dev的联系,</span></span><br><span class="line"><span class="comment">       当一个Input设备注册到内核的时候被调用,将输入设备与事件处理器联结起来 */</span></span><br><span class="line">    <span class="keyword">int</span> (*connect)(struct input_handler *handler, struct input_dev *dev, <span class="keyword">const</span> struct input_device_id *id);</span><br><span class="line">    <span class="comment">/* disconnect用于解除handler和device的联系 */</span></span><br><span class="line">    <span class="keyword">void</span> (*disconnect)(struct input_handle *handle);</span><br><span class="line">    <span class="keyword">void</span> (*start)(struct input_handle *handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> legacy_minors;</span><br><span class="line">    <span class="keyword">int</span> minor;    <span class="comment">//次设备号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;    <span class="comment">//次设备号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id_table</span>;</span>    <span class="comment">//用于和device匹配 ,这个是事件处理器所支持的input设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个链表用来链接他所支持的input_handle结构,input_dev与input_handler配对之后就会生成一个input_handle结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_list</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接到input_handler_list，这个链表链接了所有注册到内核的事件处理器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-3、input-handle"><a href="#2-3、input-handle" class="headerlink" title="2.3、input_handle"></a>2.3、input_handle</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每个配对的事件处理器都会分配一个对应的设备结构，如evdev事件处理器的evdev结构，</span></span><br><span class="line"><span class="comment">    注意这个结构与设备驱动层的input_dev不同，初始化handle时，保存到这里。   </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">private</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    打开标志，每个input_handle 打开后才能操作，</span></span><br><span class="line"><span class="comment">    这个一般通过事件处理器的open方法间接设置  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> open;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">/* 指向Input_dev结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="comment">/* 指向Input_Hander结构实体 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过d_node连接到了input_dev上的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">d_node</span>;</span></span><br><span class="line">    <span class="comment">/* input_handle通过h_node连接到了input_handler的h_list链表上 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">h_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-4、三个数据结构之间的关系"><a href="#2-4、三个数据结构之间的关系" class="headerlink" title="2.4、三个数据结构之间的关系"></a>2.4、三个数据结构之间的关系</h2><blockquote><p>input_dev: 是硬件驱动层，代表一个input设备。 input_handler: 是事件处理层，代表一个事件处理器。 input_handle: 属于核心层，代表一个配对的input_dev与input_handler</p></blockquote><p>input_dev 通过全局的input_dev_list链接在一起。设备注册的时候实现这个操作。注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">  ......</span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_handler 通过全局的input_handler_list链接在一起。事件处理器注册的时候实现这个操作（事件处理器一般内核自带，一般不需要我们来写）注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_dev_list)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">LIST_HEAD</span><span class="params">(input_handler_list)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    ......</span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line"></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_hande 没有一个全局的链表，它注册的时候将自己分别挂在了input_dev 和 input_handler 的h_list上了。通过input_dev 和input_handler就可以找到input_handle在设备注册和事件处理器，注册的时候都要进行配对工作<strong>(input_match_device)</strong>，配对后就会实现链接<strong>(handler-&gt;connect)</strong>通过input_handle也可以找到input_dev和input_handler。注：（稍后详细分析）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，input_device和input_handler中都有一个h_list,而input_handle拥有指向input_dev和input_handler的指针，也就是说input_handle是用来关联input_dev和input_handler的。 那么为什么一个input_device和input_handler中拥有的是h_list而不是一个handle呢？因为一个device可能对应多个handler,而一个handler也不能只处理一个device,比如说一个鼠标，它可以对应even handler，也可以对应mouse handler,因此当其注册时与系统中的handler进行匹配，就有可能产生两个实例，一个是evdev,另一个是mousedev,而任何一个实例中都只有一个handle。至于以何种方式来传递事件，就由用户程序打开哪个实例来决定。后面一个情况很容易理解，一个事件驱动不能只为一个甚至一种设备服务，系统中可能有多种设备都能使用这类handler,比如event handler就可以匹配所有的设备。在input子系统中，有8种事件驱动，每种事件驱动最多可以对应32个设备，因此dev实例总数最多可以达到256个。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/02-Linux-kernel-input-dev-handler.png" alt="Markdown"></p><h2 id="（三）、Input-核心层（Input-c）"><a href="#（三）、Input-核心层（Input-c）" class="headerlink" title="（三）、Input 核心层（Input.c）"></a>（三）、Input 核心层（Input.c）</h2><p>这一节主要介绍核心层的初始化，input_device、input_handle、input_handler之间的关系(稍后回头看更佳)。 总体概览图：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/03-Linux-kernel-input-core-h_list.png" alt="Markdown"></p><h2 id="3-1、输入核心层：初始化"><a href="#3-1、输入核心层：初始化" class="headerlink" title="3.1、输入核心层：初始化"></a>3.1、输入核心层：初始化</h2><p>首先从驱动”入口函数”开始查看</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">input_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="comment">//注册input类，可在/sys/class下看到对应节点文件</span></span><br><span class="line">    err = class_register(&amp;input_class);</span><br><span class="line">    ......</span><br><span class="line">    err = input_proc_init();<span class="comment">/*创建/proc中的项，查看/proc/bus/input  */</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/*注册设备/dev/input，主设备号为INPUT_MAJOR，就是13，后面注册的输入设备都使用该主设备号*/</span></span><br><span class="line">    err = register_chrdev_region(MKDEV(INPUT_MAJOR, <span class="number">0</span>),</span><br><span class="line">                     INPUT_MAX_CHAR_DEVICES, <span class="string">"input"</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在入口函数里面创建了一个input_class类，其实就在/sys/class下创建了一个目录input.当然对于一个新设备，可以注册进一个class也可以不注册进去，如果存在对应class的话注册进去更好，另外在/proc创建了入口项,这样就可以/proc目录看到input的信息，然后就注册设备，可以看出输入子系统的主设备号是13，在这里并没有生成设备文件。只是在/dev/目录下创建了input目录，以后所有注册进系统的输入设备文件都放在这个目录下。</p><p>相应的对应关系可以使用adb 命令进入文件系统之后，cat /proc/bus/input/devices ，查看各个设备对应的event多少，比如Google Pixel 手机：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=<span class="number">0000</span> Vendor=<span class="number">0000</span> Product=<span class="number">0003</span> Version=<span class="number">2066</span></span><br><span class="line">N: Name=<span class="string">"synaptics_dsxv26"</span></span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=<span class="number">2</span></span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=<span class="number">8000</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">B: ABS=<span class="number">663800000000000</span></span><br></pre></td></tr></table></figure><p>event3 就是事件序号， 我们在调试的时候直接 adb shell getevent /dev/input/event3，来实时捕捉 event3 中储存的数据。</p><p>那么接下来看看怎么注册input设备的.我们需要在设备驱动层中完成输入设备的注册，通过调用input_register_device()函数来完成，该函数的一个重要任务就是完成设备与事件驱动的匹配</p><h2 id="3-2、输入核心层：注册设备input-dev"><a href="#3-2、输入核心层：注册设备input-dev" class="headerlink" title="3.2、输入核心层：注册设备input_dev"></a>3.2、输入核心层：注册设备input_dev</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_device</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_devres</span> *<span class="title">devres</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_size;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        devres = devres_alloc(devm_input_device_unregister,</span><br><span class="line">                      <span class="keyword">sizeof</span>(struct input_devres), GFP_KERNEL);</span><br><span class="line">        ......</span><br><span class="line">        devres-&gt;input = dev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//EN_SYN这个是设备都要支持的事件类型，所以要设置   </span></span><br><span class="line">    <span class="comment">/* Every input device generates EV_SYN/SYN_REPORT events. */</span></span><br><span class="line">    __set_bit(EV_SYN, dev-&gt;evbit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* KEY_RESERVED is not supposed to be transmitted to userspace. */</span></span><br><span class="line">    __clear_bit(KEY_RESERVED, dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that bitmasks not mentioned in dev-&gt;evbit are clean. */</span></span><br><span class="line">    input_cleanse_bitmasks(dev);</span><br><span class="line"></span><br><span class="line">    packet_size = input_estimate_events_per_packet(dev);</span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;hint_events_per_packet &lt; packet_size)</span><br><span class="line">        dev-&gt;hint_events_per_packet = packet_size;</span><br><span class="line"></span><br><span class="line">    dev-&gt;max_vals = dev-&gt;hint_events_per_packet + <span class="number">2</span>;</span><br><span class="line">    dev-&gt;vals = kcalloc(dev-&gt;max_vals, <span class="keyword">sizeof</span>(*dev-&gt;vals), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If delay and period are pre-set by the driver, then autorepeating</span></span><br><span class="line"><span class="comment">     * is handled by the driver itself and we don't do it in input.c.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 这个定时器是为了重复按键而设置的</span></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;rep[REP_DELAY] &amp;&amp; !dev-&gt;rep[REP_PERIOD]) &#123;</span><br><span class="line">        dev-&gt;timer.data = (<span class="keyword">long</span>) dev;</span><br><span class="line">        dev-&gt;timer.function = input_repeat_key;</span><br><span class="line">        dev-&gt;rep[REP_DELAY] = <span class="number">250</span>;</span><br><span class="line">        dev-&gt;rep[REP_PERIOD] = <span class="number">33</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有设置自己的获取键值的函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;getkeycode)</span><br><span class="line">        dev-&gt;getkeycode = input_default_getkeycode;</span><br><span class="line">    <span class="comment">/* 如果设备驱动没有指定按键重置函数，系统默认 */</span>  </span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;setkeycode)</span><br><span class="line">        dev-&gt;setkeycode = input_default_setkeycode;</span><br><span class="line"></span><br><span class="line">    error = device_add(&amp;dev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    path = kobject_get_path(&amp;dev-&gt;dev.kobj, GFP_KERNEL);</span><br><span class="line">    pr_info(<span class="string">"%s as %s\n"</span>,</span><br><span class="line">        dev-&gt;name ? dev-&gt;name : <span class="string">"Unspecified device"</span>,</span><br><span class="line">        path ? path : <span class="string">"N/A"</span>);</span><br><span class="line">    kfree(path);</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 将新分配的input设备连接到input_dev_list链表上  </span></span><br><span class="line">    list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);</span><br><span class="line">    <span class="comment">/* 核心重点，input设备在增加到input_dev_list链表上之后，会查找</span></span><br><span class="line"><span class="comment">     * input_handler_list事件处理链表上的handler进行匹配，这里的匹配</span></span><br><span class="line"><span class="comment">     * 方式与设备模型的device和driver匹配过程很相似，所有的input</span></span><br><span class="line"><span class="comment">     * 都挂在input_dev_list上，所有类型的事件都挂在input_handler_list</span></span><br><span class="line"><span class="comment">     * 上，进行“匹配相亲”，list_for_each_entry就是个for循环，跳出条件遍历了一遍，又回到链表头 */</span>  </span><br><span class="line">    list_for_each_entry(handler, &amp;input_handler_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;devres_managed) &#123;</span><br><span class="line">        dev_dbg(dev-&gt;dev.parent, <span class="string">"%s: registering %s with devres.\n"</span>,</span><br><span class="line">            __func__, dev_name(&amp;dev-&gt;dev));</span><br><span class="line">        devres_add(dev-&gt;dev.parent, devres);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码主要的功能有以下几个功能，也是设备驱动注册为输入设备委托内核做的事情：</p><p>1、进一步初始化输入设备，例如连击事件 2、注册输入设备到input类中，把输入设备挂到输入设备链表input_dev_list中 3、查找并匹配输入设备对应的事件处理层，通过input_handler_list链表</p><p>我们需要再分析下这个匹配的过程，input_attach_handler()匹配过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">input_attach_handler</span><span class="params">(struct input_dev *dev, struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* input_dev 和 input_handler 进行匹配,返回匹配的id，类型是struct input_device_id  */</span>  </span><br><span class="line">    id = input_match_device(handler, dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 匹配成功，调用handler里面的connect函数,这个函数在事件处理器中定义，主要生成一个input_handle结构，并初始化，还生成一个事件处理器相关的设备结构 */</span>  </span><br><span class="line">    error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看下input_match_device（）函数，看一下这个匹配的条件是什么，如何匹配的过程是怎样的，匹配的结果会是什么</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> struct input_device_id *<span class="title">input_match_device</span><span class="params">(struct input_handler *handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                            struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (id = handler-&gt;id_table; id-&gt;flags || id-&gt;driver_info; id++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_BUS)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;bustype != dev-&gt;id.bustype) <span class="comment">//匹配总线id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VENDOR)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;vendor != dev-&gt;id.vendor)  <span class="comment">//匹配生产商id</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_PRODUCT)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;product != dev-&gt;id.product)  <span class="comment">//匹配产品id  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id-&gt;flags &amp; INPUT_DEVICE_ID_MATCH_VERSION)</span><br><span class="line">            <span class="keyword">if</span> (id-&gt;version != dev-&gt;id.version) <span class="comment">//匹配版本  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//匹配id的evbit和input_dev中evbit的各个位，如果不匹配则continue，数组中下一个设备  </span></span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;evbit, dev-&gt;evbit, EV_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">if</span> (!bitmap_subset(id-&gt;swbit, dev-&gt;swbit, SW_MAX))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!handler-&gt;match || handler-&gt;match(handler, dev))</span><br><span class="line">            <span class="keyword">return</span> id;<span class="comment">//匹配成功,返回id</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input_match_device() 到最合适的事件处理层驱动时，便执行handler-&gt;connect() 函数进行连接了，看下面这部分代码（以evdev类型驱动为例，在input/evdev.c中）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_connect</span><span class="params">(struct input_handler *handler, struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> minor;</span><br><span class="line">    <span class="keyword">int</span> dev_no;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">/* EVDEV_MINORS为32，代表共能容纳32个evdev事件层设备，下面代码在找到空的地方，用于保存evdev事件层的数据，即上面定义的evdev */</span></span><br><span class="line">    minor = input_get_new_minor(EVDEV_MINOR_BASE, EVDEV_MINORS, <span class="literal">true</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 开始给evdev事件层驱动分配空间了 */</span></span><br><span class="line">    evdev = kzalloc(<span class="keyword">sizeof</span>(struct evdev), GFP_KERNEL);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 初始化client_list列表和evdev_wait队列，后面介绍 */</span></span><br><span class="line">    INIT_LIST_HEAD(&amp;evdev-&gt;client_list);</span><br><span class="line">    spin_lock_init(&amp;evdev-&gt;client_lock);</span><br><span class="line">    mutex_init(&amp;evdev-&gt;mutex);</span><br><span class="line">    init_waitqueue_head(&amp;evdev-&gt;wait);</span><br><span class="line">    evdev-&gt;exist = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">/* 初始化evdev结构体，其中handle为输入设备和事件处理的关联接口 */</span></span><br><span class="line">    dev_no = minor;</span><br><span class="line">    <span class="comment">/* Normalize device number if it falls into legacy range */</span></span><br><span class="line">    <span class="keyword">if</span> (dev_no &lt; EVDEV_MINOR_BASE + EVDEV_MINORS)</span><br><span class="line">        dev_no -= EVDEV_MINOR_BASE;</span><br><span class="line">    dev_set_name(&amp;evdev-&gt;dev, <span class="string">"event%d"</span>, dev_no);</span><br><span class="line">    <span class="comment">/*这里就将handle的dev指针指向了input_dev*/</span></span><br><span class="line">    evdev-&gt;handle.dev = input_get_device(dev);</span><br><span class="line">    evdev-&gt;handle.name = dev_name(&amp;evdev-&gt;dev);</span><br><span class="line">    evdev-&gt;handle.handler = handler;<span class="comment">/*这里将handle的handler指向了当前的input_handler.注意本函数evdev_connect,可能是在在输入设备注册的时候</span></span><br><span class="line"><span class="comment">38     在input_register_device函数中调用input_attach_handler的时候调用;也可能是在输入设备的处理方法input_handler时在input_register_handler</span></span><br><span class="line"><span class="comment">39     函数中也会用到input_attach_handler函数,就会调用本函数.这里就很明显了,本函数就将input_handler和input_dev都放在input_handle中统一管理*/</span></span><br><span class="line">    evdev-&gt;handle.<span class="keyword">private</span> = evdev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*初始化evdev中的内嵌device*/</span></span><br><span class="line">    evdev-&gt;dev.devt = MKDEV(INPUT_MAJOR, minor);</span><br><span class="line">    evdev-&gt;dev.class = &amp;input_class;</span><br><span class="line">    evdev-&gt;dev.parent = &amp;dev-&gt;dev;</span><br><span class="line">    evdev-&gt;dev.release = evdev_free;</span><br><span class="line">    device_initialize(&amp;evdev-&gt;dev);</span><br><span class="line">   <span class="comment">/* input_dev设备驱动层和input_handler事件处理层的关联，由input_handle完成(不要和handler搞混淆了，这不是一个概念～) */</span>  </span><br><span class="line">    error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    cdev_init(&amp;evdev-&gt;cdev, &amp;evdev_fops);</span><br><span class="line">    evdev-&gt;cdev.kobj.parent = &amp;evdev-&gt;dev.kobj;</span><br><span class="line">    error = cdev_add(&amp;evdev-&gt;cdev, evdev-&gt;dev.devt, <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    error = device_add(&amp;evdev-&gt;dev);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、输入核心层：注册input-handler"><a href="#3-3、输入核心层：注册input-handler" class="headerlink" title="3.3、输入核心层：注册input_handler"></a>3.3、输入核心层：注册input_handler</h2><p>为了逻辑更清新，我们稍后再来看input_register_handle() 程，先来了解input_handler的注册过程。 要了解input_handler的注册过程，又需要先了解evdev初始化过程（以evdev为例）： /kernel/drivers/input下众多事件处理器handler其中的一个，可以看下源码/kernel/drivers/input/evdev.c中的模块init</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">evdev_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> input_register_handler(&amp;evdev_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个初始化就是往input核心中注册一个input_handler类型的evdev_handler，调用的是input.c提供的接口，input_handler结构前面有介绍，看下evdev_handler的赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> <span class="title">evdev_handler</span> = &#123;</span></span><br><span class="line">    .event        = evdev_event,</span><br><span class="line">    .events        = evdev_events,</span><br><span class="line">    .connect    = evdev_connect,</span><br><span class="line">    .disconnect    = evdev_disconnect,</span><br><span class="line">    .legacy_minors    = <span class="literal">true</span>,</span><br><span class="line">    .minor        = EVDEV_MINOR_BASE,</span><br><span class="line">    .name        = <span class="string">"evdev"</span>,</span><br><span class="line">    .id_table    = evdev_ids,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以注意的是evdev是匹配所有设备的，因为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;edev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_device_id</span> <span class="title">evdev_ids</span>[] = &#123;</span></span><br><span class="line">    &#123; .driver_info = <span class="number">1</span> &#125;,    <span class="comment">/* Matches all devices */</span></span><br><span class="line">    &#123; &#125;,            <span class="comment">/* Terminating zero entry */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handler</span><span class="params">(struct input_handler *handler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = mutex_lock_interruptible(&amp;input_mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    INIT_LIST_HEAD(&amp;handler-&gt;h_list);</span><br><span class="line">    <span class="comment">//添加进input_handler_list全局链表</span></span><br><span class="line">    list_add_tail(&amp;handler-&gt;node, &amp;input_handler_list);</span><br><span class="line">    <span class="comment">//同样遍历input_dev这个链表，依次调用下面的input_attach_handler去匹配input_dev,这个跟input_dev注册的时候的情形类似  </span></span><br><span class="line">    list_for_each_entry(dev, &amp;input_dev_list, node)</span><br><span class="line">        input_attach_handler(dev, handler);</span><br><span class="line"></span><br><span class="line">    input_wakeup_procfs_readers();</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;input_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）"><a href="#3-4、输入核心层：注册input-handle（不要和handler搞混淆了哦，这不是一个概念～）" class="headerlink" title="3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）"></a>3.4、输入核心层：注册input_handle（不要和handler搞混淆了哦，这不是一个概念～）</h2><p>input_handle关联匹配input_dev和input_handler 继续分析input_dev和input_handler 是如何关联上的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_register_handle</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    error = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将d_node链接到输入设备的h_list，h_node链接到事件层的h_list链表上</span></span><br><span class="line"><span class="comment">    * 因此，在handle中是输入设备和事件层的关联结构体，通过输入设备可以</span></span><br><span class="line"><span class="comment">    * 找到对应的事件处理层接口，通过事件处理层也可找到匹配的输入设备</span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//把这个handle的d_node 加到对应input_dev的h_list链表里面  </span></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;filter)</span><br><span class="line">        list_add_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_add_tail_rcu(&amp;handle-&gt;d_node, &amp;dev-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//把这个handle的h_node 加到对应input_handler的h_list链表里面</span></span><br><span class="line">    list_add_tail_rcu(&amp;handle-&gt;h_node, &amp;handler-&gt;h_list);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;start)</span><br><span class="line">        handler-&gt;start(handle);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个注册是把handle 本身的链表加入到它自己的input_dev 以及 input_handler的h_list链表中，这样以后就可以通过h_list遍历到这个handle，这样就实现了三者的绑定联系。</p><p>以上是输入设备驱动注册的全过程，纵观整个过程，输入设备驱动最终的目的就是能够与事件处理层的事件驱动相互匹配，但是在drivers/input目录下有evdev.c事件驱动、mousedev.c事件驱动、joydev.c事件驱动等等，我们的输入设备产生的事件应该最终上报给谁，然后让事件被谁去处理呢？知道了这么个原因再看上面代码就会明白，其实evdev.c、mousedev.c等根据硬件输入设备的处理方式的不同抽象出了不同的事件处理接口帮助上层去调用，而我们写的设备驱动程序只不过是完成了硬件寄存器中数据的读写，但提交给用户的事件必须是经过事件处理层的封装和同步才能够完成的，事件处理层提供给用户一个统一的界面来操作。 整个关联注册的过程：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/04-Linux-kernel-input-reg-device.png" alt="Markdown"></p><h2 id="（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）"><a href="#（四）、Input-事件处理层-Event-handler-（以evdev事件处理器为例）" class="headerlink" title="（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）"></a>（四）、Input 事件处理层 Event handler （以evdev事件处理器为例）</h2><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/05-Linux-kernel-input-event-hardware.png" alt="Markdown"></p><h2 id="4-1、主要数据结构"><a href="#4-1、主要数据结构" class="headerlink" title="4.1、主要数据结构"></a>4.1、主要数据结构</h2><p><strong>（1） evdev设备结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> &#123;</span>   </span><br><span class="line">    <span class="keyword">int</span> exist;   </span><br><span class="line">    <span class="keyword">int</span> open;                     <span class="comment">//打开标志   </span></span><br><span class="line">    <span class="keyword">int</span> minor;                    <span class="comment">//次设备号   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> <span class="title">handle</span>;</span>   <span class="comment">//关联的input_handle   </span></span><br><span class="line">    <span class="keyword">wait_queue_head_t</span> wait;       <span class="comment">//等待队列，当进程读取设备，而没有事件产生的时候，进程就会睡在其上面   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">grab</span>;</span>    <span class="comment">//强制绑定的evdev_client结构，这个结构后面再分析   </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">client_list</span>;</span> <span class="comment">//evdev_client 链表，这说明一个evdev设备可以处理多个evdev_client，可以有多个进程访问evdev设备   </span></span><br><span class="line">    <span class="keyword">spinlock_t</span> client_lock;       <span class="comment">/* protects client_list */</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span>            <span class="comment">//device结构，说明这是一个设备结构   </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>evdev结构体在配对成功的时候生成，由handler-&gt;connect生成，对应设备文件为/class/input/event(n)，如触摸屏驱动的event3，这个设备是用户空间要访问的设备，可以理解它是一个虚拟设备，因为没有对应的硬件，但是通过handle-&gt;dev 就可以找到input_dev结构，而它对应着触摸屏，设备文件为/class/input/input3。这个设备结构生成之后保存在evdev_table中，索引值是minor。 <strong>（2）evdev用户端结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[evdev.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> head;  <span class="comment">//buffer数组的索引头  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tail;   <span class="comment">//buffer数组的索引尾  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> packet_head; <span class="comment">/* [future] position of the first element of next packet */</span>  </span><br><span class="line">    <span class="keyword">spinlock_t</span> buffer_lock; <span class="comment">/* protects access to buffer, head and tail */</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">wake_lock</span> <span class="title">wake_lock</span>;</span>  </span><br><span class="line">    <span class="keyword">bool</span> use_wake_lock;  </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">28</span>];  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span>    <span class="comment">//异步通知函数  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span>;</span>  <span class="comment">//包含一个evdev变量  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span>  <span class="comment">//链表  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">buffer</span>[];</span>   <span class="comment">//input_event数据结构的数组，input_event代表一个事件，基本成员：类型（type），编码（code），值（value）  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构在进程打开event3设备的时候调用evdev的open方法，在open中创建这个结构，并初始化。在关闭设备文件的时候释放这个结构。 <strong>（3）input_event结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[input.h]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span>    <span class="comment">//事件发生的时间   </span></span><br><span class="line">    __u16 type;             <span class="comment">//事件类型   </span></span><br><span class="line">    __u16 code;             <span class="comment">//子事件   </span></span><br><span class="line">    __s32 value;            <span class="comment">//事件的value  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-2、事件处理层evdev"><a href="#4-2、事件处理层evdev" class="headerlink" title="4.2、事件处理层evdev"></a>4.2、事件处理层evdev</h2><p>事件处理层与用户程序和输入子系统核心打交道，是他们两层的桥梁。一般内核有好几个事件处理器，像evdev mousedev jotdev。evdev事件处理器可以处理所有的事件，触摸屏驱动就是用的这个，所以下面分析这个事件处理器的实现。它也是作为模块注册到内核中的,前面已经分析过它的模块初始化函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">evdev_fops</span> = &#123;</span></span><br><span class="line">    .owner        = THIS_MODULE,</span><br><span class="line">    .read        = evdev_read,</span><br><span class="line">    .write        = evdev_write,</span><br><span class="line">    .poll        = evdev_poll,</span><br><span class="line">    .open        = evdev_open,</span><br><span class="line">    .release    = evdev_release,</span><br><span class="line">    .unlocked_ioctl    = evdev_ioctl,</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    .compat_ioctl    = evdev_ioctl_compat,</span><br><span class="line">#endif</span><br><span class="line">    .fasync        = evdev_fasync,</span><br><span class="line">    .flush        = evdev_flush,</span><br><span class="line">    .llseek        = no_llseek,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果匹配上了就会创建一个evdev，它里边封装了一个handle，会把input_dev和input_handler关联到一起。关系如下：</p><p><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/06-Linux-kernel-input-evdev-connect.png" alt="Markdown"></p><h2 id="4-3、evdev设备结点的open-操作"><a href="#4-3、evdev设备结点的open-操作" class="headerlink" title="4.3、evdev设备结点的open()操作"></a>4.3、evdev设备结点的open()操作</h2><p>我们知道.对主设备号为INPUT_MAJOR的设备节点进行操作，会将操作集转换成handler的操作集。在evdev中，这个操作集就是evdev_fops。对应的open函数如下示：</p><p>首先来看打开event(x)设备文件，evdev_open函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open</span><span class="params">(struct inode *inode, struct file *file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">container_of</span>(<span class="title">inode</span>-&gt;<span class="title">i_cdev</span>, <span class="title">struct</span> <span class="title">evdev</span>, <span class="title">cdev</span>);</span></span><br><span class="line">    <span class="comment">//evdev_client的buffer大小  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bufsize = evdev_compute_buffer_size(evdev-&gt;handle.dev);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(struct evdev_client) +</span><br><span class="line">                    bufsize * <span class="keyword">sizeof</span>(struct input_event);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line">    <span class="comment">//打开的时候创建一个evdev_client</span></span><br><span class="line">    client = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    client-&gt;bufsize = bufsize;</span><br><span class="line">    spin_lock_init(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="built_in">snprintf</span>(client-&gt;name, <span class="keyword">sizeof</span>(client-&gt;name), <span class="string">"%s-%d"</span>,</span><br><span class="line">            dev_name(&amp;evdev-&gt;dev), task_tgid_vnr(current));</span><br><span class="line">    client-&gt;evdev = evdev;</span><br><span class="line">    evdev_attach_client(evdev, client);</span><br><span class="line">    <span class="comment">//调用打开真正的底层设备函数  </span></span><br><span class="line">    error = evdev_open_device(evdev);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    file-&gt;private_data = client;</span><br><span class="line">    nonseekable_open(inode, file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_open_device</span><span class="params">(struct evdev *evdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">if</span> (retval)<span class="comment">/*如果设备不存在，返回错误*/</span>  </span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!evdev-&gt;exist)</span><br><span class="line">        retval = -ENODEV;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!evdev-&gt;open++) &#123;<span class="comment">//递增打开计数  </span></span><br><span class="line">        retval = input_open_device(&amp;evdev-&gt;handle);<span class="comment">//如果是被第一次打开，则调用input_open_device</span></span><br><span class="line">        <span class="keyword">if</span> (retval)</span><br><span class="line">            evdev-&gt;open--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;evdev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_open_device</span><span class="params">(struct input_handle *handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_dev</span> *<span class="title">dev</span> = <span class="title">handle</span>-&gt;<span class="title">dev</span>;</span><span class="comment">//根据input_handle找到对应的input_dev设备  </span></span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = mutex_lock_interruptible(&amp;dev-&gt;mutex);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    handle-&gt;open++;<span class="comment">//递增handle的打开计数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dev-&gt;users++ &amp;&amp; dev-&gt;open)</span><br><span class="line">        retval = dev-&gt;open(dev);<span class="comment">//如果是第一次打开.则调用input device的open()函数  </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval) &#123;</span><br><span class="line">        dev-&gt;users--;</span><br><span class="line">        <span class="keyword">if</span> (!--handle-&gt;open) &#123;</span><br><span class="line">            synchronize_rcu();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">    mutex_unlock(&amp;dev-&gt;mutex);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4、用户进程读取event的底层实现"><a href="#4-4、用户进程读取event的底层实现" class="headerlink" title="4.4、用户进程读取event的底层实现"></a>4.4、用户进程读取event的底层实现</h2><p>至于具体的如何初始化input_dev，这个是具体的输入设备去实现的，稍后具体实例再分析，现在来看看，对于一个event(x)设备文件的，应用程序来读，最终会导致”handler”里面的的”读函数”被调用。</p><p>evdev_fops 结 构 体 是 一 个 file_operations 的 类 型 。 当 用 户 层 调 用 类 似 代 码open(“/dev/input/event3” , O_RDONLY) 函 数 打 开 设 备 结 点 时 , 会 调 用 evdev_fops 中 的evdev_read()函数,该函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> ssize_t <span class="title">evdev_read</span><span class="params">(struct file *file, <span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">size_t</span> count, <span class="keyword">loff_t</span> *ppos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span> = <span class="title">file</span>-&gt;<span class="title">private_data</span>;</span><span class="comment">//就是刚才在open函数中保存的evdev_client  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> read = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">//如果获得了数据则取出来，调用evdev_fetch_next_event  </span></span><br><span class="line">        <span class="keyword">while</span> (read + input_event_size() &lt;= count &amp;&amp;</span><br><span class="line">               evdev_fetch_next_event(client, &amp;event)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//input_event_to_user调用copy_to_user传入用户程序中，这样读取完成  </span></span><br><span class="line">            <span class="keyword">if</span> (input_event_to_user(buffer + read, &amp;event))</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">            read += input_event_size();</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">/*如果是可阻塞状态的话,则等待在wait队列上.直到有数据要被处理,当前进程才被唤醒.这很好理解,既然是</span></span><br><span class="line"><span class="comment">         输入设备,读的话比如读按键,那么必须要有硬件设备有按键按下才会返回按键值,这里还是处于事件处理层,应用程序在这里休眠,那么谁来唤醒?</span></span><br><span class="line"><span class="comment">         当然是有按键按下才去唤醒,因此这个工作就交给了设备驱动层,那么找到这个唤醒呢,直接去找不好找,那么可以直接搜索evdev-&gt;wait,搜索结果</span></span><br><span class="line"><span class="comment">         可知evdev-&gt;wait在evdev_event()函数中被唤醒*/</span></span><br><span class="line">        <span class="keyword">if</span> (!(file-&gt;f_flags &amp; O_NONBLOCK)) &#123;</span><br><span class="line">            error = wait_event_interruptible(evdev-&gt;wait,</span><br><span class="line">                    client-&gt;packet_head != client-&gt;tail ||</span><br><span class="line">                    !evdev-&gt;exist || client-&gt;revoked);</span><br><span class="line">            <span class="keyword">if</span> (error)</span><br><span class="line">                <span class="keyword">return</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">evdev_fetch_next_event</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> have_event;</span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line">    <span class="comment">/*先判断一下是否有数据*/</span>   </span><br><span class="line">    have_event = client-&gt;packet_head != client-&gt;tail;</span><br><span class="line">    <span class="comment">/*如果有就从环形缓冲区的取出来，记得是从head存储，tail取出*/</span></span><br><span class="line">    <span class="keyword">if</span> (have_event) &#123;</span><br><span class="line">        *event = client-&gt;buffer[client-&gt;tail++];</span><br><span class="line">        client-&gt;tail &amp;= client-&gt;bufsize - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (client-&gt;use_wake_lock &amp;&amp;</span><br><span class="line">            client-&gt;packet_head == client-&gt;tail)</span><br><span class="line">            wake_unlock(&amp;client-&gt;wake_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irq(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> have_event;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">input_event_to_user</span><span class="params">(<span class="keyword">char</span> __user *buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_event *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*如果设置了标志INPUT_COMPAT_TEST就将事件event包装成结构体compat_event*/</span></span><br><span class="line">    <span class="keyword">if</span> (INPUT_COMPAT_TEST &amp;&amp; !COMPAT_USE_64BIT_TIME) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_event_compat</span> <span class="title">compat_event</span>;</span></span><br><span class="line"></span><br><span class="line">        compat_event.time.tv_sec = event-&gt;time.tv_sec;</span><br><span class="line">        compat_event.time.tv_usec = event-&gt;time.tv_usec;</span><br><span class="line">        compat_event.type = event-&gt;type;</span><br><span class="line">        compat_event.code = event-&gt;code;</span><br><span class="line">        compat_event.value = event-&gt;value;</span><br><span class="line">         <span class="comment">/*将包装成的compat_event拷贝到用户空间*/</span>  </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, &amp;compat_event,</span><br><span class="line">                 <span class="keyword">sizeof</span>(struct input_event_compat)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">/*否则，将event拷贝到用户空间*/</span>   </span><br><span class="line">        <span class="keyword">if</span> (copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是可阻塞状态的话，则等待在wait队列上。直到有数据要被处理，当前进程才被唤醒。这很好理解，既然是输入设备，读的话比如读按键，那么必须要有硬件设备有按键按下才会返回按键值，这里还是处于事件处理层，应用程序在这里休眠，那么谁来唤醒?</p><p>当然是有按键按下才去唤醒，因此这个工作就交给了设备驱动层。那么找到这个唤醒呢，直接去找不好找。那么可以直接搜索evdev-&gt;wait，搜索结果可知evdev-&gt;wait在evdev_event()函数中被唤醒</p><p>注释中说的很清楚，evdev_event()会唤醒此处的读按键进程。那么evdev_event()又是被谁调用?显然是设备驱动层，现在看一个设备层例子，内核中有个按键的例子，gpiokey.c，这只是个例子不针对任何设备，在gpio_keys.c终端处理函数里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;gpio_keys.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">gpio_keys_irq_isr</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *dev_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!bdata-&gt;key_pressed) &#123;</span><br><span class="line">        ......</span><br><span class="line">        input_event(input, EV_KEY, button-&gt;code, <span class="number">1</span>);</span><br><span class="line">        input_sync(input);</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此可以看出 在设备的中断服务程序里面，确定事件是什么，然后调用相应的input_handler的event处理函数 实际上这就是我们的核心 input_event()是用来上报事件的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_event_supported(type, dev-&gt;evbit, EV_MAX)) &#123;</span><br><span class="line"></span><br><span class="line">        spin_lock_irqsave(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">        input_handle_event(dev, type, code, value);</span><br><span class="line">        spin_unlock_irqrestore(&amp;dev-&gt;event_lock, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_handle_event</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (disposition &amp; INPUT_FLUSH) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dev-&gt;num_vals &gt;= <span class="number">2</span>)</span><br><span class="line">            input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;num_vals &gt;= dev-&gt;max_vals - <span class="number">2</span>) &#123;</span><br><span class="line">        dev-&gt;vals[dev-&gt;num_vals++] = input_value_sync;</span><br><span class="line">        input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">        dev-&gt;num_vals = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">input_pass_values</span><span class="params">(struct input_dev *dev,</span></span></span><br><span class="line"><span class="function"><span class="params">                  struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handle</span> *<span class="title">handle</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    handle = rcu_dereference(dev-&gt;grab);</span><br><span class="line">    <span class="keyword">if</span> (handle) &#123;</span><br><span class="line">        count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list_for_each_entry_rcu(handle, &amp;dev-&gt;h_list, d_node)</span><br><span class="line">            <span class="keyword">if</span> (handle-&gt;open)</span><br><span class="line">                count = input_to_handler(handle, vals, count);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">input_to_handler</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_handler</span> *<span class="title">handler</span> = <span class="title">handle</span>-&gt;<span class="title">handler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">end</span> = <span class="title">vals</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (handler-&gt;events)</span><br><span class="line">        handler-&gt;events(handle, vals, count);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handler-&gt;event)</span><br><span class="line">        <span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">            handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到最终调用handler-&gt;event()来处理，此处handler即对应evdev。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c]</span><br><span class="line">handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value)</span><br></pre></td></tr></table></figure><p>所以会调用evdev_event()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;evdev.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_pass_values</span><span class="params">(struct evdev_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">ktime_t</span> mono, <span class="keyword">ktime_t</span> real)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">client</span>-&gt;<span class="title">evdev</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> *<span class="title">v</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> wakeup = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client-&gt;revoked)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    event.time = ktime_to_timeval(client-&gt;clkid == CLOCK_MONOTONIC ?</span><br><span class="line">                      mono : real);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Interrupts are disabled, just acquire the lock. */</span></span><br><span class="line">    spin_lock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (v = vals; v != vals + count; v++) &#123;</span><br><span class="line">        event.type = v-&gt;type;</span><br><span class="line">        event.code = v-&gt;code;</span><br><span class="line">        event.value = v-&gt;value;</span><br><span class="line">        __pass_event(client, &amp;event);</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;type == EV_SYN &amp;&amp; v-&gt;code == SYN_REPORT)</span><br><span class="line">            wakeup = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock(&amp;client-&gt;buffer_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wakeup)</span><br><span class="line">        wake_up_interruptible(&amp;evdev-&gt;wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_events</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> struct input_value *vals, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev</span> *<span class="title">evdev</span> = <span class="title">handle</span>-&gt;<span class="title">private</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evdev_client</span> *<span class="title">client</span>;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (client)</span><br><span class="line">        evdev_pass_values(client, vals, count, time_mono, time_real);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        list_for_each_entry_rcu(client, &amp;evdev-&gt;client_list, node)</span><br><span class="line">            evdev_pass_values(client, vals, count,</span><br><span class="line">                      time_mono, time_real);</span><br><span class="line"></span><br><span class="line">    rcu_read_unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">evdev_event</span><span class="params">(struct input_handle *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">int</span> type, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_value</span> <span class="title">vals</span>[] = &#123;</span> &#123; type, code, value &#125; &#125;;</span><br><span class="line">    evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终唤醒evdev_read()将数据拷贝到用户空间。</p><h2 id="（五）、Input-事件上报过程"><a href="#（五）、Input-事件上报过程" class="headerlink" title="（五）、Input 事件上报过程"></a>（五）、Input 事件上报过程</h2><h2 id="5-1、Input-事件产生"><a href="#5-1、Input-事件产生" class="headerlink" title="5.1、Input 事件产生"></a>5.1、Input 事件产生</h2><p>当按下触摸屏时，进入触摸屏按下中断，开始ad转换，ad转换完成进入ad完成中断，在这个终端中将事件发送出去，会调用以下函数上报事件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> input_report_key(input_dev,</span><br><span class="line">         BTN_TOUCH, 1);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_X, x);</span><br><span class="line"></span><br><span class="line"> input_report_abs(input_dev,</span><br><span class="line">         ABS_POSITION_Y, y);</span><br><span class="line"></span><br><span class="line">input_sync(input_dev);</span><br></pre></td></tr></table></figure><p>这两个函数调用了 input_event(dev, EV_ABS, code, value) 所有的事件报告函数都调用这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.h]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_key</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_KEY, code, !!value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_report_abs</span><span class="params">(struct input_dev *dev, <span class="keyword">unsigned</span> <span class="keyword">int</span> code, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_ABS, code, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">input_sync</span><span class="params">(struct input_dev *dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input_event(dev, EV_SYN, SYN_REPORT, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2、Input-事件报告"><a href="#5-2、Input-事件报告" class="headerlink" title="5.2、Input 事件报告"></a>5.2、Input 事件报告</h2><p>input_event 函数前面已经分析过，这里不再分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;input.c:input_pass_values]</span><br><span class="line"><span class="keyword">for</span> (v = vals; v != end; v++)</span><br><span class="line">    handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br></pre></td></tr></table></figure><p>最终会调用handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value) 来将数据 传递给用户空间等待读取数据的进程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy_to_user(buffer, event, <span class="keyword">sizeof</span>(struct input_event))</span><br></pre></td></tr></table></figure><h2 id="（六）、Android-Input子系统"><a href="#（六）、Android-Input子系统" class="headerlink" title="（六）、Android Input子系统"></a>（六）、Android Input子系统</h2><p>输入子系统的系统架构如下图所示：<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/07-Linux-kernel-android-input-system.png" alt="Markdown"></p><p>详细分析请参考：Android 7.1.2 (Android N) Android 输入子系统-Input System 分析</p><h2 id="（七）、Input-设备驱动层实例（Synaptics）"><a href="#（七）、Input-设备驱动层实例（Synaptics）" class="headerlink" title="（七）、Input 设备驱动层实例（Synaptics）"></a>（七）、Input 设备驱动层实例（Synaptics）</h2><p>触摸屏也是用上面这一套框架来操作的。右边需要一个”evdev.c”文件。左边要分配一个”input_dev”结构。接着就看上图的硬件设备左边的过程：分配一个”input_dev”结构体 –&gt; 设置这个”input_dev”结构体 –&gt; 注册这个”input_dev”结构体 –&gt; 硬件相关的操作。<br><img src="https://raw.githubusercontent.com/izhoujinjian/zhoujinjian.cc/master/linux.input/08-Linux-kernel-input-drivers-fw.png" alt="Markdown"></p><p>编写Input驱动一般框架:</p><p>Google Pixel、Pixel XL 触控驱动模块型号为Synaptics（ClearPad S3708），源码：<a href="https://github.com/matthewdalex/marlin/tree/2f567606935d601f1391ad9575b103f35737a438/drivers/input/touchscreen/synaptics_dsx_htc_2.6" target="_blank" rel="noopener">Synaptics 触摸屏驱动源码</a></p><p>Makefile：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;drivers/input/touchscreen/synaptics_dsx_htc_2<span class="number">.6</span>/Makefile]</span><br><span class="line">#</span><br><span class="line"># Makefile <span class="keyword">for</span> the Synaptics DSX touchscreen driver.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line"># Each configuration option enables a <span class="built_in">list</span> of files.</span><br><span class="line"></span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_I2C_HTC_v26) += synaptics_dsx_i2c.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_SPI_HTC_v26) += synaptics_dsx_spi.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_CORE_HTC_v26) += synaptics_dsx_core.o</span><br><span class="line">obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_DSX_RMI_DEV_HTC_v26) += synaptics_dsx_rmi_dev.o</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>抓取kernel log：可知input 驱动名为synaptics_dsxv26，全局搜索可知synaptics_rmi4_f12_init在[-&gt;synaptics_dsx_core.c]中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[    <span class="number">1.362728</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init: Function <span class="number">12</span> max x = <span class="number">1079</span> max y = <span class="number">1919</span> Rx: <span class="number">16</span> Tx: <span class="number">28</span></span><br><span class="line">[    <span class="number">1.363344</span>] c3      <span class="number">1</span> [TP]synaptics_rmi4_f12_init:Wakeup Gesture range (<span class="number">0</span>,<span class="number">0</span>) -&gt; (<span class="number">1079</span>,<span class="number">1919</span>)</span><br><span class="line">[    <span class="number">1.363623</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_f12_init report data init done</span><br><span class="line">[    <span class="number">1.371945</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: chip_id:<span class="number">3708</span>, firmware_id:<span class="number">2433782</span></span><br><span class="line">[    <span class="number">1.372865</span>] c3      <span class="number">1</span> [TP]:synaptics_rmi4_query_device: config_version: <span class="number">5331763200190000000000000000000000000000000000000000000000000000</span></span><br><span class="line">[    <span class="number">1.373249</span>] c3      <span class="number">1</span> input: synaptics_dsxv26 as /devices/soc/<span class="number">7577000.</span>i2c/i2c<span class="number">-3</span>/<span class="number">3</span><span class="number">-0020</span>/input/input3</span><br></pre></td></tr></table></figure><p>查看input设备：adb shell cat /proc/bus/input/devices</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">I: Bus=0000 Vendor=0000 Product=0003 Version=2066</span><br><span class="line">N: Name=&quot;synaptics_dsxv26&quot;</span><br><span class="line">P: Phys=synaptics_dsx/touch_input</span><br><span class="line">S: Sysfs=/devices/soc/7577000.i2c/i2c-3/3-0020/input/input3</span><br><span class="line">U: Uniq=</span><br><span class="line">H: Handlers=mdss_fb kgsl event3</span><br><span class="line">B: PROP=2</span><br><span class="line">B: EV=b</span><br><span class="line">B: KEY=8000 0 0</span><br><span class="line">B: ABS=663800000000000</span><br><span class="line"></span><br><span class="line">对应：/dev/input/event3</span><br></pre></td></tr></table></figure><h2 id="7-1、分配Input-dev结构体"><a href="#7-1、分配Input-dev结构体" class="headerlink" title="7.1、分配Input_dev结构体"></a>7.1、分配Input_dev结构体</h2><h2 id="7-1-1、synaptics-rmi4-f12-init"><a href="#7-1-1、synaptics-rmi4-f12-init" class="headerlink" title="7.1.1、synaptics_rmi4_f12_init()"></a>7.1.1、synaptics_rmi4_f12_init()</h2><p>首先看一下初始化过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">synaptics_rmi4_driver</span> = &#123;</span></span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name = PLATFORM_DRIVER_NAME,</span><br><span class="line">        .owner = THIS_MODULE,</span><br><span class="line">#ifdef CONFIG_PM</span><br><span class="line">        .pm = &amp;synaptics_rmi4_dev_pm_ops,</span><br><span class="line">#endif</span><br><span class="line">    &#125;,</span><br><span class="line">    .probe = synaptics_rmi4_probe,</span><br><span class="line">    .remove = synaptics_rmi4_remove,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">synaptics_rmi4_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_bus_init();</span><br><span class="line">    <span class="keyword">if</span> (retval)</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> platform_driver_register(&amp;synaptics_rmi4_driver);</span><br><span class="line">&#125;</span><br><span class="line">module_init(synaptics_rmi4_init);</span><br></pre></td></tr></table></figure><p>首先注册平台驱动，当驱动和设备匹配成功，继续看一下synaptics_rmi4_probe()函数</p><h2 id="7-1-2、synaptics-rmi4-probe"><a href="#7-1-2、synaptics-rmi4-probe" class="headerlink" title="7.1.2、synaptics_rmi4_probe()"></a>7.1.2、synaptics_rmi4_probe()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_probe</span><span class="params">(struct platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval, len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> attr_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_hw_interface</span> *<span class="title">hw_if</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">temp</span>;</span></span><br><span class="line">    <span class="comment">//初始化platform_data、board_data、rmi4_data</span></span><br><span class="line">    hw_if = pdev-&gt;dev.platform_data;</span><br><span class="line">    bdata = hw_if-&gt;board_data;</span><br><span class="line">    rmi4_data = kzalloc(<span class="keyword">sizeof</span>(*rmi4_data), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;pdev = pdev;</span><br><span class="line">    rmi4_data-&gt;current_page = MASK_8BIT;</span><br><span class="line">    rmi4_data-&gt;hw_if = hw_if;</span><br><span class="line">    rmi4_data-&gt;touch_stopped = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;sensor_sleep = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;irq_enabled = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fw_updating = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">    rmi4_data-&gt;update_coords = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;write_buf = devm_kzalloc(&amp;pdev-&gt;dev, I2C_WRITE_BUF_MAX_LEN,</span><br><span class="line">                    GFP_KERNEL);</span><br><span class="line">    rmi4_data-&gt;write_buf_len = I2C_WRITE_BUF_MAX_LEN;</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq_enable = synaptics_rmi4_irq_enable;</span><br><span class="line">    rmi4_data-&gt;reset_device = synaptics_rmi4_reset_device;</span><br><span class="line"></span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_io_ctrl_mutex));</span><br><span class="line">    mutex_init(&amp;(rmi4_data-&gt;rmi4_reset_mutex));</span><br><span class="line"></span><br><span class="line">    retval = synaptics_dsx_regulator_configure(rmi4_data);</span><br><span class="line">    retval = synaptics_dsx_regulator_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    platform_set_drvdata(pdev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;gpio_config) &#123;</span><br><span class="line">        retval = synaptics_rmi4_set_gpio(rmi4_data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        retval = synaptics_dsx_pinctrl_init(rmi4_data);</span><br><span class="line">        <span class="keyword">if</span> (!retval &amp;&amp; rmi4_data-&gt;ts_pinctrl) &#123;</span><br><span class="line">            retval = pinctrl_select_state(rmi4_data-&gt;ts_pinctrl,</span><br><span class="line">                    rmi4_data-&gt;pinctrl_state_active);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        retval = synaptics_dsx_gpio_configure(rmi4_data, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bdata-&gt;fw_name) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(bdata-&gt;fw_name);</span><br><span class="line"></span><br><span class="line">        strlcpy(rmi4_data-&gt;fw_name, bdata-&gt;fw_name, len + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分配Input_dev结构体，设置，注册</span></span><br><span class="line">    retval = synaptics_rmi4_set_input_dev(rmi4_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;irq = gpio_to_irq(bdata-&gt;irq_gpio);</span><br><span class="line">    <span class="comment">//请求中断，并设置中断处理函数synaptics_rmi4_irq</span></span><br><span class="line">    retval = synaptics_rmi4_irq_enable(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!exp_data.initialized) &#123;</span><br><span class="line">        mutex_init(&amp;exp_data.mutex);</span><br><span class="line">        INIT_LIST_HEAD(&amp;exp_data.<span class="built_in">list</span>);</span><br><span class="line">        exp_data.initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exp_data.workqueue = create_singlethread_workqueue(<span class="string">"dsx_exp_workqueue"</span>);</span><br><span class="line">    INIT_DELAYED_WORK(&amp;exp_data.work, synaptics_rmi4_exp_fn_work);</span><br><span class="line">    exp_data.rmi4_data = rmi4_data;</span><br><span class="line">    exp_data.queue_work = <span class="literal">true</span>;</span><br><span class="line">    queue_delayed_work(exp_data.workqueue,</span><br><span class="line">            &amp;exp_data.work,</span><br><span class="line">            msecs_to_jiffies(EXP_FN_WORK_DELAY_MS));</span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;dir = debugfs_create_dir(DEBUGFS_DIR_NAME, <span class="literal">NULL</span>);</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (attr_count = <span class="number">0</span>; attr_count &lt; ARRAY_SIZE(attrs); attr_count++) &#123;</span><br><span class="line">        retval = sysfs_create_file(&amp;rmi4_data-&gt;input_dev-&gt;dev.kobj,</span><br><span class="line">                &amp;attrs[attr_count].attr);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    synaptics_secure_touch_init(rmi4_data);</span><br><span class="line">    synaptics_secure_touch_stop(rmi4_data, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-3、分配Input-dev结构体"><a href="#7-1-3、分配Input-dev结构体" class="headerlink" title="7.1.3、分配Input_dev结构体"></a>7.1.3、分配Input_dev结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……"><a href="#7-2、设置支持事件类型-set-bit-EV-SYN-evbit-、set-bit-EV-KEY-evbit-、set-bit-EV-ABS-evbit-……" class="headerlink" title="7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……"></a>7.2、设置支持事件类型 set_bit(EV_SYN, evbit)、set_bit(EV_KEY, evbit)、set_bit(EV_ABS,evbit) ……</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME "synaptics_dsxv26"(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-3、注册设备input-register-device"><a href="#7-3、注册设备input-register-device" class="headerlink" title="7.3、注册设备input_register_device()"></a>7.3、注册设备input_register_device()</h2><p>此处即与前面kernel log呼应：注册名为 synaptics_dsxv26 的输入设备</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_set_input_dev</span><span class="params">(struct synaptics_rmi4_data *rmi4_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">                <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev = input_allocate_device();</span><br><span class="line">    ......</span><br><span class="line">    retval = synaptics_rmi4_query_device(rmi4_data);</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">//#define PLATFORM_DRIVER_NAME "synaptics_dsxv26"(synaptics_dsx_v2_6.h)</span></span><br><span class="line"></span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;name = PLATFORM_DRIVER_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;phys = INPUT_PHYS_NAME;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.product = SYNAPTICS_DSX_DRIVER_PRODUCT;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;id.version = SYNAPTICS_DSX_DRIVER_VERSION;</span><br><span class="line">    rmi4_data-&gt;input_dev-&gt;dev.parent = rmi4_data-&gt;pdev-&gt;dev.parent;</span><br><span class="line">    input_set_drvdata(rmi4_data-&gt;input_dev, rmi4_data);</span><br><span class="line"></span><br><span class="line">    set_bit(EV_SYN, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_KEY, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(EV_ABS, rmi4_data-&gt;input_dev-&gt;evbit);</span><br><span class="line">    set_bit(BTN_TOUCH, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line">    set_bit(BTN_TOOL_FINGER, rmi4_data-&gt;input_dev-&gt;keybit);</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_set_params(rmi4_data);</span><br><span class="line">    ......</span><br><span class="line">    retval = input_register_device(rmi4_data-&gt;input_dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4、硬件相关操作"><a href="#7-4、硬件相关操作" class="headerlink" title="7.4、硬件相关操作"></a>7.4、硬件相关操作</h2><p>当触摸屏按下，会产生中断，进而调用中断处理函数synaptics_rmi4_irq():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> irqreturn_t <span class="title">synaptics_rmi4_irq</span><span class="params">(<span class="keyword">int</span> irq, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_data</span> *<span class="title">rmi4_data</span> = <span class="title">data</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_dsx_board_data</span> *<span class="title">bdata</span> =</span></span><br><span class="line"><span class="class">            <span class="title">rmi4_data</span>-&gt;<span class="title">hw_if</span>-&gt;<span class="title">board_data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IRQ_HANDLED == synaptics_filter_interrupt(data))</span><br><span class="line">        <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gpio_get_value(bdata-&gt;irq_gpio) != bdata-&gt;irq_on_state)</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">exit</span>;</span><br><span class="line"></span><br><span class="line">    synaptics_rmi4_sensor_report(rmi4_data, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步调用synaptics_rmi4_sensor_report(rmi4_data, true)处理数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_sensor_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> report)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[MAX_INTR_REGISTERS + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *intr = &amp;data[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> was_in_bl_mode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f01_device_status</span> <span class="title">status</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_fn</span> *<span class="title">fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_exp_fhandler</span> *<span class="title">exp_fhandler</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_device_info</span> *<span class="title">rmi</span>;</span></span><br><span class="line"></span><br><span class="line">    rmi = &amp;(rmi4_data-&gt;rmi4_mod_info);</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">            data,</span><br><span class="line">            rmi4_data-&gt;num_of_intr_regs + <span class="number">1</span>);</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//读取寄存器数据</span></span><br><span class="line">    status.data[<span class="number">0</span>] = data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (status.status_code == STATUS_CRC_IN_PROGRESS) &#123;</span><br><span class="line">        retval = synaptics_rmi4_check_status(rmi4_data,</span><br><span class="line">                &amp;was_in_bl_mode);</span><br><span class="line">        ....</span><br><span class="line">        retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">                rmi4_data-&gt;f01_data_base_addr,</span><br><span class="line">                status.data,</span><br><span class="line">                <span class="keyword">sizeof</span>(status.data));</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (status.unconfigured &amp;&amp; !status.flash_prog) &#123;</span><br><span class="line">        pr_notice(<span class="string">"%s: spontaneous reset detected\n"</span>, __func__);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//synaptics_rmi4_report_touch()上报数据</span></span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;rmi-&gt;support_fn_list)) &#123;</span><br><span class="line">        list_for_each_entry(fhandler, &amp;rmi-&gt;support_fn_list, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fhandler-&gt;num_of_data_sources) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fhandler-&gt;intr_mask &amp;</span><br><span class="line">                        intr[fhandler-&gt;intr_reg_num]) &#123;</span><br><span class="line">                    synaptics_rmi4_report_touch(rmi4_data,</span><br><span class="line">                            fhandler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;exp_data.mutex);</span><br><span class="line">    <span class="keyword">if</span> (!list_empty(&amp;exp_data.<span class="built_in">list</span>)) &#123;</span><br><span class="line">        list_for_each_entry(exp_fhandler, &amp;exp_data.<span class="built_in">list</span>, link) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!exp_fhandler-&gt;insert &amp;&amp;</span><br><span class="line">                    !exp_fhandler-&gt;remove &amp;&amp;</span><br><span class="line">                    (exp_fhandler-&gt;exp_fn-&gt;attn != <span class="literal">NULL</span>))</span><br><span class="line">                exp_fhandler-&gt;exp_fn-&gt;attn(rmi4_data, intr[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;exp_data.mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-4-1、Input数据上报："><a href="#7-4-1、Input数据上报：" class="headerlink" title="7.4.1、Input数据上报："></a>7.4.1、Input数据上报：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">[-&gt;synaptics_dsx_core.c]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synaptics_rmi4_report_touch</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">switch</span> (fhandler-&gt;fn_number) &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">case</span> SYNAPTICS_RMI4_F12:</span><br><span class="line">        touch_count_2d = synaptics_rmi4_f12_abs_report(rmi4_data,</span><br><span class="line">                fhandler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (touch_count_2d)</span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rmi4_data-&gt;fingers_on_2d = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">synaptics_rmi4_f12_abs_report</span><span class="params">(struct synaptics_rmi4_data *rmi4_data,</span></span></span><br><span class="line"><span class="function"><span class="params">        struct synaptics_rmi4_fn *fhandler)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> touch_count = <span class="number">0</span>; <span class="comment">/* number of touch points */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> index;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> fingers_to_process;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_status;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> size_of_2d_data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> gesture_type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> data_addr;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">int</span> wx;</span><br><span class="line">    <span class="keyword">int</span> wy;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_extra_data</span> *<span class="title">extra_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">synaptics_rmi4_f12_finger_data</span> *<span class="title">finger_data</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> finger_presence;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> stylus_presence;</span><br><span class="line"></span><br><span class="line">    fingers_to_process = fhandler-&gt;num_of_data_points;</span><br><span class="line">    data_addr = fhandler-&gt;full_addr.data_base;</span><br><span class="line">    extra_data = (struct synaptics_rmi4_f12_extra_data *)fhandler-&gt;extra;</span><br><span class="line">    size_of_2d_data = <span class="keyword">sizeof</span>(struct synaptics_rmi4_f12_finger_data);</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    retval = synaptics_rmi4_reg_read(rmi4_data,</span><br><span class="line">            data_addr + extra_data-&gt;data1_offset,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)fhandler-&gt;data,</span><br><span class="line">            fingers_to_process * size_of_2d_data);</span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    data = (struct synaptics_rmi4_f12_finger_data *)fhandler-&gt;data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line">    <span class="comment">//根据触摸点数量循环上报input数据</span></span><br><span class="line">    <span class="keyword">for</span> (finger = <span class="number">0</span>; finger &lt; fingers_to_process; finger++) &#123;</span><br><span class="line">        finger_data = data + finger;</span><br><span class="line">        finger_status = finger_data-&gt;object_type_and_status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        x = (finger_data-&gt;x_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;x_lsb);</span><br><span class="line">        y = (finger_data-&gt;y_msb &lt;&lt; <span class="number">8</span>) | (finger_data-&gt;y_lsb);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;swap_axes) &#123;</span><br><span class="line">            temp = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = temp;</span><br><span class="line">            temp = wx;</span><br><span class="line">            wx = wy;</span><br><span class="line">            wy = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;x_flip)</span><br><span class="line">            x = rmi4_data-&gt;sensor_max_x - x;</span><br><span class="line">        <span class="keyword">if</span> (rmi4_data-&gt;hw_if-&gt;board_data-&gt;y_flip)</span><br><span class="line">            y = rmi4_data-&gt;sensor_max_y - y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (finger_status) &#123;</span><br><span class="line">        <span class="keyword">case</span> F12_FINGER_STATUS:</span><br><span class="line">        <span class="keyword">case</span> F12_GLOVED_FINGER_STATUS:</span><br><span class="line"></span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOUCH, <span class="number">1</span>);</span><br><span class="line">            input_report_key(rmi4_data-&gt;input_dev,</span><br><span class="line">                    BTN_TOOL_FINGER, <span class="number">1</span>);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_X, x);</span><br><span class="line">            input_report_abs(rmi4_data-&gt;input_dev,</span><br><span class="line">                    ABS_MT_POSITION_Y, y);</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    input_sync(rmi4_data-&gt;input_dev);</span><br><span class="line"></span><br><span class="line">    mutex_unlock(&amp;(rmi4_data-&gt;rmi4_report_mutex));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> touch_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用input_report_key()、input_report_abs()、input_sync() 上报、同步数据。</p><h2 id="（八）、参考文档-特别感谢各位前辈的分析和图示-："><a href="#（八）、参考文档-特别感谢各位前辈的分析和图示-：" class="headerlink" title="（八）、参考文档(特别感谢各位前辈的分析和图示)："></a>（八）、参考文档(特别感谢各位前辈的分析和图示)：</h2><p><a href="https://blog.csdn.net/column/details/input.html" target="_blank" rel="noopener">Linux/Android—-Input系统</a><br><a href="https://blog.csdn.net/tiantangniaochao/article/details/50497353" target="_blank" rel="noopener">Android Input子系统浅谈</a><br><a href="http://huaqianlee.github.io/2017/11/23/Android/Android-Linux-input-system-analysis/" target="_blank" rel="noopener">Android(Linux) 输入子系统解析</a><br><a href="http://www.cnblogs.com/jason-lu/p/3156411.html" target="_blank" rel="noopener">input子系统分析之三:驱动模块</a><br><a href="https://blog.csdn.net/fanwenjieok/article/details/38503027" target="_blank" rel="noopener">Linux驱动框架之—-Input子系统</a><br><a href="https://www.zybuluo.com/zifehng/note/718523" target="_blank" rel="noopener">input子系统事件处理层(evdev)的环形缓冲区</a><br><a href="https://blog.csdn.net/ielife/article/details/7814108" target="_blank" rel="noopener">linux input输入子系统分析《四》：input子系统整体流程全面分析</a><br><a href="https://blog.csdn.net/yueqian_scut/article/details/48792939" target="_blank" rel="noopener">Linux input子系统分析之二：深入剖析input_handler、input_core、input_device</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/izhoujinjian/zhoujinjian.cc/tree/master/linux.input&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【博客原图链接】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码（部分
      
    
    </summary>
    
      <category term="Android" scheme="http://zhoujinjian.cc/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhoujinjian.cc/tags/Android/"/>
    
  </entry>
  
</feed>
